{"sha": "f9621cc4774d44166dc6e25228a1d86f14aaaca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2MjFjYzQ3NzRkNDQxNjZkYzZlMjUyMjhhMWQ4NmYxNGFhYWNhNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-04T22:14:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-04T22:14:56Z"}, "message": "gcc/\n\t* optabs.h (reload_in_optab, reload_out_optab, code_to_optab)\n\t(vcond_gen_code, vcondu_gen_code, movmem_optab, setmem_optab)\n\t(cmpstr_optab, cmpstrn_optab, cmpmem_optab, sync_add_optab)\n\t(sync_sub_optab, sync_ior_optab, sync_and_optab, sync_xor_optab)\n\t(sync_nand_optab, sync_old_add_optab, sync_old_sub_optab)\n\t(sync_old_ior_optab, sync_old_and_optab, sync_old_xor_optab)\n\t(sync_old_nand_optab, sync_new_add_optab, sync_new_sub_optab)\n\t(sync_new_ior_optab, sync_new_and_optab, sync_new_xor_optab)\n\t(sync_new_nand_optab): Redefine as macros.\n\t(sync_compare_and_swap, sync_lock_test_and_set, sync_lock_release):\n\tDelete.\n\t(direct_optab_index): New enum.\n\t(direct_optab_d): New structure.\n\t(direct_optab): New typedef.\n\t(direct_optab_table): Declare.\n\t(direct_optab_handler, set_direct_optab_handler): New functions.\n\t(sync_compare_and_swap_optab, sync_lock_test_and_set_optab)\n\t(sync_lock_release_optab): New macros.\n\t* optabs.c (direct_optab_table): New variable.\n\t(movcc_gen_code, vcond_gen_code, vcondu_gen_code): Delete.\n\t(prepare_cmp_insn): Use direct_optab_handler for cmpmem_optab,\n\tcmpstr_optab and cmpstrn_optab.\n\t(emit_conditional_move): Likewise for movcc_optab.\n\t(can_conditionally_move_p): Likewise for movcc_gen_code.\n\t(init_insn_codes): Clear direct_optab_table.\n\t(init_optabs): Don't initialize the new \"direct optabs\" here.\n\t(get_vcond_icode): Use direct_optab_handler for vcondu_gen_code and\n\tvcond_gen_code.\n\t(expand_val_compare_and_swap): Likewise sync_compare_and_swap_optab.\n\t(expand_bool_compare_and_swap): Likewise sync_compare_and_swap_optab.\n\t(expand_compare_and_swap_loop): Likewise sync_compare_and_swap_optab.\n\t(expand_sync_operation): Likewise other sync_*_optabs.\n\t(expand_sync_fetch_operation): Likewise.  Rename sync_compare_and_swap\n\tto sync_compare_and_swap_optab.\n\t(expand_sync_lock_test_and_set): Use direct_optab_handler for\n\tsync_lock_test_and_set and sync_compare_and_swap, adding \"_optab\"\n\tto the names of both.\n\t* builtins.c (expand_builtin_strcmp): Use direct_optab_handler for\n\tcmpstr_optab and cmpstrn_optab.\n\t(expand_builtin_lock_release): Likewise sync_lock_release.\n\t* expr.c (movmem_optab, setmem_optab, cmpstr_optab, cmpstrn_optab)\n\t(cmpmem_optab, sync_add_optab, sync_sub_optab, sync_ior_optab)\n\t(sync_and_optab, sync_xor_optab, sync_nand_optab, sync_old_add_optab)\n\t(sync_old_sub_optab, sync_old_ior_optab, sync_old_and_optab)\n\t(sync_old_xor_optab, sync_old_nand_optab, sync_new_add_optab)\n\t(sync_new_sub_optab, sync_new_ior_optab, sync_new_and_optab)\n\t(sync_new_xor_optab, sync_new_nand_optab, sync_compare_and_swap)\n\t(sync_lock_test_and_set, sync_lock_release): Delete.\n\t(emit_block_move_via_movmem): Use direct_optab_handler for movmem_optab.\n\t(emit_block_move_via_setmem): Use direct_optab_handler for setmem_optab.\n\t* genopinit.c (optabs): Use set_direct_optab_handler for the new\n\tmacro optabs.\n\t* omp-low.c (expand_omp_atomic_fetch_op): Update the type of\n\tthe \"optab\" local variable.  Use direct_optab_handler for optab and\n\tsync_compare_and_swap_optab.\n\t* reload1.c (reload_in_optab, reload_out_optab): Delete.\n\t* targhooks.c (default_secondary_reload): Use direct_optab_handler for\n\treload_in_optab and reload_out_optab.\n\t* config/alpha/alpha.c (alpha_secondary_reload): Likewise.\n\t* config/frv/frv.c (frv_alloc_temp_reg): Likewise.\n\t* config/pa/pa.c (pa_secondary_reload): Likewise.\n\t* java/builtins.c (compareAndSwapInt_builtin): Use direct_optab_handler\n\tfor sync_compare_and_swap, renaming it to sync_compare_and_swap_optab.\n\t(compareAndSwapLong_builtin, compareAndSwapObject_builtin): Likewise.\n\t(VMSupportsCS8_builtin): Likewise.\n\nFrom-SVN: r161810", "tree": {"sha": "a30ef11d74c7da9ce0ee003131a81a63259e96d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a30ef11d74c7da9ce0ee003131a81a63259e96d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9621cc4774d44166dc6e25228a1d86f14aaaca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9621cc4774d44166dc6e25228a1d86f14aaaca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9621cc4774d44166dc6e25228a1d86f14aaaca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9621cc4774d44166dc6e25228a1d86f14aaaca6/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "596455ce057d68deec9e7a3e308a10364c2d4498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596455ce057d68deec9e7a3e308a10364c2d4498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/596455ce057d68deec9e7a3e308a10364c2d4498"}], "stats": {"total": 561, "additions": 308, "deletions": 253}, "files": [{"sha": "fca47ae36f91f3d44d97249b6c1db307f9d91697", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -1,3 +1,71 @@\n+2010-07-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* optabs.h (reload_in_optab, reload_out_optab, code_to_optab)\n+\t(vcond_gen_code, vcondu_gen_code, movmem_optab, setmem_optab)\n+\t(cmpstr_optab, cmpstrn_optab, cmpmem_optab, sync_add_optab)\n+\t(sync_sub_optab, sync_ior_optab, sync_and_optab, sync_xor_optab)\n+\t(sync_nand_optab, sync_old_add_optab, sync_old_sub_optab)\n+\t(sync_old_ior_optab, sync_old_and_optab, sync_old_xor_optab)\n+\t(sync_old_nand_optab, sync_new_add_optab, sync_new_sub_optab)\n+\t(sync_new_ior_optab, sync_new_and_optab, sync_new_xor_optab)\n+\t(sync_new_nand_optab): Redefine as macros.\n+\t(sync_compare_and_swap, sync_lock_test_and_set, sync_lock_release):\n+\tDelete.\n+\t(direct_optab_index): New enum.\n+\t(direct_optab_d): New structure.\n+\t(direct_optab): New typedef.\n+\t(direct_optab_table): Declare.\n+\t(direct_optab_handler, set_direct_optab_handler): New functions.\n+\t(sync_compare_and_swap_optab, sync_lock_test_and_set_optab)\n+\t(sync_lock_release_optab): New macros.\n+\t* optabs.c (direct_optab_table): New variable.\n+\t(movcc_gen_code, vcond_gen_code, vcondu_gen_code): Delete.\n+\t(prepare_cmp_insn): Use direct_optab_handler for cmpmem_optab,\n+\tcmpstr_optab and cmpstrn_optab.\n+\t(emit_conditional_move): Likewise for movcc_optab.\n+\t(can_conditionally_move_p): Likewise for movcc_gen_code.\n+\t(init_insn_codes): Clear direct_optab_table.\n+\t(init_optabs): Don't initialize the new \"direct optabs\" here.\n+\t(get_vcond_icode): Use direct_optab_handler for vcondu_gen_code and\n+\tvcond_gen_code.\n+\t(expand_val_compare_and_swap): Likewise sync_compare_and_swap_optab.\n+\t(expand_bool_compare_and_swap): Likewise sync_compare_and_swap_optab.\n+\t(expand_compare_and_swap_loop): Likewise sync_compare_and_swap_optab.\n+\t(expand_sync_operation): Likewise other sync_*_optabs.\n+\t(expand_sync_fetch_operation): Likewise.  Rename sync_compare_and_swap\n+\tto sync_compare_and_swap_optab.\n+\t(expand_sync_lock_test_and_set): Use direct_optab_handler for\n+\tsync_lock_test_and_set and sync_compare_and_swap, adding \"_optab\"\n+\tto the names of both.\n+\t* builtins.c (expand_builtin_strcmp): Use direct_optab_handler for\n+\tcmpstr_optab and cmpstrn_optab.\n+\t(expand_builtin_lock_release): Likewise sync_lock_release.\n+\t* expr.c (movmem_optab, setmem_optab, cmpstr_optab, cmpstrn_optab)\n+\t(cmpmem_optab, sync_add_optab, sync_sub_optab, sync_ior_optab)\n+\t(sync_and_optab, sync_xor_optab, sync_nand_optab, sync_old_add_optab)\n+\t(sync_old_sub_optab, sync_old_ior_optab, sync_old_and_optab)\n+\t(sync_old_xor_optab, sync_old_nand_optab, sync_new_add_optab)\n+\t(sync_new_sub_optab, sync_new_ior_optab, sync_new_and_optab)\n+\t(sync_new_xor_optab, sync_new_nand_optab, sync_compare_and_swap)\n+\t(sync_lock_test_and_set, sync_lock_release): Delete.\n+\t(emit_block_move_via_movmem): Use direct_optab_handler for movmem_optab.\n+\t(emit_block_move_via_setmem): Use direct_optab_handler for setmem_optab.\n+\t* genopinit.c (optabs): Use set_direct_optab_handler for the new\n+\tmacro optabs.\n+\t* omp-low.c (expand_omp_atomic_fetch_op): Update the type of\n+\tthe \"optab\" local variable.  Use direct_optab_handler for optab and\n+\tsync_compare_and_swap_optab.\n+\t* reload1.c (reload_in_optab, reload_out_optab): Delete.\n+\t* targhooks.c (default_secondary_reload): Use direct_optab_handler for\n+\treload_in_optab and reload_out_optab.\n+\t* config/alpha/alpha.c (alpha_secondary_reload): Likewise.\n+\t* config/frv/frv.c (frv_alloc_temp_reg): Likewise.\n+\t* config/pa/pa.c (pa_secondary_reload): Likewise.\n+\t* java/builtins.c (compareAndSwapInt_builtin): Use direct_optab_handler\n+\tfor sync_compare_and_swap, renaming it to sync_compare_and_swap_optab.\n+\t(compareAndSwapLong_builtin, compareAndSwapObject_builtin): Likewise.\n+\t(VMSupportsCS8_builtin): Likewise.\n+\n 2010-07-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* optabs.h (optab_handlers): Change type of insn_code to int."}, {"sha": "8598becd8c9da179d9d092aee6e324835680df86", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -4109,8 +4109,8 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n     return NULL_RTX;\n \n #if defined HAVE_cmpstrsi || defined HAVE_cmpstrnsi\n-  if (cmpstr_optab[SImode] != CODE_FOR_nothing\n-      || cmpstrn_optab[SImode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (cmpstr_optab, SImode) != CODE_FOR_nothing\n+      || direct_optab_handler (cmpstrn_optab, SImode) != CODE_FOR_nothing)\n     {\n       rtx arg1_rtx, arg2_rtx;\n       rtx result, insn = NULL_RTX;\n@@ -5677,7 +5677,7 @@ expand_builtin_lock_release (enum machine_mode mode, tree exp)\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n \n   /* If there is an explicit operation in the md file, use it.  */\n-  icode = sync_lock_release[mode];\n+  icode = direct_optab_handler (sync_lock_release_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       if (!insn_data[icode].operand[1].predicate (val, mode))"}, {"sha": "92647f1a373cb169f4e6b95bec572b7088b54bbc", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -1584,10 +1584,10 @@ alpha_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t  if (in_p)\n \t    {\n \t      if (!aligned_memory_operand (x, mode))\n-\t\tsri->icode = reload_in_optab[mode];\n+\t\tsri->icode = direct_optab_handler (reload_in_optab, mode);\n \t    }\n \t  else\n-\t    sri->icode = reload_out_optab[mode];\n+\t    sri->icode = direct_optab_handler (reload_out_optab, mode);\n \t  return NO_REGS;\n \t}\n     }"}, {"sha": "25f149c7b4ec32e9354143dc3b7e8e174d833e30", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -6510,8 +6510,9 @@ frv_secondary_reload (bool in_p, rtx x, reg_class_t reload_class_i,\n \n   if (rclass != NO_REGS)\n     {\n-      enum insn_code icode = (in_p ? reload_in_optab[(int) reload_mode]\n-\t\t\t      : reload_out_optab[(int) reload_mode]);\n+      enum insn_code icode\n+\t= direct_optab_handler (in_p ? reload_in_optab : reload_out_optab,\n+\t\t\t\treload_mode);\n       if (icode == 0)\n \t{\n \t  /* This happens when then the reload_[in|out]_optabs have"}, {"sha": "863b154c377e3482fe9d10c7bac2b623750067f9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -5767,15 +5767,19 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       /* Request a secondary reload with a general scratch register\n \t for everthing else.  ??? Could symbolic operands be handled\n \t directly when generating non-pic PA 2.0 code?  */\n-      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      sri->icode = (in_p\n+\t\t    ? direct_optab_handler (reload_in_optab, mode)\n+\t\t    : direct_optab_handler (reload_out_optab, mode));\n       return NO_REGS;\n     }\n \n   /* We need a secondary register (GPR) for copies between the SAR\n      and anything other than a general register.  */\n   if (rclass == SHIFT_REGS && (regno <= 0 || regno >= 32))\n     {\n-      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      sri->icode = (in_p\n+\t\t    ? direct_optab_handler (reload_in_optab, mode)\n+\t\t    : direct_optab_handler (reload_out_optab, mode));\n       return NO_REGS;\n     }\n \n@@ -5785,7 +5789,9 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       && (REGNO_REG_CLASS (regno) == SHIFT_REGS\n       && FP_REG_CLASS_P (rclass)))\n     {\n-      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      sri->icode = (in_p\n+\t\t    ? direct_optab_handler (reload_in_optab, mode)\n+\t\t    : direct_optab_handler (reload_out_optab, mode));\n       return NO_REGS;\n     }\n "}, {"sha": "23baa63435b4d50db45efc2c04fab45b5b9d3350", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -201,41 +201,6 @@ static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n    < (unsigned int) MOVE_RATIO (optimize_insn_for_speed_p ()))\n #endif\n \n-/* This array records the insn_code of insns to perform block moves.  */\n-enum insn_code movmem_optab[NUM_MACHINE_MODES];\n-\n-/* This array records the insn_code of insns to perform block sets.  */\n-enum insn_code setmem_optab[NUM_MACHINE_MODES];\n-\n-/* These arrays record the insn_code of three different kinds of insns\n-   to perform block compares.  */\n-enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n-enum insn_code cmpstrn_optab[NUM_MACHINE_MODES];\n-enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n-\n-/* Synchronization primitives.  */\n-enum insn_code sync_add_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_sub_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_ior_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_and_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_xor_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_nand_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_add_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_sub_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_ior_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_and_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_xor_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_old_nand_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_add_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_sub_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_ior_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_and_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_xor_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_new_nand_optab[NUM_MACHINE_MODES];\n-enum insn_code sync_compare_and_swap[NUM_MACHINE_MODES];\n-enum insn_code sync_lock_test_and_set[NUM_MACHINE_MODES];\n-enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n-\n /* SLOW_UNALIGNED_ACCESS is nonzero if unaligned accesses are very slow.  */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n@@ -1315,7 +1280,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      enum insn_code code = movmem_optab[(int) mode];\n+      enum insn_code code = direct_optab_handler (movmem_optab, mode);\n       insn_operand_predicate_fn pred;\n \n       if (code != CODE_FOR_nothing\n@@ -2791,7 +2756,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      enum insn_code code = setmem_optab[(int) mode];\n+      enum insn_code code = direct_optab_handler (setmem_optab, mode);\n       insn_operand_predicate_fn pred;\n \n       if (code != CODE_FOR_nothing"}, {"sha": "6bc3c3526f6e65649b5696fa359fc4235e20670e", "filename": "gcc/genopinit.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -200,40 +200,40 @@ static const char * const optabs[] =\n   \"set_optab_handler (movmisalign_optab, $A, CODE_FOR_$(movmisalign$a$))\",\n   \"set_optab_handler (storent_optab, $A, CODE_FOR_$(storent$a$))\",\n   \"set_optab_handler (addcc_optab, $A, CODE_FOR_$(add$acc$))\",\n-  \"movcc_gen_code[$A] = CODE_FOR_$(mov$acc$)\",\n+  \"set_direct_optab_handler (movcc_optab, $A, CODE_FOR_$(mov$acc$))\",\n   \"set_optab_handler (cbranch_optab, $A, CODE_FOR_$(cbranch$a4$))\",\n   \"set_optab_handler (cmov_optab, $A, CODE_FOR_$(cmov$a6$))\",\n   \"set_optab_handler (cstore_optab, $A, CODE_FOR_$(cstore$a4$))\",\n   \"set_optab_handler (ctrap_optab, $A, CODE_FOR_$(ctrap$a4$))\",\n   \"set_optab_handler (push_optab, $A, CODE_FOR_$(push$a1$))\",\n-  \"reload_in_optab[$A] = CODE_FOR_$(reload_in$a$)\",\n-  \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n-  \"movmem_optab[$A] = CODE_FOR_$(movmem$a$)\",\n-  \"cmpstr_optab[$A] = CODE_FOR_$(cmpstr$a$)\",\n-  \"cmpstrn_optab[$A] = CODE_FOR_$(cmpstrn$a$)\",\n-  \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\",\n-  \"setmem_optab[$A] = CODE_FOR_$(setmem$a$)\",\n-  \"sync_add_optab[$A] = CODE_FOR_$(sync_add$I$a$)\",\n-  \"sync_sub_optab[$A] = CODE_FOR_$(sync_sub$I$a$)\",\n-  \"sync_ior_optab[$A] = CODE_FOR_$(sync_ior$I$a$)\",\n-  \"sync_and_optab[$A] = CODE_FOR_$(sync_and$I$a$)\",\n-  \"sync_xor_optab[$A] = CODE_FOR_$(sync_xor$I$a$)\",\n-  \"sync_nand_optab[$A] = CODE_FOR_$(sync_nand$I$a$)\",\n-  \"sync_old_add_optab[$A] = CODE_FOR_$(sync_old_add$I$a$)\",\n-  \"sync_old_sub_optab[$A] = CODE_FOR_$(sync_old_sub$I$a$)\",\n-  \"sync_old_ior_optab[$A] = CODE_FOR_$(sync_old_ior$I$a$)\",\n-  \"sync_old_and_optab[$A] = CODE_FOR_$(sync_old_and$I$a$)\",\n-  \"sync_old_xor_optab[$A] = CODE_FOR_$(sync_old_xor$I$a$)\",\n-  \"sync_old_nand_optab[$A] = CODE_FOR_$(sync_old_nand$I$a$)\",\n-  \"sync_new_add_optab[$A] = CODE_FOR_$(sync_new_add$I$a$)\",\n-  \"sync_new_sub_optab[$A] = CODE_FOR_$(sync_new_sub$I$a$)\",\n-  \"sync_new_ior_optab[$A] = CODE_FOR_$(sync_new_ior$I$a$)\",\n-  \"sync_new_and_optab[$A] = CODE_FOR_$(sync_new_and$I$a$)\",\n-  \"sync_new_xor_optab[$A] = CODE_FOR_$(sync_new_xor$I$a$)\",\n-  \"sync_new_nand_optab[$A] = CODE_FOR_$(sync_new_nand$I$a$)\",\n-  \"sync_compare_and_swap[$A] = CODE_FOR_$(sync_compare_and_swap$I$a$)\",\n-  \"sync_lock_test_and_set[$A] = CODE_FOR_$(sync_lock_test_and_set$I$a$)\",\n-  \"sync_lock_release[$A] = CODE_FOR_$(sync_lock_release$I$a$)\",\n+  \"set_direct_optab_handler (reload_in_optab, $A, CODE_FOR_$(reload_in$a$))\",\n+  \"set_direct_optab_handler (reload_out_optab, $A, CODE_FOR_$(reload_out$a$))\",\n+  \"set_direct_optab_handler (movmem_optab, $A, CODE_FOR_$(movmem$a$))\",\n+  \"set_direct_optab_handler (cmpstr_optab, $A, CODE_FOR_$(cmpstr$a$))\",\n+  \"set_direct_optab_handler (cmpstrn_optab, $A, CODE_FOR_$(cmpstrn$a$))\",\n+  \"set_direct_optab_handler (cmpmem_optab, $A, CODE_FOR_$(cmpmem$a$))\",\n+  \"set_direct_optab_handler (setmem_optab, $A, CODE_FOR_$(setmem$a$))\",\n+  \"set_direct_optab_handler (sync_add_optab, $A, CODE_FOR_$(sync_add$I$a$))\",\n+  \"set_direct_optab_handler (sync_sub_optab, $A, CODE_FOR_$(sync_sub$I$a$))\",\n+  \"set_direct_optab_handler (sync_ior_optab, $A, CODE_FOR_$(sync_ior$I$a$))\",\n+  \"set_direct_optab_handler (sync_and_optab, $A, CODE_FOR_$(sync_and$I$a$))\",\n+  \"set_direct_optab_handler (sync_xor_optab, $A, CODE_FOR_$(sync_xor$I$a$))\",\n+  \"set_direct_optab_handler (sync_nand_optab, $A, CODE_FOR_$(sync_nand$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_add_optab, $A, CODE_FOR_$(sync_old_add$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_sub_optab, $A, CODE_FOR_$(sync_old_sub$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_ior_optab, $A, CODE_FOR_$(sync_old_ior$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_and_optab, $A, CODE_FOR_$(sync_old_and$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_xor_optab, $A, CODE_FOR_$(sync_old_xor$I$a$))\",\n+  \"set_direct_optab_handler (sync_old_nand_optab, $A, CODE_FOR_$(sync_old_nand$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_add_optab, $A, CODE_FOR_$(sync_new_add$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_sub_optab, $A, CODE_FOR_$(sync_new_sub$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_ior_optab, $A, CODE_FOR_$(sync_new_ior$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_and_optab, $A, CODE_FOR_$(sync_new_and$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_xor_optab, $A, CODE_FOR_$(sync_new_xor$I$a$))\",\n+  \"set_direct_optab_handler (sync_new_nand_optab, $A, CODE_FOR_$(sync_new_nand$I$a$))\",\n+  \"set_direct_optab_handler (sync_compare_and_swap_optab, $A, CODE_FOR_$(sync_compare_and_swap$I$a$))\",\n+  \"set_direct_optab_handler (sync_lock_test_and_set_optab, $A, CODE_FOR_$(sync_lock_test_and_set$I$a$))\",\n+  \"set_direct_optab_handler (sync_lock_release_optab, $A, CODE_FOR_$(sync_lock_release$I$a$))\",\n   \"set_optab_handler (vec_set_optab, $A, CODE_FOR_$(vec_set$a$))\",\n   \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n   \"set_optab_handler (vec_extract_even_optab, $A, CODE_FOR_$(vec_extract_even$a$))\",\n@@ -244,8 +244,8 @@ static const char * const optabs[] =\n   \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n   \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\",\n   \"set_optab_handler (vec_realign_load_optab, $A, CODE_FOR_$(vec_realign_load_$a$))\",\n-  \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n-  \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n+  \"set_direct_optab_handler (vcond_optab, $A, CODE_FOR_$(vcond$a$))\",\n+  \"set_direct_optab_handler (vcondu_optab, $A, CODE_FOR_$(vcondu$a$))\",\n   \"set_optab_handler (ssum_widen_optab, $A, CODE_FOR_$(widen_ssum$I$a3$))\",\n   \"set_optab_handler (usum_widen_optab, $A, CODE_FOR_$(widen_usum$I$a3$))\",\n   \"set_optab_handler (udot_prod_optab, $A, CODE_FOR_$(udot_prod$I$a$))\","}, {"sha": "527c4e6fb9a5e7ad9df4baf43d5b38c2cf8ddfe8", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -323,7 +323,8 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t   tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (int_type_node);\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing\n       || flag_use_atomic_builtins)\n     {\n       tree addr, stmt;\n@@ -344,7 +345,8 @@ compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t    tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing\n       || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode)\n \t  && flag_use_atomic_builtins))\n     /* We don't trust flag_use_atomic_builtins for multi-word\n@@ -368,7 +370,8 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t      tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (ptr_type_node);\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing\n       || flag_use_atomic_builtins)\n   {\n     tree addr, stmt;\n@@ -448,7 +451,8 @@ VMSupportsCS8_builtin (tree method_return_type,\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n   gcc_assert (method_return_type == boolean_type_node);\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing)\n     return boolean_true_node;\n   else\n     return boolean_false_node;"}, {"sha": "eca27c8d023cd5285f61c25de92b8687e571e0a5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -4918,7 +4918,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n {\n   enum built_in_function base;\n   tree decl, itype, call;\n-  enum insn_code *optab;\n+  direct_optab optab;\n   tree rhs;\n   basic_block store_bb = single_succ (load_bb);\n   gimple_stmt_iterator gsi;\n@@ -4990,7 +4990,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   decl = built_in_decls[base + index + 1];\n   itype = TREE_TYPE (TREE_TYPE (decl));\n \n-  if (optab[TYPE_MODE (itype)] == CODE_FOR_nothing)\n+  if (direct_optab_handler (optab, TYPE_MODE (itype)) == CODE_FOR_nothing)\n     return false;\n \n   gsi = gsi_last_bb (load_bb);\n@@ -5042,7 +5042,8 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n   itype = TREE_TYPE (TREE_TYPE (cmpxchg));\n \n-  if (sync_compare_and_swap[TYPE_MODE (itype)] == CODE_FOR_nothing)\n+  if (direct_optab_handler (sync_compare_and_swap_optab, TYPE_MODE (itype))\n+      == CODE_FOR_nothing)\n     return false;\n \n   /* Load the initial value, replacing the GIMPLE_OMP_ATOMIC_LOAD.  */"}, {"sha": "1b1a8699eaaabc467dca0f04b2d4dd7d022070d9", "filename": "gcc/optabs.c", "status": "modified", "additions": 45, "deletions": 97, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -60,24 +60,13 @@ rtx libfunc_table[LTI_MAX];\n /* Tables of patterns for converting one mode to another.  */\n struct convert_optab_d convert_optab_table[COI_MAX];\n \n+/* Tables of patterns for direct optabs (i.e. those which cannot be\n+   implemented using a libcall).  */\n+struct direct_optab_d direct_optab_table[(int) DOI_MAX];\n+\n /* Contains the optab used for each rtx code.  */\n optab code_to_optab[NUM_RTX_CODE + 1];\n \n-#ifdef HAVE_conditional_move\n-/* Indexed by the machine mode, gives the insn code to make a conditional\n-   move insn.  This is not indexed by the rtx-code like bcc_gen_fctn and\n-   setcc_gen_code to cut down on the number of named patterns.  Consider a day\n-   when a lot more rtx codes are conditional (eg: for the ARM).  */\n-\n-enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n-#endif\n-\n-/* Indexed by the machine mode, gives the insn code for vector conditional\n-   operation.  */\n-\n-enum insn_code vcond_gen_code[NUM_MACHINE_MODES];\n-enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n-\n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   enum machine_mode *);\n static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n@@ -4071,11 +4060,11 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t   cmp_mode != VOIDmode;\n \t   cmp_mode = GET_MODE_WIDER_MODE (cmp_mode))\n \t{\n-\t  cmp_code = cmpmem_optab[cmp_mode];\n+\t  cmp_code = direct_optab_handler (cmpmem_optab, cmp_mode);\n \t  if (cmp_code == CODE_FOR_nothing)\n-\t    cmp_code = cmpstr_optab[cmp_mode];\n+\t    cmp_code = direct_optab_handler (cmpstr_optab, cmp_mode);\n \t  if (cmp_code == CODE_FOR_nothing)\n-\t    cmp_code = cmpstrn_optab[cmp_mode];\n+\t    cmp_code = direct_optab_handler (cmpstrn_optab, cmp_mode);\n \t  if (cmp_code == CODE_FOR_nothing)\n \t    continue;\n \n@@ -4520,7 +4509,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (mode == VOIDmode)\n     mode = GET_MODE (op2);\n \n-  icode = movcc_gen_code[mode];\n+  icode = direct_optab_handler (movcc_optab, mode);\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4593,7 +4582,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n int\n can_conditionally_move_p (enum machine_mode mode)\n {\n-  if (movcc_gen_code[mode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (movcc_optab, mode) != CODE_FOR_nothing)\n     return 1;\n \n   return 0;\n@@ -5439,6 +5428,7 @@ init_insn_codes (void)\n {\n   memset (optab_table, 0, sizeof (optab_table));\n   memset (convert_optab_table, 0, sizeof (convert_optab_table));\n+  memset (direct_optab_table, 0, sizeof (direct_optab_table));\n }\n \n /* Initialize OP's code to CODE, and write it into the code_to_optab table.  */\n@@ -6146,25 +6136,12 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n void\n init_optabs (void)\n {\n-  unsigned int i;\n   static bool reinit;\n \n   libfunc_hash = htab_create_ggc (10, hash_libfunc, eq_libfunc, NULL);\n-  /* Start by initializing all tables to contain CODE_FOR_nothing.  */\n-\n-#ifdef HAVE_conditional_move\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    movcc_gen_code[i] = CODE_FOR_nothing;\n-#endif\n-\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    {\n-      vcond_gen_code[i] = CODE_FOR_nothing;\n-      vcondu_gen_code[i] = CODE_FOR_nothing;\n-    }\n \n   /* We statically initialize the insn_codes with the equivalent of\n-     CODE_FOR_nothing.  */\n+     CODE_FOR_nothing.  Repeat the process if reinitialising.  */\n   if (reinit)\n     init_insn_codes ();\n \n@@ -6357,39 +6334,6 @@ init_optabs (void)\n   init_convert_optab (satfract_optab, SAT_FRACT);\n   init_convert_optab (satfractuns_optab, UNSIGNED_SAT_FRACT);\n \n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    {\n-      movmem_optab[i] = CODE_FOR_nothing;\n-      cmpstr_optab[i] = CODE_FOR_nothing;\n-      cmpstrn_optab[i] = CODE_FOR_nothing;\n-      cmpmem_optab[i] = CODE_FOR_nothing;\n-      setmem_optab[i] = CODE_FOR_nothing;\n-\n-      sync_add_optab[i] = CODE_FOR_nothing;\n-      sync_sub_optab[i] = CODE_FOR_nothing;\n-      sync_ior_optab[i] = CODE_FOR_nothing;\n-      sync_and_optab[i] = CODE_FOR_nothing;\n-      sync_xor_optab[i] = CODE_FOR_nothing;\n-      sync_nand_optab[i] = CODE_FOR_nothing;\n-      sync_old_add_optab[i] = CODE_FOR_nothing;\n-      sync_old_sub_optab[i] = CODE_FOR_nothing;\n-      sync_old_ior_optab[i] = CODE_FOR_nothing;\n-      sync_old_and_optab[i] = CODE_FOR_nothing;\n-      sync_old_xor_optab[i] = CODE_FOR_nothing;\n-      sync_old_nand_optab[i] = CODE_FOR_nothing;\n-      sync_new_add_optab[i] = CODE_FOR_nothing;\n-      sync_new_sub_optab[i] = CODE_FOR_nothing;\n-      sync_new_ior_optab[i] = CODE_FOR_nothing;\n-      sync_new_and_optab[i] = CODE_FOR_nothing;\n-      sync_new_xor_optab[i] = CODE_FOR_nothing;\n-      sync_new_nand_optab[i] = CODE_FOR_nothing;\n-      sync_compare_and_swap[i] = CODE_FOR_nothing;\n-      sync_lock_test_and_set[i] = CODE_FOR_nothing;\n-      sync_lock_release[i] = CODE_FOR_nothing;\n-\n-      reload_in_optab[i] = reload_out_optab[i] = CODE_FOR_nothing;\n-    }\n-\n   /* Fill in the optabs with the insns we support.  */\n   init_all_optabs ();\n \n@@ -6845,9 +6789,9 @@ get_vcond_icode (tree type, enum machine_mode mode)\n   enum insn_code icode = CODE_FOR_nothing;\n \n   if (TYPE_UNSIGNED (type))\n-    icode = vcondu_gen_code[mode];\n+    icode = direct_optab_handler (vcondu_optab, mode);\n   else\n-    icode = vcond_gen_code[mode];\n+    icode = direct_optab_handler (vcond_optab, mode);\n   return icode;\n }\n \n@@ -6945,7 +6889,8 @@ rtx\n expand_val_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  enum insn_code icode = sync_compare_and_swap[mode];\n+  enum insn_code icode\n+    = direct_optab_handler (sync_compare_and_swap_optab, mode);\n \n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n@@ -6982,7 +6927,7 @@ expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n   /* If the target supports a compare-and-swap pattern that simultaneously\n      sets some flag for success, then use it.  Otherwise use the regular\n      compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = sync_compare_and_swap[mode];\n+  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n@@ -7060,7 +7005,7 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n   /* If the target supports a compare-and-swap pattern that simultaneously\n      sets some flag for success, then use it.  Otherwise use the regular\n      compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = sync_compare_and_swap[mode];\n+  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n   if (icode == CODE_FOR_nothing)\n     return false;\n \n@@ -7104,26 +7049,26 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n   switch (code)\n     {\n     case PLUS:\n-      icode = sync_add_optab[mode];\n+      icode = direct_optab_handler (sync_add_optab, mode);\n       break;\n     case IOR:\n-      icode = sync_ior_optab[mode];\n+      icode = direct_optab_handler (sync_ior_optab, mode);\n       break;\n     case XOR:\n-      icode = sync_xor_optab[mode];\n+      icode = direct_optab_handler (sync_xor_optab, mode);\n       break;\n     case AND:\n-      icode = sync_and_optab[mode];\n+      icode = direct_optab_handler (sync_and_optab, mode);\n       break;\n     case NOT:\n-      icode = sync_nand_optab[mode];\n+      icode = direct_optab_handler (sync_nand_optab, mode);\n       break;\n \n     case MINUS:\n-      icode = sync_sub_optab[mode];\n+      icode = direct_optab_handler (sync_sub_optab, mode);\n       if (icode == CODE_FOR_nothing || CONST_INT_P (val))\n \t{\n-\t  icode = sync_add_optab[mode];\n+\t  icode = direct_optab_handler (sync_add_optab, mode);\n \t  if (icode != CODE_FOR_nothing)\n \t    {\n \t      val = expand_simple_unop (mode, NEG, val, NULL_RTX, 1);\n@@ -7154,7 +7099,8 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n \n   /* Failing that, generate a compare-and-swap loop in which we perform the\n      operation with normal arithmetic instructions.  */\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing)\n     {\n       rtx t0 = gen_reg_rtx (mode), t1;\n \n@@ -7199,34 +7145,34 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n   switch (code)\n     {\n     case PLUS:\n-      old_code = sync_old_add_optab[mode];\n-      new_code = sync_new_add_optab[mode];\n+      old_code = direct_optab_handler (sync_old_add_optab, mode);\n+      new_code = direct_optab_handler (sync_new_add_optab, mode);\n       break;\n     case IOR:\n-      old_code = sync_old_ior_optab[mode];\n-      new_code = sync_new_ior_optab[mode];\n+      old_code = direct_optab_handler (sync_old_ior_optab, mode);\n+      new_code = direct_optab_handler (sync_new_ior_optab, mode);\n       break;\n     case XOR:\n-      old_code = sync_old_xor_optab[mode];\n-      new_code = sync_new_xor_optab[mode];\n+      old_code = direct_optab_handler (sync_old_xor_optab, mode);\n+      new_code = direct_optab_handler (sync_new_xor_optab, mode);\n       break;\n     case AND:\n-      old_code = sync_old_and_optab[mode];\n-      new_code = sync_new_and_optab[mode];\n+      old_code = direct_optab_handler (sync_old_and_optab, mode);\n+      new_code = direct_optab_handler (sync_new_and_optab, mode);\n       break;\n     case NOT:\n-      old_code = sync_old_nand_optab[mode];\n-      new_code = sync_new_nand_optab[mode];\n+      old_code = direct_optab_handler (sync_old_nand_optab, mode);\n+      new_code = direct_optab_handler (sync_new_nand_optab, mode);\n       break;\n \n     case MINUS:\n-      old_code = sync_old_sub_optab[mode];\n-      new_code = sync_new_sub_optab[mode];\n+      old_code = direct_optab_handler (sync_old_sub_optab, mode);\n+      new_code = direct_optab_handler (sync_new_sub_optab, mode);\n       if ((old_code == CODE_FOR_nothing && new_code == CODE_FOR_nothing)\n           || CONST_INT_P (val))\n \t{\n-\t  old_code = sync_old_add_optab[mode];\n-\t  new_code = sync_new_add_optab[mode];\n+\t  old_code = direct_optab_handler (sync_old_add_optab, mode);\n+\t  new_code = direct_optab_handler (sync_new_add_optab, mode);\n \t  if (old_code != CODE_FOR_nothing || new_code != CODE_FOR_nothing)\n \t    {\n \t      val = expand_simple_unop (mode, NEG, val, NULL_RTX, 1);\n@@ -7316,7 +7262,8 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n \n   /* Failing that, generate a compare-and-swap loop in which we perform the\n      operation with normal arithmetic instructions.  */\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing)\n     {\n       rtx t0 = gen_reg_rtx (mode), t1;\n \n@@ -7365,7 +7312,7 @@ expand_sync_lock_test_and_set (rtx mem, rtx val, rtx target)\n   rtx insn;\n \n   /* If the target supports the test-and-set directly, great.  */\n-  icode = sync_lock_test_and_set[mode];\n+  icode = direct_optab_handler (sync_lock_test_and_set_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n@@ -7385,7 +7332,8 @@ expand_sync_lock_test_and_set (rtx mem, rtx val, rtx target)\n     }\n \n   /* Otherwise, use a compare-and-swap loop for the exchange.  */\n-  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n+      != CODE_FOR_nothing)\n     {\n       if (!target || !register_operand (target, mode))\n \ttarget = gen_reg_rtx (mode);"}, {"sha": "1c518e56fd5499cbcbbefa9a0c4c44d25a261a24", "filename": "gcc/optabs.h", "status": "modified", "additions": 130, "deletions": 63, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -594,79 +594,127 @@ extern struct convert_optab_d convert_optab_table[COI_MAX];\n #define satfract_optab (&convert_optab_table[COI_satfract])\n #define satfractuns_optab (&convert_optab_table[COI_satfractuns])\n \n-/* These arrays record the insn_code of insns that may be needed to\n-   perform input and output reloads of special objects.  They provide a\n-   place to pass a scratch register.  */\n-extern enum insn_code reload_in_optab[NUM_MACHINE_MODES];\n-extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n-\n /* Contains the optab used for each rtx code.  */\n extern optab code_to_optab[NUM_RTX_CODE + 1];\n \n \f\n typedef rtx (*rtxfun) (rtx);\n \n+/* Enumerates operations that have a named .md pattern associated\n+   with them, but which are not implemented as library functions.  */\n+enum direct_optab_index\n+{\n #ifdef HAVE_conditional_move\n-/* Indexed by the machine mode, gives the insn code to make a conditional\n-   move insn.  */\n-\n-extern enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n+  /* Conditional move operations.  */\n+  DOI_movcc,\n #endif\n \n-/* Indexed by the machine mode, gives the insn code for vector conditional\n-   operation.  */\n-\n-extern enum insn_code vcond_gen_code[NUM_MACHINE_MODES];\n-extern enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n-\n-/* This array records the insn_code of insns to perform block moves.  */\n-extern enum insn_code movmem_optab[NUM_MACHINE_MODES];\n-\n-/* This array records the insn_code of insns to perform block sets.  */\n-extern enum insn_code setmem_optab[NUM_MACHINE_MODES];\n-\n-/* These arrays record the insn_code of two different kinds of insns\n-   to perform block compares.  */\n-extern enum insn_code cmpstr_optab[NUM_MACHINE_MODES];\n-extern enum insn_code cmpstrn_optab[NUM_MACHINE_MODES];\n-extern enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n-\n-/* Synchronization primitives.  This first set is atomic operation for\n-   which we don't care about the resulting value.  */\n-extern enum insn_code sync_add_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_sub_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_ior_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_and_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_xor_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_nand_optab[NUM_MACHINE_MODES];\n-\n-/* This second set is atomic operations in which we return the value\n-   that existed in memory before the operation.  */\n-extern enum insn_code sync_old_add_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_old_sub_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_old_ior_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_old_and_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_old_xor_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_old_nand_optab[NUM_MACHINE_MODES];\n-\n-/* This third set is atomic operations in which we return the value\n-   that resulted after performing the operation.  */\n-extern enum insn_code sync_new_add_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_new_sub_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_new_ior_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_new_and_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_new_xor_optab[NUM_MACHINE_MODES];\n-extern enum insn_code sync_new_nand_optab[NUM_MACHINE_MODES];\n-\n-/* Atomic compare and swap.  */\n-extern enum insn_code sync_compare_and_swap[NUM_MACHINE_MODES];\n-\n-/* Atomic exchange with acquire semantics.  */\n-extern enum insn_code sync_lock_test_and_set[NUM_MACHINE_MODES];\n-\n-/* Atomic clear with release semantics.  */\n-extern enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n+  /* Operations that use a scratch register to perform input and output\n+     reloads of special objects.  */\n+  DOI_reload_in,\n+  DOI_reload_out,\n+\n+  /* Vector conditional operations.  */\n+  DOI_vcond,\n+  DOI_vcondu,\n+\n+  /* Block move operation.  */\n+  DOI_movmem,\n+\n+  /* Block set operation.  */\n+  DOI_setmem,\n+\n+  /* Various types of block compare operation.  */\n+  DOI_cmpstr,\n+  DOI_cmpstrn,\n+  DOI_cmpmem,\n+\n+  /* Synchronization primitives.  This first set is atomic operation for\n+     which we don't care about the resulting value.  */\n+  DOI_sync_add,\n+  DOI_sync_sub,\n+  DOI_sync_ior,\n+  DOI_sync_and,\n+  DOI_sync_xor,\n+  DOI_sync_nand,\n+\n+  /* This second set is atomic operations in which we return the value\n+     that existed in memory before the operation.  */\n+  DOI_sync_old_add,\n+  DOI_sync_old_sub,\n+  DOI_sync_old_ior,\n+  DOI_sync_old_and,\n+  DOI_sync_old_xor,\n+  DOI_sync_old_nand,\n+\n+  /* This third set is atomic operations in which we return the value\n+     that resulted after performing the operation.  */\n+  DOI_sync_new_add,\n+  DOI_sync_new_sub,\n+  DOI_sync_new_ior,\n+  DOI_sync_new_and,\n+  DOI_sync_new_xor,\n+  DOI_sync_new_nand,\n+\n+  /* Atomic compare and swap.  */\n+  DOI_sync_compare_and_swap,\n+\n+  /* Atomic exchange with acquire semantics.  */\n+  DOI_sync_lock_test_and_set,\n+\n+  /* Atomic clear with release semantics.  */\n+  DOI_sync_lock_release,\n+\n+  DOI_MAX\n+};\n+\n+/* A structure that says which insn should be used to perform an operation\n+   in a particular mode.  */\n+struct direct_optab_d\n+{\n+  struct optab_handlers handlers[NUM_MACHINE_MODES];\n+};\n+typedef struct direct_optab_d *direct_optab;\n+\n+extern struct direct_optab_d direct_optab_table[(int) DOI_MAX];\n \n+#ifdef HAVE_conditional_move\n+#define movcc_optab (&direct_optab_table[(int) DOI_movcc])\n+#endif\n+#define reload_in_optab (&direct_optab_table[(int) DOI_reload_in])\n+#define reload_out_optab (&direct_optab_table[(int) DOI_reload_out])\n+#define vcond_optab (&direct_optab_table[(int) DOI_vcond])\n+#define vcondu_optab (&direct_optab_table[(int) DOI_vcondu])\n+#define movmem_optab (&direct_optab_table[(int) DOI_movmem])\n+#define setmem_optab (&direct_optab_table[(int) DOI_setmem])\n+#define cmpstr_optab (&direct_optab_table[(int) DOI_cmpstr])\n+#define cmpstrn_optab (&direct_optab_table[(int) DOI_cmpstrn])\n+#define cmpmem_optab (&direct_optab_table[(int) DOI_cmpmem])\n+#define sync_add_optab (&direct_optab_table[(int) DOI_sync_add])\n+#define sync_sub_optab (&direct_optab_table[(int) DOI_sync_sub])\n+#define sync_ior_optab (&direct_optab_table[(int) DOI_sync_ior])\n+#define sync_and_optab (&direct_optab_table[(int) DOI_sync_and])\n+#define sync_xor_optab (&direct_optab_table[(int) DOI_sync_xor])\n+#define sync_nand_optab (&direct_optab_table[(int) DOI_sync_nand])\n+#define sync_old_add_optab (&direct_optab_table[(int) DOI_sync_old_add])\n+#define sync_old_sub_optab (&direct_optab_table[(int) DOI_sync_old_sub])\n+#define sync_old_ior_optab (&direct_optab_table[(int) DOI_sync_old_ior])\n+#define sync_old_and_optab (&direct_optab_table[(int) DOI_sync_old_and])\n+#define sync_old_xor_optab (&direct_optab_table[(int) DOI_sync_old_xor])\n+#define sync_old_nand_optab (&direct_optab_table[(int) DOI_sync_old_nand])\n+#define sync_new_add_optab (&direct_optab_table[(int) DOI_sync_new_add])\n+#define sync_new_sub_optab (&direct_optab_table[(int) DOI_sync_new_sub])\n+#define sync_new_ior_optab (&direct_optab_table[(int) DOI_sync_new_ior])\n+#define sync_new_and_optab (&direct_optab_table[(int) DOI_sync_new_and])\n+#define sync_new_xor_optab (&direct_optab_table[(int) DOI_sync_new_xor])\n+#define sync_new_nand_optab (&direct_optab_table[(int) DOI_sync_new_nand])\n+#define sync_compare_and_swap_optab \\\n+  (&direct_optab_table[(int) DOI_sync_compare_and_swap])\n+#define sync_lock_test_and_set_optab \\\n+  (&direct_optab_table[(int) DOI_sync_lock_test_and_set])\n+#define sync_lock_release_optab \\\n+  (&direct_optab_table[(int) DOI_sync_lock_release])\n+\f\n /* Define functions given in optabs.c.  */\n \n extern rtx expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n@@ -823,6 +871,25 @@ set_convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n     = (int) code - (int) CODE_FOR_nothing;\n }\n \n+/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n+   if the target does not have such an insn.  */\n+\n+static inline enum insn_code\n+direct_optab_handler (direct_optab op, enum machine_mode mode)\n+{\n+  return (enum insn_code) (op->handlers[(int) mode].insn_code\n+\t\t\t   + (int) CODE_FOR_nothing);\n+}\n+\n+/* Record that insn CODE should be used to implement mode MODE of OP.  */\n+\n+static inline void\n+set_direct_optab_handler (direct_optab op, enum machine_mode mode,\n+\t\t\t  enum insn_code code)\n+{\n+  op->handlers[(int) mode].insn_code = (int) code - (int) CODE_FOR_nothing;\n+}\n+\n extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \t\t\t          enum machine_mode mode2);"}, {"sha": "48191a2a00fbf102bf211d0887ffad4565eba849", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -275,12 +275,6 @@ int caller_save_needed;\n    Required by some machines to handle any generated moves differently.  */\n int reload_in_progress = 0;\n \n-/* These arrays record the insn_code of insns that may be needed to\n-   perform input and output reloads of special objects.  They provide a\n-   place to pass a scratch register.  */\n-enum insn_code reload_in_optab[NUM_MACHINE_MODES];\n-enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n-\n /* This obstack is used for allocation of rtl during register elimination.\n    The allocated storage can be freed once find_reloads has processed the\n    insn.  */"}, {"sha": "002c0e35f200aeed5f188e8f173af9430674e374", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9621cc4774d44166dc6e25228a1d86f14aaaca6/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f9621cc4774d44166dc6e25228a1d86f14aaaca6", "patch": "@@ -849,8 +849,9 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n #endif\n   if (rclass != NO_REGS)\n     {\n-      enum insn_code icode = (in_p ? reload_in_optab[(int) reload_mode]\n-\t\t\t      : reload_out_optab[(int) reload_mode]);\n+      enum insn_code icode\n+\t= direct_optab_handler (in_p ? reload_in_optab : reload_out_optab,\n+\t\t\t\treload_mode);\n \n       if (icode != CODE_FOR_nothing\n \t  && insn_data[(int) icode].operand[in_p].predicate"}]}