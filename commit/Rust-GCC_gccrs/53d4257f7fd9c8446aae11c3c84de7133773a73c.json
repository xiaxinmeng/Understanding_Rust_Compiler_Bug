{"sha": "53d4257f7fd9c8446aae11c3c84de7133773a73c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkNDI1N2Y3ZmQ5Yzg0NDZhYWUxMWMzYzg0ZGU3MTMzNzczYTczYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-23T00:10:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-23T00:10:43Z"}, "message": "calls.c (ECF_LIBCALL_BLOCK): New constant.\n\n\t* calls.c (ECF_LIBCALL_BLOCK): New constant.\n\t(emit_call_1, initialize_argument_information,\n\tprecompute_arguments, expand_call,\n\temit_library_call_value_1): Use ECF_LIBCALL_BLOCK\n\tinstead of ECF_PURE | ECF_CONST. Honnor LCT_CONST/LCT_PURE.\n\nFrom-SVN: r48279", "tree": {"sha": "a2d23ff5b37a44891d171b8de241e12bd3b9bf95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2d23ff5b37a44891d171b8de241e12bd3b9bf95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53d4257f7fd9c8446aae11c3c84de7133773a73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d4257f7fd9c8446aae11c3c84de7133773a73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d4257f7fd9c8446aae11c3c84de7133773a73c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d4257f7fd9c8446aae11c3c84de7133773a73c/comments", "author": null, "committer": null, "parents": [{"sha": "affb9cddc0541f27279d5a1c6350f106f574375c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affb9cddc0541f27279d5a1c6350f106f574375c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affb9cddc0541f27279d5a1c6350f106f574375c"}], "stats": {"total": 75, "additions": 37, "deletions": 38}, "files": [{"sha": "238e583fe614854d753265eeee0776888fe604f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d4257f7fd9c8446aae11c3c84de7133773a73c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d4257f7fd9c8446aae11c3c84de7133773a73c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53d4257f7fd9c8446aae11c3c84de7133773a73c", "patch": "@@ -1,3 +1,11 @@\n+Sun Dec 23 00:49:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (ECF_LIBCALL_BLOCK): New constant.\n+\t(emit_call_1, initialize_argument_information,\n+\tprecompute_arguments, expand_call,\n+\temit_library_call_value_1): Use ECF_LIBCALL_BLOCK\n+\tinstead of ECF_PURE | ECF_CONST. Honnor LCT_CONST/LCT_PURE.\n+\n 2001-12-22  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* config.gcc (extra_headers): Move settings to math-68881.h and"}, {"sha": "2049bd2f9c831e2ce684c40151db86da8e6a3cd4", "filename": "gcc/calls.c", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53d4257f7fd9c8446aae11c3c84de7133773a73c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53d4257f7fd9c8446aae11c3c84de7133773a73c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=53d4257f7fd9c8446aae11c3c84de7133773a73c", "patch": "@@ -176,6 +176,8 @@ static int calls_function_1\tPARAMS ((tree, int));\n #define ECF_SP_DEPRESSED\t1024\n /* Nonzero if this call is known to always return.  */\n #define ECF_ALWAYS_RETURN\t2048\n+/* Create libcall block around the call.  */\n+#define ECF_LIBCALL_BLOCK\t4096\n \n static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, rtx,\n@@ -808,14 +810,14 @@ flags_from_decl_or_type (exp)\n \n       /* The function exp may have the `pure' attribute.  */\n       if (DECL_P (exp) && DECL_IS_PURE (exp))\n-\tflags |= ECF_PURE;\n+\tflags |= ECF_PURE | ECF_LIBCALL_BLOCK;\n \n       if (TREE_NOTHROW (exp))\n \tflags |= ECF_NOTHROW;\n     }\n \n   if (TREE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n-    flags |= ECF_CONST;\n+    flags |= ECF_CONST | ECF_LIBCALL_BLOCK;\n \n   if (TREE_THIS_VOLATILE (exp))\n     flags |= ECF_NORETURN;\n@@ -825,7 +827,7 @@ flags_from_decl_or_type (exp)\n   if (TREE_CODE (type) == FUNCTION_TYPE && TYPE_RETURNS_STACK_DEPRESSED (type))\n     {\n       flags |= ECF_SP_DEPRESSED;\n-      flags &= ~(ECF_PURE | ECF_CONST);\n+      flags &= ~(ECF_PURE | ECF_CONST | ECF_LIBCALL_BLOCK);\n     }\n \n   return flags;\n@@ -1264,7 +1266,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\tcopy = assign_temp (type, 0, 1, 0);\n \n \t      store_expr (args[i].tree_value, copy, 0);\n-\t      *ecf_flags &= ~(ECF_CONST | ECF_PURE);\n+\t      *ecf_flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n \n \t      args[i].tree_value = build1 (ADDR_EXPR,\n \t\t\t\t\t   build_pointer_type (type),\n@@ -1323,7 +1325,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n       /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n \t we cannot consider this function call constant.  */\n       if (TREE_ADDRESSABLE (type))\n-\t*ecf_flags &= ~(ECF_CONST | ECF_PURE);\n+\t*ecf_flags &= ~ECF_LIBCALL_BLOCK;\n \n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n@@ -1494,7 +1496,7 @@ precompute_arguments (flags, num_actuals, args)\n      worse code)  */\n \n   for (i = 0; i < num_actuals; i++)\n-    if ((flags & (ECF_CONST | ECF_PURE))\n+    if ((flags & ECF_LIBCALL_BLOCK)\n \t|| calls_function (args[i].tree_value, !ACCUMULATE_OUTGOING_ARGS))\n       {\n \tenum machine_mode mode;\n@@ -2240,7 +2242,7 @@ expand_call (exp, target, ignore)\n   if (aggregate_value_p (exp))\n     {\n       /* This call returns a big structure.  */\n-      flags &= ~(ECF_CONST | ECF_PURE);\n+      flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n@@ -2387,7 +2389,7 @@ expand_call (exp, target, ignore)\n \t do this eventually, but it is too complicated to keep track of\n \t what insns go in the cse'able block and which don't.  */\n \n-      flags &= ~(ECF_CONST | ECF_PURE);\n+      flags &= ~ECF_LIBCALL_BLOCK;\n       must_preallocate = 1;\n     }\n \n@@ -2670,7 +2672,7 @@ expand_call (exp, target, ignore)\n \n       /* When calling a const function, we must pop the stack args right away,\n \t so that the pop is deleted or moved with the call.  */\n-      if (flags & (ECF_CONST | ECF_PURE))\n+      if (pass && (flags & ECF_LIBCALL_BLOCK))\n \tNO_DEFER_POP;\n \n       /* Push the temporary stack slot level so that we can free any\n@@ -2687,7 +2689,7 @@ expand_call (exp, target, ignore)\n \n       /* Now we are about to start emitting insns that can be deleted\n \t if a libcall is deleted.  */\n-      if (flags & (ECF_CONST | ECF_PURE | ECF_MALLOC))\n+      if (pass && (flags & (ECF_LIBCALL_BLOCK | ECF_MALLOC)))\n \tstart_sequence ();\n \n       adjusted_args_size = args_size;\n@@ -2903,7 +2905,7 @@ expand_call (exp, target, ignore)\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n \t  if (pending_stack_adjust\n-\t      && ! (flags & (ECF_CONST | ECF_PURE))\n+\t      && ! (flags & ECF_LIBCALL_BLOCK)\n \t      && ! inhibit_defer_pop)\n \t    {\n \t      pending_stack_adjust\n@@ -2935,6 +2937,9 @@ expand_call (exp, target, ignore)\n \t    valreg = hard_function_value (TREE_TYPE (exp), fndecl, (pass == 0));\n \t}\n \n+      if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n+        flags &= ~ECF_LIBCALL_BLOCK;\n+\n       /* Precompute all register parameters.  It isn't safe to compute anything\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n@@ -3064,9 +3069,7 @@ expand_call (exp, target, ignore)\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n \t we have no way to move such values into a pseudo register.  */\n-      if (pass\n-\t  && (flags & (ECF_CONST | ECF_PURE))\n-\t  && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+      if (pass && (flags & ECF_LIBCALL_BLOCK))\n \t{\n \t  rtx note = 0;\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n@@ -3095,15 +3098,7 @@ expand_call (exp, target, ignore)\n \n \t  valreg = temp;\n \t}\n-      else if (flags & (ECF_CONST | ECF_PURE))\n-\t{\n-\t  /* Otherwise, just write out the sequence without a note.  */\n-\t  rtx insns = get_insns ();\n-\n-\t  end_sequence ();\n-\t  emit_insns (insns);\n-\t}\n-      else if (flags & ECF_MALLOC)\n+      else if (pass && (flags & ECF_MALLOC))\n \t{\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n \t  rtx last, insns;\n@@ -3502,15 +3497,18 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   switch (fn_type)\n     {\n     case LCT_NORMAL:\n+      break;\n     case LCT_CONST:\n+      flags |= ECF_CONST;\n+      break;\n     case LCT_PURE:\n-      /* Nothing to do here.  */\n+      flags |= ECF_PURE;\n       break;\n     case LCT_CONST_MAKE_BLOCK:\n-      flags |= ECF_CONST;\n+      flags |= ECF_CONST | ECF_LIBCALL_BLOCK;\n       break;\n     case LCT_PURE_MAKE_BLOCK:\n-      flags |= ECF_PURE;\n+      flags |= ECF_PURE | ECF_LIBCALL_BLOCK;\n       break;\n     case LCT_NORETURN:\n       flags |= ECF_NORETURN;\n@@ -3553,7 +3551,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #endif\n \n       /* This call returns a big structure.  */\n-      flags &= ~(ECF_CONST | ECF_PURE);\n+      flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n     }\n \n   /* ??? Unfinished: must pass the memory address as an argument.  */\n@@ -3581,7 +3579,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n   /* Now we are about to start emitting insns that can be deleted\n      if a libcall is deleted.  */\n-  if (flags & (ECF_CONST | ECF_PURE))\n+  if (flags & ECF_LIBCALL_BLOCK)\n     start_sequence ();\n \n   push_temp_slots ();\n@@ -4023,6 +4021,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   NO_DEFER_POP;\n   valreg = (mem_value == 0 && outmode != VOIDmode\n \t    ? hard_libcall_value (outmode) : NULL_RTX);\n+  if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n+    flags &= ~ECF_LIBCALL_BLOCK;\n \n   /* Stack must be properly aligned now.  */\n   if (stack_pointer_delta & (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1))\n@@ -4076,8 +4076,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      Test valreg so we don't crash; may safely ignore `const'\n      if return type is void.  Disable for PARALLEL return values, because\n      we have no way to move such values into a pseudo register.  */\n-  if ((flags & (ECF_CONST | ECF_PURE))\n-      && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+  if (flags & ECF_LIBCALL_BLOCK)\n     {\n       rtx note = 0;\n       rtx temp = gen_reg_rtx (GET_MODE (valreg));\n@@ -4103,14 +4102,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n       valreg = temp;\n     }\n-  else if (flags & (ECF_CONST | ECF_PURE))\n-    {\n-      /* Otherwise, just write out the sequence without a note.  */\n-      rtx insns = get_insns ();\n-\n-      end_sequence ();\n-      emit_insns (insns);\n-    }\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */"}]}