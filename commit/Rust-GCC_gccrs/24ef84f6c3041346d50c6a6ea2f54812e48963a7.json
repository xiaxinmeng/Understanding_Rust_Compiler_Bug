{"sha": "24ef84f6c3041346d50c6a6ea2f54812e48963a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRlZjg0ZjZjMzA0MTM0NmQ1MGM2YTZlYTJmNTQ4MTJlNDg5NjNhNw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2011-10-19T22:05:26Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2011-10-19T22:05:26Z"}, "message": "[multiple changes]\n\n2011-10-19  Ed Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* include/tr2/bool_set (bool_set): New.\n\t* include/tr2/bool_set.tcc: New.\n\t* include/tr2/dynamic_bitset (dynamic_bitset): New.\n\t* include/tr2/ratio (kibi, mebi, gibi, tebi, pebi, exbi): New.\n\t* include/Makefile.am: Add files.\n\t* include/Makefile.in: Regenerate.\n\n2011-10-19  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* doc/doxygen/user.cfg.in: Add tr2 files.\n\t* testsuite/tr2/headers/all.cc: New.\n\t* testsuite/tr2/headers/using_namespace_std_tr2.cc: New.\n\n\t* include/tr2/type_traits: Tweak.\n\nFrom-SVN: r180211", "tree": {"sha": "85d906a7c369c3f35f724b441ee1a70fd8b69dcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85d906a7c369c3f35f724b441ee1a70fd8b69dcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24ef84f6c3041346d50c6a6ea2f54812e48963a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ef84f6c3041346d50c6a6ea2f54812e48963a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ef84f6c3041346d50c6a6ea2f54812e48963a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ef84f6c3041346d50c6a6ea2f54812e48963a7/comments", "author": null, "committer": null, "parents": [{"sha": "2c23ebfec69d77f9d62e80bfb4157c184f88364f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c23ebfec69d77f9d62e80bfb4157c184f88364f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c23ebfec69d77f9d62e80bfb4157c184f88364f"}], "stats": {"total": 2417, "additions": 2312, "deletions": 105}, "files": [{"sha": "9f70e377e77bfe080f3b76771441713790a930ff", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -1,3 +1,20 @@\n+2011-10-19  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* include/tr2/bool_set (bool_set): New.\n+\t* include/tr2/bool_set.tcc: New.\n+\t* include/tr2/dynamic_bitset (dynamic_bitset): New.\n+\t* include/tr2/ratio (kibi, mebi, gibi, tebi, pebi, exbi): New.\n+\t* include/Makefile.am: Add files.\n+\t* include/Makefile.in: Regenerate.\n+\n+2011-10-19  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* doc/doxygen/user.cfg.in: Add tr2 files.\n+\t* testsuite/tr2/headers/all.cc: New.\n+\t* testsuite/tr2/headers/using_namespace_std_tr2.cc: New.\n+\n+\t* include/tr2/type_traits: Tweak.\n+\n 2011-10-18  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50500"}, {"sha": "0b01ceb61e6a049e7870d54514211cdab0a309bb", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -746,6 +746,10 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n \t\t\t include/tr1/ctime \\\n \t\t\t include/tr1/cwchar \\\n \t\t\t include/tr1/cwctype \\\n+\t\t\t include/tr2/bool_set \\\n+\t\t\t include/tr2/dynamic_bitset \\\n+\t\t\t include/tr2/ratio \\\n+\t\t\t include/tr2/type_traits \\\n \t\t\t include/decimal/decimal \\\n \t\t\t include/ext \\\n \t\t\t include/ext/pb_ds \\"}, {"sha": "02deefc72228d984a6f52d9b023d9c6cea2e7a41", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -79,7 +79,7 @@ std_headers = \\\n bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n-        ${bits_srcdir}/algorithmfwd.h \\\n+\t${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n@@ -179,11 +179,11 @@ bits_headers = \\\n \n bits_sup_srcdir = ${glibcxx_srcdir}/libsupc++\n bits_sup_headers = \\\n-        ${bits_sup_srcdir}/cxxabi_forced.h \\\n-        ${bits_sup_srcdir}/exception_defines.h \\\n-        ${bits_sup_srcdir}/exception_ptr.h \\\n-        ${bits_sup_srcdir}/hash_bytes.h \\\n-        ${bits_sup_srcdir}/nested_exception.h\n+\t${bits_sup_srcdir}/cxxabi_forced.h \\\n+\t${bits_sup_srcdir}/exception_defines.h \\\n+\t${bits_sup_srcdir}/exception_ptr.h \\\n+\t${bits_sup_srcdir}/hash_bytes.h \\\n+\t${bits_sup_srcdir}/nested_exception.h\n \n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n@@ -269,7 +269,7 @@ pb_headers1 = \\\n \t${pb_srcdir}/detail/binomial_heap_/binomial_heap_.hpp \\\n \t${pb_srcdir}/detail/binomial_heap_/constructors_destructor_fn_imps.hpp \\\n \t${pb_srcdir}/detail/binomial_heap_/debug_fn_imps.hpp \\\n-\t${pb_srcdir}/detail/bin_search_tree_/bin_search_tree_.hpp \n+\t${pb_srcdir}/detail/bin_search_tree_/bin_search_tree_.hpp\n \n pb_headers2 = \\\n \t${pb_srcdir}/detail/bin_search_tree_/constructors_destructor_fn_imps.hpp \\\n@@ -607,6 +607,10 @@ tr1_headers = \\\n tr2_srcdir = ${glibcxx_srcdir}/include/tr2\n tr2_builddir = ./tr2\n tr2_headers = \\\n+\t${tr2_srcdir}/bool_set \\\n+\t${tr2_srcdir}/bool_set.tcc \\\n+\t${tr2_srcdir}/dynamic_bitset \\\n+\t${tr2_srcdir}/ratio \\\n \t${tr2_srcdir}/type_traits\n \n decimal_srcdir = ${glibcxx_srcdir}/include/decimal\n@@ -725,49 +729,49 @@ parallel_srcdir = ${glibcxx_srcdir}/include/parallel\n parallel_builddir = ./parallel\n if ENABLE_PARALLEL\n parallel_headers = \\\n-        ${parallel_srcdir}/algo.h \\\n-        ${parallel_srcdir}/algobase.h \\\n-        ${parallel_srcdir}/algorithm \\\n-        ${parallel_srcdir}/algorithmfwd.h \\\n-        ${parallel_srcdir}/balanced_quicksort.h \\\n-        ${parallel_srcdir}/base.h \\\n-        ${parallel_srcdir}/basic_iterator.h \\\n-        ${parallel_srcdir}/checkers.h \\\n-        ${parallel_srcdir}/compatibility.h \\\n-        ${parallel_srcdir}/compiletime_settings.h \\\n-        ${parallel_srcdir}/equally_split.h \\\n-        ${parallel_srcdir}/features.h \\\n-        ${parallel_srcdir}/find.h \\\n-        ${parallel_srcdir}/find_selectors.h \\\n-        ${parallel_srcdir}/for_each.h \\\n-        ${parallel_srcdir}/for_each_selectors.h \\\n-        ${parallel_srcdir}/iterator.h \\\n-        ${parallel_srcdir}/list_partition.h \\\n-        ${parallel_srcdir}/losertree.h \\\n-        ${parallel_srcdir}/merge.h \\\n-        ${parallel_srcdir}/multiseq_selection.h \\\n-        ${parallel_srcdir}/multiway_merge.h \\\n-        ${parallel_srcdir}/multiway_mergesort.h \\\n-        ${parallel_srcdir}/numeric \\\n-        ${parallel_srcdir}/numericfwd.h \\\n-        ${parallel_srcdir}/omp_loop.h \\\n-        ${parallel_srcdir}/omp_loop_static.h \\\n-        ${parallel_srcdir}/par_loop.h \\\n-        ${parallel_srcdir}/parallel.h \\\n-        ${parallel_srcdir}/partial_sum.h \\\n-        ${parallel_srcdir}/partition.h \\\n-        ${parallel_srcdir}/queue.h \\\n-        ${parallel_srcdir}/quicksort.h \\\n-        ${parallel_srcdir}/random_number.h \\\n-        ${parallel_srcdir}/random_shuffle.h \\\n-        ${parallel_srcdir}/search.h \\\n-        ${parallel_srcdir}/set_operations.h \\\n-        ${parallel_srcdir}/settings.h \\\n-        ${parallel_srcdir}/sort.h \\\n-        ${parallel_srcdir}/tags.h \\\n-        ${parallel_srcdir}/types.h \\\n-        ${parallel_srcdir}/unique_copy.h \\\n-        ${parallel_srcdir}/workstealing.h\n+\t${parallel_srcdir}/algo.h \\\n+\t${parallel_srcdir}/algobase.h \\\n+\t${parallel_srcdir}/algorithm \\\n+\t${parallel_srcdir}/algorithmfwd.h \\\n+\t${parallel_srcdir}/balanced_quicksort.h \\\n+\t${parallel_srcdir}/base.h \\\n+\t${parallel_srcdir}/basic_iterator.h \\\n+\t${parallel_srcdir}/checkers.h \\\n+\t${parallel_srcdir}/compatibility.h \\\n+\t${parallel_srcdir}/compiletime_settings.h \\\n+\t${parallel_srcdir}/equally_split.h \\\n+\t${parallel_srcdir}/features.h \\\n+\t${parallel_srcdir}/find.h \\\n+\t${parallel_srcdir}/find_selectors.h \\\n+\t${parallel_srcdir}/for_each.h \\\n+\t${parallel_srcdir}/for_each_selectors.h \\\n+\t${parallel_srcdir}/iterator.h \\\n+\t${parallel_srcdir}/list_partition.h \\\n+\t${parallel_srcdir}/losertree.h \\\n+\t${parallel_srcdir}/merge.h \\\n+\t${parallel_srcdir}/multiseq_selection.h \\\n+\t${parallel_srcdir}/multiway_merge.h \\\n+\t${parallel_srcdir}/multiway_mergesort.h \\\n+\t${parallel_srcdir}/numeric \\\n+\t${parallel_srcdir}/numericfwd.h \\\n+\t${parallel_srcdir}/omp_loop.h \\\n+\t${parallel_srcdir}/omp_loop_static.h \\\n+\t${parallel_srcdir}/par_loop.h \\\n+\t${parallel_srcdir}/parallel.h \\\n+\t${parallel_srcdir}/partial_sum.h \\\n+\t${parallel_srcdir}/partition.h \\\n+\t${parallel_srcdir}/queue.h \\\n+\t${parallel_srcdir}/quicksort.h \\\n+\t${parallel_srcdir}/random_number.h \\\n+\t${parallel_srcdir}/random_shuffle.h \\\n+\t${parallel_srcdir}/search.h \\\n+\t${parallel_srcdir}/set_operations.h \\\n+\t${parallel_srcdir}/settings.h \\\n+\t${parallel_srcdir}/sort.h \\\n+\t${parallel_srcdir}/tags.h \\\n+\t${parallel_srcdir}/types.h \\\n+\t${parallel_srcdir}/unique_copy.h \\\n+\t${parallel_srcdir}/workstealing.h\n else\n parallel_headers =\n endif\n@@ -894,7 +898,7 @@ allstamped = \\\n \tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n \tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n-\tstamp-host \n+\tstamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -1104,7 +1108,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \\\n \t-e \"s,define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY, define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY $$visibility,\" \\\n \t-e \"s,define _GLIBCXX_EXTERN_TEMPLATE, define _GLIBCXX_EXTERN_TEMPLATE $$externtemplate,\" \\\n \t-e \"$$ldbl_compat\" \\\n-            < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\\\n+\t    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\\\n \tsed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \\\n \t    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \\\n \t    -e 's/VERSION/_GLIBCXX_VERSION/g' \\"}, {"sha": "e3e75a00511901e3282ea3ab795f059b9aa6108d", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -331,7 +331,7 @@ std_headers = \\\n bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n-        ${bits_srcdir}/algorithmfwd.h \\\n+\t${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/alloc_traits.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n@@ -431,11 +431,11 @@ bits_headers = \\\n \n bits_sup_srcdir = ${glibcxx_srcdir}/libsupc++\n bits_sup_headers = \\\n-        ${bits_sup_srcdir}/cxxabi_forced.h \\\n-        ${bits_sup_srcdir}/exception_defines.h \\\n-        ${bits_sup_srcdir}/exception_ptr.h \\\n-        ${bits_sup_srcdir}/hash_bytes.h \\\n-        ${bits_sup_srcdir}/nested_exception.h\n+\t${bits_sup_srcdir}/cxxabi_forced.h \\\n+\t${bits_sup_srcdir}/exception_defines.h \\\n+\t${bits_sup_srcdir}/exception_ptr.h \\\n+\t${bits_sup_srcdir}/hash_bytes.h \\\n+\t${bits_sup_srcdir}/nested_exception.h\n \n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n@@ -520,7 +520,7 @@ pb_headers1 = \\\n \t${pb_srcdir}/detail/binomial_heap_/binomial_heap_.hpp \\\n \t${pb_srcdir}/detail/binomial_heap_/constructors_destructor_fn_imps.hpp \\\n \t${pb_srcdir}/detail/binomial_heap_/debug_fn_imps.hpp \\\n-\t${pb_srcdir}/detail/bin_search_tree_/bin_search_tree_.hpp \n+\t${pb_srcdir}/detail/bin_search_tree_/bin_search_tree_.hpp\n \n pb_headers2 = \\\n \t${pb_srcdir}/detail/bin_search_tree_/constructors_destructor_fn_imps.hpp \\\n@@ -857,6 +857,10 @@ tr1_headers = \\\n tr2_srcdir = ${glibcxx_srcdir}/include/tr2\n tr2_builddir = ./tr2\n tr2_headers = \\\n+\t${tr2_srcdir}/bool_set \\\n+\t${tr2_srcdir}/bool_set.tcc \\\n+\t${tr2_srcdir}/dynamic_bitset \\\n+\t${tr2_srcdir}/ratio \\\n \t${tr2_srcdir}/type_traits\n \n decimal_srcdir = ${glibcxx_srcdir}/include/decimal\n@@ -971,49 +975,49 @@ parallel_srcdir = ${glibcxx_srcdir}/include/parallel\n parallel_builddir = ./parallel\n @ENABLE_PARALLEL_FALSE@parallel_headers = \n @ENABLE_PARALLEL_TRUE@parallel_headers = \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/algo.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/algobase.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/algorithm \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/algorithmfwd.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/balanced_quicksort.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/base.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/basic_iterator.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/checkers.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/compatibility.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/compiletime_settings.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/equally_split.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/features.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/find.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/find_selectors.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/for_each.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/for_each_selectors.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/iterator.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/list_partition.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/losertree.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/merge.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/multiseq_selection.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/multiway_merge.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/multiway_mergesort.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/numeric \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/numericfwd.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/omp_loop.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/omp_loop_static.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/par_loop.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/parallel.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/partial_sum.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/partition.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/queue.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/quicksort.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/random_number.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/random_shuffle.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/search.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/set_operations.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/settings.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/sort.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/tags.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/types.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/unique_copy.h \\\n-@ENABLE_PARALLEL_TRUE@        ${parallel_srcdir}/workstealing.h\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/algo.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/algobase.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/algorithm \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/algorithmfwd.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/balanced_quicksort.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/base.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/basic_iterator.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/checkers.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/compatibility.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/compiletime_settings.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/equally_split.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/features.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/find.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/find_selectors.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/for_each.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/for_each_selectors.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/iterator.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/list_partition.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/losertree.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/merge.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/multiseq_selection.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/multiway_merge.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/multiway_mergesort.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/numeric \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/numericfwd.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/omp_loop.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/omp_loop_static.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/par_loop.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/parallel.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/partial_sum.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/partition.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/queue.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/quicksort.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/random_number.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/random_shuffle.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/search.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/set_operations.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/settings.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/sort.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/tags.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/types.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/unique_copy.h \\\n+@ENABLE_PARALLEL_TRUE@\t${parallel_srcdir}/workstealing.h\n \n \n # Profile mode headers\n@@ -1132,7 +1136,7 @@ allstamped = \\\n \tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n \tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n-\tstamp-host \n+\tstamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1495,7 +1499,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \\\n \t-e \"s,define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY, define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY $$visibility,\" \\\n \t-e \"s,define _GLIBCXX_EXTERN_TEMPLATE, define _GLIBCXX_EXTERN_TEMPLATE $$externtemplate,\" \\\n \t-e \"$$ldbl_compat\" \\\n-            < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\\\n+\t    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\\\n \tsed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \\\n \t    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \\\n \t    -e 's/VERSION/_GLIBCXX_VERSION/g' \\"}, {"sha": "fe322675991ea414e5cfed944e60f5f805bc7514", "filename": "libstdc++-v3/include/tr2/bool_set", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,320 @@\n+// TR2 <bool_set> -*- C++ -*-\n+\n+// Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file tr2/bool_set\n+ *  This is a TR2 C++ Library header.\n+ */\n+\n+//\n+//  Sort of an implementation of bool_set in n2136 Herv\ufffd Br\ufffdnnimann,\n+//  Guillaume Melquiond, Sylvain Pion.\n+//\n+//  The implicit conversion to bool is slippery!  I may use the new\n+//  explicit conversion.  This has been specialized in the language so\n+//  that in contexts requiring a bool the conversion happens\n+//  implicitly.  Thus most objections should be eliminated.\n+//\n+\n+#ifndef _GLIBCXX_TR2_BOOL_SET\n+#define _GLIBCXX_TR2_BOOL_SET 1\n+\n+#pragma GCC system_header\n+\n+#include <typeinfo>\n+#include <iostream>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace tr2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  class bool_set\n+  {\n+  public:\n+\n+    ///  Default constructor.\n+    bool_set() : _M_b(_S_false) { }\n+\n+    ///  Constructor from bool.\n+    bool_set(bool __t) : _M_b(_Bool_set_val(__t)) { }\n+\n+    ///\n+    // I'm not sure about this.\n+    bool contains(bool_set __b) const\n+    { return this->is_singleton() && this->equals(__b); }\n+\n+    ///  Return true if states are equal.\n+    bool equals(bool_set __b) const\n+    { return __b._M_b == _M_b; }\n+\n+    ///  Return true if this is empty.\n+    bool is_emptyset() const\n+    { return _M_b == _S_empty; }\n+\n+    ///  Return true if this is indeterminate.\n+    bool is_indeterminate() const\n+    { return _M_b == _S_indet; }\n+\n+    ///  Return true if this is false or true (normal boolean).\n+    bool is_singleton() const\n+    { return _M_b == _S_false || _M_b == _S_true_; }\n+\n+    ///  Conversion to bool.\n+    //explicit\n+    operator bool() const\n+    {\n+      if (! is_singleton())\n+\tthrow std::bad_cast();\n+      return _M_b;\n+    }\n+\n+    ///\n+    static bool_set indeterminate()\n+    {\n+      bool_set __b;\n+      __b._M_b = _S_indet;\n+      return __b;\n+    }\n+\n+    ///\n+    static bool_set emptyset()\n+    {\n+      bool_set __b;\n+      __b._M_b = _S_empty;\n+      return __b;\n+    }\n+\n+    friend bool_set\n+    operator!(bool_set __b)\n+    { return __b._M_not(); }\n+\n+    friend bool_set\n+    operator^(bool_set __s, bool_set __t)\n+    { return __s._M_xor(__t); }\n+\n+    friend bool_set\n+    operator|(bool_set __s, bool_set __t)\n+    { return __s._M_or(__t); }\n+\n+    friend bool_set\n+    operator&(bool_set __s, bool_set __t)\n+    { return __s._M_and(__t); }\n+\n+    friend bool_set\n+    operator==(bool_set __s, bool_set __t)\n+    { return __s._M_eq(__t); }\n+\n+\n+    //  These overloads replace the facet additions in the paper!\n+\n+    template<typename CharT, typename Traits>\n+      friend std::basic_ostream<CharT, Traits>&\n+      operator<<(std::basic_ostream<CharT, Traits>& __out, bool_set __b)\n+      {\n+\tint __a = __b._M_b;\n+\t__out << __a;\n+      }\n+\n+    template<typename CharT, typename Traits>\n+      friend std::basic_istream<CharT, Traits>&\n+      operator>>(std::basic_istream<CharT, Traits>& __in, bool_set& __b)\n+      {\n+\tlong __c;\n+\t__in >> __c;\n+\tif (__c >= _S_false && __c < _S_empty)\n+\t  __b._M_b = static_cast<_Bool_set_val>(__c);\n+      }\n+\n+  private:\n+\n+    ///\n+    enum _Bool_set_val: unsigned char\n+    {\n+      _S_false = 0,\n+      _S_true_ = 1,\n+      _S_indet = 2,\n+      _S_empty = 3\n+    };\n+\n+    ///  Bool set state.\n+    _Bool_set_val _M_b;\n+\n+    ///\n+    bool_set(_Bool_set_val __c) : _M_b(__c) { }\n+\n+    ///\n+    bool_set _M_not() const\n+    { return _S_not[this->_M_b]; }\n+\n+    ///\n+    bool_set _M_xor(bool_set __b) const\n+    { return _S_xor[this->_M_b][__b._M_b]; }\n+\n+    ///\n+    bool_set _M_or(bool_set __b) const\n+    { return _S_or[this->_M_b][__b._M_b]; }\n+\n+    ///\n+    bool_set _M_and(bool_set __b) const\n+    { return _S_and[this->_M_b][__b._M_b]; }\n+\n+    ///\n+    bool_set _M_eq(bool_set __b) const\n+    { return _S_eq[this->_M_b][__b._M_b]; }\n+\n+    ///\n+    static _Bool_set_val _S_not[4];\n+\n+    ///\n+    static _Bool_set_val _S_xor[4][4];\n+\n+    ///\n+    static _Bool_set_val _S_or[4][4];\n+\n+    ///\n+    static _Bool_set_val _S_and[4][4];\n+\n+    ///\n+    static _Bool_set_val _S_eq[4][4];\n+  };\n+\n+  //  20.2.3.2 bool_set values\n+\n+  inline bool\n+  contains(bool_set __s, bool_set __t)\n+  { return __s.contains(__t); }\n+\n+  inline bool\n+  equals(bool_set __s, bool_set __t)\n+  { return __s.equals(__t); }\n+\n+  inline bool\n+  is_emptyset(bool_set __b)\n+  { return __b.is_emptyset(); }\n+\n+  inline bool\n+  is_indeterminate(bool_set __b)\n+  { return __b.is_indeterminate(); }\n+\n+  inline bool\n+  is_singleton(bool_set __b)\n+  { return __b.is_singleton(); }\n+\n+  inline bool\n+  certainly(bool_set __b)\n+  { return ! __b.contains(false); }\n+\n+  inline bool\n+  possibly(bool_set __b)\n+  { return __b.contains(true); }\n+\n+\n+  //  20.2.3.3 bool_set set operations\n+\n+  inline bool_set\n+  set_union(bool __s, bool_set __t)\n+  { return bool_set(__s) | __t; }\n+\n+  inline bool_set\n+  set_union(bool_set __s, bool __t)\n+  { return __s | bool_set(__t); }\n+\n+  inline bool_set\n+  set_union(bool_set __s, bool_set __t)\n+  { return __s | __t; }\n+\n+  inline bool_set\n+  set_intersection(bool __s, bool_set __t)\n+  { return bool_set(__s) & __t; }\n+\n+  inline bool_set\n+  set_intersection(bool_set __s, bool __t)\n+  { return __s & bool_set(__t); }\n+\n+  inline bool_set\n+  set_intersection(bool_set __s, bool_set __t)\n+  { return __s & __t; }\n+\n+  inline bool_set\n+  set_complement(bool_set __b)\n+  { return ! __b; }\n+\n+\n+  //  20.2.3.4 bool_set logical operators\n+\n+  inline bool_set\n+  operator^(bool __s, bool_set __t)\n+  { return bool_set(__s) ^ __t; }\n+\n+  inline bool_set\n+  operator^(bool_set __s, bool __t)\n+  { return __s ^ bool_set(__t); }\n+\n+  inline bool_set\n+  operator|(bool __s, bool_set __t)\n+  { return bool_set(__s) | __t; }\n+\n+  inline bool_set\n+  operator|(bool_set __s, bool __t)\n+  { return __s | bool_set(__t); }\n+\n+  inline bool_set\n+  operator&(bool __s, bool_set __t)\n+  { return bool_set(__s) & __t; }\n+\n+  inline bool_set\n+  operator&(bool_set __s, bool __t)\n+  { return __s & bool_set(__t); }\n+\n+\n+  //  20.2.3.5 bool_set relational operators\n+\n+  inline bool_set\n+  operator==(bool __s, bool_set __t)\n+  { return bool_set(__s) == __t; }\n+\n+  inline bool_set\n+  operator==(bool_set __s, bool __t)\n+  { return __s == bool_set(__t); }\n+\n+  inline bool_set\n+  operator!=(bool __s, bool_set __t)\n+  { return ! (__s == __t); }\n+\n+  inline bool_set\n+  operator!=(bool_set __s, bool __t)\n+  { return ! (__s == __t); }\n+\n+  inline bool_set\n+  operator!=(bool_set __s, bool_set __t)\n+  { return ! (__s == __t); }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+}\n+}\n+\n+#include <tr2/bool_set.tcc>\n+\n+#endif // _GLIBCXX_TR2_BOOL_SET"}, {"sha": "f24d44823985fe9125f8da6a4735665140579e2a", "filename": "libstdc++-v3/include/tr2/bool_set.tcc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fbool_set.tcc?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,277 @@\n+// TR2 <bool_set> support files -*- C++ -*-\n+\n+// Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file tr2/bool_set.tcc\n+ *  This is a TR2 C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_TR2_BOOL_SET_TCC\n+#define _GLIBCXX_TR2_BOOL_SET_TCC 1\n+\n+#pragma GCC system_header\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace tr2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  bool_set::_Bool_set_val\n+  bool_set::_S_not[4] =\n+  { _S_true_, _S_false, _S_indet, _S_empty };\n+\n+  bool_set::_Bool_set_val\n+  bool_set::_S_xor[4][4] =\n+  { { _S_false, _S_true_, _S_indet, _S_empty },\n+    { _S_true_, _S_false, _S_indet, _S_empty },\n+    { _S_indet, _S_indet, _S_indet, _S_empty },\n+    { _S_empty, _S_empty, _S_empty, _S_empty } };\n+\n+  bool_set::_Bool_set_val\n+  bool_set::_S_or[4][4] =\n+  { { _S_false, _S_true_, _S_indet, _S_empty },\n+    { _S_true_, _S_true_, _S_true_, _S_empty },\n+    { _S_indet, _S_true_, _S_indet, _S_empty },\n+    { _S_empty, _S_empty, _S_empty, _S_empty } };\n+\n+  bool_set::_Bool_set_val\n+  bool_set::_S_and[4][4] =\n+  { { _S_false, _S_false, _S_false, _S_empty },\n+    { _S_false, _S_true_, _S_indet, _S_empty },\n+    { _S_false, _S_indet, _S_indet, _S_empty },\n+    { _S_empty, _S_empty, _S_empty, _S_empty } };\n+\n+  bool_set::_Bool_set_val\n+  bool_set::_S_eq[4][4] =\n+  { { _S_true_, _S_false, _S_indet, _S_empty },\n+    { _S_false, _S_true_, _S_indet, _S_empty },\n+    { _S_indet, _S_indet, _S_indet, _S_empty },\n+    { _S_empty, _S_empty, _S_empty, _S_empty } };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+}\n+}\n+\n+//  I object to these things.\n+//  The stuff in locale facets are for basic types.\n+//  I think we could hack operator<< and operator>>.\n+\n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the bool @a v.  It does so by calling\n+       *  num_get::do_get().\n+       *\n+       *  If ios_base::boolalpha is set, attempts to read\n+       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets\n+       *  @a v to true or false if successful.  Sets err to\n+       *  ios_base::failbit if reading the string fails.  Sets err to\n+       *  ios_base::eofbit if the stream is emptied.\n+       *\n+       *  If ios_base::boolalpha is not set, proceeds as with reading a long,\n+       *  except if the value is 1, sets @a v to true, if the value is 0, sets\n+       *  @a v to false, and otherwise set err to ios_base::failbit.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      iter_type\n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, bool& __v) const\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n+       */\n+/*\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+\t   ios_base::iostate& __err, bool_set& __v) const\n+    {\n+      if (!(__io.flags() & ios_base::boolalpha))\n+\t{\n+\t  // Parse bool values as long.\n+\t  // NB: We can't just call do_get(long) here, as it might\n+\t  // refer to a derived class.\n+\t  long __l = -1;\n+\t  __beg = _M_extract_int(__beg, __end, __io, __err, __l);\n+\t  if (__c >= _S_false && __c < _S_empty)\n+\t    __b._M_b = static_cast<_Bool_set_val>(__c);\n+\t  else\n+\t    {\n+\t      // What should we do here?\n+\t      __v = true;\n+\t      __err = ios_base::failbit;\n+\t      if (__beg == __end)\n+\t\t__err |= ios_base::eofbit;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // Parse bool values as alphanumeric.\n+\t  typedef __numpunct_cache<_CharT>  __cache_type;\n+\t  __use_cache<__cache_type> __uc;\n+\t  const locale& __loc = __io._M_getloc();\n+\t  const __cache_type* __lc = __uc(__loc);\n+\n+\t  bool __testf = true;\n+\t  bool __testt = true;\n+\t  bool __donef = __lc->_M_falsename_size == 0;\n+\t  bool __donet = __lc->_M_truename_size == 0;\n+\t  bool __testeof = false;\n+\t  size_t __n = 0;\n+\t  while (!__donef || !__donet)\n+\t    {\n+\t      if (__beg == __end)\n+\t\t{\n+\t\t  __testeof = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      const char_type __c = *__beg;\n+\n+\t      if (!__donef)\n+\t\t__testf = __c == __lc->_M_falsename[__n];\n+\n+\t      if (!__testf && __donet)\n+\t\tbreak;\n+\n+\t      if (!__donet)\n+\t\t__testt = __c == __lc->_M_truename[__n];\n+\n+\t      if (!__testt && __donef)\n+\t\tbreak;\n+\n+\t      if (!__testt && !__testf)\n+\t\tbreak;\n+\n+\t      ++__n;\n+\t      ++__beg;\n+\n+\t      __donef = !__testf || __n >= __lc->_M_falsename_size;\n+\t      __donet = !__testt || __n >= __lc->_M_truename_size;\n+\t    }\n+\t  if (__testf && __n == __lc->_M_falsename_size && __n)\n+\t    {\n+\t      __v = false;\n+\t      if (__testt && __n == __lc->_M_truename_size)\n+\t\t__err = ios_base::failbit;\n+\t      else\n+\t\t__err = __testeof ? ios_base::eofbit : ios_base::goodbit;\n+\t    }\n+\t  else if (__testt && __n == __lc->_M_truename_size && __n)\n+\t    {\n+\t      __v = true;\n+\t      __err = __testeof ? ios_base::eofbit : ios_base::goodbit;\n+\t    }\n+\t  else\n+\t    {\n+\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t      // 23. Num_get overflow result.\n+\t      __v = false;\n+\t      __err = ios_base::failbit;\n+\t      if (__testeof)\n+\t\t__err |= ios_base::eofbit;\n+\t    }\n+\t}\n+      return __beg;\n+    }\n+*/\n+\n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  Formats the boolean @a v and inserts it into a stream.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or\n+       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      iter_type\n+      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n+      { return this->do_put(__s, __f, __fill, __v); }\n+       */\n+\n+/*\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, bool_set __v) const\n+    {\n+      const ios_base::fmtflags __flags = __io.flags();\n+      if ((__flags & ios_base::boolalpha) == 0)\n+\t{\n+\t  const long __l = __v;\n+\t  __s = _M_insert_int(__s, __io, __fill, __l);\n+\t}\n+      else\n+\t{\n+\t  typedef __numpunct_cache<_CharT> __cache_type;\n+\t  __use_cache<__cache_type> __uc;\n+\t  const locale& __loc = __io._M_getloc();\n+\t  const __cache_type* __lc = __uc(__loc);\n+\n+\t  const _CharT* __name = __v ? __lc->_M_truename\n+\t\t\t\t     : __lc->_M_falsename;\n+\t  int __len = __v ? __lc->_M_truename_size\n+\t\t\t  : __lc->_M_falsename_size;\n+\n+\t  const streamsize __w = __io.width();\n+\t  if (__w > static_cast<streamsize>(__len))\n+\t    {\n+\t      const streamsize __plen = __w - __len;\n+\t      _CharT* __ps\n+\t\t= static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+\t\t\t\t\t\t\t* __plen));\n+\n+\t      char_traits<_CharT>::assign(__ps, __plen, __fill);\n+\t      __io.width(0);\n+\n+\t      if ((__flags & ios_base::adjustfield) == ios_base::left)\n+\t\t{\n+\t\t  __s = std::__write(__s, __name, __len);\n+\t\t  __s = std::__write(__s, __ps, __plen);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __s = std::__write(__s, __ps, __plen);\n+\t\t  __s = std::__write(__s, __name, __len);\n+\t\t}\n+\t      return __s;\n+\t    }\n+\t  __io.width(0);\n+\t  __s = std::__write(__s, __name, __len);\n+\t}\n+      return __s;\n+    }\n+*/\n+\n+#endif // _GLIBCXX_TR2_BOOL_SET_TCC"}, {"sha": "5a4b7943bbef00d3c282400fcc792ff8b2434366", "filename": "libstdc++-v3/include/tr2/dynamic_bitset", "status": "added", "additions": 1472, "deletions": 0, "changes": 1472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,1472 @@\n+// TR2 <dynamic_bitset> -*- C++ -*-\n+\n+// Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file tr2/dynamic_bitset\n+ *  This is a TR2 C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_TR2_DYNAMIC_BITSET\n+#define _GLIBCXX_TR2_DYNAMIC_BITSET 1\n+\n+#pragma GCC system_header\n+\n+#include <limits>\n+#include <vector>\n+#include <cstddef> // For size_t\n+#include <string>\n+#include <memory> // For std::allocator\n+#include <bits/functexcept.h>   // For invalid_argument, out_of_range,\n+\t\t\t\t// overflow_error\n+#include <iosfwd>\n+#include <cxxabi_forced.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace tr2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   *  Dynamic Bitset.\n+   *\n+   *  See N2050,\n+   *  Proposal to Add a Dynamically Sizeable Bitset to the Standard Library.\n+   */\n+namespace __detail\n+{\n+\n+template<typename T>\n+class _Bool2UChar\n+{\n+  typedef T type;\n+};\n+\n+template<>\n+class _Bool2UChar<bool>\n+{\n+public:\n+  typedef unsigned char type;\n+};\n+\n+}\n+\n+  /**\n+   *  Base class, general case.\n+   *\n+   *  See documentation for dynamic_bitset.\n+   */\n+  template<typename _WordT = unsigned long long,\n+\t   typename _Alloc = std::allocator<_WordT>>\n+    struct __dynamic_bitset_base\n+    {\n+      static_assert(std::is_unsigned<_WordT>::value, \"template argument \"\n+\t\t    \"_WordT not an unsigned integral type\");\n+\n+      typedef _WordT block_type;\n+      typedef _Alloc allocator_type;\n+      typedef size_t size_type;\n+\n+      static const size_type _S_bits_per_block = __CHAR_BIT__ * sizeof(block_type);\n+      static const size_type npos = static_cast<size_type>(-1);\n+\n+      /// 0 is the least significant word.\n+      std::vector<block_type, allocator_type> _M_w;\n+\n+      explicit\n+      __dynamic_bitset_base(const allocator_type& __alloc = allocator_type())\n+      : _M_w(__alloc)\n+      { }\n+\n+      explicit\n+      __dynamic_bitset_base(__dynamic_bitset_base&& __b)\n+      { this->_M_w.swap(__b._M_w); }\n+\n+      explicit\n+      __dynamic_bitset_base(size_type __nbits, unsigned long long __val = 0ULL,\n+\t\t\t   const allocator_type& __alloc = allocator_type())\n+      : _M_w(__nbits / _S_bits_per_block\n+\t     + (__nbits % _S_bits_per_block > 0),\n+\t     __val, __alloc)\n+      {\n+\tunsigned long long __mask = ~static_cast<block_type>(0);\n+\tsize_t __n = std::min(this->_M_w.size(),\n+\t\t\t      sizeof(unsigned long long) / sizeof(block_type));\n+\tfor (size_t __i = 0; __i < __n; ++__i)\n+\t  {\n+\t    this->_M_w[__i] = (__val & __mask) >> (__i * _S_bits_per_block);\n+\t    __mask <<= _S_bits_per_block;\n+\t  }\n+      }\n+\n+      void\n+      _M_assign(const __dynamic_bitset_base<block_type, allocator_type>& __b)\n+      { this->_M_w = __b._M_w; }\n+\n+      void\n+      _M_swap(__dynamic_bitset_base<block_type, allocator_type>& __b)\n+      { this->_M_w.swap(__b._M_w); }\n+\n+      void\n+      _M_clear()\n+      { this->_M_w.clear(); }\n+\n+      void\n+      _M_resize(size_t __nbits, bool __value)\n+      {\n+\tsize_t __sz = __nbits / _S_bits_per_block;\n+\tif (__nbits % _S_bits_per_block > 0)\n+\t  ++__sz;\n+\tif (__sz != this->_M_w.size())\n+\t  this->_M_w.resize(__sz);\n+      }\n+\n+      allocator_type\n+      _M_get_allocator() const\n+      { return this->_M_w.get_allocator(); }\n+\n+      static size_type\n+      _S_whichword(size_type __pos)\n+      { return __pos / _S_bits_per_block; }\n+\n+      static size_type\n+      _S_whichbyte(size_type __pos)\n+      { return (__pos % _S_bits_per_block) / __CHAR_BIT__; }\n+\n+      static size_type\n+      _S_whichbit(size_type __pos)\n+      { return __pos % _S_bits_per_block; }\n+\n+      static block_type\n+      _S_maskbit(size_type __pos)\n+      { return (static_cast<block_type>(1)) << _S_whichbit(__pos); }\n+\n+      block_type&\n+      _M_getword(size_type __pos)\n+      { return this->_M_w[_S_whichword(__pos)]; }\n+\n+      block_type\n+      _M_getword(size_type __pos) const\n+      { return this->_M_w[_S_whichword(__pos)]; }\n+\n+      block_type&\n+      _M_hiword()\n+      { return this->_M_w[_M_w.size() - 1]; }\n+\n+      block_type\n+      _M_hiword() const\n+      { return this->_M_w[_M_w.size() - 1]; }\n+\n+      void\n+      _M_do_and(const __dynamic_bitset_base<block_type, allocator_type>& __x)\n+      {\n+\tif (__x._M_w.size() == this->_M_w.size())\n+\t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t    this->_M_w[__i] &= __x._M_w[__i];\n+\telse\n+\t  return;\n+      }\n+\n+      void\n+      _M_do_or(const __dynamic_bitset_base<block_type, allocator_type>& __x)\n+      {\n+\tif (__x._M_w.size() == this->_M_w.size())\n+\t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t    this->_M_w[__i] |= __x._M_w[__i];\n+\telse\n+\t  return;\n+      }\n+\n+      void\n+      _M_do_xor(const __dynamic_bitset_base<block_type, allocator_type>& __x)\n+      {\n+\tif (__x._M_w.size() == this->_M_w.size())\n+\t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t    this->_M_w[__i] ^= __x._M_w[__i];\n+\telse\n+\t  return;\n+      }\n+\n+      void\n+      _M_do_dif(const __dynamic_bitset_base<block_type, allocator_type>& __x)\n+      {\n+\tif (__x._M_w.size() == this->_M_w.size())\n+\t  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t    this->_M_w[__i] &= ~__x._M_w[__i];\n+\telse\n+\t  return;\n+      }\n+\n+      void\n+      _M_do_left_shift(size_t __shift);\n+\n+      void\n+      _M_do_right_shift(size_t __shift);\n+\n+      void\n+      _M_do_flip()\n+      {\n+\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t  this->_M_w[__i] = ~this->_M_w[__i];\n+      }\n+\n+      void\n+      _M_do_set()\n+      {\n+\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t  this->_M_w[__i] = ~static_cast<block_type>(0);\n+      }\n+\n+      void\n+      _M_do_reset()\n+      {\n+\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t  this->_M_w[__i] = static_cast<block_type>(0);\n+      }\n+\n+      bool\n+      _M_is_equal(const __dynamic_bitset_base<block_type, allocator_type>& __x) const\n+      {\n+\tif (__x.size() == this->size())\n+\t  {\n+\t    for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t      if (this->_M_w[__i] != __x._M_w[__i])\n+\t\treturn false;\n+\t    return true;\n+\t  }\n+\telse\n+\t  return false;\n+      }\n+\n+      bool\n+      _M_is_less(const __dynamic_bitset_base<block_type, allocator_type>& __x) const\n+      {\n+\tif (__x.size() == this->size())\n+\t  {\n+\t    for (size_t __i = this->_M_w.size(); __i > 0; --__i)\n+\t      {\n+\t\tif (this->_M_w[__i-1] < __x._M_w[__i-1])\n+\t\t  return true;\n+\t\telse if (this->_M_w[__i-1] > __x._M_w[__i-1])\n+\t\t  return false;\n+\t      }\n+\t    return false;\n+\t  }\n+\telse\n+\t  return false;\n+      }\n+\n+      size_t\n+      _M_are_all_aux() const\n+      {\n+\tfor (size_t __i = 0; __i < this->_M_w.size() - 1; ++__i)\n+\t  if (_M_w[__i] != ~static_cast<block_type>(0))\n+\t    return 0;\n+\treturn ((this->_M_w.size() - 1) * _S_bits_per_block\n+\t\t+ __builtin_popcountl(this->_M_hiword()));\n+      }\n+\n+      bool\n+      _M_is_any() const\n+      {\n+\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t  if (this->_M_w[__i] != static_cast<block_type>(0))\n+\t    return true;\n+\treturn false;\n+      }\n+\n+      bool\n+      _M_is_subset_of(const __dynamic_bitset_base<block_type, allocator_type>& __b)\n+      {\n+\tif (__b.size() == this->size())\n+\t  {\n+\t    for (size_t __i = 0; __i < _M_w.size(); ++__i)\n+\t      if (this->_M_w[__i] != (this->_M_w[__i] | __b._M_w[__i]))\n+\t\treturn false;\n+\t    return true;\n+\t  }\n+\telse\n+\t  return false;\n+      }\n+\n+      bool\n+      _M_is_proper_subset_of(const __dynamic_bitset_base<block_type, allocator_type>& __b) const\n+      {\n+\tif (this->is_subset_of(__b))\n+\t  {\n+\t    if (*this == __b)\n+\t      return false;\n+\t    else\n+\t      return true;\n+\t  }\n+\telse\n+\t  return false;\n+      }\n+\n+      size_t\n+      _M_do_count() const\n+      {\n+\tsize_t __result = 0;\n+\tfor (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t  __result += __builtin_popcountl(this->_M_w[__i]);\n+\treturn __result;\n+      }\n+\n+      size_type\n+      _M_size() const\n+      { return this->_M_w.size(); }\n+\n+      unsigned long\n+      _M_do_to_ulong() const;\n+\n+      unsigned long long\n+      _M_do_to_ullong() const;\n+\n+      // find first \"on\" bit\n+      size_type\n+      _M_do_find_first(size_t __not_found) const;\n+\n+      // find the next \"on\" bit that follows \"prev\"\n+      size_type\n+      _M_do_find_next(size_t __prev, size_t __not_found) const;\n+\n+      // do append of block\n+      void\n+      _M_do_append_block(block_type __block, size_type __pos)\n+      {\n+\tsize_t __offset = __pos % _S_bits_per_block;\n+\tif (__offset == 0)\n+\t  this->_M_w.push_back(__block);\n+\telse\n+\t  {\n+\t    this->_M_hiword() |= (__block << __offset);\n+\t    this->_M_w.push_back(__block >> (_S_bits_per_block - __offset));\n+\t  }\n+      }\n+    };\n+\n+  // Definitions of non-inline functions from __dynamic_bitset_base.\n+  template<typename _WordT, typename _Alloc>\n+    void\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_left_shift(size_t __shift)\n+    {\n+      if (__builtin_expect(__shift != 0, 1))\n+\t{\n+\t  const size_t __wshift = __shift / _S_bits_per_block;\n+\t  const size_t __offset = __shift % _S_bits_per_block;\n+\n+\t  if (__offset == 0)\n+\t    for (size_t __n = this->_M_w.size() - 1; __n >= __wshift; --__n)\n+\t      this->_M_w[__n] = this->_M_w[__n - __wshift];\n+\t  else\n+\t    {\n+\t      const size_t __sub_offset = _S_bits_per_block - __offset;\n+\t      for (size_t __n = _M_w.size() - 1; __n > __wshift; --__n)\n+\t\tthis->_M_w[__n] = ((this->_M_w[__n - __wshift] << __offset)\n+\t\t\t     | (this->_M_w[__n - __wshift - 1] >> __sub_offset));\n+\t      this->_M_w[__wshift] = this->_M_w[0] << __offset;\n+\t    }\n+\n+\t  ////std::fill(this->_M_w.begin(), this->_M_w.begin() + __wshift,\n+\t  ////          static_cast<_WordT>(0));\n+\t}\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    void\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_right_shift(size_t __shift)\n+    {\n+      if (__builtin_expect(__shift != 0, 1))\n+\t{\n+\t  const size_t __wshift = __shift / _S_bits_per_block;\n+\t  const size_t __offset = __shift % _S_bits_per_block;\n+\t  const size_t __limit = this->_M_w.size() - __wshift - 1;\n+\n+\t  if (__offset == 0)\n+\t    for (size_t __n = 0; __n <= __limit; ++__n)\n+\t      this->_M_w[__n] = this->_M_w[__n + __wshift];\n+\t  else\n+\t    {\n+\t      const size_t __sub_offset = (_S_bits_per_block\n+\t\t\t\t\t   - __offset);\n+\t      for (size_t __n = 0; __n < __limit; ++__n)\n+\t\tthis->_M_w[__n] = ((this->_M_w[__n + __wshift] >> __offset)\n+\t\t\t     | (this->_M_w[__n + __wshift + 1] << __sub_offset));\n+\t      this->_M_w[__limit] = this->_M_w[_M_w.size()-1] >> __offset;\n+\t    }\n+\n+\t  ////std::fill(this->_M_w.begin() + __limit + 1, this->_M_w.end(),\n+\t  ////          static_cast<_WordT>(0));\n+\t}\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    unsigned long\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ulong() const\n+    {\n+      size_t __n = sizeof(unsigned long) / sizeof(block_type);\n+      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n+\tif (this->_M_w[__i])\n+\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ulong\"));\n+      unsigned long __res = 0UL;\n+      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n+\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n+      return __res;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    unsigned long long\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ullong() const\n+    {\n+      size_t __n = sizeof(unsigned long long) / sizeof(block_type);\n+      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n+\tif (this->_M_w[__i])\n+\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ullong\"));\n+      unsigned long long __res = 0ULL;\n+      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n+\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n+      return __res;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    size_t\n+    __dynamic_bitset_base<_WordT, _Alloc>\n+    ::_M_do_find_first(size_t __not_found) const\n+    {\n+      for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t{\n+\t  _WordT __thisword = this->_M_w[__i];\n+\t  if (__thisword != static_cast<_WordT>(0))\n+\t    return (__i * _S_bits_per_block\n+\t\t    + __builtin_ctzl(__thisword));\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    size_t\n+    __dynamic_bitset_base<_WordT, _Alloc>\n+    ::_M_do_find_next(size_t __prev, size_t __not_found) const\n+    {\n+      // make bound inclusive\n+      ++__prev;\n+\n+      // check out of bounds\n+      if (__prev >= this->_M_w.size() * _S_bits_per_block)\n+\treturn __not_found;\n+\n+      // search first word\n+      size_t __i = _S_whichword(__prev);\n+      _WordT __thisword = this->_M_w[__i];\n+\n+      // mask off bits below bound\n+      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+      if (__thisword != static_cast<_WordT>(0))\n+\treturn (__i * _S_bits_per_block\n+\t\t+ __builtin_ctzl(__thisword));\n+\n+      // check subsequent words\n+      for (++__i; __i < this->_M_w.size(); ++__i)\n+\t{\n+\t  __thisword = this->_M_w[__i];\n+\t  if (__thisword != static_cast<_WordT>(0))\n+\t    return (__i * _S_bits_per_block\n+\t\t    + __builtin_ctzl(__thisword));\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n+    } // end _M_do_find_next\n+\n+  /**\n+   *  @brief  The %dynamic_bitset class represents a sequence of bits.\n+   *\n+   *  @ingroup containers\n+   *\n+   *  (Note that %dynamic_bitset does @e not meet the formal\n+   *  requirements of a <a href=\"tables.html#65\">container</a>.\n+   *  Mainly, it lacks iterators.)\n+   *\n+   *  The template argument, @a Nb, may be any non-negative number,\n+   *  specifying the number of bits (e.g., \"0\", \"12\", \"1024*1024\").\n+   *\n+   *  In the general unoptimized case, storage is allocated in\n+   *  word-sized blocks.  Let B be the number of bits in a word, then\n+   *  (Nb+(B-1))/B words will be used for storage.  B - Nb%B bits are\n+   *  unused.  (They are the high-order bits in the highest word.)  It\n+   *  is a class invariant that those unused bits are always zero.\n+   *\n+   *  If you think of %dynamic_bitset as \"a simple array of bits,\" be\n+   *  aware that your mental picture is reversed: a %dynamic_bitset\n+   *  behaves the same way as bits in integers do, with the bit at\n+   *  index 0 in the \"least significant / right-hand\" position, and\n+   *  the bit at index Nb-1 in the \"most significant / left-hand\"\n+   *  position.  Thus, unlike other containers, a %dynamic_bitset's\n+   *  index \"counts from right to left,\" to put it very loosely.\n+   *\n+   *  This behavior is preserved when translating to and from strings.\n+   *  For example, the first line of the following program probably\n+   *  prints \"b('a') is 0001100001\" on a modern ASCII system.\n+   *\n+   *  @code\n+   *     #include <dynamic_bitset>\n+   *     #include <iostream>\n+   *     #include <sstream>\n+   *\n+   *     using namespace std;\n+   *\n+   *     int main()\n+   *     {\n+   *         long         a = 'a';\n+   *         dynamic_bitset   b(a);\n+   *\n+   *         cout << \"b('a') is \" << b << endl;\n+   *\n+   *         ostringstream s;\n+   *         s << b;\n+   *         string  str = s.str();\n+   *         cout << \"index 3 in the string is \" << str[3] << \" but\\n\"\n+   *              << \"index 3 in the bitset is \" << b[3] << endl;\n+   *     }\n+   *  @endcode\n+   *\n+   *  Also see:\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html\n+   *  for a description of extensions.\n+   *\n+   *  Most of the actual code isn't contained in %dynamic_bitset<>\n+   *  itself, but in the base class __dynamic_bitset_base.  The base\n+   *  class works with whole words, not with individual bits.  This\n+   *  allows us to specialize __dynamic_bitset_base for the important\n+   *  special case where the %dynamic_bitset is only a single word.\n+   *\n+   *  Extra confusion can result due to the fact that the storage for\n+   *  __dynamic_bitset_base @e is a vector, and is indexed as such.  This is\n+   *  carefully encapsulated.\n+   */\n+  template<typename _WordT = unsigned long long,\n+\t   typename _Alloc = std::allocator<_WordT>>\n+    class dynamic_bitset\n+    : private __dynamic_bitset_base<_WordT, _Alloc>\n+    {\n+      static_assert(std::is_unsigned<_WordT>::value, \"template argument \"\n+\t\t    \"_WordT not an unsigned integral type\");\n+\n+    public:\n+\n+      typedef __dynamic_bitset_base<_WordT, _Alloc> _Base;\n+      typedef _WordT block_type;\n+      typedef _Alloc allocator_type;\n+      typedef size_t size_type;\n+\n+      static const size_type bits_per_block = __CHAR_BIT__ * sizeof(block_type);\n+      // Use this: constexpr size_type std::numeric_limits<size_type>::max().\n+      static const size_type npos = static_cast<size_type>(-1);\n+\n+    private:\n+\n+      //  Clear the unused bits in the uppermost word.\n+      void\n+      _M_do_sanitize()\n+      {\n+\tsize_type __shift = this->_M_Nb % bits_per_block;\n+\tif (__shift > 0)\n+\t  this->_M_hiword() &= ~((~static_cast<block_type>(0)) << __shift);\n+      }\n+\n+      /**\n+       *  These versions of single-bit set, reset, flip, and test\n+       *  do no range checking.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      _M_unchecked_set(size_type __pos)\n+      {\n+\tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      _M_unchecked_set(size_type __pos, int __val)\n+      {\n+\tif (__val)\n+\t  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+\telse\n+\t  this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      _M_unchecked_reset(size_type __pos)\n+      {\n+\tthis->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      _M_unchecked_flip(size_type __pos)\n+      {\n+\tthis->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n+\treturn *this;\n+      }\n+\n+      bool\n+      _M_unchecked_test(size_type __pos) const\n+      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n+\t\t!= static_cast<_WordT>(0)); }\n+\n+      size_type _M_Nb;\n+\n+    public:\n+      /**\n+       *  This encapsulates the concept of a single bit.  An instance\n+       *  of this class is a proxy for an actual bit; this way the\n+       *  individual bit operations are done as faster word-size\n+       *  bitwise instructions.\n+       *\n+       *  Most users will never need to use this class directly;\n+       *  conversions to and from bool are automatic and should be\n+       *  transparent.  Overloaded operators help to preserve the\n+       *  illusion.\n+       *\n+       *  (On a typical system, this \"bit %reference\" is 64 times the\n+       *  size of an actual bit.  Ha.)\n+       */\n+      class reference\n+      {\n+\tfriend class dynamic_bitset;\n+\n+\tblock_type *_M_wp;\n+\tsize_type _M_bpos;\n+\n+\t// left undefined\n+\treference();\n+\n+      public:\n+\treference(dynamic_bitset& __b, size_type __pos)\n+\t{\n+\t  this->_M_wp = &__b._M_getword(__pos);\n+\t  this->_M_bpos = _Base::_S_whichbit(__pos);\n+\t}\n+\n+\t~reference()\n+\t{ }\n+\n+\t// For b[i] = __x;\n+\treference&\n+\toperator=(bool __x)\n+\t{\n+\t  if (__x)\n+\t    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);\n+\t  else\n+\t    *this->_M_wp &= ~_Base::_S_maskbit(this->_M_bpos);\n+\t  return *this;\n+\t}\n+\n+\t// For b[i] = b[__j];\n+\treference&\n+\toperator=(const reference& __j)\n+\t{\n+\t  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))\n+\t    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);\n+\t  else\n+\t    *this->_M_wp &= ~_Base::_S_maskbit(this->_M_bpos);\n+\t  return *this;\n+\t}\n+\n+\t// Flips the bit\n+\tbool\n+\toperator~() const\n+\t{ return (*(_M_wp) & _Base::_S_maskbit(this->_M_bpos)) == 0; }\n+\n+\t// For __x = b[i];\n+\toperator bool() const\n+\t{ return (*(this->_M_wp) & _Base::_S_maskbit(this->_M_bpos)) != 0; }\n+\n+\t// For b[i].flip();\n+\treference&\n+\tflip()\n+\t{\n+\t  *this->_M_wp ^= _Base::_S_maskbit(this->_M_bpos);\n+\t  return *this;\n+\t}\n+      };\n+\n+      friend class reference;\n+\n+      typedef bool const_reference;\n+\n+      // 23.3.5.1 constructors:\n+      /// All bits set to zero.\n+      explicit\n+      dynamic_bitset(const allocator_type& __alloc = allocator_type())\n+      : _Base(__alloc), _M_Nb(0)\n+      { }\n+\n+      /// Initial bits bitwise-copied from a single word (others set to zero).\n+      explicit\n+      dynamic_bitset(size_type __nbits, unsigned long long __val = 0ULL,\n+\t\t     const allocator_type& __alloc = allocator_type())\n+      : _Base(__nbits, __val, __alloc),\n+\t_M_Nb(__nbits)\n+      { }\n+\n+      dynamic_bitset(initializer_list<block_type> __il,\n+\t\t     const allocator_type& __alloc = allocator_type())\n+      : _Base(__alloc), _M_Nb(0)\n+      { this->append(__il); }\n+\n+      /**\n+       *  @brief  Use a subset of a string.\n+       *  @param  str  A string of '0' and '1' characters.\n+       *  @param  pos  Index of the first character in @a s to use.\n+       *  @param  n    The number of characters to copy.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n+       *  @throw  std::invalid_argument  If a character appears in the string\n+       *                                 which is neither '0' nor '1'.\n+       */\n+      template<typename _CharT, typename _Traits, typename _Alloc1>\n+\texplicit\n+\tdynamic_bitset(const std::basic_string<_CharT, _Traits, _Alloc1>& __str,\n+\t\t       typename basic_string<_CharT,_Traits,_Alloc1>::size_type\n+\t\t       __pos = 0,\n+\t\t       typename basic_string<_CharT,_Traits,_Alloc1>::size_type\n+\t\t       __n = std::basic_string<_CharT, _Traits, _Alloc1>::npos,\n+\t\t       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'),\n+\t\t       const allocator_type& __alloc = allocator_type())\n+\t: _Base(__alloc),\n+\t  _M_Nb(0) // Watch for npos.\n+\t{\n+\t  if (__pos > __str.size())\n+\t    __throw_out_of_range(__N(\"dynamic_bitset::bitset initial position \"\n+\t\t\t\t     \"not valid\"));\n+\n+\t  // Watch for npos.\n+\t  this->_M_Nb = (__n > __str.size() ? __str.size() - __pos : __n);\n+\t  this->resize(this->_M_Nb);\n+\t  this->_M_copy_from_string(__str, __pos, __n,\n+\t\t\t\t    _CharT('0'), _CharT('1'));\n+\t}\n+\n+      /**\n+       *  @brief  Construct from a string.\n+       *  @param  str  A string of '0' and '1' characters.\n+       *  @throw  std::invalid_argument  If a character appears in the string\n+       *                                 which is neither '0' nor '1'.\n+       */\n+      explicit\n+      dynamic_bitset(const char* __str,\n+\t\t     const allocator_type& __alloc = allocator_type())\n+      : _Base(__alloc)\n+      {\n+\tsize_t __len = 0;\n+\tif (__str)\n+\t  while (__str[__len] != '\\0')\n+\t    ++__len;\n+\tthis->resize(__len);\n+\tthis->_M_copy_from_ptr<char,std::char_traits<char>>\n+\t\t   (__str, __len, 0, __len, '0', '1');\n+      }\n+\n+      /**\n+       *  @brief  Copy constructor.\n+       */\n+      dynamic_bitset(const dynamic_bitset& __b)\n+      : _Base(__b), _M_Nb(__b.size())\n+      { }\n+\n+      /**\n+       *  @brief  Move constructor.\n+       */\n+      dynamic_bitset(dynamic_bitset&& __b)\n+      : _Base(std::forward<_Base>(__b)), _M_Nb(__b.size())\n+      { }\n+\n+      /**\n+       *  @brief  Swap with another bitset.\n+       */\n+      void\n+      swap(dynamic_bitset& __b)\n+      {\n+\tthis->_M_swap(__b);\n+\tstd::swap(this->_M_Nb, __b._M_Nb);\n+      }\n+\n+      /**\n+       *  @brief  Assignment.\n+       */\n+      dynamic_bitset&\n+      operator=(const dynamic_bitset& __b)\n+      {\n+\tif (&__b != this)\n+\t  {\n+\t    this->_M_assign(__b);\n+\t    this->_M_Nb = __b._M_Nb;\n+\t  }\n+      }\n+\n+      /**\n+       *  @brief  Move assignment.\n+       */\n+      dynamic_bitset&\n+      operator=(dynamic_bitset&& __b)\n+      {\n+\tthis->swap(__b);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief  Return the allocator for the bitset.\n+       */\n+      allocator_type\n+      get_allocator() const\n+      { return this->_M_get_allocator(); }\n+\n+      /**\n+       *  @brief  Resize the bitset.\n+       */\n+      void\n+      resize(size_type __nbits, bool __value = false)\n+      {\n+\tthis->_M_resize(__nbits, __value);\n+\tthis->_M_Nb = __nbits;\n+\tthis->_M_do_sanitize();\n+      }\n+\n+      /**\n+       *  @brief  Clear the bitset.\n+       */\n+      void\n+      clear()\n+      {\n+\tthis->_M_clear();\n+\tthis->_M_Nb = 0;\n+      }\n+\n+      /**\n+       *  @brief  Push a bit onto the high end of the bitset.\n+       */\n+      void\n+      push_back(bool __bit)\n+      {\n+\tif (size_t __offset = this->size() % bits_per_block == 0)\n+\t  this->_M_do_append_block(block_type(0), this->_M_Nb);\n+\t++this->_M_Nb;\n+\tthis->_M_unchecked_set(this->_M_Nb, __bit);\n+      }\n+\n+      /**\n+       *  @brief  Append a block.\n+       */\n+      void\n+      append(block_type __block)\n+      {\n+\tthis->_M_do_append_block(__block, this->_M_Nb);\n+\tthis->_M_Nb += bits_per_block;\n+      }\n+\n+      /**\n+       *  @brief\n+       */\n+      void\n+      append(initializer_list<block_type> __il)\n+      { this->append(__il.begin(), __il.end()); }\n+\n+      /**\n+       *  @brief  Append an iterator range of blocks.\n+       */\n+      template <typename _BlockInputIterator>\n+\tvoid\n+\tappend(_BlockInputIterator __first, _BlockInputIterator __last)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    this->append(*__first);\n+\t}\n+\n+      // 23.3.5.2 dynamic_bitset operations:\n+      //@{\n+      /**\n+       *  @brief  Operations on dynamic_bitsets.\n+       *  @param  rhs  A same-sized dynamic_bitset.\n+       *\n+       *  These should be self-explanatory.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator&=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      {\n+\tthis->_M_do_and(__rhs);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator&=(dynamic_bitset<_WordT, _Alloc>&& __rhs)\n+      {\n+\tthis->_M_do_and(std::move(__rhs));\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator|=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      {\n+\tthis->_M_do_or(__rhs);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator^=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      {\n+\tthis->_M_do_xor(__rhs);\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator-=(const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      {\n+\tthis->_M_do_dif(__rhs);\n+\treturn *this;\n+      }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief  Operations on dynamic_bitsets.\n+       *  @param  position  The number of places to shift.\n+       *\n+       *  These should be self-explanatory.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator<<=(size_type __pos)\n+      {\n+\tif (__builtin_expect(__pos < this->_M_Nb, 1))\n+\t  {\n+\t    this->_M_do_left_shift(__pos);\n+\t    this->_M_do_sanitize();\n+\t  }\n+\telse\n+\t  this->_M_do_reset();\n+\treturn *this;\n+      }\n+\n+      dynamic_bitset<_WordT, _Alloc>&\n+      operator>>=(size_type __pos)\n+      {\n+\tif (__builtin_expect(__pos < this->_M_Nb, 1))\n+\t  {\n+\t    this->_M_do_right_shift(__pos);\n+\t    this->_M_do_sanitize();\n+\t  }\n+\telse\n+\t  this->_M_do_reset();\n+\treturn *this;\n+      }\n+      //@}\n+\n+      // Set, reset, and flip.\n+      /**\n+       *  @brief Sets every bit to true.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      set()\n+      {\n+\tthis->_M_do_set();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Sets a given bit to a particular value.\n+       *  @param  position  The index of the bit.\n+       *  @param  val  Either true or false, defaults to true.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      set(size_type __pos, bool __val = true)\n+      {\n+\tif (__pos >= _M_Nb)\n+\t  __throw_out_of_range(__N(\"dynamic_bitset::set\"));\n+\treturn this->_M_unchecked_set(__pos, __val);\n+      }\n+\n+      /**\n+       *  @brief Sets every bit to false.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      reset()\n+      {\n+\tthis->_M_do_reset();\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Sets a given bit to false.\n+       *  @param  position  The index of the bit.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       *\n+       *  Same as writing @c set(pos,false).\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      reset(size_type __pos)\n+      {\n+\tif (__pos >= _M_Nb)\n+\t  __throw_out_of_range(__N(\"dynamic_bitset::reset\"));\n+\treturn this->_M_unchecked_reset(__pos);\n+      }\n+\n+      /**\n+       *  @brief Toggles every bit to its opposite value.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      flip()\n+      {\n+\tthis->_M_do_flip();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Toggles a given bit to its opposite value.\n+       *  @param  position  The index of the bit.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      dynamic_bitset<_WordT, _Alloc>&\n+      flip(size_type __pos)\n+      {\n+\tif (__pos >= _M_Nb)\n+\t  __throw_out_of_range(__N(\"dynamic_bitset::flip\"));\n+\treturn this->_M_unchecked_flip(__pos);\n+      }\n+\n+      /// See the no-argument flip().\n+      dynamic_bitset<_WordT, _Alloc>\n+      operator~() const\n+      { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }\n+\n+      //@{\n+      /**\n+       *  @brief  Array-indexing support.\n+       *  @param  position  Index into the %dynamic_bitset.\n+       *  @return A bool for a 'const %dynamic_bitset'.  For non-const\n+       *           bitsets, an instance of the reference proxy class.\n+       *  @note These operators do no range checking and throw no\n+       *         exceptions, as required by DR 11 to the standard.\n+       */\n+      reference\n+      operator[](size_type __pos)\n+      { return reference(*this,__pos); }\n+\n+      const_reference\n+      operator[](size_type __pos) const\n+      { return _M_unchecked_test(__pos); }\n+      //@}\n+\n+      /**\n+       *  @brief Returns a numerical interpretation of the %dynamic_bitset.\n+       *  @return  The integral equivalent of the bits.\n+       *  @throw  std::overflow_error  If there are too many bits to be\n+       *                               represented in an @c unsigned @c long.\n+       */\n+      unsigned long\n+      to_ulong() const\n+      { return this->_M_do_to_ulong(); }\n+\n+      /**\n+       *  @brief Returns a numerical interpretation of the %dynamic_bitset.\n+       *  @return  The integral equivalent of the bits.\n+       *  @throw  std::overflow_error  If there are too many bits to be\n+       *                               represented in an @c unsigned @c long.\n+       */\n+      unsigned long long\n+      to_ullong() const\n+      { return this->_M_do_to_ullong(); }\n+\n+      /**\n+       *  @brief Returns a character interpretation of the %dynamic_bitset.\n+       *  @return  The string equivalent of the bits.\n+       *\n+       *  Note the ordering of the bits:  decreasing character positions\n+       *  correspond to increasing bit positions (see the main class notes for\n+       *  an example).\n+       */\n+      template<typename _CharT = char,\n+\t       typename _Traits = std::char_traits<_CharT>,\n+\t       typename _Alloc1 = std::allocator<_CharT>>\n+\tstd::basic_string<_CharT, _Traits, _Alloc1>\n+\tto_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const\n+\t{\n+\t  std::basic_string<_CharT, _Traits, _Alloc1> __result;\n+\t  _M_copy_to_string(__result, __zero, __one);\n+\t  return __result;\n+\t}\n+\n+      // Helper functions for string operations.\n+      template<typename _CharT, typename _Traits>\n+\tvoid\n+\t_M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,\n+\t\t\t _CharT, _CharT);\n+\n+      template<typename _CharT, typename _Traits, typename _Alloc1>\n+\tvoid\n+\t_M_copy_from_string(const std::basic_string<_CharT,\n+\t\t\t    _Traits, _Alloc1>& __str, size_t __pos, size_t __n,\n+\t\t\t    _CharT __zero = _CharT('0'),\n+\t\t\t    _CharT __one = _CharT('1'))\n+\t{ _M_copy_from_ptr<_CharT, _Traits>(__str.data(), __str.size(),\n+\t\t\t\t\t    __pos, __n, __zero, __one); }\n+\n+      template<typename _CharT, typename _Traits, typename _Alloc1>\n+\tvoid\n+\t_M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc1>& __str,\n+\t\t\t  _CharT __zero = _CharT('0'),\n+\t\t\t  _CharT __one = _CharT('1')) const;\n+\n+      /// Returns the number of bits which are set.\n+      size_type\n+      count() const\n+      { return this->_M_do_count(); }\n+\n+      /// Returns the total number of bits.\n+      size_type\n+      size() const\n+      { return this->_M_Nb; }\n+\n+      /// Returns the total number of blocks.\n+      size_type num_blocks() const\n+      { return this->_M_size(); }\n+\n+      /// Returns true if the dynamic_bitset is empty.\n+      bool\n+      empty() const\n+      { return (this->_M_Nb == 0); }\n+\n+      /// Returns the maximum size of a dynamic_bitset object having the same\n+      /// type as *this.\n+      /// The real answer is max() * bits_per_block but is likely to overflow.\n+      /*constexpr*/ size_type\n+      max_size() const\n+      { return std::numeric_limits<block_type>::max(); }\n+\n+      /**\n+       *  @brief Tests the value of a bit.\n+       *  @param  position  The index of a bit.\n+       *  @return  The value at @a pos.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      bool\n+      test(size_type __pos) const\n+      {\n+\tif (__pos >= _M_Nb)\n+\t  __throw_out_of_range(__N(\"dynamic_bitset::test\"));\n+\treturn _M_unchecked_test(__pos);\n+      }\n+\n+      /**\n+       *  @brief Tests whether all the bits are on.\n+       *  @return  True if all the bits are set.\n+       */\n+      bool\n+      all() const\n+      { return this->_M_are_all_aux() == _M_Nb; }\n+\n+      /**\n+       *  @brief Tests whether any of the bits are on.\n+       *  @return  True if at least one bit is set.\n+       */\n+      bool\n+      any() const\n+      { return this->_M_is_any(); }\n+\n+      /**\n+       *  @brief Tests whether any of the bits are on.\n+       *  @return  True if none of the bits are set.\n+       */\n+      bool\n+      none() const\n+      { return !this->_M_is_any(); }\n+\n+      //@{\n+      /// Self-explanatory.\n+      dynamic_bitset<_WordT, _Alloc>\n+      operator<<(size_type __pos) const\n+      { return dynamic_bitset<_WordT, _Alloc>(*this) <<= __pos; }\n+\n+      dynamic_bitset<_WordT, _Alloc>\n+      operator>>(size_type __pos) const\n+      { return dynamic_bitset<_WordT, _Alloc>(*this) >>= __pos; }\n+      //@}\n+\n+      /**\n+       *  @brief  Finds the index of the first \"on\" bit.\n+       *  @return  The index of the first bit set, or size() if not found.\n+       *  @sa  find_next\n+       */\n+      size_type\n+      find_first() const\n+      { return this->_M_do_find_first(this->_M_Nb); }\n+\n+      /**\n+       *  @brief  Finds the index of the next \"on\" bit after prev.\n+       *  @return  The index of the next bit set, or size() if not found.\n+       *  @param  prev  Where to start searching.\n+       *  @sa  find_first\n+       */\n+      size_type\n+      find_next(size_t __prev) const\n+      { return this->_M_do_find_next(__prev, this->_M_Nb); }\n+\n+      bool\n+      is_subset_of(const dynamic_bitset& __b) const\n+      { return this->_M_is_subset_of(__b); }\n+\n+      bool\n+      is_proper_subset_of(const dynamic_bitset& __b) const\n+      { return this->_M_is_proper_subset_of(__b); }\n+    };\n+\n+  // Definitions of non-inline member functions.\n+  template<typename _WordT, typename _Alloc>\n+    template<typename _CharT, typename _Traits>\n+      void\n+      dynamic_bitset<_WordT, _Alloc>::\n+      _M_copy_from_ptr(const _CharT* __str, size_t __len,\n+\t\t       size_t __pos, size_t __n, _CharT __zero, _CharT __one)\n+      {\n+\treset();\n+\tconst size_t __nbits = std::min(_M_Nb, std::min(__n, __len - __pos));\n+\tfor (size_t __i = __nbits; __i > 0; --__i)\n+\t  {\n+\t    const _CharT __c = __str[__pos + __nbits - __i];\n+\t    if (_Traits::eq(__c, __zero))\n+\t      ;\n+\t    else if (_Traits::eq(__c, __one))\n+\t      _M_unchecked_set(__i - 1);\n+\t    else\n+\t      __throw_invalid_argument(__N(\"dynamic_bitset::_M_copy_from_ptr\"));\n+\t  }\n+      }\n+\n+  template<typename _WordT, typename _Alloc>\n+    template<typename _CharT, typename _Traits, typename _Alloc1>\n+      void\n+      dynamic_bitset<_WordT, _Alloc>::\n+      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc1>& __str,\n+\t\t\t_CharT __zero, _CharT __one) const\n+      {\n+\t__str.assign(_M_Nb, __zero);\n+\tfor (size_t __i = _M_Nb; __i > 0; --__i)\n+\t  if (_M_unchecked_test(__i - 1))\n+\t    _Traits::assign(__str[_M_Nb - __i], __one);\n+      }\n+\n+\n+  //@{\n+  /// These comparisons for equality/inequality are, well, @e bitwise.\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return __lhs._M_is_equal(__rhs); }\n+\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator!=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return !__lhs._M_is_equal(__rhs); }\n+\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return __lhs._M_is_less(__rhs); }\n+\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator<=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return !(__lhs > __rhs); }\n+\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator>(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return __rhs < __lhs; }\n+\n+  template<typename _WordT, typename _Alloc>\n+    bool\n+    operator>=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+    { return !(__lhs < __rhs); }\n+  //@}\n+\n+  // 23.3.5.3 bitset operations:\n+  //@{\n+  /**\n+   *  @brief  Global bitwise operations on bitsets.\n+   *  @param  x  A bitset.\n+   *  @param  y  A bitset of the same size as @a x.\n+   *  @return  A new bitset.\n+   *\n+   *  These should be self-explanatory.\n+   */\n+  template<typename _WordT, typename _Alloc>\n+    inline dynamic_bitset<_WordT, _Alloc>\n+    operator&(const dynamic_bitset<_WordT, _Alloc>& __x,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __y)\n+    {\n+      dynamic_bitset<_WordT, _Alloc> __result(__x);\n+      __result &= __y;\n+      return __result;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    inline dynamic_bitset<_WordT, _Alloc>\n+    operator|(const dynamic_bitset<_WordT, _Alloc>& __x,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __y)\n+    {\n+      dynamic_bitset<_WordT, _Alloc> __result(__x);\n+      __result |= __y;\n+      return __result;\n+    }\n+\n+  template <typename _WordT, typename _Alloc>\n+    inline dynamic_bitset<_WordT, _Alloc>\n+    operator^(const dynamic_bitset<_WordT, _Alloc>& __x,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __y)\n+    {\n+      dynamic_bitset<_WordT, _Alloc> __result(__x);\n+      __result ^= __y;\n+      return __result;\n+    }\n+\n+  template <typename _WordT, typename _Alloc>\n+    inline dynamic_bitset<_WordT, _Alloc>\n+    operator-(const dynamic_bitset<_WordT, _Alloc>& __x,\n+\t      const dynamic_bitset<_WordT, _Alloc>& __y)\n+    {\n+      dynamic_bitset<_WordT, _Alloc> __result(__x);\n+      __result -= __y;\n+      return __result;\n+    }\n+  //@}\n+\n+  //@{\n+  /**\n+   *  @brief Global I/O operators for bitsets.\n+   *\n+   *  Direct I/O between streams and bitsets is supported.  Output is\n+   *  straightforward.  Input will skip whitespace and only accept '0'\n+   *  and '1' characters.  The %dynamic_bitset will grow as necessary\n+   *  to hold the string of bits.\n+   */\n+  template<typename _CharT, typename _Traits,\n+\t   typename _WordT, typename _Alloc>\n+    std::basic_istream<_CharT, _Traits>&\n+    operator>>(std::basic_istream<_CharT, _Traits>& __is,\n+\t       dynamic_bitset<_WordT, _Alloc>& __x)\n+    {\n+      typedef typename _Traits::char_type          char_type;\n+      typedef std::basic_istream<_CharT, _Traits>  __istream_type;\n+      typedef typename __istream_type::ios_base    __ios_base;\n+\n+      std::basic_string<_CharT, _Traits> __tmp;\n+      __tmp.reserve(__x.size());\n+\n+      const char_type __zero = __is.widen('0');\n+      const char_type __one = __is.widen('1');\n+\n+      typename __ios_base::iostate __state = __ios_base::goodbit;\n+      typename __istream_type::sentry __sentry(__is);\n+      if (__sentry)\n+\t{\n+\t  __try\n+\t    {\n+\t      while (1)\n+\t\t{\n+\t\t  static typename _Traits::int_type __eof = _Traits::eof();\n+\n+\t\t  typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();\n+\t\t  if (_Traits::eq_int_type(__c1, __eof))\n+\t\t    {\n+\t\t      __state |= __ios_base::eofbit;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      const char_type __c2 = _Traits::to_char_type(__c1);\n+\t\t      if (_Traits::eq(__c2, __zero))\n+\t\t\t__tmp.push_back(__zero);\n+\t\t      else if (_Traits::eq(__c2, __one))\n+\t\t\t__tmp.push_back(__one);\n+\t\t      else if (_Traits::\n+\t\t\t       eq_int_type(__is.rdbuf()->sputbackc(__c2),\n+\t\t\t\t\t   __eof))\n+\t\t\t{\n+\t\t\t  __state |= __ios_base::failbit;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  __catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __is._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n+\t  __catch(...)\n+\t    { __is._M_setstate(__ios_base::badbit); }\n+\t}\n+\n+      __x.resize(__tmp.size());\n+\n+      if (__tmp.empty() && __x.size())\n+\t__state |= __ios_base::failbit;\n+      else\n+\t__x._M_copy_from_string(__tmp, static_cast<size_t>(0), __x.size(),\n+\t\t\t\t__zero, __one);\n+      if (__state)\n+\t__is.setstate(__state);\n+      return __is;\n+    }\n+\n+  template <typename _CharT, typename _Traits,\n+\t    typename _WordT, typename _Alloc>\n+    std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t       const dynamic_bitset<_WordT, _Alloc>& __x)\n+    {\n+      std::basic_string<_CharT, _Traits> __tmp;\n+\n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT>>(__os.getloc());\n+      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));\n+      return __os << __tmp;\n+    }\n+  //@}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // tr2\n+} // std\n+\n+#undef _GLIBCXX_BITSET_BITS_PER_WORD\n+\n+#endif /* _GLIBCXX_TR2_DYNAMIC_BITSET */"}, {"sha": "34a9553c444675777313796b4abcabcccdb7b472", "filename": "libstdc++-v3/include/tr2/ratio", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fratio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fratio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fratio?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,59 @@\n+// TR2 <ratio> -*- C++ -*-\n+\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file tr2/ratio\n+ *  This is a TR2 C++ Library header.\n+ */\n+\n+#include <ratio>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace tr2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<intmax_t _Pn, size_t _Bit,\n+\t     bool = _Bit < static_cast<size_t>\n+\t\t\t  (std::numeric_limits<intmax_t>::digits)>\n+    struct __safe_lshift\n+    { static const intmax_t __value = 0; };\n+\n+    template<intmax_t _Pn, size_t _Bit>\n+      struct __safe_lshift<_Pn, _Bit, true>\n+      { static const intmax_t __value = _Pn << _Bit; };\n+\n+  /// Add binary prefixes (IEC 60027-2 A.2 and ISO/IEC 80000).\n+  typedef ratio<__safe_lshift<1, 10>::__value, 1> kibi;\n+  typedef ratio<__safe_lshift<1, 20>::__value, 1> mebi;\n+  typedef ratio<__safe_lshift<1, 30>::__value, 1> gibi;\n+  typedef ratio<__safe_lshift<1, 40>::__value, 1> tebi;\n+  typedef ratio<__safe_lshift<1, 50>::__value, 1> pebi;\n+  typedef ratio<__safe_lshift<1, 60>::__value, 1> exbi;\n+  //typedef ratio<__safe_lshift<1, 70>::__value, 1> zebi;\n+  //typedef ratio<__safe_lshift<1, 80>::__value, 1> yobi;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+}\n+}"}, {"sha": "73edf1137e41a0992549118d4f1e599333e258bd", "filename": "libstdc++-v3/include/tr2/type_traits", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Ftype_traits?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -1,4 +1,4 @@\n-// TR2 type_traits -*- C++ -*-\n+// TR2 <type_traits> -*- C++ -*-\n \n // Copyright (C) 2011 Free Software Foundation, Inc.\n //"}, {"sha": "096cdc06248bff72c6fc9c397ee22f7e7bf294df", "filename": "libstdc++-v3/testsuite/tr2/headers/all.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fall.cc?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tr2/type_traits>\n+#include <tr2/dynamic_bitset>\n+#include <tr2/bool_set>\n+#include <tr2/ratio>"}, {"sha": "b114327bb20171ed35572d8b00bb216c472208d8", "filename": "libstdc++-v3/testsuite/tr2/headers/using_namespace_std_tr2.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fusing_namespace_std_tr2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ef84f6c3041346d50c6a6ea2f54812e48963a7/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fusing_namespace_std_tr2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fheaders%2Fusing_namespace_std_tr2.cc?ref=24ef84f6c3041346d50c6a6ea2f54812e48963a7", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tr2/type_traits>\n+\n+namespace gnu\n+{\n+  using namespace std::tr2;\n+}"}]}