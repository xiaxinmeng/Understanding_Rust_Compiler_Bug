{"sha": "dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "node_id": "C_kwDOANBUbNoAKGRmZTJlZjdmMmI2Y2FjNzAxN2YzMmEwYTA0Zjc0ZTFiNmQ5ZjEzMTE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-06T23:24:16Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-06T23:24:16Z"}, "message": "analyzer: don't create bindings or binding keys for empty regions [PR107882]\n\nPR analyzer/107882 reports an ICE, due to trying to get a compound svalue\nfor this binding:\n\n  cluster for: a:\n    key:   {bytes 0-3}\n    value:  {UNKNOWN()}\n    key:   {empty}\n    value:  {UNKNOWN()}\n    key:   {bytes 4-7}\n    value:  {UNKNOWN()}\n\nwhere there's an binding to the unknown value of zero bits in size\n\"somewhere\" within \"a\" (perhaps between bits 3 and 4?)\n\nThis makes no sense, so this patch adds an assertion that we never\nattempt to create a binding key for an empty region, and adds early\nrejection of attempts to get or set the values of such regions, fixing\nthe ICE.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/107882\n\t* region-model.cc (region_model::get_store_value): Return an\n\tunknown value for empty regions.\n\t(region_model::set_value): Bail on empty regions.\n\t* region.cc (region::empty_p): New.\n\t* region.h (region::empty_p): New decl.\n\t* state-purge.cc (same_binding_p): Bail if either region is empty.\n\t* store.cc (binding_key::make): Assert that a concrete binding's\n\tbit_size must be > 0.\n\t(binding_cluster::mark_region_as_unknown): Bail on empty regions.\n\t(binding_cluster::get_binding): Likewise.\n\t(binding_cluster::remove_overlapping_bindings): Likewise.\n\t(binding_cluster::on_unknown_fncall): Don't conjure values for\n\tempty regions.\n\t(store::fill_region): Bail on empty regions.\n\t* store.h (class concrete_binding): Update comment to reflect that\n\tthe range of bits must be non-empty.\n\t(concrete_binding::concrete_binding): Assert that bit range is\n\tnon-empty.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/107882\n\t* gcc.dg/analyzer/memcpy-pr107882.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "ad0f486c15d0251b91323d06be965402bd95d680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad0f486c15d0251b91323d06be965402bd95d680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a23b93f944fa78d4284eb5687051c224e5ab08f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a23b93f944fa78d4284eb5687051c224e5ab08f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a23b93f944fa78d4284eb5687051c224e5ab08f"}], "stats": {"total": 72, "additions": 63, "deletions": 9}, "files": [{"sha": "18eaf22a5d19de388998528455b64f68bb4c5894", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -2321,6 +2321,10 @@ const svalue *\n region_model::get_store_value (const region *reg,\n \t\t\t       region_model_context *ctxt) const\n {\n+  /* Getting the value of an empty region gives an unknown_svalue.  */\n+  if (reg->empty_p ())\n+    return m_mgr->get_or_create_unknown_svalue (reg->get_type ());\n+\n   check_region_for_read (reg, ctxt);\n \n   /* Special-case: handle var_decls in the constant pool.  */\n@@ -3159,6 +3163,10 @@ region_model::set_value (const region *lhs_reg, const svalue *rhs_sval,\n   gcc_assert (lhs_reg);\n   gcc_assert (rhs_sval);\n \n+  /* Setting the value of an empty region is a no-op.  */\n+  if (lhs_reg->empty_p ())\n+    return;\n+\n   check_region_size (lhs_reg, rhs_sval, ctxt);\n \n   check_region_for_write (lhs_reg, ctxt);"}, {"sha": "67ba9486980b263478e3f3f9ea0284bd117d7df6", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -671,6 +671,18 @@ region::symbolic_p () const\n   return get_kind () == RK_SYMBOLIC;\n }\n \n+/* Return true if this region is known to be zero bits in size.  */\n+\n+bool\n+region::empty_p () const\n+{\n+  bit_size_t num_bits;\n+  if (get_bit_size (&num_bits))\n+    if (num_bits == 0)\n+      return true;\n+  return false;\n+}\n+\n /* Return true if this is a region for a decl with name DECL_NAME.\n    Intended for use when debugging (for assertions and conditional\n    breakpoints).  */"}, {"sha": "6d8bcfb8868a24ec8396926a77c92bd29e035e0d", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -233,6 +233,8 @@ class region\n \n   bool is_named_decl_p (const char *decl_name) const;\n \n+  bool empty_p () const;\n+\n  protected:\n   region (complexity c, unsigned id, const region *parent, tree type);\n "}, {"sha": "e9bcb4b0345478248ff079d718462a7521e0a5b3", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -813,7 +813,11 @@ same_binding_p (const region *reg_a, const region *reg_b,\n {\n   if (reg_a->get_base_region () != reg_b->get_base_region ())\n     return false;\n+  if (reg_a->empty_p ())\n+    return false;\n   const binding_key *bind_key_a = binding_key::make (store_mgr, reg_a);\n+  if (reg_b->empty_p ())\n+    return false;\n   const binding_key *bind_key_b = binding_key::make (store_mgr, reg_b);\n   return bind_key_a == bind_key_b;\n }"}, {"sha": "dd8ebaa73742779bcc242f173c8557ef5d980bb9", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -127,8 +127,12 @@ binding_key::make (store_manager *mgr, const region *r)\n     {\n       bit_size_t bit_size;\n       if (r->get_bit_size (&bit_size))\n-\treturn mgr->get_concrete_binding (offset.get_bit_offset (),\n-\t\t\t\t\t  bit_size);\n+\t{\n+\t  /* Must be non-empty.  */\n+\t  gcc_assert (bit_size > 0);\n+\t  return mgr->get_concrete_binding (offset.get_bit_offset (),\n+\t\t\t\t\t    bit_size);\n+\t}\n       else\n \treturn mgr->get_symbolic_binding (r);\n     }\n@@ -1464,6 +1468,9 @@ binding_cluster::mark_region_as_unknown (store_manager *mgr,\n \t\t\t\t\t const region *reg_for_overlap,\n \t\t\t\t\t uncertainty_t *uncertainty)\n {\n+  if (reg_to_bind->empty_p ())\n+    return;\n+\n   remove_overlapping_bindings (mgr, reg_for_overlap, uncertainty);\n \n   /* Add a default binding to \"unknown\".  */\n@@ -1516,6 +1523,8 @@ const svalue *\n binding_cluster::get_binding (store_manager *mgr,\n \t\t\t      const region *reg) const\n {\n+  if (reg->empty_p ())\n+    return NULL;\n   const binding_key *reg_binding = binding_key::make (mgr, reg);\n   const svalue *sval = m_map.get (reg_binding);\n   if (sval)\n@@ -1800,6 +1809,8 @@ binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t\t      const region *reg,\n \t\t\t\t\t      uncertainty_t *uncertainty)\n {\n+  if (reg->empty_p ())\n+    return;\n   const binding_key *reg_binding = binding_key::make (mgr, reg);\n \n   const region *cluster_base_reg = get_base_region ();\n@@ -2007,11 +2018,14 @@ binding_cluster::on_unknown_fncall (const gcall *call,\n     {\n       m_map.empty ();\n \n-      /* Bind it to a new \"conjured\" value using CALL.  */\n-      const svalue *sval\n-\t= mgr->get_svalue_manager ()->get_or_create_conjured_svalue\n+      if (!m_base_region->empty_p ())\n+\t{\n+\t  /* Bind it to a new \"conjured\" value using CALL.  */\n+\t  const svalue *sval\n+\t    = mgr->get_svalue_manager ()->get_or_create_conjured_svalue\n \t    (m_base_region->get_type (), call, m_base_region, p);\n-      bind (mgr, m_base_region, sval);\n+\t  bind (mgr, m_base_region, sval);\n+\t}\n \n       m_touched = true;\n     }\n@@ -2742,6 +2756,10 @@ store::purge_region (store_manager *mgr, const region *reg)\n void\n store::fill_region (store_manager *mgr, const region *reg, const svalue *sval)\n {\n+  /* Filling an empty region is a no-op.  */\n+  if (reg->empty_p ())\n+    return;\n+\n   const region *base_reg = reg->get_base_region ();\n   if (base_reg->symbolic_for_unknown_ptr_p ()\n       || !base_reg->tracked_p ())"}, {"sha": "30284eb78038f37b6305d01784c251e43c884062", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -356,8 +356,8 @@ struct byte_range\n   byte_size_t m_size_in_bytes;\n };\n \n-/* Concrete subclass of binding_key, for describing a concrete range of\n-   bits within the binding_map (e.g. \"bits 8-15\").  */\n+/* Concrete subclass of binding_key, for describing a non-empty\n+   concrete range of bits within the binding_map (e.g. \"bits 8-15\").  */\n \n class concrete_binding : public binding_key\n {\n@@ -367,7 +367,9 @@ class concrete_binding : public binding_key\n \n   concrete_binding (bit_offset_t start_bit_offset, bit_size_t size_in_bits)\n   : m_bit_range (start_bit_offset, size_in_bits)\n-  {}\n+  {\n+    gcc_assert (!m_bit_range.empty_p ());\n+  }\n   bool concrete_p () const final override { return true; }\n \n   hashval_t hash () const"}, {"sha": "4ecb0fd973f3f28ad0ba3b60f9d5acaadb771d65", "filename": "gcc/testsuite/gcc.dg/analyzer/memcpy-pr107882.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-pr107882.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-pr107882.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemcpy-pr107882.c?ref=dfe2ef7f2b6cac7017f32a0a04f74e1b6d9f1311", "patch": "@@ -0,0 +1,8 @@\n+void\n+foo (int *x, int y)\n+{\n+  int *a = x, *b = (int *) &a;\n+\n+  __builtin_memcpy (b + 1, x, y);\n+  foo (a, 0);\n+}"}]}