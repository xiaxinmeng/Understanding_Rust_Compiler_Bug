{"sha": "7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RmYzBmYmU1OWYwNzRlMjU0ZTZjMWIxMGUyYTYyMTU4MDQ0ZWZkMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-27T17:50:11Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-27T17:50:11Z"}, "message": "While building global lifetime information, keep track of which registers are only conditionally set.\n\nWhile building global lifetime information, keep track of which registers are\nonly conditionally set.  Use this to force rescans in more cases where they\nare needed.\n\nFrom-SVN: r37801", "tree": {"sha": "9edf3e2ab6d41894c57ae07bf83a362429fbfab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9edf3e2ab6d41894c57ae07bf83a362429fbfab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/comments", "author": null, "committer": null, "parents": [{"sha": "5f6fa212265d8d680e81467884395b475443c1b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6fa212265d8d680e81467884395b475443c1b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6fa212265d8d680e81467884395b475443c1b5"}], "stats": {"total": 97, "additions": 78, "deletions": 19}, "files": [{"sha": "1d540a957cf3c86f3cfa3e2b9dbf3063a607e0f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "patch": "@@ -1,3 +1,17 @@\n+2000-11-27  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* flow.c (entry_exit_blocks): Add entry for cond_local_set.\n+\t(struct propagate_block_info): Add new member cond_local_set.\n+\t(propagate_block): Accept new arg cond_local_set.  All callers\n+\tchanged.\n+\t(init_propagate_block_info): Likewise.\n+\t(calculate_global_regs_live): Allocate & free cond_local_set.  Always\n+\trescan if there's overlap between cond_local_set and new_live_at_end.\n+\t(mark_set_1): Set bits either in cond_local_set or local_set, as\n+\tappropriate.\n+\t* basic-block.h (struct basic_block_def): New field cond_local_set.\n+\t(propagate_block, init_propagate_block_info): Update prototypes.\n+\n Mon Nov 27 17:29:44 2000  kaz Kojima <kkojima@rr.iij4u.or.jp>\n \n \t* gcc/config/sh/sh.md (udivsi3_i4, udivsi3_i4_single): Clobber"}, {"sha": "1f6edf1cb9cdf2978aed8b77107a2a8b6cb7d5a5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "patch": "@@ -165,6 +165,7 @@ typedef struct basic_block_def {\n      not reflect the use of regs in phi functions, since the liveness\n      of these regs may depend on which edge was taken into the block.  */\n   regset local_set;\n+  regset cond_local_set;\n   regset global_live_at_start;\n   regset global_live_at_end;\n \n@@ -489,12 +490,13 @@ extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));\n extern int count_or_remove_death_notes\tPARAMS ((sbitmap, int));\n-extern void propagate_block\tPARAMS ((basic_block, regset, regset, int));\n+extern void propagate_block\tPARAMS ((basic_block, regset, regset, regset,\n+\t\t\t\t\t int));\n \n struct propagate_block_info;\n extern rtx propagate_one_insn\tPARAMS ((struct propagate_block_info *, rtx));\n extern struct propagate_block_info *init_propagate_block_info\n-  PARAMS ((basic_block, regset, regset, int));\n+  PARAMS ((basic_block, regset, regset, regset, int));\n extern void free_propagate_block_info PARAMS ((struct propagate_block_info *));\n \n /* In lcm.c */"}, {"sha": "0a20f4837e5e67fdb10c369472c190231fcd76a3", "filename": "gcc/flow.c", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "patch": "@@ -193,6 +193,7 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* pred */\n     NULL,\t\t\t/* succ */\n     NULL,\t\t\t/* local_set */\n+    NULL,\t\t\t/* cond_local_set */\n     NULL,\t\t\t/* global_live_at_start */\n     NULL,\t\t\t/* global_live_at_end */\n     NULL,\t\t\t/* aux */\n@@ -207,6 +208,7 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* pred */\n     NULL,\t\t\t/* succ */\n     NULL,\t\t\t/* local_set */\n+    NULL,\t\t\t/* cond_local_set */\n     NULL,\t\t\t/* global_live_at_start */\n     NULL,\t\t\t/* global_live_at_end */\n     NULL,\t\t\t/* aux */\n@@ -293,9 +295,14 @@ struct propagate_block_info\n      elimination.  */\n   rtx mem_set_list;\n \n-  /* If non-null, record the set of registers set in the basic block.  */\n+  /* If non-null, record the set of registers set unconditionally in the\n+     basic block.  */\n   regset local_set;\n \n+  /* If non-null, record the set of registers set conditionally in the\n+     basic block.  */\n+  regset cond_local_set;\n+\n #ifdef HAVE_conditional_execution\n   /* Indexed by register number, holds a reg_cond_life_info for each\n      register that is not unconditionally live or dead.  */\n@@ -1544,7 +1551,7 @@ split_block (bb, insn)\n \t at the end of the original basic block and get\n \t propagate_block to determine which registers are live.  */\n       COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_end);\n-      propagate_block (new_bb, new_bb->global_live_at_start, NULL, 0);\n+      propagate_block (new_bb, new_bb->global_live_at_start, NULL, NULL, 0);\n       COPY_REG_SET (bb->global_live_at_end, \n \t\t    new_bb->global_live_at_start);\n     }\n@@ -2966,7 +2973,7 @@ update_life_info (blocks, extent, prop_flags)\n \t  basic_block bb = BASIC_BLOCK (i);\n \n \t  COPY_REG_SET (tmp, bb->global_live_at_end);\n-\t  propagate_block (bb, tmp, (regset) NULL, prop_flags);\n+\t  propagate_block (bb, tmp, NULL, NULL, prop_flags);\n \n \t  if (extent == UPDATE_LIFE_LOCAL)\n \t    verify_local_live_at_start (tmp, bb);\n@@ -2979,7 +2986,7 @@ update_life_info (blocks, extent, prop_flags)\n \t  basic_block bb = BASIC_BLOCK (i);\n \n \t  COPY_REG_SET (tmp, bb->global_live_at_end);\n-\t  propagate_block (bb, tmp, (regset) NULL, prop_flags);\n+\t  propagate_block (bb, tmp, NULL, NULL, prop_flags);\n \n \t  if (extent == UPDATE_LIFE_LOCAL)\n \t    verify_local_live_at_start (tmp, bb);\n@@ -3378,6 +3385,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n       if (bb->local_set == NULL)\n \t{\n \t  bb->local_set = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  bb->cond_local_set = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n \t  rescan = 1;\n \t}\n       else\n@@ -3390,6 +3398,20 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t  rescan = bitmap_operation (tmp, bb->global_live_at_end,\n \t\t\t\t     new_live_at_end, BITMAP_AND_COMPL);\n \n+\t  if (! rescan)\n+\t    {\n+\t      /* If any of the registers in the new live_at_end set are\n+\t\t conditionally set in this basic block, we must rescan.\n+\t         This is because conditional lifetimes at the end of the\n+\t\t block do not just take the live_at_end set into account,\n+\t\t but also the liveness at the start of each successor\n+\t\t block.  We can miss changes in those sets if we only\n+\t\t compare the new live_at_end against the previous one.  */\n+\t      CLEAR_REG_SET (tmp);\n+\t      rescan = bitmap_operation (tmp, new_live_at_end,\n+\t\t\t\t\t bb->cond_local_set, BITMAP_AND);\n+\t    }\n+\n \t  if (! rescan)\n \t    {\n \t      /* Find the set of changed bits.  Take this opportunity\n@@ -3434,7 +3456,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n \t  /* Rescan the block insn by insn to turn (a copy of) live_at_end\n \t     into live_at_start.  */\n-\t  propagate_block (bb, new_live_at_end, bb->local_set, flags);\n+\t  propagate_block (bb, new_live_at_end, bb->local_set,\n+\t\t\t   bb->cond_local_set, flags);\n \n \t  /* If live_at start didn't change, no need to go farther.  */\n \t  if (REG_SET_EQUAL_P (bb->global_live_at_start, new_live_at_end))\n@@ -3467,6 +3490,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n \t  FREE_REG_SET (bb->local_set);\n+\t  FREE_REG_SET (bb->cond_local_set);\n \t});\n     }\n   else\n@@ -3475,6 +3499,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n \t  FREE_REG_SET (bb->local_set);\n+\t  FREE_REG_SET (bb->cond_local_set);\n \t}\n     }\n \n@@ -3811,10 +3836,9 @@ propagate_one_insn (pbi, insn)\n    the user can use the regsets provided here.  */\n \n struct propagate_block_info *\n-init_propagate_block_info (bb, live, local_set, flags)\n+init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n      basic_block bb;\n-     regset live;\n-     regset local_set;\n+     regset live, local_set, cond_local_set;\n      int flags;\n {\n   struct propagate_block_info *pbi = xmalloc (sizeof (*pbi));\n@@ -3823,6 +3847,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n   pbi->reg_live = live;\n   pbi->mem_set_list = NULL_RTX;\n   pbi->local_set = local_set;\n+  pbi->cond_local_set = cond_local_set;\n   pbi->cc0_live = 0;\n   pbi->flags = flags;\n \n@@ -4000,20 +4025,28 @@ free_propagate_block_info (pbi)\n    When called, REG_LIVE contains those live at the end.  On return, it\n    contains those live at the beginning.\n \n-   LOCAL_SET, if non-null, will be set with all registers killed by\n-   this basic block.  */\n+   LOCAL_SET, if non-null, will be set with all registers killed\n+   unconditionally by this basic block.\n+   Likewise, COND_LOCAL_SET, if non-null, will be set with all registers\n+   killed conditionally by this basic block.  If there is any unconditional\n+   set of a register, then the corresponding bit will be set in LOCAL_SET\n+   and cleared in COND_LOCAL_SET.\n+   It is valid for LOCAL_SET and COND_LOCAL_SET to be the same set.  In this\n+   case, the resulting set will be equal to the union of the two sets that\n+   would otherwise be computed.  */\n \n void\n-propagate_block (bb, live, local_set, flags)\n+propagate_block (bb, live, local_set, cond_local_set, flags)\n      basic_block bb;\n      regset live;\n      regset local_set;\n+     regset cond_local_set;\n      int flags;\n {\n   struct propagate_block_info *pbi;\n   rtx insn, prev;\n \n-  pbi = init_propagate_block_info (bb, live, local_set, flags);\n+  pbi = init_propagate_block_info (bb, live, local_set, cond_local_set, flags);\n \n   if (flags & PROP_REG_INFO)\n     {\n@@ -4635,7 +4668,16 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t{\n \t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, i);\n \t  if (pbi->local_set)\n-\t    SET_REGNO_REG_SET (pbi->local_set, i);\n+\t    {\n+\t      /* Order of the set operation matters here since both\n+\t\t sets may be the same.  */\n+\t      CLEAR_REGNO_REG_SET (pbi->cond_local_set, i);\n+\t      if (cond != NULL_RTX\n+\t\t  && ! REGNO_REG_SET_P (pbi->local_set, i))\n+\t\tSET_REGNO_REG_SET (pbi->cond_local_set, i);\n+\t      else\n+\t\tSET_REGNO_REG_SET (pbi->local_set, i);\n+\t    }\n \t  if (code != CLOBBER)\n \t    SET_REGNO_REG_SET (pbi->new_set, i);\n "}, {"sha": "e4955a74477a783b95855a10504ba8c1c849037b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "patch": "@@ -1973,7 +1973,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n       /* ??? bb->local_set is only valid during calculate_global_regs_live,\n \t so we must recompute usage for MERGE_BB.  Not so bad, I suppose, \n          since we've already asserted that MERGE_BB is small.  */\n-      propagate_block (merge_bb, tmp, merge_set, 0);\n+      propagate_block (merge_bb, tmp, merge_set, merge_set, 0);\n \n       /* For small register class machines, don't lengthen lifetimes of\n \t hard registers before reload.  */\n@@ -1993,7 +1993,8 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n \t Moreover, we're interested in the insns live from OTHER_BB.  */\n \n       COPY_REG_SET (test_live, other_bb->global_live_at_start);\n-      pbi = init_propagate_block_info (test_bb, test_live, test_set, 0);\n+      pbi = init_propagate_block_info (test_bb, test_live, test_set, test_set,\n+\t\t\t\t       0);\n \n       for (insn = jump; ; insn = prev)\n \t{"}, {"sha": "4257d7c08c0547d2b42d3b4b0fb90d16fec5034f", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfc0fbe59f074e254e6c1b10e2a62158044efd3/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7dfc0fbe59f074e254e6c1b10e2a62158044efd3", "patch": "@@ -3053,9 +3053,9 @@ peephole2_optimize (dump_file)\n       COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n \n #ifdef HAVE_conditional_execution\n-      pbi = init_propagate_block_info (bb, live, NULL, 0);\n+      pbi = init_propagate_block_info (bb, live, NULL, NULL, 0);\n #else\n-      pbi = init_propagate_block_info (bb, live, NULL, PROP_DEATH_NOTES);\n+      pbi = init_propagate_block_info (bb, live, NULL, NULL, PROP_DEATH_NOTES);\n #endif\n \n       for (insn = bb->end; ; insn = prev)"}]}