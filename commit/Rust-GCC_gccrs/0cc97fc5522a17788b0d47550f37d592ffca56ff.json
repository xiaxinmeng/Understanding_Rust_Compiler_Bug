{"sha": "0cc97fc5522a17788b0d47550f37d592ffca56ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNjOTdmYzU1MjJhMTc3ODhiMGQ0NzU1MGYzN2Q1OTJmZmNhNTZmZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-09-09T15:10:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-09-09T15:10:39Z"}, "message": "struct ira_reg_equiv_s's \"init_insns\" is an rtx_insn_list\n\ngcc/ChangeLog:\n2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n\n\t* ira.c (ira_update_equiv_info_by_shuffle_insn): Use NULL rather\n\tthan NULL_RTX.\n\t(no_equiv): Likewise.\n\t(update_equiv_regs): Likewise.\n\t(setup_reg_equiv): Likewise.  Strengthen locals \"elem\",\n\t\"prev_elem\", \"next_elem\" from rtx to rtx_insn_list *, and \"insn\"\n\tfrom rtx to rtx_insn *.  Use methods of \"elem\" for typesafety and\n\tclarity.\n\t* ira.h (struct ira_reg_equiv_s): Strengthen field \"init_insns\"\n\tfrom rtx to rtx_insn_list *.\n\t* lra-assigns.c (spill_for): Strengthen local \"x\" from rtx to\n\trtx_insn_list * and use methods for clarity and typesafety.\n\t* lra-constraints.c (contains_deleted_insn_p): Likewise for param\n\t\"list\".\n\t(init_insn_rhs_dead_pseudo_p): Likewise for local \"insns\".  Remove\n\tredundant check on INSN_P (insns): this cannot hold, as \"insns\" is\n\tan INSN_LIST, not an insn.\n\t(reverse_equiv_p): Strengthen local \"insns\" from rtx to\n\trtx_insn_list * and use methods for clarity and typesafety.\n\t(contains_reloaded_insn_p): Likewise for local \"list\".\n\nFrom-SVN: r215082", "tree": {"sha": "9fc7a0c191becf6398b01c789e1d25eaa063ba97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fc7a0c191becf6398b01c789e1d25eaa063ba97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cc97fc5522a17788b0d47550f37d592ffca56ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc97fc5522a17788b0d47550f37d592ffca56ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cc97fc5522a17788b0d47550f37d592ffca56ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc97fc5522a17788b0d47550f37d592ffca56ff/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fcad3635f9cc635ebdd1f5b7ae2cd1586ac4511c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcad3635f9cc635ebdd1f5b7ae2cd1586ac4511c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcad3635f9cc635ebdd1f5b7ae2cd1586ac4511c"}], "stats": {"total": 82, "additions": 53, "deletions": 29}, "files": [{"sha": "4427243913f8257832b1a6d9bd6a252189d95040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cc97fc5522a17788b0d47550f37d592ffca56ff", "patch": "@@ -1,3 +1,26 @@\n+2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ira.c (ira_update_equiv_info_by_shuffle_insn): Use NULL rather\n+\tthan NULL_RTX.\n+\t(no_equiv): Likewise.\n+\t(update_equiv_regs): Likewise.\n+\t(setup_reg_equiv): Likewise.  Strengthen locals \"elem\",\n+\t\"prev_elem\", \"next_elem\" from rtx to rtx_insn_list *, and \"insn\"\n+\tfrom rtx to rtx_insn *.  Use methods of \"elem\" for typesafety and\n+\tclarity.\n+\t* ira.h (struct ira_reg_equiv_s): Strengthen field \"init_insns\"\n+\tfrom rtx to rtx_insn_list *.\n+\t* lra-assigns.c (spill_for): Strengthen local \"x\" from rtx to\n+\trtx_insn_list * and use methods for clarity and typesafety.\n+\t* lra-constraints.c (contains_deleted_insn_p): Likewise for param\n+\t\"list\".\n+\t(init_insn_rhs_dead_pseudo_p): Likewise for local \"insns\".  Remove\n+\tredundant check on INSN_P (insns): this cannot hold, as \"insns\" is\n+\tan INSN_LIST, not an insn.\n+\t(reverse_equiv_p): Strengthen local \"insns\" from rtx to\n+\trtx_insn_list * and use methods for clarity and typesafety.\n+\t(contains_reloaded_insn_p): Likewise for local \"list\".\n+\n 2014-09-09  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/arm/arm.c (NEON_COPYSIGNF): New enum."}, {"sha": "a04ec2b38bc7a4acddeb6936c9b94af18ad2b797", "filename": "gcc/ira.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=0cc97fc5522a17788b0d47550f37d592ffca56ff", "patch": "@@ -2605,7 +2605,7 @@ ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx_insn *i\n       ira_reg_equiv[to_regno].memory\n \t= ira_reg_equiv[to_regno].constant\n \t= ira_reg_equiv[to_regno].invariant\n-\t= ira_reg_equiv[to_regno].init_insns = NULL_RTX;\n+\t= ira_reg_equiv[to_regno].init_insns = NULL;\n       if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file,\n \t\t \"      Invalidating equiv info for reg %d\\n\", to_regno);\n@@ -3259,7 +3259,7 @@ no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED,\n   if (reg_equiv[regno].is_arg_equivalence)\n     return;\n   ira_reg_equiv[regno].defined_p = false;\n-  ira_reg_equiv[regno].init_insns = NULL_RTX;\n+  ira_reg_equiv[regno].init_insns = NULL;\n   for (; list; list =  XEXP (list, 1))\n     {\n       rtx insn = XEXP (list, 0);\n@@ -3732,7 +3732,7 @@ update_equiv_regs (void)\n \t\t      reg_equiv[regno].init_insns\n \t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n \n-\t\t      ira_reg_equiv[regno].init_insns = NULL_RTX;\n+\t\t      ira_reg_equiv[regno].init_insns = NULL;\n \t\t      bitmap_set_bit (cleared_regs, regno);\n \t\t    }\n \t\t  /* Move the initialization of the register to just before\n@@ -3820,15 +3820,17 @@ static void\n setup_reg_equiv (void)\n {\n   int i;\n-  rtx elem, prev_elem, next_elem, insn, set, x;\n+  rtx_insn_list *elem, *prev_elem, *next_elem;\n+  rtx_insn *insn;\n+  rtx set, x;\n \n   for (i = FIRST_PSEUDO_REGISTER; i < ira_reg_equiv_len; i++)\n     for (prev_elem = NULL, elem = ira_reg_equiv[i].init_insns;\n \t elem;\n \t prev_elem = elem, elem = next_elem)\n       {\n-\tnext_elem = XEXP (elem, 1);\n-\tinsn = XEXP (elem, 0);\n+\tnext_elem = elem->next ();\n+\tinsn = elem->insn ();\n \tset = single_set (insn);\n \t\n \t/* Init insns can set up equivalence when the reg is a destination or\n@@ -3897,7 +3899,7 @@ setup_reg_equiv (void)\n \t\t\tif (ira_reg_equiv[i].memory == NULL_RTX)\n \t\t\t  {\n \t\t\t    ira_reg_equiv[i].defined_p = false;\n-\t\t\t    ira_reg_equiv[i].init_insns = NULL_RTX;\n+\t\t\t    ira_reg_equiv[i].init_insns = NULL;\n \t\t\t    break;\n \t\t\t  }\n \t\t      }\n@@ -3907,7 +3909,7 @@ setup_reg_equiv (void)\n \t      }\n \t  }\n \tira_reg_equiv[i].defined_p = false;\n-\tira_reg_equiv[i].init_insns = NULL_RTX;\n+\tira_reg_equiv[i].init_insns = NULL;\n \tbreak;\n       }\n }"}, {"sha": "66030d6f00b9fc67222e07256adbb077f2e6f9a6", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=0cc97fc5522a17788b0d47550f37d592ffca56ff", "patch": "@@ -166,7 +166,7 @@ struct ira_reg_equiv_s\n   rtx constant;\n   rtx invariant;\n   /* Always NULL_RTX if defined_p is false.  */\n-  rtx init_insns;\n+  rtx_insn_list *init_insns;\n };\n \n /* The length of the following array.  */"}, {"sha": "c7164cde68c81736a7d55dd5272ff7ff3bfc02a3", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=0cc97fc5522a17788b0d47550f37d592ffca56ff", "patch": "@@ -951,15 +951,15 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t    }\n \t  EXECUTE_IF_SET_IN_BITMAP (&spill_pseudos_bitmap, 0, spill_regno, bi)\n \t    {\n-\t      rtx x;\n+\t      rtx_insn_list *x;\n \n \t      cost += lra_reg_info[spill_regno].freq;\n \t      if (ira_reg_equiv[spill_regno].memory != NULL\n \t\t  || ira_reg_equiv[spill_regno].constant != NULL)\n \t\tfor (x = ira_reg_equiv[spill_regno].init_insns;\n \t\t     x != NULL;\n-\t\t     x = XEXP (x, 1))\n-\t\t  cost -= REG_FREQ_FROM_BB (BLOCK_FOR_INSN (XEXP (x, 0)));\n+\t\t     x = x->next ())\n+\t\t  cost -= REG_FREQ_FROM_BB (BLOCK_FOR_INSN (x->insn ()));\n \t    }\n \t  if (best_insn_pseudos_num > insn_pseudos_num\n \t      || (best_insn_pseudos_num == insn_pseudos_num"}, {"sha": "d5287d1d50da65058a6eabbcaeaf14df1e602beb", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc97fc5522a17788b0d47550f37d592ffca56ff/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=0cc97fc5522a17788b0d47550f37d592ffca56ff", "patch": "@@ -3897,11 +3897,11 @@ multi_block_pseudo_p (int regno)\n \n /* Return true if LIST contains a deleted insn.  */\n static bool\n-contains_deleted_insn_p (rtx list)\n+contains_deleted_insn_p (rtx_insn_list *list)\n {\n-  for (; list != NULL_RTX; list = XEXP (list, 1))\n-    if (NOTE_P (XEXP (list, 0))\n-\t&& NOTE_KIND (XEXP (list, 0)) == NOTE_INSN_DELETED)\n+  for (; list != NULL_RTX; list = list->next ())\n+    if (NOTE_P (list->insn ())\n+\t&& NOTE_KIND (list->insn ()) == NOTE_INSN_DELETED)\n       return true;\n   return false;\n }\n@@ -3952,14 +3952,12 @@ insn_rhs_dead_pseudo_p (rtx insn)\n static bool\n init_insn_rhs_dead_pseudo_p (int regno)\n {\n-  rtx insns = ira_reg_equiv[regno].init_insns;\n+  rtx_insn_list *insns = ira_reg_equiv[regno].init_insns;\n \n   if (insns == NULL)\n     return false;\n-  if (INSN_P (insns))\n-    return insn_rhs_dead_pseudo_p (insns);\n-  for (; insns != NULL_RTX; insns = XEXP (insns, 1))\n-    if (insn_rhs_dead_pseudo_p (XEXP (insns, 0)))\n+  for (; insns != NULL_RTX; insns = insns->next ())\n+    if (insn_rhs_dead_pseudo_p (insns->insn ()))\n       return true;\n   return false;\n }\n@@ -3970,14 +3968,15 @@ init_insn_rhs_dead_pseudo_p (int regno)\n static bool\n reverse_equiv_p (int regno)\n {\n-  rtx insns, set;\n+  rtx_insn_list *insns = ira_reg_equiv[regno].init_insns;\n+  rtx set;\n \n-  if ((insns = ira_reg_equiv[regno].init_insns) == NULL_RTX)\n+  if (insns == NULL)\n     return false;\n-  if (! INSN_P (XEXP (insns, 0))\n-      || XEXP (insns, 1) != NULL_RTX)\n+  if (! INSN_P (insns->insn ())\n+      || insns->next () != NULL)\n     return false;\n-  if ((set = single_set (XEXP (insns, 0))) == NULL_RTX)\n+  if ((set = single_set (insns->insn ())) == NULL_RTX)\n     return false;\n   return REG_P (SET_SRC (set)) && (int) REGNO (SET_SRC (set)) == regno;\n }\n@@ -3988,10 +3987,10 @@ static bool\n contains_reloaded_insn_p (int regno)\n {\n   rtx set;\n-  rtx list = ira_reg_equiv[regno].init_insns;\n+  rtx_insn_list *list = ira_reg_equiv[regno].init_insns;\n \n-  for (; list != NULL_RTX; list = XEXP (list, 1))\n-    if ((set = single_set (XEXP (list, 0))) == NULL_RTX\n+  for (; list != NULL; list = list->next ())\n+    if ((set = single_set (list->insn ())) == NULL_RTX\n \t|| ! REG_P (SET_DEST (set))\n \t|| (int) REGNO (SET_DEST (set)) != regno)\n       return true;"}]}