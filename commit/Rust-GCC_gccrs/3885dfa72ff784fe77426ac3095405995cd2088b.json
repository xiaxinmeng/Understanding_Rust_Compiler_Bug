{"sha": "3885dfa72ff784fe77426ac3095405995cd2088b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4NWRmYTcyZmY3ODRmZTc3NDI2YWMzMDk1NDA1OTk1Y2QyMDg4Yg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-12T16:15:14Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-12T16:15:14Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r23619", "tree": {"sha": "d98e5cd3ad30257d857723c5c28e2f93f5f3b702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d98e5cd3ad30257d857723c5c28e2f93f5f3b702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3885dfa72ff784fe77426ac3095405995cd2088b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3885dfa72ff784fe77426ac3095405995cd2088b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3885dfa72ff784fe77426ac3095405995cd2088b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3885dfa72ff784fe77426ac3095405995cd2088b/comments", "author": null, "committer": null, "parents": [{"sha": "421fb0858d68eedf410a1d0ba9ec7176d112e94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421fb0858d68eedf410a1d0ba9ec7176d112e94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421fb0858d68eedf410a1d0ba9ec7176d112e94c"}], "stats": {"total": 825, "additions": 741, "deletions": 84}, "files": [{"sha": "c88463c16864abb677db76d081fc1e42a1fbc425", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 741, "deletions": 84, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3885dfa72ff784fe77426ac3095405995cd2088b/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3885dfa72ff784fe77426ac3095405995cd2088b/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=3885dfa72ff784fe77426ac3095405995cd2088b", "patch": "@@ -23,6 +23,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include <string.h>\n #include \"tree.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n@@ -112,6 +113,8 @@ struct jcf_block\n \n   int linenumber;\n \n+  /* After finish_jcf_block is called, The actual instructions contained in this block.\n+     Before than NULL, and the instructions are in state->bytecode. */\n   struct chunk *chunk;\n \n   union {\n@@ -124,20 +127,27 @@ struct jcf_block\n   } u;\n };\n \n+#define SWITCH_ALIGN_RELOC 4\n+#define BLOCK_START_RELOC 1\n+\n struct jcf_relocation\n {\n   /* Next relocation for the current jcf_block. */\n   struct jcf_relocation *next;\n \n   /* The (byte) offset within the current block that needs to be relocated. */\n-  int offset;\n+  HOST_WIDE_INT offset;\n \n   /* 0 if offset is a 4-byte relative offset.\n+     4 (SWITCH_ALIGN_RELOC) if offset points to 0-3 padding bytes inserted\n+     for proper alignment in tableswitch/lookupswitch instructions.\n+     1 (BLOCK_START_RELOC) if offset points to a 4-byte offset relative\n+     to the start of the containing block.\n      -1 if offset is a 2-byte relative offset.\n-     < 0 if offset is the address of an instruction with a 2-byte offset\n+     < -1 if offset is the address of an instruction with a 2-byte offset\n      that does not have a corresponding 4-byte offset version, in which\n      case the absolute value of kind is the inverted opcode.\n-     > 0 if offset is the address of an instruction (such as jsr) with a\n+     > 4 if offset is the address of an instruction (such as jsr) with a\n      2-byte offset that does have a corresponding 4-byte offset version,\n      in which case kind is the opcode of the 4-byte version (such as jsr_w). */\n   int kind;\n@@ -146,6 +156,32 @@ struct jcf_relocation\n   struct jcf_block *label;\n };\n \n+/* State for single catch clause. */\n+\n+struct jcf_handler\n+{\n+  struct jcf_handler *next;\n+\n+  struct jcf_block *start_label;\n+  struct jcf_block *end_label;\n+  struct jcf_block *handler_label;\n+\n+  /* The sub-class of Throwable handled, or NULL_TREE (for finally). */\n+  tree type;\n+};\n+\n+/* State for the current switch statement. */\n+\n+struct jcf_switch_state\n+{\n+  struct jcf_switch_state *prev;\n+  struct jcf_block *default_label;\n+\n+  struct jcf_relocation *cases;\n+  int num_cases;\n+  HOST_WIDE_INT min_case, max_case;\n+};\n+\n /* This structure is used to contain the various pieces that will\n    become a .class file. */\n \n@@ -186,6 +222,18 @@ struct jcf_partial\n \n   /* The buffer allocated for bytecode for the current jcf_block. */\n   struct buffer bytecode;\n+\n+  /* Chain of exception handlers for the current method. */\n+  struct jcf_handler *handlers;\n+\n+  /* Last element in handlers chain. */\n+  struct jcf_handler *last_handler;\n+\n+  /* Number of exception handlers for the current method. */\n+  int num_handlers;\n+\n+  /* Information about the current switch statemenet. */\n+  struct jcf_switch_state *sw_state;\n };\n \n static void generate_bytecode_insns PROTO ((tree, int, struct jcf_partial *));\n@@ -197,7 +245,7 @@ static void generate_bytecode_insns PROTO ((tree, int, struct jcf_partial *));\n #define PUT1(X)  (*ptr++ = (X))\n #define PUT2(X)  (PUT1((X) >> 8), PUT1((X) & 0xFF))\n #define PUT4(X)  (PUT2((X) >> 16), PUT2((X) & 0xFFFF))\n-#define PUTN(P, N)  (bcopy(P, ptr, N), ptr += (N))\n+#define PUTN(P, N)  (memcpy(ptr, P, N), ptr += (N))\n \n \f\n /* Allocate a new chunk on obstack WORK, and link it in after LAST.\n@@ -244,7 +292,7 @@ append_chunk_copy (data, size, state)\n      struct jcf_partial *state;\n {\n   unsigned char *ptr = append_chunk (NULL, size, state);\n-  bcopy (data, ptr, size);\n+  memcpy (ptr, data, size);\n }\n \f\n struct jcf_block *\n@@ -265,9 +313,9 @@ finish_jcf_block (state)\n {\n   struct jcf_block *block = state->last_block;\n   struct jcf_relocation *reloc;\n+  int code_length = BUFFER_LENGTH (&state->bytecode);\n   int pc = state->code_length;\n-  append_chunk_copy (state->bytecode.data, BUFFER_LENGTH (&state->bytecode),\n-\t\t     state);\n+  append_chunk_copy (state->bytecode.data, code_length, state);\n   BUFFER_RESET (&state->bytecode);\n   block->chunk = state->chunk;\n \n@@ -276,7 +324,9 @@ finish_jcf_block (state)\n   for (reloc = block->u.relocations;  reloc != NULL;  reloc = reloc->next)\n     {\n       int kind = reloc->kind;\n-      if (kind > 0)\n+      if (kind == SWITCH_ALIGN_RELOC)\n+\tpc += 3;\n+      else if (kind > BLOCK_START_RELOC)\n \tpc += 2; /* 2-byte offset may grow to 4-byte offset */\n       else if (kind < -1)\n \tpc += 5; /* May need to add a goto_w. */\n@@ -326,6 +376,30 @@ put_linenumber (line, state)\n   state->linenumber_count++;\n }\n \n+/* Allocate a new jcf_handler, for a catch clause that catches exceptions\n+   in the range (START_LABEL, END_LABEL). */\n+\n+static struct jcf_handler *\n+alloc_handler (start_label, end_label, state)\n+     struct jcf_block *start_label;\n+     struct jcf_block *end_label;\n+     struct jcf_partial *state;\n+{\n+  struct jcf_handler *handler = (struct jcf_handler *)\n+    obstack_alloc (state->chunk_obstack, sizeof (struct jcf_handler));\n+  handler->start_label = start_label;\n+  handler->end_label = end_label;\n+  handler->handler_label = get_jcf_label_here (state);\n+  if (state->handlers == NULL)\n+    state->handlers = handler;\n+  else\n+    state->last_handler->next = handler;\n+  state->last_handler = handler;\n+  handler->next = NULL;\n+  state->num_handlers++;\n+  return handler;\n+}\n+\n \f\n /* The index of jvm local variable allocated for this DECL.\n    This is assigned when generating .class files;\n@@ -347,7 +421,7 @@ struct localvar_info\n #define localvar_max \\\n   ((struct localvar_info**) state->localvars.ptr - localvar_buffer)\n \n-void\n+int\n localvar_alloc (decl, state)\n      tree decl;\n      struct jcf_partial *state;\n@@ -403,6 +477,7 @@ localvar_free (decl, state)\n   register struct localvar_info **ptr = &localvar_buffer [index];\n   register struct localvar_info *info = *ptr;\n   int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n+  int i;\n \n   info->end_label = end_label;\n \n@@ -493,6 +568,7 @@ push_constant1 (index, state)\n      int index;\n      struct jcf_partial *state;\n {\n+  RESERVE (3);\n   if (index < 256)\n     {\n       OP1 (OPCODE_ldc);\n@@ -540,7 +616,7 @@ push_int_const (i, state)\n   else\n     {\n       i = find_constant1 (&state->cpool, CONSTANT_Integer, i & 0xFFFFFFFF);\n-      push_constant1 (i);\n+      push_constant1 (i, state);\n     }\n }\n \n@@ -557,21 +633,19 @@ push_long_const (lo, hi, state)\n       RESERVE(1);\n       OP1(OPCODE_lconst_0 + lo);\n     }\n-#if 0\n-    else if ((jlong) (jint) i == i)\n+  else if ((hi == 0 && lo < 32768) || (hi == -1 && lo >= -32768))\n       {\n-        push_int_const ((jint) i, state);\n+        push_int_const (lo, state);\n         RESERVE (1);\n         OP1 (OPCODE_i2l);\n       }\n-#endif\n   else\n     {\n       HOST_WIDE_INT w1, w2;\n       lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n-      hi = find_constant1 (&state->cpool, CONSTANT_Long,\n+      hi = find_constant2 (&state->cpool, CONSTANT_Long,\n \t\t\t   w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);\n-      push_constant2 (hi);\n+      push_constant2 (hi, state);\n     }\n }\n \n@@ -592,22 +666,23 @@ field_op (field, opcode, state)\n    opcodes typically depend on the operand type. */\n \n int\n-adjust_typed_op (type)\n+adjust_typed_op (type, max)\n      tree type;\n+     int max;\n {\n   switch (TREE_CODE (type))\n     {\n     case POINTER_TYPE:\n     case RECORD_TYPE:   return 4;\n     case BOOLEAN_TYPE:\n-      return TYPE_PRECISION (type) == 32 ? 0 : 5;\n+      return TYPE_PRECISION (type) == 32 || max < 5 ? 0 : 5;\n     case CHAR_TYPE:\n-      return TYPE_PRECISION (type) == 32 ? 0 : 6;\n+      return TYPE_PRECISION (type) == 32 || max < 6 ? 0 : 6;\n     case INTEGER_TYPE:\n       switch (TYPE_PRECISION (type))\n \t{\n-\tcase  8:       return 5;\n-\tcase 16:       return 7;\n+\tcase  8:       return max < 5 ? 0 : 5;\n+\tcase 16:       return max < 7 ? 0 : 7;\n \tcase 32:       return 0;\n \tcase 64:       return 1;\n \t}\n@@ -619,6 +694,8 @@ adjust_typed_op (type)\n \tcase 64:       return 3;\n \t}\n       break;\n+    default:\n+      break;\n     }\n   abort ();\n }\n@@ -705,19 +782,20 @@ emit_iinc (var, value, state)\n \n static void\n emit_load_or_store (var, opcode, state)\n-     tree var;\n+     tree var;    /* Variable to load from or store into. */\n+     int opcode;  /* Either OPCODE_iload or OPCODE_istore. */\n      struct jcf_partial *state;\n {\n   tree type = TREE_TYPE (var);\n-  int kind = adjust_typed_op (type);\n+  int kind = adjust_typed_op (type, 4);\n   int index = DECL_LOCAL_INDEX (var);\n   if (index <= 3)\n     {\n       RESERVE (1);\n       OP1 (opcode + 5 + 4 * kind + index);    /* [ilfda]{load,store}_[0123] */\n     }\n   else\n-    maybe_wide (opcode + kind, index);  /* [ilfda]{load,store} */\n+    maybe_wide (opcode + kind, index, state);  /* [ilfda]{load,store} */\n }\n \n static void\n@@ -738,6 +816,17 @@ emit_store (var, state)\n   NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (var)) ? 2 : 1);\n }\n \n+static void\n+emit_unop (opcode, type, state)\n+     enum java_opcode opcode;\n+     tree type;\n+     struct jcf_partial *state;\n+{\n+  int size = TYPE_IS_WIDE (type) ? 2 : 1;\n+  RESERVE(1);\n+  OP1 (opcode);\n+}\n+\n static void\n emit_binop (opcode, type, state)\n      enum java_opcode opcode;\n@@ -750,59 +839,83 @@ emit_binop (opcode, type, state)\n   NOTE_POP (size);\n }\n \n-/* Emit a conditional jump to TARGET with a 2-byte relative jump offset\n-   The opcode is OPCODE, the inverted opcode is INV_OPCODE. */\n-\n-static void\n-emit_if (target, opcode, inv_opcode, state)\n+static struct jcf_relocation *\n+emit_reloc (value, kind, target, state)\n+     HOST_WIDE_INT value;\n+     int kind;\n      struct jcf_block *target;\n-     int opcode, inv_opcode;\n      struct jcf_partial *state;\n {\n   struct jcf_relocation *reloc = (struct jcf_relocation *)\n     obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n   struct jcf_block *block = state->last_block;\n   reloc->next = block->u.relocations;\n   block->u.relocations = reloc;\n-  OP1 (opcode);\n   reloc->offset = BUFFER_LENGTH (&state->bytecode);\n-  OP2 (1); // 1 byte from reloc back to start of instruction.\n-  reloc->kind = - inv_opcode;\n   reloc->label = target;\n+  reloc->kind = kind;\n+  if (kind == 0 || kind == BLOCK_START_RELOC)\n+    OP4 (value);\n+  else if (kind != SWITCH_ALIGN_RELOC)\n+    OP2 (value);\n }\n \n static void\n-emit_goto_or_jsr (target, opcode, opcode_w, state)\n-     struct jcf_block *target;\n-     int opcode, opcode_w;\n+emit_switch_reloc (label, state)\n+     struct jcf_block *label;\n+     struct jcf_partial *state;\n+{\n+  emit_reloc (0, BLOCK_START_RELOC, label, state);\n+}\n+\n+/* Similar to emit_switch_reloc,\n+   but re-uses an existing case reloc. */\n+\n+static void\n+emit_case_reloc (reloc, state)\n+     struct jcf_relocation *reloc;\n      struct jcf_partial *state;\n {\n-  struct jcf_relocation *reloc = (struct jcf_relocation *)\n-    obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n   struct jcf_block *block = state->last_block;\n   reloc->next = block->u.relocations;\n   block->u.relocations = reloc;\n-  OP1 (opcode);\n   reloc->offset = BUFFER_LENGTH (&state->bytecode);\n-  OP2 (1); // 1 byte from reloc back to start of instruction.\n-  reloc->kind = opcode_w;\n-  reloc->label = target;\n+  reloc->kind = BLOCK_START_RELOC;\n+  OP4 (0);\n+}\n+\n+/* Emit a conditional jump to TARGET with a 2-byte relative jump offset\n+   The opcode is OPCODE, the inverted opcode is INV_OPCODE. */\n+\n+static void\n+emit_if (target, opcode, inv_opcode, state)\n+     struct jcf_block *target;\n+     int opcode, inv_opcode;\n+     struct jcf_partial *state;\n+{\n+  OP1 (opcode);\n+  // value is 1 byte from reloc back to start of instruction.\n+  emit_reloc (1, - inv_opcode, target, state);\n }\n \n static void\n emit_goto (target, state)\n      struct jcf_block *target;\n      struct jcf_partial *state;\n {\n-  emit_goto_or_jsr (target, OPCODE_goto, OPCODE_goto_w, state);\n+  OP1 (OPCODE_goto);\n+ // Value is 1 byte from reloc back to start of instruction.\n+  emit_reloc (1, OPCODE_goto_w, target, state);\n }\n \n static void\n emit_jsr (target, state)\n      struct jcf_block *target;\n      struct jcf_partial *state;\n {\n-  emit_goto_or_jsr (target, OPCODE_jsr, OPCODE_jsr_w, state);\n+  OP1 (OPCODE_jsr);\n+ // Value is 1 byte from reloc back to start of instruction.\n+  emit_reloc (1, OPCODE_jsr_w, target, state);\n }\n \n /* Generate code to evaluate EXP.  If the result is true,\n@@ -850,6 +963,10 @@ generate_bytecode_conditional (exp, true_label, false_label,\n \t  fatal (\"internal error  non-matching SP\");\n       }\n       break;\n+    case TRUTH_NOT_EXPR:\n+      generate_bytecode_conditional (TREE_OPERAND (exp, 0), false_label, true_label,\n+\t\t\t\t     ! true_branch_first, state);\n+      break;\n     case TRUTH_ANDIF_EXPR:\n       {\n \tstruct jcf_block *next_label = gen_jcf_label (state);\n@@ -915,6 +1032,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n       type = TREE_TYPE (exp0);\n       switch (TREE_CODE (type))\n \t{\n+\t  int opf;\n \tcase POINTER_TYPE:  case RECORD_TYPE:\n \t  switch (TREE_CODE (exp))\n \t    {\n@@ -936,7 +1054,22 @@ generate_bytecode_conditional (exp, true_label, false_label,\n \t  NOTE_POP (2);\n \t  goto compare_2;\n \tcase REAL_TYPE:\n-\t  fatal (\"float comparison not implemented\");\n+\t  generate_bytecode_insns (exp0, STACK_TARGET, state);\n+\t  generate_bytecode_insns (exp1, STACK_TARGET, state);\n+\t  if (op == OPCODE_if_icmplt || op == op == OPCODE_if_icmple)\n+\t    opf = OPCODE_fcmpg;\n+\t  else\n+\t    opf = OPCODE_fcmpl;\n+\t  if (TYPE_PRECISION (type) > 32)\n+\t    {\n+\t      opf += 2;\n+\t      NOTE_POP (4);\n+\t    }\n+\t  else\n+\t    NOTE_POP (2);\n+\t  RESERVE (1);\n+\t  OP1 (opf);\n+\t  goto compare_1;\n \tcase INTEGER_TYPE:\n \t  if (TYPE_PRECISION (type) > 32)\n \t    {\n@@ -967,6 +1100,8 @@ generate_bytecode_conditional (exp, true_label, false_label,\n \t\tcase OPCODE_if_icmple:\n \t\t  op -= 2;\n \t\t  break;\n+\t\tdefault:\n+\t\t  break;\n \t\t}\n \t      generate_bytecode_insns (exp1, STACK_TARGET, state);\n \t      NOTE_POP (1);\n@@ -994,7 +1129,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n       break;\n     }\n   if (save_SP != state->code_SP)\n-    fatal (\"inetrnal error - SP mismatch\");\n+    fatal (\"internal error - SP mismatch\");\n }\n \n /* Generate bytecode for sub-expression EXP of METHOD.\n@@ -1025,13 +1160,20 @@ generate_bytecode_insns (exp, target, state)\n       if (BLOCK_EXPR_BODY (exp))\n \t{\n \t  tree local;\n+\t  tree body = BLOCK_EXPR_BODY (exp);\n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n \t      localvar_alloc (local, state);\n \t      local = next;\n \t    }\n-\t  generate_bytecode_insns (BLOCK_EXPR_BODY (exp), target, state);\n+\t  /* Avoid deep recursion for long blocks. */\n+\t  while (TREE_CODE (body) == COMPOUND_EXPR)\n+\t    {\n+\t      generate_bytecode_insns (TREE_OPERAND (body, 0), target, state);\n+\t      body = TREE_OPERAND (body, 1);\n+\t    }\n+\t  generate_bytecode_insns (body, target, state);\n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n@@ -1079,6 +1221,32 @@ generate_bytecode_insns (exp, target, state)\n \t  NOTE_PUSH (2);\n \t}\n       break;\n+    case REAL_CST:\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\t  long words[2];\n+\t  int index;\n+\tcase 32:\n+\t  words[0] = etarsingle (TREE_REAL_CST (exp)) & 0xFFFFFFFF;\n+\t  index = find_constant1 (&state->cpool, CONSTANT_Float, words[0]);\n+\t  push_constant1 (index, state);\n+\t  NOTE_PUSH (1);\n+\t  break;\n+\tcase 64:\n+\t  etardouble (TREE_REAL_CST (exp), words);\n+\t  index = find_constant2 (&state->cpool, CONSTANT_Double,\n+\t\t\t\t  words[1-FLOAT_WORDS_BIG_ENDIAN] & 0xFFFFFFFF,\n+\t\t\t\t  words[FLOAT_WORDS_BIG_ENDIAN] & 0xFFFFFFFF);\n+\t  push_constant2 (index, state);\n+\t  NOTE_PUSH (2);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+    case STRING_CST:\n+      push_constant1 (find_string_constant (&state->cpool, exp), state);\n+      break;\n     case VAR_DECL:\n       if (TREE_STATIC (exp))\n \t{\n@@ -1090,6 +1258,7 @@ generate_bytecode_insns (exp, target, state)\n     case PARM_DECL:\n       emit_load (exp, state);\n       break;\n+    case NON_LVALUE_EXPR:\n     case INDIRECT_REF:\n       generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n       break;\n@@ -1098,10 +1267,11 @@ generate_bytecode_insns (exp, target, state)\n       generate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n       if (target != IGNORE_TARGET)\n \t{\n-\t  jopcode = OPCODE_iaload + adjust_typed_op (type);\n+\t  jopcode = OPCODE_iaload + adjust_typed_op (type, 7);\n \t  RESERVE(1);\n \t  OP1 (jopcode);\n-\t  NOTE_POP (2);\n+\t  if (! TYPE_IS_WIDE (type))\n+\t    NOTE_POP (1);\n \t}\n       break;\n     case COMPONENT_REF:\n@@ -1162,12 +1332,186 @@ generate_bytecode_insns (exp, target, state)\n \t\t\t\t       then_label, else_label, 1, state);\n \tdefine_jcf_label (then_label, state);\n \tgenerate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n-\temit_goto (end_label, state);\n+\tif (CAN_COMPLETE_NORMALLY (TREE_OPERAND (exp, 1))\n+\t    /* Not all expressions have CAN_COMPLETE_NORMALLY set properly. */\n+\t    || TREE_CODE (TREE_TYPE (exp)) != VOID_TYPE)\n+\t  emit_goto (end_label, state);\n \tdefine_jcf_label (else_label, state);\n \tgenerate_bytecode_insns (TREE_OPERAND (exp, 2), target, state);\n \tdefine_jcf_label (end_label, state);\n       }\n       break;\n+    case CASE_EXPR:\n+      {\n+\tstruct jcf_switch_state *sw_state = state->sw_state;\n+\tstruct jcf_relocation *reloc = (struct jcf_relocation *)\n+\t  obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n+\tHOST_WIDE_INT case_value = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n+\treloc->kind = 0;\n+\treloc->label = get_jcf_label_here (state);\n+\treloc->offset = case_value;\n+\treloc->next = sw_state->cases;\n+\tsw_state->cases = reloc;\n+\tif (sw_state->num_cases == 0)\n+\t  {\n+\t    sw_state->min_case = case_value;\n+\t    sw_state->max_case = case_value;\n+\t  }\n+\telse\n+\t  {\n+\t    if (case_value < sw_state->min_case)\n+\t      sw_state->min_case = case_value;\n+\t    if (case_value > sw_state->max_case)\n+\t      sw_state->max_case = case_value;\n+\t  }\n+\tsw_state->num_cases++;\n+      }\n+      break;\n+    case DEFAULT_EXPR:\n+      state->sw_state->default_label = get_jcf_label_here (state);\n+      break;\n+\n+    case SWITCH_EXPR:\n+      {\n+\t/* The SWITCH_EXPR has three parts, generated in the following order:\n+\t   1.  the switch_expression (the value used to select the correct case);\n+\t   2.  the switch_body;\n+\t   3.  the switch_instruction (the tableswitch/loopupswitch instruction.).\n+\t   After code generation, we will re-order then in the order 1, 3, 2.\n+\t   This is to avoid an extra GOTOs. */\n+\tstruct jcf_switch_state sw_state;\n+\tstruct jcf_block *expression_last; /* Last block of the switch_expression. */\n+\tstruct jcf_block *body_last; /* Last block of the switch_body. */\n+\tstruct jcf_block *switch_instruction;  /* First block of switch_instruction. */\n+\tstruct jcf_block *instruction_last; /* Last block of the switch_instruction. */\n+\tstruct jcf_block *body_block;\n+\tint switch_length;\n+\tsw_state.prev = state->sw_state;\n+\tstate->sw_state = &sw_state;\n+\tsw_state.cases = NULL;\n+\tsw_state.num_cases = 0;\n+\tsw_state.default_label = NULL;\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+\texpression_last = state->last_block;\n+\tbody_block = get_jcf_label_here (state);  /* Force a new block here. */\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 1), IGNORE_TARGET, state);\n+\tbody_last = state->last_block;\n+\n+\tif (sw_state.default_label == NULL)\n+\t  sw_state.default_label = gen_jcf_label (state);\n+\tswitch_instruction = get_jcf_label_here (state);\n+\n+\tif (sw_state.num_cases <= 1)\n+\t  {\n+\t    if (sw_state.num_cases == 0)\n+\t      {\n+\t\temit_pop (1, state);\n+\t\tNOTE_POP (1);\n+\t      }\n+\t    else\n+\t      {\n+\t\tpush_int_const (sw_state.cases->offset, state);\n+\t\temit_if (sw_state.cases->label,\n+\t\t\t OPCODE_ifeq, OPCODE_ifne, state);\n+\t      }\n+\t    emit_goto (sw_state.default_label, state);\n+\t  }\n+\telse\n+\t  {\n+\t    HOST_WIDE_INT i;\n+\t    /* Copy the chain of relocs into a sorted array. */\n+\t    struct jcf_relocation **relocs = (struct jcf_relocation **)\n+\t      xmalloc (sw_state.num_cases * sizeof (struct jcf_relocation *));\n+\t    /* The relocs arrays is a buffer with a gap.\n+\t       The assumption is that cases will normally come in \"runs\". */\n+\t    int gap_start = 0;\n+\t    int gap_end = sw_state.num_cases;\n+\t    struct jcf_relocation *reloc;\n+\t    for (reloc = sw_state.cases;  reloc != NULL;  reloc = reloc->next)\n+\t      {\n+\t\tHOST_WIDE_INT case_value = reloc->offset;\n+\t\twhile (gap_end < sw_state.num_cases)\n+\t\t  {\n+\t\t    struct jcf_relocation *end = relocs[gap_end];\n+\t\t    if (case_value <= end->offset)\n+\t\t      break;\n+\t\t    relocs[gap_start++] = end;\n+\t\t    gap_end++;\n+\t\t  }\n+\t\twhile (gap_start > 0)\n+\t\t  {\n+\t\t    struct jcf_relocation *before = relocs[gap_start-1];\n+\t\t    if (case_value >= before->offset)\n+\t\t      break;\n+\t\t    relocs[--gap_end] = before;\n+\t\t    gap_start--;\n+\t\t  }\n+\t\trelocs[gap_start++] = reloc;\n+\t\t/* Note we don't check for duplicates.  FIXME! */\n+\t      }\n+\n+\t    if (2 * sw_state.num_cases\n+\t\t>= sw_state.max_case - sw_state.min_case)\n+\t      { /* Use tableswitch. */\n+\t\tint index = 0;\n+\t\tRESERVE (13 + 4 * (sw_state.max_case - sw_state.min_case + 1));\n+\t\tOP1 (OPCODE_tableswitch);\n+\t\temit_reloc (0, SWITCH_ALIGN_RELOC, NULL, state);\n+\t\temit_switch_reloc (sw_state.default_label, state);\n+\t\tOP4 (sw_state.min_case);\n+\t\tOP4 (sw_state.max_case);\n+\t\tfor (i = sw_state.min_case; ; )\n+\t\t  {\n+\t\t    if (i == sw_state.min_case + index)\n+\t\t      emit_case_reloc (relocs[index++], state);\n+\t\t    else\n+\t\t      emit_switch_reloc (sw_state.default_label, state);\n+\t\t    if (i == sw_state.max_case)\n+\t\t      break;\n+\t\t    i++;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      { /* Use lookupswitch. */\n+\t\tRESERVE(9 + 8 * sw_state.num_cases);\n+\t\tOP1 (OPCODE_lookupswitch);\n+\t\temit_reloc (0, SWITCH_ALIGN_RELOC, NULL, state);\n+\t\temit_switch_reloc (sw_state.default_label, state);\n+\t\tOP4 (sw_state.num_cases);\n+\t\tfor (i = 0;  i < sw_state.num_cases;  i++)\n+\t\t  {\n+\t\t    struct jcf_relocation *reloc = relocs[i];\n+\t\t    OP4 (reloc->offset);\n+\t\t    emit_case_reloc (reloc, state);\n+\t\t  }\n+\t      }\n+\t    free (relocs);\n+\t  }\n+\n+\tinstruction_last = state->last_block;\n+\tif (sw_state.default_label->pc < 0)\n+\t  define_jcf_label (sw_state.default_label, state);\n+\telse /* Force a new block. */\n+\t  sw_state.default_label = get_jcf_label_here (state);\n+\t/* Now re-arrange the blocks so the switch_instruction\n+\t   comes before the switch_body. */\n+\tswitch_length = state->code_length - switch_instruction->pc;\n+\tswitch_instruction->pc = body_block->pc;\n+\tinstruction_last->next = body_block;\n+\tinstruction_last->chunk->next = body_block->chunk;\n+\texpression_last->next = switch_instruction;\n+\texpression_last->chunk->next = switch_instruction->chunk;\n+\tbody_last->next = sw_state.default_label;\n+\tbody_last->chunk->next = NULL;\n+\tstate->chunk = body_last->chunk;\n+\tfor (;  body_block != sw_state.default_label;  body_block = body_block->next)\n+\t  body_block->pc += switch_length;\n+\n+\tfree (sw_state.cases);\n+\tstate->sw_state = sw_state.prev;\n+\tbreak;\n+      }\n+\n     case RETURN_EXPR:\n       if (!TREE_OPERAND (exp, 0))\n \top = OPCODE_return;\n@@ -1177,7 +1521,7 @@ generate_bytecode_insns (exp, target, state)\n \t  if (TREE_CODE (exp) != MODIFY_EXPR)\n \t    abort ();\n \t  exp = TREE_OPERAND (exp, 1);\n-\t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp));\n+\t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp), 4);\n \t  generate_bytecode_insns (exp, STACK_TARGET, state);\n \t}\n       RESERVE (1);\n@@ -1288,7 +1632,7 @@ generate_bytecode_insns (exp, target, state)\n \t  generate_bytecode_insns (TREE_OPERAND (exp, 1), STACK_TARGET, state);\n \t  emit_dup (2, 0, state);\n \t  /* Stack:  ..., array, index, array, index. */\n-\t  jopcode = OPCODE_iaload + adjust_typed_op (TREE_TYPE (exp));\n+\t  jopcode = OPCODE_iaload + adjust_typed_op (TREE_TYPE (exp), 7);\n \t  RESERVE(1);\n \t  OP1 (jopcode);\n \t  NOTE_POP (2-size);\n@@ -1311,7 +1655,7 @@ generate_bytecode_insns (exp, target, state)\n       /* Stack, otherwise:  ..., [result, ] oldvalue. */\n       push_int_const (value, state); /* FIXME - assumes int! */\n       NOTE_PUSH (1);\n-      emit_binop (OPCODE_iadd + adjust_typed_op (type), type, state);\n+      emit_binop (OPCODE_iadd + adjust_typed_op (type, 3), type, state);\n       if (target != IGNORE_TARGET && ! post_op)\n \temit_dup (size, offset, state);\n       /* Stack:  ..., [result,] newvalue. */\n@@ -1399,7 +1743,7 @@ generate_bytecode_insns (exp, target, state)\n       else if (TREE_CODE (exp) == ARRAY_REF)\n \t{\n \t  NOTE_POP (2);\n-\t  jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (exp));\n+\t  jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (exp), 7);\n \t  RESERVE(1);\n \t  OP1 (jopcode);\n \t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n@@ -1408,49 +1752,289 @@ generate_bytecode_insns (exp, target, state)\n \tfatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n       break;\n     case PLUS_EXPR:\n-      jopcode = OPCODE_iadd + adjust_typed_op (type);\n+      jopcode = OPCODE_iadd;\n       goto binop;\n     case MINUS_EXPR:\n-      jopcode = OPCODE_isub + adjust_typed_op (type);\n+      jopcode = OPCODE_isub;\n       goto binop;\n     case MULT_EXPR:\n-      jopcode = OPCODE_imul + adjust_typed_op (type);\n+      jopcode = OPCODE_imul;\n       goto binop;\n     case TRUNC_DIV_EXPR:\n     case RDIV_EXPR:\n-      jopcode = OPCODE_idiv + adjust_typed_op (type);\n+      jopcode = OPCODE_idiv;\n+      goto binop;\n+    case TRUNC_MOD_EXPR:\n+      jopcode = OPCODE_irem;\n       goto binop;\n+    case LSHIFT_EXPR:   jopcode = OPCODE_ishl;   goto binop;\n+    case RSHIFT_EXPR:   jopcode = OPCODE_ishr;   goto binop;\n+    case URSHIFT_EXPR:  jopcode = OPCODE_iushr;  goto binop;\n+    case BIT_AND_EXPR:  jopcode = OPCODE_iand;   goto binop;\n+    case BIT_IOR_EXPR:  jopcode = OPCODE_ior;    goto binop;\n+    case BIT_XOR_EXPR:  jopcode = OPCODE_ixor;   goto binop;\n     binop:\n-      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n-      generate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n+    {\n+      tree arg0 = TREE_OPERAND (exp, 0);\n+      tree arg1 = TREE_OPERAND (exp, 1);\n+      jopcode += adjust_typed_op (type, 3);\n+      if (arg0 == arg1 && TREE_CODE (arg0) == SAVE_EXPR)\n+\t{\n+\t  /* fold may (e.g) convert 2*x to x+x. */\n+\t  generate_bytecode_insns (TREE_OPERAND (arg0, 0), target, state);\n+\t  emit_dup (TYPE_PRECISION (TREE_TYPE (arg0)) > 32 ? 2 : 1, 0, state);\n+\t}\n+      else\n+\t{\n+\t  generate_bytecode_insns (arg0, target, state);\n+\t  generate_bytecode_insns (arg1, target, state);\n+\t}\n       if (target == STACK_TARGET)\n \temit_binop (jopcode, type, state);\n       break;\n+    }\n+    case TRUTH_NOT_EXPR:\n+    case BIT_NOT_EXPR:\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+      if (target == STACK_TARGET)\n+\t{\n+\t  int is_long = TYPE_PRECISION (TREE_TYPE (exp)) > 32;\n+\t  push_int_const (TREE_CODE (exp) == BIT_NOT_EXPR ? -1 : 1, state); \n+\t  RESERVE (2);\n+\t  if (is_long)\n+\t    OP1 (OPCODE_i2l);\n+\t  OP1 (OPCODE_ixor + is_long);\n+\t}\n+      break;\n+    case NEGATE_EXPR:\n+      jopcode = OPCODE_ineg;\n+      jopcode += adjust_typed_op (type, 3);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+      if (target == STACK_TARGET)\n+\temit_unop (jopcode, type, state);\n+      break;\n+    case INSTANCEOF_EXPR:\n+      {\n+\tint index = find_class_constant (&state->cpool, TREE_OPERAND (exp, 1));\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+\tRESERVE (3);\n+\tOP1 (OPCODE_instanceof);\n+\tOP2 (index);\n+      }\n+      break;\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+      {\n+\ttree src = TREE_OPERAND (exp, 0);\n+\ttree src_type = TREE_TYPE (src);\n+\ttree dst_type = TREE_TYPE (exp);\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+\tif (target == IGNORE_TARGET || src_type == dst_type)\n+\t  break;\n+\tif (TREE_CODE (dst_type) == POINTER_TYPE)\n+\t  {\n+\t    if (TREE_CODE (exp) == CONVERT_EXPR)\n+\t      {\n+\t\tint index = find_class_constant (&state->cpool, TREE_TYPE (dst_type));\n+\t\tRESERVE (3);\n+\t\tOP1 (OPCODE_checkcast);\n+\t\tOP2 (index);\n+\t      }\n+\t  }\n+\telse /* Convert numeric types. */\n+\t  {\n+\t    int wide_src = TYPE_PRECISION (src_type) > 32;\n+\t    int wide_dst = TYPE_PRECISION (dst_type) > 32;\n+\t    NOTE_POP (1 + wide_src);\n+\t    RESERVE (1);\n+\t    if (TREE_CODE (dst_type) == REAL_TYPE)\n+\t      {\n+\t\tif (TREE_CODE (src_type) == REAL_TYPE)\n+\t\t  OP1 (wide_dst ? OPCODE_f2d : OPCODE_d2f);\n+\t\telse if (TYPE_PRECISION (src_type) == 64)\n+\t\t  OP1 (OPCODE_l2f + wide_dst);\n+\t\telse\n+\t\t  OP1 (OPCODE_i2f + wide_dst);\n+\t      }\n+\t    else /* Convert to integral type. */\n+\t      {\n+\t\tif (TREE_CODE (src_type) == REAL_TYPE)\n+\t\t  OP1 (OPCODE_f2i + wide_dst + 3 * wide_src);\n+\t\telse if (wide_dst)\n+\t\t  OP1 (OPCODE_i2l);\n+\t\telse if (wide_src)\n+\t\t  OP1 (OPCODE_l2i);\n+\t\tif (TYPE_PRECISION (dst_type) < 32)\n+\t\t  {\n+\t\t    RESERVE (1);\n+\t\t    /* Already converted to int, if needed. */\n+\t\t    if (TYPE_PRECISION (dst_type) <= 8)\n+\t\t      OP1 (OPCODE_i2b);\n+\t\t    else if (TREE_UNSIGNED (dst_type))\n+\t\t      OP1 (OPCODE_i2c);\n+\t\t    else\n+\t\t      OP1 (OPCODE_i2s);\n+\t\t  }\n+\t      }\n+\t    NOTE_PUSH (1 + wide_dst);\n+\t  }\n+      }\n+      break;\n+    case TRY_EXPR:\n+      {\n+\ttree try_clause = TREE_OPERAND (exp, 0);\n+\ttree finally = TREE_OPERAND (exp, 2);\n+\tstruct jcf_block *start_label = get_jcf_label_here (state);\n+\tstruct jcf_block *end_label;  /* End of try clause. */\n+\tstruct jcf_block *finally_label;  /* Finally subroutine. */\n+\tstruct jcf_block *finished_label = gen_jcf_label (state);\n+\ttree clause = TREE_OPERAND (exp, 1);\n+\tif (finally)\n+\t  {\n+\t    finally = FINALLY_EXPR_BLOCK (finally);\n+\t    finally_label = gen_jcf_label (state);\n+\t  }\n+\tif (target != IGNORE_TARGET)\n+\t  abort ();\n+\tgenerate_bytecode_insns (try_clause, IGNORE_TARGET, state);\n+\tend_label = get_jcf_label_here (state);\n+\tif (CAN_COMPLETE_NORMALLY (try_clause))\n+\t  emit_goto (finished_label, state);\n+\tfor ( ; clause != NULL_TREE;  clause = TREE_CHAIN (clause))\n+\t  {\n+\t    tree catch_clause = TREE_OPERAND (clause, 0);\n+\t    tree exception_decl = BLOCK_EXPR_DECLS (catch_clause);\n+\t    struct jcf_handler *handler = alloc_handler (start_label, end_label, state);\n+\t    handler->type = TREE_TYPE (TREE_TYPE (exception_decl));\n+\t    generate_bytecode_insns (catch_clause, IGNORE_TARGET, state);\n+\t    if (CAN_COMPLETE_NORMALLY (catch_clause))\n+\t      emit_goto (finished_label, state);\n+\t  }\n+\tif (finally)\n+\t  {\n+\t    tree return_link;\n+\t    tree exception_type = build_pointer_type (throwable_type_node);\n+\t    tree exception_decl = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t\t      exception_type);\n+\t    struct jcf_handler *handler\n+\t      = alloc_handler (start_label, NULL_TREE, state);\n+\t    handler->end_label = handler->handler_label;\n+\t    handler->type = NULL_TREE;\n+\t    localvar_alloc (exception_decl, state);\n+\t    NOTE_PUSH (1);\n+            emit_store (exception_decl, state);\n+\t    emit_jsr (finally_label, state);\n+\t    emit_load (exception_decl, state);\n+\t    RESERVE (1);\n+\t    OP1 (OPCODE_athrow);\n+\t    NOTE_POP (1);\n+\t    localvar_free (exception_decl, state);\n+\n+\t    /* The finally block. */\n+\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t      return_address_type_node);\n+\t    define_jcf_label (finally_label, state);\n+\t    NOTE_PUSH (1);\n+\t    localvar_alloc (return_link, state);\n+\t    emit_store (return_link, state);\n+\t    generate_bytecode_insns (finally, IGNORE_TARGET, state);\n+\t    maybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n+\t    localvar_free (return_link, state);\n+\t  }\n+\tdefine_jcf_label (finished_label, state);\n+\tif (finally)\n+\t  emit_jsr (finally_label, state);\n+      }\n+      break;\n+    case THROW_EXPR:\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+      RESERVE (1);\n+      OP1 (OPCODE_athrow);\n+      break;\n+    case NEW_CLASS_EXPR:\n+      {\n+\ttree class = TREE_TYPE (TREE_TYPE (exp));\n+\tint index = find_class_constant (&state->cpool, class);\n+\tRESERVE (4);\n+\tOP1 (OPCODE_new);\n+\tOP2 (index);\n+\tOP1 (OPCODE_dup);\n+\tNOTE_PUSH (1);\n+      }\n+      /* ... fall though ... */\n     case CALL_EXPR:\n       {\n-\ttree t;\n+\ttree f = TREE_OPERAND (exp, 0);\n+\ttree x = TREE_OPERAND (exp, 1);\n \tint save_SP = state->code_SP;\n-\tfor (t = TREE_OPERAND (exp, 1);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+\tif (TREE_CODE (f) == ADDR_EXPR)\n+\t  f = TREE_OPERAND (f, 0);\n+\tif (f == soft_newarray_node)\n \t  {\n-\t    generate_bytecode_insns (TREE_VALUE (t), STACK_TARGET, state);\n+\t    int type_code = TREE_INT_CST_LOW (TREE_VALUE (x));\n+\t    generate_bytecode_insns (TREE_VALUE (TREE_CHAIN (x)),\n+\t\t\t\t     STACK_TARGET, state);\n+\t    RESERVE (2);\n+\t    OP1 (OPCODE_newarray);\n+\t    OP1 (type_code);\n+\t    break;\n+\t  }\n+\telse if (f == soft_multianewarray_node)\n+\t  {\n+\t    int ndims;\n+\t    int idim;\n+\t    int index = find_class_constant (&state->cpool,\n+\t\t\t\t\t     TREE_TYPE (TREE_TYPE (exp)));\n+\t    x = TREE_CHAIN (x);  /* Skip class argument. */\n+\t    ndims = TREE_INT_CST_LOW (TREE_VALUE (x));\n+\t    for (idim = ndims;  --idim >= 0; )\n+\t      {\n+\t\tx = TREE_CHAIN (x);\n+\t\tgenerate_bytecode_insns (TREE_VALUE (x), STACK_TARGET, state);\n+\t      }\n+\t    RESERVE (4);\n+\t    OP1 (OPCODE_multianewarray);\n+\t    OP2 (index);\n+\t    OP1 (ndims);\n+\t    break;\n+\t  }\n+\telse if (f == soft_anewarray_node)\n+\t  {\n+\t    tree cl = TYPE_ARRAY_ELEMENT (TREE_TYPE (TREE_TYPE (exp)));\n+\t    int index = find_class_constant (&state->cpool, TREE_TYPE (cl));\n+\t    generate_bytecode_insns (TREE_VALUE (x), STACK_TARGET, state);\n+\t    RESERVE (3);\n+\t    OP1 (OPCODE_anewarray);\n+\t    OP2 (index);\n+\t    break;\n+\t  }\n+\telse if (exp == soft_exceptioninfo_call_node)\n+\t  {\n+\t    NOTE_PUSH (1);  /* Pushed by exception system. */\n+\t    break;\n+\t  }\n+\tfor ( ;  x != NULL_TREE;  x = TREE_CHAIN (x))\n+\t  {\n+\t    generate_bytecode_insns (TREE_VALUE (x), STACK_TARGET, state);\n \t  }\n-\tt = TREE_OPERAND (exp, 0);\n \tstate->code_SP = save_SP;\n-\tif (TREE_CODE (t) == FUNCTION_DECL)\n+\tif (TREE_CODE (f) == FUNCTION_DECL && DECL_CONTEXT (f) != NULL_TREE)\n \t  {\n-\t    int index = find_methodref_index (&state->cpool, t);\n+\t    int index = find_methodref_index (&state->cpool, f);\n \t    RESERVE (3);\n-\t    if (DECL_CONSTRUCTOR_P (t))\n+\t    if (DECL_CONSTRUCTOR_P (f))\n \t      OP1 (OPCODE_invokespecial);\n-\t    else if (METHOD_STATIC (t))\n+\t    else if (METHOD_STATIC (f))\n \t      OP1 (OPCODE_invokestatic);\n \t    else\n \t      OP1 (OPCODE_invokevirtual);\n \t    OP2 (index);\n-\t    t = TREE_TYPE (TREE_TYPE (t));\n-\t    if (TREE_CODE (t) != VOID_TYPE)\n+\t    f = TREE_TYPE (TREE_TYPE (f));\n+\t    if (TREE_CODE (f) != VOID_TYPE)\n \t      {\n-\t\tint size = TYPE_IS_WIDE (t) ? 2 : 1;\n+\t\tint size = TYPE_IS_WIDE (f) ? 2 : 1;\n \t\tif (target == IGNORE_TARGET)\n \t\t  emit_pop (size, state);\n \t\telse\n@@ -1476,7 +2060,13 @@ perform_relocations (state)\n   int pc;\n   int shrink;\n \n-  /* Figure out the actual locations of each block. */\n+  /* Before we start, the pc field of each block is an upper bound on\n+     the block's start pc (it may be less, if previous blocks need less\n+     than their maximum).\n+\n+     The minimum size of each block is in the block's chunk->size. */\n+\n+  /* First, figure out the actual locations of each block. */\n   pc = 0;\n   shrink = 0;\n   for (block = state->blocks;  block != NULL;  block = block->next)\n@@ -1489,9 +2079,9 @@ perform_relocations (state)\n \t Assumes relocations are in reverse order. */\n       reloc = block->u.relocations;\n       while (reloc != NULL\n+\t     && reloc->kind == OPCODE_goto_w\n \t     && reloc->label->pc == block->next->pc\n-\t     && reloc->offset + 2 == block_size\n-\t     && reloc->kind == OPCODE_goto_w)\n+\t     && reloc->offset + 2 == block_size)\n \t{\n \t  reloc = reloc->next;\n \t  block->u.relocations = reloc;\n@@ -1502,7 +2092,15 @@ perform_relocations (state)\n \n       for (reloc = block->u.relocations;  reloc != NULL;  reloc = reloc->next)\n \t{\n-\t  if (reloc->kind < -1 || reloc->kind > 0)\n+\t  if (reloc->kind == SWITCH_ALIGN_RELOC)\n+\t    {\n+\t      /* We assume this is the first relocation in this block,\n+\t\t so we know its final pc. */\n+\t      int where = pc + reloc->offset;\n+\t      int pad = ((where + 3) & ~3) - where;\n+\t      block_size += pad;\n+\t    }\n+\t  else if (reloc->kind < -1 || reloc->kind > BLOCK_START_RELOC)\n \t    {\n \t      int delta = reloc->label->pc - (pc + reloc->offset - 1);\n \t      int expand = reloc->kind > 0 ? 2 : 5;\n@@ -1536,38 +2134,63 @@ perform_relocations (state)\n \t{\n \t  chunk->data = (unsigned char *)\n \t    obstack_alloc (state->chunk_obstack, new_size);\n+\t  chunk->size = new_size;\n \t}\n       new_ptr = chunk->data + new_size;\n \n       /* We do the relocations from back to front, because\n-\t thre relocations are in reverse order. */\n+\t the relocations are in reverse order. */\n       for (reloc = block->u.relocations; ; reloc = reloc->next)\n \t{\n-\t  /* Lower old index of piece to be copied with no relocation. */\n+\t  /* new_ptr and old_ptr point into the old and new buffers,\n+\t     respectively.  (If no relocations cause the buffer to\n+\t     grow, the buffer will be the same buffer, and new_ptr==old_ptr.)\n+\t     The bytes at higher adress have been copied and relocations\n+\t     handled; those at lower addresses remain to process. */\n+\n+\t  /* Lower old index of piece to be copied with no relocation.\n+\t     I.e. high index of the first piece that does need relocation. */\n \t  int start = reloc == NULL ? 0\n-\t    : reloc->kind == 0 ? reloc->offset + 4\n+\t    : reloc->kind == SWITCH_ALIGN_RELOC ? reloc->offset\n+\t    : (reloc->kind == 0 || reloc->kind == BLOCK_START_RELOC)\n+\t    ? reloc->offset + 4\n \t    : reloc->offset + 2;\n \t  int32 value;\n \t  int new_offset;\n \t  int n = (old_ptr - old_buffer) - start;\n \t  new_ptr -= n;\n \t  old_ptr -= n;\n \t  if (n > 0)\n-\t    bcopy (old_ptr, new_ptr, n);\n+\t    memcpy (new_ptr, old_ptr, n);\n \t  if (old_ptr == old_buffer)\n \t    break;\n \n+\t  new_offset = new_ptr - chunk->data;\n+\t  new_offset -= (reloc->kind == -1 ? 2 : 4);\n \t  if (reloc->kind == 0)\n \t    {\n \t      old_ptr -= 4;\n \t      value = GET_u4 (old_ptr);\n \t    }\n+\t  else if (reloc->kind == BLOCK_START_RELOC)\n+\t    {\n+\t      old_ptr -= 4;\n+\t      value = 0;\n+\t      new_offset = 0;\n+\t    }\n+\t  else if (reloc->kind == SWITCH_ALIGN_RELOC)\n+\t    {\n+\t      int where = block->pc + reloc->offset;\n+\t      int pad = ((where + 3) & ~3) - where;\n+\t      while (--pad >= 0)\n+\t\t*--new_ptr = 0;\n+\t      continue;\n+\t    }\n \t  else\n \t    {\n \t      old_ptr -= 2;\n \t      value = GET_u2 (old_ptr);\n \t    }\n-\t  new_offset = new_ptr - chunk->data - (reloc->kind == -1 ? 2 : 4);\n \t  value += reloc->label->pc - (block->pc + new_offset);\n \t  *--new_ptr = (unsigned char) value;  value >>= 8;\n \t  *--new_ptr = (unsigned char) value;  value >>= 8;\n@@ -1576,7 +2199,7 @@ perform_relocations (state)\n \t      *--new_ptr = (unsigned char) value;  value >>= 8;\n \t      *--new_ptr = (unsigned char) value;\n \t    }\n-\t  if (reloc->kind > 0)\n+\t  if (reloc->kind > BLOCK_START_RELOC)\n \t    {\n \t      /* Convert: OP TARGET to: OP_w TARGET;  (OP is goto or jsr). */\n \t      --old_ptr;\n@@ -1624,6 +2247,9 @@ init_jcf_method (state, method)\n   BUFFER_RESET (&state->localvars);\n   state->code_SP = 0;\n   state->code_SP_max = 0;\n+  state->handlers = NULL;\n+  state->last_handler = NULL;\n+  state->num_handlers = 0;\n }\n \n void\n@@ -1731,6 +2357,7 @@ generate_classfile (clas, state)\n \t  static tree Code_node = NULL_TREE;\n \t  tree t;\n \t  char *attr_len_ptr;\n+\t  struct jcf_handler *handler;\n \t  if (Code_node == NULL_TREE)\n \t    Code_node = get_identifier (\"Code\");\n \t  ptr = append_chunk (NULL, 14, state);\n@@ -1741,13 +2368,20 @@ generate_classfile (clas, state)\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n \t    localvar_alloc (t, state);\n \t  generate_bytecode_insns (body, IGNORE_TARGET, state);\n+\t  if (CAN_COMPLETE_NORMALLY (body))\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (type)) != VOID_TYPE)\n+\t\tabort();\n+\t      RESERVE (1);\n+\t      OP1 (OPCODE_return);\n+\t    }\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n \t    localvar_free (t, state);\n \t  finish_jcf_block (state);\n \t  perform_relocations (state);\n \n \t  ptr = attr_len_ptr;\n-\t  i = 8 + state->code_length + 4;\n+\t  i = 8 + state->code_length + 4 + 8 * state->num_handlers;\n \t  if (state->linenumber_count > 0)\n \t    {\n \t      code_attributes_count++;\n@@ -1762,8 +2396,26 @@ generate_classfile (clas, state)\n \t  PUT2 (state->code_SP_max);  /* max_stack */\n \t  PUT2 (localvar_max);  /* max_locals */\n \t  PUT4 (state->code_length);\n-\t  ptr = append_chunk (NULL, 4, state);\n-\t  PUT2 (0);  /* exception_table_length */\n+\n+\t  /* Emit the exception table. */\n+\t  ptr = append_chunk (NULL, 2 + 8 * state->num_handlers, state);\n+\t  PUT2 (state->num_handlers);  /* exception_table_length */\n+\t  handler = state->handlers;\n+\t  for (; handler != NULL;  handler = handler->next)\n+\t    {\n+\t      int type_index;\n+\t      PUT2 (handler->start_label->pc);\n+\t      PUT2 (handler->end_label->pc);\n+\t      PUT2 (handler->handler_label->pc);\n+\t      if (handler->type == NULL_TREE)\n+\t\ttype_index = 0;\n+\t      else\n+\t\ttype_index = find_class_constant (&state->cpool,\n+\t\t\t\t\t\t  handler->type);\n+\t      PUT2 (type_index);\n+\t    }\n+\n+\t  ptr = append_chunk (NULL, 2, state);\n \t  PUT2 (code_attributes_count);\n \n \t  /* Write the LineNumberTable attribute. */\n@@ -1877,3 +2529,8 @@ write_classfile (clas)\n     fatal (\"failed to close after writing `%s'\", class_file_name);\n   release_jcf_state (state);\n }\n+\n+/* TODO:\n+   string concatenation\n+   synchronized statement\n+   */"}]}