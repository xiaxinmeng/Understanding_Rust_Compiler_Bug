{"sha": "d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5Y2JjYjVlM2RkODNlMjYyOGQyNWQyY2QyMzg5MmE0Y2FjODNiMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-09-12T22:23:59Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-09-12T22:23:59Z"}, "message": "re GNATS gcj/33 (gcj mangles composed characters)\n\n\tFix for PR gcj/33:\n\t* jv-scan.c (help): Document --encoding.\n\t(options): Added `encoding' entry.\n\t(OPT_ENCODING): New define.\n\t(main): Handle --encoding.\n\tInclude <langinfo.h> if nl_langinfo exists.\n\t* lang-options.h: Document --classpath, --CLASSPATH, --main, and\n\t--encoding.\n\t* jcf-parse.c Include <langinfo.h> if we have nl_langinfo.\n\t(parse_source_file): Correctly call java_init_lex.  Added `finput'\n\targument.  Use nl_langinfo to determine default encoding.\n\t* java-tree.h (current_encoding): Declare.\n\t* parse.y (java_parser_context_restore_global): Don't restore\n\t`finput'.\n\t(java_parser_context_save_global): Don't set `finput' field.\n\t(java_pop_parser_context): Don't restore `finput'.  Free old lexer\n\tif required.\n\t* lang.c (current_encoding): New global.\n\t(lang_decode_option): Recognize `-fencoding='.\n\t(finish_parse): Don't close finput.\n\t* parse.h (struct parser_ctxt): Removed `finput' and\n\t`unget_utf8_value' fields.  Added `lexer' field.\n\t(java_init_lex): Fixed declaration.\n\t* lex.c (java_new_lexer): New function.\n\t(java_destroy_lexer): Likewise.\n\t(java_read_char): Added `lex' argument.  Handle iconv case.\n\t(java_read_unicode): Added `lex' argument.  Count backslashes in\n\tlexer structure.\n\t(java_init_lex): Added `finput' and `encoding' arguments.  Set\n\t`lexer' field in ctxp.\n\t(BAD_UTF8_VALUE): Removed.\n\t(java_lex): Handle seeing UEOF in the middle of a string literal.\n\t* lex.h: Include <iconv.h> if HAVE_ICONV defined.\n\t(java_lexer): New structure.\n\t(UNGETC): Removed.\n\t(GETC): Removed.\n\t(DEFAULT_ENCODING): New define.\n\t(java_destroy_lexer): Declare.\n\nFrom-SVN: r36377", "tree": {"sha": "21cc6935b87686835780712e1d9a7d64eae418d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21cc6935b87686835780712e1d9a7d64eae418d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/comments", "author": null, "committer": null, "parents": [{"sha": "ee17a29049f330ff40a486e56826468a223323c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee17a29049f330ff40a486e56826468a223323c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee17a29049f330ff40a486e56826468a223323c2"}], "stats": {"total": 467, "additions": 363, "deletions": 104}, "files": [{"sha": "7b13f9a0485da645d913a943e155dd86ccac7ea2", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -1,3 +1,44 @@\n+2000-09-12  Tom Tromey  <tromey@cygnus.com>\n+\n+\tFix for PR gcj/33:\n+\t* jv-scan.c (help): Document --encoding.\n+\t(options): Added `encoding' entry.\n+\t(OPT_ENCODING): New define.\n+\t(main): Handle --encoding.\n+\tInclude <langinfo.h> if nl_langinfo exists.\n+\t* lang-options.h: Document --classpath, --CLASSPATH, --main, and\n+\t--encoding.\n+\t* jcf-parse.c Include <langinfo.h> if we have nl_langinfo.\n+\t(parse_source_file): Correctly call java_init_lex.  Added `finput'\n+\targument.  Use nl_langinfo to determine default encoding.\n+\t* java-tree.h (current_encoding): Declare.\n+\t* parse.y (java_parser_context_restore_global): Don't restore\n+\t`finput'.\n+\t(java_parser_context_save_global): Don't set `finput' field.\n+\t(java_pop_parser_context): Don't restore `finput'.  Free old lexer\n+\tif required.\n+\t* lang.c (current_encoding): New global.\n+\t(lang_decode_option): Recognize `-fencoding='.\n+\t(finish_parse): Don't close finput.\n+\t* parse.h (struct parser_ctxt): Removed `finput' and\n+\t`unget_utf8_value' fields.  Added `lexer' field.\n+\t(java_init_lex): Fixed declaration.\n+\t* lex.c (java_new_lexer): New function.\n+\t(java_destroy_lexer): Likewise.\n+\t(java_read_char): Added `lex' argument.  Handle iconv case.\n+\t(java_read_unicode): Added `lex' argument.  Count backslashes in\n+\tlexer structure.\n+\t(java_init_lex): Added `finput' and `encoding' arguments.  Set\n+\t`lexer' field in ctxp.\n+\t(BAD_UTF8_VALUE): Removed.\n+\t(java_lex): Handle seeing UEOF in the middle of a string literal.\n+\t* lex.h: Include <iconv.h> if HAVE_ICONV defined.\n+\t(java_lexer): New structure.\n+\t(UNGETC): Removed.\n+\t(GETC): Removed.\n+\t(DEFAULT_ENCODING): New define.\n+\t(java_destroy_lexer): Declare.\n+\n 2000-09-12  Tom Tromey  <tromey@cygnus.com>\n \n \tFix for PR gcj/343:"}, {"sha": "18cdf7a785d7581271ed7ccb9ff788c088778487", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -169,6 +169,9 @@ extern int flag_use_boehm_gc;\n    object to its synchronization structure.  */\n extern int flag_hash_synchronization;\n \n+/* Encoding used for source files.  */\n+extern char *current_encoding;\n+\n /* The Java .class file that provides main_class;  the main input file. */\n extern struct JCF *current_jcf;\n "}, {"sha": "4b76f598ca0279344652a27bf03e17eee179754b", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -35,6 +35,10 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"parse.h\"\n \n+#ifdef HAVE_NL_LANGINFO\n+#include <langinfo.h>\n+#endif\n+\n /* A CONSTANT_Utf8 element is converted to an IDENTIFIER_NODE at parse time. */\n #define JPOOL_UTF(JCF, INDEX) CPOOL_UTF(&(JCF)->cpool, INDEX)\n #define JPOOL_UTF_LENGTH(JCF, INDEX) IDENTIFIER_LENGTH (JPOOL_UTF (JCF, INDEX))\n@@ -83,7 +87,7 @@ static struct JCF main_jcf[1];\n static tree give_name_to_class PARAMS ((JCF *jcf, int index));\n static void parse_zip_file_entries PARAMS ((void));\n static void process_zip_dir PARAMS ((void));\n-static void parse_source_file PARAMS ((tree));\n+static void parse_source_file PARAMS ((tree, FILE *));\n static void jcf_parse_source PARAMS ((void));\n static int jcf_figure_file_type PARAMS ((JCF *));\n static int find_in_current_zip PARAMS ((const char *, struct JCF **));\n@@ -564,6 +568,7 @@ static void\n jcf_parse_source ()\n {\n   tree file;\n+  FILE *finput;\n \n   java_parser_context_save_global ();\n   java_push_parser_context ();\n@@ -576,7 +581,7 @@ jcf_parse_source ()\n       if (!(finput = fopen (input_filename, \"r\")))\n \tfatal (\"input file `%s' just disappeared - jcf_parse_source\",\n \t       input_filename);\n-      parse_source_file (file);\n+      parse_source_file (file, finput);\n       if (fclose (finput))\n \tfatal (\"can't close input file `%s' stream - jcf_parse_source\",\n \t       input_filename);\n@@ -754,8 +759,9 @@ parse_class_file ()\n /* Parse a source file, as pointed by the current value of INPUT_FILENAME. */\n \n static void\n-parse_source_file (file)\n+parse_source_file (file, finput)\n      tree file;\n+     FILE *finput;\n {\n   int save_error_count = java_error_count;\n   /* Mark the file as parsed */\n@@ -765,7 +771,21 @@ parse_source_file (file)\n \n   lang_init_source (1);\t\t    /* Error msgs have no method prototypes */\n \n-  java_init_lex ();\t\t    /* Initialize the parser */\n+  /* There's no point in trying to find the current encoding unless we\n+     are going to do something intelligent with it -- hence the test\n+     for iconv.  */\n+#ifdef HAVE_ICONV\n+#ifdef HAVE_NL_LANGINFO\n+  setlocale (LC_CTYPE, \"\");\n+  if (current_encoding == NULL)\n+    current_encoding = nl_langinfo (CODESET);\n+#endif /* HAVE_NL_LANGINFO */\n+#endif /* HAVE_ICONV */\n+  if (current_encoding == NULL || *current_encoding == '\\0')\n+    current_encoding = DEFAULT_ENCODING;\n+\n+  /* Initialize the parser */\n+  java_init_lex (finput, current_encoding);\n   java_parse_abort_on_error ();\n \n   java_parse ();\t\t    /* Parse and build partial tree nodes. */\n@@ -796,6 +816,7 @@ yyparse ()\n   int several_files = 0;\n   char *list = xstrdup (input_filename), *next;\n   tree node, current_file_list = NULL_TREE;\n+  FILE *finput;\n \n   do \n     {\n@@ -901,7 +922,7 @@ yyparse ()\n \tcase JCF_SOURCE:\n \t  java_push_parser_context ();\n \t  java_parser_context_save_global ();\n-\t  parse_source_file (name);\n+\t  parse_source_file (name, finput);\n \t  java_parser_context_restore_global ();\n \t  java_pop_parser_context (1);\n \t  break;"}, {"sha": "ae9c91d108e3a7cbe521111deaf339b21d5f2676", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -26,6 +26,10 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"version.h\"\n \n+#ifdef HAVE_NL_LANGINFO\n+#include <langinfo.h>\n+#endif\n+\n #include <getopt.h>\n \n void fatal PARAMS ((const char *s, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n@@ -61,6 +65,7 @@ int flag_list_filename = 0;\n \n #define OPT_HELP      LONG_OPT (0)\n #define OPT_VERSION   LONG_OPT (1)\n+#define OPT_ENCODING  LONG_OPT (2)\n \n static struct option options[] =\n {\n@@ -69,6 +74,7 @@ static struct option options[] =\n   { \"print-main\", no_argument,      &flag_find_main, 1 },\n   { \"list-filename\", no_argument,   &flag_list_filename, 1 },\n   { \"list-class\", no_argument,      &flag_dump_class, 1 },\n+  { \"encoding\",  required_argument, NULL, OPT_ENCODING },\n   { NULL,        no_argument,       NULL, 0 }\n };\n \n@@ -84,6 +90,7 @@ help ()\n {\n   printf (\"Usage: jv-scan [OPTION]... FILE...\\n\\n\");\n   printf (\"Print useful information read from Java source files.\\n\\n\");\n+  printf (\"  --encoding NAME         Specify encoding of input file\\n\");\n   printf (\"  --print-main            Print name of class containing `main'\\n\");\n   printf (\"  --list-class            List all classes defined in file\\n\");\n   printf (\"  --list-filename         Print input filename when listing class names\\n\");\n@@ -114,6 +121,7 @@ DEFUN (main, (argc, argv),\n {\n   int i = 1;\n   const char *output_file = NULL;\n+  const char *encoding = NULL;\n   long ft;\n   int opt;\n \n@@ -144,6 +152,10 @@ DEFUN (main, (argc, argv),\n \t  version ();\n \t  break;\n \n+\tcase OPT_ENCODING:\n+\t  encoding = optarg;\n+\t  break;\n+\n \tdefault:\n \t  usage ();\n \t  break;\n@@ -172,7 +184,20 @@ DEFUN (main, (argc, argv),\n \tinput_filename = argv [i];\n \tif ( (finput = fopen (argv [i], \"r\")) )\n \t  {\n-\t    java_init_lex ();\n+\t    /* There's no point in trying to find the current encoding\n+\t       unless we are going to do something intelligent with it\n+\t       -- hence the test for iconv.  */\n+#ifdef HAVE_ICONV\n+#ifdef HAVE_NL_LANGINFO\n+\t    setlocale (LC_CTYPE, \"\");\n+\t    if (encoding == NULL)\n+\t      encoding = nl_langinfo (CODESET);\n+#endif /* HAVE_NL_LANGINFO */\n+#endif /* HAVE_ICONV */\n+\t    if (encoding == NULL || *encoding == '\\0')\n+\t      encoding = DEFAULT_ENCODING;\n+\n+\t    java_init_lex (finput, encoding);\n \t    yyparse ();\n \t    if (ftell (out) != ft)\n \t      fputc ('\\n', out);"}, {"sha": "2b207dcdeb2ac1cc77a83143208cde76bfb0c9d7", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -42,8 +42,10 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-M\", \"Print dependencies to stdout\" },\n   { \"-MM\", \"Print dependencies to stdout\" },\n #endif /* ! USE_CPPLIB */\n-  { \"-fclasspath\", \"Set class path and suppress system path\" },\n-  { \"-fCLASSPATH\", \"Set class path\" },\n+  { \"--classpath\", \"Set class path and suppress system path\" },\n+  { \"--CLASSPATH\", \"Set class path\" },\n+  { \"--main\", \"Choose class whose main method should be used\" },\n+  { \"--encoding\", \"Choose input encoding (default is UTF-8)\" },\n   { \"-I\", \"Add directory to class path\" },\n   { \"-foutput-class-dir\", \"Directory where class files should be written\" },\n   { \"-fuse-divide-subroutine\", \"\" },"}, {"sha": "2dc33f22b0902958d031c530a95e9579347929be", "filename": "gcc/java/lang.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -121,6 +121,9 @@ int flag_hash_synchronization;\n    JNI, not CNI.  */\n int flag_jni = 0;\n \n+/* The encoding of the source file.  */\n+char *current_encoding = NULL;\n+\n /* When non zero, report the now deprecated empty statements.  */\n int flag_extraneous_semicolon;\n \n@@ -222,6 +225,13 @@ lang_decode_option (argc, argv)\n       return 1;\n     }\n #undef ARG\n+#define ARG \"-fencoding=\"\n+  if (strncmp (p, ARG, sizeof (ARG) - 1) == 0)\n+    {\n+      current_encoding = p + sizeof (ARG) - 1;\n+      return 1;\n+    }\n+#undef ARG\n \n   if (p[0] == '-' && p[1] == 'f')\n     {\n@@ -309,7 +319,9 @@ lang_decode_option (argc, argv)\n   return 0;\n }\n \n+/* Global open file.  */\n FILE *finput;\n+\n const char *\n init_parse (filename)\n      const char *filename;\n@@ -362,6 +374,7 @@ init_parse (filename)\n \t    }\n \t}\n     }\n+\n   init_lex ();\n \n   return filename;\n@@ -370,7 +383,6 @@ init_parse (filename)\n void\n finish_parse ()\n {\n-  fclose (finput);\n   jcf_dependency_write ();\n }\n "}, {"sha": "4179b1dbca50b77f940feb62f61e983818320138", "filename": "gcc/java/lex.c", "status": "modified", "additions": 207, "deletions": 85, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -24,15 +24,15 @@ of Sun Microsystems, Inc. in the United States and other countries.\n The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n /* It defines java_lex (yylex) that reads a Java ASCII source file\n-possibly containing Unicode escape sequence or utf8 encoded characters\n-and returns a token for everything found but comments, white spaces\n-and line terminators. When necessary, it also fills the java_lval\n-(yylval) union. It's implemented to be called by a re-entrant parser\n-generated by Bison.\n+   possibly containing Unicode escape sequence or utf8 encoded\n+   characters and returns a token for everything found but comments,\n+   white spaces and line terminators. When necessary, it also fills\n+   the java_lval (yylval) union. It's implemented to be called by a\n+   re-entrant parser generated by Bison.\n \n-The lexical analysis conforms to the Java grammar described in \"The\n-Java(TM) Language Specification. J. Gosling, B. Joy, G. Steele.\n-Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html)  */\n+   The lexical analysis conforms to the Java grammar described in \"The\n+   Java(TM) Language Specification. J. Gosling, B. Joy, G. Steele.\n+   Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html) */\n \n #include \"keyword.h\"\n \n@@ -55,15 +55,18 @@ static int java_letter_or_digit_p PARAMS ((unicode_t));\n static int java_parse_doc_section PARAMS ((unicode_t));\n static void java_parse_end_comment PARAMS ((unicode_t));\n static unicode_t java_get_unicode PARAMS ((void));\n-static unicode_t java_read_unicode PARAMS ((int, int *));\n+static unicode_t java_read_unicode PARAMS ((java_lexer *, int, int *));\n static void java_store_unicode PARAMS ((struct java_line *, unicode_t, int));\n-static unicode_t java_read_char PARAMS ((void));\n+static unicode_t java_read_char PARAMS ((java_lexer *));\n static void java_allocate_new_line PARAMS ((void));\n static void java_unget_unicode PARAMS ((void));\n static unicode_t java_sneak_unicode PARAMS ((void));\n+java_lexer *java_new_lexer PARAMS ((FILE *, const char *));\n \n void\n-java_init_lex ()\n+java_init_lex (finput, encoding)\n+     FILE *finput;\n+     const char *encoding;\n {\n #ifndef JC1_LITE\n   int java_lang_imported = 0;\n@@ -114,9 +117,9 @@ java_init_lex ()\n   ctxp->lineno = lineno = 0;\n   ctxp->p_line = NULL;\n   ctxp->c_line = NULL;\n-  ctxp->unget_utf8_value = 0;\n   ctxp->minus_seen = 0;\n   ctxp->java_error_flag = 0;\n+  ctxp->lexer = java_new_lexer (finput, encoding);\n }\n \n static char *\n@@ -194,59 +197,180 @@ java_allocate_new_line ()\n   ctxp->c_line->white_space_only = 1;\n }\n \n-#define BAD_UTF8_VALUE 0xFFFE\n-\n-static unicode_t\n-java_read_char ()\n+/* Create a new lexer object.  */\n+java_lexer *\n+java_new_lexer (finput, encoding)\n+     FILE *finput;\n+     const char *encoding;\n {\n-  int c;\n-  int c1, c2;\n+  java_lexer *lex = (java_lexer *) xmalloc (sizeof (java_lexer));\n+  int enc_error = 0;\n+\n+  lex->finput = finput;\n+  lex->bs_count = 0;\n+  lex->unget_value = 0;\n \n-  if (ctxp->unget_utf8_value)\n+#ifdef HAVE_ICONV\n+  lex->handle = iconv_open (\"UCS-2\", encoding);\n+  if (lex->handle == (iconv_t) -1)\n     {\n-      int to_return = ctxp->unget_utf8_value;\n-      ctxp->unget_utf8_value = 0;\n-      return (to_return);\n+      /* FIXME: we should give a nice error based on errno here.  */\n+      enc_error = 1;\n     }\n+  lex->first = -1;\n+  lex->last = -1;\n+#else /* HAVE_ICONV */\n+  if (strcmp (encoding, DEFAULT_ENCODING))\n+    enc_error = 1;\n+#endif /* HAVE_ICONV */\n \n-  c = GETC ();\n+  if (enc_error)\n+    fatal (\"unknown encoding: `%s'\", encoding);\n \n-  if (c < 128)\n-    return (unicode_t)c;\n-  if (c == EOF)\n-    return UEOF;\n-  else\n+  return lex;\n+}\n+\n+void\n+java_destroy_lexer (lex)\n+     java_lexer *lex;\n+{\n+#ifdef HAVE_ICONV\n+  iconv_close (lex->handle);\n+#endif\n+  free (lex);\n+}\n+\n+static unicode_t\n+java_read_char (lex)\n+     java_lexer *lex;\n+{\n+  if (lex->unget_value)\n     {\n-      if ((c & 0xe0) == 0xc0)\n-        {\n-          c1 = GETC ();\n-\t  if ((c1 & 0xc0) == 0x80)\n-\t    return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n-\t  c = c1;\n-\t}\n-      else if ((c & 0xf0) == 0xe0)\n-        {\n-          c1 = GETC ();\n-\t  if ((c1 & 0xc0) == 0x80)\n-\t    {\n-\t      c2 = GETC ();\n-\t      if ((c2 & 0xc0) == 0x80)\n-\t        return (unicode_t)(((c & 0xf) << 12) + \n-\t\t\t\t   (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n-\t      else\n-\t\tc = c2;\n-\t    }\n-\t  else\n-\t    c = c1;\n-\t}\n-      /* We looked for a UTF8 multi-byte sequence (since we saw an initial\n-\t byte with the high bit set), but found invalid bytes instead.\n-\t If the most recent byte was Ascii (and not EOF), we should\n-\t unget it, in case it was a comment terminator or other delimitor. */\n-      if ((c & 0x80) == 0)\n-\tUNGETC (c);\n-      return BAD_UTF8_VALUE;\n+      unicode_t r = lex->unget_value;\n+      lex->unget_value = 0;\n+      return r;\n     }\n+\n+#ifdef HAVE_ICONV\n+  {\n+    char out[2];\n+    size_t ir, inbytesleft, in_save, out_count;\n+    char *inp, *outp;\n+\n+    while (1)\n+      {\n+\t/* See if we need to read more data.  If FIRST == 0 then the\n+\t   previous conversion attempt ended in the middle of a\n+\t   character at the end of the buffer.  Otherwise we only have\n+\t   to read if the buffer is empty.  */\n+\tif (lex->first == 0 || lex->first >= lex->last)\n+\t  {\n+\t    int r;\n+\n+\t    if (lex->first >= lex->last)\n+\t      {\n+\t\tlex->first = 0;\n+\t\tlex->last = 0;\n+\t      }\n+\t    if (feof (lex->finput))\n+\t      return UEOF;\n+\t    r = fread (&lex->buffer[lex->last], 1,\n+\t\t       sizeof (lex->buffer) - lex->last,\n+\t\t       lex->finput);\n+\t    lex->last += r;\n+\t  }\n+\n+\tinbytesleft = lex->last - lex->first;\n+\n+\tif (inbytesleft == 0)\n+\t  {\n+\t    /* We've tried to read and there is nothing left.  */\n+\t    return UEOF;\n+\t  }\n+\n+\tin_save = inbytesleft;\n+\tout_count = 2;\n+\tinp = &lex->buffer[lex->first];\n+\toutp = out;\n+\tir = iconv (lex->handle, (const char **) &inp, &inbytesleft,\n+\t\t    &outp, &out_count);\n+\tlex->first += in_save - inbytesleft;\n+\n+\tif (out_count == 0)\n+\t  {\n+\t    /* Success.  We assume that UCS-2 is big-endian.  This\n+\t       appears to be an ok assumption.  */\n+\t    unicode_t result;\n+\t    result = (((unsigned char) out[0]) << 8) | (unsigned char) out[1];\n+\t    return result;\n+\t  }\n+\n+\tif (ir == (size_t) -1)\n+\t  {\n+\t    if (errno == EINVAL)\n+\t      {\n+\t\t/* This is ok.  This means that the end of our buffer\n+\t\t   is in the middle of a character sequence.  We just\n+\t\t   move the valid part of the buffer to the beginning\n+\t\t   to force a read.  */\n+\t\t/* We use bcopy() because it should work for\n+\t\t   overlapping strings.  Use memmove() instead... */\n+\t\tbcopy (&lex->buffer[lex->first], &lex->buffer[0],\n+\t\t       lex->last - lex->first);\n+\t\tlex->last -= lex->first;\n+\t\tlex->first = 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* A more serious error.  */\n+\t\tjava_lex_error (\"unrecognized character in input stream\", 0);\n+\t\treturn UEOF;\n+\t      }\n+\t  }\n+      }\n+  }\n+#else /* HAVE_ICONV */\n+  {\n+    int c, c1, c2;\n+    c = getc (lex->finput);\n+\n+    if (c < 128)\n+      return (unicode_t)c;\n+    if (c == EOF)\n+      return UEOF;\n+    else\n+      {\n+\tif ((c & 0xe0) == 0xc0)\n+\t  {\n+\t    c1 = getc (lex->finput);\n+\t    if ((c1 & 0xc0) == 0x80)\n+\t      return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n+\t    c = c1;\n+\t  }\n+\telse if ((c & 0xf0) == 0xe0)\n+\t  {\n+\t    c1 = getc (lex->finput);\n+\t    if ((c1 & 0xc0) == 0x80)\n+\t      {\n+\t\tc2 = getc (lex->finput);\n+\t\tif ((c2 & 0xc0) == 0x80)\n+\t\t  return (unicode_t)(((c & 0xf) << 12) + \n+\t\t\t\t     (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n+\t\telse\n+\t\t  c = c2;\n+\t      }\n+\t    else\n+\t      c = c1;\n+\t  }\n+\n+\t/* We simply don't support invalid characters.  */\n+\tjava_lex_error (\"malformed UTF-8 character\", 0);\n+      }\n+  }\n+#endif /* HAVE_ICONV */\n+\n+  /* We only get here on error.  */\n+  return UEOF;\n }\n \n static void\n@@ -267,56 +391,54 @@ java_store_unicode (l, c, unicode_escape_p)\n }\n \n static unicode_t\n-java_read_unicode (term_context, unicode_escape_p)\n-    int term_context;\n-    int *unicode_escape_p;\n+java_read_unicode (lex, term_context, unicode_escape_p)\n+     java_lexer *lex;\n+     int term_context;\n+     int *unicode_escape_p;\n {\n   unicode_t c;\n-  long i, base;\n \n-  c = java_read_char ();\n+  c = java_read_char (lex);\n   *unicode_escape_p = 0;\n \n   if (c != '\\\\')\n-    return ((term_context ? c : \n-\t     java_lineterminator (c) ? '\\n' : (unicode_t)c));\n-\n-  /* Count the number of preceeding '\\' */\n-  for (base = ftell (finput), i = base-2; c == '\\\\';)\n-    { \n-      fseek (finput, i--, SEEK_SET);\n-      c = java_read_char ();\t/* Will fail if reading utf8 stream. FIXME */\n+    {\n+      lex->bs_count = 0;\n+      return (term_context ? c : (java_lineterminator (c)\n+\t\t\t\t  ? '\\n'\n+\t\t\t\t  : (unicode_t) c));\n     }\n-  fseek (finput, base, SEEK_SET);\n-  if ((base-i-3)%2 == 0)\t/* If odd number of \\ seen */\n+\n+  ++lex->bs_count;\n+  if ((lex->bs_count) % 2 == 1)\n     {\n-      c = java_read_char ();\n+      /* Odd number of \\ seen.  */\n+      c = java_read_char (lex);\n       if (c == 'u')\n         {\n-\t  unsigned short unicode = 0;\n+\t  unicode_t unicode = 0;\n \t  int shift = 12;\n \t  /* Next should be 4 hex digits, otherwise it's an error.\n \t     The hex value is converted into the unicode, pushed into\n \t     the Unicode stream.  */\n \t  for (shift = 12; shift >= 0; shift -= 4)\n \t    {\n-\t      if ((c = java_read_char ()) == UEOF)\n+\t      if ((c = java_read_char (lex)) == UEOF)\n \t        return UEOF;\n \t      if (c >= '0' && c <= '9')\n \t\tunicode |= (unicode_t)((c-'0') << shift);\n \t      else if ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))\n \t        unicode |= (unicode_t)((10+(c | 0x20)-'a') << shift);\n \t      else\n-\t\t  java_lex_error \n-\t\t    (\"Non hex digit in Unicode escape sequence\", 0);\n+\t\tjava_lex_error (\"Non hex digit in Unicode escape sequence\", 0);\n \t    }\n \t  *unicode_escape_p = 1;\n-\t  return (term_context ? unicode :\n-\t\t  (java_lineterminator (c) ? '\\n' : unicode));\n+\t  return (term_context\n+\t\t  ? unicode : (java_lineterminator (c) ? '\\n' : unicode));\n \t}\n-      ctxp->unget_utf8_value = c;\n+      lex->unget_value = c;\n     }\n-  return (unicode_t)'\\\\';\n+  return (unicode_t) '\\\\';\n }\n \n static unicode_t\n@@ -331,7 +453,7 @@ java_get_unicode ()\n \tfor (;;)\n \t  {\n \t    int unicode_escape_p;\n-\t    c = java_read_unicode (0, &unicode_escape_p);\n+\t    c = java_read_unicode (ctxp->lexer, 0, &unicode_escape_p);\n \t    java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n \t    if (ctxp->c_line->white_space_only \n \t\t&& !JAVA_WHITE_SPACE_P (c) && c!='\\n')\n@@ -354,7 +476,7 @@ java_lineterminator (c)\n   else if (c == '\\r')\t\t/* CR */\n     {\n       int unicode_escape_p;\n-      c = java_read_unicode (1, &unicode_escape_p);\n+      c = java_read_unicode (ctxp->lexer, 1, &unicode_escape_p);\n       if (c == '\\r')\n \t{\n \t  /* In this case we will have another terminator.  For some\n@@ -363,7 +485,7 @@ java_lineterminator (c)\n \t     up in the actual text of the line, causing an error.  So\n \t     instead we choose a very low-level method.  FIXME: this\n \t     is incredibly ugly.  */\n-\t  UNGETC (c);\n+\t  ctxp->lexer->unget_value = c;\n \t}\n       else if (c != '\\n')\n \t{\n@@ -939,7 +1061,7 @@ java_lex (java_lval)\n       char *string;\n \n       for (no_error = 1, c = java_get_unicode (); \n-\t   c != '\"' && c != '\\n'; c = java_get_unicode ())\n+\t   c != UEOF && c != '\"' && c != '\\n'; c = java_get_unicode ())\n \t{\n \t  if (c == '\\\\')\n \t    c = java_parse_escape_sequence ();"}, {"sha": "cf29aa16a70e271f8e4cf78fa3c90e36b867305d", "filename": "gcc/java/lex.h", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -35,6 +35,13 @@ extern int   lineno;\n /* A Unicode character, as read from the input file  */\n typedef unsigned short unicode_t;\n \n+#ifdef HAVE_ICONV\n+#include <iconv.h>\n+#endif /* HAVE_ICONV */\n+\n+/* Default encoding to use if no encoding is specified.  */\n+#define DEFAULT_ENCODING \"UTF-8\"\n+\n /* Debug macro to print-out what we match  */\n #ifdef JAVA_LEX_DEBUG\n #ifdef JAVA_LEX_DEBUG_CHAR\n@@ -96,12 +103,38 @@ typedef struct _java_lc {\n   int col;\n } java_lc;\n \n+typedef struct java_lexer\n+{\n+  /* The file from which we're reading.  */\n+  FILE *finput;\n \n-#define JAVA_LINE_MAX 80\n+  /* Number of consecutive backslashes we've read.  */\n+  int bs_count;\n+\n+  /* If nonzero, a value that was pushed back.  */\n+  unicode_t unget_value;\n+\n+#ifdef HAVE_ICONV\n+  /* The handle for the iconv converter we're using.  */\n+  iconv_t handle;\n \n-/* Macro to read and unread bytes */\n-#define UNGETC(c) ungetc(c, finput)\n-#define GETC()    getc(finput)\n+  /* Bytes we've read from the file but have not sent to iconv.  */\n+  char buffer[1024];\n+\n+  /* Index of first valid character in buffer, -1 if no valid\n+     characters.  */\n+  int first;\n+\n+  /* Index of last valid character in buffer, plus one.  -1 if no\n+     valid characters in buffer.  */\n+  int last;\n+#endif /* HAVE_ICONV */\n+} java_lexer;\n+\n+/* Destroy a lexer object.  */\n+extern void java_destroy_lexer PARAMS ((java_lexer *));\n+\n+#define JAVA_LINE_MAX 80\n \n /* Build a location compound integer */\n #define BUILD_LOCATION() ((ctxp->elc.line << 12) | (ctxp->elc.col & 0xfff))"}, {"sha": "b1b0e8e9831d516bbd1682c44833f7c3aabbb7c8", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -728,13 +728,12 @@ typedef struct _jdeplist {\n struct parser_ctxt {\n \n   const char *filename;\t\t    /* Current filename */\n-  FILE *finput;\t\t\t    /* Current file input stream */\n   struct parser_ctxt *next;\n \n+  java_lexer *lexer;\t\t     /* Current lexer state */\n   char marker_begining;\t\t     /* Marker. Should be a sub-struct */\n   struct java_line *p_line, *c_line; /* Previous and current line */\n   java_lc elc;\t\t\t     /* Error's line column info */\n-  unicode_t unget_utf8_value;        /* An unget utf8 value */\n   int ccb_indent;\t\t     /* Keep track of {} indent, lexer */\n   int first_ccb_indent1;\t     /* First { at ident level 1 */\n   int last_ccb_indent1;\t\t     /* Last } at ident level 1 */\n@@ -928,7 +927,7 @@ extern void reset_report PARAMS ((void));\n /* Always in use, no matter what you compile */\n void java_push_parser_context PARAMS ((void));\n void java_pop_parser_context PARAMS ((int));\n-void java_init_lex PARAMS ((void));\n+void java_init_lex PARAMS ((FILE *, const char *));\n extern void java_parser_context_save_global PARAMS ((void));\n extern void java_parser_context_restore_global PARAMS ((void));\n int yyparse PARAMS ((void));"}, {"sha": "42f4206948a30d0d5a8e2903fb36c2a6b177059b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=d19cbcb5e3dd83e2628d25d2cd23892a4cac83b0", "patch": "@@ -2618,10 +2618,13 @@ java_pop_parser_context (generate)\n       next->incomplete_class = ctxp->incomplete_class;\n       next->gclass_list = ctxp->gclass_list;\n       lineno = ctxp->lineno;\n-      finput = ctxp->finput;\n       current_class = ctxp->current_class;\n     }\n \n+  /* If the old and new lexers differ, then free the old one.  */\n+  if (ctxp->lexer && next && ctxp->lexer != next->lexer)\n+    java_destroy_lexer (ctxp->lexer);\n+\n   /* Set the single import class file flag to 0 for the current list\n      of imported things */\n   for (current = ctxp->import_list; current; current = TREE_CHAIN (current))\n@@ -2661,7 +2664,6 @@ java_parser_context_save_global ()\n   else if (ctxp->saved_data)\n     create_new_parser_context (1);\n \n-  ctxp->finput = finput;\n   ctxp->lineno = lineno;\n   ctxp->current_class = current_class;\n   ctxp->filename = input_filename;\n@@ -2675,7 +2677,6 @@ java_parser_context_save_global ()\n void\n java_parser_context_restore_global ()\n {\n-  finput = ctxp->finput;\n   lineno = ctxp->lineno;\n   current_class = ctxp->current_class;\n   input_filename = ctxp->filename;"}]}