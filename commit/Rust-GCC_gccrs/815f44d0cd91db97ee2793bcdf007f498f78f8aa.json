{"sha": "815f44d0cd91db97ee2793bcdf007f498f78f8aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE1ZjQ0ZDBjZDkxZGI5N2VlMjc5M2JjZGYwMDdmNDk4Zjc4ZjhhYQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2007-04-06T09:23:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:23:23Z"}, "message": "i-fortra.ads: Add Double_Complex type.\n\n2007-04-06  Geert Bosch  <bosch@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* i-fortra.ads: Add Double_Complex type.\n\n\t* impunit.adb: (Is_Known_Unit): New function\n\tAdd Gnat.Byte_Swapping\n\tAdd GNAT.SHA1\n\tAdd new Ada 2005 units\n\tAda.Numerics.Generic_Complex_Arrays, Ada.Numerics.Generic_Real_Arrays,\n\tAda.Numerics.Complex_Arrays, Ada.Numerics.Real_Arrays,\n\tAda.Numerics.Long_Complex_Arrays, Ada.Numerics.Long_Long_Complex_Arrays,\n\tAda.Numerics.Long_Long_Real_Arrays and Ada.Numerics.Long_Real_Arrays\n\n\t* impunit.ads (Is_Known_Unit): New function\n\n\t* a-ngcoar.adb, a-ngcoar.ads, a-ngrear.adb,\n\ta-ngrear.ads, a-nlcoar.ads, a-nllcar.ads, a-nllrar.ads, a-nlrear.ads,\n\ta-nucoar.ads, a-nurear.ads, g-bytswa.adb, g-bytswa-x86.adb,\n\tg-bytswa.ads, g-sha1.adb, g-sha1.ads, i-forbla.ads, i-forlap.ads,\n\ts-gearop.adb, s-gearop.ads, s-gecobl.adb, s-gecobl.ads, s-gecola.adb,\n\ts-gecola.ads, s-gerebl.adb, s-gerebl.ads, s-gerela.adb, s-gerela.ads:\n\tNew files.\n\n\t* Makefile.rtl: Add g-bytswa, g-sha1, a-fzteio and a-izteio\n\n\t* a-fzteio.ads, a-izteio.ads: New Ada 2005 run-time units.\n\nFrom-SVN: r123579", "tree": {"sha": "3dae18939bf7386b4ee86c6180790a3c352c21c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dae18939bf7386b4ee86c6180790a3c352c21c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/815f44d0cd91db97ee2793bcdf007f498f78f8aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815f44d0cd91db97ee2793bcdf007f498f78f8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815f44d0cd91db97ee2793bcdf007f498f78f8aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815f44d0cd91db97ee2793bcdf007f498f78f8aa/comments", "author": null, "committer": null, "parents": [{"sha": "0ee3046437815605b29af1b39aa17596286078ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee3046437815605b29af1b39aa17596286078ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee3046437815605b29af1b39aa17596286078ca"}], "stats": {"total": 7251, "additions": 7246, "deletions": 5}, "files": [{"sha": "aed7b6174ee3e01201b0233e8fee95e7e113c59c", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -26,7 +26,6 @@\n \n # Objects needed only for tasking\n GNATRTL_TASKING_OBJS= \\\n-  a-diroro$(objext) \\\n   a-dispat$(objext) \\\n   a-dynpri$(objext) \\\n   a-interr$(objext) \\\n@@ -135,9 +134,11 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-finali$(objext) \\\n   a-flteio$(objext) \\\n   a-fwteio$(objext) \\\n+  a-fzteio$(objext) \\\n   a-inteio$(objext) \\\n   a-ioexce$(objext) \\\n   a-iwteio$(objext) \\\n+  a-izteio$(objext) \\\n   a-lcteio$(objext) \\\n   a-lfteio$(objext) \\\n   a-llctio$(objext) \\\n@@ -313,6 +314,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-bubsor$(objext) \\\n   g-busora$(objext) \\\n   g-busorg$(objext) \\\n+  g-bytswa$(objext) \\\n   g-calend$(objext) \\\n   g-casuti$(objext) \\\n   g-catiio$(objext) \\\n@@ -350,6 +352,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-regexp$(objext) \\\n   g-regpat$(objext) \\\n   g-sestin$(objext) \\\n+  g-sha1$(objext) \\\n   g-soccon$(objext) \\\n   g-socket$(objext) \\\n   g-socthi$(objext) \\"}, {"sha": "81bf7b20e65b2383b53170842702b9d617293f58", "filename": "gcc/ada/a-fzteio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-fzteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-fzteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fzteio.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,19 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--          A D A . F L O A T _ W I D E _ W I D E _ T E X T _ I O           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO;\n+\n+package Ada.Float_Wide_Wide_Text_IO is\n+  new Ada.Wide_Wide_Text_IO.Float_IO (Float);"}, {"sha": "8eb5466d84d94f4cb028a694b6550c547d65b715", "filename": "gcc/ada/a-izteio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-izteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-izteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-izteio.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,19 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--        A D A . I N T E G E R _ W I D E _ W I D E _ T E X T _ I O         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO;\n+\n+package Ada.Integer_Wide_Wide_Text_IO is\n+  new Ada.Wide_Wide_Text_IO.Integer_IO (Integer);"}, {"sha": "7d5a51e79374f0b87e9597476677c9664923df24", "filename": "gcc/ada/a-ngcoar.adb", "status": "added", "additions": 1501, "deletions": 0, "changes": 1501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngcoar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngcoar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoar.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,1501 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.NUMERICS.GENERIC_COMPLEX_ARRAYS                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+with System.Generic_Complex_BLAS;\n+with System.Generic_Complex_LAPACK;\n+\n+package body Ada.Numerics.Generic_Complex_Arrays is\n+\n+   --  Operations involving inner products use BLAS library implementations.\n+   --  This allows larger matrices and vectors to be computed efficiently,\n+   --  taking into account memory hierarchy issues and vector instructions\n+   --  that vary widely between machines.\n+\n+   --  Operations that are defined in terms of operations on the type Real,\n+   --  such as addition, subtraction and scaling, are computed in the canonical\n+   --  way looping over all elements.\n+\n+   --  Operations for solving linear systems and computing determinant,\n+   --  eigenvalues, eigensystem and inverse, are implemented using the\n+   --  LAPACK library.\n+\n+   type BLAS_Real_Vector is array (Integer range <>) of Real;\n+\n+   package BLAS is new System.Generic_Complex_BLAS\n+     (Real           => Real,\n+      Complex_Types  => Complex_Types,\n+      Complex_Vector => Complex_Vector,\n+      Complex_Matrix => Complex_Matrix);\n+\n+   package LAPACK is new System.Generic_Complex_LAPACK\n+     (Real           => Real,\n+      Real_Vector    => BLAS_Real_Vector,\n+      Complex_Types  => Complex_Types,\n+      Complex_Vector => Complex_Vector,\n+      Complex_Matrix => Complex_Matrix);\n+\n+   use BLAS, LAPACK;\n+\n+   --  Procedure versions of functions returning unconstrained values.\n+   --  This allows for inlining the function wrapper.\n+\n+   procedure Eigenvalues\n+     (A      : Complex_Matrix;\n+      Values : out Real_Vector);\n+\n+   procedure Inverse\n+     (A      : Complex_Matrix;\n+      R      : out Complex_Matrix);\n+\n+   procedure Solve\n+     (A      : Complex_Matrix;\n+      X      : Complex_Vector;\n+      B      : out Complex_Vector);\n+\n+   procedure Solve\n+     (A      : Complex_Matrix;\n+      X      : Complex_Matrix;\n+      B      : out Complex_Matrix);\n+\n+   procedure Transpose is new System.Generic_Array_Operations.Transpose\n+                                (Scalar => Complex,\n+                                 Matrix => Complex_Matrix);\n+\n+   --  Helper function that raises a Constraint_Error is the argument is\n+   --  not a square matrix, and otherwise returns its length.\n+\n+   function Length is new Square_Matrix_Length (Complex, Complex_Matrix);\n+\n+   --  Instantiating the following subprograms directly would lead to\n+   --  name clashes, so use a local package.\n+\n+   package Instantiations is\n+\n+      ---------\n+      -- \"*\" --\n+      ---------\n+\n+      function \"*\" is new Vector_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Vector_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Scalar_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Scalar_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Inner_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Inner_Product\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Outer_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Matrix        => Complex_Matrix);\n+\n+      function \"*\" is new Outer_Product\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Matrix        => Complex_Matrix);\n+\n+      function \"*\" is new Outer_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Matrix        => Complex_Matrix);\n+\n+      function \"*\" is new Matrix_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Matrix_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Scalar_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Scalar_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"*\");\n+\n+      function \"*\" is new Matrix_Vector_Product\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Matrix        => Real_Matrix,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Matrix_Vector_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Matrix        => Complex_Matrix,\n+                             Right_Vector  => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Vector_Matrix_Product\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Matrix        => Complex_Matrix,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Vector_Matrix_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Matrix        => Real_Matrix,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Matrix_Matrix_Product\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Real_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Matrix_Matrix_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Zero          => (0.0, 0.0));\n+\n+      ---------\n+      -- \"+\" --\n+      ---------\n+\n+      function \"+\" is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Real_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"+\");\n+\n+      function \"+\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"+\");\n+\n+      ---------\n+      -- \"-\" --\n+      ---------\n+\n+      function \"-\" is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Real_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"-\");\n+\n+      function \"-\" is new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"-\");\n+\n+      ---------\n+      -- \"/\" --\n+      ---------\n+\n+      function \"/\" is new Vector_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"/\");\n+\n+      function \"/\" is new Vector_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => \"/\");\n+\n+      function \"/\" is new Matrix_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"/\");\n+\n+      function \"/\" is new Matrix_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => \"/\");\n+\n+      --------------\n+      -- Argument --\n+      --------------\n+\n+      function Argument is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Real_Vector,\n+                             Operation     => Argument);\n+\n+      function Argument is new Vector_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Real'Base,\n+                             Left_Vector   => Complex_Vector,\n+                             Result_Vector => Real_Vector,\n+                             Operation     => Argument);\n+\n+      function Argument is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Real_Matrix,\n+                             Operation     => Argument);\n+\n+      function Argument is new Matrix_Scalar_Elementwise_Operation\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Real'Base,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Result_Matrix => Real_Matrix,\n+                             Operation     => Argument);\n+\n+      ----------------------------\n+      -- Compose_From_Cartesian --\n+      ----------------------------\n+\n+      function Compose_From_Cartesian is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Real'Base,\n+                             Result_Scalar => Complex,\n+                             X_Vector      => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => Compose_From_Cartesian);\n+\n+      function Compose_From_Cartesian is\n+         new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => Compose_From_Cartesian);\n+\n+      function Compose_From_Cartesian is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Real'Base,\n+                             Result_Scalar => Complex,\n+                             X_Matrix      => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => Compose_From_Cartesian);\n+\n+      function Compose_From_Cartesian is\n+         new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Real_Matrix,\n+                             Right_Matrix  => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => Compose_From_Cartesian);\n+\n+      ------------------------\n+      -- Compose_From_Polar --\n+      ------------------------\n+\n+      function Compose_From_Polar is\n+        new Vector_Vector_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Real_Vector,\n+                             Right_Vector  => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => Compose_From_Polar);\n+\n+      function Compose_From_Polar is\n+        new Vector_Vector_Scalar_Elementwise_Operation\n+                            (X_Scalar      => Real'Base,\n+                             Y_Scalar      => Real'Base,\n+                             Z_Scalar      => Real'Base,\n+                             Result_Scalar => Complex,\n+                             X_Vector      => Real_Vector,\n+                             Y_Vector      => Real_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => Compose_From_Polar);\n+\n+      function Compose_From_Polar is\n+        new Matrix_Matrix_Elementwise_Operation\n+                            (Left_Scalar   => Real'Base,\n+                             Right_Scalar  => Real'Base,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Real_Matrix,\n+                             Right_Matrix  => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => Compose_From_Polar);\n+\n+      function Compose_From_Polar is\n+        new Matrix_Matrix_Scalar_Elementwise_Operation\n+                            (X_Scalar      => Real'Base,\n+                             Y_Scalar      => Real'Base,\n+                             Z_Scalar      => Real'Base,\n+                             Result_Scalar => Complex,\n+                             X_Matrix      => Real_Matrix,\n+                             Y_Matrix      => Real_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => Compose_From_Polar);\n+\n+      ---------------\n+      -- Conjugate --\n+      ---------------\n+\n+      function Conjugate is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Operation     => Conjugate);\n+\n+      function Conjugate is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Complex,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Operation     => Conjugate);\n+\n+      --------\n+      -- Im --\n+      --------\n+\n+      function Im is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Real_Vector,\n+                             Operation     => Im);\n+\n+      function Im is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Real_Matrix,\n+                             Operation     => Im);\n+\n+      -------------\n+      -- Modulus --\n+      -------------\n+\n+      function Modulus is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Real_Vector,\n+                             Operation     => Modulus);\n+\n+      function Modulus is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Real_Matrix,\n+                             Operation     => Modulus);\n+\n+      --------\n+      -- Re --\n+      --------\n+\n+      function Re is new Vector_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Result_Vector => Real_Vector,\n+                             Operation     => Re);\n+\n+      function Re is new Matrix_Elementwise_Operation\n+                            (X_Scalar      => Complex,\n+                             Result_Scalar => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Result_Matrix => Real_Matrix,\n+                             Operation     => Re);\n+\n+      ------------\n+      -- Set_Im --\n+      ------------\n+\n+      procedure Set_Im is new Update_Vector_With_Vector\n+                            (X_Scalar      => Complex,\n+                             Y_Scalar      => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Y_Vector      => Real_Vector,\n+                             Update        => Set_Im);\n+\n+      procedure Set_Im is new Update_Matrix_With_Matrix\n+                            (X_Scalar      => Complex,\n+                             Y_Scalar      => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Y_Matrix      => Real_Matrix,\n+                             Update        => Set_Im);\n+\n+      ------------\n+      -- Set_Re --\n+      ------------\n+\n+      procedure Set_Re is new Update_Vector_With_Vector\n+                            (X_Scalar      => Complex,\n+                             Y_Scalar      => Real'Base,\n+                             X_Vector      => Complex_Vector,\n+                             Y_Vector      => Real_Vector,\n+                             Update        => Set_Re);\n+\n+      procedure Set_Re is new Update_Matrix_With_Matrix\n+                            (X_Scalar      => Complex,\n+                             Y_Scalar      => Real'Base,\n+                             X_Matrix      => Complex_Matrix,\n+                             Y_Matrix      => Real_Matrix,\n+                             Update        => Set_Re);\n+\n+      -----------------\n+      -- Unit_Matrix --\n+      -----------------\n+\n+      function Unit_Matrix is new System.Generic_Array_Operations.Unit_Matrix\n+                            (Scalar        => Complex,\n+                             Matrix        => Complex_Matrix,\n+                             Zero          => (0.0, 0.0),\n+                             One           => (1.0, 0.0));\n+\n+      function Unit_Vector is new System.Generic_Array_Operations.Unit_Vector\n+                            (Scalar        => Complex,\n+                             Vector        => Complex_Vector,\n+                             Zero          => (0.0, 0.0),\n+                             One           => (1.0, 0.0));\n+\n+   end Instantiations;\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Vector) return Complex\n+   is\n+   begin\n+      if Left'Length /= Right'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in inner product\";\n+      end if;\n+\n+      return dot (Left'Length, X => Left, Y => Right);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Real'Base;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real'Base) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex_Matrix)\n+      return  Complex_Matrix\n+   is\n+      R : Complex_Matrix (Left'Range (1), Right'Range (2));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length (1) then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix-matrix multipication\";\n+      end if;\n+\n+      gemm (Trans_A => No_Trans'Access,\n+            Trans_B => No_Trans'Access,\n+            M       => Right'Length (2),\n+            N       => Left'Length (1),\n+            K       => Right'Length (1),\n+            A       => Right,\n+            Ld_A    => Right'Length (2),\n+            B       => Left,\n+            Ld_B    => Left'Length (2),\n+            C       => R,\n+            Ld_C    => R'Length (2));\n+\n+      return R;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Vector) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Matrix) return Complex_Vector\n+   is\n+      R : Complex_Vector (Right'Range (2));\n+\n+   begin\n+      if Left'Length /= Right'Length (1) then\n+         raise Constraint_Error with\n+           \"incompatible dimensions in vector-matrix multiplication\";\n+      end if;\n+\n+      gemv (Trans => No_Trans'Access,\n+            M     => Right'Length (2),\n+            N     => Right'Length (1),\n+            A     => Right,\n+            Ld_A  => Right'Length (2),\n+            X     => Left,\n+            Y     => R);\n+\n+      return R;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex_Vector) return Complex_Vector\n+   is\n+      R : Complex_Vector (Left'Range (1));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix-vector multiplication\";\n+      end if;\n+\n+      gemv (Trans => Trans'Access,\n+            M     => Left'Length (2),\n+            N     => Left'Length (1),\n+            A     => Left,\n+            Ld_A  => Left'Length (2),\n+            X     => Right,\n+            Y     => R);\n+\n+      return R;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Matrix) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Matrix) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Vector) return Complex_Vector\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Real'Base;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real'Base) return Complex_Matrix\n+     renames Instantiations.\"*\";\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Vector\n+     renames Instantiations.\"+\";\n+\n+   function \"+\" (Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"+\";\n+\n+   function \"+\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.\"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\"\n+     (Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Vector) return Complex_Vector\n+     renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Vector\n+      renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Vector\n+     renames Instantiations.\"-\";\n+\n+   function \"-\" (Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.\"-\";\n+\n+   function \"-\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.\"-\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\"\n+     (Left  : Complex_Vector;\n+      Right : Complex) return Complex_Vector\n+     renames Instantiations.\"/\";\n+\n+   function \"/\"\n+     (Left  : Complex_Vector;\n+      Right : Real'Base) return Complex_Vector\n+     renames Instantiations.\"/\";\n+\n+   function \"/\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex) return Complex_Matrix\n+     renames Instantiations.\"/\";\n+\n+   function \"/\"\n+     (Left  : Complex_Matrix;\n+      Right : Real'Base) return Complex_Matrix\n+     renames Instantiations.\"/\";\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (Right : Complex_Vector) return Complex is\n+   begin\n+      return (nrm2 (Right'Length, Right), 0.0);\n+   end \"abs\";\n+\n+   --------------\n+   -- Argument --\n+   --------------\n+\n+   function Argument (X : Complex_Vector) return Real_Vector\n+     renames Instantiations.Argument;\n+\n+   function Argument\n+     (X     : Complex_Vector;\n+      Cycle : Real'Base) return Real_Vector\n+     renames Instantiations.Argument;\n+\n+   function Argument (X : Complex_Matrix) return Real_Matrix\n+     renames Instantiations.Argument;\n+\n+   function Argument\n+     (X     : Complex_Matrix;\n+      Cycle : Real'Base) return Real_Matrix\n+     renames Instantiations.Argument;\n+\n+   ----------------------------\n+   -- Compose_From_Cartesian --\n+   ----------------------------\n+\n+   function Compose_From_Cartesian (Re : Real_Vector) return Complex_Vector\n+     renames Instantiations.Compose_From_Cartesian;\n+\n+   function Compose_From_Cartesian\n+     (Re : Real_Vector;\n+      Im : Real_Vector) return Complex_Vector\n+     renames Instantiations.Compose_From_Cartesian;\n+\n+   function Compose_From_Cartesian (Re : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.Compose_From_Cartesian;\n+\n+   function Compose_From_Cartesian\n+     (Re : Real_Matrix;\n+      Im : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.Compose_From_Cartesian;\n+\n+   ------------------------\n+   -- Compose_From_Polar --\n+   ------------------------\n+\n+   function Compose_From_Polar\n+     (Modulus  : Real_Vector;\n+      Argument : Real_Vector) return Complex_Vector\n+     renames Instantiations.Compose_From_Polar;\n+\n+   function Compose_From_Polar\n+     (Modulus  : Real_Vector;\n+      Argument : Real_Vector;\n+      Cycle    : Real'Base) return Complex_Vector\n+     renames Instantiations.Compose_From_Polar;\n+\n+   function Compose_From_Polar\n+     (Modulus  : Real_Matrix;\n+      Argument : Real_Matrix) return Complex_Matrix\n+     renames Instantiations.Compose_From_Polar;\n+\n+   function Compose_From_Polar\n+     (Modulus  : Real_Matrix;\n+      Argument : Real_Matrix;\n+      Cycle    : Real'Base) return Complex_Matrix\n+     renames Instantiations.Compose_From_Polar;\n+\n+   ---------------\n+   -- Conjugate --\n+   ---------------\n+\n+   function Conjugate (X : Complex_Vector) return Complex_Vector\n+     renames Instantiations.Conjugate;\n+\n+   function Conjugate (X : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.Conjugate;\n+\n+   -----------------\n+   -- Determinant --\n+   -----------------\n+\n+   function Determinant (A : Complex_Matrix) return Complex is\n+      N    : constant Integer := Length (A);\n+      LU   : Complex_Matrix (1 .. N, 1 .. N) := A;\n+      Piv  : Integer_Vector (1 .. N);\n+      Info : aliased Integer := -1;\n+      Neg  : Boolean;\n+      Det  : Complex;\n+\n+   begin\n+      if N = 0 then\n+         return (0.0, 0.0);\n+      end if;\n+\n+      getrf (N, N, LU, N, Piv, Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error with \"ill-conditioned matrix\";\n+      end if;\n+\n+      Det := LU (1, 1);\n+      Neg := Piv (1) /= 1;\n+\n+      for J in 2 .. N loop\n+         Det := Det * LU (J, J);\n+         Neg := Neg xor (Piv (J) /= J);\n+      end loop;\n+\n+      if Neg then\n+         return -Det;\n+\n+      else\n+         return Det;\n+      end if;\n+   end Determinant;\n+\n+   -----------------\n+   -- Eigensystem --\n+   -----------------\n+\n+   procedure Eigensystem\n+     (A       : in Complex_Matrix;\n+      Values  : out Real_Vector;\n+      Vectors : out Complex_Matrix)\n+   is\n+      Job_Z    : aliased Character := 'V';\n+      Rng      : aliased Character := 'A';\n+      Uplo     : aliased Character := 'U';\n+\n+      N        : constant Natural := Length (A);\n+      W        : BLAS_Real_Vector (Values'Range);\n+      M        : Integer;\n+      B        : Complex_Matrix (1 .. N, 1 .. N);\n+      L_Work   : Complex_Vector (1 .. 1);\n+      LR_Work  : BLAS_Real_Vector (1 .. 1);\n+      LI_Work  : Integer_Vector (1 .. 1);\n+      I_Supp_Z : Integer_Vector (1 .. 2 * N);\n+      Info     : aliased Integer;\n+\n+   begin\n+      if Values'Length /= N then\n+         raise Constraint_Error with \"wrong length for output vector\";\n+      end if;\n+\n+      if Vectors'First (1) /= A'First (1)\n+        or else Vectors'Last (1) /= A'Last (1)\n+        or else Vectors'First (2) /= A'First (2)\n+        or else Vectors'Last (2) /= A'Last (2)\n+      then\n+         raise Constraint_Error with \"wrong dimensions for output matrix\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      --  Check for hermitian matrix ???\n+      --  Copy only required triangle ???\n+\n+      B := A;\n+\n+      --  Find size of work area\n+\n+      heevr\n+        (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n+         M        => M,\n+         W        => W,\n+         Z        => Vectors,\n+         Ld_Z     => N,\n+         I_Supp_Z => I_Supp_Z,\n+         Work     => L_Work,\n+         L_Work   => -1,\n+         R_Work   => LR_Work,\n+         LR_Work  => -1,\n+         I_Work   => LI_Work,\n+         LI_Work  => -1,\n+         Info     => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Work   : Complex_Vector (1 .. Integer (L_Work (1).Re));\n+         R_Work : BLAS_Real_Vector (1 .. Integer (LR_Work (1)));\n+         I_Work : Integer_Vector (1 .. LI_Work (1));\n+\n+      begin\n+         heevr\n+           (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n+            M        => M,\n+            W        => W,\n+            Z        => Vectors,\n+            Ld_Z     => N,\n+            I_Supp_Z => I_Supp_Z,\n+            Work     => Work,\n+            L_Work   => Work'Length,\n+            R_Work   => R_Work,\n+            LR_Work  => LR_Work'Length,\n+            I_Work   => I_Work,\n+            LI_Work  => LI_Work'Length,\n+            Info     => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with \"inverting non-Hermetian matrix\";\n+         end if;\n+\n+         for J in Values'Range loop\n+            Values (J) := W (J);\n+         end loop;\n+      end;\n+   end Eigensystem;\n+\n+   -----------------\n+   -- Eigenvalues --\n+   -----------------\n+\n+   procedure Eigenvalues\n+     (A      : Complex_Matrix;\n+      Values : out Real_Vector)\n+   is\n+      Job_Z    : aliased Character := 'N';\n+      Rng      : aliased Character := 'A';\n+      Uplo     : aliased Character := 'U';\n+      N        : constant Natural := Length (A);\n+      B        : Complex_Matrix (1 .. N, 1 .. N) := A;\n+      Z        : Complex_Matrix (1 .. 1, 1 .. 1);\n+      W        : BLAS_Real_Vector (Values'Range);\n+      L_Work   : Complex_Vector (1 .. 1);\n+      LR_Work  : BLAS_Real_Vector (1 .. 1);\n+      LI_Work  : Integer_Vector (1 .. 1);\n+      I_Supp_Z : Integer_Vector (1 .. 2 * N);\n+      M        : Integer;\n+      Info     : aliased Integer;\n+\n+   begin\n+      if Values'Length /= N then\n+         raise Constraint_Error with \"wrong length for output vector\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      --  Check for hermitian matrix ???\n+\n+      --  Find size of work area\n+\n+      heevr (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n+             M        => M,\n+             W        => W,\n+             Z        => Z,\n+             Ld_Z     => 1,\n+             I_Supp_Z => I_Supp_Z,\n+             Work     => L_Work,  L_Work  => -1,\n+             R_Work   => LR_Work, LR_Work => -1,\n+             I_Work   => LI_Work, LI_Work => -1,\n+             Info     => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Work : Complex_Vector (1 .. Integer (L_Work (1).Re));\n+         R_Work : BLAS_Real_Vector (1 .. Integer (LR_Work (1)));\n+         I_Work : Integer_Vector (1 .. LI_Work (1));\n+      begin\n+         heevr (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n+                M        => M,\n+                W        => W,\n+                Z        => Z,\n+                Ld_Z     => 1,\n+                I_Supp_Z => I_Supp_Z,\n+                Work     => Work,   L_Work  => Work'Length,\n+                R_Work   => R_Work, LR_Work => R_Work'Length,\n+                I_Work   => I_Work, LI_Work => I_Work'Length,\n+                Info     => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with \"inverting singular matrix\";\n+         end if;\n+\n+         for J in Values'Range loop\n+            Values (J) := W (J);\n+         end loop;\n+      end;\n+   end Eigenvalues;\n+\n+   function Eigenvalues (A : Complex_Matrix) return Real_Vector is\n+      R : Real_Vector (A'Range (1));\n+   begin\n+      Eigenvalues (A, R);\n+      return R;\n+   end Eigenvalues;\n+\n+   --------\n+   -- Im --\n+   --------\n+\n+   function Im (X : Complex_Vector) return Real_Vector\n+     renames Instantiations.Im;\n+\n+   function Im (X : Complex_Matrix) return Real_Matrix\n+     renames Instantiations.Im;\n+\n+   -------------\n+   -- Inverse --\n+   -------------\n+\n+   procedure Inverse (A : Complex_Matrix; R : out Complex_Matrix) is\n+      N      : constant Integer := Length (A);\n+      Piv    : Integer_Vector (1 .. N);\n+      L_Work : Complex_Vector (1 .. 1);\n+      Info   : aliased Integer := -1;\n+\n+   begin\n+      --  All computations are done using column-major order, but this works\n+      --  out fine, because Transpose (Inverse (Transpose (A))) = Inverse (A).\n+\n+      R := A;\n+\n+      --  Compute LU decomposition\n+\n+      getrf (M      => N,\n+             N      => N,\n+             A      => R,\n+             Ld_A   => N,\n+             I_Piv  => Piv,\n+             Info   => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error with \"inverting singular matrix\";\n+      end if;\n+\n+      --  Determine size of work area\n+\n+      getri (N      => N,\n+             A      => R,\n+             Ld_A   => N,\n+             I_Piv  => Piv,\n+             Work   => L_Work,\n+             L_Work => -1,\n+             Info   => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Work : Complex_Vector (1 .. Integer (L_Work (1).Re));\n+\n+      begin\n+         --  Compute inverse from LU decomposition\n+\n+         getri (N      => N,\n+                A      => R,\n+                Ld_A   => N,\n+                I_Piv  => Piv,\n+                Work   => Work,\n+                L_Work => Work'Length,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with \"inverting singular matrix\";\n+         end if;\n+\n+         --  ??? Should iterate with gerfs, based on implementation advice\n+      end;\n+   end Inverse;\n+\n+   function Inverse (A : Complex_Matrix) return Complex_Matrix is\n+      R : Complex_Matrix (A'Range (2), A'Range (1));\n+   begin\n+      Inverse (A, R);\n+      return R;\n+   end Inverse;\n+\n+   -------------\n+   -- Modulus --\n+   -------------\n+\n+   function Modulus (X : Complex_Vector) return Real_Vector\n+     renames Instantiations.Modulus;\n+\n+   function Modulus (X : Complex_Matrix) return Real_Matrix\n+     renames Instantiations.Modulus;\n+\n+   --------\n+   -- Re --\n+   --------\n+\n+   function Re (X : Complex_Vector) return Real_Vector\n+     renames Instantiations.Re;\n+\n+   function Re (X : Complex_Matrix) return Real_Matrix\n+     renames Instantiations.Re;\n+\n+   ------------\n+   -- Set_Im --\n+   ------------\n+\n+   procedure Set_Im\n+     (X  : in out Complex_Matrix;\n+      Im : Real_Matrix)\n+     renames Instantiations.Set_Im;\n+\n+   procedure Set_Im\n+     (X  : in out Complex_Vector;\n+      Im : Real_Vector)\n+     renames Instantiations.Set_Im;\n+\n+   ------------\n+   -- Set_Re --\n+   ------------\n+\n+   procedure Set_Re\n+     (X  : in out Complex_Matrix;\n+      Re : Real_Matrix)\n+     renames Instantiations.Set_Re;\n+\n+   procedure Set_Re\n+     (X  : in out Complex_Vector;\n+      Re : Real_Vector)\n+     renames Instantiations.Set_Re;\n+\n+   -----------\n+   -- Solve --\n+   -----------\n+\n+   procedure Solve\n+     (A : Complex_Matrix;\n+      X : Complex_Vector;\n+      B : out Complex_Vector)\n+   is\n+   begin\n+      if Length (A) /= X'Length then\n+         raise Constraint_Error with\n+           \"incompatible matrix and vector dimensions\";\n+      end if;\n+\n+      --  ??? Should solve directly, is faster and more accurate\n+\n+      B := Inverse (A) * X;\n+   end Solve;\n+\n+   procedure Solve\n+     (A : Complex_Matrix;\n+      X : Complex_Matrix;\n+      B : out Complex_Matrix)\n+   is\n+   begin\n+      if Length (A) /= X'Length (1) then\n+         raise Constraint_Error with \"incompatible matrix dimensions\";\n+      end if;\n+\n+      --  ??? Should solve directly, is faster and more accurate\n+\n+      B := Inverse (A) * X;\n+   end Solve;\n+\n+   function Solve\n+     (A : Complex_Matrix;\n+      X : Complex_Vector) return Complex_Vector\n+   is\n+      B : Complex_Vector (A'Range (2));\n+   begin\n+      Solve (A, X, B);\n+      return B;\n+   end Solve;\n+\n+   function Solve (A, X : Complex_Matrix) return Complex_Matrix is\n+      B : Complex_Matrix (A'Range (2), X'Range (2));\n+   begin\n+      Solve (A, X, B);\n+      return B;\n+   end Solve;\n+\n+   ---------------\n+   -- Transpose --\n+   ---------------\n+\n+   function Transpose\n+     (X : Complex_Matrix) return Complex_Matrix\n+   is\n+      R : Complex_Matrix (X'Range (2), X'Range (1));\n+   begin\n+      Transpose (X, R);\n+      return R;\n+   end Transpose;\n+\n+   -----------------\n+   -- Unit_Matrix --\n+   -----------------\n+\n+   function Unit_Matrix\n+     (Order   : Positive;\n+      First_1 : Integer := 1;\n+      First_2 : Integer := 1) return Complex_Matrix\n+     renames Instantiations.Unit_Matrix;\n+\n+   -----------------\n+   -- Unit_Vector --\n+   -----------------\n+\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Complex_Vector\n+     renames Instantiations.Unit_Vector;\n+\n+end Ada.Numerics.Generic_Complex_Arrays;"}, {"sha": "f94721c5879e5304acbf36b02fc879f6e6903afa", "filename": "gcc/ada/a-ngcoar.ads", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngcoar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngcoar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoar.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,281 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.NUMERICS.GENERIC_COMPLEX_ARRAYS                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Real_Arrays, Ada.Numerics.Generic_Complex_Types;\n+\n+generic\n+   with package Real_Arrays is new Ada.Numerics.Generic_Real_Arrays (<>);\n+   use Real_Arrays;\n+   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Real);\n+   use Complex_Types;\n+package Ada.Numerics.Generic_Complex_Arrays is\n+   pragma Pure (Generic_Complex_Arrays);\n+\n+   --  Types\n+\n+   type Complex_Vector is array (Integer range <>) of Complex;\n+   type Complex_Matrix is\n+     array (Integer range <>, Integer range <>) of Complex;\n+\n+   --  Subprograms for Complex_Vector types\n+   --  Complex_Vector selection, conversion and composition operations\n+\n+   function Re (X : Complex_Vector) return Real_Vector;\n+   function Im (X : Complex_Vector) return Real_Vector;\n+\n+   procedure Set_Re (X : in out Complex_Vector; Re : in Real_Vector);\n+   procedure Set_Im (X : in out Complex_Vector; Im : in Real_Vector);\n+\n+   function Compose_From_Cartesian\n+     (Re : Real_Vector) return Complex_Vector;\n+   function Compose_From_Cartesian\n+     (Re, Im : Real_Vector) return Complex_Vector;\n+\n+   function Modulus (X : Complex_Vector) return Real_Vector;\n+   function \"abs\" (Right : Complex_Vector) return Real_Vector renames Modulus;\n+   function Argument (X : Complex_Vector) return Real_Vector;\n+\n+   function Argument\n+     (X     : Complex_Vector;\n+      Cycle : Real'Base) return Real_Vector;\n+\n+   function Compose_From_Polar\n+     (Modulus, Argument : Real_Vector) return Complex_Vector;\n+\n+   function Compose_From_Polar\n+     (Modulus, Argument : Real_Vector;\n+      Cycle             : Real'Base) return Complex_Vector;\n+\n+   --  Complex_Vector arithmetic operations\n+\n+   function \"+\" (Right : Complex_Vector) return Complex_Vector;\n+   function \"-\" (Right : Complex_Vector) return Complex_Vector;\n+   function Conjugate (X : Complex_Vector) return Complex_Vector;\n+   function \"+\" (Left, Right : Complex_Vector) return Complex_Vector;\n+   function \"-\" (Left, Right : Complex_Vector) return Complex_Vector;\n+   function \"*\" (Left, Right : Complex_Vector) return Complex;\n+   function \"abs\" (Right : Complex_Vector) return Complex;\n+\n+   --  Mixed Real_Vector and Complex_Vector arithmetic operations\n+\n+   function \"+\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   function \"+\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Vector;\n+\n+   function \"-\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   function \"-\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Vector;\n+\n+   function \"*\" (Left : Real_Vector; Right : Complex_Vector) return Complex;\n+   function \"*\" (Left : Complex_Vector; Right : Real_Vector) return Complex;\n+\n+   --  Complex_Vector scaling operations\n+\n+   function \"*\"\n+     (Left  : Complex;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex) return Complex_Vector;\n+\n+   function \"/\"\n+     (Left  : Complex_Vector;\n+      Right : Complex) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Real'Base;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real'Base) return Complex_Vector;\n+\n+   function \"/\"\n+     (Left  : Complex_Vector;\n+      Right : Real'Base) return Complex_Vector;\n+\n+   --  Other Complex_Vector operations\n+\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Complex_Vector;\n+\n+   --  Subprograms for Complex_Matrix types\n+\n+   --  Complex_Matrix selection, conversion and composition operations\n+\n+   function Re (X : Complex_Matrix) return Real_Matrix;\n+   function Im (X : Complex_Matrix) return Real_Matrix;\n+\n+   procedure Set_Re (X : in out Complex_Matrix; Re : in Real_Matrix);\n+   procedure Set_Im (X : in out Complex_Matrix; Im : in Real_Matrix);\n+\n+   function Compose_From_Cartesian (Re : Real_Matrix) return Complex_Matrix;\n+\n+   function Compose_From_Cartesian\n+     (Re, Im : Real_Matrix) return  Complex_Matrix;\n+\n+   function Modulus (X : Complex_Matrix) return Real_Matrix;\n+   function \"abs\" (Right : Complex_Matrix) return Real_Matrix renames Modulus;\n+\n+   function Argument (X : Complex_Matrix) return Real_Matrix;\n+\n+   function Argument\n+     (X     : Complex_Matrix;\n+      Cycle : Real'Base) return Real_Matrix;\n+\n+   function Compose_From_Polar\n+     (Modulus, Argument : Real_Matrix) return Complex_Matrix;\n+\n+   function Compose_From_Polar\n+     (Modulus  : Real_Matrix;\n+      Argument : Real_Matrix;\n+      Cycle    : Real'Base) return Complex_Matrix;\n+\n+   --  Complex_Matrix arithmetic operations\n+\n+   function \"+\" (Right : Complex_Matrix) return Complex_Matrix;\n+   function \"-\" (Right : Complex_Matrix) return Complex_Matrix;\n+\n+   function Conjugate (X : Complex_Matrix) return Complex_Matrix;\n+   function Transpose (X : Complex_Matrix) return Complex_Matrix;\n+\n+   function \"+\" (Left, Right : Complex_Matrix) return Complex_Matrix;\n+   function \"-\" (Left, Right : Complex_Matrix) return Complex_Matrix;\n+   function \"*\" (Left, Right : Complex_Matrix) return Complex_Matrix;\n+   function \"*\" (Left, Right : Complex_Vector) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Complex_Matrix) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   --  Mixed Real_Matrix and Complex_Matrix arithmetic operations\n+\n+   function \"+\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix;\n+\n+   function \"+\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix;\n+\n+   function \"-\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix;\n+\n+   function \"-\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Matrix) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Matrix) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Vector) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Vector) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Real_Vector;\n+      Right : Complex_Matrix) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Complex_Vector;\n+      Right : Real_Matrix) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Real_Matrix;\n+      Right : Complex_Vector) return Complex_Vector;\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real_Vector) return Complex_Vector;\n+\n+   --  Complex_Matrix scaling operations\n+\n+   function \"*\"\n+     (Left  : Complex;\n+      Right : Complex_Matrix) return  Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex) return Complex_Matrix;\n+\n+   function \"/\"\n+     (Left  : Complex_Matrix;\n+      Right : Complex) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Real'Base;\n+      Right : Complex_Matrix) return Complex_Matrix;\n+\n+   function \"*\"\n+     (Left  : Complex_Matrix;\n+      Right : Real'Base) return Complex_Matrix;\n+\n+   function \"/\"\n+     (Left  : Complex_Matrix;\n+      Right : Real'Base) return Complex_Matrix;\n+\n+   --  Complex_Matrix inversion and related operations\n+\n+   function Solve\n+     (A : Complex_Matrix;\n+      X : Complex_Vector) return Complex_Vector;\n+\n+   function Solve (A, X : Complex_Matrix) return Complex_Matrix;\n+\n+   function Inverse (A : Complex_Matrix) return Complex_Matrix;\n+\n+   function Determinant (A : Complex_Matrix) return Complex;\n+\n+   --  Eigenvalues and vectors of a Hermitian matrix\n+\n+   function Eigenvalues (A : Complex_Matrix) return Real_Vector;\n+\n+   procedure Eigensystem\n+     (A       : in Complex_Matrix;\n+      Values  : out Real_Vector;\n+      Vectors : out Complex_Matrix);\n+\n+   --  Other Complex_Matrix operations\n+\n+   function Unit_Matrix\n+     (Order            : Positive;\n+      First_1, First_2 : Integer := 1) return Complex_Matrix;\n+\n+end Ada.Numerics.Generic_Complex_Arrays;"}, {"sha": "2ff5d01c0aaa51afe4568b6e52e6300bce6f7f11", "filename": "gcc/ada/a-ngrear.adb", "status": "added", "additions": 779, "deletions": 0, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngrear.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngrear.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,779 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     ADA.NUMERICS.GENERIC_REAL_ARRAYS                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System; use System;\n+with System.Generic_Real_BLAS;\n+with System.Generic_Real_LAPACK;\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+\n+package body Ada.Numerics.Generic_Real_Arrays is\n+\n+   --  Operations involving inner products use BLAS library implementations.\n+   --  This allows larger matrices and vectors to be computed efficiently,\n+   --  taking into account memory hierarchy issues and vector instructions\n+   --  that vary widely between machines.\n+\n+   --  Operations that are defined in terms of operations on the type Real,\n+   --  such as addition, subtraction and scaling, are computed in the canonical\n+   --  way looping over all elements.\n+\n+   --  Operations for solving linear systems and computing determinant,\n+   --  eigenvalues, eigensystem and inverse, are implemented using the\n+   --  LAPACK library.\n+\n+   package BLAS is\n+      new Generic_Real_BLAS (Real'Base, Real_Vector, Real_Matrix);\n+\n+   package LAPACK is\n+      new Generic_Real_LAPACK (Real'Base, Real_Vector, Real_Matrix);\n+\n+   use BLAS, LAPACK;\n+\n+   --  Procedure versions of functions returning unconstrained values.\n+   --  This allows for inlining the function wrapper.\n+\n+   procedure Eigenvalues (A : Real_Matrix; Values : out Real_Vector);\n+   procedure Inverse   (A : Real_Matrix; R : out Real_Matrix);\n+   procedure Solve     (A : Real_Matrix; X : Real_Vector; B : out Real_Vector);\n+   procedure Solve     (A : Real_Matrix; X : Real_Matrix; B : out Real_Matrix);\n+\n+   procedure Transpose is new\n+     Generic_Array_Operations.Transpose\n+       (Scalar        => Real'Base,\n+        Matrix        => Real_Matrix);\n+\n+   --  Helper function that raises a Constraint_Error is the argument is\n+   --  not a square matrix, and otherwise returns its length.\n+\n+   function Length is new Square_Matrix_Length (Real'Base, Real_Matrix);\n+\n+   --  Instantiating the following subprograms directly would lead to\n+   --  name clashes, so use a local package.\n+\n+   package Instantiations is\n+\n+      function \"+\" is new\n+        Vector_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Vector      => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"+\");\n+\n+      function \"+\" is new\n+        Matrix_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Matrix      => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"+\");\n+\n+      function \"+\" is new\n+        Vector_Vector_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Right_Vector  => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"+\");\n+\n+      function \"+\" is new\n+        Matrix_Matrix_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Matrix   => Real_Matrix,\n+           Right_Matrix  => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"+\");\n+\n+      function \"-\" is new\n+        Vector_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Vector      => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"-\");\n+\n+      function \"-\" is new\n+        Matrix_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Matrix      => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"-\");\n+\n+      function \"-\" is new\n+        Vector_Vector_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Right_Vector  => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"-\");\n+\n+      function \"-\" is new\n+        Matrix_Matrix_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Matrix   => Real_Matrix,\n+           Right_Matrix  => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"-\");\n+\n+      function \"*\" is new\n+        Scalar_Vector_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Right_Vector  => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"*\");\n+\n+      function \"*\" is new\n+        Scalar_Matrix_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Right_Matrix  => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"*\");\n+\n+      function \"*\" is new\n+        Vector_Scalar_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"*\");\n+\n+      function \"*\" is new\n+        Matrix_Scalar_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Matrix   => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"*\");\n+\n+      function \"*\" is new\n+        Outer_Product\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Right_Vector  => Real_Vector,\n+           Matrix        => Real_Matrix);\n+\n+      function \"/\" is new\n+        Vector_Scalar_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Vector   => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"/\");\n+\n+      function \"/\" is new\n+        Matrix_Scalar_Elementwise_Operation\n+          (Left_Scalar   => Real'Base,\n+           Right_Scalar  => Real'Base,\n+           Result_Scalar => Real'Base,\n+           Left_Matrix   => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"/\");\n+\n+      function \"abs\" is new\n+        Vector_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Vector      => Real_Vector,\n+           Result_Vector => Real_Vector,\n+           Operation     => \"abs\");\n+\n+      function \"abs\" is new\n+        Matrix_Elementwise_Operation\n+          (X_Scalar      => Real'Base,\n+           Result_Scalar => Real'Base,\n+           X_Matrix      => Real_Matrix,\n+           Result_Matrix => Real_Matrix,\n+           Operation     => \"abs\");\n+\n+      function Unit_Matrix is new\n+        Generic_Array_Operations.Unit_Matrix\n+          (Scalar        => Real'Base,\n+           Matrix        => Real_Matrix,\n+           Zero          => 0.0,\n+           One           => 1.0);\n+\n+      function Unit_Vector is new\n+        Generic_Array_Operations.Unit_Vector\n+          (Scalar        => Real'Base,\n+           Vector        => Real_Vector,\n+           Zero          => 0.0,\n+           One           => 1.0);\n+\n+   end Instantiations;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"+\";\n+\n+   function \"+\" (Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"+\";\n+\n+   function \"+\" (Left, Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"+\";\n+\n+   function \"+\" (Left, Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"-\";\n+\n+   function \"-\" (Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"-\";\n+\n+   function \"-\" (Left, Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"-\";\n+\n+   function \"-\" (Left, Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"-\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   --  Scalar multiplication\n+\n+   function \"*\" (Left : Real'Base; Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"*\";\n+\n+   function \"*\" (Left : Real_Vector; Right : Real'Base) return Real_Vector\n+      renames Instantiations.\"*\";\n+\n+   function \"*\" (Left : Real'Base; Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"*\";\n+\n+   function \"*\" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix\n+      renames Instantiations.\"*\";\n+\n+   --  Vector multiplication\n+\n+   function \"*\" (Left, Right : Real_Vector) return Real'Base is\n+   begin\n+      if Left'Length /= Right'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in inner product\";\n+      end if;\n+\n+      return dot (Left'Length, X => Left, Y => Right);\n+   end \"*\";\n+\n+   function \"*\" (Left, Right : Real_Vector) return Real_Matrix\n+      renames Instantiations.\"*\";\n+\n+   function \"*\"\n+     (Left : Real_Vector;\n+      Right : Real_Matrix) return Real_Vector\n+   is\n+      R : Real_Vector (Right'Range (2));\n+\n+   begin\n+      if Left'Length /= Right'Length (1) then\n+         raise Constraint_Error with\n+           \"incompatible dimensions in vector-matrix multiplication\";\n+      end if;\n+\n+      gemv (Trans => No_Trans'Access,\n+            M     => Right'Length (2),\n+            N     => Right'Length (1),\n+            A     => Right,\n+            Ld_A  => Right'Length (2),\n+            X     => Left,\n+            Y     => R);\n+\n+      return R;\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left : Real_Matrix;\n+      Right : Real_Vector) return Real_Vector\n+   is\n+      R : Real_Vector (Left'Range (1));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix-vector multiplication\";\n+      end if;\n+\n+      gemv (Trans => Trans'Access,\n+            M     => Left'Length (2),\n+            N     => Left'Length (1),\n+            A     => Left,\n+            Ld_A  => Left'Length (2),\n+            X     => Right,\n+            Y     => R);\n+\n+      return R;\n+   end \"*\";\n+\n+   --  Matrix Multiplication\n+\n+   function \"*\" (Left, Right : Real_Matrix) return Real_Matrix is\n+      R : Real_Matrix (Left'Range (1), Right'Range (2));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length (1) then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix-matrix multipication\";\n+      end if;\n+\n+      gemm (Trans_A => No_Trans'Access,\n+            Trans_B => No_Trans'Access,\n+            M       => Right'Length (2),\n+            N       => Left'Length (1),\n+            K       => Right'Length (1),\n+            A       => Right,\n+            Ld_A    => Right'Length (2),\n+            B       => Left,\n+            Ld_B    => Left'Length (2),\n+            C       => R,\n+            Ld_C    => R'Length (2));\n+\n+      return R;\n+   end \"*\";\n+\n+   ---------\n+   -- \"/\" --\n+   ---------\n+\n+   function \"/\" (Left : Real_Vector; Right : Real'Base) return Real_Vector\n+      renames Instantiations.\"/\";\n+\n+   function \"/\" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix\n+      renames Instantiations.\"/\";\n+\n+   -----------\n+   -- \"abs\" --\n+   -----------\n+\n+   function \"abs\" (Right : Real_Vector) return Real'Base is\n+   begin\n+      return nrm2 (Right'Length, Right);\n+   end \"abs\";\n+\n+   function \"abs\" (Right : Real_Vector) return Real_Vector\n+      renames Instantiations.\"abs\";\n+\n+   function \"abs\" (Right : Real_Matrix) return Real_Matrix\n+      renames Instantiations.\"abs\";\n+\n+   -----------------\n+   -- Determinant --\n+   -----------------\n+\n+   function Determinant (A : Real_Matrix) return Real'Base is\n+      N    : constant Integer := Length (A);\n+      LU   : Real_Matrix (1 .. N, 1 .. N) := A;\n+      Piv  : Integer_Vector (1 .. N);\n+      Info : aliased Integer := -1;\n+      Det  : Real := 1.0;\n+\n+   begin\n+      getrf (M     => N,\n+             N     => N,\n+             A     => LU,\n+             Ld_A  => N,\n+             I_Piv => Piv,\n+             Info  => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error with \"ill-conditioned matrix\";\n+      end if;\n+\n+      for J in 1 .. N loop\n+         if Piv (J) /= J then\n+            Det := -Det * LU (J, J);\n+         else\n+            Det := Det * LU (J, J);\n+         end if;\n+      end loop;\n+\n+      return Det;\n+   end Determinant;\n+\n+   -----------------\n+   -- Eigensystem --\n+   -----------------\n+\n+   procedure Eigensystem\n+     (A       : Real_Matrix;\n+      Values  : out Real_Vector;\n+      Vectors : out Real_Matrix)\n+   is\n+      N      : constant Natural := Length (A);\n+      E      : Real_Vector (1 .. N);\n+      Tau    : Real_Vector (1 .. N);\n+      L_Work : Real_Vector (1 .. 1);\n+      Info   : aliased Integer;\n+\n+   begin\n+      if Values'Length /= N then\n+         raise Constraint_Error with \"wrong length for output vector\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      --  Initialize working matrix and check for symmetric input matrix\n+\n+      Transpose (A, Vectors);\n+\n+      if A /= Vectors then\n+         raise Argument_Error with \"matrix not symmetric\";\n+      end if;\n+\n+      --  Compute size of additional working space\n+\n+      sytrd (Uplo   => Lower'Access,\n+             N      => N,\n+             A      => Vectors,\n+             Ld_A   => N,\n+             D      => Values,\n+             E      => E,\n+             Tau    => Tau,\n+             Work   => L_Work,\n+             L_Work => -1,\n+             Info   => Info'Access);\n+\n+      declare\n+         Work   : Real_Vector (1 .. Integer'Max (Integer (L_Work (1)), 2 * N));\n+         Comp_Z : aliased constant Character := 'V';\n+\n+      begin\n+         --  Reduce matrix to tridiagonal form\n+\n+         sytrd (Uplo   => Lower'Access,\n+                N      => N,\n+                A      => Vectors,\n+                Ld_A   => A'Length (1),\n+                D      => Values,\n+                E      => E,\n+                Tau    => Tau,\n+                Work   => Work,\n+                L_Work => Work'Length,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         --  Generate the real orthogonal matrix determined by sytrd\n+\n+         orgtr (Uplo   => Lower'Access,\n+                N      => N,\n+                A      => Vectors,\n+                Ld_A   => N,\n+                Tau    => Tau,\n+                Work   => Work,\n+                L_Work => Work'Length,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         --  Compute all eigenvalues and eigenvectors using QR algorithm\n+\n+         steqr (Comp_Z => Comp_Z'Access,\n+                N      => N,\n+                D      => Values,\n+                E      => E,\n+                Z      => Vectors,\n+                Ld_Z   => N,\n+                Work   => Work,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with\n+               \"eigensystem computation failed to converge\";\n+         end if;\n+      end;\n+   end Eigensystem;\n+\n+   -----------------\n+   -- Eigenvalues --\n+   -----------------\n+\n+   procedure Eigenvalues\n+     (A      : Real_Matrix;\n+      Values : out Real_Vector)\n+   is\n+      N      : constant Natural := Length (A);\n+      B      : Real_Matrix (1 .. N, 1 .. N);\n+      E      : Real_Vector (1 .. N);\n+      Tau    : Real_Vector (1 .. N);\n+      L_Work : Real_Vector (1 .. 1);\n+      Info   : aliased Integer;\n+\n+   begin\n+      if Values'Length /= N then\n+         raise Constraint_Error with \"wrong length for output vector\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      --  Initialize working matrix and check for symmetric input matrix\n+\n+      Transpose (A, B);\n+\n+      if A /= B then\n+         raise Argument_Error with \"matrix not symmetric\";\n+      end if;\n+\n+      --  Find size of work area\n+\n+      sytrd (Uplo   => Lower'Access,\n+             N      => N,\n+             A      => B,\n+             Ld_A   => N,\n+             D      => Values,\n+             E      => E,\n+             Tau    => Tau,\n+             Work   => L_Work,\n+             L_Work => -1,\n+             Info   => Info'Access);\n+\n+      declare\n+         Work : Real_Vector (1 .. Integer'Min (Integer (L_Work (1)), 4 * N));\n+\n+      begin\n+         --  Reduce matrix to tridiagonal form\n+\n+         sytrd (Uplo   => Lower'Access,\n+                N      => N,\n+                A      => B,\n+                Ld_A   => A'Length (1),\n+                D      => Values,\n+                E      => E,\n+                Tau    => Tau,\n+                Work   => Work,\n+                L_Work => Work'Length,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error;\n+         end if;\n+\n+         --  Compute all eigenvalues using QR algorithm\n+\n+         sterf (N      => N,\n+                D      => Values,\n+                E      => E,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with\n+               \"eigenvalues computation failed to converge\";\n+         end if;\n+      end;\n+   end Eigenvalues;\n+\n+   function Eigenvalues (A : Real_Matrix) return Real_Vector is\n+      R : Real_Vector (A'Range (1));\n+   begin\n+      Eigenvalues (A, R);\n+      return R;\n+   end Eigenvalues;\n+\n+   -------------\n+   -- Inverse --\n+   -------------\n+\n+   procedure Inverse (A : Real_Matrix; R : out Real_Matrix) is\n+      N      : constant Integer := Length (A);\n+      Piv    : Integer_Vector (1 .. N);\n+      L_Work : Real_Vector (1 .. 1);\n+      Info   : aliased Integer := -1;\n+\n+   begin\n+      --  All computations are done using column-major order, but this works\n+      --  out fine, because Transpose (Inverse (Transpose (A))) = Inverse (A).\n+\n+      R := A;\n+\n+      --  Compute LU decomposition\n+\n+      getrf (M      => N,\n+             N      => N,\n+             A      => R,\n+             Ld_A   => N,\n+             I_Piv  => Piv,\n+             Info   => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error with \"inverting singular matrix\";\n+      end if;\n+\n+      --  Determine size of work area\n+\n+      getri (N      => N,\n+             A      => R,\n+             Ld_A   => N,\n+             I_Piv  => Piv,\n+             Work   => L_Work,\n+             L_Work => -1,\n+             Info   => Info'Access);\n+\n+      if Info /= 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Work : Real_Vector (1 .. Integer (L_Work (1)));\n+      begin\n+         --  Compute inverse from LU decomposition\n+\n+         getri (N      => N,\n+                A      => R,\n+                Ld_A   => N,\n+                I_Piv  => Piv,\n+                Work   => Work,\n+                L_Work => Work'Length,\n+                Info   => Info'Access);\n+\n+         if Info /= 0 then\n+            raise Constraint_Error with \"inverting singular matrix\";\n+         end if;\n+\n+         --  ??? Should iterate with gerfs, based on implementation advice\n+      end;\n+   end Inverse;\n+\n+   function Inverse (A : Real_Matrix) return Real_Matrix is\n+      R : Real_Matrix (A'Range (2), A'Range (1));\n+   begin\n+      Inverse (A, R);\n+      return R;\n+   end Inverse;\n+\n+   -----------\n+   -- Solve --\n+   -----------\n+\n+   procedure Solve (A : Real_Matrix; X : Real_Vector; B : out Real_Vector) is\n+   begin\n+      if Length (A) /= X'Length then\n+         raise Constraint_Error with\n+           \"incompatible matrix and vector dimensions\";\n+      end if;\n+\n+      --  ??? Should solve directly, is faster and more accurate\n+\n+      B := Inverse (A) * X;\n+   end Solve;\n+\n+   procedure Solve (A : Real_Matrix; X : Real_Matrix; B : out Real_Matrix) is\n+   begin\n+      if Length (A) /= X'Length (1) then\n+         raise Constraint_Error with \"incompatible matrix dimensions\";\n+      end if;\n+\n+      --  ??? Should solve directly, is faster and more accurate\n+\n+      B := Inverse (A) * X;\n+   end Solve;\n+\n+   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector is\n+      B : Real_Vector (A'Range (2));\n+   begin\n+      Solve (A, X, B);\n+      return B;\n+   end Solve;\n+\n+   function Solve (A, X : Real_Matrix) return Real_Matrix is\n+      B : Real_Matrix (A'Range (2), X'Range (2));\n+   begin\n+      Solve (A, X, B);\n+      return B;\n+   end Solve;\n+\n+   ---------------\n+   -- Transpose --\n+   ---------------\n+\n+   function Transpose (X : Real_Matrix) return Real_Matrix is\n+      R : Real_Matrix (X'Range (2), X'Range (1));\n+   begin\n+      Transpose (X, R);\n+\n+      return R;\n+   end Transpose;\n+\n+   -----------------\n+   -- Unit_Matrix --\n+   -----------------\n+\n+   function Unit_Matrix\n+     (Order   : Positive;\n+      First_1 : Integer := 1;\n+      First_2 : Integer := 1) return Real_Matrix\n+     renames Instantiations.Unit_Matrix;\n+\n+   -----------------\n+   -- Unit_Vector --\n+   -----------------\n+\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Real_Vector\n+     renames Instantiations.Unit_Vector;\n+\n+end Ada.Numerics.Generic_Real_Arrays;"}, {"sha": "61e1f34c6ed336190a3f9412c5938a751a224019", "filename": "gcc/ada/a-ngrear.ads", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngrear.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-ngrear.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,141 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     ADA.NUMERICS.GENERIC_REAL_ARRAYS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Real is digits <>;\n+package Ada.Numerics.Generic_Real_Arrays is\n+   pragma Pure (Generic_Real_Arrays);\n+\n+   --  Types\n+\n+   type Real_Vector is array (Integer range <>) of Real'Base;\n+   type Real_Matrix is array (Integer range <>, Integer range <>) of Real'Base;\n+\n+   --  Subprograms for Real_Vector types\n+\n+   --  Real_Vector arithmetic operations\n+\n+   function \"+\"   (Right : Real_Vector)       return Real_Vector;\n+   function \"-\"   (Right : Real_Vector)       return Real_Vector;\n+   function \"abs\" (Right : Real_Vector)       return Real_Vector;\n+\n+   function \"+\"   (Left, Right : Real_Vector) return Real_Vector;\n+   function \"-\"   (Left, Right : Real_Vector) return Real_Vector;\n+\n+   function \"*\"   (Left, Right : Real_Vector) return Real'Base;\n+\n+   function \"abs\" (Right : Real_Vector)       return Real'Base;\n+\n+   --  Real_Vector scaling operations\n+\n+   function \"*\" (Left : Real'Base;   Right : Real_Vector) return Real_Vector;\n+   function \"*\" (Left : Real_Vector; Right : Real'Base)   return Real_Vector;\n+   function \"/\" (Left : Real_Vector; Right : Real'Base)   return Real_Vector;\n+\n+   --  Other Real_Vector operations\n+\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Real_Vector;\n+\n+   --  Subprograms for Real_Matrix types\n+\n+   --  Real_Matrix arithmetic operations\n+\n+   function \"+\"       (Right : Real_Matrix) return Real_Matrix;\n+   function \"-\"       (Right : Real_Matrix) return Real_Matrix;\n+   function \"abs\"     (Right : Real_Matrix) return Real_Matrix;\n+   function Transpose (X     : Real_Matrix) return Real_Matrix;\n+\n+   function \"+\" (Left, Right : Real_Matrix) return Real_Matrix;\n+   function \"-\" (Left, Right : Real_Matrix) return Real_Matrix;\n+   function \"*\" (Left, Right : Real_Matrix) return Real_Matrix;\n+\n+   function \"*\" (Left, Right : Real_Vector) return Real_Matrix;\n+\n+   function \"*\" (Left : Real_Vector; Right : Real_Matrix) return Real_Vector;\n+   function \"*\" (Left : Real_Matrix; Right : Real_Vector) return Real_Vector;\n+\n+   --  Real_Matrix scaling operations\n+\n+   function \"*\" (Left : Real'Base;   Right : Real_Matrix) return Real_Matrix;\n+   function \"*\" (Left : Real_Matrix; Right : Real'Base)   return Real_Matrix;\n+   function \"/\" (Left : Real_Matrix; Right : Real'Base)   return Real_Matrix;\n+\n+   --  Real_Matrix inversion and related operations\n+\n+   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector;\n+   function Solve (A, X : Real_Matrix) return Real_Matrix;\n+   function Inverse (A : Real_Matrix) return Real_Matrix;\n+   function Determinant (A : Real_Matrix) return Real'Base;\n+\n+   --  Eigenvalues and vectors of a real symmetric matrix\n+\n+   function Eigenvalues (A : Real_Matrix) return Real_Vector;\n+\n+   procedure Eigensystem\n+     (A       : Real_Matrix;\n+      Values  : out Real_Vector;\n+      Vectors : out Real_Matrix);\n+\n+   --  Other Real_Matrix operations\n+\n+   function Unit_Matrix\n+     (Order   : Positive;\n+      First_1 : Integer := 1;\n+      First_2 : Integer := 1) return Real_Matrix;\n+\n+private\n+   --  The following operations are either relatively simple compared to the\n+   --  expense of returning unconstrained arrays, or are just function wrappers\n+   --  calling procedures implementing the actual operation. By having the\n+   --  front end always inline these, the expense of the unconstrained returns\n+   --  can be avoided.\n+\n+   pragma Inline_Always (\"+\");\n+   pragma Inline_Always (\"-\");\n+   pragma Inline_Always (\"*\");\n+   pragma Inline_Always (\"/\");\n+   pragma Inline_Always (\"abs\");\n+   pragma Inline_Always (Eigenvalues);\n+   pragma Inline_Always (Inverse);\n+   pragma Inline_Always (Solve);\n+   pragma Inline_Always (Transpose);\n+   pragma Inline_Always (Unit_Matrix);\n+   pragma Inline_Always (Unit_Vector);\n+end Ada.Numerics.Generic_Real_Arrays;"}, {"sha": "35e97a5ce4c553622ec112c9e5a312ba45ceeeae", "filename": "gcc/ada/a-nlcoar.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nlcoar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nlcoar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nlcoar.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     ADA.NUMERICS.LONG_COMPLEX_ARRAYS                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Arrays;\n+with Ada.Numerics.Long_Real_Arrays;\n+with Ada.Numerics.Long_Complex_Types;\n+\n+package Ada.Numerics.Long_Complex_Arrays is new\n+   Ada.Numerics.Generic_Complex_Arrays (Long_Real_Arrays, Long_Complex_Types);\n+\n+pragma Pure (Long_Complex_Arrays);"}, {"sha": "48fd91ab94881c38a1c95c945edcc0c7cde5ff28", "filename": "gcc/ada/a-nllcar.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nllcar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nllcar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nllcar.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,24 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.NUMERICS.LONG_LONG_COMPLEX_ARRAYS                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Arrays;\n+with Ada.Numerics.Long_Long_Real_Arrays;\n+with Ada.Numerics.Long_Long_Complex_Types;\n+\n+package Ada.Numerics.Long_Long_Complex_Arrays is\n+   new Ada.Numerics.Generic_Complex_Arrays (Long_Long_Real_Arrays,\n+                                            Long_Long_Complex_Types);\n+\n+pragma Pure (Long_Long_Complex_Arrays);"}, {"sha": "8a1713bc413fb37a0eb99bd2a9f519f649bcd560", "filename": "gcc/ada/a-nllrar.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nllrar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nllrar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nllrar.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    ADA.NUMERICS.LONG_LONG_REAL_ARRAYS                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Real_Arrays;\n+\n+package Ada.Numerics.Long_Long_Real_Arrays is\n+   new Ada.Numerics.Generic_Real_Arrays (Long_Long_Float);\n+\n+pragma Pure (Long_Long_Real_Arrays);"}, {"sha": "252c5d2ab4508306b00e66a7514de07d29263687", "filename": "gcc/ada/a-nlrear.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nlrear.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nlrear.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nlrear.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.NUMERICS.LONG_REAL_ARRAYS                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Real_Arrays;\n+\n+package Ada.Numerics.Long_Real_Arrays is\n+   new Ada.Numerics.Generic_Real_Arrays (Long_Float);\n+\n+pragma Pure (Long_Real_Arrays);"}, {"sha": "938e70a50cccf85747b895ed6dc8bdf60ee94a52", "filename": "gcc/ada/a-nucoar.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nucoar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nucoar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nucoar.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       ADA.NUMERICS.COMPLEX_ARRAYS                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Complex_Arrays;\n+with Ada.Numerics.Real_Arrays;\n+with Ada.Numerics.Complex_Types;\n+\n+package Ada.Numerics.Complex_Arrays is\n+   new Ada.Numerics.Generic_Complex_Arrays (Real_Arrays, Complex_Types);\n+\n+pragma Pure (Complex_Arrays);"}, {"sha": "5141a16e6ef0d28043a61768911965ec831f6f80", "filename": "gcc/ada/a-nurear.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nurear.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fa-nurear.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nurear.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         ADA.NUMERICS.REAL_ARRAYS                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Generic_Real_Arrays;\n+\n+package Ada.Numerics.Real_Arrays is\n+   new Ada.Numerics.Generic_Real_Arrays (Float);\n+\n+pragma Pure (Real_Arrays);"}, {"sha": "72b19244a36d4d3aeae1b60fda2d72c5d9a4e9be", "filename": "gcc/ada/g-sha1.adb", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fg-sha1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fg-sha1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sha1.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,379 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                           G N A T . S H A 1                              --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                     Copyright (C) 2002-2006, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: the code for this unit is derived from GNAT.MD5\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body GNAT.SHA1 is\n+\n+   use Interfaces;\n+\n+   Padding : constant String :=\n+     (1 => Character'Val (16#80#), 2 .. 64 => ASCII.NUL);\n+\n+   Hex_Digit : constant array (Unsigned_32 range 0 .. 15) of Character :=\n+     ('0', '1', '2', '3', '4', '5', '6', '7',\n+      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');\n+   --  Look-up table for each hex digit of the Message-Digest.\n+   --  Used by function Digest (Context).\n+\n+   type Sixteen_Words is array (Natural range 0 .. 15)\n+     of Interfaces.Unsigned_32;\n+   --  Sixteen 32-bit words, converted from block of 64 characters.\n+   --  Used in procedure Decode and Transform.\n+\n+   procedure Decode (Block : String; X : out Sixteen_Words);\n+   --  Convert a String of 64 characters into 16 32-bit numbers\n+\n+   --  The following functions are the four elementary components of each\n+   --  of the four round groups (0 .. 19, 20 .. 39, 40 .. 59, and 60 .. 79)\n+   --  defined in RFC 3174.\n+\n+   function F0 (B, C, D : Unsigned_32) return Unsigned_32;\n+   pragma Inline (F0);\n+\n+   function F1 (B, C, D : Unsigned_32) return Unsigned_32;\n+   pragma Inline (F1);\n+\n+   function F2 (B, C, D : Unsigned_32) return Unsigned_32;\n+   pragma Inline (F2);\n+\n+   function F3 (B, C, D : Unsigned_32) return Unsigned_32;\n+   pragma Inline (F3);\n+\n+   procedure Transform (Ctx : in out Context; Block : String);\n+   --  Process one block of 64 characters\n+\n+   ------------\n+   -- Decode --\n+   ------------\n+\n+   procedure Decode (Block : String; X : out Sixteen_Words) is\n+      Cur : Positive := Block'First;\n+\n+   begin\n+      pragma Assert (Block'Length = 64);\n+\n+      for Index in X'Range loop\n+         X (Index) :=\n+           Unsigned_32 (Character'Pos (Block (Cur + 3))) +\n+           Shift_Left (Unsigned_32 (Character'Pos (Block (Cur + 2))), 8) +\n+           Shift_Left (Unsigned_32 (Character'Pos (Block (Cur + 1))), 16) +\n+           Shift_Left (Unsigned_32 (Character'Pos (Block (Cur))), 24);\n+         Cur := Cur + 4;\n+      end loop;\n+   end Decode;\n+\n+   ------------\n+   -- Digest --\n+   ------------\n+\n+   function Digest (C : Context) return Message_Digest is\n+      Result : Message_Digest;\n+\n+      Cur : Natural := 1;\n+      --  Index in Result where the next character will be placed\n+\n+      Last_Block : String (1 .. 64);\n+\n+      C1 : Context := C;\n+\n+      procedure Convert (X : Unsigned_32);\n+      --  Put the contribution of one of the five H words of the Context in\n+      --  Result. Increments Cur.\n+\n+      -------------\n+      -- Convert --\n+      -------------\n+\n+      procedure Convert (X : Unsigned_32) is\n+         Y : Unsigned_32 := X;\n+      begin\n+         for J in 1 .. 8 loop\n+            Y := Rotate_Left (Y, 4);\n+            Result (Cur) := Hex_Digit (Y and Unsigned_32'(16#0F#));\n+            Cur := Cur + 1;\n+         end loop;\n+      end Convert;\n+\n+   --  Start of processing for Digest\n+\n+   begin\n+      --  Process characters in the context buffer, if any\n+\n+      pragma Assert (C.Last /= C.Buffer'Last);\n+      Last_Block (1 .. C.Last) := C.Buffer (1 .. C.Last);\n+\n+      if C.Last > 55 then\n+         Last_Block (C.Last + 1 .. 64) := Padding (1 .. 64 - C.Last);\n+         Transform (C1, Last_Block);\n+         Last_Block := (others => ASCII.NUL);\n+\n+      else\n+         Last_Block (C.Last + 1 .. 56) := Padding (1 .. 56 - C.Last);\n+      end if;\n+\n+      --  Add the input length (as stored in the context) as 8 characters\n+\n+      Last_Block (57 .. 64) := (others => ASCII.NUL);\n+\n+      declare\n+         L   : Unsigned_64 := Unsigned_64 (C.Length) * 8;\n+         Idx : Positive := 64;\n+      begin\n+         while L > 0 loop\n+            Last_Block (Idx) := Character'Val (L and 16#Ff#);\n+            L := Shift_Right (L, 8);\n+            Idx := Idx - 1;\n+         end loop;\n+      end;\n+\n+      Transform (C1, Last_Block);\n+\n+      Convert (C1.H (0));\n+      Convert (C1.H (1));\n+      Convert (C1.H (2));\n+      Convert (C1.H (3));\n+      Convert (C1.H (4));\n+      return Result;\n+   end Digest;\n+\n+   function Digest (S : String) return Message_Digest is\n+      C : Context;\n+   begin\n+      Update (C, S);\n+      return Digest (C);\n+   end Digest;\n+\n+   function Digest\n+     (A : Ada.Streams.Stream_Element_Array) return Message_Digest\n+   is\n+      C : Context;\n+   begin\n+      Update (C, A);\n+      return Digest (C);\n+   end Digest;\n+\n+   --------\n+   -- F0 --\n+   --------\n+\n+   function F0\n+     (B, C, D : Interfaces.Unsigned_32) return Interfaces.Unsigned_32\n+   is\n+   begin\n+      return (B and C) or ((not B) and D);\n+   end F0;\n+\n+   --------\n+   -- F1 --\n+   --------\n+\n+   function F1\n+     (B, C, D : Interfaces.Unsigned_32) return Interfaces.Unsigned_32\n+   is\n+   begin\n+      return B xor C xor D;\n+   end F1;\n+\n+   --------\n+   -- F2 --\n+   --------\n+\n+   function F2\n+     (B, C, D : Interfaces.Unsigned_32) return Interfaces.Unsigned_32\n+   is\n+   begin\n+      return (B and C) or (B and D) or (C and D);\n+   end F2;\n+\n+   --------\n+   -- F3 --\n+   --------\n+\n+   function F3\n+     (B, C, D : Interfaces.Unsigned_32) return Interfaces.Unsigned_32\n+     renames F1;\n+\n+   ---------------\n+   -- Transform --\n+   ---------------\n+\n+   procedure Transform\n+     (Ctx   : in out Context;\n+      Block : String)\n+   is\n+      W : array (0 .. 79) of Interfaces.Unsigned_32;\n+\n+      A, B, C, D, E, Temp : Interfaces.Unsigned_32;\n+\n+   begin\n+      pragma Assert (Block'Length = 64);\n+\n+      --  a. Divide data block into sixteen words\n+\n+      Decode (Block, Sixteen_Words (W (0 .. 15)));\n+\n+      --  b. Prepare working block of 80 words\n+\n+      for T in 16 .. 79 loop\n+\n+         --  W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16))\n+\n+         W (T) := Rotate_Left\n+           (W (T - 3) xor W (T - 8) xor W (T - 14) xor W (T - 16), 1);\n+\n+      end loop;\n+\n+      --  c. Set up transformation variables\n+\n+      A := Ctx.H (0);\n+      B := Ctx.H (1);\n+      C := Ctx.H (2);\n+      D := Ctx.H (3);\n+      E := Ctx.H (4);\n+\n+      --  d. For each of the 80 rounds, compute:\n+\n+      --  TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);\n+      --  E = D;  D = C;  C = S^30(B);  B = A; A = TEMP;\n+\n+      for T in 0 .. 19 loop\n+         Temp := Rotate_Left (A, 5) + F0 (B, C, D) + E + W (T) + 16#5A827999#;\n+         E := D; D := C; C := Rotate_Left (B, 30); B := A; A := Temp;\n+      end loop;\n+\n+      for T in 20 .. 39 loop\n+         Temp := Rotate_Left (A, 5) + F1 (B, C, D) + E + W (T) + 16#6ED9EBA1#;\n+         E := D; D := C; C := Rotate_Left (B, 30); B := A; A := Temp;\n+      end loop;\n+\n+      for T in 40 .. 59 loop\n+         Temp := Rotate_Left (A, 5) + F2 (B, C, D) + E + W (T) + 16#8F1BBCDC#;\n+         E := D; D := C; C := Rotate_Left (B, 30); B := A; A := Temp;\n+      end loop;\n+\n+      for T in 60 .. 79 loop\n+         Temp := Rotate_Left (A, 5) + F3 (B, C, D) + E + W (T) + 16#CA62C1D6#;\n+         E := D; D := C; C := Rotate_Left (B, 30); B := A; A := Temp;\n+      end loop;\n+\n+      --  e. Update context:\n+      --  H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E\n+\n+      Ctx.H (0) := Ctx.H (0) + A;\n+      Ctx.H (1) := Ctx.H (1) + B;\n+      Ctx.H (2) := Ctx.H (2) + C;\n+      Ctx.H (3) := Ctx.H (3) + D;\n+      Ctx.H (4) := Ctx.H (4) + E;\n+   end Transform;\n+\n+   ------------\n+   -- Update --\n+   ------------\n+\n+   procedure Update\n+     (C     : in out Context;\n+      Input : String)\n+   is\n+      Inp : constant String := C.Buffer (1 .. C.Last) & Input;\n+      Cur : Positive := Inp'First;\n+\n+   begin\n+      C.Length := C.Length + Input'Length;\n+\n+      while Cur + 63 <= Inp'Last loop\n+         Transform (C, Inp (Cur .. Cur + 63));\n+         Cur := Cur + 64;\n+      end loop;\n+\n+      C.Last := Inp'Last - Cur + 1;\n+      C.Buffer (1 .. C.Last) := Inp (Cur .. Inp'Last);\n+   end Update;\n+\n+   procedure Update\n+     (C     : in out Context;\n+      Input : Ada.Streams.Stream_Element_Array)\n+   is\n+      subtype Stream_Array is Ada.Streams.Stream_Element_Array (Input'Range);\n+      subtype Stream_String is\n+        String (1 + Integer (Input'First) .. 1 + Integer (Input'Last));\n+\n+      function To_String is new Ada.Unchecked_Conversion\n+        (Stream_Array, Stream_String);\n+\n+      String_Input : constant String := To_String (Input);\n+   begin\n+      Update (C, String_Input);\n+   end Update;\n+\n+   -----------------\n+   -- Wide_Digest --\n+   -----------------\n+\n+   function Wide_Digest (W : Wide_String) return Message_Digest is\n+      C : Context;\n+   begin\n+      Wide_Update (C, W);\n+      return Digest (C);\n+   end Wide_Digest;\n+\n+   -----------------\n+   -- Wide_Update --\n+   -----------------\n+\n+   procedure Wide_Update\n+     (C     : in out Context;\n+      Input : Wide_String)\n+   is\n+      String_Input : String (1 .. 2 * Input'Length);\n+      Cur          : Positive := 1;\n+\n+   begin\n+      for Index in Input'Range loop\n+         String_Input (Cur) :=\n+           Character'Val\n+            (Unsigned_32 (Wide_Character'Pos (Input (Index))) and 16#FF#);\n+         Cur := Cur + 1;\n+         String_Input (Cur) :=\n+           Character'Val\n+           (Shift_Right (Unsigned_32 (Wide_Character'Pos (Input (Index))), 8)\n+            and 16#FF#);\n+         Cur := Cur + 1;\n+      end loop;\n+\n+      Update (C, String_Input);\n+   end Wide_Update;\n+\n+end GNAT.SHA1;"}, {"sha": "36e2e25d853683b2002ac6c37bcd30aca3584684", "filename": "gcc/ada/g-sha1.ads", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fg-sha1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fg-sha1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sha1.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                            G N A T . S H A 1                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2002-2006, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements the US Secure Hash Algorithm 1 (SHA1) as described\n+--  in RFC 3174. The complete text of RFC 3174 can be found at:\n+\n+--          http://www.ietf.org/rfc/rfc3174.txt\n+\n+--  Note: the code for this unit is derived from GNAT.MD5\n+\n+with Ada.Streams;\n+with Interfaces;\n+\n+package GNAT.SHA1 is\n+\n+   type Context is private;\n+   --  This type holds the five-word (20 byte) buffer H, as described in\n+   --  RFC 3174 (6.1). Its initial value is Initial_Context below.\n+\n+   Initial_Context : constant Context;\n+   --  Initial value of a Context object. May be used to reinitialize\n+   --  a Context value by simple assignment of this value to the object.\n+\n+   procedure Update\n+     (C     : in out Context;\n+      Input : String);\n+   procedure Wide_Update\n+     (C     : in out Context;\n+      Input : Wide_String);\n+   procedure Update\n+     (C     : in out Context;\n+      Input : Ada.Streams.Stream_Element_Array);\n+   --  Modify the Context C. If C has the initial value Initial_Context,\n+   --  then, after a call to one of these procedures, Digest (C) will return\n+   --  the Message-Digest of Input.\n+   --\n+   --  These procedures may be called successively with the same context and\n+   --  different inputs, and these several successive calls will produce\n+   --  the same final context as a call with the concatenation of the inputs.\n+\n+   subtype Message_Digest is String (1 .. 40);\n+   --  The string type returned by function Digest\n+\n+   function Digest (C : Context) return Message_Digest;\n+   --  Extracts the Message-Digest from a context. This function should be\n+   --  used after one or several calls to Update.\n+\n+   function Digest      (S : String)      return Message_Digest;\n+   function Wide_Digest (W : Wide_String) return Message_Digest;\n+   function Digest\n+     (A : Ada.Streams.Stream_Element_Array) return Message_Digest;\n+   --  These functions are equivalent to the corresponding Update (or\n+   --  Wide_Update) on a default initialized Context, followed by Digest\n+   --  on the resulting Context.\n+\n+private\n+\n+   --  Magic numbers\n+\n+   Initial_H0 : constant := 16#67452301#;\n+   Initial_H1 : constant := 16#EFCDAB89#;\n+   Initial_H2 : constant := 16#98BADCFE#;\n+   Initial_H3 : constant := 16#10325476#;\n+   Initial_H4 : constant := 16#C3D2E1F0#;\n+\n+   type H_Type is array (0 .. 4) of Interfaces.Unsigned_32;\n+\n+   Initial_H : constant H_Type :=\n+                (0 => Initial_H0,\n+                 1 => Initial_H1,\n+                 2 => Initial_H2,\n+                 3 => Initial_H3,\n+                 4 => Initial_H4);\n+\n+   type Context is record\n+      H      : H_Type := Initial_H;\n+      Buffer : String (1 .. 64)  := (others => ASCII.NUL);\n+      Last   : Natural := 0;\n+      Length : Natural := 0;\n+   end record;\n+\n+   Initial_Context : constant Context :=\n+     (H => Initial_H,\n+      Buffer => (others => ASCII.NUL), Last => 0, Length => 0);\n+\n+end GNAT.SHA1;"}, {"sha": "db093dd397e1ce258d3a2f7fc618fb07ee372965", "filename": "gcc/ada/i-forbla.ads", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-forbla.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-forbla.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-forbla.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,251 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         INTERFACES.FORTRAN.BLAS                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Comment required if non-RM package ???\n+\n+package Interfaces.Fortran.BLAS is\n+   pragma Pure;\n+\n+   No_Trans   : aliased constant Character := 'N';\n+   Trans      : aliased constant Character := 'T';\n+   Conj_Trans : aliased constant Character := 'C';\n+\n+   --  Vector types\n+\n+   type Real_Vector is array (Integer range <>) of Real;\n+\n+   type Complex_Vector is array (Integer range <>) of Complex;\n+\n+   type Double_Precision_Vector is array (Integer range <>)\n+     of Double_Precision;\n+\n+   type Double_Complex_Vector is array (Integer range <>) of Double_Complex;\n+\n+   --  Matrix types\n+\n+   type Real_Matrix is array (Integer range <>, Integer range <>)\n+     of Real;\n+\n+   type Double_Precision_Matrix is array (Integer range <>, Integer range <>)\n+     of Double_Precision;\n+\n+   type Complex_Matrix is array (Integer range <>, Integer range <>)\n+     of Complex;\n+\n+   type Double_Complex_Matrix is array (Integer range <>, Integer range <>)\n+     of Double_Complex;\n+\n+   --  BLAS Level 1\n+\n+   function sdot\n+     (N     : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Real_Vector;\n+      Inc_Y : Integer := 1) return Real;\n+\n+   function ddot\n+     (N     : Positive;\n+      X     : Double_Precision_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Double_Precision_Vector;\n+      Inc_Y : Integer := 1) return Double_Precision;\n+\n+   function cdot\n+     (N     : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Complex_Vector;\n+      Inc_Y : Integer := 1) return Complex;\n+\n+   function zdot\n+     (N     : Positive;\n+      X     : Double_Complex_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Double_Complex_Vector;\n+      Inc_Y : Integer := 1) return Double_Complex;\n+\n+   function snrm2\n+     (N     : Natural;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1) return Real;\n+\n+   function dnrm2\n+     (N     : Natural;\n+      X     : Double_Precision_Vector;\n+      Inc_X : Integer := 1) return Double_Precision;\n+\n+   function scnrm2\n+     (N     : Natural;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1) return Real;\n+\n+   function dznrm2\n+     (N     : Natural;\n+      X     : Double_Complex_Vector;\n+      Inc_X : Integer := 1) return Double_Precision;\n+\n+   --  BLAS Level 2\n+\n+   procedure sgemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Real := 1.0;\n+      A     : Real_Matrix;\n+      Ld_A  : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Real := 0.0;\n+      Y     : in out Real_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   procedure dgemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Double_Precision := 1.0;\n+      A     : Double_Precision_Matrix;\n+      Ld_A  : Positive;\n+      X     : Double_Precision_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Double_Precision := 0.0;\n+      Y     : in out Double_Precision_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   procedure cgemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Complex := (1.0, 1.0);\n+      A     : Complex_Matrix;\n+      Ld_A  : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Complex := (0.0, 0.0);\n+      Y     : in out Complex_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   procedure zgemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Double_Complex := (1.0, 1.0);\n+      A     : Double_Complex_Matrix;\n+      Ld_A  : Positive;\n+      X     : Double_Complex_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Double_Complex := (0.0, 0.0);\n+      Y     : in out Double_Complex_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   --  BLAS Level 3\n+\n+   procedure sgemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Real := 1.0;\n+      A       : Real_Matrix;\n+      Ld_A    : Integer;\n+      B       : Real_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Real := 0.0;\n+      C       : in out Real_Matrix;\n+      Ld_C    : Integer);\n+\n+   procedure dgemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Double_Precision := 1.0;\n+      A       : Double_Precision_Matrix;\n+      Ld_A    : Integer;\n+      B       : Double_Precision_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Double_Precision := 0.0;\n+      C       : in out Double_Precision_Matrix;\n+      Ld_C    : Integer);\n+\n+   procedure cgemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Complex := (1.0, 1.0);\n+      A       : Complex_Matrix;\n+      Ld_A    : Integer;\n+      B       : Complex_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Complex := (0.0, 0.0);\n+      C       : in out Complex_Matrix;\n+      Ld_C    : Integer);\n+\n+   procedure zgemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Double_Complex := (1.0, 1.0);\n+      A       : Double_Complex_Matrix;\n+      Ld_A    : Integer;\n+      B       : Double_Complex_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Double_Complex := (0.0, 0.0);\n+      C       : in out Double_Complex_Matrix;\n+      Ld_C    : Integer);\n+\n+private\n+   pragma Import (Fortran, cdot,   \"cdot_\");\n+   pragma Import (Fortran, cgemm,  \"cgemm_\");\n+   pragma Import (Fortran, cgemv,  \"cgemv_\");\n+   pragma Import (Fortran, ddot,   \"ddot_\");\n+   pragma Import (Fortran, dgemm,  \"dgemm_\");\n+   pragma Import (Fortran, dgemv,  \"dgemv_\");\n+   pragma Import (Fortran, dnrm2,  \"dnrm2_\");\n+   pragma Import (Fortran, dznrm2, \"dznrm2_\");\n+   pragma Import (Fortran, scnrm2, \"scnrm2_\");\n+   pragma Import (Fortran, sdot,   \"sdot_\");\n+   pragma Import (Fortran, sgemm,  \"sgemm_\");\n+   pragma Import (Fortran, sgemv,  \"sgemv_\");\n+   pragma Import (Fortran, snrm2,  \"snrm2_\");\n+   pragma Import (Fortran, zdot,   \"zdot_\");\n+   pragma Import (Fortran, zgemm,  \"zgemm_\");\n+   pragma Import (Fortran, zgemv,  \"zgemv_\");\n+end Interfaces.Fortran.BLAS;"}, {"sha": "9faacceef70a034c5ebca5685d48db26fd8f873b", "filename": "gcc/ada/i-forlap.ads", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-forlap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-forlap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-forlap.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,416 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        INTERFACES.FORTRAN.LAPACK                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package comment required if non-RM package ???\n+\n+with Interfaces.Fortran.BLAS;\n+package Interfaces.Fortran.LAPACK is\n+   pragma Pure;\n+\n+   type Integer_Vector is array (Integer range <>) of Integer;\n+\n+   Upper : aliased constant Character := 'U';\n+   Lower : aliased constant Character := 'L';\n+\n+   subtype Real_Vector is BLAS.Real_Vector;\n+   subtype Real_Matrix is BLAS.Real_Matrix;\n+   subtype Double_Precision_Vector is BLAS.Double_Precision_Vector;\n+   subtype Double_Precision_Matrix is BLAS.Double_Precision_Matrix;\n+   subtype Complex_Vector is BLAS.Complex_Vector;\n+   subtype Complex_Matrix is BLAS.Complex_Matrix;\n+   subtype Double_Complex_Vector is BLAS.Double_Complex_Vector;\n+   subtype Double_Complex_Matrix is BLAS.Double_Complex_Matrix;\n+\n+   --  LAPACK Computational Routines\n+\n+   --  gerfs  Refines the solution of a system of linear equations with\n+   --         a general matrix and estimates its error\n+   --  getrf  Computes LU factorization of a general m-by-n matrix\n+   --  getri  Computes inverse of an LU-factored general matrix\n+   --         square matrix, with multiple right-hand sides\n+   --  getrs  Solves a system of linear equations with an LU-factored\n+   --         square matrix, with multiple right-hand sides\n+   --  hetrd  Reduces a complex Hermitian matrix to tridiagonal form\n+   --  heevr  Computes selected eigenvalues and, optionally, eigenvectors of\n+   --         a Hermitian matrix using the Relatively Robust Representations\n+   --  orgtr  Generates the real orthogonal matrix Q determined by sytrd\n+   --  steqr  Computes all eigenvalues and eigenvectors of a symmetric or\n+   --         Hermitian matrix reduced to tridiagonal form (QR algorithm)\n+   --  sterf  Computes all eigenvalues of a real symmetric\n+   --         tridiagonal matrix using QR algorithm\n+   --  sytrd  Reduces a real symmetric matrix to tridiagonal form\n+\n+   procedure sgetrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Real_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   procedure dgetrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Double_Precision_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   procedure cgetrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Complex_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   procedure zgetrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Double_Complex_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   procedure sgetri\n+     (N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure dgetri\n+     (N      : Natural;\n+      A      : in out Double_Precision_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Double_Precision_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure cgetri\n+     (N      : Natural;\n+      A      : in out Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure zgetri\n+     (N      : Natural;\n+      A      : in out Double_Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Double_Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure sgetrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Real_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   procedure dgetrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Double_Precision_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Double_Precision_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   procedure cgetrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Complex_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   procedure zgetrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Double_Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Double_Complex_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   procedure cheevr\n+     (Job_Z    : access constant Character;\n+      Rng      : access constant Character;\n+      Uplo     : access constant Character;\n+      N        : Natural;\n+      A        : in out Complex_Matrix;\n+      Ld_A     : Positive;\n+      Vl, Vu   : Real := 0.0;\n+      Il, Iu   : Integer := 1;\n+      Abs_Tol  : Real := 0.0;\n+      M        : out Integer;\n+      W        : out Real_Vector;\n+      Z        : out Complex_Matrix;\n+      Ld_Z     : Positive;\n+      I_Supp_Z : out Integer_Vector;\n+      Work     : out Complex_Vector;\n+      L_Work   : Integer;\n+      R_Work   : out Real_Vector;\n+      LR_Work  : Integer;\n+      I_Work   : out Integer_Vector;\n+      LI_Work  : Integer;\n+      Info     : access Integer);\n+\n+   procedure zheevr\n+     (Job_Z    : access constant Character;\n+      Rng      : access constant Character;\n+      Uplo     : access constant Character;\n+      N        : Natural;\n+      A        : in out Double_Complex_Matrix;\n+      Ld_A     : Positive;\n+      Vl, Vu   : Double_Precision := 0.0;\n+      Il, Iu   : Integer := 1;\n+      Abs_Tol  : Double_Precision := 0.0;\n+      M        : out Integer;\n+      W        : out Double_Precision_Vector;\n+      Z        : out Double_Complex_Matrix;\n+      Ld_Z     : Positive;\n+      I_Supp_Z : out Integer_Vector;\n+      Work     : out Double_Complex_Vector;\n+      L_Work   : Integer;\n+      R_Work   : out Double_Precision_Vector;\n+      LR_Work  : Integer;\n+      I_Work   : out Integer_Vector;\n+      LI_Work  : Integer;\n+      Info     : access Integer);\n+\n+   procedure chetrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Complex_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Real_Vector;\n+      E      : out Real_Vector;\n+      Tau    : out Complex_Vector;\n+      Work   : out Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure zhetrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Double_Complex_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Double_Precision_Vector;\n+      E      : out Double_Precision_Vector;\n+      Tau    : out Double_Complex_Vector;\n+      Work   : out Double_Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure ssytrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Real_Vector;\n+      E      : out Real_Vector;\n+      Tau    : out Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure dsytrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Double_Precision_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Double_Precision_Vector;\n+      E      : out Double_Precision_Vector;\n+      Tau    : out Double_Precision_Vector;\n+      Work   : out Double_Precision_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure ssterf\n+     (N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Info   : access Integer);\n+\n+   procedure dsterf\n+     (N      : Natural;\n+      D      : in out Double_Precision_Vector;\n+      E      : in out Double_Precision_Vector;\n+      Info   : access Integer);\n+\n+   procedure sorgtr\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      Tau    : in Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure dorgtr\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Double_Precision_Matrix;\n+      Ld_A   : Positive;\n+      Tau    : in Double_Precision_Vector;\n+      Work   : out Double_Precision_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure sstebz\n+     (Rng      : access constant Character;\n+      Order    : access constant Character;\n+      N        : in Natural;\n+      Vl, Vu   : in Real := 0.0;\n+      Il, Iu   : in Integer := 1;\n+      Abs_Tol  : in Real := 0.0;\n+      D        : in Real_Vector;\n+      E        : in Real_Vector;\n+      M        : out Natural;\n+      N_Split  : out Natural;\n+      W        : out Real_Vector;\n+      I_Block  : out Integer_Vector;\n+      I_Split  : out Integer_Vector;\n+      Work     : out Real_Vector;\n+      I_Work   : out Integer_Vector;\n+      Info     : access Integer);\n+\n+   procedure dstebz\n+     (Rng      : access constant Character;\n+      Order    : access constant Character;\n+      N        : in Natural;\n+      Vl, Vu   : in Double_Precision := 0.0;\n+      Il, Iu   : in Integer := 1;\n+      Abs_Tol  : in Double_Precision := 0.0;\n+      D        : in Double_Precision_Vector;\n+      E        : in Double_Precision_Vector;\n+      M        : out Natural;\n+      N_Split  : out Natural;\n+      W        : out Double_Precision_Vector;\n+      I_Block  : out Integer_Vector;\n+      I_Split  : out Integer_Vector;\n+      Work     : out Double_Precision_Vector;\n+      I_Work   : out Integer_Vector;\n+      Info     : access Integer);\n+\n+   procedure ssteqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Real_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer);\n+\n+   procedure dsteqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Double_Precision_Vector;\n+      E      : in out Double_Precision_Vector;\n+      Z      : in out Double_Precision_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Double_Precision_Vector;\n+      Info   : access Integer);\n+\n+   procedure csteqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Complex_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer);\n+\n+   procedure zsteqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Double_Precision_Vector;\n+      E      : in out Double_Precision_Vector;\n+      Z      : in out Double_Complex_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Double_Precision_Vector;\n+      Info   : access Integer);\n+\n+private\n+   pragma Import (Fortran, csteqr, \"csteqr_\");\n+   pragma Import (Fortran, cgetrf, \"cgetrf_\");\n+   pragma Import (Fortran, cgetri, \"cgetri_\");\n+   pragma Import (Fortran, cgetrs, \"cgetrs_\");\n+   pragma Import (Fortran, cheevr, \"cheevr_\");\n+   pragma Import (Fortran, chetrd, \"chetrd_\");\n+   pragma Import (Fortran, dgetrf, \"dgetrf_\");\n+   pragma Import (Fortran, dgetri, \"dgetri_\");\n+   pragma Import (Fortran, dgetrs, \"dgetrs_\");\n+   pragma Import (Fortran, dsytrd, \"dsytrd_\");\n+   pragma Import (Fortran, dstebz, \"dstebz_\");\n+   pragma Import (Fortran, dsterf, \"dsterf_\");\n+   pragma Import (Fortran, dorgtr, \"dorgtr_\");\n+   pragma Import (Fortran, dsteqr, \"dsteqr_\");\n+   pragma Import (Fortran, sgetrf, \"sgetrf_\");\n+   pragma Import (Fortran, sgetri, \"sgetri_\");\n+   pragma Import (Fortran, sgetrs, \"sgetrs_\");\n+   pragma Import (Fortran, sorgtr, \"sorgtr_\");\n+   pragma Import (Fortran, sstebz, \"sstebz_\");\n+   pragma Import (Fortran, ssterf, \"ssterf_\");\n+   pragma Import (Fortran, ssteqr, \"ssteqr_\");\n+   pragma Import (Fortran, ssytrd, \"ssytrd_\");\n+   pragma Import (Fortran, zgetrf, \"zgetrf_\");\n+   pragma Import (Fortran, zgetri, \"zgetri_\");\n+   pragma Import (Fortran, zgetrs, \"zgetrs_\");\n+   pragma Import (Fortran, zheevr, \"zheevr_\");\n+   pragma Import (Fortran, zhetrd, \"zhetrd_\");\n+   pragma Import (Fortran, zsteqr, \"zsteqr_\");\n+end Interfaces.Fortran.LAPACK;"}, {"sha": "992eb28634ceda588e883521fa5c46f29f855fd8", "filename": "gcc/ada/i-fortra.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-fortra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fi-fortra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-fortra.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is adapted from the Ada Reference Manual for use with --\n+-- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT.  In accordance with the copyright of that document, you can freely --\n -- copy and modify this specification,  provided that if you redistribute a --\n -- modified version,  any changes that you have made are clearly indicated. --\n@@ -35,8 +35,13 @@ package Interfaces.Fortran is\n    package Single_Precision_Complex_Types is\n       new Ada.Numerics.Generic_Complex_Types (Real);\n \n+   package Double_Precision_Complex_Types is\n+      new Ada.Numerics.Generic_Complex_Types (Double_Precision);\n+\n    type Complex is new Single_Precision_Complex_Types.Complex;\n \n+   type Double_Complex is new Double_Precision_Complex_Types.Complex;\n+\n    subtype Imaginary is Single_Precision_Complex_Types.Imaginary;\n    i : Imaginary renames Single_Precision_Complex_Types.i;\n    j : Imaginary renames Single_Precision_Complex_Types.j;"}, {"sha": "ff5e88b5b3111873afe95021f5d9a7837d4c5de5", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -24,8 +24,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Lib;   use Lib;\n-with Namet; use Namet;\n+with Atree;    use Atree;\n+with Sinfo;    use Sinfo;\n+with Fname.UF; use Fname.UF;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Uname;    use Uname;\n \n package body Impunit is\n \n@@ -207,6 +211,7 @@ package body Impunit is\n      \"g-bubsor\",    -- GNAT.Bubble_Sort\n      \"g-busora\",    -- GNAT.Bubble_Sort_A\n      \"g-busorg\",    -- GNAT.Bubble_Sort_G\n+     \"g-bytswa\",    -- Gnat.Byte_Swapping\n      \"g-calend\",    -- GNAT.Calendar\n      \"g-casuti\",    -- GNAT.Case_Util\n      \"g-catiio\",    -- GNAT.Calendar.Time_IO\n@@ -246,6 +251,7 @@ package body Impunit is\n      \"g-regpat\",    -- GNAT.Regpat\n      \"g-semaph\",    -- GNAT.Semaphores\n      \"g-sestin\",    -- GNAT.Secondary_Stack_Info\n+     \"g-sha1  \",    -- GNAT.SHA1\n      \"g-signal\",    -- GNAT.Signals\n      \"g-socket\",    -- GNAT.Sockets\n      \"g-souinf\",    -- GNAT.Source_Info\n@@ -359,6 +365,10 @@ package body Impunit is\n      \"a-dispat\",    -- Ada.Dispatching\n      \"a-envvar\",    -- Ada.Environment_Variables\n      \"a-rttiev\",    -- Ada.Real_Time.Timing_Events\n+     \"a-ngcoar\",    -- Ada.Numerics.Generic_Complex_Arrays\n+     \"a-ngrear\",    -- Ada.Numerics.Generic_Real_Arrays\n+     \"a-nucoar\",    -- Ada.Numerics.Complex_Arrays\n+     \"a-nurear\",    -- Ada.Numerics.Real_Arrays\n      \"a-stboha\",    -- Ada.Strings.Bounded.Hash\n      \"a-stfiha\",    -- Ada.Strings.Fixed.Hash\n      \"a-strhas\",    -- Ada.Strings.Hash\n@@ -401,6 +411,10 @@ package body Impunit is\n      \"a-llctio\",    -- Ada.Long_Long_Complex_Text_IO\n      \"a-llfzti\",    -- Ada.Long_Long_Float_Wide_Wide_Text_IO\n      \"a-llizti\",    -- Ada.Long_Long_Integer_Wide_Wide_Text_IO\n+     \"a-nlcoar\",    -- Ada.Numerics.Long_Complex_Arrays\n+     \"a-nllcar\",    -- Ada.Numerics.Long_Long_Complex_Arrays\n+     \"a-nllrar\",    -- Ada.Numerics.Long_Long_Real_Arrays\n+     \"a-nlrear\",    -- Ada.Numerics.Long_Real_Arrays\n      \"a-scteio\",    -- Ada.Short_Complex_Text_IO\n      \"a-sfztio\",    -- Ada.Short_Float_Wide_Wide_Text_IO\n      \"a-siztio\",    -- Ada.Short_Integer_Wide_Wide_Text_IO\n@@ -536,4 +550,75 @@ package body Impunit is\n       return Implementation_Unit;\n    end Get_Kind_Of_Unit;\n \n+   -------------------\n+   -- Is_Known_Unit --\n+   -------------------\n+\n+   function Is_Known_Unit (Nam : Node_Id) return Boolean is\n+      Unam : Unit_Name_Type;\n+      Fnam : File_Name_Type;\n+\n+   begin\n+      --  If selector is not an identifier (e.g. it is a character literal or\n+      --  some junk from a previous error), then definitely not a known unit.\n+\n+      if Nkind (Selector_Name (Nam)) /= N_Identifier then\n+         return False;\n+      end if;\n+\n+      --  Otherwise get corresponding file name\n+\n+      Unam := Get_Unit_Name (Nam);\n+      Fnam := Get_File_Name (Unam, Subunit => False);\n+      Get_Name_String (Fnam);\n+\n+      --  Remove extension from file name\n+\n+      if Name_Buffer (Name_Len - 3 .. Name_Len) = \".adb\" then\n+         Name_Len := Name_Len - 4;\n+      else\n+         return False;\n+      end if;\n+\n+      --  Pad name to 8 characters\n+\n+      while Name_Len < 8 loop\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := ' ';\n+      end loop;\n+\n+      --  If length more than 8, definitely not a match\n+\n+      if Name_Len /= 8 then\n+         return False;\n+      end if;\n+\n+      --  If length is 8, search our tables\n+\n+      for J in Non_Imp_File_Names_95'Range loop\n+         if Name_Buffer (1 .. 8) = Non_Imp_File_Names_95 (J) then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      for J in Non_Imp_File_Names_05'Range loop\n+         if Name_Buffer (1 .. 8) = Non_Imp_File_Names_05 (J) then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      --  If not found, not known\n+\n+      return False;\n+\n+   --  A safety guard, if we get an exception during this processing then it\n+   --  is most likely the result of a previous error, or a peculiar case we\n+   --  have not thought of. Since this routine is only used for error message\n+   --  refinement, we will just return False.\n+\n+   exception\n+      when others =>\n+         return False;\n+   end Is_Known_Unit;\n+\n end Impunit;"}, {"sha": "f2ffc4efa1c1100074a2273249e6b4c768beefba", "filename": "gcc/ada/impunit.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fimpunit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fimpunit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -58,4 +58,10 @@ package Impunit is\n    --  Given the unit number of a unit, this function determines the type\n    --  of the unit, as defined above.\n \n+   function Is_Known_Unit (Nam : Node_Id) return Boolean;\n+   --  Nam is the possible name of a child unit, represented as a selected\n+   --  component node. This function determines whether the name matches\n+   --  one of the known library units, and if so, returns True. If the name\n+   --  does not match any known library unit, False is returned.\n+\n end Impunit;"}, {"sha": "b6a3c79b9e93601449ef5693717f81ba8fa93c0b", "filename": "gcc/ada/s-gearop.adb", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,518 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     SYSTEM.GENERIC_ARRAY_OPERATIONS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Generic_Array_Operations is\n+\n+   --  The local function Check_Unit_Last computes the index\n+   --  of the last element returned by Unit_Vector or Unit_Matrix.\n+   --  A separate function is needed to allow raising Constraint_Error\n+   --  before declaring the function result variable. The result variable\n+   --  needs to be declared first, to allow front-end inlining.\n+\n+   function Check_Unit_Last\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer) return Integer;\n+   pragma Inline_Always (Check_Unit_Last);\n+\n+   function Square_Matrix_Length (A : Matrix) return Natural is\n+   begin\n+      if A'Length (1) /= A'Length (2) then\n+         raise Constraint_Error with \"matrix is not square\";\n+      end if;\n+\n+      return A'Length (1);\n+   end Square_Matrix_Length;\n+\n+   ---------------------\n+   -- Check_Unit_Last --\n+   ---------------------\n+\n+   function Check_Unit_Last\n+      (Index : Integer;\n+       Order : Positive;\n+       First : Integer) return Integer is\n+   begin\n+      --  Order the tests carefully to avoid overflow\n+\n+      if Index < First\n+           or else First > Integer'Last - Order + 1\n+           or else Index > First + (Order - 1)\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return First + (Order - 1);\n+   end Check_Unit_Last;\n+\n+   -------------------\n+   -- Inner_Product --\n+   -------------------\n+\n+   function Inner_Product\n+     (Left  : Left_Vector;\n+      Right : Right_Vector)\n+      return  Result_Scalar\n+   is\n+      R : Result_Scalar := Zero;\n+\n+   begin\n+      if Left'Length /= Right'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in inner product\";\n+      end if;\n+\n+      for J in Left'Range loop\n+         R := R + Left (J) * Right (J - Left'First + Right'First);\n+      end loop;\n+\n+      return R;\n+   end Inner_Product;\n+\n+   ----------------------------------\n+   -- Matrix_Elementwise_Operation --\n+   ----------------------------------\n+\n+   function Matrix_Elementwise_Operation (X : X_Matrix) return Result_Matrix is\n+      R : Result_Matrix (X'Range (1), X'Range (2));\n+\n+   begin\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Operation (X (J, K));\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Matrix_Elementwise_Operation;\n+\n+   ----------------------------------\n+   -- Vector_Elementwise_Operation --\n+   ----------------------------------\n+\n+   function Vector_Elementwise_Operation (X : X_Vector) return Result_Vector is\n+      R : Result_Vector (X'Range);\n+\n+   begin\n+      for J in R'Range loop\n+         R (J) := Operation (X (J));\n+      end loop;\n+\n+      return R;\n+   end Vector_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Matrix_Matrix_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Matrix_Matrix_Elementwise_Operation\n+     (Left  : Left_Matrix;\n+      Right : Right_Matrix)\n+      return Result_Matrix\n+   is\n+      R : Result_Matrix (Left'Range (1), Left'Range (2));\n+   begin\n+      if Left'Length (1) /= Right'Length (1)\n+        or else Left'Length (2) /= Right'Length (2)\n+      then\n+         raise Constraint_Error with\n+            \"matrices are of different dimension in elementwise operation\";\n+      end if;\n+\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Operation (Left (J, K), Right (J, K));\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Matrix_Matrix_Elementwise_Operation;\n+\n+   ------------------------------------------------\n+   -- Matrix_Matrix_Scalar_Elementwise_Operation --\n+   ------------------------------------------------\n+\n+   function Matrix_Matrix_Scalar_Elementwise_Operation\n+     (X    : X_Matrix;\n+      Y    : Y_Matrix;\n+      Z    : Z_Scalar) return Result_Matrix\n+   is\n+      R : Result_Matrix (X'Range (1), X'Range (2));\n+\n+   begin\n+      if X'Length (1) /= Y'Length (1)\n+        or else X'Length (2) /= Y'Length (2)\n+      then\n+         raise Constraint_Error with\n+            \"matrices are of different dimension in elementwise operation\";\n+      end if;\n+\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Operation (X (J, K), Y (J, K), Z);\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Matrix_Matrix_Scalar_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Vector_Vector_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Vector_Vector_Elementwise_Operation\n+     (Left  : Left_Vector;\n+      Right : Right_Vector) return Result_Vector\n+   is\n+      R : Result_Vector (Left'Range);\n+\n+   begin\n+      if Left'Length /= Right'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in elementwise operation\";\n+      end if;\n+\n+      for J in R'Range loop\n+         R (J) := Operation (Left (J), Right (J));\n+      end loop;\n+\n+      return R;\n+   end Vector_Vector_Elementwise_Operation;\n+\n+   ------------------------------------------------\n+   -- Vector_Vector_Scalar_Elementwise_Operation --\n+   ------------------------------------------------\n+\n+   function Vector_Vector_Scalar_Elementwise_Operation\n+     (X : X_Vector;\n+      Y : Y_Vector;\n+      Z : Z_Scalar) return Result_Vector\n+   is\n+      R : Result_Vector (X'Range);\n+\n+   begin\n+      if X'Length /= Y'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in elementwise operation\";\n+      end if;\n+\n+      for J in R'Range loop\n+         R (J) := Operation (X (J), Y (J), Z);\n+      end loop;\n+\n+      return R;\n+   end Vector_Vector_Scalar_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Matrix_Scalar_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Matrix_Scalar_Elementwise_Operation\n+     (Left  : Left_Matrix;\n+      Right : Right_Scalar) return Result_Matrix\n+   is\n+      R : Result_Matrix (Left'Range (1), Left'Range (2));\n+\n+   begin\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Operation (Left (J, K), Right);\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Matrix_Scalar_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Vector_Scalar_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Vector_Scalar_Elementwise_Operation\n+     (Left  : Left_Vector;\n+      Right : Right_Scalar) return Result_Vector\n+   is\n+      R : Result_Vector (Left'Range);\n+\n+   begin\n+      for J in R'Range loop\n+         R (J) := Operation (Left (J), Right);\n+      end loop;\n+\n+      return R;\n+   end Vector_Scalar_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Scalar_Matrix_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Scalar_Matrix_Elementwise_Operation\n+     (Left  : Left_Scalar;\n+      Right : Right_Matrix) return Result_Matrix\n+   is\n+      R : Result_Matrix (Right'Range (1), Right'Range (2));\n+\n+   begin\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Operation (Left, Right (J, K));\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Scalar_Matrix_Elementwise_Operation;\n+\n+   -----------------------------------------\n+   -- Scalar_Vector_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   function Scalar_Vector_Elementwise_Operation\n+     (Left  : Left_Scalar;\n+      Right : Right_Vector) return Result_Vector\n+   is\n+      R : Result_Vector (Right'Range);\n+\n+   begin\n+      for J in R'Range loop\n+         R (J) := Operation (Left, Right (J));\n+      end loop;\n+\n+      return R;\n+   end Scalar_Vector_Elementwise_Operation;\n+\n+   ---------------------------\n+   -- Matrix_Matrix_Product --\n+   ---------------------------\n+\n+   function Matrix_Matrix_Product\n+     (Left  : Left_Matrix;\n+      Right : Right_Matrix) return Result_Matrix\n+   is\n+      R : Result_Matrix (Left'Range (1), Right'Range (2));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length (1) then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix multiplication\";\n+      end if;\n+\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            declare\n+               S : Result_Scalar := Zero;\n+            begin\n+               for M in Left'Range (2) loop\n+                  S := S + Left (J, M)\n+                            * Right (M - Left'First (2) + Right'First (1), K);\n+               end loop;\n+\n+               R (J, K) := S;\n+            end;\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end  Matrix_Matrix_Product;\n+\n+   ---------------------------\n+   -- Matrix_Vector_Product --\n+   ---------------------------\n+\n+   function Matrix_Vector_Product\n+     (Left  : Matrix;\n+      Right : Right_Vector) return Result_Vector\n+   is\n+      R : Result_Vector (Left'Range (1));\n+\n+   begin\n+      if Left'Length (2) /= Right'Length then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in matrix-vector multiplication\";\n+      end if;\n+\n+      for J in Left'Range (1) loop\n+         declare\n+            S : Result_Scalar := Zero;\n+         begin\n+            for K in Left'Range (2) loop\n+               S := S + Left (J, K) * Right (K - Left'First (2) + Right'First);\n+            end loop;\n+\n+            R (J) := S;\n+         end;\n+      end loop;\n+\n+      return R;\n+   end Matrix_Vector_Product;\n+\n+   -------------------\n+   -- Outer_Product --\n+   -------------------\n+\n+   function Outer_Product\n+     (Left  : Left_Vector;\n+      Right : Right_Vector) return Matrix\n+   is\n+      R : Matrix (Left'Range, Right'Range);\n+\n+   begin\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := Left (J) * Right (K);\n+         end loop;\n+      end loop;\n+\n+      return R;\n+   end Outer_Product;\n+\n+   ---------------\n+   -- Transpose --\n+   ---------------\n+\n+   procedure Transpose (A : Matrix; R : out Matrix) is\n+   begin\n+      for J in R'Range (1) loop\n+         for K in R'Range (2) loop\n+            R (J, K) := A (J - R'First (1) + A'First (1),\n+                           K - R'First (2) + A'First (2));\n+         end loop;\n+      end loop;\n+   end Transpose;\n+\n+   -------------------------------\n+   -- Update_Matrix_With_Matrix --\n+   -------------------------------\n+\n+   procedure Update_Matrix_With_Matrix (X : in out X_Matrix; Y : Y_Matrix) is\n+   begin\n+      if X'Length (1) /= Y'Length (1)\n+        or else X'Length (2) /= Y'Length (2)\n+      then\n+         raise Constraint_Error with\n+            \"matrices are of different dimension in update operation\";\n+      end if;\n+\n+      for J in X'Range (1) loop\n+         for K in X'Range (2) loop\n+            Update (X (J, K), Y (J - X'First (1) + Y'First (1),\n+                                 K - X'First (2) + Y'First (2)));\n+         end loop;\n+      end loop;\n+   end Update_Matrix_With_Matrix;\n+\n+   -------------------------------\n+   -- Update_Vector_With_Vector --\n+   -------------------------------\n+\n+   procedure Update_Vector_With_Vector (X : in out X_Vector; Y : Y_Vector) is\n+   begin\n+      if X'Length /= Y'Length then\n+         raise Constraint_Error with\n+            \"vectors are of different length in update operation\";\n+      end if;\n+\n+      for J in X'Range loop\n+         Update (X (J), Y (J - X'First + Y'First));\n+      end loop;\n+   end Update_Vector_With_Vector;\n+\n+   -----------------\n+   -- Unit_Matrix --\n+   -----------------\n+\n+   function Unit_Matrix\n+     (Order   : Positive;\n+      First_1 : Integer := 1;\n+      First_2 : Integer := 1) return Matrix\n+   is\n+      R : Matrix (First_1 .. Check_Unit_Last (First_1, Order, First_1),\n+                  First_2 .. Check_Unit_Last (First_2, Order, First_2));\n+\n+   begin\n+      R := (others => (others => Zero));\n+\n+      for J in 0 .. Order - 1 loop\n+         R (First_1 + J, First_2 + J) := One;\n+      end loop;\n+\n+      return R;\n+   end Unit_Matrix;\n+\n+   -----------------\n+   -- Unit_Vector --\n+   -----------------\n+\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Vector\n+   is\n+      R : Vector (First .. Check_Unit_Last (Index, Order, First));\n+   begin\n+      R := (others => Zero);\n+      R (Index) := One;\n+      return R;\n+   end Unit_Vector;\n+\n+   ---------------------------\n+   -- Vector_Matrix_Product --\n+   ---------------------------\n+\n+   function Vector_Matrix_Product\n+     (Left  : Left_Vector;\n+      Right : Matrix) return Result_Vector\n+   is\n+      R : Result_Vector (Right'Range (2));\n+\n+   begin\n+      if Left'Length /= Right'Length (2) then\n+         raise Constraint_Error with\n+            \"incompatible dimensions in vector-matrix multiplication\";\n+      end if;\n+\n+      for J in Right'Range (2) loop\n+         declare\n+            S : Result_Scalar := Zero;\n+\n+         begin\n+            for K in Right'Range (1) loop\n+               S := S + Left (J - Right'First (1) + Left'First) * Right (K, J);\n+            end loop;\n+\n+            R (J) := S;\n+         end;\n+      end loop;\n+\n+      return R;\n+   end Vector_Matrix_Product;\n+\n+end System.Generic_Array_Operations;"}, {"sha": "b922871979dfac09551990c7e4869dce43d0ae0a", "filename": "gcc/ada/s-gearop.ads", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gearop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gearop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,398 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     SYSTEM.GENERIC_ARRAY_OPERATIONS                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System.Generic_Array_Operations is\n+pragma Pure (Generic_Array_Operations);\n+\n+   --------------------------\n+   -- Square_Matrix_Length --\n+   --------------------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+   function Square_Matrix_Length (A : Matrix) return Natural;\n+   --  If A is non-square, raise Constraint_Error,  else return its dimension\n+\n+   ----------------------------------\n+   -- Vector_Elementwise_Operation --\n+   ----------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Result_Scalar is private;\n+      type X_Vector is array (Integer range <>) of X_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      with function Operation (X : X_Scalar) return Result_Scalar;\n+   function Vector_Elementwise_Operation (X : X_Vector) return Result_Vector;\n+\n+   ----------------------------------\n+   -- Matrix_Elementwise_Operation --\n+   ----------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Result_Scalar is private;\n+      type X_Matrix is array (Integer range <>, Integer range <>) of X_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function Operation (X : X_Scalar) return Result_Scalar;\n+   function Matrix_Elementwise_Operation (X : X_Matrix) return Result_Matrix;\n+\n+   -----------------------------------------\n+   -- Vector_Vector_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Vector is array (Integer range <>) of Left_Scalar;\n+      type Right_Vector is array (Integer range <>) of Right_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Vector_Vector_Elementwise_Operation\n+     (Left  : Left_Vector;\n+      Right : Right_Vector) return Result_Vector;\n+\n+   ------------------------------------------------\n+   -- Vector_Vector_Scalar_Elementwise_Operation --\n+   ------------------------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Y_Scalar is private;\n+      type Z_Scalar is private;\n+      type Result_Scalar is private;\n+      type X_Vector is array (Integer range <>) of X_Scalar;\n+      type Y_Vector is array (Integer range <>) of Y_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      with function Operation\n+             (X : X_Scalar;\n+              Y : Y_Scalar;\n+              Z : Z_Scalar) return Result_Scalar;\n+   function Vector_Vector_Scalar_Elementwise_Operation\n+     (X : X_Vector;\n+      Y : Y_Vector;\n+      Z : Z_Scalar) return Result_Vector;\n+\n+   -----------------------------------------\n+   -- Matrix_Matrix_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Matrix is array (Integer range <>, Integer range <>)\n+        of Left_Scalar;\n+      type Right_Matrix is array (Integer range <>, Integer range <>)\n+        of Right_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Matrix_Matrix_Elementwise_Operation\n+     (Left  : Left_Matrix;\n+      Right : Right_Matrix) return Result_Matrix;\n+\n+   ------------------------------------------------\n+   -- Matrix_Matrix_Scalar_Elementwise_Operation --\n+   ------------------------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Y_Scalar is private;\n+      type Z_Scalar is private;\n+      type Result_Scalar is private;\n+      type X_Matrix is array (Integer range <>, Integer range <>) of X_Scalar;\n+      type Y_Matrix is array (Integer range <>, Integer range <>) of Y_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function Operation\n+             (X : X_Scalar;\n+              Y : Y_Scalar;\n+              Z : Z_Scalar) return Result_Scalar;\n+   function Matrix_Matrix_Scalar_Elementwise_Operation\n+     (X : X_Matrix;\n+      Y : Y_Matrix;\n+      Z : Z_Scalar) return Result_Matrix;\n+\n+   -----------------------------------------\n+   -- Vector_Scalar_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Vector is array (Integer range <>) of Left_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Vector_Scalar_Elementwise_Operation\n+     (Left  : Left_Vector;\n+      Right : Right_Scalar) return Result_Vector;\n+\n+   -----------------------------------------\n+   -- Matrix_Scalar_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Matrix is array (Integer range <>, Integer range <>)\n+        of Left_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Matrix_Scalar_Elementwise_Operation\n+     (Left  : Left_Matrix;\n+      Right : Right_Scalar) return Result_Matrix;\n+\n+   -----------------------------------------\n+   -- Scalar_Vector_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Right_Vector is array (Integer range <>) of Right_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Scalar_Vector_Elementwise_Operation\n+     (Left  : Left_Scalar;\n+      Right : Right_Vector) return Result_Vector;\n+\n+   -----------------------------------------\n+   -- Scalar_Matrix_Elementwise_Operation --\n+   -----------------------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Right_Matrix is array (Integer range <>, Integer range <>)\n+        of Right_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function Operation\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar;\n+   function Scalar_Matrix_Elementwise_Operation\n+     (Left  : Left_Scalar;\n+      Right : Right_Matrix) return Result_Matrix;\n+\n+   -------------------\n+   -- Inner_Product --\n+   -------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Vector is array (Integer range <>) of Left_Scalar;\n+      type Right_Vector is array (Integer range <>) of Right_Scalar;\n+      Zero : Result_Scalar;\n+      with function \"*\"\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar is <>;\n+      with function \"+\"\n+             (Left  : Result_Scalar;\n+              Right : Result_Scalar) return Result_Scalar is <>;\n+   function Inner_Product\n+     (Left  : Left_Vector;\n+      Right : Right_Vector) return Result_Scalar;\n+\n+   -------------------\n+   -- Outer_Product --\n+   -------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Vector is array (Integer range <>) of Left_Scalar;\n+      type Right_Vector is array (Integer range <>) of Right_Scalar;\n+      type Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      with function \"*\"\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar is <>;\n+   function Outer_Product\n+     (Left  : Left_Vector;\n+      Right : Right_Vector) return Matrix;\n+\n+   ---------------------------\n+   -- Matrix_Vector_Product --\n+   ---------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>)\n+        of Left_Scalar;\n+      type Right_Vector is array (Integer range <>) of Right_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      Zero : Result_Scalar;\n+      with function \"*\"\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar is <>;\n+      with function \"+\"\n+             (Left  : Result_Scalar;\n+              Right : Result_Scalar) return Result_Scalar is <>;\n+   function Matrix_Vector_Product\n+     (Left  : Matrix;\n+      Right : Right_Vector) return Result_Vector;\n+\n+   ---------------------------\n+   -- Vector_Matrix_Product --\n+   ---------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Vector is array (Integer range <>) of Left_Scalar;\n+      type Matrix is array (Integer range <>, Integer range <>)\n+        of Right_Scalar;\n+      type Result_Vector is array (Integer range <>) of Result_Scalar;\n+      Zero : Result_Scalar;\n+      with function \"*\"\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar is <>;\n+      with function \"+\"\n+             (Left  : Result_Scalar;\n+              Right : Result_Scalar) return Result_Scalar is <>;\n+   function Vector_Matrix_Product\n+     (Left  : Left_Vector;\n+      Right : Matrix) return Result_Vector;\n+\n+   ---------------------------\n+   -- Matrix_Matrix_Product --\n+   ---------------------------\n+\n+   generic\n+      type Left_Scalar is private;\n+      type Right_Scalar is private;\n+      type Result_Scalar is private;\n+      type Left_Matrix is array (Integer range <>, Integer range <>)\n+        of Left_Scalar;\n+      type Right_Matrix is array (Integer range <>, Integer range <>)\n+        of Right_Scalar;\n+      type Result_Matrix is array (Integer range <>, Integer range <>)\n+        of Result_Scalar;\n+      Zero : Result_Scalar;\n+      with function \"*\"\n+             (Left  : Left_Scalar;\n+              Right : Right_Scalar) return Result_Scalar is <>;\n+      with function \"+\"\n+             (Left  : Result_Scalar;\n+              Right : Result_Scalar) return Result_Scalar is <>;\n+   function Matrix_Matrix_Product\n+     (Left  : Left_Matrix;\n+      Right : Right_Matrix) return Result_Matrix;\n+\n+   ---------------\n+   -- Transpose --\n+   ---------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+   procedure Transpose (A : Matrix; R : out Matrix);\n+\n+   -------------------------------\n+   -- Update_Vector_With_Vector --\n+   -------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Y_Scalar is private;\n+      type X_Vector is array (Integer range <>) of X_Scalar;\n+      type Y_Vector is array (Integer range <>) of Y_Scalar;\n+      with procedure Update (X : in out X_Scalar; Y : Y_Scalar);\n+   procedure Update_Vector_With_Vector (X : in out X_Vector; Y : Y_Vector);\n+\n+   -------------------------------\n+   -- Update_Matrix_With_Matrix --\n+   -------------------------------\n+\n+   generic\n+      type X_Scalar is private;\n+      type Y_Scalar is private;\n+      type X_Matrix is array (Integer range <>, Integer range <>) of X_Scalar;\n+      type Y_Matrix is array (Integer range <>, Integer range <>) of Y_Scalar;\n+      with procedure Update (X : in out X_Scalar; Y : Y_Scalar);\n+   procedure Update_Matrix_With_Matrix (X : in out X_Matrix; Y : Y_Matrix);\n+\n+   -----------------\n+   -- Unit_Matrix --\n+   -----------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+      Zero : Scalar;\n+      One  : Scalar;\n+   function Unit_Matrix\n+     (Order   : Positive;\n+      First_1 : Integer := 1;\n+      First_2 : Integer := 1) return Matrix;\n+\n+   -----------------\n+   -- Unit_Vector --\n+   -----------------\n+\n+   generic\n+      type Scalar is private;\n+      type Vector is array (Integer range <>) of Scalar;\n+      Zero : Scalar;\n+      One  : Scalar;\n+   function Unit_Vector\n+     (Index : Integer;\n+      Order : Positive;\n+      First : Integer := 1) return Vector;\n+\n+end System.Generic_Array_Operations;"}, {"sha": "db657c322edf5e29cf2608f2671eef917a9edc2d", "filename": "gcc/ada/s-gecobl.adb", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecobl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecobl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecobl.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,352 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       SYSTEM.GENERIC_COMPLEX_BLAS                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;        use Ada;\n+with Interfaces;                      use Interfaces;\n+with Interfaces.Fortran;              use Interfaces.Fortran;\n+with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+\n+package body System.Generic_Complex_BLAS is\n+\n+   Is_Single : constant Boolean :=\n+                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n+                  and then Fortran.Real (Real'First) = Fortran.Real'First\n+                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n+\n+   Is_Double : constant Boolean :=\n+                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n+                  and then\n+                    Double_Precision (Real'First) = Double_Precision'First\n+                  and then\n+                    Double_Precision (Real'Last) = Double_Precision'Last;\n+\n+   subtype Complex is Complex_Types.Complex;\n+\n+   --  Local subprograms\n+\n+   function To_Double_Precision (X : Real) return Double_Precision;\n+   pragma Inline (To_Double_Precision);\n+\n+   function To_Double_Complex (X : Complex) return Double_Complex;\n+   pragma Inline (To_Double_Complex);\n+\n+   function To_Complex (X : Double_Complex) return Complex;\n+   function To_Complex (X : Fortran.Complex) return Complex;\n+   pragma Inline (To_Complex);\n+\n+   function To_Fortran (X : Complex) return Fortran.Complex;\n+   pragma Inline (To_Fortran);\n+\n+   --  Instantiations\n+\n+   function To_Double_Complex is new\n+      Vector_Elementwise_Operation\n+       (X_Scalar      => Complex_Types.Complex,\n+        Result_Scalar => Fortran.Double_Complex,\n+        X_Vector      => Complex_Vector,\n+        Result_Vector => BLAS.Double_Complex_Vector,\n+        Operation     => To_Double_Complex);\n+\n+   function To_Complex is new\n+      Vector_Elementwise_Operation\n+       (X_Scalar      => Fortran.Double_Complex,\n+        Result_Scalar => Complex,\n+        X_Vector      => BLAS.Double_Complex_Vector,\n+        Result_Vector => Complex_Vector,\n+        Operation     => To_Complex);\n+\n+   function To_Double_Complex is new\n+      Matrix_Elementwise_Operation\n+       (X_Scalar      => Complex,\n+        Result_Scalar => Double_Complex,\n+        X_Matrix      => Complex_Matrix,\n+        Result_Matrix => BLAS.Double_Complex_Matrix,\n+        Operation     => To_Double_Complex);\n+\n+   function To_Complex is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Double_Complex,\n+        Result_Scalar => Complex,\n+        X_Matrix      => BLAS.Double_Complex_Matrix,\n+        Result_Matrix => Complex_Matrix,\n+        Operation     => To_Complex);\n+\n+   function To_Double_Precision (X : Real) return Double_Precision is\n+   begin\n+      return Double_Precision (X);\n+   end To_Double_Precision;\n+\n+   function To_Double_Complex (X : Complex) return Double_Complex is\n+   begin\n+      return (To_Double_Precision (X.Re), To_Double_Precision (X.Im));\n+   end To_Double_Complex;\n+\n+   function To_Complex (X : Double_Complex) return Complex is\n+   begin\n+      return (Real (X.Re), Real (X.Im));\n+   end To_Complex;\n+\n+   function To_Complex (X : Fortran.Complex) return Complex is\n+   begin\n+      return (Real (X.Re), Real (X.Im));\n+   end To_Complex;\n+\n+   function To_Fortran (X : Complex) return Fortran.Complex is\n+   begin\n+      return (Fortran.Real (X.Re), Fortran.Real (X.Im));\n+   end To_Fortran;\n+\n+   ---------\n+   -- dot --\n+   ---------\n+\n+   function dot\n+     (N     : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Complex_Vector;\n+      Inc_Y : Integer := 1) return Complex\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type X_Ptr is access all BLAS.Complex_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Complex_Vector (Y'Range);\n+            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            return To_Complex (BLAS.cdot (N, Conv_X (X'Address).all, Inc_X,\n+                                  Conv_Y (Y'Address).all, Inc_Y));\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type X_Ptr is access all BLAS.Double_Complex_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Double_Complex_Vector (Y'Range);\n+            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            return To_Complex (BLAS.zdot (N, Conv_X (X'Address).all, Inc_X,\n+                                     Conv_Y (Y'Address).all, Inc_Y));\n+         end;\n+\n+      else\n+         return To_Complex (BLAS.zdot (N, To_Double_Complex (X), Inc_X,\n+                                  To_Double_Complex (Y), Inc_Y));\n+      end if;\n+   end dot;\n+\n+   ----------\n+   -- gemm --\n+   ----------\n+\n+   procedure gemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Complex := (1.0, 1.0);\n+      A       : Complex_Matrix;\n+      Ld_A    : Integer;\n+      B       : Complex_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Complex := (0.0, 0.0);\n+      C       : in out Complex_Matrix;\n+      Ld_C    : Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            subtype B_Type is BLAS.Complex_Matrix (B'Range (1), B'Range (2));\n+            type C_Ptr is\n+              access all BLAS.Complex_Matrix (C'Range (1), C'Range (2));\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_B is\n+               new Unchecked_Conversion (Complex_Matrix, B_Type);\n+            function Conv_C is\n+               new Unchecked_Conversion (Address, C_Ptr);\n+         begin\n+            BLAS.cgemm (Trans_A, Trans_B, M, N, K, To_Fortran (Alpha),\n+                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, To_Fortran (Beta),\n+                   Conv_C (C'Address).all, Ld_C);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype A_Type is\n+               BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            subtype B_Type is\n+               BLAS.Double_Complex_Matrix (B'Range (1), B'Range (2));\n+            type C_Ptr is access all\n+               BLAS.Double_Complex_Matrix (C'Range (1), C'Range (2));\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_B is\n+               new Unchecked_Conversion (Complex_Matrix, B_Type);\n+            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n+         begin\n+            BLAS.zgemm (Trans_A, Trans_B, M, N, K, To_Double_Complex (Alpha),\n+                   Conv_A (A), Ld_A, Conv_B (B), Ld_B,\n+                   To_Double_Complex (Beta),\n+                   Conv_C (C'Address).all, Ld_C);\n+         end;\n+\n+      else\n+         declare\n+            DP_C : BLAS.Double_Complex_Matrix (C'Range (1), C'Range (2));\n+         begin\n+            if Beta.Re /= 0.0 or else Beta.Im /= 0.0 then\n+               DP_C := To_Double_Complex (C);\n+            end if;\n+\n+            BLAS.zgemm (Trans_A, Trans_B, M, N, K, To_Double_Complex (Alpha),\n+                   To_Double_Complex (A), Ld_A,\n+                   To_Double_Complex (B), Ld_B, To_Double_Complex (Beta),\n+                   DP_C, Ld_C);\n+\n+            C := To_Complex (DP_C);\n+         end;\n+      end if;\n+   end gemm;\n+\n+   ----------\n+   -- gemv --\n+   ----------\n+\n+   procedure gemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Complex := (1.0, 1.0);\n+      A     : Complex_Matrix;\n+      Ld_A  : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;\n+      Beta  : Complex := (0.0, 0.0);\n+      Y     : in out Complex_Vector;\n+      Inc_Y : Integer := 1)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            subtype X_Type is BLAS.Complex_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Complex_Vector (Y'Range);\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_X is\n+               new Unchecked_Conversion (Complex_Vector, X_Type);\n+            function Conv_Y is\n+               new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            BLAS.cgemv (Trans, M, N, To_Fortran (Alpha),\n+                   Conv_A (A), Ld_A, Conv_X (X), Inc_X, To_Fortran (Beta),\n+                   Conv_Y (Y'Address).all, Inc_Y);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype A_Type is\n+               BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            subtype X_Type is\n+               BLAS.Double_Complex_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Double_Complex_Vector (Y'Range);\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_X is\n+               new Unchecked_Conversion (Complex_Vector, X_Type);\n+            function Conv_Y is\n+               new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            BLAS.zgemv (Trans, M, N, To_Double_Complex (Alpha),\n+                   Conv_A (A), Ld_A, Conv_X (X), Inc_X,\n+                   To_Double_Complex (Beta),\n+                   Conv_Y (Y'Address).all, Inc_Y);\n+         end;\n+\n+      else\n+         declare\n+            DP_Y : BLAS.Double_Complex_Vector (Y'Range);\n+         begin\n+            if Beta.Re /= 0.0 or else Beta.Im /= 0.0 then\n+               DP_Y := To_Double_Complex (Y);\n+            end if;\n+\n+            BLAS.zgemv (Trans, M, N, To_Double_Complex (Alpha),\n+                   To_Double_Complex (A), Ld_A,\n+                   To_Double_Complex (X), Inc_X, To_Double_Complex (Beta),\n+                   DP_Y, Inc_Y);\n+\n+            Y := To_Complex (DP_Y);\n+         end;\n+      end if;\n+   end gemv;\n+\n+   ----------\n+   -- nrm2 --\n+   ----------\n+\n+   function nrm2\n+     (N     : Natural;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1) return Real\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype X_Type is BLAS.Complex_Vector (X'Range);\n+            function Conv_X is\n+               new Unchecked_Conversion (Complex_Vector, X_Type);\n+         begin\n+            return Real (BLAS.scnrm2 (N, Conv_X (X), Inc_X));\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype X_Type is BLAS.Double_Complex_Vector (X'Range);\n+            function Conv_X is\n+               new Unchecked_Conversion (Complex_Vector, X_Type);\n+         begin\n+            return Real (BLAS.dznrm2 (N, Conv_X (X), Inc_X));\n+         end;\n+\n+      else\n+         return Real (BLAS.dznrm2 (N, To_Double_Complex (X), Inc_X));\n+      end if;\n+   end nrm2;\n+\n+end System.Generic_Complex_BLAS;"}, {"sha": "9d9d2162ca36e05ed453cf286a2b6ace9dfd318b", "filename": "gcc/ada/s-gecobl.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecobl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecobl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecobl.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       SYSTEM.GENERIC_COMPLEX_BLAS                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package comment required ???\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+\n+generic\n+   type Real is digits <>;\n+   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Real);\n+   use Complex_Types;\n+\n+   type Complex_Vector is array (Integer range <>) of Complex;\n+   type Complex_Matrix is array (Integer range <>, Integer range <>)\n+      of Complex;\n+package System.Generic_Complex_BLAS is\n+   pragma Pure;\n+\n+   --  Although BLAS support is only available for IEEE single and double\n+   --  compatible floating-point types, this unit will accept any type\n+   --  and apply conversions as necessary, with possible loss of\n+   --  precision and range.\n+\n+   No_Trans   : aliased constant Character := 'N';\n+   Trans      : aliased constant Character := 'T';\n+   Conj_Trans : aliased constant Character := 'C';\n+\n+   --  BLAS Level 1 Subprograms and Types\n+\n+   function dot\n+     (N     : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Complex_Vector;\n+      Inc_Y : Integer := 1) return Complex;\n+\n+   function nrm2\n+     (N     : Natural;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1) return Real;\n+\n+   procedure gemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Complex := (1.0, 1.0);\n+      A     : Complex_Matrix;\n+      Ld_A  : Positive;\n+      X     : Complex_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Complex := (0.0, 0.0);\n+      Y     : in out Complex_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   --  BLAS Level 3\n+\n+   --  gemm   s, d, c, z  Matrix-matrix product of general matrices\n+\n+   procedure gemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Complex := (1.0, 1.0);\n+      A       : Complex_Matrix;\n+      Ld_A    : Integer;\n+      B       : Complex_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Complex := (0.0, 0.0);\n+      C       : in out Complex_Matrix;\n+      Ld_C    : Integer);\n+\n+end System.Generic_Complex_BLAS;"}, {"sha": "ef3ea1ccecae61698622519c88544893fa1c2d0d", "filename": "gcc/ada/s-gecola.adb", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecola.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecola.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecola.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,495 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      SYSTEM.GENERIC_COMPLEX_LAPACK                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;        use Ada;\n+with Interfaces;                      use Interfaces;\n+with Interfaces.Fortran;              use Interfaces.Fortran;\n+with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n+with Interfaces.Fortran.LAPACK;       use Interfaces.Fortran.LAPACK;\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+\n+package body System.Generic_Complex_LAPACK is\n+\n+   Is_Single : constant Boolean :=\n+                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n+                  and then Fortran.Real (Real'First) = Fortran.Real'First\n+                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n+\n+   Is_Double : constant Boolean :=\n+                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n+                  and then\n+                    Double_Precision (Real'First) = Double_Precision'First\n+                  and then\n+                    Double_Precision (Real'Last) = Double_Precision'Last;\n+\n+   subtype Complex is Complex_Types.Complex;\n+\n+   --  Local subprograms\n+\n+   function To_Double_Precision (X : Real) return Double_Precision;\n+   pragma Inline (To_Double_Precision);\n+\n+   function To_Real (X : Double_Precision) return Real;\n+   pragma Inline (To_Real);\n+\n+   function To_Double_Complex (X : Complex) return Double_Complex;\n+   pragma Inline (To_Double_Complex);\n+\n+   function To_Complex (X : Double_Complex) return Complex;\n+   pragma Inline (To_Complex);\n+\n+   --  Instantiations\n+\n+   function To_Double_Precision is new\n+      Vector_Elementwise_Operation\n+       (X_Scalar      => Real,\n+        Result_Scalar => Double_Precision,\n+        X_Vector      => Real_Vector,\n+        Result_Vector => Double_Precision_Vector,\n+        Operation     => To_Double_Precision);\n+\n+   function To_Real is new\n+      Vector_Elementwise_Operation\n+       (X_Scalar      => Double_Precision,\n+        Result_Scalar => Real,\n+        X_Vector      => Double_Precision_Vector,\n+        Result_Vector => Real_Vector,\n+        Operation     => To_Real);\n+\n+   function To_Double_Complex is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Complex,\n+        Result_Scalar => Double_Complex,\n+        X_Matrix      => Complex_Matrix,\n+        Result_Matrix => Double_Complex_Matrix,\n+        Operation     => To_Double_Complex);\n+\n+   function To_Complex is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Double_Complex,\n+        Result_Scalar => Complex,\n+        X_Matrix      => Double_Complex_Matrix,\n+        Result_Matrix => Complex_Matrix,\n+        Operation     => To_Complex);\n+\n+   function To_Double_Precision (X : Real) return Double_Precision is\n+   begin\n+      return Double_Precision (X);\n+   end To_Double_Precision;\n+\n+   function To_Real (X : Double_Precision) return Real is\n+   begin\n+      return Real (X);\n+   end To_Real;\n+\n+   function To_Double_Complex (X : Complex) return Double_Complex is\n+   begin\n+      return (To_Double_Precision (X.Re), To_Double_Precision (X.Im));\n+   end To_Double_Complex;\n+\n+   function To_Complex (X : Double_Complex) return Complex is\n+   begin\n+      return (Real (X.Re), Real (X.Im));\n+   end To_Complex;\n+\n+   -----------\n+   -- getrf --\n+   -----------\n+\n+   procedure getrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Complex_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+         begin\n+            cgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv), Info);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type A_Ptr is\n+               access all Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+         begin\n+            zgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv), Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n+         begin\n+            DP_A := To_Double_Complex (A);\n+            zgetrf (M, N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv), Info);\n+            A := To_Complex (DP_A);\n+         end;\n+      end if;\n+   end getrf;\n+\n+   -----------\n+   -- getri --\n+   -----------\n+\n+   procedure getri\n+     (N      : Natural;\n+      A      : in out Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            type Work_Ptr is\n+               access all BLAS.Complex_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            cgetri (N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type A_Ptr is\n+               access all Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            type Work_Ptr is\n+               access all Double_Complex_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            zgetri (N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            DP_Work : Double_Complex_Vector (Work'Range);\n+         begin\n+            DP_A := To_Double_Complex (A);\n+            zgetri (N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv),\n+                    DP_Work, L_Work, Info);\n+            A := To_Complex (DP_A);\n+            Work (1) := To_Complex (DP_Work (1));\n+         end;\n+      end if;\n+   end getri;\n+\n+   -----------\n+   -- getrs --\n+   -----------\n+\n+   procedure getrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Complex_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype A_Type is BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            type B_Ptr is\n+               access all BLAS.Complex_Matrix (B'Range (1), B'Range (2));\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n+         begin\n+            cgetrs (Trans, N, N_Rhs,\n+                    Conv_A (A), Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_B (B'Address).all, Ld_B,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype A_Type is\n+               Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            type B_Ptr is\n+               access all Double_Complex_Matrix (B'Range (1), B'Range (2));\n+            function Conv_A is\n+               new Unchecked_Conversion (Complex_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n+         begin\n+            zgetrs (Trans, N, N_Rhs,\n+                    Conv_A (A), Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_B (B'Address).all, Ld_B,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            DP_B : Double_Complex_Matrix (B'Range (1), B'Range (2));\n+         begin\n+            DP_A := To_Double_Complex (A);\n+            DP_B := To_Double_Complex (B);\n+            zgetrs (Trans, N, N_Rhs,\n+                    DP_A, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    DP_B, Ld_B,\n+                    Info);\n+            B := To_Complex (DP_B);\n+         end;\n+      end if;\n+   end getrs;\n+\n+   procedure heevr\n+     (Job_Z    : access constant Character;\n+      Rng      : access constant Character;\n+      Uplo     : access constant Character;\n+      N        : Natural;\n+      A        : in out Complex_Matrix;\n+      Ld_A     : Positive;\n+      Vl, Vu   : Real := 0.0;\n+      Il, Iu   : Integer := 1;\n+      Abs_Tol  : Real := 0.0;\n+      M        : out Integer;\n+      W        : out Real_Vector;\n+      Z        : out Complex_Matrix;\n+      Ld_Z     : Positive;\n+      I_Supp_Z : out Integer_Vector;\n+      Work     : out Complex_Vector;\n+      L_Work   : Integer;\n+      R_Work   : out Real_Vector;\n+      LR_Work  : Integer;\n+      I_Work   : out Integer_Vector;\n+      LI_Work  : Integer;\n+      Info     : access Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Complex_Matrix (A'Range (1), A'Range (2));\n+            type W_Ptr is\n+               access all BLAS.Real_Vector (W'Range);\n+            type Z_Ptr is\n+               access all BLAS.Complex_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is access all  BLAS.Complex_Vector (Work'Range);\n+            type R_Work_Ptr is access all BLAS.Real_Vector (R_Work'Range);\n+\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_W is new Unchecked_Conversion (Address, W_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+            function Conv_R_Work is\n+               new Unchecked_Conversion (Address, R_Work_Ptr);\n+         begin\n+            cheevr (Job_Z, Rng, Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Fortran.Real (Vl), Fortran.Real (Vu),\n+                    Il, Iu, Fortran.Real (Abs_Tol), M,\n+                    Conv_W (W'Address).all,\n+                    Conv_Z (Z'Address).all, Ld_Z,\n+                    LAPACK.Integer_Vector (I_Supp_Z),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Conv_R_Work (R_Work'Address).all, LR_Work,\n+                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type A_Ptr is\n+              access all BLAS.Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            type W_Ptr is\n+              access all BLAS.Double_Precision_Vector (W'Range);\n+            type Z_Ptr is\n+              access all BLAS.Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is\n+               access all BLAS.Double_Complex_Vector (Work'Range);\n+            type R_Work_Ptr is\n+               access all BLAS.Double_Precision_Vector (R_Work'Range);\n+\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_W is new Unchecked_Conversion (Address, W_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+            function Conv_R_Work is\n+               new Unchecked_Conversion (Address, R_Work_Ptr);\n+         begin\n+            zheevr (Job_Z, Rng, Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Double_Precision (Vl), Double_Precision (Vu),\n+                    Il, Iu, Double_Precision (Abs_Tol), M,\n+                    Conv_W (W'Address).all,\n+                    Conv_Z (Z'Address).all, Ld_Z,\n+                    LAPACK.Integer_Vector (I_Supp_Z),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Conv_R_Work (R_Work'Address).all, LR_Work,\n+                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Complex_Matrix (A'Range (1), A'Range (2));\n+            DP_W : Double_Precision_Vector (W'Range);\n+            DP_Z : Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n+            DP_Work : Double_Complex_Vector (Work'Range);\n+            DP_R_Work : Double_Precision_Vector (R_Work'Range);\n+\n+         begin\n+            DP_A := To_Double_Complex (A);\n+\n+            zheevr (Job_Z, Rng, Uplo, N,\n+                    DP_A, Ld_A,\n+                    Double_Precision (Vl), Double_Precision (Vu),\n+                    Il, Iu, Double_Precision (Abs_Tol), M,\n+                    DP_W, DP_Z, Ld_Z,\n+                    LAPACK.Integer_Vector (I_Supp_Z),\n+                    DP_Work, L_Work,\n+                    DP_R_Work, LR_Work,\n+                    LAPACK.Integer_Vector (I_Work), LI_Work, Info);\n+\n+            A := To_Complex (DP_A);\n+            W := To_Real (DP_W);\n+            Z := To_Complex (DP_Z);\n+\n+            Work (1) := To_Complex (DP_Work (1));\n+            R_Work (1) := To_Real (DP_R_Work (1));\n+         end;\n+      end if;\n+   end heevr;\n+\n+   -----------\n+   -- steqr --\n+   -----------\n+\n+   procedure steqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Complex_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n+            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n+            type Z_Ptr is\n+               access all BLAS.Complex_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is\n+               access all BLAS.Real_Vector (Work'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            csteqr (Comp_Z, N,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Z (Z'Address).all,\n+                    Ld_Z,\n+                    Conv_Work (Work'Address).all,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type D_Ptr is access all Double_Precision_Vector (D'Range);\n+            type E_Ptr is access all Double_Precision_Vector (E'Range);\n+            type Z_Ptr is\n+               access all Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is\n+               access all Double_Precision_Vector (Work'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            zsteqr (Comp_Z, N,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Z (Z'Address).all,\n+                    Ld_Z,\n+                    Conv_Work (Work'Address).all,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_D    : Double_Precision_Vector (D'Range);\n+            DP_E    : Double_Precision_Vector (E'Range);\n+            DP_Z    : Double_Complex_Matrix (Z'Range (1), Z'Range (2));\n+            DP_Work : Double_Precision_Vector (Work'Range);\n+         begin\n+            DP_D := To_Double_Precision (D);\n+            DP_E := To_Double_Precision (E);\n+\n+            if Comp_Z.all = 'V' then\n+               DP_Z := To_Double_Complex (Z);\n+            end if;\n+\n+            zsteqr (Comp_Z, N, DP_D, DP_E, DP_Z, Ld_Z, DP_Work, Info);\n+\n+            D := To_Real (DP_D);\n+            E := To_Real (DP_E);\n+\n+            if Comp_Z.all /= 'N' then\n+               Z := To_Complex (DP_Z);\n+            end if;\n+         end;\n+      end if;\n+   end steqr;\n+\n+end System.Generic_Complex_LAPACK;"}, {"sha": "2597a902178f01b2d0800d9590f2ca712681bb66", "filename": "gcc/ada/s-gecola.ads", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecola.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gecola.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gecola.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,133 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      SYSTEM.GENERIC_COMPLEX_LAPACK                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package comment required ???\n+\n+with Ada.Numerics.Generic_Complex_Types;\n+generic\n+   type Real is digits <>;\n+   type Real_Vector is array (Integer range <>) of Real;\n+\n+   with package Complex_Types is new Ada.Numerics.Generic_Complex_Types (Real);\n+   use Complex_Types;\n+\n+   type Complex_Vector is array (Integer range <>) of Complex;\n+   type Complex_Matrix is array (Integer range <>, Integer range <>)\n+      of Complex;\n+package System.Generic_Complex_LAPACK is\n+   pragma Pure;\n+\n+   type Integer_Vector is array (Integer range <>) of Integer;\n+\n+   Upper : aliased constant Character := 'U';\n+   Lower : aliased constant Character := 'L';\n+\n+   --  LAPACK Computational Routines\n+\n+   --  getrf computes LU factorization of a general m-by-n matrix\n+\n+   procedure getrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Complex_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   --  getri computes inverse of an LU-factored square matrix,\n+   --  with multiple right-hand sides\n+\n+   procedure getri\n+     (N      : Natural;\n+      A      : in out Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Complex_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   --  getrs solves a system of linear equations with an LU-factored\n+   --  square matrix, with multiple right-hand sides\n+\n+   procedure getrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Complex_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Complex_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   --  heevr computes selected eigenvalues and, optionally,\n+   --  eigenvectors of a Hermitian matrix using the Relatively\n+   --  Robust Representations\n+\n+   procedure heevr\n+     (Job_Z    : access constant Character;\n+      Rng      : access constant Character;\n+      Uplo     : access constant Character;\n+      N        : Natural;\n+      A        : in out Complex_Matrix;\n+      Ld_A     : Positive;\n+      Vl, Vu   : Real := 0.0;\n+      Il, Iu   : Integer := 1;\n+      Abs_Tol  : Real := 0.0;\n+      M        : out Integer;\n+      W        : out Real_Vector;\n+      Z        : out Complex_Matrix;\n+      Ld_Z     : Positive;\n+      I_Supp_Z : out Integer_Vector;\n+      Work     : out Complex_Vector;\n+      L_Work   : Integer;\n+      R_Work   : out Real_Vector;\n+      LR_Work  : Integer;\n+      I_Work   : out Integer_Vector;\n+      LI_Work  : Integer;\n+      Info     : access Integer);\n+\n+   --  steqr computes all eigenvalues and eigenvectors of a symmetric or\n+   --  Hermitian matrix reduced to tridiagonal form (QR algorithm)\n+\n+   procedure steqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Complex_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer);\n+\n+end System.Generic_Complex_LAPACK;"}, {"sha": "810a167cf80453c19d454d61682e326d392f87c0", "filename": "gcc/ada/s-gerebl.adb", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerebl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerebl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerebl.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,313 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         SYSTEM.GENERIC_REAL_BLAS                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;        use Ada;\n+with Interfaces;                      use Interfaces;\n+with Interfaces.Fortran;              use Interfaces.Fortran;\n+with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+\n+package body System.Generic_Real_BLAS is\n+\n+   Is_Single : constant Boolean :=\n+                 Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n+                  and then Fortran.Real (Real'First) = Fortran.Real'First\n+                  and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n+\n+   Is_Double : constant Boolean :=\n+                 Real'Machine_Mantissa = Double_Precision'Machine_Mantissa\n+                  and then\n+                    Double_Precision (Real'First) = Double_Precision'First\n+                  and then\n+                    Double_Precision (Real'Last) = Double_Precision'Last;\n+\n+   --  Local subprograms\n+\n+   function To_Double_Precision (X : Real) return Double_Precision;\n+   pragma Inline_Always (To_Double_Precision);\n+\n+   function To_Real (X : Double_Precision) return Real;\n+   pragma Inline_Always (To_Real);\n+\n+   --  Instantiations\n+\n+   function To_Double_Precision is new\n+     Vector_Elementwise_Operation\n+       (X_Scalar      => Real,\n+        Result_Scalar => Double_Precision,\n+        X_Vector      => Real_Vector,\n+        Result_Vector => Double_Precision_Vector,\n+        Operation     => To_Double_Precision);\n+\n+   function To_Real is new\n+     Vector_Elementwise_Operation\n+       (X_Scalar      => Double_Precision,\n+        Result_Scalar => Real,\n+        X_Vector      => Double_Precision_Vector,\n+        Result_Vector => Real_Vector,\n+        Operation     => To_Real);\n+\n+   function To_Double_Precision is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Real,\n+        Result_Scalar => Double_Precision,\n+        X_Matrix      => Real_Matrix,\n+        Result_Matrix => Double_Precision_Matrix,\n+        Operation     => To_Double_Precision);\n+\n+   function To_Real is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Double_Precision,\n+        Result_Scalar => Real,\n+        X_Matrix      => Double_Precision_Matrix,\n+        Result_Matrix => Real_Matrix,\n+        Operation     => To_Real);\n+\n+   function To_Double_Precision (X : Real) return Double_Precision is\n+   begin\n+      return Double_Precision (X);\n+   end To_Double_Precision;\n+\n+   function To_Real (X : Double_Precision) return Real is\n+   begin\n+      return Real (X);\n+   end To_Real;\n+\n+   ---------\n+   -- dot --\n+   ---------\n+\n+   function dot\n+     (N     : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Real_Vector;\n+      Inc_Y : Integer := 1) return Real\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            type X_Ptr is access all BLAS.Real_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Real_Vector (Y'Range);\n+            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            return Real (sdot (N, Conv_X (X'Address).all, Inc_X,\n+                                  Conv_Y (Y'Address).all, Inc_Y));\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            type X_Ptr is access all BLAS.Double_Precision_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Double_Precision_Vector (Y'Range);\n+            function Conv_X is new Unchecked_Conversion (Address, X_Ptr);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            return Real (ddot (N, Conv_X (X'Address).all, Inc_X,\n+                                  Conv_Y (Y'Address).all, Inc_Y));\n+         end;\n+\n+      else\n+         return Real (ddot (N, To_Double_Precision (X), Inc_X,\n+                               To_Double_Precision (Y), Inc_Y));\n+      end if;\n+   end dot;\n+\n+   ----------\n+   -- gemm --\n+   ----------\n+\n+   procedure gemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Real := 1.0;\n+      A       : Real_Matrix;\n+      Ld_A    : Integer;\n+      B       : Real_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Real := 0.0;\n+      C       : in out Real_Matrix;\n+      Ld_C    : Integer)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            subtype B_Type is BLAS.Real_Matrix (B'Range (1), B'Range (2));\n+            type C_Ptr is\n+              access all BLAS.Real_Matrix (C'Range (1), C'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Real_Matrix, B_Type);\n+            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n+         begin\n+            sgemm (Trans_A, Trans_B, M, N, K, Fortran.Real (Alpha),\n+                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, Fortran.Real (Beta),\n+                   Conv_C (C'Address).all, Ld_C);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype A_Type is\n+               Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            subtype B_Type is\n+               Double_Precision_Matrix (B'Range (1), B'Range (2));\n+            type C_Ptr is\n+              access all Double_Precision_Matrix (C'Range (1), C'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Real_Matrix, B_Type);\n+            function Conv_C is new Unchecked_Conversion (Address, C_Ptr);\n+         begin\n+            dgemm (Trans_A, Trans_B, M, N, K, Double_Precision (Alpha),\n+                   Conv_A (A), Ld_A, Conv_B (B), Ld_B, Double_Precision (Beta),\n+                   Conv_C (C'Address).all, Ld_C);\n+         end;\n+\n+      else\n+         declare\n+            DP_C : Double_Precision_Matrix (C'Range (1), C'Range (2));\n+         begin\n+            if Beta /= 0.0 then\n+               DP_C := To_Double_Precision (C);\n+            end if;\n+\n+            dgemm (Trans_A, Trans_B, M, N, K, Double_Precision (Alpha),\n+                   To_Double_Precision (A), Ld_A,\n+                   To_Double_Precision (B), Ld_B, Double_Precision (Beta),\n+                   DP_C, Ld_C);\n+\n+            C := To_Real (DP_C);\n+         end;\n+      end if;\n+   end gemm;\n+\n+   ----------\n+   -- gemv --\n+   ----------\n+\n+   procedure gemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Real := 1.0;\n+      A     : Real_Matrix;\n+      Ld_A  : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;\n+      Beta  : Real := 0.0;\n+      Y     : in out Real_Vector;\n+      Inc_Y : Integer := 1)\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            subtype X_Type is BLAS.Real_Vector (X'Range);\n+            type Y_Ptr is access all BLAS.Real_Vector (Y'Range);\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            sgemv (Trans, M, N, Fortran.Real (Alpha),\n+                   Conv_A (A), Ld_A, Conv_X (X), Inc_X, Fortran.Real (Beta),\n+                   Conv_Y (Y'Address).all, Inc_Y);\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype A_Type is\n+               Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            subtype X_Type is Double_Precision_Vector (X'Range);\n+            type Y_Ptr is access all Double_Precision_Vector (Y'Range);\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n+            function Conv_Y is new Unchecked_Conversion (Address, Y_Ptr);\n+         begin\n+            dgemv (Trans, M, N, Double_Precision (Alpha),\n+                   Conv_A (A), Ld_A, Conv_X (X), Inc_X,\n+                   Double_Precision (Beta),\n+                   Conv_Y (Y'Address).all, Inc_Y);\n+         end;\n+\n+      else\n+         declare\n+            DP_Y : Double_Precision_Vector (Y'Range);\n+         begin\n+            if Beta /= 0.0 then\n+               DP_Y := To_Double_Precision (Y);\n+            end if;\n+\n+            dgemv (Trans, M, N, Double_Precision (Alpha),\n+                   To_Double_Precision (A), Ld_A,\n+                   To_Double_Precision (X), Inc_X, Double_Precision (Beta),\n+                   DP_Y, Inc_Y);\n+\n+            Y := To_Real (DP_Y);\n+         end;\n+      end if;\n+   end gemv;\n+\n+   ----------\n+   -- nrm2 --\n+   ----------\n+\n+   function nrm2\n+     (N     : Natural;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1) return Real\n+   is\n+   begin\n+      if Is_Single then\n+         declare\n+            subtype X_Type is BLAS.Real_Vector (X'Range);\n+            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n+         begin\n+            return Real (snrm2 (N, Conv_X (X), Inc_X));\n+         end;\n+\n+      elsif Is_Double then\n+         declare\n+            subtype X_Type is Double_Precision_Vector (X'Range);\n+            function Conv_X is new Unchecked_Conversion (Real_Vector, X_Type);\n+         begin\n+            return Real (dnrm2 (N, Conv_X (X), Inc_X));\n+         end;\n+\n+      else\n+         return Real (dnrm2 (N, To_Double_Precision (X), Inc_X));\n+      end if;\n+   end nrm2;\n+\n+end System.Generic_Real_BLAS;"}, {"sha": "adb62eb070e5768fd236c94f3ebf82b60fcc6dbc", "filename": "gcc/ada/s-gerebl.ads", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerebl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerebl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerebl.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,98 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                         SYSTEM.GENERIC_REAL_BLAS                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package comment required ???\n+\n+generic\n+   type Real is digits <>;\n+   type Real_Vector is array (Integer range <>) of Real;\n+   type Real_Matrix is array (Integer range <>, Integer range <>) of Real;\n+package System.Generic_Real_BLAS is\n+   pragma Pure;\n+\n+   --  Although BLAS support is only available for IEEE single and double\n+   --  compatible floating-point types, this unit will accept any type\n+   --  and apply conversions as necessary, with possible loss of\n+   --  precision and range.\n+\n+   No_Trans   : aliased constant Character := 'N';\n+   Trans      : aliased constant Character := 'T';\n+   Conj_Trans : aliased constant Character := 'C';\n+\n+   --  BLAS Level 1 Subprograms and Types\n+\n+   function dot\n+     (N     : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;\n+      Y     : Real_Vector;\n+      Inc_Y : Integer := 1) return Real;\n+\n+   function nrm2\n+     (N     : Natural;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1) return Real;\n+\n+   procedure gemv\n+     (Trans : access constant Character;\n+      M     : Natural := 0;\n+      N     : Natural := 0;\n+      Alpha : Real := 1.0;\n+      A     : Real_Matrix;\n+      Ld_A  : Positive;\n+      X     : Real_Vector;\n+      Inc_X : Integer := 1;  -- must be non-zero\n+      Beta  : Real := 0.0;\n+      Y     : in out Real_Vector;\n+      Inc_Y : Integer := 1); -- must be non-zero\n+\n+   --  BLAS Level 3\n+\n+   --  gemm   s, d, c, z  Matrix-matrix product of general matrices\n+\n+   procedure gemm\n+     (Trans_A : access constant Character;\n+      Trans_B : access constant Character;\n+      M       : Positive;\n+      N       : Positive;\n+      K       : Positive;\n+      Alpha   : Real := 1.0;\n+      A       : Real_Matrix;\n+      Ld_A    : Integer;\n+      B       : Real_Matrix;\n+      Ld_B    : Integer;\n+      Beta    : Real := 0.0;\n+      C       : in out Real_Matrix;\n+      Ld_C    : Integer);\n+\n+end System.Generic_Real_BLAS;"}, {"sha": "aa0e964ba784b7ea7bec124da5aa7e4f404236aa", "filename": "gcc/ada/s-gerela.adb", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerela.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerela.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerela.adb?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,566 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        SYSTEM.GENERIC_REAL_LAPACK                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;        use Ada;\n+with Interfaces;                      use Interfaces;\n+with Interfaces.Fortran;              use Interfaces.Fortran;\n+with Interfaces.Fortran.BLAS;         use Interfaces.Fortran.BLAS;\n+with Interfaces.Fortran.LAPACK;       use Interfaces.Fortran.LAPACK;\n+with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n+\n+package body System.Generic_Real_LAPACK is\n+\n+   Is_Real : constant Boolean :=\n+               Real'Machine_Mantissa = Fortran.Real'Machine_Mantissa\n+                and then Fortran.Real (Real'First) = Fortran.Real'First\n+                and then Fortran.Real (Real'Last) = Fortran.Real'Last;\n+\n+   Is_Double_Precision : constant Boolean :=\n+                           Real'Machine_Mantissa =\n+                                            Double_Precision'Machine_Mantissa\n+                            and then\n+                              Double_Precision (Real'First) =\n+                                            Double_Precision'First\n+                            and then\n+                              Double_Precision (Real'Last) =\n+                                            Double_Precision'Last;\n+\n+   --  Local subprograms\n+\n+   function To_Double_Precision (X : Real) return Double_Precision;\n+   pragma Inline_Always (To_Double_Precision);\n+\n+   function To_Real (X : Double_Precision) return Real;\n+   pragma Inline_Always (To_Real);\n+\n+   --  Instantiations\n+\n+   function To_Double_Precision is new\n+     Vector_Elementwise_Operation\n+       (X_Scalar      => Real,\n+        Result_Scalar => Double_Precision,\n+        X_Vector      => Real_Vector,\n+        Result_Vector => Double_Precision_Vector,\n+        Operation     => To_Double_Precision);\n+\n+   function To_Real is new\n+     Vector_Elementwise_Operation\n+       (X_Scalar      => Double_Precision,\n+        Result_Scalar => Real,\n+        X_Vector      => Double_Precision_Vector,\n+        Result_Vector => Real_Vector,\n+        Operation     => To_Real);\n+\n+   function To_Double_Precision is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Real,\n+        Result_Scalar => Double_Precision,\n+        X_Matrix      => Real_Matrix,\n+        Result_Matrix => Double_Precision_Matrix,\n+        Operation     => To_Double_Precision);\n+\n+   function To_Real is new\n+     Matrix_Elementwise_Operation\n+       (X_Scalar      => Double_Precision,\n+        Result_Scalar => Real,\n+        X_Matrix      => Double_Precision_Matrix,\n+        Result_Matrix => Real_Matrix,\n+        Operation     => To_Real);\n+\n+   function To_Double_Precision (X : Real) return Double_Precision is\n+   begin\n+      return Double_Precision (X);\n+   end To_Double_Precision;\n+\n+   function To_Real (X : Double_Precision) return Real is\n+   begin\n+      return Real (X);\n+   end To_Real;\n+\n+   -----------\n+   -- getrf --\n+   -----------\n+\n+   procedure getrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Real_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+         begin\n+            sgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv), Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type A_Ptr is\n+               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+         begin\n+            dgetrf (M, N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv), Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n+         begin\n+            DP_A := To_Double_Precision (A);\n+            dgetrf (M, N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv), Info);\n+            A := To_Real (DP_A);\n+         end;\n+      end if;\n+   end getrf;\n+\n+   -----------\n+   -- getri --\n+   -----------\n+\n+   procedure getri\n+     (N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            type Work_Ptr is\n+               access all BLAS.Real_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            sgetri (N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type A_Ptr is\n+               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            type Work_Ptr is\n+               access all Double_Precision_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            dgetri (N, Conv_A (A'Address).all, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            DP_Work : Double_Precision_Vector (Work'Range);\n+         begin\n+            DP_A := To_Double_Precision (A);\n+            dgetri (N, DP_A, Ld_A, LAPACK.Integer_Vector (I_Piv),\n+                    DP_Work, L_Work, Info);\n+            A := To_Real (DP_A);\n+            Work (1) := To_Real (DP_Work (1));\n+         end;\n+      end if;\n+   end getri;\n+\n+   -----------\n+   -- getrs --\n+   -----------\n+\n+   procedure getrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Real_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            subtype A_Type is BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            type B_Ptr is\n+               access all BLAS.Real_Matrix (B'Range (1), B'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n+         begin\n+            sgetrs (Trans, N, N_Rhs,\n+                    Conv_A (A), Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_B (B'Address).all, Ld_B,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            subtype A_Type is\n+               Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            type B_Ptr is\n+               access all Double_Precision_Matrix (B'Range (1), B'Range (2));\n+            function Conv_A is new Unchecked_Conversion (Real_Matrix, A_Type);\n+            function Conv_B is new Unchecked_Conversion (Address, B_Ptr);\n+         begin\n+            dgetrs (Trans, N, N_Rhs,\n+                    Conv_A (A), Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    Conv_B (B'Address).all, Ld_B,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            DP_B : Double_Precision_Matrix (B'Range (1), B'Range (2));\n+         begin\n+            DP_A := To_Double_Precision (A);\n+            DP_B := To_Double_Precision (B);\n+            dgetrs (Trans, N, N_Rhs,\n+                    DP_A, Ld_A,\n+                    LAPACK.Integer_Vector (I_Piv),\n+                    DP_B, Ld_B,\n+                    Info);\n+            B := To_Real (DP_B);\n+         end;\n+      end if;\n+   end getrs;\n+\n+   -----------\n+   -- orgtr --\n+   -----------\n+\n+   procedure orgtr\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      Tau    : in Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            subtype Tau_Type is BLAS.Real_Vector (Tau'Range);\n+            type Work_Ptr is\n+               access all BLAS.Real_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Tau is\n+               new Unchecked_Conversion (Real_Vector, Tau_Type);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            sorgtr (Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Conv_Tau (Tau),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type A_Ptr is\n+               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            subtype Tau_Type is Double_Precision_Vector (Tau'Range);\n+            type Work_Ptr is\n+               access all Double_Precision_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_Tau is\n+               new Unchecked_Conversion (Real_Vector, Tau_Type);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            dorgtr (Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Conv_Tau (Tau),\n+                    Conv_Work (Work'Address).all, L_Work,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A : Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            DP_Work : Double_Precision_Vector (Work'Range);\n+            DP_Tau  : Double_Precision_Vector (Tau'Range);\n+         begin\n+            DP_A := To_Double_Precision (A);\n+            DP_Tau := To_Double_Precision (Tau);\n+            dorgtr (Uplo, N, DP_A, Ld_A, DP_Tau, DP_Work, L_Work, Info);\n+            A := To_Real (DP_A);\n+            Work (1) := To_Real (DP_Work (1));\n+         end;\n+      end if;\n+   end orgtr;\n+\n+   -----------\n+   -- steqr --\n+   -----------\n+\n+   procedure steqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Real_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n+            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n+            type Z_Ptr is\n+               access all BLAS.Real_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is\n+               access all BLAS.Real_Vector (Work'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            ssteqr (Comp_Z, N,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Z (Z'Address).all,\n+                    Ld_Z,\n+                    Conv_Work (Work'Address).all,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type D_Ptr is access all Double_Precision_Vector (D'Range);\n+            type E_Ptr is access all Double_Precision_Vector (E'Range);\n+            type Z_Ptr is\n+               access all Double_Precision_Matrix (Z'Range (1), Z'Range (2));\n+            type Work_Ptr is\n+               access all Double_Precision_Vector (Work'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Z is new Unchecked_Conversion (Address, Z_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            dsteqr (Comp_Z, N,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Z (Z'Address).all,\n+                    Ld_Z,\n+                    Conv_Work (Work'Address).all,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_D    : Double_Precision_Vector (D'Range);\n+            DP_E    : Double_Precision_Vector (E'Range);\n+            DP_Z    : Double_Precision_Matrix (Z'Range (1), Z'Range (2));\n+            DP_Work : Double_Precision_Vector (Work'Range);\n+         begin\n+            DP_D := To_Double_Precision (D);\n+            DP_E := To_Double_Precision (E);\n+\n+            if Comp_Z.all = 'V' then\n+               DP_Z := To_Double_Precision (Z);\n+            end if;\n+\n+            dsteqr (Comp_Z, N, DP_D, DP_E, DP_Z, Ld_Z, DP_Work, Info);\n+\n+            D := To_Real (DP_D);\n+            E := To_Real (DP_E);\n+            Z := To_Real (DP_Z);\n+         end;\n+      end if;\n+   end steqr;\n+\n+   -----------\n+   -- sterf --\n+   -----------\n+\n+   procedure sterf\n+     (N    : Natural;\n+      D    : in out Real_Vector;\n+      E    : in out Real_Vector;\n+      Info : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n+            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+         begin\n+            ssterf (N, Conv_D (D'Address).all, Conv_E (E'Address).all, Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type D_Ptr is access all Double_Precision_Vector (D'Range);\n+            type E_Ptr is access all Double_Precision_Vector (E'Range);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+         begin\n+            dsterf (N, Conv_D (D'Address).all, Conv_E (E'Address).all, Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_D    : Double_Precision_Vector (D'Range);\n+            DP_E    : Double_Precision_Vector (E'Range);\n+\n+         begin\n+            DP_D := To_Double_Precision (D);\n+            DP_E := To_Double_Precision (E);\n+\n+            dsterf (N, DP_D, DP_E, Info);\n+\n+            D := To_Real (DP_D);\n+            E := To_Real (DP_E);\n+         end;\n+      end if;\n+   end sterf;\n+\n+   -----------\n+   -- sytrd --\n+   -----------\n+\n+   procedure sytrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Real_Vector;\n+      E      : out Real_Vector;\n+      Tau    : out Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer)\n+   is\n+   begin\n+      if Is_Real then\n+         declare\n+            type A_Ptr is\n+               access all BLAS.Real_Matrix (A'Range (1), A'Range (2));\n+            type D_Ptr is access all BLAS.Real_Vector (D'Range);\n+            type E_Ptr is access all BLAS.Real_Vector (E'Range);\n+            type Tau_Ptr is access all BLAS.Real_Vector (Tau'Range);\n+            type Work_Ptr is\n+               access all BLAS.Real_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Tau is new Unchecked_Conversion (Address, Tau_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            ssytrd (Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Tau (Tau'Address).all,\n+                    Conv_Work (Work'Address).all,\n+                    L_Work,\n+                    Info);\n+         end;\n+\n+      elsif Is_Double_Precision then\n+         declare\n+            type A_Ptr is\n+               access all Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            type D_Ptr is access all Double_Precision_Vector (D'Range);\n+            type E_Ptr is access all Double_Precision_Vector (E'Range);\n+            type Tau_Ptr is access all Double_Precision_Vector (Tau'Range);\n+            type Work_Ptr is\n+               access all Double_Precision_Vector (Work'Range);\n+            function Conv_A is new Unchecked_Conversion (Address, A_Ptr);\n+            function Conv_D is new Unchecked_Conversion (Address, D_Ptr);\n+            function Conv_E is new Unchecked_Conversion (Address, E_Ptr);\n+            function Conv_Tau is new Unchecked_Conversion (Address, Tau_Ptr);\n+            function Conv_Work is new Unchecked_Conversion (Address, Work_Ptr);\n+         begin\n+            dsytrd (Uplo, N,\n+                    Conv_A (A'Address).all, Ld_A,\n+                    Conv_D (D'Address).all,\n+                    Conv_E (E'Address).all,\n+                    Conv_Tau (Tau'Address).all,\n+                    Conv_Work (Work'Address).all,\n+                    L_Work,\n+                    Info);\n+         end;\n+\n+      else\n+         declare\n+            DP_A    : Double_Precision_Matrix (A'Range (1), A'Range (2));\n+            DP_D    : Double_Precision_Vector (D'Range);\n+            DP_E    : Double_Precision_Vector (E'Range);\n+            DP_Tau  : Double_Precision_Vector (Tau'Range);\n+            DP_Work : Double_Precision_Vector (Work'Range);\n+         begin\n+            DP_A := To_Double_Precision (A);\n+\n+            dsytrd (Uplo, N, DP_A, Ld_A, DP_D, DP_E, DP_Tau,\n+                    DP_Work, L_Work, Info);\n+\n+            if L_Work /= -1 then\n+               A := To_Real (DP_A);\n+               D := To_Real (DP_D);\n+               E := To_Real (DP_E);\n+               Tau := To_Real (DP_Tau);\n+            end if;\n+\n+            Work (1) := To_Real (DP_Work (1));\n+         end;\n+      end if;\n+   end sytrd;\n+\n+end System.Generic_Real_LAPACK;"}, {"sha": "c9f29f2f5e3fe8213aa25ac4e7006ae5c3b5056b", "filename": "gcc/ada/s-gerela.ads", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerela.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815f44d0cd91db97ee2793bcdf007f498f78f8aa/gcc%2Fada%2Fs-gerela.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gerela.ads?ref=815f44d0cd91db97ee2793bcdf007f498f78f8aa", "patch": "@@ -0,0 +1,130 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        SYSTEM.GENERIC_REAL_LAPACK                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package comment required ???\n+\n+generic\n+   type Real is digits <>;\n+   type Real_Vector is array (Integer range <>) of Real;\n+   type Real_Matrix is array (Integer range <>, Integer range <>) of Real;\n+package System.Generic_Real_LAPACK is\n+   pragma Pure;\n+\n+   type Integer_Vector is array (Integer range <>) of Integer;\n+\n+   Upper : aliased constant Character := 'U';\n+   Lower : aliased constant Character := 'L';\n+\n+   --  LAPACK Computational Routines\n+\n+   --  gerfs  Refines the solution of a system of linear equations with\n+   --         a general matrix and estimates its error\n+   --  getrf  Computes LU factorization of a general m-by-n matrix\n+   --  getri  Computes inverse of an LU-factored general matrix\n+   --         square matrix, with multiple right-hand sides\n+   --  getrs  Solves a system of linear equations with an LU-factored\n+   --         square matrix, with multiple right-hand sides\n+   --  orgtr  Generates the Float orthogonal matrix Q determined by sytrd\n+   --  steqr  Computes all eigenvalues and eigenvectors of a symmetric or\n+   --         Hermitian matrix reduced to tridiagonal form (QR algorithm)\n+   --  sterf  Computes all eigenvalues of a Float symmetric\n+   --         tridiagonal matrix using QR algorithm\n+   --  sytrd  Reduces a Float symmetric matrix to tridiagonal form\n+\n+   procedure getrf\n+     (M     : Natural;\n+      N     : Natural;\n+      A     : in out Real_Matrix;\n+      Ld_A  : Positive;\n+      I_Piv : out Integer_Vector;\n+      Info  : access Integer);\n+\n+   procedure getri\n+     (N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      Work   : in out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure getrs\n+     (Trans  : access constant Character;\n+      N      : Natural;\n+      N_Rhs  : Natural;\n+      A      : Real_Matrix;\n+      Ld_A   : Positive;\n+      I_Piv  : Integer_Vector;\n+      B      : in out Real_Matrix;\n+      Ld_B   : Positive;\n+      Info   : access Integer);\n+\n+   procedure orgtr\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      Tau    : in Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+   procedure sterf\n+     (N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Info   : access Integer);\n+\n+   procedure steqr\n+     (Comp_Z : access constant Character;\n+      N      : Natural;\n+      D      : in out Real_Vector;\n+      E      : in out Real_Vector;\n+      Z      : in out Real_Matrix;\n+      Ld_Z   : Positive;\n+      Work   : out Real_Vector;\n+      Info   : access Integer);\n+\n+   procedure sytrd\n+     (Uplo   : access constant Character;\n+      N      : Natural;\n+      A      : in out Real_Matrix;\n+      Ld_A   : Positive;\n+      D      : out Real_Vector;\n+      E      : out Real_Vector;\n+      Tau    : out Real_Vector;\n+      Work   : out Real_Vector;\n+      L_Work : Integer;\n+      Info   : access Integer);\n+\n+end System.Generic_Real_LAPACK;"}]}