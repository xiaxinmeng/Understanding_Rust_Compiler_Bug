{"sha": "9b75f56d4b7951c60a656396dddd4a65787b95bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3NWY1NmQ0Yjc5NTFjNjBhNjU2Mzk2ZGRkZDRhNjU3ODdiOTViYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T10:29:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T10:29:31Z"}, "message": "Apply maximum nunits for BB SLP\n\nThe BB vectoriser picked vector types in the same way as the loop\nvectoriser: it picked a vector mode/size for the region and then\nbased all the vector types off that choice.  This meant we could\nend up trying to use vector types that had too many elements for\nthe group size.\n\nThe main part of this patch is therefore about passing the SLP\ngroup size down to routines like get_vectype_for_scalar_type and\nensuring that each vector type in the SLP tree is chosen wrt the\ngroup size.  That part in itself is pretty easy and mechanical.\n\nThe main warts are:\n\n(1) We normally pick a STMT_VINFO_VECTYPE for data references at an\n    early stage (vect_analyze_data_refs).  However, nothing in the\n    BB vectoriser relied on this, or on the min_vf calculated from it.\n    I couldn't see anything other than vect_recog_bool_pattern that\n    tried to access the vector type before the SLP tree is built.\n\n(2) It's possible for the same statement to be used in groups of\n    different sizes.  Taking the group size into account meant that\n    we could try to pick different vector types for the same statement.\n\n    This problem should go away with the move to doing everything on\n    SLP trees, where presumably we would attach the vector type to the\n    SLP node rather than the stmt_vec_info.  Until then, the patch just\n    uses a first-come, first-served approach.\n\n(3) A similar problem exists for grouped data references, where\n    different statements in the same dataref group could be used\n    in SLP nodes that have different group sizes.  The patch copes\n    with that by making sure that all vector types in a dataref\n    group remain consistent.\n\nThe patch means that:\n\n    void\n    f (int *x, short *y)\n    {\n      x[0] += y[0];\n      x[1] += y[1];\n      x[2] += y[2];\n      x[3] += y[3];\n    }\n\nnow produces:\n\n        ldr     q0, [x0]\n        ldr     d1, [x1]\n        saddw   v0.4s, v0.4s, v1.4h\n        str     q0, [x0]\n        ret\n\ninstead of:\n\n        ldrsh   w2, [x1]\n        ldrsh   w3, [x1, 2]\n        fmov    s0, w2\n        ldrsh   w2, [x1, 4]\n        ldrsh   w1, [x1, 6]\n        ins     v0.s[1], w3\n        ldr     q1, [x0]\n        ins     v0.s[2], w2\n        ins     v0.s[3], w1\n        add     v0.4s, v0.4s, v1.4s\n        str     q0, [x0]\n        ret\n\nUnfortunately it also means we start to vectorise\ngcc.target/i386/pr84101.c for -m32.  That seems like a target\ncost issue though; see PR92265 for details.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Take an\n\toptional maximum nunits.\n\t(get_vectype_for_scalar_type): Likewise.  Also declare a form that\n\ttakes an slp_tree.\n\t(get_mask_type_for_scalar_type): Take an optional slp_tree.\n\t(vect_get_mask_type_for_stmt): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Don't store\n\tthe vector type in STMT_VINFO_VECTYPE for BB vectorization.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Use\n\tvect_get_vector_types_for_stmt instead of STMT_VINFO_VECTYPE\n\tto get an assumed vector type for data references.\n\t* tree-vect-slp.c (vect_update_shared_vectype): New function.\n\t(vect_update_all_shared_vectypes): Likewise.\n\t(vect_build_slp_tree_1): Pass the group size to\n\tvect_get_vector_types_for_stmt.  Use vect_update_shared_vectype\n\tfor BB vectorization.\n\t(vect_build_slp_tree_2): Call vect_update_all_shared_vectypes\n\tbefore building the vectof from scalars.\n\t(vect_analyze_slp_instance): Pass the group size to\n\tget_vectype_for_scalar_type.\n\t(vect_slp_analyze_node_operations_1): Don't recompute the vector\n\ttypes for BB vectorization here; just handle the case in which\n\twe deferred the choice for booleans.\n\t(vect_get_constant_vectors): Pass the slp_tree to\n\tget_vectype_for_scalar_type.\n\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_comparison): Likewise.\n\t(vect_is_simple_cond): Take the slp_tree as argument and\n\tpass it to get_vectype_for_scalar_type.\n\t(vectorizable_condition): Update call accordingly.\n\t(get_vectype_for_scalar_type): Take a group_size argument.\n\tFor BB vectorization, limit the the vector to that number\n\tof elements.  Also define an overload that takes an slp_tree.\n\t(get_mask_type_for_scalar_type): Add an slp_tree argument and\n\tpass it to get_vectype_for_scalar_type.\n\t(vect_get_vector_types_for_stmt): Add a group_size argument\n\tand pass it to get_vectype_for_scalar_type.  Don't use the\n\tcached vector type for BB vectorization if a group size is given.\n\tHandle data references in that case.\n\t(vect_get_mask_type_for_stmt): Take an slp_tree argument and\n\tpass it to get_mask_type_for_scalar_type.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-4.c: Expect the block to be vectorized\n\twith -fno-vect-cost-model.\n\t* gcc.dg/vect/bb-slp-bool-1.c: New test.\n\t* gcc.target/aarch64/vect_mixed_sizes_14.c: Likewise.\n\t* gcc.target/i386/pr84101.c: XFAIL for -m32.\n\nFrom-SVN: r278334", "tree": {"sha": "5908e1c542d7e66687f8d2141198f3323e3a51eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5908e1c542d7e66687f8d2141198f3323e3a51eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b75f56d4b7951c60a656396dddd4a65787b95bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b75f56d4b7951c60a656396dddd4a65787b95bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b75f56d4b7951c60a656396dddd4a65787b95bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b75f56d4b7951c60a656396dddd4a65787b95bc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23ff8c05804c2d3fc6e9179d2e9c2940ae53d592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ff8c05804c2d3fc6e9179d2e9c2940ae53d592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23ff8c05804c2d3fc6e9179d2e9c2940ae53d592"}], "stats": {"total": 423, "additions": 359, "deletions": 64}, "files": [{"sha": "a6333b11c572de4ec028092ed9b228660499d27c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -1,3 +1,52 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Take an\n+\toptional maximum nunits.\n+\t(get_vectype_for_scalar_type): Likewise.  Also declare a form that\n+\ttakes an slp_tree.\n+\t(get_mask_type_for_scalar_type): Take an optional slp_tree.\n+\t(vect_get_mask_type_for_stmt): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Don't store\n+\tthe vector type in STMT_VINFO_VECTYPE for BB vectorization.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Use\n+\tvect_get_vector_types_for_stmt instead of STMT_VINFO_VECTYPE\n+\tto get an assumed vector type for data references.\n+\t* tree-vect-slp.c (vect_update_shared_vectype): New function.\n+\t(vect_update_all_shared_vectypes): Likewise.\n+\t(vect_build_slp_tree_1): Pass the group size to\n+\tvect_get_vector_types_for_stmt.  Use vect_update_shared_vectype\n+\tfor BB vectorization.\n+\t(vect_build_slp_tree_2): Call vect_update_all_shared_vectypes\n+\tbefore building the vectof from scalars.\n+\t(vect_analyze_slp_instance): Pass the group size to\n+\tget_vectype_for_scalar_type.\n+\t(vect_slp_analyze_node_operations_1): Don't recompute the vector\n+\ttypes for BB vectorization here; just handle the case in which\n+\twe deferred the choice for booleans.\n+\t(vect_get_constant_vectors): Pass the slp_tree to\n+\tget_vectype_for_scalar_type.\n+\t* tree-vect-stmts.c (vect_prologue_cost_for_slp_op): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\t(vect_is_simple_cond): Take the slp_tree as argument and\n+\tpass it to get_vectype_for_scalar_type.\n+\t(vectorizable_condition): Update call accordingly.\n+\t(get_vectype_for_scalar_type): Take a group_size argument.\n+\tFor BB vectorization, limit the the vector to that number\n+\tof elements.  Also define an overload that takes an slp_tree.\n+\t(get_mask_type_for_scalar_type): Add an slp_tree argument and\n+\tpass it to get_vectype_for_scalar_type.\n+\t(vect_get_vector_types_for_stmt): Add a group_size argument\n+\tand pass it to get_vectype_for_scalar_type.  Don't use the\n+\tcached vector type for BB vectorization if a group size is given.\n+\tHandle data references in that case.\n+\t(vect_get_mask_type_for_stmt): Take an slp_tree argument and\n+\tpass it to get_mask_type_for_scalar_type.\n+\n 2019-11-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.h (do_estimate_edge_time): Add nonspec_time"}, {"sha": "daac2708d7fb9e5786a7079d91979ae1cee0a2b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -1,3 +1,11 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/bb-slp-4.c: Expect the block to be vectorized\n+\twith -fno-vect-cost-model.\n+\t* gcc.dg/vect/bb-slp-bool-1.c: New test.\n+\t* gcc.target/aarch64/vect_mixed_sizes_14.c: Likewise.\n+\t* gcc.target/i386/pr84101.c: XFAIL for -m32.\n+\n 2019-11-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c2x-attr-deprecated-4.c, gcc.dg/c2x-attr-fallthrough-4.c,"}, {"sha": "293b0e3405e850acfe30d71725fb591c9498ba18", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-4.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -38,5 +38,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 0 \"slp2\" } } */\n-  \n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "bf39b21b4e1ab6c13fa47deb7f54047783fd9f35", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-bool-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-bool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-bool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-bool-1.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -0,0 +1,44 @@\n+#include \"tree-vect.h\"\n+\n+void __attribute__ ((noipa))\n+f1 (_Bool *x, unsigned short *y)\n+{\n+  x[0] = (y[0] == 1);\n+  x[1] = (y[1] == 1);\n+}\n+\n+void __attribute__ ((noipa))\n+f2 (_Bool *x, unsigned short *y)\n+{\n+  x[0] = (y[0] == 1);\n+  x[1] = (y[1] == 1);\n+  x[2] = (y[2] == 1);\n+  x[3] = (y[3] == 1);\n+  x[4] = (y[4] == 1);\n+  x[5] = (y[5] == 1);\n+  x[6] = (y[6] == 1);\n+  x[7] = (y[7] == 1);\n+}\n+\n+_Bool x[8];\n+unsigned short y[8] = { 11, 1, 9, 5, 1, 44, 1, 1 };\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  f1 (x, y);\n+\n+  if (x[0] || !x[1])\n+    __builtin_abort ();\n+\n+  x[1] = 0;\n+\n+  f2 (x, y);\n+\n+  if (x[0] || !x[1] || x[2] | x[3] || !x[4] || x[5] || !x[6] || !x[7])\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "00c90e4efdbddf3417cf1e84f6c6f8df8b9bdd9e", "filename": "gcc/testsuite/gcc.target/aarch64/vect_mixed_sizes_14.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_mixed_sizes_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_mixed_sizes_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect_mixed_sizes_14.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** foo:\n+** (\n+**\tldr\td([0-9]+), \\[x1\\]\n+**\tldr\tq([0-9]+), \\[x0\\]\n+**\tsaddw\tv([0-9]+)\\.4s, v\\2\\.4s, v\\1\\.4h\n+**\tstr\tq\\3, \\[x0\\]\n+** |\n+**\tldr\tq([0-9]+), \\[x0\\]\n+**\tldr\td([0-9]+), \\[x1\\]\n+**\tsaddw\tv([0-9]+)\\.4s, v\\4\\.4s, v\\5\\.4h\n+**\tstr\tq\\6, \\[x0\\]\n+** )\n+**\tret\n+*/\n+void\n+foo (int *x, short *y)\n+{\n+  x[0] += y[0];\n+  x[1] += y[1];\n+  x[2] += y[2];\n+  x[3] += y[3];\n+}"}, {"sha": "65117f1dc08c96c2118688290f974b4ab2c53ba0", "filename": "gcc/testsuite/gcc.target/i386/pr84101.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -18,4 +18,5 @@ uint64_pair_t pair(int num)\n   return p ;\n }\n \n-/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp2\" } } */\n+/* See PR92266 for the XFAIL.  */\n+/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp2\" { xfail ilp32 } } } */"}, {"sha": "87973b214532f834d3b4b1de4251f431da41f3a2", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -4368,9 +4368,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n \n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n-      STMT_VINFO_VECTYPE (stmt_info)\n-\t= get_vectype_for_scalar_type (vinfo, scalar_type);\n-      if (!STMT_VINFO_VECTYPE (stmt_info))\n+      tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+      if (!vectype)\n         {\n           if (dump_enabled_p ())\n             {\n@@ -4403,14 +4402,19 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"got vectype for stmt: %G%T\\n\",\n-\t\t\t     stmt_info->stmt, STMT_VINFO_VECTYPE (stmt_info));\n+\t\t\t     stmt_info->stmt, vectype);\n \t}\n \n       /* Adjust the minimal vectorization factor according to the\n \t vector type.  */\n-      vf = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+      vf = TYPE_VECTOR_SUBPARTS (vectype);\n       *min_vf = upper_bound (*min_vf, vf);\n \n+      /* Leave the BB vectorizer to pick the vector type later, based on\n+\t the final dataref group size and SLP node size.  */\n+      if (is_a <loop_vec_info> (vinfo))\n+\tSTMT_VINFO_VECTYPE (stmt_info) = vectype;\n+\n       if (gatherscatter != SG_NONE)\n \t{\n \t  gather_scatter_info gs_info;"}, {"sha": "e4cfe8581636d5262763eb777409edef05a161f4", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -4153,9 +4153,10 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t   && STMT_VINFO_DATA_REF (stmt_vinfo))\n     {\n       stmt_vec_info pattern_stmt_info;\n-      vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n-      gcc_assert (vectype != NULL_TREE);\n-      if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n+      tree nunits_vectype;\n+      if (!vect_get_vector_types_for_stmt (stmt_vinfo, &vectype,\n+\t\t\t\t\t   &nunits_vectype)\n+\t  || !VECTOR_MODE_P (TYPE_MODE (vectype)))\n \treturn NULL;\n \n       if (check_bool_pattern (var, vinfo, bool_stmts))"}, {"sha": "e5a707826325e8737ec903dfd31a4f7399e3e9de", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 92, "deletions": 21, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -607,6 +607,77 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   return 0;\n }\n \n+/* Try to assign vector type VECTYPE to STMT_INFO for BB vectorization.\n+   Return true if we can, meaning that this choice doesn't conflict with\n+   existing SLP nodes that use STMT_INFO.  */\n+\n+static bool\n+vect_update_shared_vectype (stmt_vec_info stmt_info, tree vectype)\n+{\n+  tree old_vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  if (old_vectype && useless_type_conversion_p (vectype, old_vectype))\n+    return true;\n+\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n+    {\n+      /* We maintain the invariant that if any statement in the group is\n+\t used, all other members of the group have the same vector type.  */\n+      stmt_vec_info first_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      stmt_vec_info member_info = first_info;\n+      for (; member_info; member_info = DR_GROUP_NEXT_ELEMENT (member_info))\n+\tif (STMT_VINFO_NUM_SLP_USES (member_info) > 0\n+\t    || is_pattern_stmt_p (member_info))\n+\t  break;\n+\n+      if (!member_info)\n+\t{\n+\t  for (member_info = first_info; member_info;\n+\t       member_info = DR_GROUP_NEXT_ELEMENT (member_info))\n+\t    STMT_VINFO_VECTYPE (member_info) = vectype;\n+\t  return true;\n+\t}\n+    }\n+  else if (STMT_VINFO_NUM_SLP_USES (stmt_info) == 0\n+\t   && !is_pattern_stmt_p (stmt_info))\n+    {\n+      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n+      return true;\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t       \"Build SLP failed: incompatible vector\"\n+\t\t       \" types for: %G\", stmt_info->stmt);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"    old vector type: %T\\n\", old_vectype);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"    new vector type: %T\\n\", vectype);\n+    }\n+  return false;\n+}\n+\n+/* Try to infer and assign a vector type to all the statements in STMTS.\n+   Used only for BB vectorization.  */\n+\n+static bool\n+vect_update_all_shared_vectypes (vec<stmt_vec_info> stmts)\n+{\n+  tree vectype, nunits_vectype;\n+  if (!vect_get_vector_types_for_stmt (stmts[0], &vectype,\n+\t\t\t\t       &nunits_vectype, stmts.length ()))\n+    return false;\n+\n+  stmt_vec_info stmt_info;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n+    if (!vect_update_shared_vectype (stmt_info, vectype))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Return true if call statements CALL1 and CALL2 are similar enough\n    to be combined into the same SLP group.  */\n \n@@ -753,6 +824,7 @@ vect_build_slp_tree_1 (unsigned char *swap,\n   stmt_vec_info stmt_info;\n   FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n     {\n+      vec_info *vinfo = stmt_info->vinfo;\n       gimple *stmt = stmt_info->stmt;\n       swap[i] = 0;\n       matches[i] = false;\n@@ -786,7 +858,7 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \n       tree nunits_vectype;\n       if (!vect_get_vector_types_for_stmt (stmt_info, &vectype,\n-\t\t\t\t\t   &nunits_vectype)\n+\t\t\t\t\t   &nunits_vectype, group_size)\n \t  || (nunits_vectype\n \t      && !vect_record_max_nunits (stmt_info, group_size,\n \t\t\t\t\t  nunits_vectype, max_nunits)))\n@@ -798,6 +870,10 @@ vect_build_slp_tree_1 (unsigned char *swap,\n \n       gcc_assert (vectype);\n \n+      if (is_a <bb_vec_info> (vinfo)\n+\t  && !vect_update_shared_vectype (stmt_info, vectype))\n+\tcontinue;\n+\n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  rhs_code = CALL_EXPR;\n@@ -1336,7 +1412,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n \t\tif (SLP_TREE_DEF_TYPE (grandchild) != vect_external_def)\n \t\t  break;\n-\t      if (!grandchild)\n+\t      if (!grandchild\n+\t\t  && vect_update_all_shared_vectypes (oprnd_info->def_stmts))\n \t\t{\n \t\t  /* Roll back.  */\n \t\t  this_tree_size = old_tree_size;\n@@ -1377,7 +1454,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t     do extra work to cancel the pattern so the uses see the\n \t     scalar version.  */\n \t  && !is_pattern_stmt_p (stmt_info)\n-\t  && !oprnd_info->any_pattern)\n+\t  && !oprnd_info->any_pattern\n+\t  && vect_update_all_shared_vectypes (oprnd_info->def_stmts))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1474,7 +1552,9 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n \t\t    if (SLP_TREE_DEF_TYPE (grandchild) != vect_external_def)\n \t\t      break;\n-\t\t  if (!grandchild)\n+\t\t  if (!grandchild\n+\t\t      && (vect_update_all_shared_vectypes\n+\t\t\t  (oprnd_info->def_stmts)))\n \t\t    {\n \t\t      /* Roll back.  */\n \t\t      this_tree_size = old_tree_size;\n@@ -2010,8 +2090,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       scalar_type = TREE_TYPE (DR_REF (dr));\n-      vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n       group_size = DR_GROUP_SIZE (stmt_info);\n+      vectype = get_vectype_for_scalar_type (vinfo, scalar_type, group_size);\n     }\n   else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n@@ -2650,22 +2730,13 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n      Memory accesses already got their vector type assigned\n      in vect_analyze_data_refs.  */\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  if (bb_vinfo\n-      && ! STMT_VINFO_DATA_REF (stmt_info))\n+  if (bb_vinfo && STMT_VINFO_VECTYPE (stmt_info) == boolean_type_node)\n     {\n-      tree vectype, nunits_vectype;\n-      if (!vect_get_vector_types_for_stmt (stmt_info, &vectype,\n-\t\t\t\t\t   &nunits_vectype))\n-\t/* We checked this when building the node.  */\n-\tgcc_unreachable ();\n-      if (vectype == boolean_type_node)\n-\t{\n-\t  vectype = vect_get_mask_type_for_stmt (stmt_info);\n-\t  if (!vectype)\n-\t    /* vect_get_mask_type_for_stmt has already explained the\n-\t       failure.  */\n-\t    return false;\n-\t}\n+      tree vectype = vect_get_mask_type_for_stmt (stmt_info, node);\n+      if (!vectype)\n+\t/* vect_get_mask_type_for_stmt has already explained the\n+\t   failure.  */\n+\treturn false;\n \n       stmt_vec_info sstmt_info;\n       unsigned int i;\n@@ -3594,7 +3665,7 @@ vect_get_constant_vectors (slp_tree op_node, slp_tree slp_node,\n       && vect_mask_constant_operand_p (stmt_vinfo))\n     vector_type = truth_type_for (stmt_vectype);\n   else\n-    vector_type = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op));\n+    vector_type = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op), op_node);\n \n   /* ???  For lane-reducing ops we should also have the required number\n      of vector stmts initialized rather than second-guessing here.  */"}, {"sha": "f76dff602214773c1cc4ade5a2c0940bd6fdafbf", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 119, "deletions": 28, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -799,7 +799,7 @@ vect_prologue_cost_for_slp_op (slp_tree node, stmt_vec_info stmt_info,\n   /* Without looking at the actual initializer a vector of\n      constants can be implemented as load from the constant pool.\n      When all elements are the same we can use a splat.  */\n-  tree vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op));\n+  tree vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op), node);\n   unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n   unsigned num_vects_to_check;\n   unsigned HOST_WIDE_INT const_nunits;\n@@ -3298,7 +3298,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* If all arguments are external or constant defs, infer the vector type\n      from the scalar type.  */\n   if (!vectype_in)\n-    vectype_in = get_vectype_for_scalar_type (vinfo, rhs_type);\n+    vectype_in = get_vectype_for_scalar_type (vinfo, rhs_type, slp_node);\n   if (vec_stmt)\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n@@ -4087,7 +4087,8 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n \t&& bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n       {\n \ttree arg_type = TREE_TYPE (gimple_call_arg (stmt, i));\n-\targinfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type);\n+\targinfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type,\n+\t\t\t\t\t\t\t  slp_node);\n \tif (arginfo[i].vectype == NULL\n \t    || (simd_clone_subparts (arginfo[i].vectype)\n \t\t> bestn->simdclone->simdlen))\n@@ -4803,7 +4804,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* If op0 is an external or constant def, infer the vector type\n      from the scalar type.  */\n   if (!vectype_in)\n-    vectype_in = get_vectype_for_scalar_type (vinfo, rhs_type);\n+    vectype_in = get_vectype_for_scalar_type (vinfo, rhs_type, slp_node);\n   if (vec_stmt)\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n@@ -5604,7 +5605,7 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* If op0 is an external or constant def, infer the vector type\n      from the scalar type.  */\n   if (!vectype)\n-    vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op0));\n+    vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op0), slp_node);\n   if (vec_stmt)\n     gcc_assert (vectype);\n   if (!vectype)\n@@ -5703,7 +5704,8 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n                          \"vector/vector shift/rotate found.\\n\");\n \n       if (!op1_vectype)\n-\top1_vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op1));\n+\top1_vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op1),\n+\t\t\t\t\t\t   slp_node);\n       incompatible_op1_vectype_p\n \t= (op1_vectype == NULL_TREE\n \t   || maybe_ne (TYPE_VECTOR_SUBPARTS (op1_vectype),\n@@ -6051,7 +6053,8 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  vectype = vectype_out;\n \t}\n       else\n-\tvectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op0));\n+\tvectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op0),\n+\t\t\t\t\t       slp_node);\n     }\n   if (vec_stmt)\n     gcc_assert (vectype);\n@@ -9794,7 +9797,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, vec_info *vinfo,\n+vect_is_simple_cond (tree cond, vec_info *vinfo, slp_tree slp_node,\n \t\t     tree *comp_vectype, enum vect_def_type *dts,\n \t\t     tree vectype)\n {\n@@ -9858,7 +9861,8 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \tscalar_type = build_nonstandard_integer_type\n \t  (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype))),\n \t   TYPE_UNSIGNED (scalar_type));\n-      *comp_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+      *comp_vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t   slp_node);\n     }\n \n   return true;\n@@ -9965,7 +9969,7 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo,\n+  if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo, slp_node,\n \t\t\t    &comp_vectype, &dts[0], slp_node ? NULL : vectype)\n       || !comp_vectype)\n     return false;\n@@ -10444,7 +10448,8 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* Invariant comparison.  */\n   if (!vectype)\n     {\n-      vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n+      vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1),\n+\t\t\t\t\t     slp_node);\n       if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype), nunits))\n \treturn false;\n     }\n@@ -11252,31 +11257,93 @@ get_related_vectype_for_scalar_type (machine_mode prevailing_mode,\n /* Function get_vectype_for_scalar_type.\n \n    Returns the vector type corresponding to SCALAR_TYPE as supported\n-   by the target.  */\n+   by the target.  If GROUP_SIZE is nonzero and we're performing BB\n+   vectorization, make sure that the number of elements in the vector\n+   is no bigger than GROUP_SIZE.  */\n \n tree\n-get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type)\n+get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type,\n+\t\t\t     unsigned int group_size)\n {\n+  /* For BB vectorization, we should always have a group size once we've\n+     constructed the SLP tree; the only valid uses of zero GROUP_SIZEs\n+     are tentative requests during things like early data reference\n+     analysis and pattern recognition.  */\n+  if (is_a <bb_vec_info> (vinfo))\n+    gcc_assert (vinfo->slp_instances.is_empty () || group_size != 0);\n+  else\n+    group_size = 0;\n+\n   tree vectype = get_related_vectype_for_scalar_type (vinfo->vector_mode,\n \t\t\t\t\t\t      scalar_type);\n   if (vectype && vinfo->vector_mode == VOIDmode)\n     vinfo->vector_mode = TYPE_MODE (vectype);\n \n+  /* Register the natural choice of vector type, before the group size\n+     has been applied.  */\n   if (vectype)\n     vinfo->used_vector_modes.add (TYPE_MODE (vectype));\n \n+  /* If the natural choice of vector type doesn't satisfy GROUP_SIZE,\n+     try again with an explicit number of elements.  */\n+  if (vectype\n+      && group_size\n+      && maybe_ge (TYPE_VECTOR_SUBPARTS (vectype), group_size))\n+    {\n+      /* Start with the biggest number of units that fits within\n+\t GROUP_SIZE and halve it until we find a valid vector type.\n+\t Usually either the first attempt will succeed or all will\n+\t fail (in the latter case because GROUP_SIZE is too small\n+\t for the target), but it's possible that a target could have\n+\t a hole between supported vector types.\n+\n+\t If GROUP_SIZE is not a power of 2, this has the effect of\n+\t trying the largest power of 2 that fits within the group,\n+\t even though the group is not a multiple of that vector size.\n+\t The BB vectorizer will then try to carve up the group into\n+\t smaller pieces.  */\n+      unsigned int nunits = 1 << floor_log2 (group_size);\n+      do\n+\t{\n+\t  vectype = get_related_vectype_for_scalar_type (vinfo->vector_mode,\n+\t\t\t\t\t\t\t scalar_type, nunits);\n+\t  nunits /= 2;\n+\t}\n+      while (nunits > 1 && !vectype);\n+    }\n+\n   return vectype;\n }\n \n+/* Return the vector type corresponding to SCALAR_TYPE as supported\n+   by the target.  NODE, if nonnull, is the SLP tree node that will\n+   use the returned vector type.  */\n+\n+tree\n+get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type, slp_tree node)\n+{\n+  unsigned int group_size = 0;\n+  if (node)\n+    {\n+      group_size = SLP_TREE_SCALAR_OPS (node).length ();\n+      if (group_size == 0)\n+\tgroup_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+    }\n+  return get_vectype_for_scalar_type (vinfo, scalar_type, group_size);\n+}\n+\n /* Function get_mask_type_for_scalar_type.\n \n    Returns the mask type corresponding to a result of comparison\n-   of vectors of specified SCALAR_TYPE as supported by target.  */\n+   of vectors of specified SCALAR_TYPE as supported by target.\n+   NODE, if nonnull, is the SLP tree node that will use the returned\n+   vector type.  */\n \n tree\n-get_mask_type_for_scalar_type (vec_info *vinfo, tree scalar_type)\n+get_mask_type_for_scalar_type (vec_info *vinfo, tree scalar_type,\n+\t\t\t       slp_tree node)\n {\n-  tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+  tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type, node);\n \n   if (!vectype)\n     return NULL;\n@@ -11963,6 +12030,9 @@ vect_gen_while_not (gimple_seq *seq, tree mask_type, tree start_index,\n \n /* Try to compute the vector types required to vectorize STMT_INFO,\n    returning true on success and false if vectorization isn't possible.\n+   If GROUP_SIZE is nonzero and we're performing BB vectorization,\n+   take sure that the number of elements in the vectors is no bigger\n+   than GROUP_SIZE.\n \n    On success:\n \n@@ -11980,11 +12050,21 @@ vect_gen_while_not (gimple_seq *seq, tree mask_type, tree start_index,\n opt_result\n vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t\ttree *stmt_vectype_out,\n-\t\t\t\ttree *nunits_vectype_out)\n+\t\t\t\ttree *nunits_vectype_out,\n+\t\t\t\tunsigned int group_size)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n   gimple *stmt = stmt_info->stmt;\n \n+  /* For BB vectorization, we should always have a group size once we've\n+     constructed the SLP tree; the only valid uses of zero GROUP_SIZEs\n+     are tentative requests during things like early data reference\n+     analysis and pattern recognition.  */\n+  if (is_a <bb_vec_info> (vinfo))\n+    gcc_assert (vinfo->slp_instances.is_empty () || group_size != 0);\n+  else\n+    group_size = 0;\n+\n   *stmt_vectype_out = NULL_TREE;\n   *nunits_vectype_out = NULL_TREE;\n \n@@ -12015,7 +12095,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \n   tree vectype;\n   tree scalar_type = NULL_TREE;\n-  if (STMT_VINFO_VECTYPE (stmt_info))\n+  if (group_size == 0 && STMT_VINFO_VECTYPE (stmt_info))\n     {\n       *stmt_vectype_out = vectype = STMT_VINFO_VECTYPE (stmt_info);\n       if (dump_enabled_p ())\n@@ -12024,15 +12104,17 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n     }\n   else\n     {\n-      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n-      if (gimple_call_internal_p (stmt, IFN_MASK_STORE))\n+      if (data_reference *dr = STMT_VINFO_DATA_REF (stmt_info))\n+\tscalar_type = TREE_TYPE (DR_REF (dr));\n+      else if (gimple_call_internal_p (stmt, IFN_MASK_STORE))\n \tscalar_type = TREE_TYPE (gimple_call_arg (stmt, 3));\n       else\n \tscalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n \n       /* Pure bool ops don't participate in number-of-units computation.\n \t For comparisons use the types being compared.  */\n-      if (VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type)\n+      if (!STMT_VINFO_DATA_REF (stmt_info)\n+\t  && VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type)\n \t  && is_gimple_assign (stmt)\n \t  && gimple_assign_rhs_code (stmt) != COND_EXPR)\n \t{\n@@ -12052,9 +12134,16 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t}\n \n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"get vectype for scalar type: %T\\n\", scalar_type);\n-      vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+\t{\n+\t  if (group_size)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"get vectype for scalar type (group size %d):\"\n+\t\t\t     \" %T\\n\", group_size, scalar_type);\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"get vectype for scalar type: %T\\n\", scalar_type);\n+\t}\n+      vectype = get_vectype_for_scalar_type (vinfo, scalar_type, group_size);\n       if (!vectype)\n \treturn opt_result::failure_at (stmt,\n \t\t\t\t       \"not vectorized:\"\n@@ -12085,7 +12174,8 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"get vectype for smallest scalar type: %T\\n\",\n \t\t\t     scalar_type);\n-\t  nunits_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+\t  nunits_vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t\tgroup_size);\n \t  if (!nunits_vectype)\n \t    return opt_result::failure_at\n \t      (stmt, \"not vectorized: unsupported data-type %T\\n\",\n@@ -12113,10 +12203,11 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \n /* Try to determine the correct vector type for STMT_INFO, which is a\n    statement that produces a scalar boolean result.  Return the vector\n-   type on success, otherwise return NULL_TREE.  */\n+   type on success, otherwise return NULL_TREE.  NODE, if nonnull,\n+   is the SLP tree node that will use the returned vector type.  */\n \n opt_tree\n-vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n+vect_get_mask_type_for_stmt (stmt_vec_info stmt_info, slp_tree node)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n   gimple *stmt = stmt_info->stmt;\n@@ -12128,7 +12219,7 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n       && !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n     {\n       scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-      mask_type = get_mask_type_for_scalar_type (vinfo, scalar_type);\n+      mask_type = get_mask_type_for_scalar_type (vinfo, scalar_type, node);\n \n       if (!mask_type)\n \treturn opt_tree::failure_at (stmt,"}, {"sha": "5f19411f93344b1df8444596095fc6f9284c59c7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b75f56d4b7951c60a656396dddd4a65787b95bc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9b75f56d4b7951c60a656396dddd4a65787b95bc", "patch": "@@ -1631,8 +1631,9 @@ extern void vect_update_inits_of_drs (loop_vec_info, tree, tree_code);\n /* In tree-vect-stmts.c.  */\n extern tree get_related_vectype_for_scalar_type (machine_mode, tree,\n \t\t\t\t\t\t poly_uint64 = 0);\n-extern tree get_vectype_for_scalar_type (vec_info *, tree);\n-extern tree get_mask_type_for_scalar_type (vec_info *, tree);\n+extern tree get_vectype_for_scalar_type (vec_info *, tree, unsigned int = 0);\n+extern tree get_vectype_for_scalar_type (vec_info *, tree, slp_tree);\n+extern tree get_mask_type_for_scalar_type (vec_info *, tree, slp_tree = 0);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_chooses_same_modes_p (vec_info *, machine_mode);\n extern bool vect_get_loop_mask_type (loop_vec_info);\n@@ -1684,8 +1685,8 @@ extern void optimize_mask_stores (class loop*);\n extern gcall *vect_gen_while (tree, tree, tree);\n extern tree vect_gen_while_not (gimple_seq *, tree, tree, tree);\n extern opt_result vect_get_vector_types_for_stmt (stmt_vec_info, tree *,\n-\t\t\t\t\t\t  tree *);\n-extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info);\n+\t\t\t\t\t\t  tree *, unsigned int = 0);\n+extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info, slp_tree = 0);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, poly_uint64);"}]}