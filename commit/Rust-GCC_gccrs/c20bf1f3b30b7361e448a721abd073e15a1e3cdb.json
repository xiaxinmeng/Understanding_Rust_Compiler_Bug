{"sha": "c20bf1f3b30b7361e448a721abd073e15a1e3cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwYmYxZjNiMzBiNzM2MWU0NDhhNzIxYWJkMDczZTE1YTFlM2NkYg==", "commit": {"author": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-22T18:45:56Z"}, "committer": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-22T18:45:56Z"}, "message": "bytecode modifications\n\nFrom-SVN: r5405", "tree": {"sha": "9ab272b1f01e7f6924e322852b59c0b55336f332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ab272b1f01e7f6924e322852b59c0b55336f332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c20bf1f3b30b7361e448a721abd073e15a1e3cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20bf1f3b30b7361e448a721abd073e15a1e3cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20bf1f3b30b7361e448a721abd073e15a1e3cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20bf1f3b30b7361e448a721abd073e15a1e3cdb/comments", "author": null, "committer": null, "parents": [{"sha": "292b12167da3473b5c7a69068b140e85e73b1faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292b12167da3473b5c7a69068b140e85e73b1faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292b12167da3473b5c7a69068b140e85e73b1faf"}], "stats": {"total": 194, "additions": 191, "deletions": 3}, "files": [{"sha": "98530736db0473e5e01e0ff70d6b556365283c30", "filename": "gcc/function.c", "status": "modified", "additions": 191, "deletions": 3, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c20bf1f3b30b7361e448a721abd073e15a1e3cdb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c20bf1f3b30b7361e448a721abd073e15a1e3cdb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c20bf1f3b30b7361e448a721abd073e15a1e3cdb", "patch": "@@ -54,6 +54,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"recog.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n+#include \"obstack.h\"\n+#include \"bytecode.h\"\n \n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n@@ -309,6 +311,10 @@ static int virtuals_instantiated;\n    integrate.c  */\n \n extern int rtx_equal_function_value_matters;\n+extern tree bc_runtime_type_code ();\n+extern rtx bc_build_calldesc ();\n+extern char *bc_emit_trampoline ();\n+extern char *bc_end_function ();\n \n void fixup_gotos ();\n \n@@ -369,6 +375,31 @@ struct temp_slot *temp_slots;\n \n int temp_slot_level;\n \f\n+/* The FUNCTION_DECL node for the current function.  */\n+static tree this_function_decl;\n+\n+/* Callinfo pointer for the current function.  */\n+static rtx this_function_callinfo;\n+\n+/* The label in the bytecode file of this function's actual bytecode.\n+   Not an rtx.  */\n+static char *this_function_bytecode;\n+\n+/* The call description vector for the current function.  */\n+static rtx this_function_calldesc;\n+\n+/* Size of the local variables allocated for the current function.  */\n+int local_vars_size;\n+\n+/* Current depth of the bytecode evaluation stack.  */\n+int stack_depth;\n+\n+/* Maximum depth of the evaluation stack in this function.  */\n+int max_stack_depth;\n+\n+/* Current depth in statement expressions.  */\n+static int stmt_expr_depth;\n+\f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n \n@@ -928,7 +959,12 @@ put_var_into_stack (decl)\n   register rtx reg;\n   enum machine_mode promoted_mode, decl_mode;\n   struct function *function = 0;\n-  tree context = decl_function_context (decl);\n+  tree context;\n+\n+  if (output_bytecode)\n+    return;\n+  \n+  context = decl_function_context (decl);\n \n   /* Get the current rtl used for this object and it's original mode.  */\n   reg = TREE_CODE (decl) == SAVE_EXPR ? SAVE_EXPR_RTL (decl) : DECL_RTL (decl);\n@@ -4279,6 +4315,49 @@ all_blocks (block, vector)\n   return n_blocks;\n }\n \f\n+/* Build bytecode call descriptor for function SUBR. */\n+rtx\n+bc_build_calldesc (subr)\n+  tree subr;\n+{\n+  tree calldesc = 0, arg;\n+  int nargs = 0;\n+\n+  /* Build the argument description vector in reverse order.  */\n+  DECL_ARGUMENTS (subr) = nreverse (DECL_ARGUMENTS (subr));\n+  nargs = 0;\n+\n+  for (arg = DECL_ARGUMENTS (subr); arg; arg = TREE_CHAIN (arg))\n+    {\n+      ++nargs;\n+\n+      calldesc = tree_cons ((tree) 0, size_in_bytes (TREE_TYPE (arg)), calldesc);\n+      calldesc = tree_cons ((tree) 0, bc_runtime_type_code (TREE_TYPE (arg)), calldesc);\n+    }\n+\n+  DECL_ARGUMENTS (subr) = nreverse (DECL_ARGUMENTS (subr));\n+\n+  /* Prepend the function's return type.  */\n+  calldesc = tree_cons ((tree) 0,\n+\t\t\tsize_in_bytes (TREE_TYPE (TREE_TYPE (subr))),\n+\t\t\tcalldesc);\n+\n+  calldesc = tree_cons ((tree) 0,\n+\t\t\tbc_runtime_type_code (TREE_TYPE (TREE_TYPE (subr))),\n+\t\t\tcalldesc);\n+\n+  /* Prepend the arg count.  */\n+  calldesc = tree_cons ((tree) 0, build_int_2 (nargs, 0), calldesc);\n+\n+  /* Output the call description vector and get its address.  */\n+  calldesc = build_nt (CONSTRUCTOR, (tree) 0, calldesc);\n+  TREE_TYPE (calldesc) = build_array_type (integer_type_node,\n+\t\t\t\t\t   build_index_type (build_int_2 (nargs * 2, 0)));\n+\n+  return output_constant_def (calldesc);\n+}\n+\n+\n /* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)\n    and initialize static variables for generating RTL for the statements\n    of the function.  */\n@@ -4291,6 +4370,17 @@ init_function_start (subr, filename, line)\n {\n   char *junk;\n \n+  if (output_bytecode)\n+    {\n+      this_function_decl = subr;\n+      this_function_calldesc = bc_build_calldesc (subr);\n+      local_vars_size = 0;\n+      stack_depth = 0;\n+      max_stack_depth = 0;\n+      stmt_expr_depth = 0;\n+      return;\n+    }\n+\n   init_stmt_for_function ();\n \n   cse_not_expected = ! optimize;\n@@ -4443,12 +4533,98 @@ mark_varargs ()\n void\n expand_main_function ()\n {\n+  if (!output_bytecode)\n+    {\n+      /* The zero below avoids a possible parse error */\n+      0;\n #if !defined (INIT_SECTION_ASM_OP) || defined (INVOKE__main)\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, NAME__MAIN), 0,\n-\t\t     VOIDmode, 0);\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__main\"), 0,\n+\t\t\t VOIDmode, 0);\n #endif /* not INIT_SECTION_ASM_OP or INVOKE__main */\n+    }\n }\n \f\n+extern struct obstack permanent_obstack;\n+\n+/* Expand start of bytecode function. See comment at\n+   expand_function_start below for details. */\n+\n+void\n+bc_expand_function_start (subr, parms_have_cleanups)\n+  tree subr;\n+  int parms_have_cleanups;\n+{\n+  char label[20], *name;\n+  static int nlab;\n+  tree thisarg;\n+  int argsz;\n+\n+  if (TREE_PUBLIC (subr))\n+    bc_globalize_label (IDENTIFIER_POINTER (DECL_NAME (subr)));\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fprintf (stderr, \"\\n<func %s>\\n\", IDENTIFIER_POINTER (DECL_NAME (subr)));\n+#endif\n+\n+  for (argsz = 0, thisarg = DECL_ARGUMENTS (subr); thisarg; thisarg = TREE_CHAIN (thisarg))\n+    {\n+      if (DECL_RTL (thisarg))\n+\tabort ();\t\t/* Should be NULL here I think.  */\n+      else if (TREE_CONSTANT (DECL_SIZE (thisarg)))\n+\t{\n+\t  DECL_RTL (thisarg) = bc_gen_rtx ((char *) 0, argsz, (struct bc_label *) 0);\n+\t  argsz += TREE_INT_CST_LOW (DECL_SIZE (thisarg));\n+\t}\n+      else\n+\t{\n+\t  /* Variable-sized objects are pointers to their storage. */\n+\t  DECL_RTL (thisarg) = bc_gen_rtx ((char *) 0, argsz, (struct bc_label *) 0);\n+\t  argsz += POINTER_SIZE;\n+\t}\n+    }\n+\n+  bc_begin_function (bc_xstrdup (IDENTIFIER_POINTER (DECL_NAME (subr))));\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LX\", nlab);\n+\n+  ++nlab;\n+  name = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+  this_function_callinfo = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n+  this_function_bytecode = bc_emit_trampoline (this_function_callinfo->label);\n+}\n+\n+\n+/* Expand end of bytecode function. See details the comment of\n+   expand_function_end(), below. */\n+\n+void\n+bc_expand_function_end ()\n+{\n+  char *ptrconsts;\n+\n+  expand_null_return ();\n+\n+  /* Emit any fixup code. This must be done before the call to\n+     to BC_END_FUNCTION (), since that will cause the bytecode\n+     segment to be finished off and closed. */\n+\n+  fixup_gotos (0, 0, 0, 0, 0);\n+\n+  ptrconsts = bc_end_function ();\n+\n+  bc_align_const (2 /* INT_ALIGN */);\n+\n+  /* If this changes also make sure to change bc-interp.h!  */\n+\n+  bc_emit_const_labeldef (this_function_callinfo->label);\n+  bc_emit_const ((char *) &max_stack_depth, sizeof max_stack_depth);\n+  bc_emit_const ((char *) &local_vars_size, sizeof local_vars_size);\n+  bc_emit_const_labelref (this_function_bytecode, 0);\n+  bc_emit_const_labelref (ptrconsts, 0);\n+  bc_emit_const_labelref (this_function_calldesc->label, 0);\n+}\n+\n+\n /* Start the RTL for a new function, and set variables used for\n    emitting RTL.\n    SUBR is the FUNCTION_DECL node.\n@@ -4464,6 +4640,12 @@ expand_function_start (subr, parms_have_cleanups)\n   tree tem;\n   rtx last_ptr;\n \n+  if (output_bytecode)\n+    {\n+      bc_expand_function_start (subr, parms_have_cleanups);\n+      return;\n+    }\n+\n   /* Make sure volatile mem refs aren't considered\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n@@ -4658,6 +4840,12 @@ expand_function_end (filename, line)\n \n   static rtx initial_trampoline;\n \n+  if (output_bytecode)\n+    {\n+      bc_expand_function_end ();\n+      return;\n+    }\n+\n #ifdef NON_SAVING_SETJMP\n   /* Don't put any variables in registers if we call setjmp\n      on a machine that fails to restore the registers.  */"}]}