{"sha": "5a783f42d77b2f00a1ed171c119b020e8df8e521", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE3ODNmNDJkNzdiMmYwMGExZWQxNzFjMTE5YjAyMGU4ZGY4ZTUyMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-15T16:45:42Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-15T16:45:42Z"}, "message": "aarch64: Add a minipass for fusing CC insns [PR88836]\n\nThis patch adds a small target-specific pass to remove redundant SVE\nPTEST instructions.  There are two important uses of this:\n\n- Removing PTESTs after WHILELOs (PR88836).  The original testcase\n  no longer exhibits the problem due to more recent optimisations,\n  but it can still be seen in simple cases like the one in the patch.\n  It also shows up in 450.soplex.\n\n- Removing PTESTs after RDFFRs in ACLE code.\n\nThis is just an interim \u201csolution\u201d for GCC 11.  I hope to replace\nit with something generic and target-independent for GCC 12.\nHowever, the use cases above are very important for performance,\nso I'd rather not leave the bug unfixed for yet another release cycle.\n\nSince the pass is intended to be short-lived, I've not added\na command-line option for it.  The pass can be disabled using\n-fdisable-rtl-cc_fusion if necessary.\n\nAlthough what the pass does is independent of SVE, it's motivated\nonly by SVE cases and doesn't trigger for any non-SVE test I've seen.\nI've therefore gated it on TARGET_SVE and restricted it to PTEST\npatterns.\n\ngcc/\n\tPR target/88836\n\t* config.gcc (aarch64*-*-*): Add aarch64-cc-fusion.o to extra_objs.\n\t* Makefile.in (RTL_SSA_H): New variable.\n\t* config/aarch64/t-aarch64 (aarch64-cc-fusion.o): New rule.\n\t* config/aarch64/aarch64-protos.h (make_pass_cc_fusion): Declare.\n\t* config/aarch64/aarch64-passes.def: Add pass_cc_fusion after\n\tpass_combine.\n\t* config/aarch64/aarch64-cc-fusion.cc: New file.\n\ngcc/testsuite/\n\tPR target/88836\n\t* gcc.target/aarch64/sve/acle/general/ldff1_8.c: New test.\n\t* gcc.target/aarch64/sve/ptest_1.c: Likewise.", "tree": {"sha": "87d1f167c2255ea3842b465fbb98c41e483b7a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87d1f167c2255ea3842b465fbb98c41e483b7a91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a783f42d77b2f00a1ed171c119b020e8df8e521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a783f42d77b2f00a1ed171c119b020e8df8e521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a783f42d77b2f00a1ed171c119b020e8df8e521", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a783f42d77b2f00a1ed171c119b020e8df8e521/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2cc526f47acbeeddd77b706a212b4703562e57f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cc526f47acbeeddd77b706a212b4703562e57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2cc526f47acbeeddd77b706a212b4703562e57f"}], "stats": {"total": 355, "additions": 354, "deletions": 1}, "files": [{"sha": "a63c5d9cab6ef39650ceffbc66034a1b295fc873", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -1024,6 +1024,13 @@ PLUGIN_H = plugin.h $(GCC_PLUGIN_H)\n PLUGIN_VERSION_H = plugin-version.h configargs.h\n CONTEXT_H = context.h\n GENSUPPORT_H = gensupport.h read-md.h optabs.def\n+RTL_SSA_H = $(PRETTY_PRINT_H) insn-config.h splay-tree-utils.h \\\n+\t    $(RECOG_H) $(REGS_H) function-abi.h obstack-utils.h \\\n+\t    mux-utils.h rtlanal.h memmodel.h $(EMIT_RTL_H) \\\n+\t    rtl-ssa/accesses.h rtl-ssa/insns.h rtl-ssa/blocks.h \\\n+\t    rtl-ssa/changes.h rtl-ssa/functions.h rtl-ssa/is-a.inl \\\n+\t    rtl-ssa/access-utils.h rtl-ssa/insn-utils.h rtl-ssa/movement.h \\\n+\t    rtl-ssa/change-utils.h rtl-ssa/member-fns.inl\n \n #\f\n # Now figure out from those variables how to compile and link."}, {"sha": "17fea83b2e4306d025ebd5a3f542fdea778b6e62", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -321,7 +321,7 @@ aarch64*-*-*)\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o aarch64-sve-builtins-sve2.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o aarch64-sve-builtins-sve2.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o aarch64-cc-fusion.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c \\$(srcdir)/config/aarch64/aarch64-sve-builtins.h \\$(srcdir)/config/aarch64/aarch64-sve-builtins.cc\"\n \ttarget_has_targetm_common=yes\n \t;;"}, {"sha": "09069a20de28f992c288f9dc87b7e935937e4baa", "filename": "gcc/config/aarch64/aarch64-cc-fusion.cc", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-cc-fusion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-cc-fusion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cc-fusion.cc?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -0,0 +1,296 @@\n+// Pass to fuse CC operations with other instructions.\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This pass looks for sequences of the form:\n+//\n+//    A: (set (reg R1) X1)\n+//    B: ...instructions that might change the value of X1...\n+//    C: (set (reg CC) X2) // X2 uses R1\n+//\n+// and tries to change them to:\n+//\n+//    C': [(set (reg CC) X2')\n+//         (set (reg R1) X1)]\n+//    B: ...instructions that might change the value of X1...\n+//\n+// where X2' is the result of replacing R1 with X1 in X2.\n+//\n+// This sequence occurs in SVE code in two important cases:\n+//\n+// (a) Sometimes, to deal correctly with overflow, we need to increment\n+//     an IV after a WHILELO rather than before it.  In this case:\n+//     - A is a WHILELO,\n+//     - B includes an IV increment and\n+//     - C is a separate PTEST.\n+//\n+// (b) ACLE code of the form:\n+//\n+//       svbool_t ok = svrdffr ();\n+//       if (svptest_last (pg, ok))\n+//         ...\n+//\n+//     must, for performance reasons, be code-generated as:\n+//\n+//       RDFFRS Pok.B, Pg/Z\n+//       ...branch on flags result...\n+//\n+//     without a separate PTEST of Pok.  In this case:\n+//     - A is an aarch64_rdffr\n+//     - B includes an aarch64_update_ffrt\n+//     - C is a separate PTEST\n+//\n+// Combine can handle this optimization if B doesn't exist and if A and\n+// C are in the same BB.  This pass instead handles cases where B does\n+// exist and cases where A and C are in different BBs of the same EBB.\n+\n+#define IN_TARGET_CODE 1\n+\n+#define INCLUDE_ALGORITHM\n+#define INCLUDE_FUNCTIONAL\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"df.h\"\n+#include \"rtl-ssa.h\"\n+#include \"tree-pass.h\"\n+\n+using namespace rtl_ssa;\n+\n+namespace {\n+const pass_data pass_data_cc_fusion =\n+{\n+  RTL_PASS, // type\n+  \"cc_fusion\", // name\n+  OPTGROUP_NONE, // optinfo_flags\n+  TV_NONE, // tv_id\n+  0, // properties_required\n+  0, // properties_provided\n+  0, // properties_destroyed\n+  0, // todo_flags_start\n+  TODO_df_finish, // todo_flags_finish\n+};\n+\n+// Class that represents one run of the pass.\n+class cc_fusion\n+{\n+public:\n+  cc_fusion ()  : m_parallel () {}\n+  void execute ();\n+\n+private:\n+  rtx optimizable_set (const insn_info *);\n+  bool parallelize_insns (def_info *, rtx, def_info *, rtx);\n+  void optimize_cc_setter (def_info *, rtx);\n+\n+  // A spare PARALLEL rtx, or null if none.\n+  rtx m_parallel;\n+};\n+\n+// See whether INSN is a single_set that we can optimize.  Return the\n+// set if so, otherwise return null.\n+rtx\n+cc_fusion::optimizable_set (const insn_info *insn)\n+{\n+  if (!insn->can_be_optimized ()\n+      || insn->is_asm ()\n+      || insn->has_volatile_refs ()\n+      || insn->has_pre_post_modify ())\n+    return NULL_RTX;\n+\n+  return single_set (insn->rtl ());\n+}\n+\n+// CC_SET is a single_set that sets (only) CC_DEF; OTHER_SET is likewise\n+// a single_set that sets (only) OTHER_DEF.  CC_SET is known to set the\n+// CC register and the instruction that contains CC_SET is known to use\n+// OTHER_DEF.  Try to do CC_SET and OTHER_SET in parallel.\n+bool\n+cc_fusion::parallelize_insns (def_info *cc_def, rtx cc_set,\n+\t\t\t      def_info *other_def, rtx other_set)\n+{\n+  auto attempt = crtl->ssa->new_change_attempt ();\n+\n+  insn_info *cc_insn = cc_def->insn ();\n+  insn_info *other_insn = other_def->insn ();\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"trying to parallelize insn %d and insn %d\\n\",\n+\t     other_insn->uid (), cc_insn->uid ());\n+\n+  // Try to substitute OTHER_SET into CC_INSN.\n+  insn_change_watermark rtl_watermark;\n+  rtx_insn *cc_rtl = cc_insn->rtl ();\n+  insn_propagation prop (cc_rtl, SET_DEST (other_set),\n+\t\t\t SET_SRC (other_set));\n+  if (!prop.apply_to_pattern (&PATTERN (cc_rtl))\n+      || prop.num_replacements == 0)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"-- failed to substitute all uses of r%d\\n\",\n+\t\t other_def->regno ());\n+      return false;\n+    }\n+\n+  // Restrict the uses to those outside notes.\n+  use_array cc_uses = remove_note_accesses (attempt, cc_insn->uses ());\n+  use_array other_set_uses = remove_note_accesses (attempt,\n+\t\t\t\t\t\t   other_insn->uses ());\n+\n+  // Remove the use of the substituted value.\n+  access_array_builder uses_builder (attempt);\n+  uses_builder.reserve (cc_uses.size ());\n+  for (use_info *use : cc_uses)\n+    if (use->def () != other_def)\n+      uses_builder.quick_push (use);\n+  cc_uses = use_array (uses_builder.finish ());\n+\n+  // Get the list of uses for the new instruction.\n+  insn_change cc_change (cc_insn);\n+  cc_change.new_uses = merge_access_arrays (attempt, other_set_uses, cc_uses);\n+  if (!cc_change.new_uses.is_valid ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"-- cannot merge uses\\n\");\n+      return false;\n+    }\n+\n+  // The instruction initially defines just two registers.  recog can add\n+  // extra clobbers if necessary.\n+  auto_vec<access_info *, 2> new_defs;\n+  new_defs.quick_push (cc_def);\n+  new_defs.quick_push (other_def);\n+  sort_accesses (new_defs);\n+  cc_change.new_defs = def_array (access_array (new_defs));\n+\n+  // Make sure there is somewhere that the new instruction could live.\n+  auto other_change = insn_change::delete_insn (other_insn);\n+  insn_change *changes[] = { &other_change, &cc_change };\n+  cc_change.move_range = cc_insn->ebb ()->insn_range ();\n+  if (!restrict_movement_ignoring (cc_change, insn_is_changing (changes)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"-- cannot satisfy all definitions and uses\\n\");\n+      return false;\n+    }\n+\n+  // Tentatively install the new pattern.  By convention, the CC set\n+  // must be first.\n+  if (m_parallel)\n+    {\n+      XVECEXP (m_parallel, 0, 0) = cc_set;\n+      XVECEXP (m_parallel, 0, 1) = other_set;\n+    }\n+  else\n+    {\n+      rtvec vec = gen_rtvec (2, cc_set, other_set);\n+      m_parallel = gen_rtx_PARALLEL (VOIDmode, vec);\n+    }\n+  validate_change (cc_rtl, &PATTERN (cc_rtl), m_parallel, 1);\n+\n+  // These routines report failures themselves.\n+  if (!recog_ignoring (attempt, cc_change, insn_is_changing (changes))\n+      || !changes_are_worthwhile (changes)\n+      || !crtl->ssa->verify_insn_changes (changes))\n+    return false;\n+\n+  remove_reg_equal_equiv_notes (cc_rtl);\n+  confirm_change_group ();\n+  crtl->ssa->change_insns (changes);\n+  m_parallel = NULL_RTX;\n+  return true;\n+}\n+\n+// Try to optimize the instruction that contains CC_DEF, where CC_DEF describes\n+// a definition of the CC register by CC_SET.\n+void\n+cc_fusion::optimize_cc_setter (def_info *cc_def, rtx cc_set)\n+{\n+  // Search the registers used by the CC setter for an easily-substitutable\n+  // def-use chain.\n+  for (use_info *other_use : cc_def->insn ()->uses ())\n+    if (def_info *other_def = other_use->def ())\n+      if (other_use->regno () != CC_REGNUM\n+\t  && other_def->ebb () == cc_def->ebb ())\n+\tif (rtx other_set = optimizable_set (other_def->insn ()))\n+\t  {\n+\t    rtx dest = SET_DEST (other_set);\n+\t    if (REG_P (dest)\n+\t\t&& REGNO (dest) == other_def->regno ()\n+\t\t&& REG_NREGS (dest) == 1\n+\t\t&& parallelize_insns (cc_def, cc_set, other_def, other_set))\n+\t      return;\n+\t  }\n+}\n+\n+// Run the pass on the current function.\n+void\n+cc_fusion::execute ()\n+{\n+  // Initialization.\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  df_analyze ();\n+  crtl->ssa = new rtl_ssa::function_info (cfun);\n+\n+  // Walk through all instructions that set CC.  Look for a PTEST instruction\n+  // that we can optimize.\n+  //\n+  // ??? The PTEST test isn't needed for correctness, but it ensures that the\n+  // pass no effect on non-SVE code.\n+  for (def_info *def : crtl->ssa->reg_defs (CC_REGNUM))\n+    if (rtx cc_set = optimizable_set (def->insn ()))\n+      if (REG_P (SET_DEST (cc_set))\n+\t  && REGNO (SET_DEST (cc_set)) == CC_REGNUM\n+\t  && GET_CODE (SET_SRC (cc_set)) == UNSPEC\n+\t  && XINT (SET_SRC (cc_set), 1) == UNSPEC_PTEST)\n+\toptimize_cc_setter (def, cc_set);\n+\n+  // Finalization.\n+  crtl->ssa->perform_pending_updates ();\n+  free_dominance_info (CDI_DOMINATORS);\n+}\n+\n+class pass_cc_fusion : public rtl_opt_pass\n+{\n+public:\n+  pass_cc_fusion (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cc_fusion, ctxt)\n+  {}\n+\n+  // opt_pass methods:\n+  virtual bool gate (function *) { return TARGET_SVE && optimize >= 2; }\n+  virtual unsigned int execute (function *);\n+};\n+\n+unsigned int\n+pass_cc_fusion::execute (function *)\n+{\n+  cc_fusion ().execute ();\n+  return 0;\n+}\n+\n+} // end namespace\n+\n+// Create a new CC fusion pass instance.\n+\n+rtl_opt_pass *\n+make_pass_cc_fusion (gcc::context *ctxt)\n+{\n+  return new pass_cc_fusion (ctxt);\n+}"}, {"sha": "0b773d2c34d44b356ae5373150536583658ad271", "filename": "gcc/config/aarch64/aarch64-passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -22,3 +22,4 @@ INSERT_PASS_AFTER (pass_regrename, 1, pass_fma_steering);\n INSERT_PASS_BEFORE (pass_reorder_blocks, 1, pass_track_speculation);\n INSERT_PASS_AFTER (pass_machine_reorg, 1, pass_tag_collision_avoidance);\n INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_bti);\n+INSERT_PASS_AFTER (pass_if_after_combine, 1, pass_cc_fusion);"}, {"sha": "ff87ced2a3439a555c4e2014ea7f6df88db1ee7e", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -790,6 +790,7 @@ rtl_opt_pass *make_pass_fma_steering (gcc::context *);\n rtl_opt_pass *make_pass_track_speculation (gcc::context *);\n rtl_opt_pass *make_pass_tag_collision_avoidance (gcc::context *);\n rtl_opt_pass *make_pass_insert_bti (gcc::context *ctxt);\n+rtl_opt_pass *make_pass_cc_fusion (gcc::context *ctxt);\n \n poly_uint64 aarch64_regmode_natural_size (machine_mode);\n "}, {"sha": "7e1606c47acef7162848fdec65306b54c8bced50", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -158,6 +158,12 @@ aarch64-bti-insert.o: $(srcdir)/config/aarch64/aarch64-bti-insert.c \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/aarch64/aarch64-bti-insert.c\n \n+aarch64-cc-fusion.o: $(srcdir)/config/aarch64/aarch64-cc-fusion.cc \\\n+    $(CONFIG_H) $(SYSTEM_H) $(CORETYPES_H) $(BACKEND_H) $(RTL_H) $(DF_H) \\\n+    $(RTL_SSA_H) tree-pass.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/aarch64-cc-fusion.cc\n+\n comma=,\n MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))\n MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}, {"sha": "b55cc1fd2b8ef95dbd11f4dd747d8c5204b91c81", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_8.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_8.c?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+foo (int8_t *ptr1, int8_t *ptr2, svint8_t *res1, svint8_t *res2)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+\n+  svsetffr ();\n+  svint8_t x1 = svldff1 (pg, ptr1);\n+  svbool_t ok1 = svrdffr ();\n+  if (!svptest_last (pg, ok1))\n+    {\n+      x1 = svsel (ok1, x1, svdup_s8 (0));\n+      svsetffr ();\n+    }\n+\n+  svint8_t x2 = svldff1 (pg, ptr2);\n+  svbool_t ok2 = svrdffr ();\n+  if (!svptest_last (pg, ok2))\n+    x2 = svsel (ok2, x2, svdup_s8 (0));\n+\n+  *res1 = x1;\n+  *res2 = x2;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\trdffrs\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\t(?:b.last|b.nfrst)\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\trdffr\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "abc5108948024e93e99bcd9c46f6046fdddd7f12", "filename": "gcc/testsuite/gcc.target/aarch64/sve/ptest_1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fptest_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a783f42d77b2f00a1ed171c119b020e8df8e521/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fptest_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fptest_1.c?ref=5a783f42d77b2f00a1ed171c119b020e8df8e521", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+void\n+f (char *restrict x, char *restrict y, char *restrict z, unsigned long n)\n+{\n+  for (unsigned long i = 0; i < n; i += 1)\n+    x[i] = y[i] + z[i];\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}]}