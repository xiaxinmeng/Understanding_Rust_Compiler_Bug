{"sha": "f3bb6135f6a5cd960e40c8e2febfa22c6b90347f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNiYjYxMzVmNmE1Y2Q5NjBlNDBjOGUyZmViZmEyMmM2YjkwMzQ3Zg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-01T17:09:29Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-01T17:09:29Z"}, "message": "General tidy up.\n\n#include <string.h>.\nDeclare some prototypes.\n(output_memory_reference_mode): Change type to enum machine_mode.\n(arm_const_nmoves): Delete.\n(adjacent_mem_locations, {load,store}_multiple_operation): Explicitly\ndeclare to return int.\n({load,store}_multiple_operation): Change type of 'count', 'base' and 'i' to\nHOST_WIDE_INT.\n(output_add_immediate): Change type of 'n' to HOST_WIDE_INT.\n(output_multi_immediate): Change type of Argument 'n' to HOST_WIDE_INT, if\nwider than 32 bits, mask out the high bits.\n(output_arithmetic_with_immediate_multiply): Change type of 'shift'\nto HOST_WIDE_INT.\n(output_func_{prologue,epilogue}): Renamed from output_{prologue,epilogue}.\nCheck all registers to see if they are live, but only push/pop them if they\nare not in call_used_regs.\n\n(const_pool_offset): New function.\n(get_prologue_size): New function.\n(output_func_prologue): Eliminate variable code_size.\n(output_func_epilogue): Only call arm_increase_location when optimizing; also\nadd the size of the function just compiled, and the size of the prologue.\n(arm_output_asm_insn): Delete.  All callers changed to use output_asm_insn.\n(arm_output_llc): Delete.\n(output_load_symbol): New first parameter 'insn'.  Rewrite so that assembler\ncan detect whether we made a mistake.\n\nFrom-SVN: r7416", "tree": {"sha": "5ad810a2dba592bd029710106d8511ed42adc46c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ad810a2dba592bd029710106d8511ed42adc46c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f/comments", "author": null, "committer": null, "parents": [{"sha": "a1dc0475d64bbb2e432a6b145a5902e355430c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1dc0475d64bbb2e432a6b145a5902e355430c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1dc0475d64bbb2e432a6b145a5902e355430c99"}], "stats": {"total": 820, "additions": 432, "deletions": 388}, "files": [{"sha": "0e8d7d7b6bb24049cd24829d355c960288f1a3ac", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 432, "deletions": 388, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3bb6135f6a5cd960e40c8e2febfa22c6b90347f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f3bb6135f6a5cd960e40c8e2febfa22c6b90347f", "patch": "@@ -21,6 +21,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n     \n #include <stdio.h>\n+#include <string.h>\n #include \"assert.h\"\n #include \"config.h\"\n #include \"rtl.h\"\n@@ -42,9 +43,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Some function declarations.  */\n extern FILE *asm_out_file;\n extern char *output_multi_immediate ();\n-extern char *arm_output_asm_insn ();\n extern void arm_increase_location ();\n \n+HOST_WIDE_INT int_log2 PROTO ((HOST_WIDE_INT));\n+static int get_prologue_size PROTO ((void));\n+\n /*  Define the information needed to generate branch insns.  This is\n    stored from the compare operation. */\n \n@@ -58,7 +61,7 @@ enum processor_type arm_cpu;\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n    PRINT_OPERAND_ADDRESS.  */\n-int output_memory_reference_mode;\n+enum machine_mode output_memory_reference_mode;\n \n /* Nonzero if the prologue must setup `fp'.  */\n int current_function_anonymous_args;\n@@ -115,24 +118,6 @@ use_return_insn ()\n   return 1;\n }\n \n-/* Return the number of mov instructions needed to get the constant VALUE into\n-   a register.  */\n-\n-int\n-arm_const_nmoves (value)\n-     register int value;\n-{\n-  register int i;\n-\n-  if (value == 0)\n-    return (1);\n-  for (i = 0; value; i++, value &= ~0xff)\n-    while ((value & 3) == 0)\n-      value = (value >> 2) | ((value & 3) << 30);\n-  return (i);\n-} /* arm_const_nmoves */\n-\n-\n /* Return TRUE if int I is a valid immediate ARM constant.  */\n \n int\n@@ -144,14 +129,14 @@ const_ok_for_arm (i)\n   do\n     {\n       if ((i & mask & (unsigned HOST_WIDE_INT) 0xffffffff) == 0)\n-        return(TRUE);\n+        return TRUE;\n       mask =\n \t  (mask << 2) | ((mask & (unsigned HOST_WIDE_INT) 0xffffffff)\n \t\t\t >> (32 - 2)) | ~((unsigned HOST_WIDE_INT) 0xffffffff);\n     } while (mask != ~0xFF);\n \n-  return (FALSE);\n-} /* const_ok_for_arm */\n+  return FALSE;\n+}\n \n /* This code has been fixed for cross compilation. */\n \n@@ -181,6 +166,7 @@ init_fpa_table ()\n       r = REAL_VALUE_ATOF (strings_fpa[i], DFmode);\n       values_fpa[i] = r;\n     }\n+\n   fpa_consts_inited = 1;\n }\n \n@@ -199,11 +185,13 @@ const_double_rtx_ok_for_fpu (x)\n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n   if (REAL_VALUE_MINUS_ZERO (r))\n     return 0;\n+\n   for (i = 0; i < 8; i++)\n     if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n       return 1;\n+\n   return 0;\n-} /* const_double_rtx_ok_for_fpu */\n+}\n \n /* Return TRUE if rtx X is a valid immediate FPU constant. */\n \n@@ -221,11 +209,13 @@ neg_const_double_rtx_ok_for_fpu (x)\n   r = REAL_VALUE_NEGATE (r);\n   if (REAL_VALUE_MINUS_ZERO (r))\n     return 0;\n+\n   for (i = 0; i < 8; i++)\n     if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n       return 1;\n+\n   return 0;\n-} /* neg_const_double_rtx_ok_for_fpu */\n+}\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n@@ -241,9 +231,7 @@ s_register_operand (op, mode)\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n-    {\n-      op = SUBREG_REG (op);\n-    }\n+    op = SUBREG_REG (op);\n \n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n@@ -276,7 +264,7 @@ arm_rhs_operand (op, mode)\n {\n   return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n-} /* arm_rhs_operand */\n+}\n \n /* Return TRUE for valid operands for the rhs of an ARM instruction, or a load.\n  */\n@@ -289,7 +277,7 @@ arm_rhsm_operand (op, mode)\n   return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op)))\n \t  || memory_operand (op, mode));\n-} /* arm_rhs_operand */\n+}\n \n /* Return TRUE for valid operands for the rhs of an ARM instruction, or if a\n    constant that is valid when negated.  */\n@@ -303,7 +291,7 @@ arm_add_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n \t      && (const_ok_for_arm (INTVAL (op))\n \t\t  || const_ok_for_arm (-INTVAL (op)))));\n-} /* arm_rhs_operand */\n+}\n \n int\n arm_not_operand (op, mode)\n@@ -314,7 +302,7 @@ arm_not_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n \t      && (const_ok_for_arm (INTVAL (op))\n \t\t  || const_ok_for_arm (~INTVAL (op)))));\n-} /* arm_rhs_operand */\n+}\n \n /* Return TRUE for valid operands for the rhs of an FPU instruction.  */\n \n@@ -324,23 +312,25 @@ fpu_rhs_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (s_register_operand (op, mode))\n-    return(TRUE);\n+    return TRUE;\n   else if (GET_CODE (op) == CONST_DOUBLE)\n     return (const_double_rtx_ok_for_fpu (op));\n-  else return (FALSE);\n-} /* fpu_rhs_operand */\n+\n+  return FALSE;\n+}\n \n int\n fpu_add_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   if (s_register_operand (op, mode))\n-    return(TRUE);\n+    return TRUE;\n   else if (GET_CODE (op) == CONST_DOUBLE)\n-    return const_double_rtx_ok_for_fpu (op) \n-\t|| neg_const_double_rtx_ok_for_fpu (op);\n-  return (FALSE);\n+    return (const_double_rtx_ok_for_fpu (op) \n+\t    || neg_const_double_rtx_ok_for_fpu (op));\n+\n+  return FALSE;\n }\n \n /* Return nonzero if OP is a constant power of two.  */\n@@ -352,11 +342,11 @@ power_of_two_operand (op, mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n-      int value = INTVAL(op);\n-      return (value != 0  &&  (value & (value-1)) == 0);\n+      HOST_WIDE_INT value = INTVAL(op);\n+      return value != 0  &&  (value & (value - 1)) == 0;\n     }\n-  return (FALSE);\n-} /* power_of_two_operand */\n+  return FALSE;\n+}\n \n /* Return TRUE for a valid operand of a DImode operation.\n    Either: REG, CONST_DOUBLE or MEM(DImode_address).\n@@ -369,19 +359,21 @@ di_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (s_register_operand (op, mode))\n-    return (TRUE);\n+    return TRUE;\n \n   switch (GET_CODE (op))\n     {\n     case CONST_DOUBLE:\n     case CONST_INT:\n-      return (TRUE);\n+      return TRUE;\n+\n     case MEM:\n-      return (memory_address_p (DImode, XEXP (op, 0)));\n+      return memory_address_p (DImode, XEXP (op, 0));\n+\n     default:\n-      return (FALSE);\n+      return FALSE;\n     }\n-} /* di_operand */\n+}\n \n /* Return TRUE for valid index operands. */\n \n@@ -393,7 +385,7 @@ index_operand (op, mode)\n   return (s_register_operand(op, mode)\n \t  || (immediate_operand (op, mode)\n \t      && INTVAL (op) < 4096 && INTVAL (op) > -4096));\n-} /* index_operand */\n+}\n \n /* Return TRUE for valid shifts by a constant. This also accepts any\n    power of two on the (somewhat overly relaxed) assumption that the\n@@ -407,7 +399,7 @@ const_shift_operand (op, mode)\n   return (power_of_two_operand (op, mode)\n \t  || (immediate_operand (op, mode)\n \t      && (INTVAL (op) < 32 && INTVAL (op) > 0)));\n-} /* const_shift_operand */\n+}\n \n /* Return TRUE for arithmetic operators which can be combined with a multiply\n    (shift).  */\n@@ -426,7 +418,7 @@ shiftable_operator (x, mode)\n       return (code == PLUS || code == MINUS\n \t      || code == IOR || code == XOR || code == AND);\n     }\n-} /* shiftable_operator */\n+}\n \n /* Return TRUE for shift operators. */\n \n@@ -443,15 +435,16 @@ shift_operator (x, mode)\n \n       if (code == MULT)\n \treturn power_of_two_operand (XEXP (x, 1));\n+\n       return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n     }\n-} /* shift_operator */\n+}\n \n int equality_operator (x, mode)\n-rtx x;\n-enum machine_mode mode;\n+     rtx x;\n+     enum machine_mode mode;\n {\n-  return (GET_CODE (x) == EQ || GET_CODE (x) == NE);\n+  return GET_CODE (x) == EQ || GET_CODE (x) == NE;\n }\n \n /* Return TRUE for SMIN SMAX UMIN UMAX operators. */\n@@ -465,8 +458,9 @@ minmax_operator (x, mode)\n \n   if (GET_MODE (x) != mode)\n     return FALSE;\n+\n   return code == SMIN || code == SMAX || code == UMIN || code == UMAX;\n-} /* minmax_operator */\n+}\n \n /* return TRUE if x is EQ or NE */\n \n@@ -475,39 +469,43 @@ minmax_operator (x, mode)\n \n int\n cc_register (x, mode)\n-rtx x;\n-enum machine_mode mode;\n+     rtx x;\n+     enum machine_mode mode;\n {\n   if (mode == VOIDmode)\n     {\n       mode = GET_MODE (x);\n       if (GET_MODE_CLASS (mode) != MODE_CC)\n \treturn FALSE;\n     }\n+\n   if (mode == GET_MODE (x) && GET_CODE (x) == REG && REGNO (x) == 24)\n     return TRUE;\n+\n   return FALSE;\n }\n        \n enum rtx_code\n minmax_code (x)\n-rtx x;\n+     rtx x;\n {\n   enum rtx_code code = GET_CODE (x);\n \n   if (code == SMAX)\n     return GE;\n-  if (code == SMIN)\n+  else if (code == SMIN)\n     return LE;\n-  if (code == UMIN)\n+  else if (code == UMIN)\n     return LEU;\n-  if (code == UMAX)\n+  else if (code == UMAX)\n     return GEU;\n+\n   abort ();\n }\n \n /* Return 1 if memory locations are adjacent */\n \n+int\n adjacent_mem_locations (a, b)\n      rtx a, b;\n {\n@@ -543,14 +541,15 @@ adjacent_mem_locations (a, b)\n /* Return 1 if OP is a load multiple operation.  It is known to be\n    parallel and the first section will be tested. */\n \n+int\n load_multiple_operation (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  int count = XVECLEN (op, 0);\n+  HOST_WIDE_INT count = XVECLEN (op, 0);\n   int dest_regno;\n   rtx src_addr;\n-  int i = 1, base = 0;\n+  HOST_WIDE_INT i = 1, base = 0;\n   rtx elt;\n \n   if (count <= 1\n@@ -574,6 +573,7 @@ load_multiple_operation (op, mode)\n           || REGNO (XEXP (XVECEXP (op, 0, count - 1), 0))\n               != REGNO (SET_DEST (elt)))\n         return 0;\n+\n       count--;\n     }\n \n@@ -610,14 +610,15 @@ load_multiple_operation (op, mode)\n /* Return 1 if OP is a store multiple operation.  It is known to be\n    parallel and the first section will be tested. */\n \n+int\n store_multiple_operation (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  int count = XVECLEN (op, 0);\n+  HOST_WIDE_INT count = XVECLEN (op, 0);\n   int src_regno;\n   rtx dest_addr;\n-  int i = 1, base = 0;\n+  HOST_WIDE_INT i = 1, base = 0;\n   rtx elt;\n \n   if (count <= 1\n@@ -641,6 +642,7 @@ store_multiple_operation (op, mode)\n           || REGNO (XEXP (XVECEXP (op, 0, count - 1), 0))\n               != REGNO (SET_DEST (elt)))\n         return 0;\n+\n       count--;\n     }\n \n@@ -674,9 +676,19 @@ store_multiple_operation (op, mode)\n   return 1;\n }\n \f\n+/* Routines for use with attributes */\n+\n+int\n+const_pool_offset (symbol)\n+     rtx (symbol);\n+{\n+  return get_pool_offset (symbol) - get_pool_size () - get_prologue_size ();\n+}\n+\f\n /* Routines for use in generating RTL */\n \n-rtx arm_gen_load_multiple (base_regno, count, from, up, write_back)\n+rtx\n+arm_gen_load_multiple (base_regno, count, from, up, write_back)\n      int base_regno;\n      int count;\n      rtx from;\n@@ -690,27 +702,30 @@ rtx arm_gen_load_multiple (base_regno, count, from, up, write_back)\n   result = gen_rtx (PARALLEL, VOIDmode,\n                     rtvec_alloc (count + (write_back ? 2 : 0)));\n   if (write_back)\n-  {\n+    {\n       XVECEXP (result, 0, 0)\n-          = gen_rtx (SET, GET_MODE (from), from,\n-                     plus_constant (from, count * 4 * sign));\n+\t= gen_rtx (SET, GET_MODE (from), from,\n+\t\t   plus_constant (from, count * 4 * sign));\n       i = 1;\n       count++;\n-  }\n+    }\n+\n   for (j = 0; i < count; i++, j++)\n-  {\n+    {\n       XVECEXP (result, 0, i)\n-          = gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, base_regno + j),\n-                     gen_rtx (MEM, SImode,\n-                              plus_constant (from, j * 4 * sign)));\n-  }\n+\t= gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, base_regno + j),\n+\t\t   gen_rtx (MEM, SImode,\n+\t\t\t    plus_constant (from, j * 4 * sign)));\n+    }\n+\n   if (write_back)\n     XVECEXP (result, 0, i) = gen_rtx (CLOBBER, SImode, from);\n \n   return result;\n }\n \n-rtx arm_gen_store_multiple (base_regno, count, to, up, write_back)\n+rtx\n+arm_gen_store_multiple (base_regno, count, to, up, write_back)\n      int base_regno;\n      int count;\n      rtx to;\n@@ -724,20 +739,22 @@ rtx arm_gen_store_multiple (base_regno, count, to, up, write_back)\n   result = gen_rtx (PARALLEL, VOIDmode,\n                     rtvec_alloc (count + (write_back ? 2 : 0)));\n   if (write_back)\n-  {\n+    {\n       XVECEXP (result, 0, 0)\n-          = gen_rtx (SET, GET_MODE (to), to,\n-                     plus_constant (to, count * 4 * sign));\n+\t= gen_rtx (SET, GET_MODE (to), to,\n+\t\t   plus_constant (to, count * 4 * sign));\n       i = 1;\n       count++;\n-  }\n+    }\n+\n   for (j = 0; i < count; i++, j++)\n-  {\n+    {\n       XVECEXP (result, 0, i)\n-          = gen_rtx (SET, VOIDmode,\n-                     gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign)),\n-                     gen_rtx (REG, SImode, base_regno + j));\n-  }\n+\t= gen_rtx (SET, VOIDmode,\n+\t\t   gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign)),\n+\t\t   gen_rtx (REG, SImode, base_regno + j));\n+    }\n+\n   if (write_back)\n     XVECEXP (result, 0, i) = gen_rtx (CLOBBER, SImode, to);\n \n@@ -762,8 +779,9 @@ gen_compare_reg (code, x, y, fp)\n   return cc_reg;\n }\n \n+void\n arm_reload_out_hi (operands)\n-rtx operands[];\n+     rtx *operands;\n {\n   rtx base = find_replacement (&XEXP (operands[0], 0));\n \n@@ -785,16 +803,16 @@ rtx operands[];\n \n int\n arm_backwards_branch (from, to)\n-int from, to;\n+     int from, to;\n {\n-  return (insn_addresses[to] <= insn_addresses[from]);\n+  return insn_addresses[to] <= insn_addresses[from];\n }\n \n /* Check to see if a branch is within the distance that can be done using\n    an arithmetic expression. */\n int\n short_branch (from, to)\n-int from, to;\n+     int from, to;\n {\n   int delta = insn_addresses[from] + 8 - insn_addresses[to];\n \n@@ -805,21 +823,20 @@ int from, to;\n    code */\n int\n arm_insn_not_targeted (insn)\n-rtx insn;\n+     rtx insn;\n {\n   return insn != arm_target_insn;\n }\n \n \f\n /* Routines to output assembly language.  */\n \n-/* fp_immediate_constant \n-   if the rtx is the correct value then return the string of the number.\n+/* If the rtx is the correct value then return the string of the number.\n    In this way we can ensure that valid double constants are generated even\n    when cross compiling. */\n char *\n fp_immediate_constant (x)\n-rtx (x);\n+     rtx (x);\n {\n   REAL_VALUE_TYPE r;\n   int i;\n@@ -831,6 +848,7 @@ rtx (x);\n   for (i = 0; i < 8; i++)\n     if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n       return strings_fpa[i];\n+\n   abort ();\n }\n \n@@ -858,30 +876,31 @@ print_multi_reg (stream, instr, mask, hat)\n \tfprintf (stream, \"%s\", reg_names[i]);\n \tnot_first = TRUE;\n       }\n+\n   fprintf (stream, \"}%s\\n\", hat ? \"^\" : \"\");\n-} /* print_multi_reg */\n+}\n \n /* Output a 'call' insn. */\n \n char *\n output_call (operands)\n-\trtx operands[];\n+     rtx *operands;\n {\n   /* Handle calls to lr using ip (which may be clobbered in subr anyway). */\n \n   if (REGNO (operands[0]) == 14)\n     {\n       operands[0] = gen_rtx (REG, SImode, 12);\n-      arm_output_asm_insn (\"mov\\t%0, lr\", operands);\n+      output_asm_insn (\"mov\\t%0, lr\", operands);\n     }\n-  arm_output_asm_insn (\"mov\\tlr, pc\", operands);\n-  arm_output_asm_insn (\"mov\\tpc, %0\", operands);\n-  return (\"\");\n-} /* output_call */\n+  output_asm_insn (\"mov\\tlr, pc\", operands);\n+  output_asm_insn (\"mov\\tpc, %0\", operands);\n+  return \"\";\n+}\n \n static int\n eliminate_lr2ip (x)\n-rtx *x;\n+     rtx *x;\n {\n   int something_changed = 0;\n   rtx x0 = *x;\n@@ -915,17 +934,18 @@ rtx *x;\n \n char *\n output_call_mem (operands)\n-\trtx operands[];\n+     rtx *operands;\n {\n   operands[0] = copy_rtx (operands[0]); /* Be ultra careful */\n   /* Handle calls using lr by using ip (which may be clobbered in subr anyway).\n    */\n   if (eliminate_lr2ip (&operands[0]))\n-    arm_output_asm_insn (\"mov\\tip, lr\", operands);\n-  arm_output_asm_insn (\"mov\\tlr, pc\", operands);\n-  arm_output_asm_insn (\"ldr\\tpc, %0\", operands);\n-  return (\"\");\n-} /* output_call */\n+    output_asm_insn (\"mov\\tip, lr\", operands);\n+\n+  output_asm_insn (\"mov\\tlr, pc\", operands);\n+  output_asm_insn (\"ldr\\tpc, %0\", operands);\n+  return \"\";\n+}\n \n \n /* Output a move from arm registers to an fpu registers.\n@@ -934,50 +954,52 @@ output_call_mem (operands)\n \n char *\n output_mov_long_double_fpu_from_arm (operands)\n-     rtx operands[];\n+     rtx *operands;\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[3];\n \n   if (arm_reg0 == 12)\n     abort();\n+\n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n   ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n   \n-  arm_output_asm_insn (\"stmfd\\tsp!, {%0, %1, %2}\", ops);\n-  arm_output_asm_insn (\"ldfe\\t%0, [sp], #12\", operands);\n-  return (\"\");\n-} /* output_mov_long_double_fpu_from_arm */\n+  output_asm_insn (\"stmfd\\tsp!, {%0, %1, %2}\", ops);\n+  output_asm_insn (\"ldfe\\t%0, [sp], #12\", operands);\n+  return \"\";\n+}\n \n /* Output a move from an fpu register to arm registers.\n    OPERANDS[0] is the first registers of an arm register pair.\n    OPERANDS[1] is an fpu register.  */\n \n char *\n output_mov_long_double_arm_from_fpu (operands)\n-     rtx operands[];\n+     rtx *operands;\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[3];\n \n   if (arm_reg0 == 12)\n     abort();\n+\n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n   ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n \n-  arm_output_asm_insn (\"stfe\\t%1, [sp, #-12]!\", operands);\n-  arm_output_asm_insn (\"ldmfd\\tsp!, {%0, %1, %2}\", ops);\n-  return(\"\");\n-} /* output_mov_long_double_arm_from_fpu */\n+  output_asm_insn (\"stfe\\t%1, [sp, #-12]!\", operands);\n+  output_asm_insn (\"ldmfd\\tsp!, {%0, %1, %2}\", ops);\n+  return \"\";\n+}\n \n /* Output a move from arm registers to arm registers of a long double\n    OPERANDS[0] is the destination.\n    OPERANDS[1] is the source.  */\n char *\n output_mov_long_double_arm_from_arm (operands)\n-rtx operands[];\n+     rtx *operands;\n {\n   /* We have to be careful here because the two might overlap */\n   int dest_start = REGNO (operands[0]);\n@@ -991,7 +1013,7 @@ rtx operands[];\n \t{\n \t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n \t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t  output_asm_insn (\"mov\\t%0, %1\", ops);\n \t}\n     }\n   else\n@@ -1000,9 +1022,10 @@ rtx operands[];\n \t{\n \t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n \t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t  output_asm_insn (\"mov\\t%0, %1\", ops);\n \t}\n     }\n+\n   return \"\";\n }\n \n@@ -1013,7 +1036,7 @@ rtx operands[];\n \n char *\n output_mov_double_fpu_from_arm (operands)\n-     rtx operands[];\n+     rtx *operands;\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[2];\n@@ -1022,38 +1045,39 @@ output_mov_double_fpu_from_arm (operands)\n     abort();\n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n-  arm_output_asm_insn (\"stmfd\\tsp!, {%0, %1}\", ops);\n-  arm_output_asm_insn (\"ldfd\\t%0, [sp], #8\", operands);\n-  return (\"\");\n-} /* output_mov_double_fpu_from_arm */\n+  output_asm_insn (\"stmfd\\tsp!, {%0, %1}\", ops);\n+  output_asm_insn (\"ldfd\\t%0, [sp], #8\", operands);\n+  return \"\";\n+}\n \n /* Output a move from an fpu register to arm registers.\n    OPERANDS[0] is the first registers of an arm register pair.\n    OPERANDS[1] is an fpu register.  */\n \n char *\n output_mov_double_arm_from_fpu (operands)\n-     rtx operands[];\n+     rtx *operands;\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[2];\n \n   if (arm_reg0 == 12)\n     abort();\n+\n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n-  arm_output_asm_insn (\"stfd\\t%1, [sp, #-8]!\", operands);\n-  arm_output_asm_insn (\"ldmfd\\tsp!, {%0, %1}\", ops);\n-  return(\"\");\n-} /* output_mov_double_arm_from_fpu */\n+  output_asm_insn (\"stfd\\t%1, [sp, #-8]!\", operands);\n+  output_asm_insn (\"ldmfd\\tsp!, {%0, %1}\", ops);\n+  return \"\";\n+}\n \n /* Output a move between double words.\n    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM\n    or MEM<-REG and all MEMs must be offsettable addresses.  */\n \n char *\n output_move_double (operands)\n-     rtx operands[];\n+     rtx *operands;\n {\n   enum rtx_code code0 = GET_CODE (operands[0]);\n   enum rtx_code code1 = GET_CODE (operands[1]);\n@@ -1069,18 +1093,19 @@ output_move_double (operands)\n \t  int reg1 = REGNO (operands[1]);\n \t  if (reg1 == 12)\n \t    abort();\n+\n \t  otherops[1] = gen_rtx (REG, SImode, 1 + reg1);\n \n \t  /* Ensure the second source is not overwritten */\n \t  if (reg0 == 1 + reg1)\n \t    {\n-\t      arm_output_asm_insn(\"mov\\t%0, %1\", otherops);\n-\t      arm_output_asm_insn(\"mov\\t%0, %1\", operands);\n+\t      output_asm_insn(\"mov\\t%0, %1\", otherops);\n+\t      output_asm_insn(\"mov\\t%0, %1\", operands);\n \t    }\n \t  else\n \t    {\n-\t      arm_output_asm_insn(\"mov\\t%0, %1\", operands);\n-\t      arm_output_asm_insn(\"mov\\t%0, %1\", otherops);\n+\t      output_asm_insn(\"mov\\t%0, %1\", operands);\n+\t      output_asm_insn(\"mov\\t%0, %1\", otherops);\n \t    }\n \t}\n       else if (code1 == CONST_DOUBLE)\n@@ -1099,9 +1124,9 @@ output_move_double (operands)\n \t  /* Note: output_mov_immediate may clobber operands[1], so we\n \t     put this out first */\n \t  if (INTVAL (operands[1]) < 0)\n-\t    arm_output_asm_insn (\"mvn\\t%0, %1\", otherops);\n+\t    output_asm_insn (\"mvn\\t%0, %1\", otherops);\n \t  else\n-\t    arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t    output_asm_insn (\"mov\\t%0, %1\", otherops);\n \t  output_mov_immediate (operands, FALSE, \"\");\n \t}\n       else if (code1 == MEM)\n@@ -1112,39 +1137,39 @@ output_move_double (operands)\n \t      /* Handle the simple case where address is [r, #0] more\n \t\t efficient.  */\n \t      operands[1] = XEXP (operands[1], 0);\n-\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n \t      break;\n   \t    case PRE_INC:\n \t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      arm_output_asm_insn (\"add\\t%1, %1, #8\", operands);\n-\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"add\\t%1, %1, #8\", operands);\n+\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n \t      break;\n \t    case PRE_DEC:\n \t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      arm_output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n-\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n+\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n \t      break;\n \t    case POST_INC:\n \t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      arm_output_asm_insn (\"ldmia\\t%1!, %M0\", operands);\n+\t      output_asm_insn (\"ldmia\\t%1!, %M0\", operands);\n \t      break;\n \t    case POST_DEC:\n \t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n-\t      arm_output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n+\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n \t      break;\n \t    default:\n \t      otherops[1] = adj_offsettable_operand (operands[1], 4);\n \t      /* Take care of overlapping base/data reg.  */\n \t      if (reg_mentioned_p (operands[0], operands[1]))\n \t\t{\n-\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", otherops);\n-\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", operands);\n+\t\t  output_asm_insn (\"ldr\\t%0, %1\", otherops);\n+\t\t  output_asm_insn (\"ldr\\t%0, %1\", operands);\n \t\t}\n \t      else\n \t\t{\n-\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", operands);\n-\t\t  arm_output_asm_insn (\"ldr\\t%0, %1\", otherops);\n+\t\t  output_asm_insn (\"ldr\\t%0, %1\", operands);\n+\t\t  output_asm_insn (\"ldr\\t%0, %1\", otherops);\n \t\t}\n \t    }\n \t}\n@@ -1158,32 +1183,32 @@ output_move_double (operands)\n         {\n \tcase REG:\n \t  operands[0] = XEXP (operands[0], 0);\n-\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n \t  break;\n         case PRE_INC:\n \t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  arm_output_asm_insn (\"add\\t%0, %0, #8\", operands);\n-\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"add\\t%0, %0, #8\", operands);\n+\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n \t  break;\n         case PRE_DEC:\n \t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  arm_output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n-\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n+\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n \t  break;\n         case POST_INC:\n \t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  arm_output_asm_insn (\"stmia\\t%0!, %M1\", operands);\n+\t  output_asm_insn (\"stmia\\t%0!, %M1\", operands);\n \t  break;\n         case POST_DEC:\n \t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n-\t  arm_output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n+\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n \t  break;\n         default:\n \t  otherops[0] = adj_offsettable_operand (operands[0], 4);\n \t  otherops[1] = gen_rtx (REG, SImode, 1 + REGNO (operands[1]));\n-\t  arm_output_asm_insn (\"str\\t%1, %0\", operands);\n-\t  arm_output_asm_insn (\"str\\t%1, %0\", otherops);\n+\t  output_asm_insn (\"str\\t%1, %0\", operands);\n+\t  output_asm_insn (\"str\\t%1, %0\", otherops);\n \t}\n     }\n   else abort();  /* Constraints should prevent this */\n@@ -1197,23 +1222,25 @@ output_move_double (operands)\n \n char *\n output_mov_immediate (operands)\n-     rtx operands[2];\n+     rtx *operands;\n {\n-  int n = INTVAL (operands[1]);\n+  HOST_WIDE_INT n = INTVAL (operands[1]);\n   int n_ones = 0;\n   int i;\n \n   /* Try to use one MOV */\n-\n   if (const_ok_for_arm (n))\n-    return (arm_output_asm_insn (\"mov\\t%0, %1\", operands));\n+    {\n+      output_asm_insn (\"mov\\t%0, %1\", operands);\n+      return \"\";\n+    }\n \n   /* Try to use one MVN */\n-\n-  if (const_ok_for_arm(~n))\n+  if (const_ok_for_arm (~n))\n     {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, ~n);\n-      return (arm_output_asm_insn (\"mvn\\t%0, %1\", operands));\n+      operands[1] = GEN_INT (~n);\n+      output_asm_insn (\"mvn\\t%0, %1\", operands);\n+      return \"\";\n     }\n \n   /* If all else fails, make it out of ORRs or BICs as appropriate. */\n@@ -1226,18 +1253,19 @@ output_mov_immediate (operands)\n     output_multi_immediate(operands, \"mvn\\t%0, %1\", \"bic\\t%0, %0, %1\", 1, ~n);\n   else\n     output_multi_immediate(operands, \"mov\\t%0, %1\", \"orr\\t%0, %0, %1\", 1, n);\n-  return(\"\");\n-} /* output_mov_immediate */\n+\n+  return \"\";\n+}\n \n \n /* Output an ADD r, s, #n where n may be too big for one instruction.  If\n    adding zero to one register, output nothing.  */\n \n char *\n output_add_immediate (operands)\n-     rtx operands[3];\n+     rtx *operands;\n {\n-  int n = INTVAL (operands[2]);\n+  HOST_WIDE_INT n = INTVAL (operands[2]);\n \n   if (n != 0 || REGNO (operands[0]) != REGNO (operands[1]))\n     {\n@@ -1248,8 +1276,9 @@ output_add_immediate (operands)\n \toutput_multi_immediate (operands,\n \t\t\t\t\"add\\t%0, %1, %2\", \"add\\t%0, %0, %2\", 2, n);\n     }\n-  return(\"\");\n-} /* output_add_immediate */\n+\n+  return \"\";\n+}\n \n \n /* Output a multiple immediate operation.\n@@ -1261,35 +1290,38 @@ output_add_immediate (operands)\n \n char *\n output_multi_immediate (operands, instr1, instr2, immed_op, n)\n-     rtx operands[];\n+     rtx *operands;\n      char *instr1, *instr2;\n-     int immed_op, n;\n+     int immed_op;\n+     HOST_WIDE_INT n;\n {\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  n &= 0xffffffff;\n+#endif\n+\n   if (n == 0)\n     {\n       operands[immed_op] = const0_rtx;\n-      arm_output_asm_insn (instr1, operands); /* Quick and easy output */\n+      output_asm_insn (instr1, operands); /* Quick and easy output */\n     }\n   else\n     {\n       int i;\n       char *instr = instr1;\n \n       /* Note that n is never zero here (which would give no output) */\n-\n       for (i = 0; i < 32; i += 2)\n \t{\n \t  if (n & (3 << i))\n \t    {\n-\t      operands[immed_op] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t    n & (255 << i));\n-\t      arm_output_asm_insn (instr, operands);\n+\t      operands[immed_op] = GEN_INT (n & (255 << i));\n+\t      output_asm_insn (instr, operands);\n \t      instr = instr2;\n \t      i += 6;\n \t    }\n \t}\n     }\n-  return (\"\");\n+  return \"\";\n } /* output_multi_immediate */\n \n \n@@ -1301,27 +1333,29 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n char *\n arithmetic_instr (op, shift_first_arg)\n      rtx op;\n+     int shift_first_arg;\n {\n   switch (GET_CODE(op))\n     {\n     case PLUS:\n-      return (\"add\");\n+      return \"add\";\n+\n     case MINUS:\n-      if (shift_first_arg)\n-\treturn (\"rsb\");\n-      else\n-\treturn (\"sub\");\n+      return shift_first_arg ? \"rsb\" : \"sub\";\n+\n     case IOR:\n-      return (\"orr\");\n+      return \"orr\";\n+\n     case XOR:\n-      return (\"eor\");\n+      return \"eor\";\n+\n     case AND:\n-      return (\"and\");\n+      return \"and\";\n+\n     default:\n-      abort();\n+      abort ();\n     }\n-  return (\"\");\t\t\t/* stupid cc */\n-} /* arithmetic_instr */\n+}\n \n \n /* Ensure valid constant shifts and return the appropriate shift mnemonic\n@@ -1343,20 +1377,23 @@ shift_instr (op, shift_ptr)\n     case ASHIFT:\n       mnem = \"asl\";\n       break;\n+\n     case ASHIFTRT:\n       mnem = \"asr\";\n       max_shift = 32;\n       break;\n+\n     case LSHIFTRT:\n       mnem = \"lsr\";\n       max_shift = 32;\n       break;\n+\n     case MULT:\n-      *shift_ptr = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t    int_log2 (INTVAL (*shift_ptr)));\n-      return (\"asl\");\n+      *shift_ptr = GEN_INT (int_log2 (INTVAL (*shift_ptr)));\n+      return \"asl\";\n+\n     default:\n-      abort();\n+      abort ();\n     }\n \n   if (GET_CODE (*shift_ptr) == CONST_INT)\n@@ -1374,20 +1411,21 @@ shift_instr (op, shift_ptr)\n \n /* Obtain the shift from the POWER of two. */\n \n-int\n+HOST_WIDE_INT\n int_log2 (power)\n-     unsigned int power;\n+     HOST_WIDE_INT power;\n {\n-  int shift = 0;\n+  HOST_WIDE_INT shift = 0;\n \n   while (((1 << shift) & power) == 0)\n     {\n       if (shift > 31)\n-\tabort();\n+\tabort ();\n       shift++;\n     }\n-  return (shift);\n-} /* int_log2 */\n+\n+  return shift;\n+}\n \n \n /* Output an arithmetic instruction which may set the condition code.\n@@ -1400,16 +1438,17 @@ int_log2 (power)\n \n char *\n output_arithmetic (operands, const_first_arg, set_cond)\n-     rtx operands[4];\n+     rtx *operands;\n      int const_first_arg;\n      int set_cond;\n {\n   char mnemonic[80];\n   char *instr = arithmetic_instr (operands[1], const_first_arg);\n \n   sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%3\", instr, set_cond ? \"s\" : \"\");\n-  return (arm_output_asm_insn (mnemonic, operands));\n-} /* output_arithmetic */\n+  output_asm_insn (mnemonic, operands);\n+  return \"\";\n+}\n \n \n /* Output an arithmetic instruction with a shift.\n@@ -1424,7 +1463,7 @@ output_arithmetic (operands, const_first_arg, set_cond)\n \n char *\n output_arithmetic_with_shift (operands, shift_first_arg, set_cond)\n-     rtx operands[6];\n+     rtx *operands;\n      int shift_first_arg;\n      int set_cond;\n {\n@@ -1434,9 +1473,9 @@ output_arithmetic_with_shift (operands, shift_first_arg, set_cond)\n   char *shift = shift_instr (GET_CODE (operands[3]), &operands[5]);\n \n   sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%4, %s %%5\", instr, condbit, shift);\n-  return (arm_output_asm_insn (mnemonic, operands));\n-} /* output_arithmetic_with_shift */\n-\n+  output_asm_insn (mnemonic, operands);\n+  return \"\";\n+}\n \n /* Output an arithmetic instruction with a power of two multiplication.\n    OPERANDS[0] is the destination register.\n@@ -1448,16 +1487,17 @@ output_arithmetic_with_shift (operands, shift_first_arg, set_cond)\n \n char *\n output_arithmetic_with_immediate_multiply (operands, shift_first_arg)\n-     rtx operands[5];\n+     rtx *operands;\n      int shift_first_arg;\n {\n   char mnemonic[80];\n   char *instr = arithmetic_instr (operands[1], shift_first_arg);\n-  int shift = int_log2 (INTVAL (operands[4]));\n+  HOST_WIDE_INT shift = int_log2 (INTVAL (operands[4]));\n \n-  sprintf (mnemonic, \"%s\\t%%0, %%2, %%3, asl#%d\", instr, shift);\n-  return (arm_output_asm_insn (mnemonic, operands));\n-} /* output_arithmetic_with_immediate_multiply */\n+  sprintf (mnemonic, \"%s\\t%%0, %%2, %%3, asl#%d\", instr, (int) shift);\n+  output_asm_insn (mnemonic, operands);\n+  return \"\";\n+}\n \n \n /* Output a move with a shift.\n@@ -1469,7 +1509,7 @@ output_arithmetic_with_immediate_multiply (operands, shift_first_arg)\n char *\n output_shifted_move (op, operands)\n      enum rtx_code op;\n-     rtx operands[2];\n+     rtx *operands;\n {\n   char mnemonic[80];\n \n@@ -1478,13 +1518,15 @@ output_shifted_move (op, operands)\n   else\n     sprintf (mnemonic, \"mov\\t%%0, %%1, %s %%2\",\n \t     shift_instr (op, &operands[2]));\n-  return (arm_output_asm_insn (mnemonic, operands));\n-} /* output_shifted_move */\n+\n+  output_asm_insn (mnemonic, operands);\n+  return \"\";\n+}\n \n char *\n output_shift_compare (operands, neg)\n-rtx *operands;\n-int neg;\n+     rtx *operands;\n+     int neg;\n {\n   char buf[80];\n \n@@ -1494,8 +1536,9 @@ int neg;\n   else\n     sprintf (buf, \"cmp\\t%%1, %%3, %s %%4\", shift_instr (GET_CODE (operands[2]),\n \t\t\t\t\t\t\t&operands[4]));\n-  return arm_output_asm_insn (buf, operands);\n-} /* output_shift_compare */\n+  output_asm_insn (buf, operands);\n+  return \"\";\n+}\n \n /* Output a .ascii pseudo-op, keeping track of lengths.  This is because\n    /bin/as is horribly restrictive.  */\n@@ -1529,6 +1572,7 @@ output_ascii_pseudo_op (stream, p, len)\n \t  putc('\\\\', stream);\n \t  len_so_far++;\n \t}\n+\n       if (c >= ' ' && c < 0177)\n \t{\n \t  putc (c, stream);\n@@ -1539,11 +1583,13 @@ output_ascii_pseudo_op (stream, p, len)\n \t  fprintf (stream, \"\\\\%03o\", c);\n \t  len_so_far +=4;\n \t}\n+\n       chars_so_far++;\n     }\n+\n   fputs (\"\\\"\\n\", stream);\n   arm_increase_location (chars_so_far);\n-} /* output_ascii_pseudo_op */\n+}\n \f\n \n /* Try to determine whether a pattern really clobbers the link register.\n@@ -1556,7 +1602,7 @@ output_ascii_pseudo_op (stream, p, len)\n \n static int\n pattern_really_clobbers_lr (x)\n-rtx x;\n+     rtx x;\n {\n   int i;\n   \n@@ -1567,42 +1613,51 @@ rtx x;\n \t{\n \tcase REG:\n \t  return REGNO (SET_DEST (x)) == 14;\n+\n         case SUBREG:\n \t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == REG)\n \t    return REGNO (XEXP (SET_DEST (x), 0)) == 14;\n+\n \t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == MEM)\n \t    return 0;\n \t  abort ();\n+\n         default:\n \t  return 0;\n         }\n+\n     case PARALLEL:\n       for (i = 0; i < XVECLEN (x, 0); i++)\n \tif (pattern_really_clobbers_lr (XVECEXP (x, 0, i)))\n \t  return 1;\n       return 0;\n+\n     case CLOBBER:\n       switch (GET_CODE (XEXP (x, 0)))\n         {\n \tcase REG:\n \t  return REGNO (XEXP (x, 0)) == 14;\n+\n         case SUBREG:\n \t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n \t    return REGNO (XEXP (XEXP (x, 0), 0)) == 14;\n \t  abort ();\n+\n         default:\n \t  return 0;\n         }\n+\n     case UNSPEC:\n       return 1;\n+\n     default:\n       return 0;\n     }\n }\n \n static int\n function_really_clobbers_lr (first)\n-rtx first;\n+     rtx first;\n {\n   rtx insn, next;\n   \n@@ -1616,31 +1671,37 @@ rtx first;\n \tcase JUMP_INSN:\t\t/* Jump insns only change the PC (and conds) */\n \tcase INLINE_HEADER:\n \t  break;\n+\n         case INSN:\n \t  if (pattern_really_clobbers_lr (PATTERN (insn)))\n \t    return 1;\n \t  break;\n+\n         case CALL_INSN:\n \t  /* Don't yet know how to handle those calls that are not to a \n \t     SYMBOL_REF */\n \t  if (GET_CODE (PATTERN (insn)) != PARALLEL)\n \t    abort ();\n+\n \t  switch (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)))\n \t    {\n \t    case CALL:\n \t      if (GET_CODE (XEXP (XEXP (XVECEXP (PATTERN (insn), 0, 0), 0), 0))\n \t\t  != SYMBOL_REF)\n \t\treturn 1;\n \t      break;\n+\n \t    case SET:\n \t      if (GET_CODE (XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn),\n \t\t\t\t\t\t\t  0, 0)), 0), 0))\n \t\t  != SYMBOL_REF)\n \t\treturn 1;\n \t      break;\n+\n \t    default:\t/* Don't recognize it, be safe */\n \t      return 1;\n \t    }\n+\n \t  /* A call can be made (by peepholing) not to clobber lr iff it is\n \t     followed by a return.  There may, however, be a use insn iff\n \t     we are returning the result of the call. \n@@ -1650,60 +1711,67 @@ rtx first;\n \t     must reject this.  (Can this be fixed by adding our own insn?) */\n \t  if ((next = next_nonnote_insn (insn)) == NULL)\n \t    return 1;\n+\n \t  if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == USE\n \t      && (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n \t      && (REGNO (SET_DEST (XVECEXP (PATTERN (insn), 0, 0)))\n \t\t  == REGNO (XEXP (PATTERN (next), 0))))\n \t    if ((next = next_nonnote_insn (next)) == NULL)\n \t      return 1;\n+\n \t  if (GET_CODE (next) == JUMP_INSN\n \t      && GET_CODE (PATTERN (next)) == RETURN)\n \t    break;\n \t  return 1;\n+\n         default:\n \t  abort ();\n         }\n     }\n+\n   /* We have reached the end of the chain so lr was _not_ clobbered */\n   return 0;\n }\n \n char *\n output_return_instruction (operand, really_return)\n-rtx operand;\n-int really_return;\n+     rtx operand;\n+     int really_return;\n {\n   char instr[100];\n   int reg, live_regs = 0;\n \n-  if (current_function_calls_alloca && !really_return)\n+  if (current_function_calls_alloca && ! really_return)\n     abort();\n     \n-  for (reg = 4; reg < 10; reg++)\n-    if (regs_ever_live[reg])\n+  for (reg = 0; reg <= 10; reg++)\n+    if (regs_ever_live[reg] && ! call_used_regs[reg])\n       live_regs++;\n \n-  if (live_regs || (regs_ever_live[14] && !lr_save_eliminated))\n+  if (live_regs || (regs_ever_live[14] && ! lr_save_eliminated))\n     live_regs++;\n \n   if (frame_pointer_needed)\n     live_regs += 4;\n \n   if (live_regs)\n     {\n-      if (lr_save_eliminated || !regs_ever_live[14])\n+      if (lr_save_eliminated || ! regs_ever_live[14])\n         live_regs++;\n+\n       if (frame_pointer_needed)\n         strcpy (instr, \"ldm%d0ea\\tfp, {\");\n       else\n         strcpy (instr, \"ldm%d0fd\\tsp!, {\");\n-      for (reg = 4; reg < 10; reg++)\n-        if (regs_ever_live[reg])\n+\n+      for (reg = 0; reg <= 10; reg++)\n+        if (regs_ever_live[reg] && ! call_used_regs[reg])\n           {\n             strcat (instr, reg_names[reg]);\n \t    if (--live_regs)\n               strcat (instr, \", \");\n           }\n+\n       if (frame_pointer_needed)\n         {\n           strcat (instr, reg_names[11]);\n@@ -1715,17 +1783,61 @@ int really_return;\n       else\n         strcat (instr, really_return ? reg_names[15] : reg_names[14]);\n       strcat (instr, (TARGET_6 || !really_return) ? \"}\" : \"}^\");\n-      arm_output_asm_insn (instr, &operand);\n+      output_asm_insn (instr, &operand);\n     }\n   else if (really_return)\n     {\n       strcpy (instr, TARGET_6 ? \"mov%d0\\tpc, lr\" : \"mov%d0s\\tpc, lr\");\n-      arm_output_asm_insn (instr, &operand);\n+      output_asm_insn (instr, &operand);\n     }\n+\n   return_used_this_function = 1;\n   return \"\";\n }\n \n+/* Return the size of the prologue.  It's not too bad if we slightly \n+   over-estimate.  */\n+\n+static int\n+get_prologue_size ()\n+{\n+  int amount = 0;\n+  int regno;\n+\n+  /* Until we know which registers are really used return the maximum.  */\n+  if (! reload_completed)\n+    return 24;\n+\n+  /* Look for integer regs that have to be saved. */\n+  for (regno = 0; regno < 15; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tamount = 4;\n+\tbreak;\n+      }\n+\n+  /* Clobbering lr when none of the other regs have been saved also requires\n+     a save.  */\n+  if (regs_ever_live[14])\n+    amount = 4;\n+\n+  /* If we need to push a stack frame then there is an extra instruction to\n+     preserve the current value of the stack pointer. */\n+  if (frame_pointer_needed)\n+    amount = 8;\n+\n+  /* Now look for floating-point regs that need saving.  We need an \n+     instruction per register.  */\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      amount += 4;\n+\n+  if (current_function_anonymous_args && current_function_pretend_args_size)\n+    amount += 4;\n+\n+  return amount;\n+}\n+\n /* The amount of stack adjustment that happens here, in output_return and in\n    output_epilogue must be exactly the same as was calculated during reload,\n    or things will point to the wrong place.  The only time we can safely\n@@ -1736,11 +1848,11 @@ int really_return;\n    onto the stack. */\n    \n void\n-output_prologue (f, frame_size)\n+output_func_prologue (f, frame_size)\n      FILE *f;\n      int frame_size;\n {\n-  int reg, live_regs_mask = 0, code_size = 0;\n+  int reg, live_regs_mask = 0;\n   rtx operands[3];\n \n   /* Nonzero if we must stuff some register arguments onto the stack as if\n@@ -1762,20 +1874,19 @@ output_prologue (f, frame_size)\n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n-  for (reg = 4; reg < 10; reg++)\n-    if (regs_ever_live[reg])\n+  for (reg = 0; reg <= 10; reg++)\n+    if (regs_ever_live[reg] && ! call_used_regs[reg])\n       live_regs_mask |= (1 << reg);\n \n   if (frame_pointer_needed)\n     {\n       live_regs_mask |= 0xD800;\n       fputs (\"\\tmov\\tip, sp\\n\", f);\n-      code_size += 4;\n     }\n   else if (regs_ever_live[14])\n     {\n       if (! current_function_args_size\n-\t  && !function_really_clobbers_lr (get_insns ()))\n+\t  && ! function_really_clobbers_lr (get_insns ()))\n \t{\n \t  fprintf (f,\"\\t@ I don't think this function clobbers lr\\n\");\n \t  lr_save_eliminated = 1;\n@@ -1798,7 +1909,6 @@ output_prologue (f, frame_size)\n \t       arg_size > 0; reg--, arg_size -= 4)\n \t    mask |= (1 << reg);\n \t  print_multi_reg (f, \"stmfd\\tsp!\", mask, FALSE);\n-\t  code_size += 4;\n \t}\n       else\n \t{\n@@ -1818,41 +1928,36 @@ output_prologue (f, frame_size)\n \n       live_regs_mask |= 0x4000;\n       lr_save_eliminated = 0;\n+\n+      /* Now push all the call-saved regs onto the stack */\n       print_multi_reg (f, \"stmfd\\tsp!\", live_regs_mask, FALSE);\n-      code_size += 4;\n     }\n \n-  for (reg = 23; reg > 19; reg--)\n-    if (regs_ever_live[reg])\n-      {\n-\tfprintf (f, \"\\tstfe\\t%s, [sp, #-12]!\\n\", reg_names[reg]);\n-\tcode_size += 4;\n-      }\n+  for (reg = 23; reg > 15; reg--)\n+    if (regs_ever_live[reg] && !call_used_regs[reg])\n+      fprintf (f, \"\\tstfe\\t%s, [sp, #-12]!\\n\", reg_names[reg]);\n \n   if (frame_pointer_needed)\n     {\n       /* Make `fp' point to saved value of `pc'. */\n \n       operands[0] = gen_rtx (REG, SImode, HARD_FRAME_POINTER_REGNUM);\n       operands[1] = gen_rtx (REG, SImode, 12);\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     - (4 + current_function_pretend_args_size));\n+      operands[2] = GEN_INT ( - (4 + current_function_pretend_args_size));\n       output_add_immediate (operands);\n     }\n \n   if (frame_size)\n     {\n       operands[0] = operands[1] = stack_pointer_rtx;\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode, -frame_size);\n+      operands[2] = GEN_INT (-frame_size);\n       output_add_immediate (operands);\n     }\n-\n-  arm_increase_location (code_size);\n-} /* output_prologue */\n+}\n \n \n void\n-output_epilogue (f, frame_size)\n+output_func_epilogue (f, frame_size)\n      FILE *f;\n      int frame_size;\n {\n@@ -1867,21 +1972,20 @@ output_epilogue (f, frame_size)\n         {\n           abort ();\n         }\n-      return;\n+      goto epilogue_done;\n     }\n \n-  for (reg = 4; reg <= 10; reg++)\n-    if (regs_ever_live[reg])\n+  for (reg = 0; reg <= 10; reg++)\n+    if (regs_ever_live[reg] && ! call_used_regs[reg])\n       {\n         live_regs_mask |= (1 << reg);\n \tfloats_offset += 4;\n       }\n \n-\n   if (frame_pointer_needed)\n     {\n-      for (reg = 23; reg >= 20; reg--)\n-\tif (regs_ever_live[reg])\n+      for (reg = 23; reg > 15; reg--)\n+\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n \t  {\n \t    fprintf (f, \"\\tldfe\\t%s, [fp, #-%d]\\n\", reg_names[reg],\n \t\t     floats_offset);\n@@ -1904,8 +2008,8 @@ output_epilogue (f, frame_size)\n \t  output_add_immediate (operands);\n \t}\n \n-      for (reg = 20; reg < 24; reg++)\n-\tif (regs_ever_live[reg])\n+      for (reg = 16; reg < 24; reg++)\n+\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n \t  {\n \t    fprintf (f, \"\\tldfe\\t%s, [sp], #12\\n\", reg_names[reg]);\n \t    code_size += 4;\n@@ -1935,9 +2039,18 @@ output_epilogue (f, frame_size)\n \t  code_size += 4;\n \t}\n     }\n-  arm_increase_location (code_size);\n+\n+ epilogue_done:\n+\n+  /* insn_addresses isn't allocated when not optimizing */\n+\n+  if (optimize > 0)\n+    arm_increase_location (code_size\n+\t\t\t   + insn_addresses[INSN_UID (get_last_insn ())]\n+\t\t\t   + get_prologue_size ());\n+\n   current_function_anonymous_args = 0;\n-} /* output_epilogue */\n+}\n \f\n /* Increase the `arm_text_location' by AMOUNT if we're in the text\n    segment.  */\n@@ -1948,26 +2061,7 @@ arm_increase_location (amount)\n {\n   if (in_text_section ())\n     arm_text_location += amount;\n-} /* arm_increase_location */\n-\n-\n-/* Like output_asm_insn (), but also increases the arm_text_location (if in\n-   the .text segment, of course, even though this will always be true).\n-   Returns the empty string.  */\n-\n-char *\n-arm_output_asm_insn (template, operands)\n-     char *template;\n-     rtx *operands;\n-{\n-  extern FILE *asm_out_file;\n-\n-  output_asm_insn (template, operands);\n-  if (in_text_section ())\n-    arm_text_location += 4;\n-  fflush (asm_out_file);\n-  return (\"\");\n-} /* arm_output_asm_insn */\n+}\n \n \n /* Output a label definition.  If this label is within the .text segment, it\n@@ -2003,91 +2097,38 @@ arm_asm_output_label (stream, name)\n     }\n   for (s = real_name; *s; s++)\n     hash += *s;\n+\n   hash = hash % LABEL_HASH_SIZE;\n   cur = (struct label_offset *) xmalloc (sizeof (struct label_offset));\n   cur->name = real_name;\n   cur->offset = arm_text_location;\n   cur->cdr = offset_table[hash];\n   offset_table[hash] = cur;\n-} /* arm_asm_output_label */\n-\n-\n-/* Output the instructions needed to perform what Martin's /bin/as called\n-   llc: load an SImode thing from the function's constant pool.\n+}\n \n-   XXX This could be enhanced in that we do not really need a pointer in the\n-   constant pool pointing to the real thing.  If we can address this pointer,\n-   we can also address what it is pointing at, in fact, anything in the text\n-   segment which has been defined already within this .s file.  */\n+/* Load a symbol that is known to be in the text segment into a register.\n+   This should never be called when not optimizing.  */\n \n char *\n-arm_output_llc (operands)\n+output_load_symbol (insn, operands)\n+     rtx insn;\n      rtx *operands;\n {\n-  char *s, *name = XSTR (XEXP (operands[1], 0), 0);\n-  struct label_offset *he;\n-  int hash = 0, conditional = (arm_ccfsm_state == 3 || arm_ccfsm_state == 4);\n-\n-  if (*name != '*')\n-    abort ();\n-\n-  for (s = &name[1]; *s; s++)\n-    hash += *s;\n-  hash = hash % LABEL_HASH_SIZE;\n-  he = offset_table[hash];\n-  while (he && strcmp (he->name, &name[1]))\n-    he = he->cdr;\n-\n-  if (!he)\n-    abort ();\n-\n-  if (arm_text_location + 8 - he->offset < 4095)\n-    {\n-      fprintf (asm_out_file, \"\\tldr%s\\t%s, [pc, #%s - . - 8]\\n\",\n-\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n-\t       reg_names[REGNO (operands[0])], &name[1]);\n-      arm_increase_location (4);\n-      return (\"\");\n-    }\n-  else\n-    {\n-      int offset = - (arm_text_location + 8 - he->offset);\n-      char *reg_name = reg_names[REGNO (operands[0])];\n-\n-      /* ??? This is a hack, assuming the constant pool never is more than\n-\t (1 + 255) * 4096 == 1Meg away from the PC.  */\n-\n-      if (offset > 1000000)\n-\tabort ();\n-\n-      fprintf (asm_out_file, \"\\tsub%s\\t%s, pc, #(8 + . - %s) & ~4095\\n\",\n-\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n-\t       reg_name, &name[1]);\n-      fprintf (asm_out_file, \"\\tldr%s\\t%s, [%s, #- ((4 + . - %s) & 4095)]\\n\",\n-\t       conditional ? arm_condition_codes[arm_current_cc] : \"\",\n-\t       reg_name, reg_name, &name[1]);\n-      arm_increase_location (8);\n-    }\n-  return (\"\");\n-} /* arm_output_llc */\n-\n-/* output_load_symbol ()\n-   load a symbol that is known to be in the text segment into a register */\n-\n-char *\n-output_load_symbol (operands)\n-rtx *operands;\n-{\n-  char *s, *name = XSTR (operands[1], 0);\n+  char *s;\n+  char *name = XSTR (operands[1], 0);\n   struct label_offset *he;\n   int hash = 0;\n   int offset;\n-  \n-  if (*name != '*')\n+  unsigned int mask, never_mask = 0xffffffff;\n+  int shift, inst;\n+  char buffer[100];\n+\n+  if (optimize == 0 || *name != '*')\n     abort ();\n \n   for (s = &name[1]; *s; s++)\n     hash += *s;\n+\n   hash = hash % LABEL_HASH_SIZE;\n   he = offset_table[hash];\n   while (he && strcmp (he->name, &name[1]))\n@@ -2096,45 +2137,48 @@ rtx *operands;\n   if (!he)\n     abort ();\n   \n-  offset = (arm_text_location + 8 - he->offset);\n+  offset = (arm_text_location + insn_addresses[INSN_UID (insn)]\n+\t    + get_prologue_size () + 8 - he->offset);\n   if (offset < 0)\n     abort ();\n \n+  /* When generating the instructions, we never mask out the bits that we\n+     think will be always zero, then if a mistake has occureed somewhere, the\n+     assembler will spot it and generate an error.  */\n+\n   /* If the symbol is word aligned then we might be able to reduce the\n-     number of loads */\n-  if ((offset & 3) == 0)\n+     number of loads.  */\n+  shift = ((offset & 3) == 0) ? 2 : 0;\n+\n+  /* Clear the bits from NEVER_MASK that will be orred in with the individual\n+     instructions.  */\n+  for (; shift < 32; shift += 8)\n     {\n-      arm_output_asm_insn (\"sub\\t%0, pc, #(8 + . -%a1) & 1023\", operands);\n-      if (offset > 0x3ff)\n-        {\n-\t  arm_output_asm_insn (\"sub\\t%0, %0, #(4 + . -%a1) & 261120\",\n-\t\t\t       operands);\n-\t  if (offset > 0x3ffff)\n-\t    {\n-\t      arm_output_asm_insn (\"sub\\t%0, %0, #(. -%a1) & 66846720\",\n-\t\t\t\t   operands);\n-\t      if (offset > 0x3ffffff)\n-\t\tarm_output_asm_insn (\"sub\\t%0, %0, #(. - 4 -%a1) & -67108864\",\n-\t\t\t\t       operands);\n-\t    }\n-        }\n+      mask = 0xff << shift;\n+      if ((offset & mask) || ((unsigned) offset) > mask)\n+\tnever_mask &= ~mask;\n     }\n-  else\n+\n+  inst = 8;\n+  mask = 0xff << (shift - 32);\n+\n+  while (mask && (never_mask & mask) == 0)\n     {\n-      arm_output_asm_insn (\"sub\\t%0, pc, #(8 + . -%a1) & 255\", operands);\n-      if (offset > 0x0ff)\n-        {\n-\t  arm_output_asm_insn (\"sub\\t%0, %0, #(4 + . -%a1) & 65280\", operands);\n-\t  if (offset > 0x0ffff)\n-\t    {\n-\t      arm_output_asm_insn (\"sub\\t%0, %0, #(. -%a1) & 16711680\",\n-\t\t\t\t   operands);\n-\t      if (offset > 0x0ffffff)\n-\t\tarm_output_asm_insn (\"sub\\t%0, %0, #(. - 4 -%a1) & -16777216\",\n-\t\t\t\t     operands);\n-\t    }\n-        }\n+      if (inst == 8)\n+\t{\n+\t  strcpy (buffer, \"sub\\t%0, pc, #(8 + . -%a1)\");\n+\t  if ((never_mask | mask) != 0xffffffff)\n+\t    sprintf (buffer + strlen (buffer), \" & 0x%x\", mask | never_mask);\n+\t}\n+      else\n+\tsprintf (buffer, \"sub\\t%%0, %%0, #(%d + . -%%a1) & 0x%x\",\n+\t\t inst, mask | never_mask);\n+\n+      output_asm_insn (buffer, operands);\n+      mask <<= 8;\n+      inst -= 4;\n     }\n+\n   return \"\";\n }\n \n@@ -2158,7 +2202,7 @@ output_lcomm_directive (stream, name, size, rounded)\n     fputs (\"\\n\\t.text\\n\", stream);\n   else\n     fputs (\"\\n\\t.data\\n\", stream);\n-} /* output_lcomm_directive */\n+}\n \f\n /* A finite state machine takes care of noticing whether or not instructions\n    can be conditionally executed, and thus decrease execution time and code\n@@ -2224,7 +2268,7 @@ get_arm_condition_code (comparison)\n     }\n   /*NOTREACHED*/\n   return (42);\n-} /* get_arm_condition_code */\n+}\n \n \n void\n@@ -2526,6 +2570,6 @@ final_prescan_insn (insn, opvec, noperands)\n \t call recog direct). */\n       recog (PATTERN (insn), insn, NULL_PTR);\n     }\n-} /* final_prescan_insn */\n+}\n \n /* EOF */"}]}