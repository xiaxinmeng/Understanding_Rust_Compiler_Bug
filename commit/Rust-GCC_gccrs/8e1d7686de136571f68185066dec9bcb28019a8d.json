{"sha": "8e1d7686de136571f68185066dec9bcb28019a8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxZDc2ODZkZTEzNjU3MWY2ODE4NTA2NmRlYzliY2IyODAxOWE4ZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-19T15:42:55Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-19T15:42:55Z"}, "message": "re PR libfortran/32972 (performance of pack/unpack)\n\n2008-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\t* Makefile.am (in_pack_c): Add in_pack_i1.c, in_pack_i2.c,\n\tin_pack_r4.c, in_pack_r8.c, in_pack_r10.c and in_pack_r16.c.\n\t(in_unpack_c): Add in_unpack_i1.c, in_unpack_i2.c,\n\tin_unpack_r4.c, in_unpack_r8.c, in_unpack_r10.c and\n\tin_unpack_r16.c.\n\t* Makefile.in: Regenerate.\n\t* libgfortran.h:  Add prototypes for internal_pack_1,\n\tinternal_pack_2, internal_pack_16, internal_pack_r4,\n\tinternal_pack_r8, internal_pack_r10, internal_pack_r16,\n\tinternal_pack_c10 and internal_pack_c16.  Add prototypes for\n\tinternal_unpack_1, internal_unpack_2, internal_unpack_16,\n\tinternal_unpack_r4, internal_unpack_r8, internal_unpack_r10,\n\tinternal_unpack_r16, internal_unpack_c10 and\n\tinternal_unpack_c16.\n\t* runtime/in_pack_generic.c (internal_pack): Use sizeof instead\n\tof hardwired sizes.\n\tAdd calls to internal_pack_1, internal_pack_2,\n\tinternal_pack_16, internal_pack_r4, internal_pack_r8,\n\tinternal_pack_r10, internal_pack_r16, internal_pack_c10 and\n\tinternal_pack_c16.\n\t* runtime/in_unpack_generic.c (internal_unpack):  Use sizeof\n\tinstead of hardwired sizes.\n\tAdd calls to internal_unpack_1, internal_unpack_2,\n\tinternal_unpack_16, internal_unpack_r4, internal_unpack_r8,\n\tinternal_unpack_r10, internal_unpack_r16, internal_unpack_c10\n\tand internal_unpack_c16.\n\t* generated/in_pack_r4.c:  New file.\n\t* generated/in_pack_i2.c:  New file.\n\t* generated/in_unpack_i1.c:  New file.\n\t* generated/in_pack_r10.c:  New file.\n\t* generated/in_unpack_r4.c:  New file.\n\t* generated/in_unpack_i2.c:  New file.\n\t* generated/in_unpack_r16.c:  New file.\n\t* generated/in_pack_r8.c:  New file.\n\t* generated/in_unpack_r10.c:  New file.\n\t* generated/in_unpack_r8.c:  New file.\n\t* generated/in_pack_r16.c:  New file.\n\t* generated/in_pack_i1.c:  New file.\n\n2008-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\t* gfortran.dg/internal_pack_1.f90:  New test case.\n\t* gfortran.dg/internal_pack_2.f90:  New test case.\n\t* gfortran.dg/internal_pack_3.f90:  New test case.\n\nFrom-SVN: r133344", "tree": {"sha": "370b9d6b0738999469c560cab3acf85bde3ceb2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370b9d6b0738999469c560cab3acf85bde3ceb2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e1d7686de136571f68185066dec9bcb28019a8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1d7686de136571f68185066dec9bcb28019a8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1d7686de136571f68185066dec9bcb28019a8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1d7686de136571f68185066dec9bcb28019a8d/comments", "author": null, "committer": null, "parents": [{"sha": "cd7e0bd4b185112f64b7b78264b0bfa6eb27d26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7e0bd4b185112f64b7b78264b0bfa6eb27d26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7e0bd4b185112f64b7b78264b0bfa6eb27d26b"}], "stats": {"total": 1915, "additions": 1893, "deletions": 22}, "files": [{"sha": "0781ed5e4beb3b8918bf1edca72cad4a881a5470", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -1,3 +1,10 @@\n+2008-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\t* gfortran.dg/internal_pack_1.f90:  New test case.\n+\t* gfortran.dg/internal_pack_2.f90:  New test case.\n+\t* gfortran.dg/internal_pack_3.f90:  New test case.\n+\n 2008-03-19  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/20050811-2.c: Update dumping flags."}, {"sha": "87565bee322803e0f14ade684bfe0b0fbcf76828", "filename": "gcc/testsuite/gfortran.dg/internal_pack_1.f90", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_1.f90?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,85 @@\n+! { dg-do run }\n+! Test that the internal pack and unpack routines work OK\n+! for different data types\n+\n+program main\n+  integer(kind=1), dimension(3) :: i1\n+  integer(kind=2), dimension(3) :: i2\n+  integer(kind=4), dimension(3) :: i4\n+  integer(kind=8), dimension(3) :: i8\n+  real(kind=4), dimension(3) :: r4\n+  real(kind=8), dimension(3) :: r8\n+\n+  i1 = (/ -1, 1, -3 /)\n+  call sub_i1(i1(1:3:2))\n+  if (any(i1 /= (/ 3, 1, 2 /))) call abort\n+\n+  i2 = (/ -1, 1, -3 /)\n+  call sub_i2(i2(1:3:2))\n+  if (any(i2 /= (/ 3, 1, 2 /))) call abort\n+\n+  i4 = (/ -1, 1, -3 /)\n+  call sub_i4(i4(1:3:2))\n+  if (any(i4 /= (/ 3, 1, 2 /))) call abort\n+\n+  i8 = (/ -1, 1, -3 /)\n+  call sub_i8(i8(1:3:2))\n+  if (any(i8 /= (/ 3, 1, 2 /))) call abort\n+\n+  r4 = (/ -1.0, 1.0, -3.0 /)\n+  call sub_r4(r4(1:3:2))\n+  if (any(r4 /= (/ 3.0, 1.0, 2.0/))) call abort\n+\n+  r8 = (/ -1.0_8, 1.0_8, -3.0_8 /)\n+  call sub_r8(r8(1:3:2))\n+  if (any(r8 /= (/ 3.0_8, 1.0_8, 2.0_8/))) call abort\n+\n+end program main\n+\n+subroutine sub_i1(i)\n+  integer(kind=1), dimension(2) :: i\n+  if (i(1) /= -1) call abort\n+  if (i(2) /= -3) call abort\n+  i(1) = 3\n+  i(2) = 2\n+end subroutine sub_i1\n+\n+subroutine sub_i2(i)\n+  integer(kind=2), dimension(2) :: i\n+  if (i(1) /= -1) call abort\n+  if (i(2) /= -3) call abort\n+  i(1) = 3\n+  i(2) = 2\n+end subroutine sub_i2\n+\n+subroutine sub_i4(i)\n+  integer(kind=4), dimension(2) :: i\n+  if (i(1) /= -1) call abort\n+  if (i(2) /= -3) call abort\n+  i(1) = 3\n+  i(2) = 2\n+end subroutine sub_i4\n+\n+subroutine sub_i8(i)\n+  integer(kind=8), dimension(2) :: i\n+  if (i(1) /= -1) call abort\n+  if (i(2) /= -3) call abort\n+  i(1) = 3\n+  i(2) = 2\n+end subroutine sub_i8\n+\n+subroutine sub_r4(r)\n+  real(kind=4), dimension(2) :: r\n+  if (r(1) /= -1.) call abort\n+  if (r(2) /= -3.) call abort\n+  r(1) = 3.\n+  r(2) = 2.\n+end subroutine sub_r4\n+\n+subroutine sub_r8(r)\n+  real(kind=8), dimension(2) :: r\n+  if (r(1) /= -1._8) call abort\n+  if (r(2) /= -3._8) call abort\n+  r(1) = 3._8\n+  r(2) = 2._8\n+end subroutine sub_r8"}, {"sha": "1966e7d05d2f0c86f648b58101e8c7b73271cb68", "filename": "gcc/testsuite/gfortran.dg/internal_pack_2.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_2.f90?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_real }\n+! Test that the internal pack and unpack routines work OK\n+! for our large real type.\n+\n+program main\n+  implicit none\n+  integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+  real(kind=k), dimension(3) :: rk\n+\n+  rk = (/ -1.0_k, 1.0_k, -3.0_k /)\n+  call sub_rk(rk(1:3:2))\n+  if (any(rk /= (/ 3.0_k, 1.0_k, 2.0_k/))) call abort\n+\n+end program main\n+\n+subroutine sub_rk(r)\n+  implicit none\n+  integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+  real(kind=k), dimension(2) :: r\n+  if (r(1) /= -1._k) call abort\n+  if (r(2) /= -3._k) call abort\n+  r(1) = 3._k\n+  r(2) = 2._k\n+end subroutine sub_rk"}, {"sha": "8312e1d22650e9aa10834226dd35aac346559344", "filename": "gcc/testsuite/gfortran.dg/internal_pack_3.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_3.f90?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_int }\n+! Test that the internal pack and unpack routines work OK\n+! for our large integer type.\n+\n+program main\n+  integer,parameter :: k = selected_int_kind (range (0_8) + 1)\n+  integer(kind=k), dimension(3) :: ik\n+\n+  ik = (/ -1, 1, -3 /)\n+  call sub_ik(ik(1:3:2))\n+  if (any(ik /= (/ 3, 1, 2 /))) call abort\n+end program main\n+\n+subroutine sub_ik(i)\n+  integer(kind=k), dimension(2) :: i\n+  if (i(1) /= -1) call abort\n+  if (i(2) /= -3) call abort\n+  i(1) = 3\n+  i(2) = 2\n+end subroutine sub_ik"}, {"sha": "baa99e2af2a8c60b7f9be2c7df75c3e550e49461", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -1,3 +1,45 @@\n+2008-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\t* Makefile.am (in_pack_c): Add in_pack_i1.c, in_pack_i2.c,\n+\tin_pack_r4.c, in_pack_r8.c, in_pack_r10.c and in_pack_r16.c.\n+\t(in_unpack_c): Add in_unpack_i1.c, in_unpack_i2.c,\n+\tin_unpack_r4.c, in_unpack_r8.c, in_unpack_r10.c and\n+\tin_unpack_r16.c.\n+\t* Makefile.in: Regenerate.\n+\t* libgfortran.h:  Add prototypes for internal_pack_1,\n+\tinternal_pack_2, internal_pack_16, internal_pack_r4,\n+\tinternal_pack_r8, internal_pack_r10, internal_pack_r16,\n+\tinternal_pack_c10 and internal_pack_c16.  Add prototypes for\n+\tinternal_unpack_1, internal_unpack_2, internal_unpack_16,\n+\tinternal_unpack_r4, internal_unpack_r8, internal_unpack_r10,\n+\tinternal_unpack_r16, internal_unpack_c10 and\n+\tinternal_unpack_c16.\n+\t* runtime/in_pack_generic.c (internal_pack): Use sizeof instead\n+\tof hardwired sizes.\n+\tAdd calls to internal_pack_1, internal_pack_2,\n+\tinternal_pack_16, internal_pack_r4, internal_pack_r8,\n+\tinternal_pack_r10, internal_pack_r16, internal_pack_c10 and\n+\tinternal_pack_c16.\n+\t* runtime/in_unpack_generic.c (internal_unpack):  Use sizeof\n+\tinstead of hardwired sizes.\n+\tAdd calls to internal_unpack_1, internal_unpack_2,\n+\tinternal_unpack_16, internal_unpack_r4, internal_unpack_r8,\n+\tinternal_unpack_r10, internal_unpack_r16, internal_unpack_c10\n+\tand internal_unpack_c16.\n+\t* generated/in_pack_r4.c:  New file.\n+\t* generated/in_pack_i2.c:  New file.\n+\t* generated/in_unpack_i1.c:  New file.\n+\t* generated/in_pack_r10.c:  New file.\n+\t* generated/in_unpack_r4.c:  New file.\n+\t* generated/in_unpack_i2.c:  New file.\n+\t* generated/in_unpack_r16.c:  New file.\n+\t* generated/in_pack_r8.c:  New file.\n+\t* generated/in_unpack_r10.c:  New file.\n+\t* generated/in_unpack_r8.c:  New file.\n+\t* generated/in_pack_r16.c:  New file.\n+\t* generated/in_pack_i1.c:  New file.\n+\n 2008-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/35617"}, {"sha": "bcf9ffa6510f55964e656d87e7be8be46c3ef74c", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -380,18 +380,30 @@ $(srcdir)/generated/cshift1_8.c \\\n $(srcdir)/generated/cshift1_16.c\n \n in_pack_c = \\\n+$(srcdir)/generated/in_pack_i1.c \\\n+$(srcdir)/generated/in_pack_i2.c \\\n $(srcdir)/generated/in_pack_i4.c \\\n $(srcdir)/generated/in_pack_i8.c \\\n $(srcdir)/generated/in_pack_i16.c \\\n+$(srcdir)/generated/in_pack_r4.c \\\n+$(srcdir)/generated/in_pack_r8.c \\\n+$(srcdir)/generated/in_pack_r10.c \\\n+$(srcdir)/generated/in_pack_r16.c \\\n $(srcdir)/generated/in_pack_c4.c \\\n $(srcdir)/generated/in_pack_c8.c \\\n $(srcdir)/generated/in_pack_c10.c \\\n $(srcdir)/generated/in_pack_c16.c\n \n in_unpack_c = \\\n+$(srcdir)/generated/in_unpack_i1.c \\\n+$(srcdir)/generated/in_unpack_i2.c \\\n $(srcdir)/generated/in_unpack_i4.c \\\n $(srcdir)/generated/in_unpack_i8.c \\\n $(srcdir)/generated/in_unpack_i16.c \\\n+$(srcdir)/generated/in_unpack_r4.c \\\n+$(srcdir)/generated/in_unpack_r8.c \\\n+$(srcdir)/generated/in_unpack_r10.c \\\n+$(srcdir)/generated/in_unpack_r16.c \\\n $(srcdir)/generated/in_unpack_c4.c \\\n $(srcdir)/generated/in_unpack_c8.c \\\n $(srcdir)/generated/in_unpack_c10.c \\"}, {"sha": "2d1ce0d7c1b71143c5be04f733c3ac3c162a919a", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 127, "deletions": 3, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -285,16 +285,28 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/reshape_c8.c \\\n \t$(srcdir)/generated/reshape_c10.c \\\n \t$(srcdir)/generated/reshape_c16.c \\\n+\t$(srcdir)/generated/in_pack_i1.c \\\n+\t$(srcdir)/generated/in_pack_i2.c \\\n \t$(srcdir)/generated/in_pack_i4.c \\\n \t$(srcdir)/generated/in_pack_i8.c \\\n \t$(srcdir)/generated/in_pack_i16.c \\\n+\t$(srcdir)/generated/in_pack_r4.c \\\n+\t$(srcdir)/generated/in_pack_r8.c \\\n+\t$(srcdir)/generated/in_pack_r10.c \\\n+\t$(srcdir)/generated/in_pack_r16.c \\\n \t$(srcdir)/generated/in_pack_c4.c \\\n \t$(srcdir)/generated/in_pack_c8.c \\\n \t$(srcdir)/generated/in_pack_c10.c \\\n \t$(srcdir)/generated/in_pack_c16.c \\\n+\t$(srcdir)/generated/in_unpack_i1.c \\\n+\t$(srcdir)/generated/in_unpack_i2.c \\\n \t$(srcdir)/generated/in_unpack_i4.c \\\n \t$(srcdir)/generated/in_unpack_i8.c \\\n \t$(srcdir)/generated/in_unpack_i16.c \\\n+\t$(srcdir)/generated/in_unpack_r4.c \\\n+\t$(srcdir)/generated/in_unpack_r8.c \\\n+\t$(srcdir)/generated/in_unpack_r10.c \\\n+\t$(srcdir)/generated/in_unpack_r16.c \\\n \t$(srcdir)/generated/in_unpack_c4.c \\\n \t$(srcdir)/generated/in_unpack_c8.c \\\n \t$(srcdir)/generated/in_unpack_c10.c \\\n@@ -592,9 +604,13 @@ am__objects_19 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n am__objects_20 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n \treshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \\\n \treshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo\n-am__objects_21 = in_pack_i4.lo in_pack_i8.lo in_pack_i16.lo \\\n-\tin_pack_c4.lo in_pack_c8.lo in_pack_c10.lo in_pack_c16.lo\n-am__objects_22 = in_unpack_i4.lo in_unpack_i8.lo in_unpack_i16.lo \\\n+am__objects_21 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \\\n+\tin_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \\\n+\tin_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \\\n+\tin_pack_c10.lo in_pack_c16.lo\n+am__objects_22 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \\\n+\tin_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \\\n+\tin_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \\\n \tin_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \\\n \tin_unpack_c16.lo\n am__objects_23 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \\\n@@ -1218,18 +1234,30 @@ $(srcdir)/generated/cshift1_8.c \\\n $(srcdir)/generated/cshift1_16.c\n \n in_pack_c = \\\n+$(srcdir)/generated/in_pack_i1.c \\\n+$(srcdir)/generated/in_pack_i2.c \\\n $(srcdir)/generated/in_pack_i4.c \\\n $(srcdir)/generated/in_pack_i8.c \\\n $(srcdir)/generated/in_pack_i16.c \\\n+$(srcdir)/generated/in_pack_r4.c \\\n+$(srcdir)/generated/in_pack_r8.c \\\n+$(srcdir)/generated/in_pack_r10.c \\\n+$(srcdir)/generated/in_pack_r16.c \\\n $(srcdir)/generated/in_pack_c4.c \\\n $(srcdir)/generated/in_pack_c8.c \\\n $(srcdir)/generated/in_pack_c10.c \\\n $(srcdir)/generated/in_pack_c16.c\n \n in_unpack_c = \\\n+$(srcdir)/generated/in_unpack_i1.c \\\n+$(srcdir)/generated/in_unpack_i2.c \\\n $(srcdir)/generated/in_unpack_i4.c \\\n $(srcdir)/generated/in_unpack_i8.c \\\n $(srcdir)/generated/in_unpack_i16.c \\\n+$(srcdir)/generated/in_unpack_r4.c \\\n+$(srcdir)/generated/in_unpack_r8.c \\\n+$(srcdir)/generated/in_unpack_r10.c \\\n+$(srcdir)/generated/in_unpack_r16.c \\\n $(srcdir)/generated/in_unpack_c4.c \\\n $(srcdir)/generated/in_unpack_c8.c \\\n $(srcdir)/generated/in_unpack_c10.c \\\n@@ -1689,17 +1717,29 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_generic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_i2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_i4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_c16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_c4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_c8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_generic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_i2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_i4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/inquire.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/intrinsics.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ishftc.Plo@am__quote@\n@@ -4026,6 +4066,20 @@ reshape_c16.lo: $(srcdir)/generated/reshape_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_c16.lo `test -f '$(srcdir)/generated/reshape_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/reshape_c16.c\n \n+in_pack_i1.lo: $(srcdir)/generated/in_pack_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_i1.lo -MD -MP -MF \"$(DEPDIR)/in_pack_i1.Tpo\" -c -o in_pack_i1.lo `test -f '$(srcdir)/generated/in_pack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_i1.Tpo\" \"$(DEPDIR)/in_pack_i1.Plo\"; else rm -f \"$(DEPDIR)/in_pack_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_i1.c' object='in_pack_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_i1.lo `test -f '$(srcdir)/generated/in_pack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i1.c\n+\n+in_pack_i2.lo: $(srcdir)/generated/in_pack_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_i2.lo -MD -MP -MF \"$(DEPDIR)/in_pack_i2.Tpo\" -c -o in_pack_i2.lo `test -f '$(srcdir)/generated/in_pack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_i2.Tpo\" \"$(DEPDIR)/in_pack_i2.Plo\"; else rm -f \"$(DEPDIR)/in_pack_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_i2.c' object='in_pack_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_i2.lo `test -f '$(srcdir)/generated/in_pack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i2.c\n+\n in_pack_i4.lo: $(srcdir)/generated/in_pack_i4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_i4.lo -MD -MP -MF \"$(DEPDIR)/in_pack_i4.Tpo\" -c -o in_pack_i4.lo `test -f '$(srcdir)/generated/in_pack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_i4.Tpo\" \"$(DEPDIR)/in_pack_i4.Plo\"; else rm -f \"$(DEPDIR)/in_pack_i4.Tpo\"; exit 1; fi\n@@ -4047,6 +4101,34 @@ in_pack_i16.lo: $(srcdir)/generated/in_pack_i16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_i16.lo `test -f '$(srcdir)/generated/in_pack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_i16.c\n \n+in_pack_r4.lo: $(srcdir)/generated/in_pack_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_r4.lo -MD -MP -MF \"$(DEPDIR)/in_pack_r4.Tpo\" -c -o in_pack_r4.lo `test -f '$(srcdir)/generated/in_pack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_r4.Tpo\" \"$(DEPDIR)/in_pack_r4.Plo\"; else rm -f \"$(DEPDIR)/in_pack_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_r4.c' object='in_pack_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_r4.lo `test -f '$(srcdir)/generated/in_pack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r4.c\n+\n+in_pack_r8.lo: $(srcdir)/generated/in_pack_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_r8.lo -MD -MP -MF \"$(DEPDIR)/in_pack_r8.Tpo\" -c -o in_pack_r8.lo `test -f '$(srcdir)/generated/in_pack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_r8.Tpo\" \"$(DEPDIR)/in_pack_r8.Plo\"; else rm -f \"$(DEPDIR)/in_pack_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_r8.c' object='in_pack_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_r8.lo `test -f '$(srcdir)/generated/in_pack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r8.c\n+\n+in_pack_r10.lo: $(srcdir)/generated/in_pack_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_r10.lo -MD -MP -MF \"$(DEPDIR)/in_pack_r10.Tpo\" -c -o in_pack_r10.lo `test -f '$(srcdir)/generated/in_pack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_r10.Tpo\" \"$(DEPDIR)/in_pack_r10.Plo\"; else rm -f \"$(DEPDIR)/in_pack_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_r10.c' object='in_pack_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_r10.lo `test -f '$(srcdir)/generated/in_pack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r10.c\n+\n+in_pack_r16.lo: $(srcdir)/generated/in_pack_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_r16.lo -MD -MP -MF \"$(DEPDIR)/in_pack_r16.Tpo\" -c -o in_pack_r16.lo `test -f '$(srcdir)/generated/in_pack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_r16.Tpo\" \"$(DEPDIR)/in_pack_r16.Plo\"; else rm -f \"$(DEPDIR)/in_pack_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_pack_r16.c' object='in_pack_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_r16.lo `test -f '$(srcdir)/generated/in_pack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_r16.c\n+\n in_pack_c4.lo: $(srcdir)/generated/in_pack_c4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_pack_c4.lo -MD -MP -MF \"$(DEPDIR)/in_pack_c4.Tpo\" -c -o in_pack_c4.lo `test -f '$(srcdir)/generated/in_pack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_c4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_pack_c4.Tpo\" \"$(DEPDIR)/in_pack_c4.Plo\"; else rm -f \"$(DEPDIR)/in_pack_c4.Tpo\"; exit 1; fi\n@@ -4075,6 +4157,20 @@ in_pack_c16.lo: $(srcdir)/generated/in_pack_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_pack_c16.lo `test -f '$(srcdir)/generated/in_pack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_pack_c16.c\n \n+in_unpack_i1.lo: $(srcdir)/generated/in_unpack_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_i1.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_i1.Tpo\" -c -o in_unpack_i1.lo `test -f '$(srcdir)/generated/in_unpack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_i1.Tpo\" \"$(DEPDIR)/in_unpack_i1.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_i1.c' object='in_unpack_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_i1.lo `test -f '$(srcdir)/generated/in_unpack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i1.c\n+\n+in_unpack_i2.lo: $(srcdir)/generated/in_unpack_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_i2.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_i2.Tpo\" -c -o in_unpack_i2.lo `test -f '$(srcdir)/generated/in_unpack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_i2.Tpo\" \"$(DEPDIR)/in_unpack_i2.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_i2.c' object='in_unpack_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_i2.lo `test -f '$(srcdir)/generated/in_unpack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i2.c\n+\n in_unpack_i4.lo: $(srcdir)/generated/in_unpack_i4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_i4.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_i4.Tpo\" -c -o in_unpack_i4.lo `test -f '$(srcdir)/generated/in_unpack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_i4.Tpo\" \"$(DEPDIR)/in_unpack_i4.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_i4.Tpo\"; exit 1; fi\n@@ -4096,6 +4192,34 @@ in_unpack_i16.lo: $(srcdir)/generated/in_unpack_i16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_i16.lo `test -f '$(srcdir)/generated/in_unpack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_i16.c\n \n+in_unpack_r4.lo: $(srcdir)/generated/in_unpack_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_r4.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_r4.Tpo\" -c -o in_unpack_r4.lo `test -f '$(srcdir)/generated/in_unpack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_r4.Tpo\" \"$(DEPDIR)/in_unpack_r4.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_r4.c' object='in_unpack_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_r4.lo `test -f '$(srcdir)/generated/in_unpack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r4.c\n+\n+in_unpack_r8.lo: $(srcdir)/generated/in_unpack_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_r8.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_r8.Tpo\" -c -o in_unpack_r8.lo `test -f '$(srcdir)/generated/in_unpack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_r8.Tpo\" \"$(DEPDIR)/in_unpack_r8.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_r8.c' object='in_unpack_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_r8.lo `test -f '$(srcdir)/generated/in_unpack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r8.c\n+\n+in_unpack_r10.lo: $(srcdir)/generated/in_unpack_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_r10.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_r10.Tpo\" -c -o in_unpack_r10.lo `test -f '$(srcdir)/generated/in_unpack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_r10.Tpo\" \"$(DEPDIR)/in_unpack_r10.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_r10.c' object='in_unpack_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_r10.lo `test -f '$(srcdir)/generated/in_unpack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r10.c\n+\n+in_unpack_r16.lo: $(srcdir)/generated/in_unpack_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_r16.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_r16.Tpo\" -c -o in_unpack_r16.lo `test -f '$(srcdir)/generated/in_unpack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_r16.Tpo\" \"$(DEPDIR)/in_unpack_r16.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/in_unpack_r16.c' object='in_unpack_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o in_unpack_r16.lo `test -f '$(srcdir)/generated/in_unpack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_r16.c\n+\n in_unpack_c4.lo: $(srcdir)/generated/in_unpack_c4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT in_unpack_c4.lo -MD -MP -MF \"$(DEPDIR)/in_unpack_c4.Tpo\" -c -o in_unpack_c4.lo `test -f '$(srcdir)/generated/in_unpack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/in_unpack_c4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/in_unpack_c4.Tpo\" \"$(DEPDIR)/in_unpack_c4.Plo\"; else rm -f \"$(DEPDIR)/in_unpack_c4.Tpo\"; exit 1; fi"}, {"sha": "b5be016cf371998b7ea91b0003dc84cf62e73908", "filename": "libgfortran/generated/in_pack_i1.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i1.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_INTEGER_1 *\n+internal_pack_1 (gfc_array_i1 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_INTEGER_1 *src;\n+  GFC_INTEGER_1 *dest;\n+  GFC_INTEGER_1 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_INTEGER_1 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_1));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "240409a357e3737776dfe149436bcd68710b9fc2", "filename": "libgfortran/generated/in_pack_i2.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_i2.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_INTEGER_2 *\n+internal_pack_2 (gfc_array_i2 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_INTEGER_2 *src;\n+  GFC_INTEGER_2 *dest;\n+  GFC_INTEGER_2 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_INTEGER_2 *)internal_malloc_size (ssize * sizeof (GFC_INTEGER_2));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "892c6bb9dc5b4a4e53de1cbfb914ed82ff3ca680", "filename": "libgfortran/generated/in_pack_r10.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r10.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_REAL_10 *\n+internal_pack_r10 (gfc_array_r10 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_REAL_10 *src;\n+  GFC_REAL_10 *dest;\n+  GFC_REAL_10 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_REAL_10 *)internal_malloc_size (ssize * sizeof (GFC_REAL_10));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "15ab585050f3948956560c3b7f7ae898ac9fa832", "filename": "libgfortran/generated/in_pack_r16.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r16.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_REAL_16 *\n+internal_pack_r16 (gfc_array_r16 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_REAL_16 *src;\n+  GFC_REAL_16 *dest;\n+  GFC_REAL_16 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_REAL_16 *)internal_malloc_size (ssize * sizeof (GFC_REAL_16));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "a1f352c4fdd545b87c317271a0f19cdc6eec9263", "filename": "libgfortran/generated/in_pack_r4.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r4.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_REAL_4 *\n+internal_pack_r4 (gfc_array_r4 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_REAL_4 *src;\n+  GFC_REAL_4 *dest;\n+  GFC_REAL_4 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_REAL_4 *)internal_malloc_size (ssize * sizeof (GFC_REAL_4));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "76cee7afe866517ebe5323bfecddeef574dce572", "filename": "libgfortran/generated/in_pack_r8.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_pack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r8.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,124 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_REAL_8 *\n+internal_pack_r8 (gfc_array_r8 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_REAL_8 *src;\n+  GFC_REAL_8 *dest;\n+  GFC_REAL_8 *destptr;\n+  int n;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = source->dim[n].stride;\n+      extent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->data;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = (GFC_REAL_8 *)internal_malloc_size (ssize * sizeof (GFC_REAL_8));\n+  dest = destptr;\n+  src = source->data;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "4b455b73d28594ea2a526163551f302bcb22ef6b", "filename": "libgfortran/generated/in_unpack_i1.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i1.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+void\n+internal_unpack_1 (gfc_array_i1 * d, const GFC_INTEGER_1 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_INTEGER_1 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_INTEGER_1));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "91e6fca9ded17f900732ab37b66e38787d2232bc", "filename": "libgfortran/generated/in_unpack_i2.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_i2.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+void\n+internal_unpack_2 (gfc_array_i2 * d, const GFC_INTEGER_2 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_INTEGER_2 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_INTEGER_2));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "5514763146fbfec771cba6ada8e6edab321aba08", "filename": "libgfortran/generated/in_unpack_r10.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r10.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+void\n+internal_unpack_r10 (gfc_array_r10 * d, const GFC_REAL_10 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_REAL_10 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_REAL_10));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "3abe19df076232f5082ce48cbdad9a6b24a3ac25", "filename": "libgfortran/generated/in_unpack_r16.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r16.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+void\n+internal_unpack_r16 (gfc_array_r16 * d, const GFC_REAL_16 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_REAL_16 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_REAL_16));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "c3c274250958798d6794e2b44a64e2e540af01d5", "filename": "libgfortran/generated/in_unpack_r4.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r4.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+void\n+internal_unpack_r4 (gfc_array_r4 * d, const GFC_REAL_4 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_REAL_4 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_REAL_4));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "9ece8b0a4d266afc2c32752cfcdb0e441dceb586", "filename": "libgfortran/generated/in_unpack_r8.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fgenerated%2Fin_unpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r8.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -0,0 +1,112 @@\n+/* Helper function for repacking arrays.\n+   Copyright 2003, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+void\n+internal_unpack_r8 (gfc_array_r8 * d, const GFC_REAL_8 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_REAL_8 *dest;\n+  int n;\n+\n+  dest = d->data;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = d->dim[n].stride;\n+      extent[n] = d->dim[n].ubound + 1 - d->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        abort ();\n+\n+      if (dsize == stride[n])\n+        dsize *= extent[n];\n+      else\n+        dsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_REAL_8));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "98af40e2ba2630eb687df51f8c40e012953f1c46", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -609,10 +609,15 @@ extern void reshape_packed (char *, index_type, const char *, index_type,\n \t\t\t    const char *, index_type);\n internal_proto(reshape_packed);\n \n-/* Repacking functions.  */\n+/* Repacking functions.  These are called internally by internal_pack\n+   and internal_unpack.  */\n+\n+GFC_INTEGER_1 *internal_pack_1 (gfc_array_i1 *);\n+internal_proto(internal_pack_1);\n+\n+GFC_INTEGER_2 *internal_pack_2 (gfc_array_i2 *);\n+internal_proto(internal_pack_2);\n \n-/* ??? These aren't currently used by the compiler, though we\n-   certainly could do so.  */\n GFC_INTEGER_4 *internal_pack_4 (gfc_array_i4 *);\n internal_proto(internal_pack_4);\n \n@@ -624,6 +629,22 @@ GFC_INTEGER_16 *internal_pack_16 (gfc_array_i16 *);\n internal_proto(internal_pack_16);\n #endif\n \n+GFC_REAL_4 *internal_pack_r4 (gfc_array_r4 *);\n+internal_proto(internal_pack_r4);\n+\n+GFC_REAL_8 *internal_pack_r8 (gfc_array_r8 *);\n+internal_proto(internal_pack_r8);\n+\n+#if defined HAVE_GFC_REAL_10\n+GFC_REAL_10 *internal_pack_r10 (gfc_array_r10 *);\n+internal_proto(internal_pack_r10);\n+#endif\n+\n+#if defined HAVE_GFC_REAL_16\n+GFC_REAL_16 *internal_pack_r16 (gfc_array_r16 *);\n+internal_proto(internal_pack_r16);\n+#endif\n+\n GFC_COMPLEX_4 *internal_pack_c4 (gfc_array_c4 *);\n internal_proto(internal_pack_c4);\n \n@@ -635,6 +656,17 @@ GFC_COMPLEX_10 *internal_pack_c10 (gfc_array_c10 *);\n internal_proto(internal_pack_c10);\n #endif\n \n+#if defined HAVE_GFC_COMPLEX_16\n+GFC_COMPLEX_16 *internal_pack_c16 (gfc_array_c16 *);\n+internal_proto(internal_pack_c16);\n+#endif\n+\n+extern void internal_unpack_1 (gfc_array_i1 *, const GFC_INTEGER_1 *);\n+internal_proto(internal_unpack_1);\n+\n+extern void internal_unpack_2 (gfc_array_i2 *, const GFC_INTEGER_2 *);\n+internal_proto(internal_unpack_2);\n+\n extern void internal_unpack_4 (gfc_array_i4 *, const GFC_INTEGER_4 *);\n internal_proto(internal_unpack_4);\n \n@@ -646,6 +678,22 @@ extern void internal_unpack_16 (gfc_array_i16 *, const GFC_INTEGER_16 *);\n internal_proto(internal_unpack_16);\n #endif\n \n+extern void internal_unpack_r4 (gfc_array_r4 *, const GFC_REAL_4 *);\n+internal_proto(internal_unpack_r4);\n+\n+extern void internal_unpack_r8 (gfc_array_r8 *, const GFC_REAL_8 *);\n+internal_proto(internal_unpack_r8);\n+\n+#if defined HAVE_GFC_REAL_10\n+extern void internal_unpack_r10 (gfc_array_r10 *, const GFC_REAL_10 *);\n+internal_proto(internal_unpack_r10);\n+#endif\n+\n+#if defined HAVE_GFC_REAL_16\n+extern void internal_unpack_r16 (gfc_array_r16 *, const GFC_REAL_16 *);\n+internal_proto(internal_unpack_r16);\n+#endif\n+\n extern void internal_unpack_c4 (gfc_array_c4 *, const GFC_COMPLEX_4 *);\n internal_proto(internal_unpack_c4);\n "}, {"sha": "ff02ec1d372f87501dfdea313216b40333e51ecd", "filename": "libgfortran/runtime/in_pack_generic.c", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fruntime%2Fin_pack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fruntime%2Fin_pack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fin_pack_generic.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -65,25 +65,65 @@ internal_pack (gfc_array_char * source)\n     {\n     case GFC_DTYPE_INTEGER:\n     case GFC_DTYPE_LOGICAL:\n-    case GFC_DTYPE_REAL:\n       switch (size)\n \t{\n-\tcase 4:\n-\t  return internal_pack_4 ((gfc_array_i4 *)source);\n+\tcase sizeof (GFC_INTEGER_1):\n+\t  return internal_pack_1 ((gfc_array_i1 *) source);\n+\n+\tcase sizeof (GFC_INTEGER_2):\n+\t  return internal_pack_2 ((gfc_array_i2 *) source);\n+\n+\tcase sizeof (GFC_INTEGER_4):\n+\t  return internal_pack_4 ((gfc_array_i4 *) source);\n \t  \n-\tcase 8:\n-\t  return internal_pack_8 ((gfc_array_i8 *)source);\n+\tcase sizeof (GFC_INTEGER_8):\n+\t  return internal_pack_8 ((gfc_array_i8 *) source);\n+\n+#if defined(HAVE_GFC_INTEGER_16)\n+\tcase sizeof (GFC_INTEGER_16):\n+\t  return internal_pack_16 (gfc_array_i16 *) source);\n+#endif\n \t}\n       break;\n \n+    case GFC_DTYPE_REAL:\n+      switch (size)\n+\t{\n+\tcase sizeof (GFC_REAL_4):\n+\t  return internal_pack_r4 ((gfc_array_r4 *) source);\n+\n+\tcase sizeof (GFC_REAL_8):\n+\t  return internal_pack_r8 ((gfc_array_r8 *) source);\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\tcase sizeof (GFC_REAL_10):\n+\t  return internal_pack_r10 ((gfc_array_r10 *) source);\n+#endif\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\tcase sizeof (GFC_REAL_16):\n+\t  return internal_pack_r16 ((gfc_array_r16 *) source);\n+#endif\n+\t}\n     case GFC_DTYPE_COMPLEX:\n       switch (size)\n \t{\n-\tcase 8:\n-\t  return internal_pack_c4 ((gfc_array_c4 *)source);\n+\tcase sizeof (GFC_COMPLEX_4):\n+\t  return internal_pack_c4 ((gfc_array_c4 *) source);\n \t  \n-\tcase 16:\n-\t  return internal_pack_c8 ((gfc_array_c8 *)source);\n+\tcase sizeof (GFC_COMPLEX_8):\n+\t  return internal_pack_c8 ((gfc_array_c8 *) source);\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\tcase sizeof (GFC_COMPLEX_10):\n+\t  return internal_pack_c10 ((gfc_array_c10 *) source);\n+#endif\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\tcase sizeof (GFC_COMPLEX_16):\n+\t  return internal_pack_c16 ((gfc_array_c16 *) source);\n+#endif\n+\n \t}\n       break;\n "}, {"sha": "8b51fe92e72852e3be259a4069a868d0d2b267e8", "filename": "libgfortran/runtime/in_unpack_generic.c", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fruntime%2Fin_unpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1d7686de136571f68185066dec9bcb28019a8d/libgfortran%2Fruntime%2Fin_unpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fin_unpack_generic.c?ref=8e1d7686de136571f68185066dec9bcb28019a8d", "patch": "@@ -62,29 +62,80 @@ internal_unpack (gfc_array_char * d, const void * s)\n     {\n     case GFC_DTYPE_INTEGER:\n     case GFC_DTYPE_LOGICAL:\n-    case GFC_DTYPE_REAL:\n       switch (size)\n \t{\n-\tcase 4:\n-\t  internal_unpack_4 ((gfc_array_i4 *)d, (const GFC_INTEGER_4 *)s);\n+\tcase sizeof (GFC_INTEGER_1):\n+\t  internal_unpack_1 ((gfc_array_i1 *) d, (const GFC_INTEGER_1 *) s);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_2):\n+\t  internal_unpack_2 ((gfc_array_i2 *) d, (const GFC_INTEGER_2 *) s);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_4):\n+\t  internal_unpack_4 ((gfc_array_i4 *) d, (const GFC_INTEGER_4 *) s);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_8):\n+\t  internal_unpack_8 ((gfc_array_i8 *) d, (const GFC_INTEGER_8 *) s);\n \t  return;\n \n-\tcase 8:\n-\t  internal_unpack_8 ((gfc_array_i8 *)d, (const GFC_INTEGER_8 *)s);\n+#if defined (HAVE_GFC_INTEGER_16)\n+\tcase sizeof (GFC_INTEGER_16):\n+\t  internal_unpack_16 ((gfc_array_i16 *) d, (const GFC_INTEGER_16 *) s);\n \t  return;\n+#endif\n \t}\n       break;\n \n+    case GFC_DTYPE_REAL:\n+      switch (size)\n+\t{\n+\tcase sizeof (GFC_REAL_4):\n+\t  internal_unpack_r4 ((gfc_array_r4 *) d, (const GFC_REAL_4 *) s);\n+\t  return;\n+\n+\tcase sizeof (GFC_REAL_8):\n+\t  internal_unpack_r8 ((gfc_array_r8 *) d, (const GFC_REAL_8 *) s);\n+\t  return;\n+\n+#if defined(HAVE_GFC_REAL_10)\n+\tcase sizeof (GFC_REAL_10):\n+\t  internal_unpack_r10 ((gfc_array_r10 *) d, (const GFC_REAL_10 *) s);\n+\t  return;\n+#endif\n+\n+#if defined(HAVE_GFC_REAL_16)\n+\tcase sizeof (GFC_REAL_16):\n+\t  internal_unpack_r16 ((gfc_array_r16 *) d, (const GFC_REAL_16 *) s);\n+\t  return;\n+#endif\n+\n+\t}\n+\n     case GFC_DTYPE_COMPLEX:\n       switch (size) \n \t{\n-\tcase 8:\n+\tcase sizeof (GFC_COMPLEX_4):\n \t  internal_unpack_c4 ((gfc_array_c4 *)d, (const GFC_COMPLEX_4 *)s);\n \t  return;\n \n-\tcase 16:\n+\tcase sizeof (GFC_COMPLEX_8):\n \t  internal_unpack_c8 ((gfc_array_c8 *)d, (const GFC_COMPLEX_8 *)s);\n \t  return;\n+\n+#if defined(HAVE_GFC_COMPLEX_10)\n+\tcase sizeof (GFC_COMPLEX_10):\n+\t  internal_unpack_c10 ((gfc_array_c10 *) d, (const GFC_COMPLEX_10 *) s);\n+\t  return;\n+#endif\n+\n+#if defined(HAVE_GFC_COMPLEX_16)\n+\tcase sizeof (GFC_COMPLEX_16):\n+\t  internal_unpack_c16 ((gfc_array_c16 *) d, (const GFC_COMPLEX_16 *) s);\n+\t  return;\n+#endif\n+\n \t}\n     default:\n       break;"}]}