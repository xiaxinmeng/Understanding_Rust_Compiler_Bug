{"sha": "61d371eb413e6917f59bea804b3c167e31f88f98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkMzcxZWI0MTNlNjkxN2Y1OWJlYTgwNGIzYzE2N2UzMWY4OGY5OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-06T11:15:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-06T11:15:40Z"}, "message": "tree-vectorizer.h (struct _bb_vec_info): Add region_begin/end members.\n\n2015-11-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct _bb_vec_info): Add region_begin/end\n\tmembers.\n\t(vect_stmt_in_region_p): Declare.\n\t* tree-vect-slp.c (new_bb_vec_info): Work on a region.\n\t(destroy_bb_vec_info): Likewise.\n\t(vect_bb_slp_scalar_cost): Use vect_stmt_in_region_p.\n\t(vect_get_and_check_slp_defs): Likewise.\n\t(vect_slp_analyze_bb_1): Refactor to make it work on sub-BBs.\n\t(vect_slp_bb): Likewise.\n\t* tree-vect-patterns.c (vect_same_loop_or_bb_p): Implement\n\tin terms of vect_stmt_in_region_p.\n\t(vect_pattern_recog): Iterate over the BB region.\n\t* tree-vect-stmts.c (vect_is_simple_use): Use vect_stmt_in_region_p.\n\t* tree-vectorizer.c (vect_stmt_in_region_p): New function.\n\t(pass_slp_vectorize::execute): Initialize all stmt UIDs to -1.\n\n\t* config/i386/i386.c: Include gimple-iterator.h.\n\t* config/aarch64/aarch64.c: Likewise.\n\n\t* gcc.dg/vect/bb-slp-38.c: New testcase.\n\nFrom-SVN: r229842", "tree": {"sha": "74dcc1ae8899af0f2b008c2052a07e430f301776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74dcc1ae8899af0f2b008c2052a07e430f301776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61d371eb413e6917f59bea804b3c167e31f88f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d371eb413e6917f59bea804b3c167e31f88f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61d371eb413e6917f59bea804b3c167e31f88f98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d371eb413e6917f59bea804b3c167e31f88f98/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66a5f0b45ff2dc172035f896903d846a6f86e8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a5f0b45ff2dc172035f896903d846a6f86e8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a5f0b45ff2dc172035f896903d846a6f86e8d0"}], "stats": {"total": 368, "additions": 240, "deletions": 128}, "files": [{"sha": "0355c9eaafa7d05f13af880346cb3fb8ced0d52c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -1,3 +1,23 @@\n+2015-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct _bb_vec_info): Add region_begin/end\n+\tmembers.\n+\t(vect_stmt_in_region_p): Declare.\n+\t* tree-vect-slp.c (new_bb_vec_info): Work on a region.\n+\t(destroy_bb_vec_info): Likewise.\n+\t(vect_bb_slp_scalar_cost): Use vect_stmt_in_region_p.\n+\t(vect_get_and_check_slp_defs): Likewise.\n+\t(vect_slp_analyze_bb_1): Refactor to make it work on sub-BBs.\n+\t(vect_slp_bb): Likewise.\n+\t* tree-vect-patterns.c (vect_same_loop_or_bb_p): Implement\n+\tin terms of vect_stmt_in_region_p.\n+\t(vect_pattern_recog): Iterate over the BB region.\n+\t* tree-vect-stmts.c (vect_is_simple_use): Use vect_stmt_in_region_p.\n+\t* tree-vectorizer.c (vect_stmt_in_region_p): New function.\n+\t(pass_slp_vectorize::execute): Initialize all stmt UIDs to -1.\n+\t* config/i386/i386.c: Include gimple-iterator.h.\n+\t* config/aarch64/aarch64.c: Likewise.\n+\n 2015-11-06  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR rtl-optimization/67753"}, {"sha": "98b13b4b7e26a66768ca8a62fcb30150278ea5f8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -52,6 +52,7 @@\n #include \"params.h\"\n #include \"gimplify.h\"\n #include \"dwarf2.h\"\n+#include \"gimple-iterator.h\"\n #include \"tree-vectorizer.h\"\n #include \"aarch64-cost-tables.h\"\n #include \"dumpfile.h\""}, {"sha": "bb37abaf119abfe10457e8c5309a29d7cbbda651", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n #include \"pass_manager.h\"\n #include \"target-globals.h\"\n+#include \"gimple-iterator.h\"\n #include \"tree-vectorizer.h\"\n #include \"shrink-wrap.h\"\n #include \"builtins.h\""}, {"sha": "3d1834dfb818892b2b0f4b7304bfa8b7bbdd6162", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -1,3 +1,7 @@\n+2015-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/bb-slp-38.c: New testcase.\n+\n 2015-11-06  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* gfortran.dg/goacc/private-3.f95: XFAIL."}, {"sha": "59aec54fffd199d242123dac0fef51b2a1a2f3dd", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-38.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+\n+int a[8], b[8];\n+int x;\n+\n+void __attribute__((noinline,noclone))\n+bar (void)\n+{\n+  x = 1;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo(void)\n+{\n+  a[0] = b[0];\n+  a[1] = b[0];\n+  a[2] = b[3];\n+  a[3] = b[3];\n+  bar ();\n+  a[4] = b[4];\n+  a[5] = b[7];\n+  a[6] = b[4];\n+  a[7] = b[7];\n+}\n+\n+int main()\n+{\n+  int i;\n+  check_vect ();\n+  for (i = 0; i < 8; ++i)\n+    b[i] = i;\n+  foo ();\n+  if (a[0] != 0 || a[1] != 0 || a[2] != 3 || a[3] != 3\n+      || a[4] != 4 || a[5] != 7 || a[6] != 4 || a[7] != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 2 \"slp2\" { target vect_perm } } } */"}, {"sha": "d003d335f5df61d56fcbdca4da49e50c3f8ea077", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -107,27 +107,7 @@ static bool\n vect_same_loop_or_bb_p (gimple *stmt1, gimple *stmt2)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt1);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-\n-  if (!gimple_bb (stmt2))\n-    return false;\n-\n-  if (loop_vinfo)\n-    {\n-      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      if (!flow_bb_inside_loop_p (loop, gimple_bb (stmt2)))\n-\treturn false;\n-    }\n-  else\n-    {\n-      if (gimple_bb (stmt2) != BB_VINFO_BB (bb_vinfo)\n-\t  || gimple_code (stmt2) == GIMPLE_PHI)\n-\treturn false;\n-    }\n-\n-  gcc_assert (vinfo_for_stmt (stmt2));\n-  return true;\n+  return vect_stmt_in_region_p (stmt_vinfo->vinfo, stmt2);\n }\n \n /* If the LHS of DEF_STMT has a single use, and that statement is\n@@ -3611,33 +3591,42 @@ vect_pattern_recog (vec_info *vinfo)\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n       bbs = LOOP_VINFO_BBS (loop_vinfo);\n       nbbs = loop->num_nodes;\n+\n+      /* Scan through the loop stmts, applying the pattern recognition\n+\t functions starting at each stmt visited:  */\n+      for (i = 0; i < nbbs; i++)\n+\t{\n+\t  basic_block bb = bbs[i];\n+\t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t    {\n+\t      /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+\t      for (j = 0; j < NUM_PATTERNS; j++)\n+\t\t{\n+\t\t  vect_recog_func = vect_vect_recog_func_ptrs[j];\n+\t\t  vect_pattern_recog_1 (vect_recog_func, si,\n+\t\t\t\t\t&stmts_to_replace);\n+\t\t}\n+\t    }\n+\t}\n     }\n   else\n     {\n-      bbs = &as_a <bb_vec_info> (vinfo)->bb;\n-      nbbs = 1;\n-    }\n-\n-  /* Scan through the loop stmts, applying the pattern recognition\n-     functions starting at each stmt visited:  */\n-  for (i = 0; i < nbbs; i++)\n-    {\n-      basic_block bb = bbs[i];\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-        {\n-\t  if (is_a <bb_vec_info> (vinfo)\n-\t      && (stmt = gsi_stmt (si))\n+      bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n+      for (si = bb_vinfo->region_begin;\n+\t   gsi_stmt (si) != gsi_stmt (bb_vinfo->region_end); gsi_next (&si))\n+\t{\n+\t  if ((stmt = gsi_stmt (si))\n \t      && vinfo_for_stmt (stmt)\n \t      && !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n-\t   continue;\n+\t    continue;\n \n-          /* Scan over all generic vect_recog_xxx_pattern functions.  */\n-          for (j = 0; j < NUM_PATTERNS; j++)\n-            {\n+\t  /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+\t  for (j = 0; j < NUM_PATTERNS; j++)\n+\t    {\n \t      vect_recog_func = vect_vect_recog_func_ptrs[j];\n \t      vect_pattern_recog_1 (vect_recog_func, si,\n \t\t\t\t    &stmts_to_replace);\n-            }\n-        }\n+\t    }\n+\t}\n     }\n }"}, {"sha": "cfdfc2936a18421d602adfe05b00fd890d60eeef", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 102, "deletions": 82, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -209,7 +209,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n   unsigned int i, number_of_oprnds;\n   gimple *def_stmt;\n   enum vect_def_type dt = vect_uninitialized_def;\n-  struct loop *loop = NULL;\n   bool pattern = false;\n   slp_oprnd_info oprnd_info;\n   int first_op_idx = 1;\n@@ -218,9 +217,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n   bool first = stmt_num == 0;\n   bool second = stmt_num == 1;\n \n-  if (is_a <loop_vec_info> (vinfo))\n-    loop = LOOP_VINFO_LOOP (as_a <loop_vec_info> (vinfo));\n-\n   if (is_gimple_call (stmt))\n     {\n       number_of_oprnds = gimple_call_num_args (stmt);\n@@ -276,11 +272,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n          from the pattern.  Check that all the stmts of the node are in the\n          pattern.  */\n       if (def_stmt && gimple_bb (def_stmt)\n-          && ((is_a <loop_vec_info> (vinfo)\n-\t       && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n-\t      || (is_a <bb_vec_info> (vinfo)\n-\t\t  && gimple_bb (def_stmt) == as_a <bb_vec_info> (vinfo)->bb\n-\t\t  && gimple_code (def_stmt) != GIMPLE_PHI))\n+          && vect_stmt_in_region_p (vinfo, def_stmt)\n           && vinfo_for_stmt (def_stmt)\n           && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt))\n \t  && !STMT_VINFO_RELEVANT (vinfo_for_stmt (def_stmt))\n@@ -2076,16 +2068,21 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n    stmt_vec_info structs for all the stmts in it.  */\n \n static bb_vec_info\n-new_bb_vec_info (basic_block bb)\n+new_bb_vec_info (gimple_stmt_iterator region_begin,\n+\t\t gimple_stmt_iterator region_end)\n {\n+  basic_block bb = gsi_bb (region_begin);\n   bb_vec_info res = NULL;\n   gimple_stmt_iterator gsi;\n \n   res = (bb_vec_info) xcalloc (1, sizeof (struct _bb_vec_info));\n   res->kind = vec_info::bb;\n   BB_VINFO_BB (res) = bb;\n+  res->region_begin = region_begin;\n+  res->region_end = region_end;\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = region_begin; gsi_stmt (gsi) != gsi_stmt (region_end);\n+       gsi_next (&gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n       gimple_set_uid (stmt, 0);\n@@ -2118,14 +2115,18 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n \n   bb = BB_VINFO_BB (bb_vinfo);\n \n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+  for (si = bb_vinfo->region_begin;\n+       gsi_stmt (si) != gsi_stmt (bb_vinfo->region_end); gsi_next (&si))\n     {\n       gimple *stmt = gsi_stmt (si);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n       if (stmt_info)\n         /* Free stmt_vec_info.  */\n         free_stmt_vec_info (stmt);\n+\n+      /* Reset region marker.  */\n+      gimple_set_uid (stmt, -1);\n     }\n \n   vect_destroy_datarefs (bb_vinfo);\n@@ -2247,8 +2248,8 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t  gimple *use_stmt;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n \t    if (!is_gimple_debug (use_stmt)\n-\t\t&& (gimple_code (use_stmt) == GIMPLE_PHI\n-\t\t    || gimple_bb (use_stmt) != bb\n+\t\t&& (! vect_stmt_in_region_p (vinfo_for_stmt (stmt)->vinfo,\n+\t\t\t\t\t     use_stmt)\n \t\t    || !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (use_stmt))))\n \t      {\n \t\t(*life)[i] = true;\n@@ -2327,40 +2328,31 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n /* Check if the basic block can be vectorized.  */\n \n static bb_vec_info\n-vect_slp_analyze_bb_1 (basic_block bb)\n+vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n+\t\t       gimple_stmt_iterator region_end,\n+\t\t       vec<data_reference_p> datarefs, int n_stmts)\n {\n   bb_vec_info bb_vinfo;\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n   int i;\n   int min_vf = 2;\n-  unsigned n_stmts = 0;\n \n-  bb_vinfo = new_bb_vec_info (bb);\n+  if (n_stmts > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: too many instructions in \"\n+\t\t\t \"basic block.\\n\");\n+      free_data_refs (datarefs);\n+      return NULL;\n+    }\n+\n+  bb_vinfo = new_bb_vec_info (region_begin, region_end);\n   if (!bb_vinfo)\n     return NULL;\n \n-  /* Gather all data references in the basic-block.  */\n-\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n-       !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-      ++n_stmts;\n-      if (!find_data_references_in_stmt (NULL, stmt,\n-\t\t\t\t\t &BB_VINFO_DATAREFS (bb_vinfo)))\n-\t{\n-\t  /* Mark the rest of the basic-block as unvectorizable.  */\n-\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      stmt = gsi_stmt (gsi);\n-\t      STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)) = false;\n-\t    }\n-\t  break;\n-\t}\n-    }\n+  BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n \n   /* Analyze the data references.  */\n \n@@ -2438,8 +2430,8 @@ vect_slp_analyze_bb_1 (basic_block bb)\n     }\n \n   /* Mark all the statements that we do not want to vectorize.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (BB_VINFO_BB (bb_vinfo));\n-       !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = bb_vinfo->region_begin;\n+       gsi_stmt (gsi) != gsi_stmt (bb_vinfo->region_end); gsi_next (&gsi))\n     {\n       stmt_vec_info vinfo = vinfo_for_stmt (gsi_stmt (gsi));\n       if (STMT_SLP_TYPE (vinfo) != pure_slp)\n@@ -2509,77 +2501,105 @@ bool\n vect_slp_bb (basic_block bb)\n {\n   bb_vec_info bb_vinfo;\n-  int insns = 0;\n   gimple_stmt_iterator gsi;\n   unsigned int vector_sizes;\n+  bool any_vectorized = false;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"===vect_slp_analyze_bb===\\n\");\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (!is_gimple_debug (stmt)\n-          && !gimple_nop_p (stmt)\n-          && gimple_code (stmt) != GIMPLE_LABEL)\n-        insns++;\n-      if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-\tvect_location = gimple_location (stmt);\n-    }\n-\n-  if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: too many instructions in \"\n-\t\t\t \"basic block.\\n\");\n-\n-      return false;\n-    }\n-\n   /* Autodetect first vector size we try.  */\n   current_vector_size = 0;\n   vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n \n+  gsi = gsi_start_bb (bb);\n+\n   while (1)\n     {\n-      bb_vinfo = vect_slp_analyze_bb_1 (bb);\n-      if (bb_vinfo)\n+      if (gsi_end_p (gsi))\n+\tbreak;\n+\n+      gimple_stmt_iterator region_begin = gsi;\n+      vec<data_reference_p> datarefs = vNULL;\n+      int insns = 0;\n+\n+      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  if (!dbg_cnt (vect_slp))\n-\t    {\n-\t      destroy_bb_vec_info (bb_vinfo);\n-\t      return false;\n-\t    }\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\t  insns++;\n+\n+\t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n+\t    vect_location = gimple_location (stmt);\n+\n+\t  if (!find_data_references_in_stmt (NULL, stmt, &datarefs))\n+\t    break;\n+\t}\n+\n+      /* Skip leading unhandled stmts.  */\n+      if (gsi_stmt (region_begin) == gsi_stmt (gsi))\n+\t{\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n \n+      gimple_stmt_iterator region_end = gsi;\n+\n+      bool vectorized = false;\n+      bb_vinfo = vect_slp_analyze_bb_1 (region_begin, region_end,\n+\t\t\t\t\tdatarefs, insns);\n+      if (bb_vinfo\n+\t  && dbg_cnt (vect_slp))\n+\t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB\\n\");\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB part\\n\");\n \n \t  vect_schedule_slp (bb_vinfo);\n \n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"BASIC BLOCK VECTORIZED\\n\");\n+\t\t\t     \"basic block part vectorized\\n\");\n \n \t  destroy_bb_vec_info (bb_vinfo);\n \n-\t  return true;\n+\t  vectorized = true;\n \t}\n+      else\n+\tdestroy_bb_vec_info (bb_vinfo);\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      any_vectorized |= vectorized;\n \n       vector_sizes &= ~current_vector_size;\n-      if (vector_sizes == 0\n-          || current_vector_size == 0)\n-        return false;\n+      if (vectorized\n+\t  || vector_sizes == 0\n+\t  || current_vector_size == 0)\n+\t{\n+\t  if (gsi_end_p (region_end))\n+\t    break;\n \n-      /* Try the next biggest vector size.  */\n-      current_vector_size = 1 << floor_log2 (vector_sizes);\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Re-trying analysis with \"\n-\t\t\t \"vector size %d\\n\", current_vector_size);\n+\t  /* Skip the unhandled stmt.  */\n+\t  gsi_next (&gsi);\n+\n+\t  /* And reset vector sizes.  */\n+\t  current_vector_size = 0;\n+\t  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+\t}\n+      else\n+\t{\n+\t  /* Try the next biggest vector size.  */\n+\t  current_vector_size = 1 << floor_log2 (vector_sizes);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Re-trying analysis with \"\n+\t\t\t     \"vector size %d\\n\", current_vector_size);\n+\n+\t  /* Start over.  */\n+\t  gsi = region_begin;\n+\t}\n     }\n+\n+  return any_vectorized;\n }\n \n "}, {"sha": "96074fcaa2c87133177f7e94daf58955389a6bc1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -8141,12 +8141,7 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n     }\n \n-  basic_block bb = gimple_bb (*def_stmt);\n-  if ((is_a <loop_vec_info> (vinfo)\n-       && !flow_bb_inside_loop_p (as_a <loop_vec_info> (vinfo)->loop, bb))\n-      || (is_a <bb_vec_info> (vinfo)\n-\t  && (bb != as_a <bb_vec_info> (vinfo)->bb\n-\t      || gimple_code (*def_stmt) == GIMPLE_PHI)))\n+  if (! vect_stmt_in_region_p (vinfo, *def_stmt))\n     *dt = vect_external_def;\n   else\n     {"}, {"sha": "41e87a8d9bd25dc64eb6a50239bb4f603bd28926", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -350,6 +350,33 @@ vect_destroy_datarefs (vec_info *vinfo)\n }\n \n \n+/* Return whether STMT is inside the region we try to vectorize.  */\n+\n+bool\n+vect_stmt_in_region_p (vec_info *vinfo, gimple *stmt)\n+{\n+  if (!gimple_bb (stmt))\n+    return false;\n+\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n+    {\n+      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n+\treturn false;\n+    }\n+  else\n+    {\n+      bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n+      if (gimple_bb (stmt) != BB_VINFO_BB (bb_vinfo)\n+\t  || gimple_uid (stmt) == -1U\n+\t  || gimple_code (stmt) == GIMPLE_PHI)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+\n /* If LOOP has been versioned during ifcvt, return the internal call\n    guarding it.  */\n \n@@ -692,6 +719,14 @@ pass_slp_vectorize::execute (function *fun)\n       scev_initialize ();\n     }\n \n+  /* Mark all stmts as not belonging to the current region.  */\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\tgimple_set_uid (gsi_stmt (gsi), -1);\n+    }\n+\n   init_stmt_vec_info_vec ();\n \n   FOR_EACH_BB_FN (bb, fun)"}, {"sha": "9cde091bde977c198ac48c8dc4c7210023b30e55", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d371eb413e6917f59bea804b3c167e31f88f98/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=61d371eb413e6917f59bea804b3c167e31f88f98", "patch": "@@ -390,6 +390,8 @@ nested_in_vect_loop_p (struct loop *loop, gimple *stmt)\n typedef struct _bb_vec_info : public vec_info\n {\n   basic_block bb;\n+  gimple_stmt_iterator region_begin;\n+  gimple_stmt_iterator region_end;\n } *bb_vec_info;\n \n #define BB_VINFO_BB(B)               (B)->bb\n@@ -1085,5 +1087,6 @@ void vect_pattern_recog (vec_info *);\n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);\n void vect_destroy_datarefs (vec_info *);\n+bool vect_stmt_in_region_p (vec_info *, gimple *);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}