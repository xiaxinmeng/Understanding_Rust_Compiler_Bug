{"sha": "c371bb73807c48f1a708c51f113caea45f0347b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM3MWJiNzM4MDdjNDhmMWE3MDhjNTFmMTEzY2FlYTQ1ZjAzNDdiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T19:03:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T19:03:25Z"}, "message": "gcc/\n\t* expmed.h (alg_code, mult_cost, MULT_COST_LESS, CHEAPER_MULT_COST)\n\t(algorithm, alg_hash_entry, NUM_ALG_HASH_ENTRIES, alg_hash): Moved\n\tfrom expmed.c.\n\t(target_expmed): Add x_alg_hash and x_alg_hash_used_p.\n\t(alg_hash, alg_hash_used_p): New macros.\n\t* expmed.c (init_expmed): Clear alg_hash if reinitializing.\n\t(alg_code, mult_cost, MULT_COST_LESS, CHEAPER_MULT_COST, algorithm)\n\t(alg_hash_entry, NUM_ALG_HASH_ENTRIES, alg_hash): Moved to expmed.h.\n\nFrom-SVN: r162104", "tree": {"sha": "fa440aa1ca8e5ec6721496213be7f7cdaa25daa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa440aa1ca8e5ec6721496213be7f7cdaa25daa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c371bb73807c48f1a708c51f113caea45f0347b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c371bb73807c48f1a708c51f113caea45f0347b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c371bb73807c48f1a708c51f113caea45f0347b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c371bb73807c48f1a708c51f113caea45f0347b1/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa1c5d72e9cb30ddea2f930b6f94045dd8f2dcbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa1c5d72e9cb30ddea2f930b6f94045dd8f2dcbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa1c5d72e9cb30ddea2f930b6f94045dd8f2dcbc"}], "stats": {"total": 236, "additions": 129, "deletions": 107}, "files": [{"sha": "7aca51933b65455e2dfc8b62b46a3feeb61e2e52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c371bb73807c48f1a708c51f113caea45f0347b1", "patch": "@@ -1,3 +1,14 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expmed.h (alg_code, mult_cost, MULT_COST_LESS, CHEAPER_MULT_COST)\n+\t(algorithm, alg_hash_entry, NUM_ALG_HASH_ENTRIES, alg_hash): Moved\n+\tfrom expmed.c.\n+\t(target_expmed): Add x_alg_hash and x_alg_hash_used_p.\n+\t(alg_hash, alg_hash_used_p): New macros.\n+\t* expmed.c (init_expmed): Clear alg_hash if reinitializing.\n+\t(alg_code, mult_cost, MULT_COST_LESS, CHEAPER_MULT_COST, algorithm)\n+\t(alg_hash_entry, NUM_ALG_HASH_ENTRIES, alg_hash): Moved to expmed.h.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* ira-int.h (target_ira_int): Add x_max_struct_costs_size, x_init_cost,"}, {"sha": "186cf01777a62a61b77b3da33347725531baad38", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 107, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c371bb73807c48f1a708c51f113caea45f0347b1", "patch": "@@ -260,6 +260,10 @@ init_expmed (void)\n \t    }\n \t}\n     }\n+  if (alg_hash_used_p)\n+    memset (alg_hash, 0, sizeof (alg_hash));\n+  else\n+    alg_hash_used_p = true;\n   default_rtl_profile ();\n }\n \n@@ -2283,113 +2287,6 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   return temp;\n }\n \f\n-enum alg_code {\n-  alg_unknown,\n-  alg_zero,\n-  alg_m, alg_shift,\n-  alg_add_t_m2,\n-  alg_sub_t_m2,\n-  alg_add_factor,\n-  alg_sub_factor,\n-  alg_add_t2_m,\n-  alg_sub_t2_m,\n-  alg_impossible\n-};\n-\n-/* This structure holds the \"cost\" of a multiply sequence.  The\n-   \"cost\" field holds the total rtx_cost of every operator in the\n-   synthetic multiplication sequence, hence cost(a op b) is defined\n-   as rtx_cost(op) + cost(a) + cost(b), where cost(leaf) is zero.\n-   The \"latency\" field holds the minimum possible latency of the\n-   synthetic multiply, on a hypothetical infinitely parallel CPU.\n-   This is the critical path, or the maximum height, of the expression\n-   tree which is the sum of rtx_costs on the most expensive path from\n-   any leaf to the root.  Hence latency(a op b) is defined as zero for\n-   leaves and rtx_cost(op) + max(latency(a), latency(b)) otherwise.  */\n-\n-struct mult_cost {\n-  short cost;     /* Total rtx_cost of the multiplication sequence.  */\n-  short latency;  /* The latency of the multiplication sequence.  */\n-};\n-\n-/* This macro is used to compare a pointer to a mult_cost against an\n-   single integer \"rtx_cost\" value.  This is equivalent to the macro\n-   CHEAPER_MULT_COST(X,Z) where Z = {Y,Y}.  */\n-#define MULT_COST_LESS(X,Y) ((X)->cost < (Y)\t\\\n-\t\t\t     || ((X)->cost == (Y) && (X)->latency < (Y)))\n-\n-/* This macro is used to compare two pointers to mult_costs against\n-   each other.  The macro returns true if X is cheaper than Y.\n-   Currently, the cheaper of two mult_costs is the one with the\n-   lower \"cost\".  If \"cost\"s are tied, the lower latency is cheaper.  */\n-#define CHEAPER_MULT_COST(X,Y)  ((X)->cost < (Y)->cost\t\t\\\n-\t\t\t\t || ((X)->cost == (Y)->cost\t\\\n-\t\t\t\t     && (X)->latency < (Y)->latency))\n-\n-/* This structure records a sequence of operations.\n-   `ops' is the number of operations recorded.\n-   `cost' is their total cost.\n-   The operations are stored in `op' and the corresponding\n-   logarithms of the integer coefficients in `log'.\n-\n-   These are the operations:\n-   alg_zero\t\ttotal := 0;\n-   alg_m\t\ttotal := multiplicand;\n-   alg_shift\t\ttotal := total * coeff\n-   alg_add_t_m2\t\ttotal := total + multiplicand * coeff;\n-   alg_sub_t_m2\t\ttotal := total - multiplicand * coeff;\n-   alg_add_factor\ttotal := total * coeff + total;\n-   alg_sub_factor\ttotal := total * coeff - total;\n-   alg_add_t2_m\t\ttotal := total * coeff + multiplicand;\n-   alg_sub_t2_m\t\ttotal := total * coeff - multiplicand;\n-\n-   The first operand must be either alg_zero or alg_m.  */\n-\n-struct algorithm\n-{\n-  struct mult_cost cost;\n-  short ops;\n-  /* The size of the OP and LOG fields are not directly related to the\n-     word size, but the worst-case algorithms will be if we have few\n-     consecutive ones or zeros, i.e., a multiplicand like 10101010101...\n-     In that case we will generate shift-by-2, add, shift-by-2, add,...,\n-     in total wordsize operations.  */\n-  enum alg_code op[MAX_BITS_PER_WORD];\n-  char log[MAX_BITS_PER_WORD];\n-};\n-\n-/* The entry for our multiplication cache/hash table.  */\n-struct alg_hash_entry {\n-  /* The number we are multiplying by.  */\n-  unsigned HOST_WIDE_INT t;\n-\n-  /* The mode in which we are multiplying something by T.  */\n-  enum machine_mode mode;\n-\n-  /* The best multiplication algorithm for t.  */\n-  enum alg_code alg;\n-\n-  /* The cost of multiplication if ALG_CODE is not alg_impossible.\n-     Otherwise, the cost within which multiplication by T is\n-     impossible.  */\n-  struct mult_cost cost;\n-\n-  /* OPtimized for speed? */\n-  bool speed;\n-};\n-\n-/* The number of cache/hash entries.  */\n-#if HOST_BITS_PER_WIDE_INT == 64\n-#define NUM_ALG_HASH_ENTRIES 1031\n-#else\n-#define NUM_ALG_HASH_ENTRIES 307\n-#endif\n-\n-/* Each entry of ALG_HASH caches alg_code for some integer.  This is\n-   actually a hash table.  If we have a collision, that the older\n-   entry is kicked out.  */\n-static struct alg_hash_entry alg_hash[NUM_ALG_HASH_ENTRIES];\n-\n /* Indicates the type of fixup needed after a constant multiplication.\n    BASIC_VARIANT means no fixup is needed, NEGATE_VARIANT means that\n    the result should be negated, and ADD_VARIANT means that the"}, {"sha": "37f575571201c0eaeff7ea7f961a4007f60959ed", "filename": "gcc/expmed.h", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c371bb73807c48f1a708c51f113caea45f0347b1/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=c371bb73807c48f1a708c51f113caea45f0347b1", "patch": "@@ -22,8 +22,118 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef EXPMED_H\n #define EXPMED_H 1\n \n+enum alg_code {\n+  alg_unknown,\n+  alg_zero,\n+  alg_m, alg_shift,\n+  alg_add_t_m2,\n+  alg_sub_t_m2,\n+  alg_add_factor,\n+  alg_sub_factor,\n+  alg_add_t2_m,\n+  alg_sub_t2_m,\n+  alg_impossible\n+};\n+\n+/* This structure holds the \"cost\" of a multiply sequence.  The\n+   \"cost\" field holds the total rtx_cost of every operator in the\n+   synthetic multiplication sequence, hence cost(a op b) is defined\n+   as rtx_cost(op) + cost(a) + cost(b), where cost(leaf) is zero.\n+   The \"latency\" field holds the minimum possible latency of the\n+   synthetic multiply, on a hypothetical infinitely parallel CPU.\n+   This is the critical path, or the maximum height, of the expression\n+   tree which is the sum of rtx_costs on the most expensive path from\n+   any leaf to the root.  Hence latency(a op b) is defined as zero for\n+   leaves and rtx_cost(op) + max(latency(a), latency(b)) otherwise.  */\n+\n+struct mult_cost {\n+  short cost;     /* Total rtx_cost of the multiplication sequence.  */\n+  short latency;  /* The latency of the multiplication sequence.  */\n+};\n+\n+/* This macro is used to compare a pointer to a mult_cost against an\n+   single integer \"rtx_cost\" value.  This is equivalent to the macro\n+   CHEAPER_MULT_COST(X,Z) where Z = {Y,Y}.  */\n+#define MULT_COST_LESS(X,Y) ((X)->cost < (Y)\t\\\n+\t\t\t     || ((X)->cost == (Y) && (X)->latency < (Y)))\n+\n+/* This macro is used to compare two pointers to mult_costs against\n+   each other.  The macro returns true if X is cheaper than Y.\n+   Currently, the cheaper of two mult_costs is the one with the\n+   lower \"cost\".  If \"cost\"s are tied, the lower latency is cheaper.  */\n+#define CHEAPER_MULT_COST(X,Y)  ((X)->cost < (Y)->cost\t\t\\\n+\t\t\t\t || ((X)->cost == (Y)->cost\t\\\n+\t\t\t\t     && (X)->latency < (Y)->latency))\n+\n+/* This structure records a sequence of operations.\n+   `ops' is the number of operations recorded.\n+   `cost' is their total cost.\n+   The operations are stored in `op' and the corresponding\n+   logarithms of the integer coefficients in `log'.\n+\n+   These are the operations:\n+   alg_zero\t\ttotal := 0;\n+   alg_m\t\ttotal := multiplicand;\n+   alg_shift\t\ttotal := total * coeff\n+   alg_add_t_m2\t\ttotal := total + multiplicand * coeff;\n+   alg_sub_t_m2\t\ttotal := total - multiplicand * coeff;\n+   alg_add_factor\ttotal := total * coeff + total;\n+   alg_sub_factor\ttotal := total * coeff - total;\n+   alg_add_t2_m\t\ttotal := total * coeff + multiplicand;\n+   alg_sub_t2_m\t\ttotal := total * coeff - multiplicand;\n+\n+   The first operand must be either alg_zero or alg_m.  */\n+\n+struct algorithm\n+{\n+  struct mult_cost cost;\n+  short ops;\n+  /* The size of the OP and LOG fields are not directly related to the\n+     word size, but the worst-case algorithms will be if we have few\n+     consecutive ones or zeros, i.e., a multiplicand like 10101010101...\n+     In that case we will generate shift-by-2, add, shift-by-2, add,...,\n+     in total wordsize operations.  */\n+  enum alg_code op[MAX_BITS_PER_WORD];\n+  char log[MAX_BITS_PER_WORD];\n+};\n+\n+/* The entry for our multiplication cache/hash table.  */\n+struct alg_hash_entry {\n+  /* The number we are multiplying by.  */\n+  unsigned HOST_WIDE_INT t;\n+\n+  /* The mode in which we are multiplying something by T.  */\n+  enum machine_mode mode;\n+\n+  /* The best multiplication algorithm for t.  */\n+  enum alg_code alg;\n+\n+  /* The cost of multiplication if ALG_CODE is not alg_impossible.\n+     Otherwise, the cost within which multiplication by T is\n+     impossible.  */\n+  struct mult_cost cost;\n+\n+  /* Optimized for speed? */\n+  bool speed;\n+};\n+\n+/* The number of cache/hash entries.  */\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#define NUM_ALG_HASH_ENTRIES 1031\n+#else\n+#define NUM_ALG_HASH_ENTRIES 307\n+#endif\n+\n /* Target-dependent globals.  */\n struct target_expmed {\n+  /* Each entry of ALG_HASH caches alg_code for some integer.  This is\n+     actually a hash table.  If we have a collision, that the older\n+     entry is kicked out.  */\n+  struct alg_hash_entry x_alg_hash[NUM_ALG_HASH_ENTRIES];\n+\n+  /* True if x_alg_hash might already have been used.  */\n+  bool x_alg_hash_used_p;\n+\n   /* Nonzero means divides or modulus operations are relatively cheap for\n      powers of two, so don't use branches; emit the operation instead.\n      Usually, this will mean that the MD file will emit non-branch\n@@ -54,6 +164,10 @@ extern struct target_expmed *this_target_expmed;\n #define this_target_expmed (&default_target_expmed)\n #endif\n \n+#define alg_hash \\\n+  (this_target_expmed->x_alg_hash)\n+#define alg_hash_used_p \\\n+  (this_target_expmed->x_alg_hash_used_p)\n #define sdiv_pow2_cheap \\\n   (this_target_expmed->x_sdiv_pow2_cheap)\n #define smod_pow2_cheap \\"}]}