{"sha": "f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlNTY2ZTUyNTNlNGIwZmUyZGNkNDc3ZmJjMzVjYTU1NzZjYzdiYw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-08-06T20:36:05Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-06T20:36:05Z"}, "message": "arith.c: Add #define for model numbers.\n\n2004-08-06  Steven G. Kargl  <kargls@comcast.net>\n\n\t* arith.c: Add #define for model numbers.  Remove global GMP variables.\n\t(natural_logarithm,common_logarithm,exponential,sine,\n\tcosine,arctangent,hypercos,hypersine ): Remove.\n\t(gfc_mpfr_to_mpz,gfc_set_model_kind,gfc_set_model): New functions.\n\t(arctangent2,gfc_arith_init_1,gfc_arith_done_1\n\tgfc_check_real_range, gfc_constant_result, gfc_range_check,\n\tgfc_arith_uminus,gfc_arith_plus, gfc_arith_minus, gfc_arith_times,\n\tgfc_arith_divide,complex_reciprocal,complex_pow_ui,\n\tgfc_arith_power,gfc_compare_expr,compare_complex,gfc_convert_real,\n\tgfc_convert_complex,gfc_int2real,gfc_int2complex,\n\tgfc_real2int,gfc_real2real,gfc_real2complex,\n\tgfc_complex2int,gfc_complex2real,gfc_complex2complex): Convert GMP\n\tto MPFR, use new functions.\n\t* arith.h: Remove extern global variables.\n\t(natural_logarithm,common_logarithm,exponential, sine, cosine,\n\tarctangent,hypercos,hypersine): Remove prototypes.\n\t(arctangent2): Update prototype from GMP to MPFR.\n\t(gfc_mpfr_to_mpz, gfc_set_model_kind,gfc_set_model): Add prototypes.\n\t* dump-parse-tree.c (gfc_show_expr): Convert GMP to MPFR.\n\t* expr.c (free_expr0,gfc_copy_expr): Convert GMP to MPFR.\n\t* gfortran.h (GFC_REAL_BITS): Remove.\n\t(arith): Add ARITH_NAN.\n\tInclude mpfr.h.  Define GFC_RND_MODE.\n\tRename GCC_GFORTRAN_H GFC_GFC_H.\n\t(gfc_expr): Convert GMP to MPFR.\n\t* module.c: Add arith.h, correct type in comment.\n\t(mio_gmp_real): Convert GMP to MPFR.\n\t(mio_expr):  Use gfc_set_model_kind().\n\t* primary.c:  Update copyright date with 2004.\n\t(match_real_constant,match_const_complex_part): Convert GMP to MPFR.\n\t* simplify.c: Remove global GMP variables\n\t(gfc_simplify_abs,gfc_simplify_acos,gfc_simplify_aimag,\n\tgfc_simplify_aint,gfc_simplify_dint,gfc_simplify_anint,\n\tgfc_simplify_dnint,gfc_simplify_asin,gfc_simplify_atan,\n\tgfc_simplify_atan2,gfc_simplify_ceiling,simplify_cmplx,\n\tgfc_simplify_conjg,gfc_simplify_cos,gfc_simplify_cosh,\n\tgfc_simplify_dim,gfc_simplify_dprod,gfc_simplify_epsilon,\n\tgfc_simplify_exp,gfc_simplify_exponent,gfc_simplify_floor,\n\tgfc_simplify_fraction,gfc_simplify_huge,gfc_simplify_int,\n\tgfc_simplify_ifix,gfc_simplify_idint,gfc_simplify_log,\n\tgfc_simplify_log10,simplify_min_max,gfc_simplify_mod,\n\tgfc_simplify_modulo,gfc_simplify_nearest,simplify_nint,\n\tgfc_simplify_rrspacing,gfc_simplify_scale,\n\tgfc_simplify_set_exponent,gfc_simplify_sign,gfc_simplify_sin,\n\tgfc_simplify_sinh,gfc_simplify_spacing,gfc_simplify_sqrt,\n\tgfc_simplify_tan,gfc_simplify_tanh,gfc_simplify_tiny,\n\tgfc_simplify_init_1,gfc_simplify_done_1):  Convert GMP to MPFR.\n\tUse new functions.\n\t* trans-const.c (gfc_conv_mpfr_to_tree): Rename from\n\tgfc_conv_mpf_to_tree.  Convert it to use MPFR\n\t(gfc_conv_constant_to_tree): Use it.\n\t* trans-const.h: Update prototype for gfc_conv_mpfr_to_tree().\n\t* trans-intrinsic.c: Add arith.h, remove gmp.h\n\t(gfc_conv_intrinsic_aint,gfc_conv_intrinsic_mod): Convert GMP to MPFR.\n\nFrom-SVN: r85652", "tree": {"sha": "53477a0ca399a88c97246cb2b86b7147d2cdaece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53477a0ca399a88c97246cb2b86b7147d2cdaece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/comments", "author": null, "committer": null, "parents": [{"sha": "1b4ed0bcf4f8a2d46d628dd7ad57ac9ec30a2a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4ed0bcf4f8a2d46d628dd7ad57ac9ec30a2a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b4ed0bcf4f8a2d46d628dd7ad57ac9ec30a2a46"}], "stats": {"total": 2224, "additions": 890, "deletions": 1334}, "files": [{"sha": "4d0b3309ffc928aa71a1a3a536bc37e8ae234707", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -1,3 +1,60 @@\n+2004-08-06  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* arith.c: Add #define for model numbers.  Remove global GMP variables.\n+\t(natural_logarithm,common_logarithm,exponential,sine,\n+\tcosine,arctangent,hypercos,hypersine ): Remove.\n+\t(gfc_mpfr_to_mpz,gfc_set_model_kind,gfc_set_model): New functions.\n+\t(arctangent2,gfc_arith_init_1,gfc_arith_done_1\n+\tgfc_check_real_range, gfc_constant_result, gfc_range_check,\n+\tgfc_arith_uminus,gfc_arith_plus, gfc_arith_minus, gfc_arith_times,\n+\tgfc_arith_divide,complex_reciprocal,complex_pow_ui,\n+\tgfc_arith_power,gfc_compare_expr,compare_complex,gfc_convert_real,\n+\tgfc_convert_complex,gfc_int2real,gfc_int2complex,\n+\tgfc_real2int,gfc_real2real,gfc_real2complex,\n+\tgfc_complex2int,gfc_complex2real,gfc_complex2complex): Convert GMP\n+\tto MPFR, use new functions.\n+\t* arith.h: Remove extern global variables.\n+\t(natural_logarithm,common_logarithm,exponential, sine, cosine,\n+\tarctangent,hypercos,hypersine): Remove prototypes.\n+\t(arctangent2): Update prototype from GMP to MPFR.\n+\t(gfc_mpfr_to_mpz, gfc_set_model_kind,gfc_set_model): Add prototypes.\n+\t* dump-parse-tree.c (gfc_show_expr): Convert GMP to MPFR.\n+\t* expr.c (free_expr0,gfc_copy_expr): Convert GMP to MPFR.\n+\t* gfortran.h (GFC_REAL_BITS): Remove.\n+\t(arith): Add ARITH_NAN.\n+\tInclude mpfr.h.  Define GFC_RND_MODE.\n+\tRename GCC_GFORTRAN_H GFC_GFC_H.\n+\t(gfc_expr): Convert GMP to MPFR.\n+\t* module.c: Add arith.h, correct type in comment.\n+\t(mio_gmp_real): Convert GMP to MPFR.\n+\t(mio_expr):  Use gfc_set_model_kind().\n+\t* primary.c:  Update copyright date with 2004.\n+\t(match_real_constant,match_const_complex_part): Convert GMP to MPFR.\n+\t* simplify.c: Remove global GMP variables\n+\t(gfc_simplify_abs,gfc_simplify_acos,gfc_simplify_aimag,\n+\tgfc_simplify_aint,gfc_simplify_dint,gfc_simplify_anint,\n+\tgfc_simplify_dnint,gfc_simplify_asin,gfc_simplify_atan,\n+\tgfc_simplify_atan2,gfc_simplify_ceiling,simplify_cmplx,\n+\tgfc_simplify_conjg,gfc_simplify_cos,gfc_simplify_cosh,\n+\tgfc_simplify_dim,gfc_simplify_dprod,gfc_simplify_epsilon,\n+\tgfc_simplify_exp,gfc_simplify_exponent,gfc_simplify_floor,\n+\tgfc_simplify_fraction,gfc_simplify_huge,gfc_simplify_int,\n+\tgfc_simplify_ifix,gfc_simplify_idint,gfc_simplify_log,\n+\tgfc_simplify_log10,simplify_min_max,gfc_simplify_mod,\n+\tgfc_simplify_modulo,gfc_simplify_nearest,simplify_nint,\n+\tgfc_simplify_rrspacing,gfc_simplify_scale,\n+\tgfc_simplify_set_exponent,gfc_simplify_sign,gfc_simplify_sin,\n+\tgfc_simplify_sinh,gfc_simplify_spacing,gfc_simplify_sqrt,\n+\tgfc_simplify_tan,gfc_simplify_tanh,gfc_simplify_tiny,\n+\tgfc_simplify_init_1,gfc_simplify_done_1):  Convert GMP to MPFR.\n+\tUse new functions.\n+\t* trans-const.c (gfc_conv_mpfr_to_tree): Rename from\n+\tgfc_conv_mpf_to_tree.  Convert it to use MPFR\n+\t(gfc_conv_constant_to_tree): Use it.\n+\t* trans-const.h: Update prototype for gfc_conv_mpfr_to_tree().\n+\t* trans-intrinsic.c: Add arith.h, remove gmp.h\n+\t(gfc_conv_intrinsic_aint,gfc_conv_intrinsic_mod): Convert GMP to MPFR.\n+\n 2004-08-06  Victor Leikehman  <lei@il.ibm.com>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "03ee14c099998381a44f4e48496d2ca8d47d7cab", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 320, "deletions": 744, "changes": 1064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -32,8 +32,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"gfortran.h\"\n #include \"arith.h\"\n \n-mpf_t pi, half_pi, two_pi, e;\n-\n /* The gfc_(integer|real)_kinds[] structures have everything the front\n    end needs to know about integers and real numbers on the target.\n    Other entries of the structure are calculated from these values.\n@@ -69,9 +67,31 @@ gfc_logical_info gfc_logical_kinds[] = {\n   DEF_GFC_LOGICAL_KIND (0,  0)\n };\n \n+\n+/* IEEE-754 uses 1.xEe representation whereas the fortran standard\n+   uses 0.xEe representation.  Hence the exponents below are biased\n+   by one.  */\n+\n+#define GFC_SP_KIND      4\n+#define GFC_SP_PREC     24   /* p    =   24, IEEE-754  */\n+#define GFC_SP_EMIN   -125   /* emin = -126, IEEE-754  */\n+#define GFC_SP_EMAX    128   /* emin =  127, IEEE-754  */\n+\n+/* Double precision model numbers.  */\n+#define GFC_DP_KIND      8\n+#define GFC_DP_PREC     53   /* p    =    53, IEEE-754  */\n+#define GFC_DP_EMIN  -1021   /* emin = -1022, IEEE-754  */\n+#define GFC_DP_EMAX   1024   /* emin =  1023, IEEE-754  */\n+\n+/* Quad precision model numbers.  Not used.  */\n+#define GFC_QP_KIND     16\n+#define GFC_QP_PREC    113   /* p    =    113, IEEE-754  */\n+#define GFC_QP_EMIN -16381   /* emin = -16382, IEEE-754  */\n+#define GFC_QP_EMAX  16384   /* emin =  16383, IEEE-754  */\n+\n gfc_real_info gfc_real_kinds[] = {\n-  DEF_GFC_REAL_KIND (4, 2, 24,  -125,  128),\n-  DEF_GFC_REAL_KIND (8, 2, 53, -1021, 1024),\n+  DEF_GFC_REAL_KIND (GFC_SP_KIND, 2, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX),\n+  DEF_GFC_REAL_KIND (GFC_DP_KIND, 2, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX),\n   DEF_GFC_REAL_KIND (0, 0,  0,     0,    0)\n };\n \n@@ -82,440 +102,67 @@ gfc_real_info gfc_real_kinds[] = {\n int gfc_index_integer_kind;\n \n \n-/* Compute the natural log of arg.\n-\n-   We first get the argument into the range 0.5 to 1.5 by successive\n-   multiplications or divisions by e.  Then we use the series:\n-\n-     ln(x) = (x-1) - (x-1)^2/2 + (x-1)^3/3 - (x-1)^4/4 + ...\n-\n-   Because we are expanding in powers of (x-1), and 0.5 < x < 1.5, we\n-   have -0.5 < (x-1) < 0.5.  Ignoring the harmonic term, this means\n-   that each term is at most 1/(2^i), meaning one bit is gained per\n-   iteration.\n-\n-   Not very efficient, but it doesn't have to be.  */\n+/* MPFR does not have a direct replacement for mpz_set_f() from GMP.\n+   It's easily implemented with a few calls though.  */\n \n void\n-natural_logarithm (mpf_t * arg, mpf_t * result)\n+gfc_mpfr_to_mpz(mpz_t z, mpfr_t x)\n {\n-  mpf_t x, xp, t, log;\n-  int i, p;\n-\n-  mpf_init_set (x, *arg);\n-  mpf_init (t);\n-\n-  p = 0;\n-\n-  mpf_set_str (t, \"0.5\", 10);\n-  while (mpf_cmp (x, t) < 0)\n-    {\n-      mpf_mul (x, x, e);\n-      p--;\n-    }\n-\n-  mpf_set_str (t, \"1.5\", 10);\n-  while (mpf_cmp (x, t) > 0)\n-    {\n-      mpf_div (x, x, e);\n-      p++;\n-    }\n-\n-  mpf_sub_ui (x, x, 1);\n-  mpf_init_set_ui (log, 0);\n-  mpf_init_set_ui (xp, 1);\n-\n-  for (i = 1; i < GFC_REAL_BITS; i++)\n-    {\n-      mpf_mul (xp, xp, x);\n-      mpf_div_ui (t, xp, i);\n+  mp_exp_t e;\n \n-      if (i % 2 == 0)\n-\tmpf_sub (log, log, t);\n-      else\n-\tmpf_add (log, log, t);\n-    }\n-\n-  /* Add in the log (e^p) = p */\n-\n-  if (p < 0)\n-    mpf_sub_ui (log, log, -p);\n+  e = mpfr_get_z_exp (z, x);\n+  if (e > 0)\n+    mpz_mul_2exp (z, z, e);\n   else\n-    mpf_add_ui (log, log, p);\n-\n-  mpf_clear (x);\n-  mpf_clear (xp);\n-  mpf_clear (t);\n-\n-  mpf_set (*result, log);\n-  mpf_clear (log);\n-}\n-\n-\n-/* Calculate the common logarithm of arg.  We use the natural\n-   logarithm of arg and of 10:\n-\n-   log10(arg) = log(arg)/log(10)  */\n-\n-void\n-common_logarithm (mpf_t * arg, mpf_t * result)\n-{\n-  mpf_t i10, log10;\n-\n-  natural_logarithm (arg, result);\n-\n-  mpf_init_set_ui (i10, 10);\n-  mpf_init (log10);\n-  natural_logarithm (&i10, &log10);\n-\n-  mpf_div (*result, *result, log10);\n-  mpf_clear (i10);\n-  mpf_clear (log10);\n+    mpz_tdiv_q_2exp (z, z, -e);\n+  if (mpfr_sgn (x) < 0)\n+    mpz_neg (z, z);\n }\n \n-/* Calculate exp(arg).\n-\n-   We use a reduction of the form\n-\n-     x = Nln2 + r\n \n-   Then we obtain exp(r) from the Maclaurin series.\n-   exp(x) is then recovered from the identity\n-\n-     exp(x) = 2^N*exp(r).  */\n+/* Set the model number precision by the requested KIND.  */\n \n void\n-exponential (mpf_t * arg, mpf_t * result)\n+gfc_set_model_kind (int kind)\n {\n-  mpf_t two, ln2, power, q, r, num, denom, term, x, xp;\n-  int i;\n-  long n;\n-  unsigned long p, mp;\n-\n-\n-  mpf_init_set (x, *arg);\n-\n-  if (mpf_cmp_ui (x, 0) == 0)\n-    {\n-      mpf_set_ui (*result, 1);\n-    }\n-  else if (mpf_cmp_ui (x, 1) == 0)\n-    {\n-      mpf_set (*result, e);\n-    }\n-  else\n-    {\n-      mpf_init_set_ui (two, 2);\n-      mpf_init (ln2);\n-      mpf_init (q);\n-      mpf_init (r);\n-      mpf_init (power);\n-      mpf_init (term);\n-\n-      natural_logarithm (&two, &ln2);\n-\n-      mpf_div (q, x, ln2);\n-      mpf_floor (power, q);\n-      mpf_mul (q, power, ln2);\n-      mpf_sub (r, x, q);\n-\n-      mpf_init_set_ui (xp, 1);\n-      mpf_init_set_ui (num, 1);\n-      mpf_init_set_ui (denom, 1);\n-\n-      for (i = 1; i <= GFC_REAL_BITS + 10; i++)\n+  switch (kind)\n \t{\n-\t  mpf_mul (num, num, r);\n-\t  mpf_mul_ui (denom, denom, i);\n-\t  mpf_div (term, num, denom);\n-\t  mpf_add (xp, xp, term);\n-\t}\n-\n-      /* Reconstruction step */\n-      n = (long) mpf_get_d (power);\n-\n-      if (n > 0)\n-\t{\n-\t  p = (unsigned int) n;\n-\t  mpf_mul_2exp (*result, xp, p);\n-\t}\n-      else\n-\t{\n-\t  mp = (unsigned int) (-n);\n-\t  mpf_div_2exp (*result, xp, mp);\n-\t}\n-\n-      mpf_clear (two);\n-      mpf_clear (ln2);\n-      mpf_clear (q);\n-      mpf_clear (r);\n-      mpf_clear (power);\n-      mpf_clear (num);\n-      mpf_clear (denom);\n-      mpf_clear (term);\n-      mpf_clear (xp);\n-    }\n-\n-  mpf_clear (x);\n-}\n-\n-\n-/* Calculate sin(arg).\n-\n-   We use a reduction of the form\n-\n-     x= N*2pi + r\n-\n-   Then we obtain sin(r) from the Maclaurin series.  */\n-\n-void\n-sine (mpf_t * arg, mpf_t * result)\n-{\n-  mpf_t factor, q, r, num, denom, term, x, xp;\n-  int i, sign;\n-\n-  mpf_init_set (x, *arg);\n-\n-  /* Special case (we do not treat multiples of pi due to roundoff issues) */\n-  if (mpf_cmp_ui (x, 0) == 0)\n-    {\n-      mpf_set_ui (*result, 0);\n-    }\n-  else\n-    {\n-      mpf_init (q);\n-      mpf_init (r);\n-      mpf_init (factor);\n-      mpf_init (term);\n-\n-      mpf_div (q, x, two_pi);\n-      mpf_floor (factor, q);\n-      mpf_mul (q, factor, two_pi);\n-      mpf_sub (r, x, q);\n-\n-      mpf_init_set_ui (xp, 0);\n-      mpf_init_set_ui (num, 1);\n-      mpf_init_set_ui (denom, 1);\n-\n-      sign = -1;\n-      for (i = 1; i < GFC_REAL_BITS + 10; i++)\n-\t{\n-\t  mpf_mul (num, num, r);\n-\t  mpf_mul_ui (denom, denom, i);\n-\t  if (i % 2 == 0)\n-\t    continue;\n-\n-\t  sign = -sign;\n-\t  mpf_div (term, num, denom);\n-\t  if (sign > 0)\n-\t    mpf_add (xp, xp, term);\n-\t  else\n-\t    mpf_sub (xp, xp, term);\n-\t}\n-\n-      mpf_set (*result, xp);\n-\n-      mpf_clear (q);\n-      mpf_clear (r);\n-      mpf_clear (factor);\n-      mpf_clear (num);\n-      mpf_clear (denom);\n-      mpf_clear (term);\n-      mpf_clear (xp);\n-    }\n-\n-  mpf_clear (x);\n-}\n-\n-\n-/* Calculate cos(arg).\n-\n-   Similar to sine.  */\n-\n-void\n-cosine (mpf_t * arg, mpf_t * result)\n-{\n-  mpf_t factor, q, r, num, denom, term, x, xp;\n-  int i, sign;\n-\n-  mpf_init_set (x, *arg);\n-\n-  /* Special case (we do not treat multiples of pi due to roundoff issues) */\n-  if (mpf_cmp_ui (x, 0) == 0)\n-    {\n-      mpf_set_ui (*result, 1);\n-    }\n-  else\n-    {\n-      mpf_init (q);\n-      mpf_init (r);\n-      mpf_init (factor);\n-      mpf_init (term);\n-\n-      mpf_div (q, x, two_pi);\n-      mpf_floor (factor, q);\n-      mpf_mul (q, factor, two_pi);\n-      mpf_sub (r, x, q);\n-\n-      mpf_init_set_ui (xp, 1);\n-      mpf_init_set_ui (num, 1);\n-      mpf_init_set_ui (denom, 1);\n-\n-      sign = 1;\n-      for (i = 1; i < GFC_REAL_BITS + 10; i++)\n-\t{\n-\t  mpf_mul (num, num, r);\n-\t  mpf_mul_ui (denom, denom, i);\n-\t  if (i % 2 != 0)\n-\t    continue;\n-\n-\t  sign = -sign;\n-\t  mpf_div (term, num, denom);\n-\t  if (sign > 0)\n-\t    mpf_add (xp, xp, term);\n-\t  else\n-\t    mpf_sub (xp, xp, term);\n-\t}\n-      mpf_set (*result, xp);\n-\n-      mpf_clear (q);\n-      mpf_clear (r);\n-      mpf_clear (factor);\n-      mpf_clear (num);\n-      mpf_clear (denom);\n-      mpf_clear (term);\n-      mpf_clear (xp);\n+    case GFC_SP_KIND:\n+      mpfr_set_default_prec (GFC_SP_PREC);\n+      break;\n+    case GFC_DP_KIND:\n+      mpfr_set_default_prec (GFC_DP_PREC);\n+      break;\n+    case GFC_QP_KIND:\n+      mpfr_set_default_prec (GFC_QP_PREC);\n+      break;\n+    default:\n+      gfc_internal_error (\"gfc_set_model_kind(): Bad model number\");\n     }\n-\n-  mpf_clear (x);\n }\n \n \n-/* Calculate atan(arg).\n-\n-   Similar to sine but requires special handling for x near 1.  */\n+/* Set the model number precision from mpfr_t x.  */\n \n void\n-arctangent (mpf_t * arg, mpf_t * result)\n+gfc_set_model (mpfr_t x)\n {\n-  mpf_t absval, convgu, convgl, num, term, x, xp;\n-  int i, sign;\n-\n-  mpf_init_set (x, *arg);\n-\n-  /* Special cases */\n-  if (mpf_cmp_ui (x, 0) == 0)\n+  switch (mpfr_get_prec (x))\n     {\n-      mpf_set_ui (*result, 0);\n-    }\n-  else if (mpf_cmp_ui (x, 1) == 0)\n-    {\n-      mpf_init (num);\n-      mpf_div_ui (num, half_pi, 2);\n-      mpf_set (*result, num);\n-      mpf_clear (num);\n-    }\n-  else if (mpf_cmp_si (x, -1) == 0)\n-    {\n-      mpf_init (num);\n-      mpf_div_ui (num, half_pi, 2);\n-      mpf_neg (*result, num);\n-      mpf_clear (num);\n-    }\n-  else\n-    {\t\t\t\t/* General cases */\n-\n-      mpf_init (absval);\n-      mpf_abs (absval, x);\n-\n-      mpf_init_set_d (convgu, 1.5);\n-      mpf_init_set_d (convgl, 0.5);\n-      mpf_init_set_ui (num, 1);\n-      mpf_init (term);\n-\n-      if (mpf_cmp (absval, convgl) < 0)\n-\t{\n-\t  mpf_init_set_ui (xp, 0);\n-\t  sign = -1;\n-\t  for (i = 1; i < GFC_REAL_BITS + 10; i++)\n-\t    {\n-\t      mpf_mul (num, num, absval);\n-\t      if (i % 2 == 0)\n-\t\tcontinue;\n-\n-\t      sign = -sign;\n-\t      mpf_div_ui (term, num, i);\n-\t      if (sign > 0)\n-\t\tmpf_add (xp, xp, term);\n-\t      else\n-\t\tmpf_sub (xp, xp, term);\n-\t    }\n-\t}\n-      else if (mpf_cmp (absval, convgu) >= 0)\n-\t{\n-\t  mpf_init_set (xp, half_pi);\n-\t  sign = 1;\n-\t  for (i = 1; i < GFC_REAL_BITS + 10; i++)\n-\t    {\n-\t      mpf_div (num, num, absval);\n-\t      if (i % 2 == 0)\n-\t\tcontinue;\n-\n-\t      sign = -sign;\n-\t      mpf_div_ui (term, num, i);\n-\t      if (sign > 0)\n-\t\tmpf_add (xp, xp, term);\n-\t      else\n-\t\tmpf_sub (xp, xp, term);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  mpf_init_set_ui (xp, 0);\n-\n-\t  mpf_sub_ui (num, absval, 1);\n-\t  mpf_add_ui (term, absval, 1);\n-\t  mpf_div (absval, num, term);\n-\n-\t  mpf_set_ui (num, 1);\n-\n-\t  sign = -1;\n-\t  for (i = 1; i < GFC_REAL_BITS + 10; i++)\n-\t    {\n-\t      mpf_mul (num, num, absval);\n-\t      if (i % 2 == 0)\n-\t\tcontinue;\n-\t      sign = -sign;\n-\t      mpf_div_ui (term, num, i);\n-\t      if (sign > 0)\n-\t\tmpf_add (xp, xp, term);\n-\t      else\n-\t\tmpf_sub (xp, xp, term);\n-\t    }\n-\n-\t  mpf_div_ui (term, half_pi, 2);\n-\t  mpf_add (xp, term, xp);\n-\t}\n-\n-      /* This makes sure to preserve the identity arctan(-x) = -arctan(x)\n-         and improves accuracy to boot.  */\n-\n-      if (mpf_cmp_ui (x, 0) > 0)\n-\tmpf_set (*result, xp);\n-      else\n-\tmpf_neg (*result, xp);\n-\n-      mpf_clear (absval);\n-      mpf_clear (convgl);\n-      mpf_clear (convgu);\n-      mpf_clear (num);\n-      mpf_clear (term);\n-      mpf_clear (xp);\n+    case GFC_SP_PREC:\n+      mpfr_set_default_prec (GFC_SP_PREC);\n+      break;\n+    case GFC_DP_PREC:\n+      mpfr_set_default_prec (GFC_DP_PREC);\n+      break;\n+    case GFC_QP_PREC:\n+      mpfr_set_default_prec (GFC_QP_PREC);\n+      break;\n+    default:\n+      gfc_internal_error (\"gfc_set_model(): Bad model number\");\n     }\n-  mpf_clear (x);\n }\n \n-\n /* Calculate atan2 (y, x)\n \n atan2(y, x) = atan(y/x)\t\t\t\tif x > 0,\n@@ -525,97 +172,46 @@ atan2(y, x) = atan(y/x)\t\t\t\tif x > 0,\n */\n \n void\n-arctangent2 (mpf_t * y, mpf_t * x, mpf_t * result)\n+arctangent2 (mpfr_t y, mpfr_t x, mpfr_t result)\n {\n-  mpf_t t;\n+  int i;\n+  mpfr_t t;\n \n-  mpf_init (t);\n+  gfc_set_model (y);\n+  mpfr_init (t);\n \n-  switch (mpf_sgn (*x))\n+  i = mpfr_sgn(x);\n+\n+  if (i > 0)\n     {\n-    case 1:\n-      mpf_div (t, *y, *x);\n-      arctangent (&t, result);\n-      break;\n-    case -1:\n-      mpf_div (t, *y, *x);\n-      mpf_abs (t, t);\n-      arctangent (&t, &t);\n-      mpf_sub (*result, pi, t);\n-      if (mpf_sgn (*y) == -1)\n-\tmpf_neg (*result, *result);\n-      break;\n-    case 0:\n-      if (mpf_sgn (*y) == 0)\n-\tmpf_set_ui (*result, 0);\n+      mpfr_div (t, y, x, GFC_RND_MODE);\n+      mpfr_atan (result, t, GFC_RND_MODE);\n+    }\n+  else if (i < 0)\n+    {\n+      mpfr_const_pi (result, GFC_RND_MODE);\n+      mpfr_div (t, y, x, GFC_RND_MODE);\n+      mpfr_abs (t, t, GFC_RND_MODE);\n+      mpfr_atan (t, t, GFC_RND_MODE);\n+      mpfr_sub (result, result, t, GFC_RND_MODE);\n+      if (mpfr_sgn (y) < 0)\n+\tmpfr_neg (result, result, GFC_RND_MODE);\n+    }\n+      else\n+\t{\n+      if (mpfr_sgn (y) == 0)\n+\tmpfr_set_ui (result, 0, GFC_RND_MODE);\n       else\n \t{\n-\t  mpf_set (*result, half_pi);\n-\t  if (mpf_sgn (*y) == -1)\n-\t    mpf_neg (*result, *result);\n+          mpfr_const_pi (result, GFC_RND_MODE);\n+          mpfr_div_ui (result, result, 2, GFC_RND_MODE);\n+\t  if (mpfr_sgn (y) < 0)\n+\t    mpfr_neg (result, result, GFC_RND_MODE);\n \t}\n-       break;\n     }\n-  mpf_clear (t);\n-}\n-\n-/* Calculate cosh(arg). */\n-\n-void\n-hypercos (mpf_t * arg, mpf_t * result)\n-{\n-  mpf_t neg, term1, term2, x, xp;\n-\n-  mpf_init_set (x, *arg);\n \n-  mpf_init (neg);\n-  mpf_init (term1);\n-  mpf_init (term2);\n-  mpf_init (xp);\n+  mpfr_clear (t);\n \n-  mpf_neg (neg, x);\n-\n-  exponential (&x, &term1);\n-  exponential (&neg, &term2);\n-\n-  mpf_add (xp, term1, term2);\n-  mpf_div_ui (*result, xp, 2);\n-\n-  mpf_clear (neg);\n-  mpf_clear (term1);\n-  mpf_clear (term2);\n-  mpf_clear (x);\n-  mpf_clear (xp);\n-}\n-\n-\n-/* Calculate sinh(arg). */\n-\n-void\n-hypersine (mpf_t * arg, mpf_t * result)\n-{\n-  mpf_t neg, term1, term2, x, xp;\n-\n-  mpf_init_set (x, *arg);\n-\n-  mpf_init (neg);\n-  mpf_init (term1);\n-  mpf_init (term2);\n-  mpf_init (xp);\n-\n-  mpf_neg (neg, x);\n-\n-  exponential (&x, &term1);\n-  exponential (&neg, &term2);\n-\n-  mpf_sub (xp, term1, term2);\n-  mpf_div_ui (*result, xp, 2);\n-\n-  mpf_clear (neg);\n-  mpf_clear (term1);\n-  mpf_clear (term2);\n-  mpf_clear (x);\n-  mpf_clear (xp);\n }\n \n \n@@ -638,6 +234,9 @@ gfc_arith_error (arith code)\n     case ARITH_UNDERFLOW:\n       p = \"Arithmetic underflow\";\n       break;\n+    case ARITH_NAN:\n+      p = \"Arithmetic NaN\";\n+      break;\n     case ARITH_DIV0:\n       p = \"Division by zero\";\n       break;\n@@ -662,72 +261,17 @@ gfc_arith_init_1 (void)\n {\n   gfc_integer_info *int_info;\n   gfc_real_info *real_info;\n-  mpf_t a, b;\n+  mpfr_t a, b, c;\n   mpz_t r;\n-  int i, n, limit;\n-\n-  /* Set the default precision for GMP computations.  */\n-  mpf_set_default_prec (GFC_REAL_BITS + 30);\n-\n-  /* Calculate e, needed by the natural_logarithm() subroutine.  */\n-  mpf_init (b);\n-  mpf_init_set_ui (e, 0);\n-  mpf_init_set_ui (a, 1);\n-\n-  for (i = 1; i < 100; i++)\n-    {\n-      mpf_add (e, e, a);\n-      mpf_div_ui (a, a, i);\t/* 1/(i!) */\n-    }\n-\n-  /* Calculate pi, 2pi, pi/2, and -pi/2, needed for trigonometric\n-     functions.\n-\n-     We use the Bailey, Borwein and Plouffe formula:\n-\n-       pi = \\sum{n=0}^\\infty (1/16)^n [4/(8n+1) - 2/(8n+4) - 1/(8n+5) - 1/(8n+6)]\n-\n-     which gives about four bits per iteration.  */\n-\n-  mpf_init_set_ui (pi, 0);\n-\n-  mpf_init (two_pi);\n-  mpf_init (half_pi);\n-\n-  limit = (GFC_REAL_BITS / 4) + 10;\t/* (1/16)^n gives 4 bits per iteration */\n-\n-  for (n = 0; n < limit; n++)\n-    {\n-      mpf_set_ui (b, 4);\n-      mpf_div_ui (b, b, 8 * n + 1);\t/* 4/(8n+1) */\n-\n-      mpf_set_ui (a, 2);\n-      mpf_div_ui (a, a, 8 * n + 4);\t/* 2/(8n+4) */\n-      mpf_sub (b, b, a);\n-\n-      mpf_set_ui (a, 1);\n-      mpf_div_ui (a, a, 8 * n + 5);\t/* 1/(8n+5) */\n-      mpf_sub (b, b, a);\n-\n-      mpf_set_ui (a, 1);\n-      mpf_div_ui (a, a, 8 * n + 6);\t/* 1/(8n+6) */\n-      mpf_sub (b, b, a);\n-\n-      mpf_set_ui (a, 16);\n-      mpf_pow_ui (a, a, n);\t/* 16^n */\n-\n-      mpf_div (b, b, a);\n+  int i;\n \n-      mpf_add (pi, pi, b);\n-    }\n+  gfc_set_model_kind (GFC_QP_KIND);\n \n-  mpf_mul_ui (two_pi, pi, 2);\n-  mpf_div_ui (half_pi, pi, 2);\n+  mpfr_init (a);\n+  mpz_init (r);\n \n   /* Convert the minimum/maximum values for each kind into their\n      GNU MP representation.  */\n-  mpz_init (r);\n-\n   for (int_info = gfc_integer_kinds; int_info->kind != 0; int_info++)\n     {\n       /* Huge */\n@@ -751,71 +295,90 @@ gfc_arith_init_1 (void)\n       mpz_add_ui (int_info->max_int, int_info->max_int, 1);\n \n       /* Range */\n-      mpf_set_z (a, int_info->huge);\n-      common_logarithm (&a, &a);\n-      mpf_trunc (a, a);\n-      mpz_set_f (r, a);\n+      mpfr_set_z (a, int_info->huge, GFC_RND_MODE);\n+      mpfr_log10 (a, a, GFC_RND_MODE);\n+      mpfr_trunc (a, a);\n+      gfc_mpfr_to_mpz (r, a);\n       int_info->range = mpz_get_si (r);\n     }\n \n-  /*  mpf_set_default_prec(GFC_REAL_BITS); */\n+  mpfr_clear (a);\n+\n   for (real_info = gfc_real_kinds; real_info->kind != 0; real_info++)\n     {\n-      /* Huge */\n-      mpf_set_ui (a, real_info->radix);\n-      mpf_set_ui (b, real_info->radix);\n+      gfc_set_model_kind (real_info->kind);\n \n-      mpf_pow_ui (a, a, real_info->max_exponent);\n-      mpf_pow_ui (b, b, real_info->max_exponent - real_info->digits);\n+      mpfr_init (a);\n+      mpfr_init (b);\n+      mpfr_init (c);\n \n-      mpf_init (real_info->huge);\n-      mpf_sub (real_info->huge, a, b);\n+      /* huge(x) = (1 - b**(-p)) * b**(emax-1) * b  */\n+      /* a = 1 - b**(-p) */\n+      mpfr_set_ui (a, 1, GFC_RND_MODE);\n+      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (b, b, -real_info->digits, GFC_RND_MODE);\n+      mpfr_sub (a, a, b, GFC_RND_MODE);\n \n-      /* Tiny */\n-      mpf_set_ui (b, real_info->radix);\n-      mpf_pow_ui (b, b, 1 - real_info->min_exponent);\n+      /* c = b**(emax-1) */\n+      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_ui (c, b, real_info->max_exponent - 1, GFC_RND_MODE);\n \n-      mpf_init (real_info->tiny);\n-      mpf_ui_div (real_info->tiny, 1, b);\n+      /* a = a * c = (1 - b**(-p)) * b**(emax-1) */\n+      mpfr_mul (a, a, c, GFC_RND_MODE);\n \n-      /* Epsilon */\n-      mpf_set_ui (b, real_info->radix);\n-      mpf_pow_ui (b, b, real_info->digits - 1);\n+      /* a = (1 - b**(-p)) * b**(emax-1) * b */\n+      mpfr_mul_ui (a, a, real_info->radix, GFC_RND_MODE);\n \n-      mpf_init (real_info->epsilon);\n-      mpf_ui_div (real_info->epsilon, 1, b);\n+      mpfr_init (real_info->huge);\n+      mpfr_set (real_info->huge, a, GFC_RND_MODE);\n \n-      /* Range */\n-      common_logarithm (&real_info->huge, &a);\n-      common_logarithm (&real_info->tiny, &b);\n-      mpf_neg (b, b);\n+      /* tiny(x) = b**(emin-1) */\n+      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (b, b, real_info->min_exponent - 1, GFC_RND_MODE);\n+\n+      mpfr_init (real_info->tiny);\n+      mpfr_set (real_info->tiny, b, GFC_RND_MODE);\n+\n+      /* epsilon(x) = b**(1-p) */\n+      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (b, b, 1 - real_info->digits, GFC_RND_MODE);\n+\n+      mpfr_init (real_info->epsilon);\n+      mpfr_set (real_info->epsilon, b, GFC_RND_MODE);\n \n-      if (mpf_cmp (a, b) > 0)\n-\tmpf_set (a, b);\t\t/* a = min(a, b) */\n+      /* range(x) = int(min(log10(huge(x)), -log10(tiny)) */\n+      mpfr_log10 (a, real_info->huge, GFC_RND_MODE);\n+      mpfr_log10 (b, real_info->tiny, GFC_RND_MODE);\n+      mpfr_neg (b, b, GFC_RND_MODE);\n \n-      mpf_trunc (a, a);\n-      mpz_set_f (r, a);\n+      if (mpfr_cmp (a, b) > 0)\n+\tmpfr_set (a, b, GFC_RND_MODE);\t\t/* a = min(a, b) */\n+\n+      mpfr_trunc (a, a);\n+      gfc_mpfr_to_mpz (r, a);\n       real_info->range = mpz_get_si (r);\n \n-      /* Precision */\n-      mpf_set_ui (a, real_info->radix);\n-      common_logarithm (&a, &a);\n+      /* precision(x) = int((p - 1) * log10(b)) + k */\n+      mpfr_set_ui (a, real_info->radix, GFC_RND_MODE);\n+      mpfr_log10 (a, a, GFC_RND_MODE);\n \n-      mpf_mul_ui (a, a, real_info->digits - 1);\n-      mpf_trunc (a, a);\n-      mpz_set_f (r, a);\n+      mpfr_mul_ui (a, a, real_info->digits - 1, GFC_RND_MODE);\n+      mpfr_trunc (a, a);\n+      gfc_mpfr_to_mpz (r, a);\n       real_info->precision = mpz_get_si (r);\n \n       /* If the radix is an integral power of 10, add one to the\n          precision.  */\n       for (i = 10; i <= real_info->radix; i *= 10)\n \tif (i == real_info->radix)\n \t  real_info->precision++;\n+\n+      mpfr_clear (a);\n+      mpfr_clear (b);\n+      mpfr_clear (c);\n     }\n \n   mpz_clear (r);\n-  mpf_clear (a);\n-  mpf_clear (b);\n }\n \n \n@@ -827,12 +390,6 @@ gfc_arith_done_1 (void)\n   gfc_integer_info *ip;\n   gfc_real_info *rp;\n \n-  mpf_clear (e);\n-\n-  mpf_clear (pi);\n-  mpf_clear (half_pi);\n-  mpf_clear (two_pi);\n-\n   for (ip = gfc_integer_kinds; ip->kind; ip++)\n     {\n       mpz_clear (ip->min_int);\n@@ -842,9 +399,9 @@ gfc_arith_done_1 (void)\n \n   for (rp = gfc_real_kinds; rp->kind; rp++)\n     {\n-      mpf_clear (rp->epsilon);\n-      mpf_clear (rp->huge);\n-      mpf_clear (rp->tiny);\n+      mpfr_clear (rp->epsilon);\n+      mpfr_clear (rp->huge);\n+      mpfr_clear (rp->tiny);\n     }\n }\n \n@@ -1022,34 +579,35 @@ gfc_check_integer_range (mpz_t p, int kind)\n    ARITH_UNDERFLOW.  */\n \n static arith\n-gfc_check_real_range (mpf_t p, int kind)\n+gfc_check_real_range (mpfr_t p, int kind)\n {\n   arith retval;\n-  mpf_t q;\n+  mpfr_t q;\n   int i;\n \n-  mpf_init (q);\n-  mpf_abs (q, p);\n-\n   i = validate_real (kind);\n   if (i == -1)\n     gfc_internal_error (\"gfc_check_real_range(): Bad kind\");\n \n+  gfc_set_model (p);\n+  mpfr_init (q);\n+  mpfr_abs (q, p, GFC_RND_MODE);\n+\n   retval = ARITH_OK;\n-  if (mpf_sgn (q) == 0)\n+  if (mpfr_sgn (q) == 0)\n     goto done;\n \n-  if (mpf_cmp (q, gfc_real_kinds[i].huge) == 1)\n+  if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n     {\n       retval = ARITH_OVERFLOW;\n       goto done;\n     }\n \n-  if (mpf_cmp (q, gfc_real_kinds[i].tiny) == -1)\n+  if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     retval = ARITH_UNDERFLOW;\n \n done:\n-  mpf_clear (q);\n+  mpfr_clear (q);\n \n   return retval;\n }\n@@ -1081,12 +639,14 @@ gfc_constant_result (bt type, int kind, locus * where)\n       break;\n \n     case BT_REAL:\n-      mpf_init (result->value.real);\n+      gfc_set_model_kind (kind);\n+      mpfr_init (result->value.real);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_init (result->value.complex.r);\n-      mpf_init (result->value.complex.i);\n+      gfc_set_model_kind (kind);\n+      mpfr_init (result->value.complex.r);\n+      mpfr_init (result->value.complex.i);\n       break;\n \n     default:\n@@ -1173,9 +733,7 @@ gfc_arith_neqv (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n /* Make sure a constant numeric expression is within the range for\n-   its type and kind.  GMP is doing 130 bit arithmetic, so an UNDERFLOW\n-   is numerically zero for REAL(4) and REAL(8) types.  Reset the value(s)\n-   to exactly 0 for UNDERFLOW.  Note that there's also a gfc_check_range(),\n+   its type and kind.  Note that there's also a gfc_check_range(),\n    but that one deals with the intrinsic RANGE function.  */\n \n arith\n@@ -1192,18 +750,18 @@ gfc_range_check (gfc_expr * e)\n     case BT_REAL:\n       rc = gfc_check_real_range (e->value.real, e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-        mpf_set_ui (e->value.real, 0);\n+        mpfr_set_ui (e->value.real, 0, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n       rc = gfc_check_real_range (e->value.complex.r, e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-        mpf_set_ui (e->value.complex.r, 0);\n+        mpfr_set_ui (e->value.complex.r, 0, GFC_RND_MODE);\n       if (rc == ARITH_OK || rc == ARITH_UNDERFLOW)\n         {\n           rc = gfc_check_real_range (e->value.complex.i, e->ts.kind);\n           if (rc == ARITH_UNDERFLOW)\n-            mpf_set_ui (e->value.complex.i, 0);\n+            mpfr_set_ui (e->value.complex.i, 0, GFC_RND_MODE);\n         }\n \n       break;\n@@ -1244,12 +802,12 @@ gfc_arith_uminus (gfc_expr * op1, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      mpf_neg (result->value.real, op1->value.real);\n+      mpfr_neg (result->value.real, op1->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_neg (result->value.complex.r, op1->value.complex.r);\n-      mpf_neg (result->value.complex.i, op1->value.complex.i);\n+      mpfr_neg (result->value.complex.r, op1->value.complex.r, GFC_RND_MODE);\n+      mpfr_neg (result->value.complex.i, op1->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -1289,15 +847,16 @@ gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      mpf_add (result->value.real, op1->value.real, op2->value.real);\n+      mpfr_add (result->value.real, op1->value.real, op2->value.real,\n+               GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_add (result->value.complex.r, op1->value.complex.r,\n-\t       op2->value.complex.r);\n+      mpfr_add (result->value.complex.r, op1->value.complex.r,\n+\t       op2->value.complex.r, GFC_RND_MODE);\n \n-      mpf_add (result->value.complex.i, op1->value.complex.i,\n-\t       op2->value.complex.i);\n+      mpfr_add (result->value.complex.i, op1->value.complex.i,\n+\t       op2->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -1337,16 +896,16 @@ gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      mpf_sub (result->value.real, op1->value.real, op2->value.real);\n+      mpfr_sub (result->value.real, op1->value.real, op2->value.real,\n+                GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_sub (result->value.complex.r, op1->value.complex.r,\n-\t       op2->value.complex.r);\n-\n-      mpf_sub (result->value.complex.i, op1->value.complex.i,\n-\t       op2->value.complex.i);\n+      mpfr_sub (result->value.complex.r, op1->value.complex.r,\n+\t       op2->value.complex.r, GFC_RND_MODE);\n \n+      mpfr_sub (result->value.complex.i, op1->value.complex.i,\n+\t       op2->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -1375,7 +934,7 @@ static arith\n gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n {\n   gfc_expr *result;\n-  mpf_t x, y;\n+  mpfr_t x, y;\n   arith rc;\n \n   result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n@@ -1387,23 +946,28 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      mpf_mul (result->value.real, op1->value.real, op2->value.real);\n+      mpfr_mul (result->value.real, op1->value.real, op2->value.real,\n+               GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_init (x);\n-      mpf_init (y);\n \n-      mpf_mul (x, op1->value.complex.r, op2->value.complex.r);\n-      mpf_mul (y, op1->value.complex.i, op2->value.complex.i);\n-      mpf_sub (result->value.complex.r, x, y);\n+      /* FIXME:  possible numericals problem.  */\n \n-      mpf_mul (x, op1->value.complex.r, op2->value.complex.i);\n-      mpf_mul (y, op1->value.complex.i, op2->value.complex.r);\n-      mpf_add (result->value.complex.i, x, y);\n+      gfc_set_model (op1->value.complex.r);\n+      mpfr_init (x);\n+      mpfr_init (y);\n \n-      mpf_clear (x);\n-      mpf_clear (y);\n+      mpfr_mul (x, op1->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (y, op1->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n+      mpfr_sub (result->value.complex.r, x, y, GFC_RND_MODE);\n+\n+      mpfr_mul (x, op1->value.complex.r, op2->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (y, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n+      mpfr_add (result->value.complex.i, x, y, GFC_RND_MODE);\n+\n+      mpfr_clear (x);\n+      mpfr_clear (y);\n \n       break;\n \n@@ -1433,7 +997,7 @@ static arith\n gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n {\n   gfc_expr *result;\n-  mpf_t x, y, div;\n+  mpfr_t x, y, div;\n   arith rc;\n \n   rc = ARITH_OK;\n@@ -1454,44 +1018,51 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      if (mpf_sgn (op2->value.real) == 0)\n+      /* FIXME: MPFR correctly generates NaN.  This may not be needed.  */\n+      if (mpfr_sgn (op2->value.real) == 0)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n \t}\n \n-      mpf_div (result->value.real, op1->value.real, op2->value.real);\n+      mpfr_div (result->value.real, op1->value.real, op2->value.real,\n+               GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      if (mpf_sgn (op2->value.complex.r) == 0\n-\t  && mpf_sgn (op2->value.complex.i) == 0)\n+      /* FIXME: MPFR correctly generates NaN.  This may not be needed.  */\n+      if (mpfr_sgn (op2->value.complex.r) == 0\n+\t  && mpfr_sgn (op2->value.complex.i) == 0)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n \t}\n \n-      mpf_init (x);\n-      mpf_init (y);\n-      mpf_init (div);\n+      gfc_set_model (op1->value.complex.r);\n+      mpfr_init (x);\n+      mpfr_init (y);\n+      mpfr_init (div);\n \n-      mpf_mul (x, op2->value.complex.r, op2->value.complex.r);\n-      mpf_mul (y, op2->value.complex.i, op2->value.complex.i);\n-      mpf_add (div, x, y);\n+      /* FIXME: possible numerical problems.  */\n+      mpfr_mul (x, op2->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (y, op2->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n+      mpfr_add (div, x, y, GFC_RND_MODE);\n \n-      mpf_mul (x, op1->value.complex.r, op2->value.complex.r);\n-      mpf_mul (y, op1->value.complex.i, op2->value.complex.i);\n-      mpf_add (result->value.complex.r, x, y);\n-      mpf_div (result->value.complex.r, result->value.complex.r, div);\n+      mpfr_mul (x, op1->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (y, op1->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n+      mpfr_add (result->value.complex.r, x, y, GFC_RND_MODE);\n+      mpfr_div (result->value.complex.r, result->value.complex.r, div,\n+                GFC_RND_MODE);\n \n-      mpf_mul (x, op1->value.complex.i, op2->value.complex.r);\n-      mpf_mul (y, op1->value.complex.r, op2->value.complex.i);\n-      mpf_sub (result->value.complex.i, x, y);\n-      mpf_div (result->value.complex.i, result->value.complex.i, div);\n+      mpfr_mul (x, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (y, op1->value.complex.r, op2->value.complex.i, GFC_RND_MODE);\n+      mpfr_sub (result->value.complex.i, x, y, GFC_RND_MODE);\n+      mpfr_div (result->value.complex.i, result->value.complex.i, div,\n+                GFC_RND_MODE);\n \n-      mpf_clear (x);\n-      mpf_clear (y);\n-      mpf_clear (div);\n+      mpfr_clear (x);\n+      mpfr_clear (y);\n+      mpfr_clear (div);\n \n       break;\n \n@@ -1523,30 +1094,31 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n static void\n complex_reciprocal (gfc_expr * op)\n {\n-  mpf_t mod, a, result_r, result_i;\n-\n-  mpf_init (mod);\n-  mpf_init (a);\n+  mpfr_t mod, a, re, im;\n \n-  mpf_mul (mod, op->value.complex.r, op->value.complex.r);\n-  mpf_mul (a, op->value.complex.i, op->value.complex.i);\n-  mpf_add (mod, mod, a);\n+  gfc_set_model (op->value.complex.r);\n+  mpfr_init (mod);\n+  mpfr_init (a);\n+  mpfr_init (re);\n+  mpfr_init (im);\n \n-  mpf_init (result_r);\n-  mpf_div (result_r, op->value.complex.r, mod);\n+  /* FIXME:  another possible numerical problem.  */\n+  mpfr_mul (mod, op->value.complex.r, op->value.complex.r, GFC_RND_MODE);\n+  mpfr_mul (a, op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n+  mpfr_add (mod, mod, a, GFC_RND_MODE);\n \n-  mpf_init (result_i);\n-  mpf_neg (result_i, op->value.complex.i);\n-  mpf_div (result_i, result_i, mod);\n+  mpfr_div (re, op->value.complex.r, mod, GFC_RND_MODE);\n \n-  mpf_set (op->value.complex.r, result_r);\n-  mpf_set (op->value.complex.i, result_i);\n+  mpfr_neg (im, op->value.complex.i, GFC_RND_MODE);\n+  mpfr_div (im, im, mod, GFC_RND_MODE);\n \n-  mpf_clear (result_r);\n-  mpf_clear (result_i);\n+  mpfr_set (op->value.complex.r, re, GFC_RND_MODE);\n+  mpfr_set (op->value.complex.i, im, GFC_RND_MODE);\n \n-  mpf_clear (mod);\n-  mpf_clear (a);\n+  mpfr_clear (re);\n+  mpfr_clear (im);\n+  mpfr_clear (mod);\n+  mpfr_clear (a);\n }\n \n \n@@ -1555,32 +1127,37 @@ complex_reciprocal (gfc_expr * op)\n static void\n complex_pow_ui (gfc_expr * base, int power, gfc_expr * result)\n {\n-  mpf_t temp_r, temp_i, a;\n+  mpfr_t re, im, a;\n \n-  mpf_set_ui (result->value.complex.r, 1);\n-  mpf_set_ui (result->value.complex.i, 0);\n+  gfc_set_model (base->value.complex.r);\n+  mpfr_init (re);\n+  mpfr_init (im);\n+  mpfr_init (a);\n \n-  mpf_init (temp_r);\n-  mpf_init (temp_i);\n-  mpf_init (a);\n+  mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n+  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \n   for (; power > 0; power--)\n     {\n-      mpf_mul (temp_r, base->value.complex.r, result->value.complex.r);\n-      mpf_mul (a, base->value.complex.i, result->value.complex.i);\n-      mpf_sub (temp_r, temp_r, a);\n+      mpfr_mul (re, base->value.complex.r, result->value.complex.r,\n+                GFC_RND_MODE);\n+      mpfr_mul (a, base->value.complex.i, result->value.complex.i,\n+                GFC_RND_MODE);\n+      mpfr_sub (re, re, a, GFC_RND_MODE);\n \n-      mpf_mul (temp_i, base->value.complex.r, result->value.complex.i);\n-      mpf_mul (a, base->value.complex.i, result->value.complex.r);\n-      mpf_add (temp_i, temp_i, a);\n+      mpfr_mul (im, base->value.complex.r, result->value.complex.i,\n+                GFC_RND_MODE);\n+      mpfr_mul (a, base->value.complex.i, result->value.complex.r,\n+                GFC_RND_MODE);\n+      mpfr_add (im, im, a, GFC_RND_MODE);\n \n-      mpf_set (result->value.complex.r, temp_r);\n-      mpf_set (result->value.complex.i, temp_i);\n+      mpfr_set (result->value.complex.r, re, GFC_RND_MODE);\n+      mpfr_set (result->value.complex.i, im, GFC_RND_MODE);\n     }\n \n-  mpf_clear (temp_r);\n-  mpf_clear (temp_i);\n-  mpf_clear (a);\n+  mpfr_clear (re);\n+  mpfr_clear (im);\n+  mpfr_clear (a);\n }\n \n \n@@ -1592,7 +1169,7 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n   int power, apower;\n   gfc_expr *result;\n   mpz_t unity_z;\n-  mpf_t unity_f;\n+  mpfr_t unity_f;\n   arith rc;\n \n   rc = ARITH_OK;\n@@ -1611,25 +1188,23 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \t    rc = ARITH_0TO0;\n \t  else\n \t    mpz_set_ui (result->value.integer, 1);\n-\n \t  break;\n \n \tcase BT_REAL:\n-\t  if (mpf_sgn (op1->value.real) == 0)\n+\t  if (mpfr_sgn (op1->value.real) == 0)\n \t    rc = ARITH_0TO0;\n \t  else\n-\t    mpf_set_ui (result->value.real, 1);\n-\n+\t    mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_COMPLEX:\n-\t  if (mpf_sgn (op1->value.complex.r) == 0\n-\t      && mpf_sgn (op1->value.complex.i) == 0)\n+\t  if (mpfr_sgn (op1->value.complex.r) == 0\n+\t      && mpfr_sgn (op1->value.complex.i) == 0)\n \t    rc = ARITH_0TO0;\n \t  else\n \t    {\n-\t      mpf_set_ui (result->value.complex.r, 1);\n-\t      mpf_set_ui (result->value.complex.i, 0);\n+\t      mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n+\t      mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \t    }\n \n \t  break;\n@@ -1638,8 +1213,7 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \t  gfc_internal_error (\"gfc_arith_power(): Bad base\");\n \t}\n     }\n-\n-  if (power != 0)\n+  else\n     {\n       apower = power;\n       if (power < 0)\n@@ -1661,22 +1235,24 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpf_pow_ui (result->value.real, op1->value.real, apower);\n+\t  mpfr_pow_ui (result->value.real, op1->value.real, apower,\n+                       GFC_RND_MODE);\n \n \t  if (power < 0)\n \t    {\n-\t      mpf_init_set_ui (unity_f, 1);\n-\t      mpf_div (result->value.real, unity_f, result->value.real);\n-\t      mpf_clear (unity_f);\n+              gfc_set_model (op1->value.real);\n+\t      mpfr_init (unity_f);\n+\t      mpfr_set_ui (unity_f, 1, GFC_RND_MODE);\n+\t      mpfr_div (result->value.real, unity_f, result->value.real,\n+                        GFC_RND_MODE);\n+\t      mpfr_clear (unity_f);\n \t    }\n-\n \t  break;\n \n \tcase BT_COMPLEX:\n \t  complex_pow_ui (op1, apower, result);\n \t  if (power < 0)\n \t    complex_reciprocal (result);\n-\n \t  break;\n \n \tdefault:\n@@ -1748,7 +1324,7 @@ gfc_compare_expr (gfc_expr * op1, gfc_expr * op2)\n       break;\n \n     case BT_REAL:\n-      rc = mpf_cmp (op1->value.real, op2->value.real);\n+      rc = mpfr_cmp (op1->value.real, op2->value.real);\n       break;\n \n     case BT_CHARACTER:\n@@ -1775,8 +1351,8 @@ static int\n compare_complex (gfc_expr * op1, gfc_expr * op2)\n {\n \n-  return (mpf_cmp (op1->value.complex.r, op2->value.complex.r) == 0\n-\t  && mpf_cmp (op1->value.complex.i, op2->value.complex.i) == 0);\n+  return (mpfr_cmp (op1->value.complex.r, op2->value.complex.r) == 0\n+\t  && mpfr_cmp (op1->value.complex.i, op2->value.complex.i) == 0);\n }\n \n \n@@ -2544,12 +2120,12 @@ gfc_convert_real (const char *buffer, int kind, locus * where)\n   const char *t;\n \n   e = gfc_constant_result (BT_REAL, kind, where);\n-  /* a leading plus is allowed, but not by mpf_set_str */\n+  /* A leading plus is allowed in Fortran, but not by mpfr_set_str */\n   if (buffer[0] == '+')\n     t = buffer + 1;\n   else\n     t = buffer;\n-  mpf_set_str (e->value.real, t, 10);\n+  mpfr_set_str (e->value.real, t, 10, GFC_RND_MODE);\n \n   return e;\n }\n@@ -2564,8 +2140,8 @@ gfc_convert_complex (gfc_expr * real, gfc_expr * imag, int kind)\n   gfc_expr *e;\n \n   e = gfc_constant_result (BT_COMPLEX, kind, &real->where);\n-  mpf_set (e->value.complex.r, real->value.real);\n-  mpf_set (e->value.complex.i, imag->value.real);\n+  mpfr_set (e->value.complex.r, real->value.real, GFC_RND_MODE);\n+  mpfr_set (e->value.complex.i, imag->value.real, GFC_RND_MODE);\n \n   return e;\n }\n@@ -2621,7 +2197,7 @@ gfc_int2real (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_REAL, kind, &src->where);\n \n-  mpf_set_z (result->value.real, src->value.integer);\n+  mpfr_set_z (result->value.real, src->value.integer, GFC_RND_MODE);\n \n   if ((rc = gfc_check_real_range (result->value.real, kind)) != ARITH_OK)\n     {\n@@ -2644,8 +2220,8 @@ gfc_int2complex (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-  mpf_set_z (result->value.complex.r, src->value.integer);\n-  mpf_set_ui (result->value.complex.i, 0);\n+  mpfr_set_z (result->value.complex.r, src->value.integer, GFC_RND_MODE);\n+  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \n   if ((rc = gfc_check_real_range (result->value.complex.r, kind)) != ARITH_OK)\n     {\n@@ -2668,7 +2244,7 @@ gfc_real2int (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n \n-  mpz_set_f (result->value.integer, src->value.real);\n+  gfc_mpfr_to_mpz (result->value.integer, src->value.real);\n \n   if ((rc = gfc_check_integer_range (result->value.integer, kind))\n       != ARITH_OK)\n@@ -2692,15 +2268,15 @@ gfc_real2real (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_REAL, kind, &src->where);\n \n-  mpf_set (result->value.real, src->value.real);\n+  mpfr_set (result->value.real, src->value.real, GFC_RND_MODE);\n \n   rc = gfc_check_real_range (result->value.real, kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n-      mpf_set_ui(result->value.real, 0);\n+      mpfr_set_ui(result->value.real, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2723,16 +2299,16 @@ gfc_real2complex (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-  mpf_set (result->value.complex.r, src->value.real);\n-  mpf_set_ui (result->value.complex.i, 0);\n+  mpfr_set (result->value.complex.r, src->value.real, GFC_RND_MODE);\n+  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \n   rc = gfc_check_real_range (result->value.complex.r, kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n-      mpf_set_ui(result->value.complex.r, 0);\n+      mpfr_set_ui(result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2755,7 +2331,7 @@ gfc_complex2int (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n \n-  mpz_set_f (result->value.integer, src->value.complex.r);\n+  gfc_mpfr_to_mpz(result->value.integer, src->value.complex.r);\n \n   if ((rc = gfc_check_integer_range (result->value.integer, kind))\n       != ARITH_OK)\n@@ -2779,15 +2355,15 @@ gfc_complex2real (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_REAL, kind, &src->where);\n \n-  mpf_set (result->value.real, src->value.complex.r);\n+  mpfr_set (result->value.real, src->value.complex.r, GFC_RND_MODE);\n \n   rc = gfc_check_real_range (result->value.real, kind);\n \n   if (rc == ARITH_UNDERFLOW) \n     {\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n-      mpf_set_ui(result->value.real, 0);\n+      mpfr_set_ui(result->value.real, 0, GFC_RND_MODE);\n     }\n   if (rc != ARITH_OK)\n     {\n@@ -2810,16 +2386,16 @@ gfc_complex2complex (gfc_expr * src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-  mpf_set (result->value.complex.r, src->value.complex.r);\n-  mpf_set (result->value.complex.i, src->value.complex.i);\n+  mpfr_set (result->value.complex.r, src->value.complex.r, GFC_RND_MODE);\n+  mpfr_set (result->value.complex.i, src->value.complex.i, GFC_RND_MODE);\n \n   rc = gfc_check_real_range (result->value.complex.r, kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n-      mpf_set_ui(result->value.complex.r, 0);\n+      mpfr_set_ui(result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2834,7 +2410,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n     {\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n-      mpf_set_ui(result->value.complex.i, 0);\n+      mpfr_set_ui(result->value.complex.i, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {"}, {"sha": "1a718d4ea4c5aaa32e7b53832246d306a6c6a29d", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -24,19 +24,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"gfortran.h\"\n \n-/* Constants calculated during initialization.  */\n-extern mpf_t pi, half_pi, two_pi, e;\n-\n-/* Calculate mathematically interesting functions.  */\n-void natural_logarithm (mpf_t *, mpf_t *);\n-void common_logarithm (mpf_t *, mpf_t *);\n-void exponential (mpf_t *, mpf_t *);\n-void sine (mpf_t *, mpf_t *);\n-void cosine (mpf_t *, mpf_t *);\n-void arctangent (mpf_t *, mpf_t *);\n-void arctangent2 (mpf_t *, mpf_t *, mpf_t *);\n-void hypercos (mpf_t *, mpf_t *);\n-void hypersine (mpf_t *, mpf_t *);\n+/* MPFR does not have mpfr_atan2(), which needs to return the principle\n+   value of atan2().  MPFR also does not have the conversion of a mpfr_t\n+   to a mpz_t, so declare a function for this as well.  */\n+\n+void arctangent2 (mpfr_t, mpfr_t, mpfr_t);\n+void gfc_mpfr_to_mpz(mpz_t, mpfr_t);\n+void gfc_set_model_kind (int);\n+void gfc_set_model (mpfr_t);\n \n /* Return a constant result of a given type and kind, with locus.  */\n gfc_expr *gfc_constant_result (bt, int, locus *);"}, {"sha": "1c948d94253feecba58f361c4079226f313f3215", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -363,7 +363,7 @@ gfc_show_expr (gfc_expr * p)\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpf_out_str (stdout, 10, 0, p->value.real);\n+\t  mpfr_out_str (stdout, 10, 0, p->value.real, GFC_RND_MODE);\n \t  if (p->ts.kind != gfc_default_real_kind ())\n \t    gfc_status (\"_%d\", p->ts.kind);\n \t  break;\n@@ -388,13 +388,13 @@ gfc_show_expr (gfc_expr * p)\n \tcase BT_COMPLEX:\n \t  gfc_status (\"(complex \");\n \n-\t  mpf_out_str (stdout, 10, 0, p->value.complex.r);\n+\t  mpfr_out_str (stdout, 10, 0, p->value.complex.r, GFC_RND_MODE);\n \t  if (p->ts.kind != gfc_default_complex_kind ())\n \t    gfc_status (\"_%d\", p->ts.kind);\n \n \t  gfc_status (\" \");\n \n-\t  mpf_out_str (stdout, 10, 0, p->value.complex.i);\n+\t  mpfr_out_str (stdout, 10, 0, p->value.complex.i, GFC_RND_MODE);\n \t  if (p->ts.kind != gfc_default_complex_kind ())\n \t    gfc_status (\"_%d\", p->ts.kind);\n "}, {"sha": "adff08e2070931d4b2450f5df5ecbef3fbbdb578", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -154,16 +154,16 @@ free_expr0 (gfc_expr * e)\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpf_clear (e->value.real);\n+\t  mpfr_clear (e->value.real);\n \t  break;\n \n \tcase BT_CHARACTER:\n \t  gfc_free (e->value.character.string);\n \t  break;\n \n \tcase BT_COMPLEX:\n-\t  mpf_clear (e->value.complex.r);\n-\t  mpf_clear (e->value.complex.i);\n+\t  mpfr_clear (e->value.complex.r);\n+\t  mpfr_clear (e->value.complex.i);\n \t  break;\n \n \tdefault:\n@@ -365,12 +365,17 @@ gfc_copy_expr (gfc_expr * p)\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpf_init_set (q->value.real, p->value.real);\n+          gfc_set_model_kind (q->ts.kind);\n+          mpfr_init (q->value.real);\n+\t  mpfr_set (q->value.real, p->value.real, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_COMPLEX:\n-\t  mpf_init_set (q->value.complex.r, p->value.complex.r);\n-\t  mpf_init_set (q->value.complex.i, p->value.complex.i);\n+          gfc_set_model_kind (q->ts.kind);\n+          mpfr_init (q->value.complex.r);\n+          mpfr_init (q->value.complex.i);\n+\t  mpfr_set (q->value.complex.r, p->value.complex.r, GFC_RND_MODE);\n+\t  mpfr_set (q->value.complex.i, p->value.complex.i, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_CHARACTER:"}, {"sha": "533479c63cdfad405ba99903f5bba2fa08d9ec3f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -59,7 +59,6 @@ char *alloca ();\n /* Major control parameters.  */\n \n #define GFC_MAX_SYMBOL_LEN 63\n-#define GFC_REAL_BITS 100\t/* Number of bits in g95's floating point numbers.  */\n #define GFC_MAX_LINE 132\t/* Characters beyond this are not seen.  */\n #define GFC_MAX_DIMENSIONS 7\t/* Maximum dimensions in an array.  */\n #define GFC_LETTERS 26\t\t/* Number of letters in the alphabet.  */\n@@ -184,7 +183,7 @@ extern mstring intrinsic_operators[];\n \n /* Arithmetic results.  */\n typedef enum\n-{ ARITH_OK = 1, ARITH_OVERFLOW, ARITH_UNDERFLOW,\n+{ ARITH_OK = 1, ARITH_OVERFLOW, ARITH_UNDERFLOW, ARITH_NAN,\n   ARITH_DIV0, ARITH_0TO0, ARITH_INCOMMENSURATE\n }\n arith;\n@@ -930,6 +929,8 @@ gfc_intrinsic_sym;\n    EXPR_ARRAY      An array constructor.  */\n \n #include <gmp.h>\n+#include <mpfr.h>\n+#define GFC_RND_MODE GMP_RNDN\n \n typedef struct gfc_expr\n {\n@@ -953,13 +954,14 @@ typedef struct gfc_expr\n \n   union\n   {\n-    mpz_t integer;\n-    mpf_t real;\n     int logical;\n+    mpz_t integer;\n+\n+    mpfr_t real;\n \n     struct\n     {\n-      mpf_t r, i;\n+      mpfr_t r, i;\n     }\n     complex;\n \n@@ -1023,7 +1025,7 @@ typedef struct\n   int kind, radix, digits, min_exponent, max_exponent;\n \n   int range, precision;\n-  mpf_t epsilon, huge, tiny;\n+  mpfr_t epsilon, huge, tiny;\n }\n gfc_real_info;\n \n@@ -1555,7 +1557,6 @@ match gfc_intrinsic_sub_interface (gfc_code *, int);\n \n /* simplify.c */\n void gfc_simplify_init_1 (void);\n-void gfc_simplify_done_1 (void);\n \n /* match.c -- FIXME */\n void gfc_free_iterator (gfc_iterator *, int);"}, {"sha": "659b507f6c5d28f56e31351adbc24c3d53dd1c87", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -1492,6 +1492,11 @@ add_functions (void)\n              gfc_check_rand, NULL, NULL,\n              i, BT_INTEGER, 4, 0);\n \n+  /* Compatibility with HP FORTRAN 77/iX Reference.  Note, rand() and \n+     ran() use slightly different shoddy multiplicative congruential \n+     PRNG.  */\n+  make_alias (\"ran\");\n+\n   make_generic (\"rand\", GFC_ISYM_RAND);\n \n   add_sym_1 (\"range\", 0, 1, BT_INTEGER, di,"}, {"sha": "159a42150dd817d707c2b292da325b02730003d2", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -309,7 +309,6 @@ gfc_done_1 (void)\n \n   gfc_scanner_done_1 ();\n   gfc_intrinsic_done_1 ();\n-  gfc_simplify_done_1 ();\n   gfc_iresolve_done_1 ();\n   gfc_arith_done_1 ();\n }"}, {"sha": "a9d0fa66c02e0f9eee7d8b6355794f63ef58a38b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -71,6 +71,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <time.h>\n \n #include \"gfortran.h\"\n+#include \"arith.h\"\n #include \"match.h\"\n #include \"parse.h\" /* FIXME */\n \n@@ -519,7 +520,7 @@ gfc_match_use (void)\n \ttail->next = new;\n       tail = new;\n \n-      /* See what kind of interface we're dealing with.  Asusume it is\n+      /* See what kind of interface we're dealing with.  Assume it is\n          not an operator.  */\n       new->operator = INTRINSIC_NONE;\n       if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n@@ -2245,7 +2246,7 @@ mio_gmp_integer (mpz_t * integer)\n \n \n static void\n-mio_gmp_real (mpf_t * real)\n+mio_gmp_real (mpfr_t * real)\n {\n   mp_exp_t exponent;\n   char *p;\n@@ -2255,14 +2256,14 @@ mio_gmp_real (mpf_t * real)\n       if (parse_atom () != ATOM_STRING)\n \tbad_module (\"Expected real string\");\n \n-      mpf_init (*real);\n-      mpf_set_str (*real, atom_string, -16);\n+      mpfr_init (*real);\n+      mpfr_set_str (*real, atom_string, 16, GFC_RND_MODE);\n       gfc_free (atom_string);\n \n     }\n   else\n     {\n-      p = mpf_get_str (NULL, &exponent, 16, 0, *real);\n+      p = mpfr_get_str (NULL, &exponent, 16, 0, *real, GFC_RND_MODE);\n       atom_string = gfc_getmem (strlen (p) + 20);\n \n       sprintf (atom_string, \"0.%s@%ld\", p, exponent);\n@@ -2507,10 +2508,12 @@ mio_expr (gfc_expr ** ep)\n \t  break;\n \n \tcase BT_REAL:\n+          gfc_set_model_kind (e->ts.kind);\n \t  mio_gmp_real (&e->value.real);\n \t  break;\n \n \tcase BT_COMPLEX:\n+          gfc_set_model_kind (e->ts.kind);\n \t  mio_gmp_real (&e->value.complex.r);\n \t  mio_gmp_real (&e->value.complex.i);\n \t  break;"}, {"sha": "eb5dc337f1d30a26a00d05b0ed35207ae9f4c040", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -1,5 +1,5 @@\n /* Primary expression subroutines\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GNU G95.\n@@ -436,7 +436,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n   buffer = alloca (count + 1);\n   memset (buffer, '\\0', count + 1);\n \n-  /* Hack for mpf_init_set_str().  */\n+  /* Hack for mpfr_set_str().  */\n   p = buffer;\n   while (count > 0)\n     {\n@@ -497,7 +497,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n     case ARITH_UNDERFLOW:\n       if (gfc_option.warn_underflow)\n         gfc_warning (\"Real constant underflows its kind at %C\");\n-      mpf_set_ui(e->value.real, 0);\n+      mpfr_set_ui (e->value.real, 0, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -1076,12 +1076,12 @@ match_const_complex_part (gfc_expr ** result)\n   buffer = alloca (count + 1);\n   memset (buffer, '\\0', count + 1);\n \n-  /* Hack for mpf_init_set_str().  */\n+  /* Hack for mpfr_set_str().  */\n   p = buffer;\n   while (count > 0)\n     {\n       c = gfc_next_char ();\n-      if (c == 'd')\n+      if (c == 'd' || c == 'q')\n \tc = 'e';\n       *p++ = c;\n       count--;"}, {"sha": "0a32d6f5cfc1baaa05aa092c30c2a12774e994f1", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 435, "deletions": 524, "changes": 959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -30,9 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"arith.h\"\n #include \"intrinsic.h\"\n \n-static mpf_t mpf_zero, mpf_half, mpf_one;\n-static mpz_t mpz_zero;\n-\n gfc_expr gfc_bad_expr;\n \n \n@@ -148,7 +145,7 @@ gfc_expr *\n gfc_simplify_abs (gfc_expr * e)\n {\n   gfc_expr *result;\n-  mpf_t a, b;\n+  mpfr_t a, b;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -166,25 +163,25 @@ gfc_simplify_abs (gfc_expr * e)\n     case BT_REAL:\n       result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n \n-      mpf_abs (result->value.real, e->value.real);\n+      mpfr_abs (result->value.real, e->value.real, GFC_RND_MODE);\n \n       result = range_check (result, \"ABS\");\n       break;\n \n     case BT_COMPLEX:\n       result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n \n-      mpf_init (a);\n-      mpf_mul (a, e->value.complex.r, e->value.complex.r);\n-\n-      mpf_init (b);\n-      mpf_mul (b, e->value.complex.i, e->value.complex.i);\n-\n-      mpf_add (a, a, b);\n-      mpf_sqrt (result->value.real, a);\n+      gfc_set_model_kind (e->ts.kind);\n+      mpfr_init (a);\n+      mpfr_init (b);\n+      /* FIXME:  Possible numerical problems.  */\n+      mpfr_mul (a, e->value.complex.r, e->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (b, e->value.complex.i, e->value.complex.i, GFC_RND_MODE);\n+      mpfr_add (a, a, b, GFC_RND_MODE);\n+      mpfr_sqrt (result->value.real, a, GFC_RND_MODE);\n \n-      mpf_clear (a);\n-      mpf_clear (b);\n+      mpfr_clear (a);\n+      mpfr_clear (b);\n \n       result = range_check (result, \"CABS\");\n       break;\n@@ -231,12 +228,11 @@ gfc_expr *\n gfc_simplify_acos (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t negative, square, term;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpf_cmp_si (x->value.real, 1) > 0 || mpf_cmp_si (x->value.real, -1) < 0)\n+  if (mpfr_cmp_si (x->value.real, 1) > 0 || mpfr_cmp_si (x->value.real, -1) < 0)\n     {\n       gfc_error (\"Argument of ACOS at %L must be between -1 and 1\",\n \t\t &x->where);\n@@ -245,33 +241,7 @@ gfc_simplify_acos (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  if (mpf_cmp_si (x->value.real, 1) == 0)\n-    {\n-      mpf_set_ui (result->value.real, 0);\n-      return range_check (result, \"ACOS\");\n-    }\n-\n-  if (mpf_cmp_si (x->value.real, -1) == 0)\n-    {\n-      mpf_set (result->value.real, pi);\n-      return range_check (result, \"ACOS\");\n-    }\n-\n-  mpf_init (negative);\n-  mpf_init (square);\n-  mpf_init (term);\n-\n-  mpf_pow_ui (square, x->value.real, 2);\n-  mpf_ui_sub (term, 1, square);\n-  mpf_sqrt (term, term);\n-  mpf_div (term, x->value.real, term);\n-  mpf_neg (term, term);\n-  arctangent (&term, &negative);\n-  mpf_add (result->value.real, half_pi, negative);\n-\n-  mpf_clear (negative);\n-  mpf_clear (square);\n-  mpf_clear (term);\n+  mpfr_acos (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ACOS\");\n }\n@@ -370,7 +340,7 @@ gfc_simplify_aimag (gfc_expr * e)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n-  mpf_set (result->value.real, e->value.complex.i);\n+  mpfr_set (result->value.real, e->value.complex.i, GFC_RND_MODE);\n \n   return range_check (result, \"AIMAG\");\n }\n@@ -391,7 +361,7 @@ gfc_simplify_aint (gfc_expr * e, gfc_expr * k)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  mpf_trunc (rtrunc->value.real, e->value.real);\n+  mpfr_trunc (rtrunc->value.real, e->value.real);\n \n   result = gfc_real2real (rtrunc, kind);\n   gfc_free_expr (rtrunc);\n@@ -410,7 +380,7 @@ gfc_simplify_dint (gfc_expr * e)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  mpf_trunc (rtrunc->value.real, e->value.real);\n+  mpfr_trunc (rtrunc->value.real, e->value.real);\n \n   result = gfc_real2real (rtrunc, gfc_default_double_kind ());\n   gfc_free_expr (rtrunc);\n@@ -425,6 +395,7 @@ gfc_simplify_anint (gfc_expr * e, gfc_expr * k)\n {\n   gfc_expr *rtrunc, *result;\n   int kind, cmp;\n+  mpfr_t half;\n \n   kind = get_kind (BT_REAL, k, \"ANINT\", e->ts.kind);\n   if (kind == -1)\n@@ -437,22 +408,27 @@ gfc_simplify_anint (gfc_expr * e, gfc_expr * k)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  cmp = mpf_cmp_ui (e->value.real, 0);\n+  cmp = mpfr_cmp_ui (e->value.real, 0);\n+\n+  gfc_set_model_kind (kind);\n+  mpfr_init (half);\n+  mpfr_set_str (half, \"0.5\", 10, GFC_RND_MODE);\n \n   if (cmp > 0)\n     {\n-      mpf_add (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (result->value.real, rtrunc->value.real);\n+      mpfr_add (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (result->value.real, rtrunc->value.real);\n     }\n   else if (cmp < 0)\n     {\n-      mpf_sub (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (result->value.real, rtrunc->value.real);\n+      mpfr_sub (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (result->value.real, rtrunc->value.real);\n     }\n   else\n-    mpf_set_ui (result->value.real, 0);\n+    mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n \n   gfc_free_expr (rtrunc);\n+  mpfr_clear (half);\n \n   return range_check (result, \"ANINT\");\n }\n@@ -463,6 +439,7 @@ gfc_simplify_dnint (gfc_expr * e)\n {\n   gfc_expr *rtrunc, *result;\n   int cmp;\n+  mpfr_t half;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -472,22 +449,27 @@ gfc_simplify_dnint (gfc_expr * e)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  cmp = mpf_cmp_ui (e->value.real, 0);\n+  cmp = mpfr_cmp_ui (e->value.real, 0);\n+\n+  gfc_set_model_kind (gfc_default_double_kind ());\n+  mpfr_init (half);\n+  mpfr_set_str (half, \"0.5\", 10, GFC_RND_MODE);\n \n   if (cmp > 0)\n     {\n-      mpf_add (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (result->value.real, rtrunc->value.real);\n+      mpfr_add (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (result->value.real, rtrunc->value.real);\n     }\n   else if (cmp < 0)\n     {\n-      mpf_sub (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (result->value.real, rtrunc->value.real);\n+      mpfr_sub (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (result->value.real, rtrunc->value.real);\n     }\n   else\n-    mpf_set_ui (result->value.real, 0);\n+    mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n \n   gfc_free_expr (rtrunc);\n+  mpfr_clear (half);\n \n   return range_check (result, \"DNINT\");\n }\n@@ -497,12 +479,11 @@ gfc_expr *\n gfc_simplify_asin (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t negative, square, term;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpf_cmp_si (x->value.real, 1) > 0 || mpf_cmp_si (x->value.real, -1) < 0)\n+  if (mpfr_cmp_si (x->value.real, 1) > 0 || mpfr_cmp_si (x->value.real, -1) < 0)\n     {\n       gfc_error (\"Argument of ASIN at %L must be between -1 and 1\",\n \t\t &x->where);\n@@ -511,32 +492,7 @@ gfc_simplify_asin (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  if (mpf_cmp_si (x->value.real, 1) == 0)\n-    {\n-      mpf_set (result->value.real, half_pi);\n-      return range_check (result, \"ASIN\");\n-    }\n-\n-  if (mpf_cmp_si (x->value.real, -1) == 0)\n-    {\n-      mpf_init (negative);\n-      mpf_neg (negative, half_pi);\n-      mpf_set (result->value.real, negative);\n-      mpf_clear (negative);\n-      return range_check (result, \"ASIN\");\n-    }\n-\n-  mpf_init (square);\n-  mpf_init (term);\n-\n-  mpf_pow_ui (square, x->value.real, 2);\n-  mpf_ui_sub (term, 1, square);\n-  mpf_sqrt (term, term);\n-  mpf_div (term, x->value.real, term);\n-  arctangent (&term, &result->value.real);\n-\n-  mpf_clear (square);\n-  mpf_clear (term);\n+  mpfr_asin(result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ASIN\");\n }\n@@ -552,7 +508,7 @@ gfc_simplify_atan (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  arctangent (&x->value.real, &result->value.real);\n+  mpfr_atan(result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ATAN\");\n \n@@ -569,17 +525,16 @@ gfc_simplify_atan2 (gfc_expr * y, gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-\n-  if (mpf_sgn (y->value.real) == 0 && mpf_sgn (x->value.real) == 0)\n+  if (mpfr_sgn (y->value.real) == 0 && mpfr_sgn (x->value.real) == 0)\n     {\n       gfc_error\n-\t(\"If first argument of ATAN2 %L is zero, the second argument \"\n+\t(\"If first argument of ATAN2 %L is zero, then the second argument \"\n \t  \"must not be zero\", &x->where);\n       gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n-  arctangent2 (&y->value.real, &x->value.real, &result->value.real);\n+  arctangent2 (y->value.real, x->value.real, result->value.real);\n \n   return range_check (result, \"ATAN2\");\n \n@@ -635,8 +590,8 @@ gfc_simplify_ceiling (gfc_expr * e, gfc_expr * k)\n \n   ceil = gfc_copy_expr (e);\n \n-  mpf_ceil (ceil->value.real, e->value.real);\n-  mpz_set_f (result->value.integer, ceil->value.real);\n+  mpfr_ceil (ceil->value.real, e->value.real);\n+  gfc_mpfr_to_mpz(result->value.integer, ceil->value.real);\n \n   gfc_free_expr (ceil);\n \n@@ -684,21 +639,21 @@ simplify_cmplx (const char *name, gfc_expr * x, gfc_expr * y, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &x->where);\n \n-  mpf_set_ui (result->value.complex.i, 0);\n+  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \n   switch (x->ts.type)\n     {\n     case BT_INTEGER:\n-      mpf_set_z (result->value.complex.r, x->value.integer);\n+      mpfr_set_z (result->value.complex.r, x->value.integer, GFC_RND_MODE);\n       break;\n \n     case BT_REAL:\n-      mpf_set (result->value.complex.r, x->value.real);\n+      mpfr_set (result->value.complex.r, x->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_set (result->value.complex.r, x->value.complex.r);\n-      mpf_set (result->value.complex.i, x->value.complex.i);\n+      mpfr_set (result->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_set (result->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -710,11 +665,11 @@ simplify_cmplx (const char *name, gfc_expr * x, gfc_expr * y, int kind)\n       switch (y->ts.type)\n \t{\n \tcase BT_INTEGER:\n-\t  mpf_set_z (result->value.complex.i, y->value.integer);\n+\t  mpfr_set_z (result->value.complex.i, y->value.integer, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpf_set (result->value.complex.i, y->value.real);\n+\t  mpfr_set (result->value.complex.i, y->value.real, GFC_RND_MODE);\n \t  break;\n \n \tdefault:\n@@ -752,7 +707,7 @@ gfc_simplify_conjg (gfc_expr * e)\n     return NULL;\n \n   result = gfc_copy_expr (e);\n-  mpf_neg (result->value.complex.i, result->value.complex.i);\n+  mpfr_neg (result->value.complex.i, result->value.complex.i, GFC_RND_MODE);\n \n   return range_check (result, \"CONJG\");\n }\n@@ -762,7 +717,7 @@ gfc_expr *\n gfc_simplify_cos (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t xp, xq;\n+  mpfr_t xp, xq;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -772,23 +727,24 @@ gfc_simplify_cos (gfc_expr * x)\n   switch (x->ts.type)\n     {\n     case BT_REAL:\n-      cosine (&x->value.real, &result->value.real);\n+      mpfr_cos (result->value.real, x->value.real, GFC_RND_MODE);\n       break;\n     case BT_COMPLEX:\n-      mpf_init (xp);\n-      mpf_init (xq);\n+      gfc_set_model_kind (x->ts.kind);\n+      mpfr_init (xp);\n+      mpfr_init (xq);\n \n-      cosine (&x->value.complex.r, &xp);\n-      hypercos (&x->value.complex.i, &xq);\n-      mpf_mul (result->value.complex.r, xp, xq);\n+      mpfr_cos  (xp, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_cosh (xq, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul(result->value.complex.r, xp, xq, GFC_RND_MODE);\n \n-      sine (&x->value.complex.r, &xp);\n-      hypersine (&x->value.complex.i, &xq);\n-      mpf_mul (xp, xp, xq);\n-      mpf_neg (result->value.complex.i, xp);\n+      mpfr_sin  (xp, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (xp, xp, xq, GFC_RND_MODE);\n+      mpfr_neg (result->value.complex.i, xp, GFC_RND_MODE );\n \n-      mpf_clear (xp);\n-      mpf_clear (xq);\n+      mpfr_clear (xp);\n+      mpfr_clear (xq);\n       break;\n     default:\n       gfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n@@ -809,7 +765,7 @@ gfc_simplify_cosh (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  hypercos (&x->value.real, &result->value.real);\n+  mpfr_cosh (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"COSH\");\n }\n@@ -902,15 +858,15 @@ gfc_simplify_dim (gfc_expr * x, gfc_expr * y)\n       if (mpz_cmp (x->value.integer, y->value.integer) > 0)\n \tmpz_sub (result->value.integer, x->value.integer, y->value.integer);\n       else\n-\tmpz_set (result->value.integer, mpz_zero);\n+\tmpz_set_ui (result->value.integer, 0);\n \n       break;\n \n     case BT_REAL:\n-      if (mpf_cmp (x->value.real, y->value.real) > 0)\n-\tmpf_sub (result->value.real, x->value.real, y->value.real);\n+      if (mpfr_cmp (x->value.real, y->value.real) > 0)\n+\tmpfr_sub (result->value.real, x->value.real, y->value.real, GFC_RND_MODE);\n       else\n-\tmpf_set (result->value.real, mpf_zero);\n+\tmpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n \n       break;\n \n@@ -925,21 +881,21 @@ gfc_simplify_dim (gfc_expr * x, gfc_expr * y)\n gfc_expr *\n gfc_simplify_dprod (gfc_expr * x, gfc_expr * y)\n {\n-  gfc_expr *mult1, *mult2, *result;\n+  gfc_expr *a1, *a2, *result;\n \n   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result =\n     gfc_constant_result (BT_REAL, gfc_default_double_kind (), &x->where);\n \n-  mult1 = gfc_real2real (x, gfc_default_double_kind ());\n-  mult2 = gfc_real2real (y, gfc_default_double_kind ());\n+  a1 = gfc_real2real (x, gfc_default_double_kind ());\n+  a2 = gfc_real2real (y, gfc_default_double_kind ());\n \n-  mpf_mul (result->value.real, mult1->value.real, mult2->value.real);\n+  mpfr_mul (result->value.real, a1->value.real, a2->value.real, GFC_RND_MODE);\n \n-  gfc_free_expr (mult1);\n-  gfc_free_expr (mult2);\n+  gfc_free_expr (a1);\n+  gfc_free_expr (a2);\n \n   return range_check (result, \"DPROD\");\n }\n@@ -957,7 +913,7 @@ gfc_simplify_epsilon (gfc_expr * e)\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n \n-  mpf_set (result->value.real, gfc_real_kinds[i].epsilon);\n+  mpfr_set (result->value.real, gfc_real_kinds[i].epsilon, GFC_RND_MODE);\n \n   return range_check (result, \"EPSILON\");\n }\n@@ -967,86 +923,30 @@ gfc_expr *\n gfc_simplify_exp (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t xp, xq;\n-  double ln2, absval, rhuge;\n+  mpfr_t xp, xq;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  /* Exactitude doesn't matter here */\n-  ln2 = .6931472;\n-  rhuge = ln2 * mpz_get_d (gfc_integer_kinds[0].huge);\n-\n   switch (x->ts.type)\n     {\n     case BT_REAL:\n-      absval = mpf_get_d (x->value.real);\n-      if (absval < 0)\n-\tabsval = -absval;\n-      if (absval > rhuge)\n-\t{\n-\t  /* Underflow (set arg to zero) if x is negative and its\n-\t     magnitude is greater than the maximum C long int times\n-\t     ln2, because the exponential method in arith.c will fail\n-\t     for such values.  */\n-\t  if (mpf_cmp_ui (x->value.real, 0) < 0)\n-\t    {\n-\t      if (pedantic == 1)\n-\t\tgfc_warning_now\n-\t\t  (\"Argument of EXP at %L is negative and too large, \"\n-\t\t   \"setting result to zero\", &x->where);\n-\t      mpf_set_ui (result->value.real, 0);\n-\t      return range_check (result, \"EXP\");\n-\t    }\n-\t  /* Overflow if magnitude of x is greater than C long int\n-             huge times ln2.  */\n-\t  else\n-\t    {\n-\t      gfc_error (\"Argument of EXP at %L too large\", &x->where);\n-\t      gfc_free_expr (result);\n-\t      return &gfc_bad_expr;\n-\t    }\n-\t}\n-      exponential (&x->value.real, &result->value.real);\n+      mpfr_exp(result->value.real, x->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      /* Using Euler's formula.  */\n-      absval = mpf_get_d (x->value.complex.r);\n-      if (absval < 0)\n-\tabsval = -absval;\n-      if (absval > rhuge)\n-\t{\n-\t  if (mpf_cmp_ui (x->value.complex.r, 0) < 0)\n-\t    {\n-\t      if (pedantic == 1)\n-\t\tgfc_warning_now\n-\t\t  (\"Real part of argument of EXP at %L is negative \"\n-\t\t   \"and too large, setting result to zero\", &x->where);\n-\n-\t      mpf_set_ui (result->value.complex.r, 0);\n-\t      mpf_set_ui (result->value.complex.i, 0);\n-\t      return range_check (result, \"EXP\");\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_error (\"Real part of argument of EXP at %L too large\",\n-\t\t\t &x->where);\n-\t      gfc_free_expr (result);\n-\t      return &gfc_bad_expr;\n-\t    }\n-\t}\n-      mpf_init (xp);\n-      mpf_init (xq);\n-      exponential (&x->value.complex.r, &xq);\n-      cosine (&x->value.complex.i, &xp);\n-      mpf_mul (result->value.complex.r, xq, xp);\n-      sine (&x->value.complex.i, &xp);\n-      mpf_mul (result->value.complex.i, xq, xp);\n-      mpf_clear (xp);\n-      mpf_clear (xq);\n+      gfc_set_model_kind (x->ts.kind);\n+      mpfr_init (xp);\n+      mpfr_init (xq);\n+      mpfr_exp (xq, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_cos (xp, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (result->value.complex.r, xq, xp, GFC_RND_MODE);\n+      mpfr_sin (xp, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (result->value.complex.i, xq, xp, GFC_RND_MODE);\n+      mpfr_clear (xp);\n+      mpfr_clear (xq);\n       break;\n \n     default:\n@@ -1056,11 +956,11 @@ gfc_simplify_exp (gfc_expr * x)\n   return range_check (result, \"EXP\");\n }\n \n-\n+/* FIXME:  MPFR should be able to do this better */\n gfc_expr *\n gfc_simplify_exponent (gfc_expr * x)\n {\n-  mpf_t i2, absv, ln2, lnx;\n+  mpfr_t i2, absv, ln2, lnx, zero;\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n@@ -1069,31 +969,39 @@ gfc_simplify_exponent (gfc_expr * x)\n   result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind (),\n \t\t\t\t&x->where);\n \n-  if (mpf_cmp (x->value.real, mpf_zero) == 0)\n+  gfc_set_model (x->value.real);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) == 0)\n     {\n       mpz_set_ui (result->value.integer, 0);\n+      mpfr_clear (zero);\n       return result;\n     }\n \n-  mpf_init_set_ui (i2, 2);\n-  mpf_init (absv);\n-  mpf_init (ln2);\n-  mpf_init (lnx);\n+  mpfr_init (i2);\n+  mpfr_init (absv);\n+  mpfr_init (ln2);\n+  mpfr_init (lnx);\n+\n+  mpfr_set_ui (i2, 2, GFC_RND_MODE);\n \n-  natural_logarithm (&i2, &ln2);\n+  mpfr_log (ln2, i2, GFC_RND_MODE); \n+  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n+  mpfr_log (lnx, absv, GFC_RND_MODE); \n \n-  mpf_abs (absv, x->value.real);\n-  natural_logarithm (&absv, &lnx);\n+  mpfr_div (lnx, lnx, ln2, GFC_RND_MODE);\n+  mpfr_trunc (lnx, lnx);\n+  mpfr_add_ui (lnx, lnx, 1, GFC_RND_MODE);\n \n-  mpf_div (lnx, lnx, ln2);\n-  mpf_trunc (lnx, lnx);\n-  mpf_add_ui (lnx, lnx, 1);\n-  mpz_set_f (result->value.integer, lnx);\n+  gfc_mpfr_to_mpz (result->value.integer, lnx);\n \n-  mpf_clear (i2);\n-  mpf_clear (ln2);\n-  mpf_clear (lnx);\n-  mpf_clear (absv);\n+  mpfr_clear (i2);\n+  mpfr_clear (ln2);\n+  mpfr_clear (lnx);\n+  mpfr_clear (absv);\n+  mpfr_clear (zero);\n \n   return range_check (result, \"EXPONENT\");\n }\n@@ -1116,7 +1024,7 @@ gfc_expr *\n gfc_simplify_floor (gfc_expr * e, gfc_expr * k)\n {\n   gfc_expr *result;\n-  mpf_t floor;\n+  mpfr_t floor;\n   int kind;\n \n   kind = get_kind (BT_REAL, k, \"FLOOR\", gfc_default_real_kind ());\n@@ -1128,10 +1036,13 @@ gfc_simplify_floor (gfc_expr * e, gfc_expr * k)\n \n   result = gfc_constant_result (BT_INTEGER, kind, &e->where);\n \n-  mpf_init (floor);\n-  mpf_floor (floor, e->value.real);\n-  mpz_set_f (result->value.integer, floor);\n-  mpf_clear (floor);\n+  gfc_set_model_kind (kind);\n+  mpfr_init (floor);\n+  mpfr_floor (floor, e->value.real);\n+\n+  gfc_mpfr_to_mpz (result->value.integer, floor);\n+\n+  mpfr_clear (floor);\n \n   return range_check (result, \"FLOOR\");\n }\n@@ -1141,45 +1052,52 @@ gfc_expr *\n gfc_simplify_fraction (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t i2, absv, ln2, lnx, pow2;\n+  mpfr_t i2, absv, ln2, lnx, pow2, zero;\n   unsigned long exp2;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpf_cmp (x->value.real, mpf_zero) == 0)\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) == 0)\n     {\n-      mpf_set (result->value.real, mpf_zero);\n+      mpfr_set (result->value.real, zero, GFC_RND_MODE);\n+      mpfr_clear (zero);\n       return result;\n     }\n \n-  mpf_init_set_ui (i2, 2);\n-  mpf_init (absv);\n-  mpf_init (ln2);\n-  mpf_init (lnx);\n-  mpf_init (pow2);\n+  mpfr_init (i2);\n+  mpfr_init (absv);\n+  mpfr_init (ln2);\n+  mpfr_init (lnx);\n+  mpfr_init (pow2);\n \n-  natural_logarithm (&i2, &ln2);\n+  mpfr_set_ui (i2, 2, GFC_RND_MODE);\n \n-  mpf_abs (absv, x->value.real);\n-  natural_logarithm (&absv, &lnx);\n+  mpfr_log (ln2, i2, GFC_RND_MODE);\n+  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n+  mpfr_log (lnx, absv, GFC_RND_MODE);\n \n-  mpf_div (lnx, lnx, ln2);\n-  mpf_trunc (lnx, lnx);\n-  mpf_add_ui (lnx, lnx, 1);\n+  mpfr_div (lnx, lnx, ln2, GFC_RND_MODE);\n+  mpfr_trunc (lnx, lnx);\n+  mpfr_add_ui (lnx, lnx, 1, GFC_RND_MODE);\n \n-  exp2 = (unsigned long) mpf_get_d (lnx);\n-  mpf_pow_ui (pow2, i2, exp2);\n+  exp2 = (unsigned long) mpfr_get_d (lnx, GFC_RND_MODE);\n+  mpfr_pow_ui (pow2, i2, exp2, GFC_RND_MODE);\n \n-  mpf_div (result->value.real, absv, pow2);\n+  mpfr_div (result->value.real, absv, pow2, GFC_RND_MODE);\n \n-  mpf_clear (i2);\n-  mpf_clear (ln2);\n-  mpf_clear (absv);\n-  mpf_clear (lnx);\n-  mpf_clear (pow2);\n+  mpfr_clear (i2);\n+  mpfr_clear (ln2);\n+  mpfr_clear (absv);\n+  mpfr_clear (lnx);\n+  mpfr_clear (pow2);\n+  mpfr_clear (zero);\n \n   return range_check (result, \"FRACTION\");\n }\n@@ -1204,7 +1122,7 @@ gfc_simplify_huge (gfc_expr * e)\n       break;\n \n     case BT_REAL:\n-      mpf_set (result->value.real, gfc_real_kinds[i].huge);\n+      mpfr_set (result->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n       break;\n \n     bad_type:\n@@ -1605,16 +1523,16 @@ gfc_simplify_int (gfc_expr * e, gfc_expr * k)\n \n     case BT_REAL:\n       rtrunc = gfc_copy_expr (e);\n-      mpf_trunc (rtrunc->value.real, e->value.real);\n-      mpz_set_f (result->value.integer, rtrunc->value.real);\n+      mpfr_trunc (rtrunc->value.real, e->value.real);\n+      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n       gfc_free_expr (rtrunc);\n       break;\n \n     case BT_COMPLEX:\n       rpart = gfc_complex2real (e, kind);\n       rtrunc = gfc_copy_expr (rpart);\n-      mpf_trunc (rtrunc->value.real, rpart->value.real);\n-      mpz_set_f (result->value.integer, rtrunc->value.real);\n+      mpfr_trunc (rtrunc->value.real, rpart->value.real);\n+      gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n       gfc_free_expr (rpart);\n       gfc_free_expr (rtrunc);\n       break;\n@@ -1642,8 +1560,8 @@ gfc_simplify_ifix (gfc_expr * e)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  mpf_trunc (rtrunc->value.real, e->value.real);\n-  mpz_set_f (result->value.integer, rtrunc->value.real);\n+  mpfr_trunc (rtrunc->value.real, e->value.real);\n+  gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n \n   gfc_free_expr (rtrunc);\n   return range_check (result, \"IFIX\");\n@@ -1663,8 +1581,8 @@ gfc_simplify_idint (gfc_expr * e)\n \n   rtrunc = gfc_copy_expr (e);\n \n-  mpf_trunc (rtrunc->value.real, e->value.real);\n-  mpz_set_f (result->value.integer, rtrunc->value.real);\n+  mpfr_trunc (rtrunc->value.real, e->value.real);\n+  gfc_mpfr_to_mpz (result->value.integer, rtrunc->value.real);\n \n   gfc_free_expr (rtrunc);\n   return range_check (result, \"IDINT\");\n@@ -2000,52 +1918,60 @@ gfc_expr *\n gfc_simplify_log (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t xr, xi;\n+  mpfr_t xr, xi, zero;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n   switch (x->ts.type)\n     {\n     case BT_REAL:\n-      if (mpf_cmp (x->value.real, mpf_zero) <= 0)\n+      if (mpfr_cmp (x->value.real, zero) <= 0)\n \t{\n \t  gfc_error\n \t    (\"Argument of LOG at %L cannot be less than or equal to zero\",\n \t     &x->where);\n \t  gfc_free_expr (result);\n+          mpfr_clear (zero);\n \t  return &gfc_bad_expr;\n \t}\n \n-      natural_logarithm (&x->value.real, &result->value.real);\n+      mpfr_log(result->value.real, x->value.real, GFC_RND_MODE);\n+      mpfr_clear (zero);\n       break;\n \n     case BT_COMPLEX:\n-      if ((mpf_cmp (x->value.complex.r, mpf_zero) == 0)\n-\t  && (mpf_cmp (x->value.complex.i, mpf_zero) == 0))\n+      if ((mpfr_cmp (x->value.complex.r, zero) == 0)\n+\t  && (mpfr_cmp (x->value.complex.i, zero) == 0))\n \t{\n \t  gfc_error (\"Complex argument of LOG at %L cannot be zero\",\n \t\t     &x->where);\n \t  gfc_free_expr (result);\n+          mpfr_clear (zero);\n \t  return &gfc_bad_expr;\n \t}\n \n-      mpf_init (xr);\n-      mpf_init (xi);\n+      mpfr_init (xr);\n+      mpfr_init (xi);\n \n-      arctangent2 (&x->value.complex.i, &x->value.complex.r,\n-\t&result->value.complex.i);\n+      arctangent2 (x->value.complex.i, x->value.complex.r,\n+\t           result->value.complex.i);\n \n-      mpf_mul (xr, x->value.complex.r, x->value.complex.r);\n-      mpf_mul (xi, x->value.complex.i, x->value.complex.i);\n-      mpf_add (xr, xr, xi);\n-      mpf_sqrt (xr, xr);\n-      natural_logarithm (&xr, &result->value.complex.r);\n+      mpfr_mul (xr, x->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_mul (xi, x->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_add (xr, xr, xi, GFC_RND_MODE);\n+      mpfr_sqrt (xr, xr, GFC_RND_MODE);\n+      mpfr_log (result->value.complex.r, xr, GFC_RND_MODE);\n \n-      mpf_clear (xr);\n-      mpf_clear (xi);\n+      mpfr_clear (xr);\n+      mpfr_clear (xi);\n+      mpfr_clear (zero);\n \n       break;\n \n@@ -2061,21 +1987,28 @@ gfc_expr *\n gfc_simplify_log10 (gfc_expr * x)\n {\n   gfc_expr *result;\n+  mpfr_t zero;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpf_cmp (x->value.real, mpf_zero) <= 0)\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) <= 0)\n     {\n       gfc_error\n \t(\"Argument of LOG10 at %L cannot be less than or equal to zero\",\n \t &x->where);\n+      mpfr_clear (zero);\n       return &gfc_bad_expr;\n     }\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  common_logarithm (&x->value.real, &result->value.real);\n+  mpfr_log10 (result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_clear (zero);\n \n   return range_check (result, \"LOG10\");\n }\n@@ -2142,9 +2075,10 @@ simplify_min_max (gfc_expr * expr, int sign)\n \t  break;\n \n \tcase BT_REAL:\n-\t  if (mpf_cmp (arg->expr->value.real, extremum->expr->value.real) *\n+\t  if (mpfr_cmp (arg->expr->value.real, extremum->expr->value.real) *\n \t      sign > 0)\n-\t    mpf_set (extremum->expr->value.real, arg->expr->value.real);\n+\t    mpfr_set (extremum->expr->value.real, arg->expr->value.real,\n+                      GFC_RND_MODE);\n \n \t  break;\n \n@@ -2235,7 +2169,7 @@ gfc_expr *\n gfc_simplify_mod (gfc_expr * a, gfc_expr * p)\n {\n   gfc_expr *result;\n-  mpf_t quot, iquot, term;\n+  mpfr_t quot, iquot, term;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -2256,26 +2190,27 @@ gfc_simplify_mod (gfc_expr * a, gfc_expr * p)\n       break;\n \n     case BT_REAL:\n-      if (mpf_cmp_ui (p->value.real, 0) == 0)\n+      if (mpfr_cmp_ui (p->value.real, 0) == 0)\n \t{\n \t  /* Result is processor-dependent.  */\n \t  gfc_error (\"Second argument of MOD at %L is zero\", &p->where);\n \t  gfc_free_expr (result);\n \t  return &gfc_bad_expr;\n \t}\n \n-      mpf_init (quot);\n-      mpf_init (iquot);\n-      mpf_init (term);\n+      gfc_set_model_kind (a->ts.kind);\n+      mpfr_init (quot);\n+      mpfr_init (iquot);\n+      mpfr_init (term);\n \n-      mpf_div (quot, a->value.real, p->value.real);\n-      mpf_trunc (iquot, quot);\n-      mpf_mul (term, iquot, p->value.real);\n-      mpf_sub (result->value.real, a->value.real, term);\n+      mpfr_div (quot, a->value.real, p->value.real, GFC_RND_MODE);\n+      mpfr_trunc (iquot, quot);\n+      mpfr_mul (term, iquot, p->value.real, GFC_RND_MODE);\n+      mpfr_sub (result->value.real, a->value.real, term, GFC_RND_MODE);\n \n-      mpf_clear (quot);\n-      mpf_clear (iquot);\n-      mpf_clear (term);\n+      mpfr_clear (quot);\n+      mpfr_clear (iquot);\n+      mpfr_clear (term);\n       break;\n \n     default:\n@@ -2290,7 +2225,7 @@ gfc_expr *\n gfc_simplify_modulo (gfc_expr * a, gfc_expr * p)\n {\n   gfc_expr *result;\n-  mpf_t quot, iquot, term;\n+  mpfr_t quot, iquot, term;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -2313,27 +2248,28 @@ gfc_simplify_modulo (gfc_expr * a, gfc_expr * p)\n       break;\n \n     case BT_REAL:\n-      if (mpf_cmp_ui (p->value.real, 0) == 0)\n+      if (mpfr_cmp_ui (p->value.real, 0) == 0)\n \t{\n \t  /* Result is processor-dependent.  */\n \t  gfc_error (\"Second argument of MODULO at %L is zero\", &p->where);\n \t  gfc_free_expr (result);\n \t  return &gfc_bad_expr;\n \t}\n \n-      mpf_init (quot);\n-      mpf_init (iquot);\n-      mpf_init (term);\n+      gfc_set_model_kind (a->ts.kind);\n+      mpfr_init (quot);\n+      mpfr_init (iquot);\n+      mpfr_init (term);\n \n-      mpf_div (quot, a->value.real, p->value.real);\n-      mpf_floor (iquot, quot);\n-      mpf_mul (term, iquot, p->value.real);\n+      mpfr_div (quot, a->value.real, p->value.real, GFC_RND_MODE);\n+      mpfr_floor (iquot, quot);\n+      mpfr_mul (term, iquot, p->value.real, GFC_RND_MODE);\n \n-      mpf_clear (quot);\n-      mpf_clear (iquot);\n-      mpf_clear (term);\n+      mpfr_clear (quot);\n+      mpfr_clear (iquot);\n+      mpfr_clear (term);\n \n-      mpf_sub (result->value.real, a->value.real, term);\n+      mpfr_sub (result->value.real, a->value.real, term, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -2376,7 +2312,7 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  val = mpf_get_d (x->value.real);\n+  val = mpfr_get_d (x->value.real, GFC_RND_MODE);\n   p = gfc_real_kinds[k].digits;\n \n   eps = 1.;\n@@ -2387,32 +2323,32 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n \n   /* TODO we should make sure that 'float' matches kind 4 */\n   match_float = gfc_real_kinds[k].kind == 4;\n-  if (mpf_cmp_ui (s->value.real, 0) > 0)\n+  if (mpfr_cmp_ui (s->value.real, 0) > 0)\n     {\n       if (match_float)\n \t{\n \t  rval = (float) val;\n \t  rval = rval + eps;\n-\t  mpf_set_d (result->value.real, rval);\n+\t  mpfr_set_d (result->value.real, rval, GFC_RND_MODE);\n \t}\n       else\n \t{\n \t  val = val + eps;\n-\t  mpf_set_d (result->value.real, val);\n+\t  mpfr_set_d (result->value.real, val, GFC_RND_MODE);\n \t}\n     }\n-  else if (mpf_cmp_ui (s->value.real, 0) < 0)\n+  else if (mpfr_cmp_ui (s->value.real, 0) < 0)\n     {\n       if (match_float)\n \t{\n \t  rval = (float) val;\n \t  rval = rval - eps;\n-\t  mpf_set_d (result->value.real, rval);\n+\t  mpfr_set_d (result->value.real, rval, GFC_RND_MODE);\n \t}\n       else\n \t{\n \t  val = val - eps;\n-\t  mpf_set_d (result->value.real, val);\n+\t  mpfr_set_d (result->value.real, val, GFC_RND_MODE);\n \t}\n     }\n   else\n@@ -2432,6 +2368,7 @@ simplify_nint (const char *name, gfc_expr * e, gfc_expr * k)\n {\n   gfc_expr *rtrunc, *itrunc, *result;\n   int kind, cmp;\n+  mpfr_t half;\n \n   kind = get_kind (BT_INTEGER, k, name, gfc_default_integer_kind ());\n   if (kind == -1)\n@@ -2445,25 +2382,30 @@ simplify_nint (const char *name, gfc_expr * e, gfc_expr * k)\n   rtrunc = gfc_copy_expr (e);\n   itrunc = gfc_copy_expr (e);\n \n-  cmp = mpf_cmp_ui (e->value.real, 0);\n+  cmp = mpfr_cmp_ui (e->value.real, 0);\n+\n+  gfc_set_model (e->value.real);\n+  mpfr_init (half);\n+  mpfr_set_str (half, \"0.5\", 10, GFC_RND_MODE);\n \n   if (cmp > 0)\n     {\n-      mpf_add (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (itrunc->value.real, rtrunc->value.real);\n+      mpfr_add (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (itrunc->value.real, rtrunc->value.real);\n     }\n   else if (cmp < 0)\n     {\n-      mpf_sub (rtrunc->value.real, e->value.real, mpf_half);\n-      mpf_trunc (itrunc->value.real, rtrunc->value.real);\n+      mpfr_sub (rtrunc->value.real, e->value.real, half, GFC_RND_MODE);\n+      mpfr_trunc (itrunc->value.real, rtrunc->value.real);\n     }\n   else\n-    mpf_set_ui (itrunc->value.real, 0);\n+    mpfr_set_ui (itrunc->value.real, 0, GFC_RND_MODE);\n \n-  mpz_set_f (result->value.integer, itrunc->value.real);\n+  gfc_mpfr_to_mpz (result->value.integer, itrunc->value.real);\n \n   gfc_free_expr (itrunc);\n   gfc_free_expr (rtrunc);\n+  mpfr_clear (half);\n \n   return range_check (result, name);\n }\n@@ -2937,7 +2879,7 @@ gfc_expr *\n gfc_simplify_rrspacing (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t i2, absv, ln2, lnx, frac, pow2;\n+  mpfr_t i2, absv, ln2, lnx, frac, pow2, zero;\n   unsigned long exp2;\n   int i, p;\n \n@@ -2952,41 +2894,48 @@ gfc_simplify_rrspacing (gfc_expr * x)\n \n   p = gfc_real_kinds[i].digits;\n \n-  if (mpf_cmp (x->value.real, mpf_zero) == 0)\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) == 0)\n     {\n-      mpf_ui_div (result->value.real, 1, gfc_real_kinds[i].tiny);\n+      mpfr_ui_div (result->value.real, 1, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n+      mpfr_clear (zero);\n       return result;\n     }\n \n-  mpf_init_set_ui (i2, 2);\n-  mpf_init (ln2);\n-  mpf_init (absv);\n-  mpf_init (lnx);\n-  mpf_init (frac);\n-  mpf_init (pow2);\n+  mpfr_init (i2);\n+  mpfr_init (ln2);\n+  mpfr_init (absv);\n+  mpfr_init (lnx);\n+  mpfr_init (frac);\n+  mpfr_init (pow2);\n \n-  natural_logarithm (&i2, &ln2);\n+  mpfr_set_ui (i2, 2, GFC_RND_MODE);\n \n-  mpf_abs (absv, x->value.real);\n-  natural_logarithm (&absv, &lnx);\n+  mpfr_log (ln2, i2, GFC_RND_MODE);\n+  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n+  mpfr_log (lnx, absv, GFC_RND_MODE);\n \n-  mpf_div (lnx, lnx, ln2);\n-  mpf_trunc (lnx, lnx);\n-  mpf_add_ui (lnx, lnx, 1);\n+  mpfr_div (lnx, lnx, ln2, GFC_RND_MODE);\n+  mpfr_trunc (lnx, lnx);\n+  mpfr_add_ui (lnx, lnx, 1, GFC_RND_MODE);\n \n-  exp2 = (unsigned long) mpf_get_d (lnx);\n-  mpf_pow_ui (pow2, i2, exp2);\n-  mpf_div (frac, absv, pow2);\n+  exp2 = (unsigned long) mpfr_get_d (lnx, GFC_RND_MODE);\n+  mpfr_pow_ui (pow2, i2, exp2, GFC_RND_MODE);\n+  mpfr_div (frac, absv, pow2, GFC_RND_MODE);\n \n   exp2 = (unsigned long) p;\n-  mpf_mul_2exp (result->value.real, frac, exp2);\n+  mpfr_mul_2exp (result->value.real, frac, exp2, GFC_RND_MODE);\n \n-  mpf_clear (i2);\n-  mpf_clear (ln2);\n-  mpf_clear (absv);\n-  mpf_clear (lnx);\n-  mpf_clear (frac);\n-  mpf_clear (pow2);\n+  mpfr_clear (i2);\n+  mpfr_clear (ln2);\n+  mpfr_clear (absv);\n+  mpfr_clear (lnx);\n+  mpfr_clear (frac);\n+  mpfr_clear (pow2);\n+  mpfr_clear (zero);\n \n   return range_check (result, \"RRSPACING\");\n }\n@@ -2996,17 +2945,17 @@ gfc_expr *\n gfc_simplify_scale (gfc_expr * x, gfc_expr * i)\n {\n   int k, neg_flag, power, exp_range;\n-  mpf_t scale, radix;\n+  mpfr_t scale, radix;\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT || i->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpf_sgn (x->value.real) == 0)\n+  if (mpfr_sgn (x->value.real) == 0)\n     {\n-      mpf_set_ui (result->value.real, 0);\n+      mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n       return result;\n     }\n \n@@ -3035,17 +2984,19 @@ gfc_simplify_scale (gfc_expr * x, gfc_expr * i)\n       power = -power;\n     }\n \n-  mpf_init_set_ui (radix, gfc_real_kinds[k].radix);\n-  mpf_init (scale);\n-  mpf_pow_ui (scale, radix, power);\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (scale);\n+  mpfr_init (radix);\n+  mpfr_set_ui (radix, gfc_real_kinds[k].radix, GFC_RND_MODE);\n+  mpfr_pow_ui (scale, radix, power, GFC_RND_MODE);\n \n   if (neg_flag)\n-    mpf_div (result->value.real, x->value.real, scale);\n+    mpfr_div (result->value.real, x->value.real, scale, GFC_RND_MODE);\n   else\n-    mpf_mul (result->value.real, x->value.real, scale);\n+    mpfr_mul (result->value.real, x->value.real, scale, GFC_RND_MODE);\n \n-  mpf_clear (scale);\n-  mpf_clear (radix);\n+  mpfr_clear (scale);\n+  mpfr_clear (radix);\n \n   return range_check (result, \"SCALE\");\n }\n@@ -3195,52 +3146,59 @@ gfc_expr *\n gfc_simplify_set_exponent (gfc_expr * x, gfc_expr * i)\n {\n   gfc_expr *result;\n-  mpf_t i2, ln2, absv, lnx, pow2, frac;\n+  mpfr_t i2, ln2, absv, lnx, pow2, frac, zero;\n   unsigned long exp2;\n \n   if (x->expr_type != EXPR_CONSTANT || i->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpf_cmp (x->value.real, mpf_zero) == 0)\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) == 0)\n     {\n-      mpf_set (result->value.real, mpf_zero);\n+      mpfr_set (result->value.real, zero, GFC_RND_MODE);\n+      mpfr_clear (zero);\n       return result;\n     }\n \n-  mpf_init_set_ui (i2, 2);\n-  mpf_init (ln2);\n-  mpf_init (absv);\n-  mpf_init (lnx);\n-  mpf_init (pow2);\n-  mpf_init (frac);\n+  mpfr_init (i2);\n+  mpfr_init (ln2);\n+  mpfr_init (absv);\n+  mpfr_init (lnx);\n+  mpfr_init (pow2);\n+  mpfr_init (frac);\n \n-  natural_logarithm (&i2, &ln2);\n+  mpfr_set_ui (i2, 2, GFC_RND_MODE);\n+  mpfr_log (ln2, i2, GFC_RND_MODE);\n \n-  mpf_abs (absv, x->value.real);\n-  natural_logarithm (&absv, &lnx);\n+  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n+  mpfr_log (lnx, absv, GFC_RND_MODE);\n \n-  mpf_div (lnx, lnx, ln2);\n-  mpf_trunc (lnx, lnx);\n-  mpf_add_ui (lnx, lnx, 1);\n+  mpfr_div (lnx, lnx, ln2, GFC_RND_MODE);\n+  mpfr_trunc (lnx, lnx);\n+  mpfr_add_ui (lnx, lnx, 1, GFC_RND_MODE);\n \n   /* Old exponent value, and fraction.  */\n-  exp2 = (unsigned long) mpf_get_d (lnx);\n-  mpf_pow_ui (pow2, i2, exp2);\n+  exp2 = (unsigned long) mpfr_get_d (lnx, GFC_RND_MODE);\n+  mpfr_pow_ui (pow2, i2, exp2, GFC_RND_MODE);\n \n-  mpf_div (frac, absv, pow2);\n+  mpfr_div (frac, absv, pow2, GFC_RND_MODE);\n \n   /* New exponent.  */\n   exp2 = (unsigned long) mpz_get_d (i->value.integer);\n-  mpf_mul_2exp (result->value.real, frac, exp2);\n+  mpfr_mul_2exp (result->value.real, frac, exp2, GFC_RND_MODE);\n \n-  mpf_clear (i2);\n-  mpf_clear (ln2);\n-  mpf_clear (absv);\n-  mpf_clear (lnx);\n-  mpf_clear (pow2);\n-  mpf_clear (frac);\n+  mpfr_clear (i2);\n+  mpfr_clear (ln2);\n+  mpfr_clear (absv);\n+  mpfr_clear (lnx);\n+  mpfr_clear (pow2);\n+  mpfr_clear (frac);\n+  mpfr_clear (zero);\n \n   return range_check (result, \"SET_EXPONENT\");\n }\n@@ -3352,9 +3310,9 @@ gfc_simplify_sign (gfc_expr * x, gfc_expr * y)\n     case BT_REAL:\n       /* TODO: Handle -0.0 and +0.0 correctly on machines that support\n          it.  */\n-      mpf_abs (result->value.real, x->value.real);\n-      if (mpf_sgn (y->value.integer) < 0)\n-\tmpf_neg (result->value.real, result->value.real);\n+      mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n+      if (mpfr_sgn (y->value.real) < 0)\n+\tmpfr_neg (result->value.real, result->value.real, GFC_RND_MODE);\n \n       break;\n \n@@ -3370,7 +3328,7 @@ gfc_expr *\n gfc_simplify_sin (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t xp, xq;\n+  mpfr_t xp, xq;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -3380,23 +3338,24 @@ gfc_simplify_sin (gfc_expr * x)\n   switch (x->ts.type)\n     {\n     case BT_REAL:\n-      sine (&x->value.real, &result->value.real);\n+      mpfr_sin (result->value.real, x->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n-      mpf_init (xp);\n-      mpf_init (xq);\n+      gfc_set_model (x->value.real);\n+      mpfr_init (xp);\n+      mpfr_init (xq);\n \n-      sine (&x->value.complex.r, &xp);\n-      hypercos (&x->value.complex.i, &xq);\n-      mpf_mul (result->value.complex.r, xp, xq);\n+      mpfr_sin  (xp, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_cosh (xq, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (result->value.complex.r, xp, xq, GFC_RND_MODE);\n \n-      cosine (&x->value.complex.r, &xp);\n-      hypersine (&x->value.complex.i, &xq);\n-      mpf_mul (result->value.complex.i, xp, xq);\n+      mpfr_cos  (xp, x->value.complex.r, GFC_RND_MODE);\n+      mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n+      mpfr_mul (result->value.complex.i, xp, xq, GFC_RND_MODE);\n \n-      mpf_clear (xp);\n-      mpf_clear (xq);\n+      mpfr_clear (xp);\n+      mpfr_clear (xq);\n       break;\n \n     default:\n@@ -3417,7 +3376,7 @@ gfc_simplify_sinh (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  hypersine (&x->value.real, &result->value.real);\n+  mpfr_sinh(result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"SINH\");\n }\n@@ -3443,7 +3402,7 @@ gfc_expr *\n gfc_simplify_spacing (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t i1, i2, ln2, absv, lnx;\n+  mpfr_t i1, i2, ln2, absv, lnx, zero;\n   long diff;\n   unsigned long exp2;\n   int i, p;\n@@ -3459,48 +3418,56 @@ gfc_simplify_spacing (gfc_expr * x)\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  if (mpf_cmp (x->value.real, mpf_zero) == 0)\n+  gfc_set_model_kind (x->ts.kind);\n+  mpfr_init (zero);\n+  mpfr_set_ui (zero, 0, GFC_RND_MODE);\n+\n+  if (mpfr_cmp (x->value.real, zero) == 0)\n     {\n-      mpf_set (result->value.real, gfc_real_kinds[i].tiny);\n+      mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n+      mpfr_clear (zero);\n       return result;\n     }\n \n-  mpf_init_set_ui (i1, 1);\n-  mpf_init_set_ui (i2, 2);\n-  mpf_init (ln2);\n-  mpf_init (absv);\n-  mpf_init (lnx);\n+  mpfr_init (i1);\n+  mpfr_init (i2);\n+  mpfr_init (ln2);\n+  mpfr_init (absv);\n+  mpfr_init (lnx);\n \n-  natural_logarithm (&i2, &ln2);\n+  mpfr_set_ui (i1, 1, GFC_RND_MODE);\n+  mpfr_set_ui (i2, 2, GFC_RND_MODE);\n \n-  mpf_abs (absv, x->value.real);\n-  natural_logarithm (&absv, &lnx);\n+  mpfr_log (ln2, i2, GFC_RND_MODE);\n+  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n+  mpfr_log (lnx, absv, GFC_RND_MODE);\n \n-  mpf_div (lnx, lnx, ln2);\n-  mpf_trunc (lnx, lnx);\n-  mpf_add_ui (lnx, lnx, 1);\n+  mpfr_div (lnx, lnx, ln2, GFC_RND_MODE);\n+  mpfr_trunc (lnx, lnx);\n+  mpfr_add_ui (lnx, lnx, 1, GFC_RND_MODE);\n \n-  diff = (long) mpf_get_d (lnx) - (long) p;\n+  diff = (long) mpfr_get_d (lnx, GFC_RND_MODE) - (long) p;\n   if (diff >= 0)\n     {\n       exp2 = (unsigned) diff;\n-      mpf_mul_2exp (result->value.real, i1, exp2);\n+      mpfr_mul_2exp (result->value.real, i1, exp2, GFC_RND_MODE);\n     }\n   else\n     {\n       diff = -diff;\n       exp2 = (unsigned) diff;\n-      mpf_div_2exp (result->value.real, i1, exp2);\n+      mpfr_div_2exp (result->value.real, i1, exp2, GFC_RND_MODE);\n     }\n \n-  mpf_clear (i1);\n-  mpf_clear (i2);\n-  mpf_clear (ln2);\n-  mpf_clear (absv);\n-  mpf_clear (lnx);\n+  mpfr_clear (i1);\n+  mpfr_clear (i2);\n+  mpfr_clear (ln2);\n+  mpfr_clear (absv);\n+  mpfr_clear (lnx);\n+  mpfr_clear (zero);\n \n-  if (mpf_cmp (result->value.real, gfc_real_kinds[i].tiny) < 0)\n-    mpf_set (result->value.real, gfc_real_kinds[i].tiny);\n+  if (mpfr_cmp (result->value.real, gfc_real_kinds[i].tiny) < 0)\n+    mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n \n   return range_check (result, \"SPACING\");\n }\n@@ -3510,7 +3477,7 @@ gfc_expr *\n gfc_simplify_sqrt (gfc_expr * e)\n {\n   gfc_expr *result;\n-  mpf_t ac, ad, s, t, w;\n+  mpfr_t ac, ad, s, t, w;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -3520,92 +3487,93 @@ gfc_simplify_sqrt (gfc_expr * e)\n   switch (e->ts.type)\n     {\n     case BT_REAL:\n-      if (mpf_cmp_si (e->value.real, 0) < 0)\n+      if (mpfr_cmp_si (e->value.real, 0) < 0)\n \tgoto negative_arg;\n-      mpf_sqrt (result->value.real, e->value.real);\n+      mpfr_sqrt (result->value.real, e->value.real, GFC_RND_MODE);\n \n       break;\n \n     case BT_COMPLEX:\n       /* Formula taken from Numerical Recipes to avoid over- and\n          underflow.  */\n \n-      mpf_init (ac);\n-      mpf_init (ad);\n-      mpf_init (s);\n-      mpf_init (t);\n-      mpf_init (w);\n+      gfc_set_model (e->value.real);\n+      mpfr_init (ac);\n+      mpfr_init (ad);\n+      mpfr_init (s);\n+      mpfr_init (t);\n+      mpfr_init (w);\n \n-      if (mpf_cmp_ui (e->value.complex.r, 0) == 0\n-\t  && mpf_cmp_ui (e->value.complex.i, 0) == 0)\n+      if (mpfr_cmp_ui (e->value.complex.r, 0) == 0\n+\t  && mpfr_cmp_ui (e->value.complex.i, 0) == 0)\n \t{\n \n-\t  mpf_set_ui (result->value.complex.r, 0);\n-\t  mpf_set_ui (result->value.complex.i, 0);\n+\t  mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n+\t  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \t  break;\n \t}\n \n-      mpf_abs (ac, e->value.complex.r);\n-      mpf_abs (ad, e->value.complex.i);\n+      mpfr_abs (ac, e->value.complex.r, GFC_RND_MODE);\n+      mpfr_abs (ad, e->value.complex.i, GFC_RND_MODE);\n \n-      if (mpf_cmp (ac, ad) >= 0)\n+      if (mpfr_cmp (ac, ad) >= 0)\n \t{\n-\t  mpf_div (t, e->value.complex.i, e->value.complex.r);\n-\t  mpf_mul (t, t, t);\n-\t  mpf_add_ui (t, t, 1);\n-\t  mpf_sqrt (t, t);\n-\t  mpf_add_ui (t, t, 1);\n-\t  mpf_div_ui (t, t, 2);\n-\t  mpf_sqrt (t, t);\n-\t  mpf_sqrt (s, ac);\n-\t  mpf_mul (w, s, t);\n+\t  mpfr_div (t, e->value.complex.i, e->value.complex.r, GFC_RND_MODE);\n+\t  mpfr_mul (t, t, t, GFC_RND_MODE);\n+\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n+\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n+\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n+\t  mpfr_div_ui (t, t, 2, GFC_RND_MODE);\n+\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n+\t  mpfr_sqrt (s, ac, GFC_RND_MODE);\n+\t  mpfr_mul (w, s, t, GFC_RND_MODE);\n \t}\n       else\n \t{\n-\t  mpf_div (s, e->value.complex.r, e->value.complex.i);\n-\t  mpf_mul (t, s, s);\n-\t  mpf_add_ui (t, t, 1);\n-\t  mpf_sqrt (t, t);\n-\t  mpf_abs (s, s);\n-\t  mpf_add (t, t, s);\n-\t  mpf_div_ui (t, t, 2);\n-\t  mpf_sqrt (t, t);\n-\t  mpf_sqrt (s, ad);\n-\t  mpf_mul (w, s, t);\n+\t  mpfr_div (s, e->value.complex.r, e->value.complex.i, GFC_RND_MODE);\n+\t  mpfr_mul (t, s, s, GFC_RND_MODE);\n+\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n+\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n+\t  mpfr_abs (s, s, GFC_RND_MODE);\n+\t  mpfr_add (t, t, s, GFC_RND_MODE);\n+\t  mpfr_div_ui (t, t, 2, GFC_RND_MODE);\n+\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n+\t  mpfr_sqrt (s, ad, GFC_RND_MODE);\n+\t  mpfr_mul (w, s, t, GFC_RND_MODE);\n \t}\n \n-      if (mpf_cmp_ui (w, 0) != 0 && mpf_cmp_ui (e->value.complex.r, 0) >= 0)\n+      if (mpfr_cmp_ui (w, 0) != 0 && mpfr_cmp_ui (e->value.complex.r, 0) >= 0)\n \t{\n-\t  mpf_mul_ui (t, w, 2);\n-\t  mpf_div (result->value.complex.i, e->value.complex.i, t);\n-\t  mpf_set (result->value.complex.r, w);\n+\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n+\t  mpfr_div (result->value.complex.i, e->value.complex.i, t, GFC_RND_MODE);\n+\t  mpfr_set (result->value.complex.r, w, GFC_RND_MODE);\n \t}\n-      else if (mpf_cmp_ui (w, 0) != 0\n-\t       && mpf_cmp_ui (e->value.complex.r, 0) < 0\n-\t       && mpf_cmp_ui (e->value.complex.i, 0) >= 0)\n+      else if (mpfr_cmp_ui (w, 0) != 0\n+\t       && mpfr_cmp_ui (e->value.complex.r, 0) < 0\n+\t       && mpfr_cmp_ui (e->value.complex.i, 0) >= 0)\n \t{\n-\t  mpf_mul_ui (t, w, 2);\n-\t  mpf_div (result->value.complex.r, e->value.complex.i, t);\n-\t  mpf_set (result->value.complex.i, w);\n+\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n+\t  mpfr_div (result->value.complex.r, e->value.complex.i, t, GFC_RND_MODE);\n+\t  mpfr_set (result->value.complex.i, w, GFC_RND_MODE);\n \t}\n-      else if (mpf_cmp_ui (w, 0) != 0\n-\t       && mpf_cmp_ui (e->value.complex.r, 0) < 0\n-\t       && mpf_cmp_ui (e->value.complex.i, 0) < 0)\n+      else if (mpfr_cmp_ui (w, 0) != 0\n+\t       && mpfr_cmp_ui (e->value.complex.r, 0) < 0\n+\t       && mpfr_cmp_ui (e->value.complex.i, 0) < 0)\n \t{\n-\t  mpf_mul_ui (t, w, 2);\n-\t  mpf_div (result->value.complex.r, ad, t);\n-\t  mpf_neg (w, w);\n-\t  mpf_set (result->value.complex.i, w);\n+\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n+\t  mpfr_div (result->value.complex.r, ad, t, GFC_RND_MODE);\n+\t  mpfr_neg (w, w, GFC_RND_MODE);\n+\t  mpfr_set (result->value.complex.i, w, GFC_RND_MODE);\n \t}\n       else\n \tgfc_internal_error (\"invalid complex argument of SQRT at %L\",\n \t\t\t    &e->where);\n \n-      mpf_clear (s);\n-      mpf_clear (t);\n-      mpf_clear (ac);\n-      mpf_clear (ad);\n-      mpf_clear (w);\n+      mpfr_clear (s);\n+      mpfr_clear (t);\n+      mpfr_clear (ac);\n+      mpfr_clear (ad);\n+      mpfr_clear (w);\n \n       break;\n \n@@ -3625,9 +3593,8 @@ gfc_simplify_sqrt (gfc_expr * e)\n gfc_expr *\n gfc_simplify_tan (gfc_expr * x)\n {\n-  gfc_expr *result;\n-  mpf_t mpf_sin, mpf_cos, mag_cos;\n   int i;\n+  gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -3638,37 +3605,7 @@ gfc_simplify_tan (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpf_init (mpf_sin);\n-  mpf_init (mpf_cos);\n-  mpf_init (mag_cos);\n-  sine (&x->value.real, &mpf_sin);\n-  cosine (&x->value.real, &mpf_cos);\n-  mpf_abs (mag_cos, mpf_cos);\n-  if (mpf_cmp_ui (mag_cos, 0) == 0)\n-    {\n-      gfc_error (\"Tangent undefined at %L\", &x->where);\n-      mpf_clear (mpf_sin);\n-      mpf_clear (mpf_cos);\n-      mpf_clear (mag_cos);\n-      gfc_free_expr (result);\n-      return &gfc_bad_expr;\n-    }\n-  else if (mpf_cmp (mag_cos, gfc_real_kinds[i].tiny) < 0)\n-    {\n-      gfc_error (\"Tangent cannot be accurately evaluated at %L\", &x->where);\n-      mpf_clear (mpf_sin);\n-      mpf_clear (mpf_cos);\n-      mpf_clear (mag_cos);\n-      gfc_free_expr (result);\n-      return &gfc_bad_expr;\n-    }\n-  else\n-    {\n-      mpf_div (result->value.real, mpf_sin, mpf_cos);\n-      mpf_clear (mpf_sin);\n-      mpf_clear (mpf_cos);\n-      mpf_clear (mag_cos);\n-    }\n+  mpfr_tan (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"TAN\");\n }\n@@ -3678,23 +3615,13 @@ gfc_expr *\n gfc_simplify_tanh (gfc_expr * x)\n {\n   gfc_expr *result;\n-  mpf_t xp, xq;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpf_init (xp);\n-  mpf_init (xq);\n-\n-  hypersine (&x->value.real, &xq);\n-  hypercos (&x->value.real, &xp);\n-\n-  mpf_div (result->value.real, xq, xp);\n-\n-  mpf_clear (xp);\n-  mpf_clear (xq);\n+  mpfr_tanh (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"TANH\");\n \n@@ -3712,7 +3639,7 @@ gfc_simplify_tiny (gfc_expr * e)\n     gfc_internal_error (\"gfc_simplify_error(): Bad kind\");\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n-  mpf_set (result->value.real, gfc_real_kinds[i].tiny);\n+  mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n \n   return result;\n }\n@@ -3988,21 +3915,5 @@ void\n gfc_simplify_init_1 (void)\n {\n \n-  mpf_init_set_str (mpf_zero, \"0.0\", 10);\n-  mpf_init_set_str (mpf_half, \"0.5\", 10);\n-  mpf_init_set_str (mpf_one, \"1.0\", 10);\n-  mpz_init_set_str (mpz_zero, \"0\", 10);\n-\n   invert_table (ascii_table, xascii_table);\n }\n-\n-\n-void\n-gfc_simplify_done_1 (void)\n-{\n-\n-  mpf_clear (mpf_zero);\n-  mpf_clear (mpf_half);\n-  mpf_clear (mpf_one);\n-  mpz_clear (mpz_zero);\n-}"}, {"sha": "3202a599c397ee465a3ec370455ca057e42bea94", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -234,7 +234,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n /* Converts a real constant into backend form.  Uses an intermediate string\n    representation.  */\n tree\n-gfc_conv_mpf_to_tree (mpf_t f, int kind)\n+gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n {\n   tree res;\n   tree type;\n@@ -251,22 +251,21 @@ gfc_conv_mpf_to_tree (mpf_t f, int kind)\n     }\n   assert (gfc_real_kinds[n].kind);\n \n-  assert (gfc_real_kinds[n].radix == 2);\n-\n   n = MAX (abs (gfc_real_kinds[n].min_exponent),\n \t   abs (gfc_real_kinds[n].max_exponent));\n-#if 0\n-  edigits = 2 + (int) (log (n) / log (gfc_real_kinds[n].radix));\n-#endif\n+\n   edigits = 1;\n   while (n > 0)\n     {\n       n = n / 10;\n       edigits += 3;\n     }\n \n+  if (kind == gfc_default_double_kind())\n+    p = mpfr_get_str (NULL, &exp, 10, 17, f, GFC_RND_MODE);\n+  else\n+    p = mpfr_get_str (NULL, &exp, 10, 8, f, GFC_RND_MODE);\n \n-  p = mpf_get_str (NULL, &exp, 10, 0, f);\n \n   /* We also have one minus sign, \"e\", \".\" and a null terminator.  */\n   q = (char *) gfc_getmem (strlen (p) + edigits + 4);\n@@ -294,6 +293,7 @@ gfc_conv_mpf_to_tree (mpf_t f, int kind)\n \n   type = gfc_get_real_type (kind);\n   res = build_real (type, REAL_VALUE_ATOF (q, TYPE_MODE (type)));\n+\n   gfc_free (q);\n   gfc_free (p);\n \n@@ -321,16 +321,16 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n       return gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n \n     case BT_REAL:\n-      return gfc_conv_mpf_to_tree (expr->value.real, expr->ts.kind);\n+      return gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n \n     case BT_LOGICAL:\n       return build_int_2 (expr->value.logical, 0);\n \n     case BT_COMPLEX:\n       {\n-\ttree real = gfc_conv_mpf_to_tree (expr->value.complex.r,\n+\ttree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,\n \t\t\t\t\t  expr->ts.kind);\n-\ttree imag = gfc_conv_mpf_to_tree (expr->value.complex.i,\n+\ttree imag = gfc_conv_mpfr_to_tree (expr->value.complex.i,\n \t\t\t\t\t  expr->ts.kind);\n \n \treturn build_complex (NULL_TREE, real, imag);"}, {"sha": "7a36e9a5bcb9585811422d2d16aa8afbd19a941d", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -23,7 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n tree gfc_conv_mpz_to_tree (mpz_t, int);\n \n /* Returns a REAL_CST.  */\n-tree gfc_conv_mpf_to_tree (mpf_t, int);\n+tree gfc_conv_mpfr_to_tree (mpfr_t, int);\n \n /* Build a tree for a constant.  Must be an EXPR_CONSTANT gfc_expr.\n    For CHARACTER literal constants, the caller still has to set the"}, {"sha": "f83e1e177b52a458b5b3e8a6e1a8f8331a8f10cb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f8e566e5253e4b0fe2dcd477fbc35ca5576cc7bc", "patch": "@@ -33,9 +33,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"tree-gimple.h\"\n #include \"flags.h\"\n-#include <gmp.h>\n #include <assert.h>\n #include \"gfortran.h\"\n+#include \"arith.h\"\n #include \"intrinsic.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n@@ -308,7 +308,7 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, int op)\n   tree arg;\n   tree tmp;\n   tree cond;\n-  mpf_t huge;\n+  mpfr_t huge;\n   int n;\n   int kind;\n \n@@ -363,21 +363,23 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, int op)\n   arg = gfc_evaluate_now (arg, &se->pre);\n \n   /* Test if the value is too large to handle sensibly.  */\n-  mpf_init (huge);\n+  gfc_set_model_kind (kind);\n+  mpfr_init (huge);\n   n = gfc_validate_kind (BT_INTEGER, kind);\n-  mpf_set_z (huge, gfc_integer_kinds[n].huge);\n-  tmp = gfc_conv_mpf_to_tree (huge, kind);\n+  mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n+  tmp = gfc_conv_mpfr_to_tree (huge, kind);\n   cond = build (LT_EXPR, boolean_type_node, arg, tmp);\n \n-  mpf_neg (huge, huge);\n-  tmp = gfc_conv_mpf_to_tree (huge, kind);\n+  mpfr_neg (huge, huge, GFC_RND_MODE);\n+  tmp = gfc_conv_mpfr_to_tree (huge, kind);\n   tmp = build (GT_EXPR, boolean_type_node, arg, tmp);\n   cond = build (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n   itype = gfc_get_int_type (kind);\n \n   tmp = build_fix_expr (&se->pre, arg, itype, op);\n   tmp = convert (type, tmp);\n   se->expr = build (COND_EXPR, type, cond, tmp, arg);\n+  mpfr_clear (huge);\n }\n \n \n@@ -777,7 +779,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n   tree zero;\n   tree test;\n   tree test2;\n-  mpf_t huge;\n+  mpfr_t huge;\n   int n;\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n@@ -799,14 +801,15 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \n       tmp = build (RDIV_EXPR, type, arg, arg2);\n       /* Test if the value is too large to handle sensibly.  */\n-      mpf_init (huge);\n+      gfc_set_model_kind (expr->ts.kind);\n+      mpfr_init (huge);\n       n = gfc_validate_kind (BT_INTEGER, expr->ts.kind);\n-      mpf_set_z (huge, gfc_integer_kinds[n].huge);\n-      test = gfc_conv_mpf_to_tree (huge, expr->ts.kind);\n+      mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n+      test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n       test2 = build (LT_EXPR, boolean_type_node, tmp, test);\n \n-      mpf_neg (huge, huge);\n-      test = gfc_conv_mpf_to_tree (huge, expr->ts.kind);\n+      mpfr_neg (huge, huge, GFC_RND_MODE);\n+      test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n       test = build (GT_EXPR, boolean_type_node, tmp, test);\n       test2 = build (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \n@@ -816,6 +819,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       tmp = build (COND_EXPR, type, test2, tmp, arg);\n       tmp = build (MULT_EXPR, type, tmp, arg2);\n       se->expr = build (MINUS_EXPR, type, arg, tmp);\n+      mpfr_clear (huge);\n       break;\n \n     default:\n@@ -1423,7 +1427,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   switch (arrayexpr->ts.type)\n     {\n     case BT_REAL:\n-      tmp = gfc_conv_mpf_to_tree (gfc_real_kinds[n].huge, arrayexpr->ts.kind);\n+      tmp = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge, arrayexpr->ts.kind);\n       break;\n \n     case BT_INTEGER:\n@@ -1564,7 +1568,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   switch (expr->ts.type)\n     {\n     case BT_REAL:\n-      tmp = gfc_conv_mpf_to_tree (gfc_real_kinds[n].huge, expr->ts.kind);\n+      tmp = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge, expr->ts.kind);\n       break;\n \n     case BT_INTEGER:"}]}