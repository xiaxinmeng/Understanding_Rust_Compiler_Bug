{"sha": "c02065fca15d60c9d34ca18b5718a145c4571db7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyMDY1ZmNhMTVkNjBjOWQzNGNhMThiNTcxOGExNDVjNDU3MWRiNw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2013-11-15T21:43:59Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2013-11-15T21:43:59Z"}, "message": "Makefile.in (C_COMMON_OBJS): Depend on c-cilkplus.o.\n\n\t* Makefile.in (C_COMMON_OBJS): Depend on c-cilkplus.o.\n\t* gimple-pretty-print.c (dump_omp_for): Add case for\n\tGF_OMP_FOR_KIND_CILKSIMD.\n\t* gimple.h (enum gf_mask): Restructure entries to add\n\tGF_OMP_FOR_KIND_CILKSIMD.\n\t* gimplify.c (is_gimple_stmt): Add case for CILK_SIMD.\n\t(gimplify_omp_for): Handle CILK_SIMD.\n\t(gimplify_expr): Add ccase for CILK_SIMD.\n\t* omp-low.c (extract_omp_for_data): Handle CILK_SIMD.\n\t(build_outer_var_ref): Same.\n\t(check_omp_nesting_restrictions): Same.\n\t(lower_rec_input_clauses): Same.\n\t(lower_lastprivate_clauses): Same.\n\t(expand_omp_for): Same.\n\t(execute_expand_omp): Check flag_enable_cilkplus.\n\t(execute_lower_omp): Same.\n\t(diagnose_sb_0): Handle CILK_SIMD.\n\t(diagnose_omp_structured_block_errors): Check\n\tflag_enable_cilkplus.\n\t(setjmp_or_longjmp_p): New.\n\t(scan_omp_1_stmt): Error on setjmp/longjmp in a simd construct.\n\t* tree-pretty-print.c (dump_generic_node): Add case for CILK_SIMD.\n\t* tree.def: Add tree code for CILK_SIMD.\n\ntestsuite/\n\t* c-c++-common/cilk-plus/PS: New directory.\n\t* g++.dg/cilk-plus/cilk-plus.exp: Run shared tests.\n\t* g++.dg/dg.exp: Run Cilk Plus tests.\n\t* gcc.dg/cilk-plus/cilk-plus.exp: Run shared tests.\n\nc-family/\n\t* c-cilkplus.c: New file.\n\t* c-common.c (readonly_error): Add location argument.\n\t* c-common.h (readonly_error): Same.\n\t(c_finish_cilk_clauses): Protoize.\n\t(c_check_cilk_loop): Same.\n\tc-omp.c (c_finish_omp_for): Handle CILK_SIMD nodes.\n\tDo not fail on error_mark_node.\n\tAbstract increment canonicalization to here...\n\t(c_omp_for_incr_canonicalize_ptr): New.\n\tc-pragma.c (init_pragma): Register \"simd\" pragma.\n\tc-pragma.h (enum pragma_kind): Add PRAGMA_CILK_SIMD.\n\t(enum pragma_cilk_clause): New.\n\nc/\n\t* c-parser.c (c_parser_cilk_simd): New.\n\t(c_parser_cilk_verify_simd): New.\n\t(c_parser_pragma): Add case for PRAGMA_CILK_SIMD.\n\t(c_parser_omp_for_loop): Add case for NE_EXPR.\n\tSet c_break_label for CILK_SIMD.\n\t(c_parser_cilk_clause_vectorlength): New.\n\t(c_parser_cilk_clause_linear): New.\n\t(c_parser_cilk_clause_name): New.\n\t(c_parser_cilk_all_clauses): New.\n\t* c-typeck.c (build_unary_op): Pass location argument to\n\treadonly_error.\n\t(build_modify_expr): Same.\n\t(build_asm_expr): Same.\n\t(c_finish_bc_stmt): Error on break/continue in loops.\n\ncp/\n\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Depend on cp/cp-cilkplus.o.\n\t* cp-cilkplus.c: New file.\n\t* cp-tree.h (cpp_validate_cilk_plus_loop): Protoize.\n\t* parser.c (cp_parser_cilk_simd): New.\n\t(cp_debug_parser): Add case for IN_CILK_SIMD_FOR.\n\t(cp_parser_jump_statement): Same.\n\t(cp_parser_omp_for_cond): Add new argument.\n\tAdd case for NE_EXPR.\n\t(cp_parser_omp_for_loop): Pass new argument to\n\tcp_parser_omp_for_cond.\n\tHandle CILK_SIMD nodes.\n\tAbstract initilization code to..\n\t(cp_parser_omp_for_loop_init): ...here.\n\t(cp_parser_pragma): Add case for PRAGMA_CILK_SIMD.\n\t(cp_parser_cilk_simd_vectorlength): New.\n\t(cp_parser_cilk_simd_linear): New.\n\t(cp_parser_cilk_simd_clause_name): New.\n\t(cp_parser_cilk_simd_all_clauses): New.\n\t(cp_parser_cilk_simd): New.\n\t* parser.h (IN_CILK_SIMD_FOR): New macro.\n\t* pt.c (tsubst_expr): Add case for CILK_SIMD.\n\t* typeck2.c (cxx_readonly_error): Pass location argument to\n\treadonly_error.\n\nFrom-SVN: r204863", "tree": {"sha": "531091069cf52d56eed457cf2b11800e2597279f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/531091069cf52d56eed457cf2b11800e2597279f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c02065fca15d60c9d34ca18b5718a145c4571db7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02065fca15d60c9d34ca18b5718a145c4571db7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02065fca15d60c9d34ca18b5718a145c4571db7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02065fca15d60c9d34ca18b5718a145c4571db7/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e19eea7164c3c6b613628e5ca90c8742a34c2d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19eea7164c3c6b613628e5ca90c8742a34c2d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19eea7164c3c6b613628e5ca90c8742a34c2d68"}], "stats": {"total": 2175, "additions": 1912, "deletions": 263}, "files": [{"sha": "53be213434c68da976201a4eb172ddab9d0335d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1,3 +1,29 @@\n+2013-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (C_COMMON_OBJS): Depend on c-cilkplus.o.\n+\t* gimple-pretty-print.c (dump_omp_for): Add case for\n+\tGF_OMP_FOR_KIND_CILKSIMD.\n+\t* gimple.h (enum gf_mask): Restructure entries to add\n+\tGF_OMP_FOR_KIND_CILKSIMD.\n+\t* gimplify.c (is_gimple_stmt): Add case for CILK_SIMD.\n+\t(gimplify_omp_for): Handle CILK_SIMD.\n+\t(gimplify_expr): Add ccase for CILK_SIMD.\n+\t* omp-low.c (extract_omp_for_data): Handle CILK_SIMD.\n+\t(build_outer_var_ref): Same.\n+\t(check_omp_nesting_restrictions): Same.\n+\t(lower_rec_input_clauses): Same.\n+\t(lower_lastprivate_clauses): Same.\n+\t(expand_omp_for): Same.\n+\t(execute_expand_omp): Check flag_enable_cilkplus.\n+\t(execute_lower_omp): Same.\n+\t(diagnose_sb_0): Handle CILK_SIMD.\n+\t(diagnose_omp_structured_block_errors): Check\n+\tflag_enable_cilkplus.\n+\t(setjmp_or_longjmp_p): New.\n+\t(scan_omp_1_stmt): Error on setjmp/longjmp in a simd construct.\n+\t* tree-pretty-print.c (dump_generic_node): Add case for CILK_SIMD.\n+\t* tree.def: Add tree code for CILK_SIMD.\n+\n 2013-11-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/altivec.md (UNSPEC_VPERM_X, UNSPEC_VPERM_UNS_X):"}, {"sha": "77fba80cffc57d9e29cb2cb44f97b010d120d5be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1138,6 +1138,7 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o \\\n+  c-family/c-cilkplus.o \\\n   c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o\n \n # Language-independent object files."}, {"sha": "9f884b6c8451be59e5f091e6ea936b4fa811a569", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1,3 +1,18 @@\n+2013-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-cilkplus.c: New file.\n+\t* c-common.c (readonly_error): Add location argument.\n+\t* c-common.h (readonly_error): Same.\n+\t(c_finish_cilk_clauses): Protoize.\n+\t(c_check_cilk_loop): Same.\n+\tc-omp.c (c_finish_omp_for): Handle CILK_SIMD nodes.\n+\tDo not fail on error_mark_node.\n+\tAbstract increment canonicalization to here...\n+\t(c_omp_for_incr_canonicalize_ptr): New.\n+\tc-pragma.c (init_pragma): Register \"simd\" pragma.\n+\tc-pragma.h (enum pragma_kind): Add PRAGMA_CILK_SIMD.\n+\t(enum pragma_cilk_clause): New.\n+\n 2013-11-15  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* c-pretty-print.c (pp_c_character_constant): Remove unnecessary"}, {"sha": "6fa979d652dd2e8be71bc39d3c680dc7997db596", "filename": "gcc/c-family/c-cilkplus.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cilkplus.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,93 @@\n+/* This file contains routines to construct and validate Cilk Plus\n+   constructs within the C and C++ front ends.\n+\n+   Copyright (C) 2013  Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+\n+/* Validate the body of a _Cilk_for construct or a <#pragma simd> for\n+   loop.\n+\n+   Returns true if there were no errors, false otherwise.  */\n+\n+bool\n+c_check_cilk_loop (location_t loc, tree decl)\n+{\n+  if (TREE_THIS_VOLATILE (decl))\n+    {\n+      error_at (loc, \"iteration variable cannot be volatile\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Validate and emit code for <#pragma simd> clauses.  */\n+\n+tree\n+c_finish_cilk_clauses (tree clauses)\n+{\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      tree prev = clauses;\n+\n+      /* If a variable appears in a linear clause it cannot appear in\n+\t any other OMP clause.  */\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n+\tfor (tree c2 = clauses; c2; c2 = OMP_CLAUSE_CHAIN (c2))\n+\t  {\n+\t    if (c == c2)\n+\t      continue;\n+\t    enum omp_clause_code code = OMP_CLAUSE_CODE (c2);\n+\n+\t    switch (code)\n+\t      {\n+\t      case OMP_CLAUSE_LINEAR:\n+\t      case OMP_CLAUSE_PRIVATE:\n+\t      case OMP_CLAUSE_FIRSTPRIVATE:\n+\t      case OMP_CLAUSE_LASTPRIVATE:\n+\t      case OMP_CLAUSE_REDUCTION:\n+\t\tbreak;\n+\n+\t      case OMP_CLAUSE_SAFELEN:\n+\t\tgoto next;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\n+\t    if (OMP_CLAUSE_DECL (c) == OMP_CLAUSE_DECL (c2))\n+\t      {\n+\t\terror_at (OMP_CLAUSE_LOCATION (c2),\n+\t\t\t  \"variable appears in more than one clause\");\n+\t\tinform (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"other clause defined here\");\n+\t\t// Remove problematic clauses.\n+\t\tOMP_CLAUSE_CHAIN (prev) = OMP_CLAUSE_CHAIN (c2);\n+\t      }\n+\t  next:\n+\t    prev = c2;\n+\t  }\n+    }\n+  return clauses;\n+}"}, {"sha": "d7d5cb20a17788530ab29d2db85febc35493b589", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -9816,7 +9816,7 @@ warn_for_omitted_condop (location_t location, tree cond)\n    how ARG was being used.  */\n \n void\n-readonly_error (tree arg, enum lvalue_use use)\n+readonly_error (location_t loc, tree arg, enum lvalue_use use)\n {\n   gcc_assert (use == lv_assign || use == lv_increment || use == lv_decrement\n \t      || use == lv_asm);\n@@ -9829,59 +9829,59 @@ readonly_error (tree arg, enum lvalue_use use)\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        error (READONLY_MSG (G_(\"assignment of member \"\n-\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t     G_(\"increment of member \"\n-\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t     G_(\"decrement of member \"\n-\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t     G_(\"member %qD in read-only object \"\n-\t\t\t\t\"used as %<asm%> output\")),\n-\t       TREE_OPERAND (arg, 1));\n+        error_at (loc, READONLY_MSG (G_(\"assignment of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"increment of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"decrement of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"member %qD in read-only object \"\n+\t\t\t\t\t\"used as %<asm%> output\")),\n+\t\t  TREE_OPERAND (arg, 1));\n       else\n-\terror (READONLY_MSG (G_(\"assignment of read-only member %qD\"),\n-\t\t\t     G_(\"increment of read-only member %qD\"),\n-\t\t\t     G_(\"decrement of read-only member %qD\"),\n-\t\t\t     G_(\"read-only member %qD used as %<asm%> output\")),\n-\t       TREE_OPERAND (arg, 1));\n+\terror_at (loc, READONLY_MSG (G_(\"assignment of read-only member %qD\"),\n+\t\t\t\t     G_(\"increment of read-only member %qD\"),\n+\t\t\t\t     G_(\"decrement of read-only member %qD\"),\n+\t\t\t\t     G_(\"read-only member %qD used as %<asm%> output\")),\n+\t\t  TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n-    error (READONLY_MSG (G_(\"assignment of read-only variable %qD\"),\n-\t\t\t G_(\"increment of read-only variable %qD\"),\n-\t\t\t G_(\"decrement of read-only variable %qD\"),\n-\t\t\t G_(\"read-only variable %qD used as %<asm%> output\")),\n-\t   arg);\n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only variable %qD\"),\n+\t\t\t\t G_(\"increment of read-only variable %qD\"),\n+\t\t\t\t G_(\"decrement of read-only variable %qD\"),\n+\t\t\t\t G_(\"read-only variable %qD used as %<asm%> output\")),\n+\t      arg);\n   else if (TREE_CODE (arg) == PARM_DECL)\n-    error (READONLY_MSG (G_(\"assignment of read-only parameter %qD\"),\n-\t\t\t G_(\"increment of read-only parameter %qD\"),\n-\t\t\t G_(\"decrement of read-only parameter %qD\"),\n-\t\t\t G_(\"read-only parameter %qD use as %<asm%> output\")),\n-\t   arg);  \n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only parameter %qD\"),\n+\t\t\t\t G_(\"increment of read-only parameter %qD\"),\n+\t\t\t\t G_(\"decrement of read-only parameter %qD\"),\n+\t\t\t\t G_(\"read-only parameter %qD use as %<asm%> output\")),\n+\t      arg);\n   else if (TREE_CODE (arg) == RESULT_DECL)\n     {\n       gcc_assert (c_dialect_cxx ());\n-      error (READONLY_MSG (G_(\"assignment of \"\n-\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t   G_(\"increment of \"\n-\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t   G_(\"decrement of \"\n-\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t   G_(\"read-only named return value %qD \"\n-\t\t\t      \"used as %<asm%>output\")),\n-\t     arg);\n+      error_at (loc, READONLY_MSG (G_(\"assignment of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"increment of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"decrement of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"read-only named return value %qD \"\n+\t\t\t\t      \"used as %<asm%>output\")),\n+\t\targ);\n     }\n   else if (TREE_CODE (arg) == FUNCTION_DECL)\n-    error (READONLY_MSG (G_(\"assignment of function %qD\"),\n-\t\t\t G_(\"increment of function %qD\"),\n-\t\t\t G_(\"decrement of function %qD\"),\n-\t\t\t G_(\"function %qD used as %<asm%> output\")),\n-\t   arg);\n+    error_at (loc, READONLY_MSG (G_(\"assignment of function %qD\"),\n+\t\t\t\t G_(\"increment of function %qD\"),\n+\t\t\t\t G_(\"decrement of function %qD\"),\n+\t\t\t\t G_(\"function %qD used as %<asm%> output\")),\n+\t      arg);\n   else\n-    error (READONLY_MSG (G_(\"assignment of read-only location %qE\"),\n-\t\t\t G_(\"increment of read-only location %qE\"),\n-\t\t\t G_(\"decrement of read-only location %qE\"),\n-\t\t\t G_(\"read-only location %qE used as %<asm%> output\")),\n-\t   arg);\n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only location %qE\"),\n+\t\t\t\t G_(\"increment of read-only location %qE\"),\n+\t\t\t\t G_(\"decrement of read-only location %qE\"),\n+\t\t\t\t G_(\"read-only location %qE used as %<asm%> output\")),\n+\t      arg);\n }\n \n /* Print an error message for an invalid lvalue.  USE says"}, {"sha": "b931fd6d2a8625b671ca366bc767780eff7c0da7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -970,7 +970,7 @@ enum lvalue_use {\n   lv_asm\n };\n \n-extern void readonly_error (tree, enum lvalue_use);\n+extern void readonly_error (location_t, tree, enum lvalue_use);\n extern void lvalue_error (location_t, enum lvalue_use);\n extern void invalid_indirection_error (location_t, tree, ref_operator);\n \n@@ -1289,6 +1289,11 @@ enum stv_conv {\n extern enum stv_conv scalar_to_vector (location_t loc, enum tree_code code,\n \t\t\t\t       tree op0, tree op1, bool);\n \n+/* In c-cilkplus.c  */\n+extern tree c_finish_cilk_clauses (tree);\n+extern tree c_validate_cilk_plus_loop (tree *, int *, void *);\n+extern bool c_check_cilk_loop (location_t, tree);\n+\n /* These #defines allow users to access different operands of the\n    array notation tree.  */\n "}, {"sha": "921b40628c364fb153936357f4a35b50e74e8518", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -349,6 +349,28 @@ check_omp_for_incr_expr (location_t loc, tree exp, tree decl)\n   return error_mark_node;\n }\n \n+/* If the OMP_FOR increment expression in INCR is of pointer type,\n+   canonicalize it into an expression handled by gimplify_omp_for()\n+   and return it.  DECL is the iteration variable.  */\n+\n+static tree\n+c_omp_for_incr_canonicalize_ptr (location_t loc, tree decl, tree incr)\n+{\n+  if (POINTER_TYPE_P (TREE_TYPE (decl))\n+      && TREE_OPERAND (incr, 1))\n+    {\n+      tree t = fold_convert_loc (loc,\n+\t\t\t\t sizetype, TREE_OPERAND (incr, 1));\n+\n+      if (TREE_CODE (incr) == POSTDECREMENT_EXPR\n+\t  || TREE_CODE (incr) == PREDECREMENT_EXPR)\n+\tt = fold_build1_loc (loc, NEGATE_EXPR, sizetype, t);\n+      t = fold_build_pointer_plus (decl, t);\n+      incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+    }\n+  return incr;\n+}\n+\n /* Validate and emit code for the OpenMP directive #pragma omp for.\n    DECLV is a vector of iteration variables, for each collapsed loop.\n    INITV, CONDV and INCRV are vectors containing initialization\n@@ -364,6 +386,10 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   bool fail = false;\n   int i;\n \n+  if (code == CILK_SIMD\n+      && !c_check_cilk_loop (locus, TREE_VEC_ELT (declv, 0)))\n+    fail = true;\n+\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (initv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (condv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n@@ -407,8 +433,11 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t    init,\n \t\t\t\t    NULL_TREE);\n \t}\n-      gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n-      gcc_assert (TREE_OPERAND (init, 0) == decl);\n+      if (init != error_mark_node)\n+\t{\n+\t  gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+\t  gcc_assert (TREE_OPERAND (init, 0) == decl);\n+\t}\n \n       if (cond == NULL_TREE)\n \t{\n@@ -487,7 +516,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t\t    0))\n \t\t    TREE_SET_CODE (cond, TREE_CODE (cond) == NE_EXPR\n \t\t\t\t\t ? LT_EXPR : GE_EXPR);\n-\t\t  else\n+\t\t  else if (code != CILK_SIMD)\n \t\t    cond_ok = false;\n \t\t}\n \t    }\n@@ -523,18 +552,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\tbreak;\n \n \t      incr_ok = true;\n-\t      if (POINTER_TYPE_P (TREE_TYPE (decl))\n-\t\t  && TREE_OPERAND (incr, 1))\n-\t\t{\n-\t\t  tree t = fold_convert_loc (elocus,\n-\t\t\t\t\t     sizetype, TREE_OPERAND (incr, 1));\n-\n-\t\t  if (TREE_CODE (incr) == POSTDECREMENT_EXPR\n-\t\t      || TREE_CODE (incr) == PREDECREMENT_EXPR)\n-\t\t    t = fold_build1_loc (elocus, NEGATE_EXPR, sizetype, t);\n-\t\t  t = fold_build_pointer_plus (decl, t);\n-\t\t  incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n-\t\t}\n+\t      incr = c_omp_for_incr_canonicalize_ptr (elocus, decl, incr);\n \t      break;\n \n \t    case MODIFY_EXPR:"}, {"sha": "029ab1e33acebc55be6c550e056c9f65ed5bbbd8", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1380,6 +1380,10 @@ init_pragma (void)\n \t\t\t\t      omp_pragmas_simd[i].id, true, true);\n     }\n \n+  if (flag_enable_cilkplus && !flag_preprocess_only)\n+    cpp_register_deferred_pragma (parse_in, NULL, \"simd\", PRAGMA_CILK_SIMD,\n+\t\t\t\t  true, false);\n+\n   if (!flag_preprocess_only)\n     cpp_register_deferred_pragma (parse_in, \"GCC\", \"pch_preprocess\",\n \t\t\t\t  PRAGMA_GCC_PCH_PREPROCESS, false, false);"}, {"sha": "5379b9e4eb82b178060ff597c8dc11b18018d939", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -52,6 +52,9 @@ typedef enum pragma_kind {\n   PRAGMA_OMP_THREADPRIVATE,\n   PRAGMA_OMP_TEAMS,\n \n+  /* Top level clause to handle all Cilk Plus pragma simd clauses.  */\n+  PRAGMA_CILK_SIMD,\n+\n   PRAGMA_GCC_PCH_PREPROCESS,\n   PRAGMA_IVDEP,\n \n@@ -103,6 +106,17 @@ typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_UNTIED\n } pragma_omp_clause;\n \n+/* All Cilk Plus #pragma omp clauses.  */\n+typedef enum pragma_cilk_clause {\n+  PRAGMA_CILK_CLAUSE_NONE = 0,\n+  PRAGMA_CILK_CLAUSE_VECTORLENGTH,\n+  PRAGMA_CILK_CLAUSE_LINEAR,\n+  PRAGMA_CILK_CLAUSE_PRIVATE,\n+  PRAGMA_CILK_CLAUSE_FIRSTPRIVATE,\n+  PRAGMA_CILK_CLAUSE_LASTPRIVATE,\n+  PRAGMA_CILK_CLAUSE_REDUCTION\n+} pragma_cilk_clause;\n+\n extern struct cpp_reader* parse_in;\n \n /* It's safe to always leave visibility pragma enabled as if"}, {"sha": "f1b1a4961853c7e4b8a7176caddd93b30c82962c", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1,3 +1,20 @@\n+2013-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-parser.c (c_parser_cilk_simd): New.\n+\t(c_parser_cilk_verify_simd): New.\n+\t(c_parser_pragma): Add case for PRAGMA_CILK_SIMD.\n+\t(c_parser_omp_for_loop): Add case for NE_EXPR.\n+\tSet c_break_label for CILK_SIMD.\n+\t(c_parser_cilk_clause_vectorlength): New.\n+\t(c_parser_cilk_clause_linear): New.\n+\t(c_parser_cilk_clause_name): New.\n+\t(c_parser_cilk_all_clauses): New.\n+\t* c-typeck.c (build_unary_op): Pass location argument to\n+\treadonly_error.\n+\t(build_modify_expr): Same.\n+\t(build_asm_expr): Same.\n+\t(c_finish_bc_stmt): Error on break/continue in loops.\n+\n 2013-11-14  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-typeck.c: Include only gimplify.h and gimple.h as needed."}, {"sha": "6f034029151f58d6749ae2ab7ee0485ad49ba685", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 263, "deletions": 1, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1237,6 +1237,9 @@ static void c_parser_objc_at_dynamic_declaration (c_parser *);\n static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n \n+/* Cilk Plus supporting routines.  */\n+static void c_parser_cilk_simd (c_parser *);\n+static bool c_parser_cilk_verify_simd (c_parser *, enum pragma_context);\n static tree c_parser_array_notation (location_t, c_parser *, tree, tree);\n \n /* Parse a translation unit (C90 6.7, C99 6.9).\n@@ -9371,6 +9374,13 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n       return false;\n \n+    case PRAGMA_CILK_SIMD:\n+      if (!c_parser_cilk_verify_simd (parser, context))\n+\treturn false;\n+      c_parser_consume_pragma (parser);\n+      c_parser_cilk_simd (parser);\n+      return false;\n+\n     default:\n       if (id < PRAGMA_FIRST_EXTERNAL)\n \t{\n@@ -11543,6 +11553,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t    case LT_EXPR:\n \t    case LE_EXPR:\n \t      break;\n+\t    case NE_EXPR:\n+\t      if (code == CILK_SIMD)\n+\t\tbreak;\n+\t      /* FALLTHRU.  */\n \t    default:\n \t      /* Can't be cond = error_mark_node, because we want to preserve\n \t\t the location until c_finish_omp_for.  */\n@@ -11616,7 +11630,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n     }\n \n   save_break = c_break_label;\n-  c_break_label = size_one_node;\n+  if (code == CILK_SIMD)\n+    c_break_label = build_int_cst (size_type_node, 2);\n+  else\n+    c_break_label = size_one_node;\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n   body = push_stmt_list ();\n@@ -13311,7 +13328,252 @@ c_parser_omp_threadprivate (c_parser *parser)\n \n   c_parser_skip_to_pragma_eol (parser);\n }\n+\f\n+/* Cilk Plus <#pragma simd> parsing routines.  */\n+\n+/* Helper function for c_parser_pragma.  Perform some sanity checking\n+   for <#pragma simd> constructs.  Returns FALSE if there was a\n+   problem.  */\n+\n+static bool\n+c_parser_cilk_verify_simd (c_parser *parser,\n+\t\t\t\t  enum pragma_context context)\n+{\n+  if (!flag_enable_cilkplus)\n+    {\n+      warning (0, \"pragma simd ignored because -fcilkplus is not enabled\");\n+      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+      return false;\n+    }\n+  if (context == pragma_external)\n+    {\n+      c_parser_error (parser,\"pragma simd must be inside a function\");\n+      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Cilk Plus:\n+   vectorlength ( constant-expression ) */\n+\n+static tree\n+c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses)\n+{\n+  /* The vectorlength clause behaves exactly like OpenMP's safelen\n+     clause.  Represent it in OpenMP terms.  */\n+  check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\");\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return clauses;\n+\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree expr = c_parser_expr_no_commas (parser, NULL).value;\n+  expr = c_fully_fold (expr, false, NULL);\n+\n+  if (!TREE_TYPE (expr)\n+      || !TREE_CONSTANT (expr)\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n+    error_at (loc, \"vectorlength must be an integer constant\");\n+  else if (exact_log2 (TREE_INT_CST_LOW (expr)) == -1)\n+    error_at (loc, \"vectorlength must be a power of 2\");\n+  else\n+    {\n+      tree u = build_omp_clause (loc, OMP_CLAUSE_SAFELEN);\n+      OMP_CLAUSE_SAFELEN_EXPR (u) = expr;\n+      OMP_CLAUSE_CHAIN (u) = clauses;\n+      clauses = u;\n+    }\n+\n+  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+  return clauses;\n+}\n+\n+/* Cilk Plus:\n+   linear ( simd-linear-variable-list )\n+\n+   simd-linear-variable-list:\n+     simd-linear-variable\n+     simd-linear-variable-list , simd-linear-variable\n+\n+   simd-linear-variable:\n+     id-expression\n+     id-expression : simd-linear-step\n+\n+   simd-linear-step:\n+   conditional-expression */\n+\n+static tree\n+c_parser_cilk_clause_linear (c_parser *parser, tree clauses)\n+{\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return clauses;\n+\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n+  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+    c_parser_error (parser, \"expected identifier\");\n+\n+  while (c_parser_next_token_is (parser, CPP_NAME)\n+\t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+    {\n+      tree var = lookup_name (c_parser_peek_token (parser)->value);\n+\n+      if (var == NULL)\n+\t{\n+\t  undeclared_variable (c_parser_peek_token (parser)->location,\n+\t\t\t       c_parser_peek_token (parser)->value);\n+\tc_parser_consume_token (parser);\n+\t}\n+      else if (var == error_mark_node)\n+\tc_parser_consume_token (parser);\n+      else\n+\t{\n+\t  tree step = integer_one_node;\n+\n+\t  /* Parse the linear step if present.  */\n+\t  if (c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\n+\t      tree expr = c_parser_expr_no_commas (parser, NULL).value;\n+\t      expr = c_fully_fold (expr, false, NULL);\n+\n+\t      if (TREE_TYPE (expr)\n+\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t\t  && (TREE_CONSTANT (expr)\n+\t\t      || DECL_P (expr)))\n+\t\tstep = expr;\n+\t      else\n+\t\tc_parser_error (parser,\n+\t\t\t\t\"step size must be an integer constant \"\n+\t\t\t\t\"expression or an integer variable\");\n+\t    }\n+\t  else\n+\t    c_parser_consume_token (parser);\n+\n+\t  /* Use OMP_CLAUSE_LINEAR, which has the same semantics.  */\n+\t  tree u = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n+\t  OMP_CLAUSE_DECL (u) = var;\n+\t  OMP_CLAUSE_LINEAR_STEP (u) = step;\n+\t  OMP_CLAUSE_CHAIN (u) = clauses;\n+\t  clauses = u;\n+\t}\n+\n+      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n+\tbreak;\n+\n+      c_parser_consume_token (parser);\n+    }\n+\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+  return clauses;\n+}\n+\n+/* Returns the name of the next clause.  If the clause is not\n+   recognized SIMD_OMP_CLAUSE_NONE is returned and the next token is\n+   not consumed.  Otherwise, the appropriate pragma_simd_clause is\n+   returned and the token is consumed.  */\n+\n+static pragma_cilk_clause\n+c_parser_cilk_clause_name (c_parser *parser)\n+{\n+  pragma_cilk_clause result;\n+  c_token *token = c_parser_peek_token (parser);\n+\n+  if (!token->value || token->type != CPP_NAME)\n+    return PRAGMA_CILK_CLAUSE_NONE;\n+\n+  const char *p = IDENTIFIER_POINTER (token->value);\n+\n+  if (!strcmp (p, \"vectorlength\"))\n+    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n+  else if (!strcmp (p, \"linear\"))\n+    result = PRAGMA_CILK_CLAUSE_LINEAR;\n+  else if (!strcmp (p, \"private\"))\n+    result = PRAGMA_CILK_CLAUSE_PRIVATE;\n+  else if (!strcmp (p, \"firstprivate\"))\n+    result = PRAGMA_CILK_CLAUSE_FIRSTPRIVATE;\n+  else if (!strcmp (p, \"lastprivate\"))\n+    result = PRAGMA_CILK_CLAUSE_LASTPRIVATE;\n+  else if (!strcmp (p, \"reduction\"))\n+    result = PRAGMA_CILK_CLAUSE_REDUCTION;\n+  else\n+    return PRAGMA_CILK_CLAUSE_NONE;\n+\n+  c_parser_consume_token (parser);\n+  return result;\n+}\n+\n+/* Parse all #<pragma simd> clauses.  Return the list of clauses\n+   found.  */\n+\n+static tree\n+c_parser_cilk_all_clauses (c_parser *parser)\n+{\n+  tree clauses = NULL;\n+\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      pragma_cilk_clause c_kind;\n+\n+      c_kind = c_parser_cilk_clause_name (parser);\n+\n+      switch (c_kind)\n+\t{\n+\tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n+\t  clauses = c_parser_cilk_clause_vectorlength (parser, clauses);\n+\t  break;\n+\tcase PRAGMA_CILK_CLAUSE_LINEAR:\n+\t  clauses = c_parser_cilk_clause_linear (parser, clauses);\n+\t  break;\n+\tcase PRAGMA_CILK_CLAUSE_PRIVATE:\n+\t  /* Use the OpenMP counterpart.  */\n+\t  clauses = c_parser_omp_clause_private (parser, clauses);\n+\t  break;\n+\tcase PRAGMA_CILK_CLAUSE_FIRSTPRIVATE:\n+\t  /* Use the OpenMP counterpart.  */\n+\t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n+\t  break;\n+\tcase PRAGMA_CILK_CLAUSE_LASTPRIVATE:\n+\t  /* Use the OpenMP counterpart.  */\n+\t  clauses = c_parser_omp_clause_lastprivate (parser, clauses);\n+\t  break;\n+\tcase PRAGMA_CILK_CLAUSE_REDUCTION:\n+\t  /* Use the OpenMP counterpart.  */\n+\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n+\t  break;\n+\tdefault:\n+\t  c_parser_error (parser, \"expected %<#pragma simd%> clause\");\n+\t  goto saw_error;\n+\t}\n+    }\n+\n+ saw_error:\n+  c_parser_skip_to_pragma_eol (parser);\n+  return c_finish_cilk_clauses (clauses);\n+}\n+\n+/* Main entry point for parsing Cilk Plus <#pragma simd> for\n+   loops.  */\n \n+static void\n+c_parser_cilk_simd (c_parser *parser ATTRIBUTE_UNUSED)\n+{\n+  char p_name[100];\n+  strcpy (p_name, \"#pragma omp\");\n+  tree clauses = c_parser_cilk_all_clauses (parser);\n+  tree block = c_begin_compound_stmt (true);\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  c_parser_omp_for_loop (loc, parser, CILK_SIMD, clauses, NULL);\n+  block = c_end_compound_stmt (loc, block, true);\n+  add_stmt (block);\n+}\n+\f\n /* Parse a transaction attribute (GCC Extension).\n \n    transaction-attribute:"}, {"sha": "a823f1439f3e77bf7c954724be6fa9a8b02769b8", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -4055,7 +4055,7 @@ build_unary_op (location_t location,\n \t/* Report a read-only lvalue.  */\n \tif (TYPE_READONLY (argtype))\n \t  {\n-\t    readonly_error (arg,\n+\t    readonly_error (location, arg,\n \t\t\t    ((code == PREINCREMENT_EXPR\n \t\t\t      || code == POSTINCREMENT_EXPR)\n \t\t\t     ? lv_increment : lv_decrement));\n@@ -5266,7 +5266,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \t   || TREE_CODE (lhstype) == UNION_TYPE)\n \t  && C_TYPE_FIELDS_READONLY (lhstype)))\n     {\n-      readonly_error (lhs, lv_assign);\n+      readonly_error (location, lhs, lv_assign);\n       return error_mark_node;\n     }\n   else if (TREE_READONLY (lhs))\n@@ -8949,7 +8949,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n \t      || ((TREE_CODE (TREE_TYPE (output)) == RECORD_TYPE\n \t\t   || TREE_CODE (TREE_TYPE (output)) == UNION_TYPE)\n \t\t  && C_TYPE_FIELDS_READONLY (TREE_TYPE (output)))))\n-\treadonly_error (output, lv_asm);\n+\treadonly_error (loc, output, lv_asm);\n \n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n       oconstraints[i] = constraint;\n@@ -9576,6 +9576,13 @@ c_finish_bc_stmt (location_t loc, tree *label_p, bool is_break)\n       error_at (loc, \"break statement used with OpenMP for loop\");\n       return NULL_TREE;\n \n+    case 2:\n+      if (is_break) \n+\terror (\"break statement within %<#pragma simd%> loop body\");\n+      else \n+\terror (\"continue statement within %<#pragma simd%> loop body\");\n+      return NULL_TREE;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "2a16220dda212cf25df57206f83368a30d1b6a3f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1,3 +1,29 @@\n+2013-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Depend on cp/cp-cilkplus.o.\n+\t* cp-cilkplus.c: New file.\n+\t* cp-tree.h (cpp_validate_cilk_plus_loop): Protoize.\n+\t* parser.c (cp_parser_cilk_simd): New.\n+\t(cp_debug_parser): Add case for IN_CILK_SIMD_FOR.\n+\t(cp_parser_jump_statement): Same.\n+\t(cp_parser_omp_for_cond): Add new argument.\n+\tAdd case for NE_EXPR.\n+\t(cp_parser_omp_for_loop): Pass new argument to\n+\tcp_parser_omp_for_cond.\n+\tHandle CILK_SIMD nodes.\n+\tAbstract initilization code to..\n+\t(cp_parser_omp_for_loop_init): ...here.\n+\t(cp_parser_pragma): Add case for PRAGMA_CILK_SIMD.\n+\t(cp_parser_cilk_simd_vectorlength): New.\n+\t(cp_parser_cilk_simd_linear): New.\n+\t(cp_parser_cilk_simd_clause_name): New.\n+\t(cp_parser_cilk_simd_all_clauses): New.\n+\t(cp_parser_cilk_simd): New.\n+\t* parser.h (IN_CILK_SIMD_FOR): New macro.\n+\t* pt.c (tsubst_expr): Add case for CILK_SIMD.\n+\t* typeck2.c (cxx_readonly_error): Pass location argument to\n+\treadonly_error.\n+\n 2013-11-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57887"}, {"sha": "424f2e6cdc509260ee86427eeffb51728c3fa65e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -76,6 +76,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n+ cp/cp-cilkplus.o \\\n  cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o \\\n  cp/vtable-class-hierarchy.o $(CXX_C_OBJS)\n "}, {"sha": "5c1090a097f7a198eb98a1e41f5ec3f1b39ca04e", "filename": "gcc/cp/cp-cilkplus.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fcp-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fcp-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-cilkplus.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,77 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains routines to handle Cilk Plus specific\n+   routines for the C++ Compiler.\n+   Copyright (C) 2013  Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"cp-tree.h\"\n+#include \"diagnostic-core.h\"\n+\n+\n+/* Callback for cp_walk_tree to validate the body of a pragma simd loop\n+   or _cilk_for loop.\n+\n+   This function is passed in as a function pointer to walk_tree.  *TP is\n+   the current tree pointer, *WALK_SUBTREES is set to 0 by this function if\n+   recursing into TP's subtrees is unnecessary. *DATA is a bool variable that\n+   is set to false if an error has occured.  */\n+\n+static tree\n+cpp_validate_cilk_plus_loop_aux (tree *tp, int *walk_subtrees, void *data)\n+{\n+  bool *valid = (bool *) data;\n+  location_t loc = EXPR_HAS_LOCATION (*tp) ? EXPR_LOCATION (*tp) :\n+    UNKNOWN_LOCATION;\n+\n+  if (!tp || !*tp)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (*tp) == THROW_EXPR)\n+    {\n+      error_at (loc, \"throw expressions are not allowed inside loops \"\n+\t\t\"marked with pragma simd\");\n+      *walk_subtrees = 0;\n+      *valid = false;\n+    }\n+  else if (TREE_CODE (*tp) == TRY_BLOCK)\n+    {\n+      error_at (loc, \"try statements are not allowed inside loops marked \"\n+\t\t\"with #pragma simd\");\n+      *valid = false;\n+      *walk_subtrees = 0;\n+    }\n+  return NULL_TREE;\n+}  \n+\n+\n+/* Walks through all the subtrees of BODY using walk_tree to make sure\n+   invalid statements/expressions are not found inside BODY.  Returns\n+   false if any invalid statements are found.  */\n+\n+bool\n+cpp_validate_cilk_plus_loop (tree body)\n+{\n+  bool valid = true;\n+  cp_walk_tree (&body, cpp_validate_cilk_plus_loop_aux,\n+\t\t(void *) &valid, NULL);\n+  return valid;\n+}"}, {"sha": "4e26bd501b44a64e4a302a15833c7a483c74454f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -6177,6 +6177,9 @@ extern void vtv_save_class_info                 (tree);\n extern void vtv_recover_class_info              (void);\n extern void vtv_build_vtable_verify_fndecl      (void);\n \n+/* In cp-cilkplus.c.  */\n+extern bool cpp_validate_cilk_plus_loop\t\t(tree);\n+\n /* In cp/cp-array-notations.c */\n extern tree expand_array_notation_exprs         (tree);\n bool cilkplus_an_triplet_types_ok_p             (location_t, tree, tree, tree,"}, {"sha": "27f10543b822e5cb0733df9008e10c8786e6d5bc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 467, "deletions": 152, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -233,6 +233,8 @@ static void cp_parser_initial_pragma\n static tree cp_literal_operator_id\n   (const char *);\n \n+static void cp_parser_cilk_simd\n+  (cp_parser *, cp_token *);\n static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n \n@@ -531,6 +533,8 @@ cp_debug_parser (FILE *file, cp_parser *parser)\n \t\t\t      parser->in_statement & IN_SWITCH_STMT);\n   cp_debug_print_flag (file, \"Parsing a structured OpenMP block\",\n \t\t\t      parser->in_statement & IN_OMP_BLOCK);\n+  cp_debug_print_flag (file, \"Parsing a Cilk Plus for loop\",\n+\t\t\t      parser->in_statement & IN_CILK_SIMD_FOR);\n   cp_debug_print_flag (file, \"Parsing a an OpenMP loop\",\n \t\t\t      parser->in_statement & IN_OMP_FOR);\n   cp_debug_print_flag (file, \"Parsing an if statement\",\n@@ -10558,6 +10562,9 @@ cp_parser_jump_statement (cp_parser* parser)\n \tcase IN_OMP_FOR:\n \t  error_at (token->location, \"break statement used with OpenMP for loop\");\n \t  break;\n+\tcase IN_CILK_SIMD_FOR:\n+\t  error_at (token->location, \"break statement used with Cilk Plus for loop\");\n+\t  break;\n \t}\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n@@ -10568,6 +10575,10 @@ cp_parser_jump_statement (cp_parser* parser)\n \tcase 0:\n \t  error_at (token->location, \"continue statement not within a loop\");\n \t  break;\n+\tcase IN_CILK_SIMD_FOR:\n+\t  error_at (token->location,\n+\t\t    \"continue statement within %<#pragma simd%> loop body\");\n+\t  /* Fall through.  */\n \tcase IN_ITERATION_STMT:\n \tcase IN_OMP_FOR:\n \t  statement = finish_continue_stmt ();\n@@ -28591,7 +28602,7 @@ cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n /* Helper function, to parse omp for increment expression.  */\n \n static tree\n-cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n+cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n {\n   tree cond = cp_parser_binary_expression (parser, false, true,\n \t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n@@ -28609,6 +28620,10 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n     case LT_EXPR:\n     case LE_EXPR:\n       break;\n+    case NE_EXPR:\n+      if (code == CILK_SIMD)\n+\tbreak;\n+      /* Fall through: OpenMP disallows NE_EXPR.  */\n     default:\n       return error_mark_node;\n     }\n@@ -28718,6 +28733,186 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n   return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n }\n \n+/* Parse the initialization statement of either an OpenMP for loop or\n+   a Cilk Plus for loop.\n+\n+   PARSING_OPENMP is true if parsing OpenMP, or false if parsing Cilk\n+   Plus.\n+\n+   Return true if the resulting construct should have an\n+   OMP_CLAUSE_PRIVATE added to it.  */\n+\n+static bool\n+cp_parser_omp_for_loop_init (cp_parser *parser,\n+\t\t\t     bool parsing_openmp,\n+\t\t\t     tree &this_pre_body,\n+\t\t\t     vec<tree, va_gc> *for_block,\n+\t\t\t     tree &init,\n+\t\t\t     tree &decl,\n+\t\t\t     tree &real_decl)\n+{\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    return false;\n+\n+  bool add_private_clause = false;\n+\n+  /* See 2.5.1 (in OpenMP 3.0, similar wording is in 2.5 standard too):\n+\n+     init-expr:\n+     var = lb\n+     integer-type var = lb\n+     random-access-iterator-type var = lb\n+     pointer-type var = lb\n+  */\n+  cp_decl_specifier_seq type_specifiers;\n+\n+  /* First, try to parse as an initialized declaration.  See\n+     cp_parser_condition, from whence the bulk of this is copied.  */\n+\n+  cp_parser_parse_tentatively (parser);\n+  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,\n+\t\t\t\t/*is_trailing_return=*/false,\n+\t\t\t\t&type_specifiers);\n+  if (cp_parser_parse_definitely (parser))\n+    {\n+      /* If parsing a type specifier seq succeeded, then this\n+\t MUST be a initialized declaration.  */\n+      tree asm_specification, attributes;\n+      cp_declarator *declarator;\n+\n+      declarator = cp_parser_declarator (parser,\n+\t\t\t\t\t CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t /*parenthesized_p=*/NULL,\n+\t\t\t\t\t /*member_p=*/false);\n+      attributes = cp_parser_attributes_opt (parser);\n+      asm_specification = cp_parser_asm_specification_opt (parser);\n+\n+      if (declarator == cp_error_declarator) \n+\tcp_parser_skip_to_end_of_statement (parser);\n+\n+      else \n+\t{\n+\t  tree pushed_scope, auto_node;\n+\n+\t  decl = start_decl (declarator, &type_specifiers,\n+\t\t\t     SD_INITIALIZED, attributes,\n+\t\t\t     /*prefix_attributes=*/NULL_TREE,\n+\t\t\t     &pushed_scope);\n+\n+\t  auto_node = type_uses_auto (TREE_TYPE (decl));\n+\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t    {\n+\t      if (cp_lexer_next_token_is (parser->lexer, \n+\t\t\t\t\t  CPP_OPEN_PAREN))\n+\t\t{\n+\t\t  if (parsing_openmp)\n+\t\t    error (\"parenthesized initialization is not allowed in \"\n+\t\t\t   \"OpenMP %<for%> loop\");\n+\t\t  else\n+\t\t    error (\"parenthesized initialization is \"\n+\t\t\t   \"not allowed in for-loop\");\n+\t\t}\n+\t      else\n+\t\t/* Trigger an error.  */\n+\t\tcp_parser_require (parser, CPP_EQ, RT_EQ);\n+\n+\t      init = error_mark_node;\n+\t      cp_parser_skip_to_end_of_statement (parser);\n+\t    }\n+\t  else if (CLASS_TYPE_P (TREE_TYPE (decl))\n+\t\t   || type_dependent_expression_p (decl)\n+\t\t   || auto_node)\n+\t    {\n+\t      bool is_direct_init, is_non_constant_init;\n+\n+\t      init = cp_parser_initializer (parser,\n+\t\t\t\t\t    &is_direct_init,\n+\t\t\t\t\t    &is_non_constant_init);\n+\n+\t      if (auto_node)\n+\t\t{\n+\t\t  TREE_TYPE (decl)\n+\t\t    = do_auto_deduction (TREE_TYPE (decl), init,\n+\t\t\t\t\t auto_node);\n+\n+\t\t  if (!CLASS_TYPE_P (TREE_TYPE (decl))\n+\t\t      && !type_dependent_expression_p (decl))\n+\t\t    goto non_class;\n+\t\t}\n+\t\t      \n+\t      cp_finish_decl (decl, init, !is_non_constant_init,\n+\t\t\t      asm_specification,\n+\t\t\t      LOOKUP_ONLYCONVERTING);\n+\t      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t\t{\n+\t\t  vec_safe_push (for_block, this_pre_body);\n+\t\t  init = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\tinit = pop_stmt_list (this_pre_body);\n+\t      this_pre_body = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Consume '='.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      init = cp_parser_assignment_expression (parser, false, NULL);\n+\n+\t    non_class:\n+\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n+\t\tinit = error_mark_node;\n+\t      else\n+\t\tcp_finish_decl (decl, NULL_TREE,\n+\t\t\t\t/*init_const_expr_p=*/false,\n+\t\t\t\tasm_specification,\n+\t\t\t\tLOOKUP_ONLYCONVERTING);\n+\t    }\n+\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n+\t}\n+    }\n+  else \n+    {\n+      cp_id_kind idk;\n+      /* If parsing a type specifier sequence failed, then\n+\t this MUST be a simple expression.  */\n+      cp_parser_parse_tentatively (parser);\n+      decl = cp_parser_primary_expression (parser, false, false,\n+\t\t\t\t\t   false, &idk);\n+      if (!cp_parser_error_occurred (parser)\n+\t  && decl\n+\t  && DECL_P (decl)\n+\t  && CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t{\n+\t  tree rhs;\n+\n+\t  cp_parser_parse_definitely (parser);\n+\t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n+\t  rhs = cp_parser_assignment_expression (parser, false, NULL);\n+\t  finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),\n+\t\t\t\t\t\t decl, NOP_EXPR,\n+\t\t\t\t\t\t rhs,\n+\t\t\t\t\t\t tf_warning_or_error));\n+\t  add_private_clause = true;\n+\t}\n+      else\n+\t{\n+\t  decl = NULL;\n+\t  cp_parser_abort_tentative_parse (parser);\n+\t  init = cp_parser_expression (parser, false, NULL);\n+\t  if (init)\n+\t    {\n+\t      if (TREE_CODE (init) == MODIFY_EXPR\n+\t\t  || TREE_CODE (init) == MODOP_EXPR)\n+\t\treal_decl = TREE_OPERAND (init, 0);\n+\t    }\n+\t}\n+    }\n+  return add_private_clause;\n+}\n+\n /* Parse the restricted form of the for statement allowed by OpenMP.  */\n \n static tree\n@@ -28763,157 +28958,13 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n       init = decl = real_decl = NULL;\n       this_pre_body = push_stmt_list ();\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t{\n-\t  /* See 2.5.1 (in OpenMP 3.0, similar wording is in 2.5 standard too):\n-\n-\t     init-expr:\n-\t               var = lb\n-\t\t       integer-type var = lb\n-\t\t       random-access-iterator-type var = lb\n-\t\t       pointer-type var = lb\n-\t  */\n-\t  cp_decl_specifier_seq type_specifiers;\n-\n-\t  /* First, try to parse as an initialized declaration.  See\n-\t     cp_parser_condition, from whence the bulk of this is copied.  */\n \n-\t  cp_parser_parse_tentatively (parser);\n-\t  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,\n-\t\t\t\t\t/*is_trailing_return=*/false,\n-\t\t\t\t\t&type_specifiers);\n-\t  if (cp_parser_parse_definitely (parser))\n-\t    {\n-\t      /* If parsing a type specifier seq succeeded, then this\n-\t\t MUST be a initialized declaration.  */\n-\t      tree asm_specification, attributes;\n-\t      cp_declarator *declarator;\n+      add_private_clause\n+\t|= cp_parser_omp_for_loop_init (parser,\n+\t\t\t\t\t/*parsing_openmp=*/code != CILK_SIMD,\n+\t\t\t\t\tthis_pre_body, for_block,\n+\t\t\t\t\tinit, decl, real_decl);\n \n-\t      declarator = cp_parser_declarator (parser,\n-\t\t\t\t\t\t CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n-\t\t\t\t\t\t /*parenthesized_p=*/NULL,\n-\t\t\t\t\t\t /*member_p=*/false);\n-\t      attributes = cp_parser_attributes_opt (parser);\n-\t      asm_specification = cp_parser_asm_specification_opt (parser);\n-\n-\t      if (declarator == cp_error_declarator) \n-\t\tcp_parser_skip_to_end_of_statement (parser);\n-\n-\t      else \n-\t\t{\n-\t\t  tree pushed_scope, auto_node;\n-\n-\t\t  decl = start_decl (declarator, &type_specifiers,\n-\t\t\t\t     SD_INITIALIZED, attributes,\n-\t\t\t\t     /*prefix_attributes=*/NULL_TREE,\n-\t\t\t\t     &pushed_scope);\n-\n-\t\t  auto_node = type_uses_auto (TREE_TYPE (decl));\n-\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n-\t\t    {\n-\t\t      if (cp_lexer_next_token_is (parser->lexer, \n-\t\t\t\t\t\t  CPP_OPEN_PAREN))\n-\t\t\terror (\"parenthesized initialization is not allowed in \"\n-\t\t\t       \"OpenMP %<for%> loop\");\n-\t\t      else\n-\t\t\t/* Trigger an error.  */\n-\t\t\tcp_parser_require (parser, CPP_EQ, RT_EQ);\n-\n-\t\t      init = error_mark_node;\n-\t\t      cp_parser_skip_to_end_of_statement (parser);\n-\t\t    }\n-\t\t  else if (CLASS_TYPE_P (TREE_TYPE (decl))\n-\t\t\t   || type_dependent_expression_p (decl)\n-\t\t\t   || auto_node)\n-\t\t    {\n-\t\t      bool is_direct_init, is_non_constant_init;\n-\n-\t\t      init = cp_parser_initializer (parser,\n-\t\t\t\t\t\t    &is_direct_init,\n-\t\t\t\t\t\t    &is_non_constant_init);\n-\n-\t\t      if (auto_node)\n-\t\t\t{\n-\t\t\t  TREE_TYPE (decl)\n-\t\t\t    = do_auto_deduction (TREE_TYPE (decl), init,\n-\t\t\t\t\t\t auto_node);\n-\n-\t\t\t  if (!CLASS_TYPE_P (TREE_TYPE (decl))\n-\t\t\t      && !type_dependent_expression_p (decl))\n-\t\t\t    goto non_class;\n-\t\t\t}\n-\t\t      \n-\t\t      cp_finish_decl (decl, init, !is_non_constant_init,\n-\t\t\t\t      asm_specification,\n-\t\t\t\t      LOOKUP_ONLYCONVERTING);\n-\t\t      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n-\t\t\t{\n-\t\t\t  vec_safe_push (for_block, this_pre_body);\n-\t\t\t  init = NULL_TREE;\n-\t\t\t}\n-\t\t      else\n-\t\t\tinit = pop_stmt_list (this_pre_body);\n-\t\t      this_pre_body = NULL_TREE;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Consume '='.  */\n-\t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t      init = cp_parser_assignment_expression (parser, false, NULL);\n-\n-\t\t    non_class:\n-\t\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n-\t\t\tinit = error_mark_node;\n-\t\t      else\n-\t\t\tcp_finish_decl (decl, NULL_TREE,\n-\t\t\t\t\t/*init_const_expr_p=*/false,\n-\t\t\t\t\tasm_specification,\n-\t\t\t\t\tLOOKUP_ONLYCONVERTING);\n-\t\t    }\n-\n-\t\t  if (pushed_scope)\n-\t\t    pop_scope (pushed_scope);\n-\t\t}\n-\t    }\n-\t  else \n-\t    {\n-\t      cp_id_kind idk;\n-\t      /* If parsing a type specifier sequence failed, then\n-\t\t this MUST be a simple expression.  */\n-\t      cp_parser_parse_tentatively (parser);\n-\t      decl = cp_parser_primary_expression (parser, false, false,\n-\t\t\t\t\t\t   false, &idk);\n-\t      if (!cp_parser_error_occurred (parser)\n-\t\t  && decl\n-\t\t  && DECL_P (decl)\n-\t\t  && CLASS_TYPE_P (TREE_TYPE (decl)))\n-\t\t{\n-\t\t  tree rhs;\n-\n-\t\t  cp_parser_parse_definitely (parser);\n-\t\t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n-\t\t  rhs = cp_parser_assignment_expression (parser, false, NULL);\n-\t\t  finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),\n-\t\t\t\t\t\t\t decl, NOP_EXPR,\n-\t\t\t\t\t\t\t rhs,\n-\t\t\t\t\t\t\t tf_warning_or_error));\n-\t\t  add_private_clause = true;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  decl = NULL;\n-\t\t  cp_parser_abort_tentative_parse (parser);\n-\t\t  init = cp_parser_expression (parser, false, NULL);\n-\t\t  if (init)\n-\t\t    {\n-\t\t      if (TREE_CODE (init) == MODIFY_EXPR\n-\t\t\t  || TREE_CODE (init) == MODOP_EXPR)\n-\t\t\treal_decl = TREE_OPERAND (init, 0);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       if (this_pre_body)\n \t{\n@@ -29002,7 +29053,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n       cond = NULL;\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\tcond = cp_parser_omp_for_cond (parser, decl);\n+\tcond = cp_parser_omp_for_cond (parser, decl, code);\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n       incr = NULL;\n@@ -29072,7 +29123,10 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n   /* Note that we saved the original contents of this flag when we entered\n      the structured block, and so we don't need to re-save it here.  */\n-  parser->in_statement = IN_OMP_FOR;\n+  if (code == CILK_SIMD)\n+    parser->in_statement = IN_CILK_SIMD_FOR;\n+  else\n+    parser->in_statement = IN_OMP_FOR;\n \n   /* Note that the grammar doesn't call for a structured block here,\n      though the loop as a whole is a structured block.  */\n@@ -31127,6 +31181,16 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \treturn true;\n       }\n \n+    case PRAGMA_CILK_SIMD:\n+      if (context == pragma_external)\n+\t{\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma simd%> must be inside a function\");\n+\t  break;\n+\t}\n+      cp_parser_cilk_simd (parser, pragma_tok);\n+      return true;\n+\n     default:\n       gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n       c_invoke_pragma_handler (id);\n@@ -31192,6 +31256,257 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n+/* Parses the Cilk Plus #pragma simd vectorlength clause:\n+   Syntax:\n+   vectorlength ( constant-expression )  */\n+\n+static tree\n+cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses)\n+{\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+  tree expr;\n+  /* The vectorlength clause behaves exactly like OpenMP's safelen\n+     clause.  Thus, vectorlength is represented as OMP 4.0\n+     safelen.  */\n+  check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\", loc);\n+  \n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return error_mark_node;\n+  \n+  expr = cp_parser_constant_expression (parser, false, NULL);\n+  expr = maybe_constant_value (expr);\n+\n+  if (TREE_CONSTANT (expr)\n+\t   && exact_log2 (TREE_INT_CST_LOW (expr)) == -1)\n+    error_at (loc, \"vectorlength must be a power of 2\");\n+  else if (expr != error_mark_node)\n+    {\n+      tree c = build_omp_clause (loc, OMP_CLAUSE_SAFELEN);\n+      OMP_CLAUSE_SAFELEN_EXPR (c) = expr;\n+      OMP_CLAUSE_CHAIN (c) = clauses;\n+      clauses = c;\n+    }\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    return error_mark_node;\n+  return clauses;\n+}\n+\n+/* Handles the Cilk Plus #pragma simd linear clause.\n+   Syntax:\n+   linear ( simd-linear-variable-list )\n+\n+   simd-linear-variable-list:\n+     simd-linear-variable\n+     simd-linear-variable-list , simd-linear-variable\n+\n+   simd-linear-variable:\n+     id-expression\n+     id-expression : simd-linear-step\n+\n+   simd-linear-step:\n+   conditional-expression */\n+\n+static tree\n+cp_parser_cilk_simd_linear (cp_parser *parser, tree clauses)\n+{\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return clauses;\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_error (parser, \"expected identifier\");\n+      cp_parser_skip_to_closing_parenthesis (parser, false, false, true);\n+      return error_mark_node;\n+    }\n+\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+  parser->colon_corrects_to_scope_p = false;\n+  while (1)\n+    {\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t{\n+\t  cp_parser_error (parser, \"expected variable-name\");\n+\t  clauses = error_mark_node;\n+\t  break;\n+\t}\n+\n+      tree var_name = cp_parser_id_expression (parser, false, true, NULL,\n+\t\t\t\t\t       false, false);\n+      tree decl = cp_parser_lookup_name_simple (parser, var_name,\n+\t\t\t\t\t\ttoken->location);\n+      if (decl == error_mark_node)\n+\t{\n+\t  cp_parser_name_lookup_error (parser, var_name, decl, NLE_NULL,\n+\t\t\t\t       token->location);\n+\t  clauses = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  tree e = NULL_TREE;\n+\t  tree step_size = integer_one_node;\n+\n+\t  /* If present, parse the linear step.  Otherwise, assume the default\n+\t     value of 1.  */\n+\t  if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\n+\t      e = cp_parser_assignment_expression (parser, false, NULL);\n+\t      e = maybe_constant_value (e);\n+\n+\t      if (e == error_mark_node)\n+\t\t{\n+\t\t  /* If an error has occurred,  then the whole pragma is\n+\t\t     considered ill-formed.  Thus, no reason to keep\n+\t\t     parsing.  */\n+\t\t  clauses = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      else if (type_dependent_expression_p (e)\n+\t\t       || value_dependent_expression_p (e)\n+\t\t       || (TREE_TYPE (e)\n+\t\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (e))\n+\t\t\t   && (TREE_CONSTANT (e)\n+\t\t\t       || DECL_P (e))))\n+\t\tstep_size = e;\n+\t      else\n+\t\tcp_parser_error (parser,\n+\t\t\t\t \"step size must be an integer constant \"\n+\t\t\t\t \"expression or an integer variable\");\n+\t    }\n+\n+\t  /* Use the OMP_CLAUSE_LINEAR,  which has the same semantics.  */\n+\t  tree l = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n+\t  OMP_CLAUSE_DECL (l) = decl;\n+\t  OMP_CLAUSE_LINEAR_STEP (l) = step_size;\n+\t  OMP_CLAUSE_CHAIN (l) = clauses;\n+\t  clauses = l;\n+\t}\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\tbreak;\n+      else\n+\t{\n+\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t    \"expected %<,%> or %<)%> after %qE\", decl);\n+\t  clauses = error_mark_node;\n+\t  break;\n+\t}\n+    }\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+  cp_parser_skip_to_closing_parenthesis (parser, false, false, true);\n+  return clauses;\n+}\n+\n+/* Returns the name of the next clause.  If the clause is not\n+   recognized, then PRAGMA_CILK_CLAUSE_NONE is returned and the next\n+   token is not consumed.  Otherwise, the appropriate enum from the\n+   pragma_simd_clause is returned and the token is consumed.  */\n+\n+static pragma_cilk_clause\n+cp_parser_cilk_simd_clause_name (cp_parser *parser)\n+{\n+  pragma_cilk_clause clause_type;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->keyword == RID_PRIVATE)\n+    clause_type = PRAGMA_CILK_CLAUSE_PRIVATE;\n+  else if (!token->u.value || token->type != CPP_NAME)\n+    return PRAGMA_CILK_CLAUSE_NONE;\n+  else if (!strcmp (IDENTIFIER_POINTER (token->u.value), \"vectorlength\"))\n+    clause_type = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n+  else if (!strcmp (IDENTIFIER_POINTER (token->u.value), \"linear\"))\n+    clause_type = PRAGMA_CILK_CLAUSE_LINEAR;\n+  else if (!strcmp (IDENTIFIER_POINTER (token->u.value), \"firstprivate\"))\n+    clause_type = PRAGMA_CILK_CLAUSE_FIRSTPRIVATE;\n+  else if (!strcmp (IDENTIFIER_POINTER (token->u.value), \"lastprivate\"))\n+    clause_type = PRAGMA_CILK_CLAUSE_LASTPRIVATE;\n+  else if (!strcmp (IDENTIFIER_POINTER (token->u.value), \"reduction\"))\n+    clause_type = PRAGMA_CILK_CLAUSE_REDUCTION;\n+  else\n+    return PRAGMA_CILK_CLAUSE_NONE;\n+\n+  cp_lexer_consume_token (parser->lexer);\n+  return clause_type;\n+}\n+\n+/* Parses all the #pragma simd clauses.  Returns a list of clauses found.  */\n+\n+static tree\n+cp_parser_cilk_simd_all_clauses (cp_parser *parser, cp_token *pragma_token)\n+{\n+  tree clauses = NULL_TREE;\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n+\t && clauses != error_mark_node)\n+    {\n+      pragma_cilk_clause c_kind;\n+      c_kind = cp_parser_cilk_simd_clause_name (parser);\n+      if (c_kind == PRAGMA_CILK_CLAUSE_VECTORLENGTH)\n+\tclauses = cp_parser_cilk_simd_vectorlength (parser, clauses);\n+      else if (c_kind == PRAGMA_CILK_CLAUSE_LINEAR)\n+\tclauses = cp_parser_cilk_simd_linear (parser, clauses);\n+      else if (c_kind == PRAGMA_CILK_CLAUSE_PRIVATE)\n+\t/* Use the OpenMP 4.0 equivalent function.  */\n+\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE, clauses);\n+      else if (c_kind == PRAGMA_CILK_CLAUSE_FIRSTPRIVATE)\n+\t/* Use the OpenMP 4.0 equivalent function.  */\n+\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,\n+\t\t\t\t\t  clauses);\n+      else if (c_kind == PRAGMA_CILK_CLAUSE_LASTPRIVATE)\n+\t/* Use the OMP 4.0 equivalent function.  */\n+\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,\n+\t\t\t\t\t  clauses);\n+      else if (c_kind == PRAGMA_CILK_CLAUSE_REDUCTION)\n+\t/* Use the OMP 4.0 equivalent function.  */\n+\tclauses = cp_parser_omp_clause_reduction (parser, clauses);\n+      else\n+\t{\n+\t  clauses = error_mark_node;\n+\t  cp_parser_error (parser, \"expected %<#pragma simd%> clause\");\n+\t  break;\n+\t}\n+    }\n+\n+  cp_parser_skip_to_pragma_eol (parser, pragma_token);\n+\n+  if (clauses == error_mark_node)\n+    return error_mark_node;\n+  else\n+    return c_finish_cilk_clauses (clauses);\n+}\n+\n+/* Main entry-point for parsing Cilk Plus <#pragma simd> for loops.  */\n+\n+static void\n+cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n+{\n+  tree clauses = cp_parser_cilk_simd_all_clauses (parser, pragma_token);\n+\n+  if (clauses == error_mark_node)\n+    return;\n+  \n+  if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_FOR))\n+    {\n+      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\"for statement expected\");\n+      return;\n+    }\n+\n+  tree sb = begin_omp_structured_block ();\n+  int save = cp_parser_begin_omp_structured_block (parser);\n+  tree ret = cp_parser_omp_for_loop (parser, CILK_SIMD, clauses, NULL);\n+  if (ret)\n+    cpp_validate_cilk_plus_loop (OMP_FOR_BODY (ret));\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_structured_block (sb));\n+  return;\n+}\n+\n /* Create an identifier for a generic parameter type (a synthesized\n    template parameter implied by `auto' or a concept identifier). */\n "}, {"sha": "edd4e6e8b98c85a5d7fc40b5e98242e7b0fcc234", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -300,6 +300,7 @@ typedef struct GTY(()) cp_parser {\n #define IN_OMP_BLOCK\t\t4\n #define IN_OMP_FOR\t\t8\n #define IN_IF_STMT             16\n+#define IN_CILK_SIMD_FOR       32\n   unsigned char in_statement;\n \n   /* TRUE if we are presently parsing the body of a switch statement."}, {"sha": "3bc8ccb0ee32da54f05b55eed74a3e9aaab01dd2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -13566,6 +13566,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case OMP_FOR:\n     case OMP_SIMD:\n+    case CILK_SIMD:\n     case OMP_DISTRIBUTE:\n       {\n \ttree clauses, body, pre_body;"}, {"sha": "5c4fdfa0162ed12d086d9c29cee93f64b27e06dc", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -125,7 +125,7 @@ cxx_readonly_error (tree arg, enum lvalue_use errstring)\n                              \"read-only reference %qD\"),\n                           TREE_OPERAND (arg, 0));\n   else\n-    readonly_error (arg, errstring);\n+    readonly_error (input_location, arg, errstring);\n }\n \n \f"}, {"sha": "b20d11ae3d48e99ae036abb35b2dca0689a95bc2", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1118,6 +1118,8 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  kind = \" simd\";\n \t  break;\n+\tcase GF_OMP_FOR_KIND_CILKSIMD:\n+\t  kind = \" cilksimd\";\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  kind = \" distribute\";\n \t  break;\n@@ -1149,6 +1151,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  pp_string (buffer, \"#pragma omp simd\");\n \t  break;\n+\tcase GF_OMP_FOR_KIND_CILKSIMD:\n+\t  pp_string (buffer, \"#pragma simd\");\n+\t  break;\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  pp_string (buffer, \"#pragma omp distribute\");\n \t  break;"}, {"sha": "c7cb9f75d18c83f5949d67ef3bba0ac081baada8", "filename": "gcc/gimple.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -102,12 +102,13 @@ enum gf_mask {\n     GF_CALL_ALLOCA_FOR_VAR\t= 1 << 5,\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n-    GF_OMP_FOR_KIND_MASK\t= 3 << 0,\n+    GF_OMP_FOR_KIND_MASK\t= 7,\n     GF_OMP_FOR_KIND_FOR\t\t= 0 << 0,\n-    GF_OMP_FOR_KIND_SIMD\t= 1 << 0,\n-    GF_OMP_FOR_KIND_DISTRIBUTE\t= 2 << 0,\n-    GF_OMP_FOR_COMBINED\t\t= 1 << 2,\n-    GF_OMP_FOR_COMBINED_INTO\t= 1 << 3,\n+    GF_OMP_FOR_KIND_SIMD\t= 2 << 0,\n+    GF_OMP_FOR_KIND_CILKSIMD\t= 3 << 0,\n+    GF_OMP_FOR_KIND_DISTRIBUTE\t= 1 << 2,\n+    GF_OMP_FOR_COMBINED\t\t= 1 << 3,\n+    GF_OMP_FOR_COMBINED_INTO\t= 1 << 4,\n     GF_OMP_TARGET_KIND_MASK\t= 3 << 0,\n     GF_OMP_TARGET_KIND_REGION\t= 0 << 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1 << 0,"}, {"sha": "bb50e250213f71031d4c0711198cdf2faca8ca4d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -4189,6 +4189,7 @@ is_gimple_stmt (tree t)\n     case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SIMD:\n+    case CILK_SIMD:\n     case OMP_DISTRIBUTE:\n     case OMP_SECTIONS:\n     case OMP_SECTION:\n@@ -6406,7 +6407,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n-  simd = TREE_CODE (for_stmt) == OMP_SIMD;\n+  simd = TREE_CODE (for_stmt) == OMP_SIMD\n+    || TREE_CODE (for_stmt) == CILK_SIMD;\n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n \t\t\t     simd ? ORT_SIMD : ORT_WORKSHARE);\n \n@@ -6543,15 +6545,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t{\n \tcase PREINCREMENT_EXPR:\n \tcase POSTINCREMENT_EXPR:\n-\t  if (orig_for_stmt != for_stmt)\n+\t  {\n+\t    tree decl = TREE_OPERAND (t, 0);\n+\t    // c_omp_for_incr_canonicalize_ptr() should have been\n+\t    // called to massage things appropriately.\n+\t    gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n+\n+\t    if (orig_for_stmt != for_stmt)\n+\t      break;\n+\t    t = build_int_cst (TREE_TYPE (decl), 1);\n+\t    if (c)\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = t;\n+\t    t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n+\t    t = build2 (MODIFY_EXPR, TREE_TYPE (var), var, t);\n+\t    TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n \t    break;\n-\t  t = build_int_cst (TREE_TYPE (decl), 1);\n-\t  if (c)\n-\t    OMP_CLAUSE_LINEAR_STEP (c) = t;\n-\t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (var), var, t);\n-\t  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n-\t  break;\n+\t  }\n \n \tcase PREDECREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n@@ -6661,6 +6670,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     {\n     case OMP_FOR: kind = GF_OMP_FOR_KIND_FOR; break;\n     case OMP_SIMD: kind = GF_OMP_FOR_KIND_SIMD; break;\n+    case CILK_SIMD: kind = GF_OMP_FOR_KIND_CILKSIMD; break;\n     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n     default:\n       gcc_unreachable ();\n@@ -7730,6 +7740,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase OMP_FOR:\n \tcase OMP_SIMD:\n+\tcase CILK_SIMD:\n \tcase OMP_DISTRIBUTE:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;"}, {"sha": "e2fc53c4b83aa6cfe4cfe87fff9e62471d106482", "filename": "gcc/omp-low.c", "status": "modified", "additions": 85, "deletions": 31, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -285,7 +285,7 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n   int i;\n   struct omp_for_data_loop dummy_loop;\n   location_t loc = gimple_location (for_stmt);\n-  bool simd = gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_SIMD;\n+  bool simd = gimple_omp_for_kind (for_stmt) & GF_OMP_FOR_KIND_SIMD;\n   bool distribute = gimple_omp_for_kind (for_stmt)\n \t\t    == GF_OMP_FOR_KIND_DISTRIBUTE;\n \n@@ -377,6 +377,10 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \tcase LT_EXPR:\n \tcase GT_EXPR:\n \t  break;\n+\tcase NE_EXPR:\n+\t  gcc_assert (gimple_omp_for_kind (for_stmt)\n+\t\t      == GF_OMP_FOR_KIND_CILKSIMD);\n+\t  break;\n \tcase LE_EXPR:\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->n2)))\n \t    loop->n2 = fold_build_pointer_plus_hwi_loc (loc, loop->n2, 1);\n@@ -1003,7 +1007,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n       x = build_receiver_ref (var, by_ref, ctx);\n     }\n   else if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t   && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t   && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD)\n     {\n       /* #pragma omp simd isn't a worksharing construct, and can reference even\n \t private vars in its linear etc. clauses.  */\n@@ -2230,7 +2234,7 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n   if (ctx != NULL)\n     {\n       if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD)\n \t{\n \t  error_at (gimple_location (stmt),\n \t\t    \"OpenMP constructs may not be nested inside simd region\");\n@@ -2253,7 +2257,7 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_OMP_FOR:\n-      if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_SIMD)\n+      if (gimple_omp_for_kind (stmt) & GF_OMP_FOR_KIND_SIMD)\n \treturn true;\n       if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t{\n@@ -2536,6 +2540,23 @@ scan_omp_1_op (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* Return true if FNDECL is a setjmp or a longjmp.  */\n+\n+static bool\n+setjmp_or_longjmp_p (const_tree fndecl)\n+{\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_SETJMP\n+\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_LONGJMP))\n+    return true;\n+\n+  tree declname = DECL_NAME (fndecl);\n+  if (!declname)\n+    return false;\n+  const char *name = IDENTIFIER_POINTER (declname);\n+  return !strcmp (name, \"setjmp\") || !strcmp (name, \"longjmp\");\n+}\n+\n \n /* Helper function for scan_omp.\n \n@@ -2559,22 +2580,33 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   else if (is_gimple_call (stmt))\n     {\n       tree fndecl = gimple_call_fndecl (stmt);\n-      if (fndecl\n-\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\tswitch (DECL_FUNCTION_CODE (fndecl))\n-\t  {\n-\t  case BUILT_IN_GOMP_BARRIER:\n-\t  case BUILT_IN_GOMP_CANCEL:\n-\t  case BUILT_IN_GOMP_CANCELLATION_POINT:\n-\t  case BUILT_IN_GOMP_TASKYIELD:\n-\t  case BUILT_IN_GOMP_TASKWAIT:\n-\t  case BUILT_IN_GOMP_TASKGROUP_START:\n-\t  case BUILT_IN_GOMP_TASKGROUP_END:\n-\t    remove = !check_omp_nesting_restrictions (stmt, ctx);\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+      if (fndecl)\n+\t{\n+\t  if (setjmp_or_longjmp_p (fndecl)\n+\t      && ctx\n+\t      && gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD)\n+\t    {\n+\t      remove = true;\n+\t      error_at (gimple_location (stmt),\n+\t\t\t\"setjmp/longjmp inside simd construct\");\n+\t    }\n+\t  else if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t    switch (DECL_FUNCTION_CODE (fndecl))\n+\t      {\n+\t      case BUILT_IN_GOMP_BARRIER:\n+\t      case BUILT_IN_GOMP_CANCEL:\n+\t      case BUILT_IN_GOMP_CANCELLATION_POINT:\n+\t      case BUILT_IN_GOMP_TASKYIELD:\n+\t      case BUILT_IN_GOMP_TASKWAIT:\n+\t      case BUILT_IN_GOMP_TASKGROUP_START:\n+\t      case BUILT_IN_GOMP_TASKGROUP_END:\n+\t\tremove = !check_omp_nesting_restrictions (stmt, ctx);\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t}\n     }\n   if (remove)\n     {\n@@ -2967,7 +2999,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   bool reduction_omp_orig_ref = false;\n   int pass;\n   bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD);\n+\t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD);\n   int max_vf = 0;\n   tree lane = NULL_TREE, idx = NULL_TREE;\n   tree ivar = NULL_TREE, lvar = NULL_TREE;\n@@ -3587,7 +3619,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       /* Don't add any barrier for #pragma omp simd or\n \t #pragma omp distribute.  */\n       if (gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n-\t  || gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_FOR)\n+\t  || gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_FOR)\n \tgimple_seq_add_stmt (ilist, build_omp_barrier (NULL_TREE));\n     }\n \n@@ -3666,7 +3698,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n     }\n \n   if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD)\n     {\n       simduid = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMDUID_);\n       if (simduid)\n@@ -3761,7 +3793,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \n   /* SIMD reductions are handled in lower_rec_input_clauses.  */\n   if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_KIND_SIMD)\n     return;\n \n   /* First see if there is exactly one reduction clause.  Use OMP_ATOMIC\n@@ -6794,7 +6826,7 @@ expand_omp_for (struct omp_region *region, gimple inner_stmt)\n        original loops from being detected.  Fix that up.  */\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n-  if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_SIMD)\n+  if (gimple_omp_for_kind (fd.for_stmt) & GF_OMP_FOR_KIND_SIMD)\n     expand_omp_simd (region, &fd);\n   else if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t   && !fd.have_ordered)\n@@ -8236,7 +8268,8 @@ execute_expand_omp (void)\n static bool\n gate_expand_omp (void)\n {\n-  return ((flag_openmp != 0 || flag_openmp_simd != 0) && !seen_error ());\n+  return ((flag_openmp != 0 || flag_openmp_simd != 0\n+\t   || flag_enable_cilkplus != 0) && !seen_error ());\n }\n \n namespace {\n@@ -10057,7 +10090,7 @@ execute_lower_omp (void)\n \n   /* This pass always runs, to provide PROP_gimple_lomp.\n      But there is nothing to do unless -fopenmp is given.  */\n-  if (flag_openmp == 0 && flag_openmp_simd == 0)\n+  if (flag_openmp == 0 && flag_openmp_simd == 0 && flag_enable_cilkplus == 0)\n     return 0;\n \n   all_contexts = splay_tree_new (splay_tree_compare_pointers, 0,\n@@ -10177,12 +10210,33 @@ diagnose_sb_0 (gimple_stmt_iterator *gsi_p,\n     error (\"invalid entry to OpenMP structured block\");\n #endif\n \n+  bool cilkplus_block = false;\n+  if (flag_enable_cilkplus)\n+    {\n+      if ((branch_ctx\n+\t   && gimple_code (branch_ctx) == GIMPLE_OMP_FOR\n+\t   && gimple_omp_for_kind (branch_ctx) == GF_OMP_FOR_KIND_CILKSIMD)\n+\t  || (gimple_code (label_ctx) == GIMPLE_OMP_FOR\n+\t      && gimple_omp_for_kind (label_ctx) == GF_OMP_FOR_KIND_CILKSIMD))\n+\tcilkplus_block = true;\n+    }\n+\n   /* If it's obvious we have an invalid entry, be specific about the error.  */\n   if (branch_ctx == NULL)\n-    error (\"invalid entry to OpenMP structured block\");\n+    {\n+      if (cilkplus_block)\n+\terror (\"invalid entry to Cilk Plus structured block\");\n+      else\n+\terror (\"invalid entry to OpenMP structured block\");\n+    }\n   else\n-    /* Otherwise, be vague and lazy, but efficient.  */\n-    error (\"invalid branch to/from an OpenMP structured block\");\n+    {\n+      /* Otherwise, be vague and lazy, but efficient.  */\n+      if (cilkplus_block)\n+\terror (\"invalid branch to/from a Cilk Plus structured block\");\n+      else\n+\terror (\"invalid branch to/from an OpenMP structured block\");\n+    }\n \n   gsi_replace (gsi_p, gimple_build_nop (), false);\n   return true;\n@@ -10486,7 +10540,7 @@ diagnose_omp_structured_block_errors (void)\n static bool\n gate_diagnose_omp_blocks (void)\n {\n-  return flag_openmp != 0;\n+  return flag_openmp || flag_enable_cilkplus;\n }\n \n namespace {"}, {"sha": "23928d4ceeeba3ca97ea96ba0b3db419028fd79f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1,3 +1,10 @@\n+2013-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-c++-common/cilk-plus/PS: New directory.\n+\t* g++.dg/cilk-plus/cilk-plus.exp: Run shared tests.\n+\t* g++.dg/dg.exp: Run Cilk Plus tests.\n+\t* gcc.dg/cilk-plus/cilk-plus.exp: Run shared tests.\n+\n 2013-11-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.dg/vmx/3b-15.c: Revise for little endian."}, {"sha": "9b10041d669ab9a92d052d46bc5a365d71aea52d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/body.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -fopenmp\" } */\n+\n+int *a, *b, c;\n+void *jmpbuf[10];\n+\n+void foo()\n+{\n+  int j;\n+\n+#pragma simd\n+  for (int i=0; i < 1000; ++i)\n+    {\n+      if (c == 6)\n+\t__builtin_setjmp (jmpbuf); /* { dg-error \"setjmp\" } */\n+      a[i] = b[i];\n+    }\n+\n+#pragma simd\n+  for (int i=0; i < 1000; ++i)\n+    {\n+      if (c==5)\n+\tbreak; /* { dg-error \"break statement \" } */\n+    }\n+\n+#pragma simd\n+  for (int i=0; i < 1000; ++i)\n+    {\n+#pragma omp for /* { dg-error \"OpenMP constructs may not\" } */\n+      for (j=0; j < 1000; ++j)\n+\ta[i] = b[i];\n+    }\n+}"}, {"sha": "27d117ec2f076f8a03177ef208dfead3b4b7f523", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Werror -Wunknown-pragmas -fcilkplus\" } */\n+\n+volatile int *a, *b;\n+\n+void foo()\n+{\n+  int i, j, k;\n+\n+#pragma simd assert /* { dg-error \"expected '#pragma simd' clause\" } */\n+  for (i=0; i < 100; ++i)\n+    a[i] = b[i];\n+\n+#pragma simd vectorlength /* { dg-error \"expected '\\\\('\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd vectorlength /* { dg-error \"expected '\\\\('\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd vectorlength(sizeof (a) == sizeof (float) ? 4 : 8)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd vectorlength(4,8) /* { dg-error \"expected '\\\\)'\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd vectorlength(i) /* { dg-error \"\\(vectorlength must be an integer\\|in a constant\\)\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(35) /* { dg-error \"expected identifier\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(blah) /* { dg-error \"'blah' \\(undeclared\\|has not been\\)\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(j, 36, k) /* { dg-error \"expected\" } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(i, j)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(i)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(i : 4)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(i : 2, j : 4, k)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(j : sizeof (a) == sizeof (float) ? 4 : 8)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+  // And now everyone in unison!\n+#pragma simd linear(j : 4) vectorlength(4)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(blah2, 36)\n+  /* { dg-error \"'blah2' \\(undeclared\\|has not been\\)\" \"undeclared\" { target *-*-* } 71 } */\n+  /* { dg-error \"expected\" \"expected\" { target *-*-* } 71 } */\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+\n+#pragma simd linear(j : k)\n+  for (int i=0; i < 1234; ++i)\n+    a[i] = b[j];\n+}"}, {"sha": "71589c2b1786fa1651993d8107e871510a3c6b6c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-original -fcilkplus\" } */\n+\n+volatile int *a, *b;\n+\n+void foo()\n+{\n+  int j, k;\n+\n+#pragma simd linear(j : 4, k) vectorlength(4)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[j];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"linear\\\\(j:4\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"linear\\\\(k:1\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"safelen\\\\(4\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "579b718a01c6932bda162ecfb57cf666b6026edc", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+#define N 1000\n+\n+int A[N], B[N], C[N];\n+int main (void)\n+{\n+#pragma simd private (B) linear(B:1) /* { dg-error \"more than one clause\" } */\n+  for (int ii = 0; ii < N; ii++)\n+    {\n+      A[ii] = B[ii] + C[ii];\n+    }\n+\n+#pragma simd private (B, C) linear(B:1) /* { dg-error \"more than one clause\" } */\n+  for (int ii = 0; ii < N; ii++)\n+    {\n+      A[ii] = B[ii] + C[ii];\n+    }\n+\n+#pragma simd private (B) linear(C:2, B:1) /* { dg-error \"more than one clause\" } */\n+  for (int ii = 0; ii < N; ii++)\n+    {\n+      A[ii] = B[ii] + C[ii];\n+    }\n+\n+#pragma simd reduction (+:B) linear(B:1) /* { dg-error \"more than one clause\" } */\n+  for (int ii = 0; ii < N; ii++)\n+    {\n+      A[ii] = B[ii] + C[ii];\n+    }\n+\n+#pragma simd reduction (+:B) linear(B) /* { dg-error \"more than one clause\" } */\n+  for (int ii = 0; ii < N; ii++)\n+    {\n+      A[ii] = B[ii] + C[ii];\n+    }\n+  return 0;\n+}"}, {"sha": "3b678952c7284ae8e2d73308197aa0c28b9a227a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+int *a, *b, *c;\n+int something;\n+\n+void foo()\n+{\n+  int i, j;\n+\n+  // Declaration and initialization is allowed.\n+#pragma simd\n+  for (int i=0; i < 1000; i++)\n+    a[i] = b[j];\n+\n+  // Empty initialization is not allowed.\n+#pragma simd\n+  for (; i < 5; ++i)\t\t// { dg-error \"expected iteration\" }\n+    a[i] = i;\n+\n+  // Empty condition is not allowed.\n+#pragma simd\n+  for (int i=0; ; ++i)\t\t/* { dg-error \"missing controlling\" } */\n+    a[i] = i;\n+\n+  // Empty increment is not allowed.\n+#pragma simd\n+  for (int i=0; i < 1234; )\t\t/* { dg-error \"missing increment\" } */\n+    a[i] = i*2;\n+\n+#pragma simd\n+  i = 5; /* { dg-error \"for statement expected\" } */\n+\n+  // Initialization variables must be either integral or pointer types.\n+  struct S {\n+    int i;\n+  };\n+#pragma simd\n+  for (struct S ss = { 0 }; ss.i <= 1000; ++ss.i) /* { dg-error \"invalid controlling\\|invalid type for iteration\\|invalid increment\" } */\n+    a[ss.i] = b[ss.i];\n+\n+  #pragma simd\n+  for (float f=0.0; f < 15.0; ++f) /* { dg-error \"invalid type\" } */\n+    a[(int)f] = (int) f;\n+\n+  // Pointers are OK.\n+  #pragma simd\n+  for (int *i=c; i < &c[100]; ++i)\n+    *a = '5';\n+\n+  // Condition of '==' is not allowed.\n+#pragma simd\n+  for (int i=j; i == 5; ++i) /* { dg-error \"invalid controlling predicate\" } */\n+    a[i] = b[i];\n+\n+  // The LHS or RHS of the condition must be the initialization variable.\n+#pragma simd\n+  for (int i=0; i+j < 1234; ++i) /* { dg-error \"invalid controlling predicate\" } */\n+    a[i] = b[i];  \n+\n+  // Likewise.\n+#pragma simd\n+  for (int i=0; 1234 < i + j; ++i) /* { dg-error \"invalid controlling predicate\" } */\n+    a[i] = b[i];  \n+\n+  // Likewise, this is ok.\n+#pragma simd\n+  for (int i=0; 1234 + j < i; ++i)\n+    a[i] = b[i];\n+\n+  // According to the CilkPlus forum, casts are not allowed, even if\n+  // they are no-ops.\n+#pragma simd\n+  for (int i=0; (char)i < 1234; ++i) /* { dg-error \"invalid controlling predicate\" } */\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=255; i != something; --i)\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=100; i != 5; i += something)\n+    a[i] = b[i];\n+\n+  // Increment must be on the induction variable.\n+#pragma simd\n+  for (int i=0; i < 100; j++) /* { dg-error \"invalid increment expression\" } */\n+    a[i] = b[i];\n+\n+  // Likewise.\n+#pragma simd\n+  for (int i=0; i < 100; j = i + 1) /* { dg-error \"invalid increment expression\" } */\n+    a[i] = b[i];\n+\n+  // Likewise.\n+#pragma simd\n+  for (int i=0; i < 100; i = j + 1) /* { dg-error \"invalid increment expression\" } */\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=0; i < 100; i = i + 5)\n+    a[i] = b[i];\n+\n+  // Only PLUS and MINUS increments are allowed.\n+#pragma simd\n+  for (int i=0; i < 100; i *= 5) /* { dg-error \"invalid increment expression\" } */\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=0; i < 100; i -= j)\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=0; i < 100; i = i + j)\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=0; i < 100; i = j + i)\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int i=0; i < 100; ++i, ++j) /* { dg-error \"invalid increment expression\" } */\n+    a[i] = b[i];\n+\n+#pragma simd\n+  for (int *point=0; point < b; ++point)\n+    *point = 555;\n+\n+#pragma simd\n+  for (int *point=0; point > b; --point)\n+    *point = 555;\n+}"}, {"sha": "86606275ac47101763f09c936dd7837094c8d893", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+#pragma simd\t\t/* { dg-error \"must be inside a function\" } */\n+\n+void foo()\n+{\n+}"}, {"sha": "2da8235f3194cdeb5f6fde11201f6b3238ca2d8d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+int *a, *c;\n+\n+void foo()\n+{\n+  int i, j;\n+\n+  // Pointers are OK.\n+  #pragma simd\n+  for (int *i=c; i < c; ++i)\n+    *a = '5';\n+}"}, {"sha": "d8cec84f149e8d2340b23420f389a557e5249f1e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+/* FIXME: This test has been xfailed until reductions are fixed.  */\n+\n+int argc = 1;\n+\n+/* This is a simple vectorization test.  It tests if reduction works\n+   and if it can vectorize the loop in func correctly. */\n+#define N 1000\n+\n+int func (int *p, int *q) {\n+    int x = 0;\n+#pragma simd reduction (+:x)\n+    for (int ii = 0; ii < N; ii++) { \n+\tx += (q[ii] + p[ii]);\n+    }\n+    return x; \n+\n+}\n+\n+int main ()\n+{\n+  int ii = 0, x;\n+  int Array[N], Array2[N];\n+\n+  for (ii = 0; ii < N; ii++)\n+    {\n+      Array[ii] = 5 + argc;\n+      Array2[ii] = argc;\n+    }\n+  x = func (Array, Array2);\n+\n+  if (x != N * 7)\n+    return 1;\n+  return 0;\n+}\n+"}, {"sha": "f5554f6b1aea0fb16e21b8e6f6c2cd4159bbd894", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+/* FIXME: This test has been xfailed until reductions are fixed.  */\n+\n+#include <stdio.h>\n+\n+#define ARRAY_SIZE  (256)\n+int a[ARRAY_SIZE];\n+\n+__attribute__((noinline))\n+int addit (int *arr, int N)\n+{\n+  int s=0;\n+#pragma simd reduction (+:s)\n+  for (int i = 0; i < N; i++)\n+    s += arr[i];\n+  return s;\n+}\n+\n+int main () {\n+  int i, s = 0, r = 0;\n+  for (i = 0; i < ARRAY_SIZE; i++)\n+    {\n+      a[i] = i;\n+    }\n+\n+  s = addit (a, ARRAY_SIZE);\n+\n+  for (i = 0; i < ARRAY_SIZE; i++) \n+    r += i;\n+\n+  if (s == r)\n+    return 0;\n+  return 1;\n+}"}, {"sha": "26822d633ffa4e8bd2b5e965a214db5346f5a4e3", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+/* FIXME: This test has been xfailed until reductions are fixed.  */\n+\n+#define N 256\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+#include <malloc.h>\n+\n+int\n+reduction_simd (int *a)\n+{\n+  int s = 0;\n+\n+#pragma simd reduction (+:s)\n+  for (int i = 0; i < N; i++)\n+    {\n+      s += a[i];\n+    }\n+\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int *a = (int *) malloc (N * sizeof (int));\n+  int i, s = (N - 1) * N / 2;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+    }\n+#if HAVE_IO\n+  printf (\"%d, %d\\n\", s, reduction_simd (a));\n+#endif\n+  if (s == reduction_simd (a))\n+    return 0;\n+  else\n+    return 1;\n+}"}, {"sha": "c8fe1c762bc3223ea04697c2ec2215e0944fbca9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/run-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus -O3\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 4\n+\n+float f1[] =  { 2.0, 3.0,  4.0,  5.0 };\n+float f2[] =  { 1.0, 6.0, -1.0, -2.0 };\n+float res[] = { 3.0, 9.0,  3.0,  3.0 };\n+\n+__attribute__((noinline))\n+void verify (float *sum)\n+{\n+  for (int i=0; i < N; ++i)\n+    if (sum[i] != res[i])\n+      abort ();\n+}\n+\n+int main()\n+{\n+  float sum[N];\n+#pragma simd\n+  for (int i=0; i < N; ++i)\n+    sum[i] = f1[i] + f2[i];\n+  verify (sum);\n+  return 0;\n+}"}, {"sha": "2c59de9b02d9297cdd6fe50f289df5524fd48b54", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/safelen.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-gimple -fcilkplus\" } */\n+\n+int *a, *b;\n+\n+void foo()\n+{\n+#pragma simd vectorlength(8)\n+  for (int i=0; i < 1000; ++i)\n+    a[i] = b[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"safelen\\\\(8\\\\)\" 1 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "9aa4a68290d56ee716705fadd80e81241145f935", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+volatile int *a, *b, N;\n+typedef int tint;\n+struct someclass {\n+  int a;\n+  char b;\n+  int *p;\n+};\n+\n+void foo()\n+{\n+#pragma simd vectorlength(4) vectorlength(8) /* { dg-error \"too many 'vectorlength' clauses\" } */\n+  for (int i=0; i < N; ++i)\n+    a[i] = b[i];\n+\n+#pragma simd vectorlength(3) /* { dg-error \"must be a power of 2\" } */\n+  for (int i=0; i < N; ++i)\n+    a[i] = b[i];\n+}"}, {"sha": "fa9246cc70491c61e640a64a9dc9543f8d895b52", "filename": "gcc/testsuite/g++.dg/cilk-plus/cilk-plus.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -16,13 +16,19 @@\n \n # Written by Balaji V. Iyer <balaji.v.iyer@intel.com>\n \n-\n load_lib g++-dg.exp\n \n if { ![check_effective_target_cilkplus] } {\n     return;\n }\n \n+dg-init\n+# Run the tests that are shared with C.\n+g++-dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/PS/*.c]] \"\"\n+# Run the C++ only tests.\n+g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \"\"\n+dg-finish\n+\n dg-init\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O0 -fcilkplus\" \" \""}, {"sha": "6e16cfcd1d1775c5ff444f2e81e9d8736a1c12f6", "filename": "gcc/testsuite/g++.dg/cilk-plus/for.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+// Test storage classes in the initialization of a <#pragma simd> for\n+// loop.\n+\n+int *a, *b;\n+\n+void foo()\n+{\n+#pragma simd\n+  for (static int tt=5; tt < 10; ++tt) /* { dg-error \"before 'static'\\|not declared\\|expected\" } */\n+    a[tt] = b[tt];\n+\n+#pragma simd\n+  for (extern int var=0; var < 1000; ++var) /* { dg-error \"before 'extern'\\|not declared\\|expected\" } */\n+    a[var] = var;\n+\n+#pragma simd\n+  for (register int regj = 0; regj < 1000; ++regj) /* { dg-error \"before 'register'\\|not declared\\|expected\" } */\n+    b[regj] = a[regj] * 2;\n+\n+#pragma simd\n+  for (volatile int vj=0; vj<1000; ++vj) /* { dg-error \"iteration variable cannot be volatile\" } */\n+    a[vj] = b[vj];\n+}"}, {"sha": "345e54236f8ef04d3b31c1a003fd63839b7c4ae6", "filename": "gcc/testsuite/g++.dg/cilk-plus/for2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int *p;\n+extern int stuff();\n+\n+template <int value>\n+void foobar(int a)\n+{\n+#pragma simd\n+  for (int i=0; i < a; ++i)\n+    p[i] = value;\n+}\n+\n+template <int value>\n+void foobar2(int a)\n+{\n+  int j = 123;\n+#pragma simd linear(j : value)\n+  for (int i=0; i < a; ++i)\n+    {\n+      p[i] = value;\n+      j += stuff();\n+    }\n+}\n+\n+void funky()\n+{\n+  foobar <69> (1000);\n+  foobar2 <123> (2000);\n+}\n+\n+void foobar3(int a)\n+{\n+  int j = 123;\n+#pragma simd linear(j : a + a) /* { dg-error \"step size must be an integer\" } */\n+  for (int i=0; i < a; ++i)\n+    {\n+    p[i] = 1234;\n+    extern int bar();\n+    j += bar();\n+    }\n+}"}, {"sha": "28dbdee4339e995e5686598a26fb3c1a0598afbd", "filename": "gcc/testsuite/g++.dg/cilk-plus/for3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+// Test storage classes in the initialization of a <#pragma simd> for\n+// loop.\n+\n+int *a, *b;\n+\n+void foo()\n+{\n+#pragma simd\n+  for (int tt=5; tt < 10; ++tt)\n+    {\n+      a[tt] = b[tt];\n+      if (tt == 8)\n+\tthrow 1; /* { dg-error \"throw expressions are not allowed\" } */\n+    }\n+}"}, {"sha": "5b86b9f7db556c44b4052202d051a0153c7dbf85", "filename": "gcc/testsuite/g++.dg/cilk-plus/for4.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int *p;\n+extern int stuff();\n+\n+template <int value>\n+void foobar(int a)\n+{\n+  int j = 123;\n+#pragma simd linear(j : value + 1)\n+  for (int i=0; i < a; ++i)\n+    {\n+      p[i] = value;\n+      j += stuff();\n+    }\n+}\n+\n+void funky()\n+{\n+  foobar <69> (1000);\n+}"}, {"sha": "d107dfe7894d8a6249a8c775a0c3f74185917324", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -49,6 +49,7 @@ set tests [prune $tests $srcdir/$subdir/tree-prof/*]\n set tests [prune $tests $srcdir/$subdir/torture/*]\n set tests [prune $tests $srcdir/$subdir/graphite/*]\n set tests [prune $tests $srcdir/$subdir/tm/*]\n+set tests [prune $tests $srcdir/$subdir/cilk-plus/*]\n set tests [prune $tests $srcdir/$subdir/guality/*]\n set tests [prune $tests $srcdir/$subdir/simulate-thread/*]\n set tests [prune $tests $srcdir/$subdir/asan/*]"}, {"sha": "7407e8e86ac1b3a345506a35fea8cf31754bc5d2", "filename": "gcc/testsuite/gcc.dg/cilk-plus/cilk-plus.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -33,6 +33,13 @@ set ALWAYS_CFLAGS \"\"\n lappend ALWAYS_CFLAGS \"-L${library_var}/libcilkrts/.libs\"\n \n dg-init\n+\n+# Run the tests that are shared with C++.\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/PS/*.c]] \" -ftree-vectorize -fcilkplus -std=c99\" \" \"\n+# Run the C-only tests.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \\\n+\t\"-ftree-vectorize -fcilkplus -std=c99\" \" \"\n+\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O1 -fcilkplus\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O2 -fcilkplus\" \" \""}, {"sha": "4fb534286d9a636dd91e13e6e74260b4ac9378b2", "filename": "gcc/testsuite/gcc.dg/cilk-plus/for1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+int *a, *b, *c;\n+\n+void foo()\n+{\n+  int i, j;\n+  // The initialization shall declare or initialize a *SINGLE* variable.\n+#pragma simd\n+  for (i=0, j=5; i < 1000; i++) // { dg-error \"expected ';' before ','\" }\n+    a[i] = b[j];\n+}"}, {"sha": "285f35a5079a94341d808efaabf7a6037ea81651", "filename": "gcc/testsuite/gcc.dg/cilk-plus/for2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fcilkplus\" } */\n+\n+int *a, *b;\n+\n+void foo()\n+{\n+#pragma simd\n+  for (const int ci=0; ci<1000; ++ci) /* { dg-error \"increment of read-only var\\|invalid controlling\\|invalid increment\\|assignment of read\" } */\n+    a[ci] = b[ci];\n+}"}, {"sha": "9ec3293cc9791cef5abf6d7de7d7880e6bd998cc", "filename": "gcc/testsuite/gcc.dg/cilk-plus/jump.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int *a, *b, c;\n+\n+void foo()\n+{\n+#pragma simd\n+  for (int i=0; i < 1000; ++i)\n+    {\n+      a[i] = b[i];\n+      if (c == 5)\n+\treturn;\t /* { dg-error \"invalid branch to.from a Cilk\" } */\n+    }\n+}\n+\n+void bar()\n+{\n+#pragma simd\n+  for (int i=0; i < 1000; ++i)\n+    {\n+    lab:\n+      a[i] = b[i];\n+    }\n+  if (c == 6)\n+    goto lab; /* { dg-error \"invalid entry to Cilk Plus\" } */\n+}"}, {"sha": "7fe849d914f1c870dec383dc1cc5b174dc4abb0b", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -2380,6 +2380,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \"#pragma omp simd\");\n       goto dump_omp_loop;\n \n+    case CILK_SIMD:\n+      pp_string (buffer, \"#pragma simd\");\n+      goto dump_omp_loop;\n+\n     case OMP_DISTRIBUTE:\n       pp_string (buffer, \"#pragma omp distribute\");\n       goto dump_omp_loop;"}, {"sha": "8eecba7a7ad3548bc0067b943893e3e451c9e51c", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02065fca15d60c9d34ca18b5718a145c4571db7/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=c02065fca15d60c9d34ca18b5718a145c4571db7", "patch": "@@ -1042,6 +1042,10 @@ DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n \n+/* Cilk Plus - #pragma simd [clause1 ... clauseN]\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (CILK_SIMD, \"cilk_simd\", tcc_statement, 6)\n+\n /* OpenMP - #pragma omp distribute [clause1 ... clauseN]\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)"}]}