{"sha": "f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYzNjZmYzdhZDY5MzhmMjM2Y2IxNzY5NzdhYTU3ZGNkOTdhOGU2Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-05-21T20:37:43Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-05-21T20:37:43Z"}, "message": "bb-reorder.c (make_reorder_chain_1): Modified.\n\n\t* bb-reorder.c (make_reorder_chain_1): Modified.\n\t* cfganal.c (can_fallthru, flow_call_edges_add,\n\tflow_preorder_transversal_compute): Modified.\n\t* cfgbuild.c (make_edges, find_basic_blocks, find_many_sub_basic_blocks,\n\tfind_sub_basic_blocks): Modified.\n\t* cfgcleanup.c (try_simplify_condjump, try_optimize_cfg): Modified.\n\t* cfglayout.c (skip_insns_after_block, fixup_reorder_chain,\n\tfixup_fallthru_exit_predecessor, cfg_layout_redirect_edge): Modified.\n\t* cfgrtl.c (tidy_fallthru_edges, verify_flow_info): Modified.\n\t* combine.c (this_basic_block): Type changed to basic_block.\n\t(combine_instructions, set_nonzero_bits_and_sign_copies, try_combine,\n\tnonzero_bits, num_sign_bit_copies, get_last_value_validate,\n\tget_last_value, distribute_notes, distribute_links): Modified.\n\t* final.c (compute_alignments): Modified.\n\t* flow.c (regno_uninitialized, regno_clobbered_at_setjmp): Modified.\n\t* function.c (thread_prologue_and_epilogue_insns): Modified.\n\t* gcse.c (compute_code_hoist_vbeinout): Modified.\n\t* global.c (build_insn_chain): Modified.\n\t* ifcvt.c (find_if_block, find_cond_trap): Modified.\n\t* predict.c (last_basic_block_p, note_prediction_to_br_prob): Modified.\n\t* regmove.c (regmove_optimize): Modified.\n\t* resource.c (find_basic_block): Modified.\n\t* sched-ebb.c (schedule_ebbs): Modified.\n\t* ssa-dce.c (find_control_dependence, find_pdom): Modified.\n\nFrom-SVN: r53695", "tree": {"sha": "bde29689b04a7cf4ca9eeef9eb9614fd3dc8cede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bde29689b04a7cf4ca9eeef9eb9614fd3dc8cede"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/comments", "author": null, "committer": null, "parents": [{"sha": "68bd6dd68879755ecff25c829d1067bb78db82bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bd6dd68879755ecff25c829d1067bb78db82bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68bd6dd68879755ecff25c829d1067bb78db82bf"}], "stats": {"total": 194, "additions": 100, "deletions": 94}, "files": [{"sha": "5434e676813bd4b06402c5f255e42fbdc63c0b2e", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -158,7 +158,7 @@ make_reorder_chain_1 (bb, prev)\n  restart:\n       RBI (prev)->next = bb;\n \n-      if (rtl_dump_file && prev->index + 1 != bb->index)\n+      if (rtl_dump_file && prev->next_bb != bb)\n \tfprintf (rtl_dump_file, \"Reordering block %d after %d\\n\",\n \t\t bb->index, prev->index);\n     }\n@@ -214,7 +214,7 @@ make_reorder_chain_1 (bb, prev)\n   if (! next)\n     {\n       for (e = bb->succ; e ; e = e->succ_next)\n-\tif (e->dest->index == bb->index + 1)\n+\tif (e->dest == bb->next_bb)\n \t  {\n \t    if ((e->flags & EDGE_FALLTHRU)\n \t        || (e->dest->succ"}, {"sha": "570f6b3d5cd4956b591e008e6e3c4ad62ed48d6e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -87,7 +87,7 @@ can_fallthru (src, target)\n   rtx insn = src->end;\n   rtx insn2 = target->head;\n \n-  if (src->index + 1 != target->index)\n+  if (src->next_bb != target)\n     return 0;\n \n   if (!active_insn_p (insn2))\n@@ -296,7 +296,7 @@ flow_call_edges_add (blocks)\n      Handle this by adding a dummy instruction in a new last basic block.  */\n   if (check_last_block)\n     {\n-      basic_block bb = BASIC_BLOCK (n_basic_blocks - 1);\n+      basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n       rtx insn = bb->end;\n \n       /* Back up past insns that must be kept in the same block as a call.  */\n@@ -1088,7 +1088,7 @@ flow_preorder_transversal_compute (pot_order)\n      walking the tree from right to left.  */\n \n   i = 0;\n-  node = &dfst[0];\n+  node = &dfst[ENTRY_BLOCK_PTR->next_bb->index];\n   pot_order[i++] = 0;\n \n   while (node)"}, {"sha": "ce7c307e391cebb57a3bdc01f6bb80028372e154", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -50,7 +50,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n-static void make_edges\t\t\tPARAMS ((rtx, int, int, int));\n+static void make_edges\t\t\tPARAMS ((rtx, basic_block,\n+\t\t\t\t\t\t basic_block, int));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n@@ -280,7 +281,8 @@ make_eh_edge (edge_cache, src, insn)\n static void\n make_edges (label_value_list, min, max, update_p)\n      rtx label_value_list;\n-     int min, max, update_p;\n+     basic_block min, max;\n+     int update_p;\n {\n   int i;\n   sbitmap *edge_cache = NULL;\n@@ -297,7 +299,7 @@ make_edges (label_value_list, min, max, update_p)\n       sbitmap_vector_zero (edge_cache, n_basic_blocks);\n \n       if (update_p)\n-\tfor (i = min; i <= max; ++i)\n+\tfor (i = min->index; i <= max->index; ++i)\n \t  {\n \t    edge e;\n \n@@ -308,11 +310,11 @@ make_edges (label_value_list, min, max, update_p)\n     }\n \n   /* By nature of the way these get numbered, block 0 is always the entry.  */\n-  if (min == 0)\n-    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, BASIC_BLOCK (0),\n+  if (min == ENTRY_BLOCK_PTR->next_bb)\n+    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, min,\n \t\t      EDGE_FALLTHRU);\n \n-  for (i = min; i <= max; ++i)\n+  for (i = min->index; i <= max->index; ++i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       rtx insn, x;\n@@ -443,16 +445,15 @@ make_edges (label_value_list, min, max, update_p)\n \n       /* Find out if we can drop through to the next block.  */\n       insn = next_nonnote_insn (insn);\n-      if (!insn || (i + 1 == n_basic_blocks && force_fallthru))\n+      if (!insn || (bb->next_bb == EXIT_BLOCK_PTR && force_fallthru))\n \tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n-      else if (i + 1 < n_basic_blocks)\n+      else if (bb->next_bb != EXIT_BLOCK_PTR)\n \t{\n-\t  rtx tmp = BLOCK_HEAD (i + 1);\n+\t  rtx tmp = bb->next_bb->head;\n \t  if (GET_CODE (tmp) == NOTE)\n \t    tmp = next_nonnote_insn (tmp);\n \t  if (force_fallthru || insn == tmp)\n-\t    cached_make_edge (edge_cache, bb, BASIC_BLOCK (i + 1),\n-\t\t\t      EDGE_FALLTHRU);\n+\t    cached_make_edge (edge_cache, bb, bb->next_bb, EDGE_FALLTHRU);\n \t}\n     }\n \n@@ -664,7 +665,7 @@ find_basic_blocks (f, nregs, file)\n   compute_bb_for_insn (max_uid);\n \n   /* Discover the edges of our cfg.  */\n-  make_edges (label_value_list, 0, n_basic_blocks - 1, 0);\n+  make_edges (label_value_list, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, 0);\n \n   /* Do very simple cleanup now, for the benefit of code that runs between\n      here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */\n@@ -815,7 +816,7 @@ find_many_sub_basic_blocks (blocks)\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, min, max, 1);\n+  make_edges (NULL, BASIC_BLOCK (min), BASIC_BLOCK (max), 1);\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */\n@@ -852,16 +853,15 @@ find_sub_basic_blocks (bb)\n {\n   int i;\n   int min, max;\n-  basic_block next = (bb->index == n_basic_blocks - 1\n-\t\t      ? NULL : BASIC_BLOCK (bb->index + 1));\n+  basic_block next = bb->next_bb;\n \n   min = bb->index;\n   find_bb_boundaries (bb);\n-  max = (next ? next->index : n_basic_blocks) - 1;\n+  max = next->prev_bb->index;\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, min, max, 1);\n+  make_edges (NULL, BASIC_BLOCK (min), BASIC_BLOCK (max), 1);\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */"}, {"sha": "070c1c7e30b258654c41d96fd74b5214f41b0001", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -147,7 +147,7 @@ try_simplify_condjump (cbranch_block)\n      unconditional jump.  */\n   jump_block = cbranch_fallthru_edge->dest;\n   if (jump_block->pred->pred_next\n-      || jump_block->index == n_basic_blocks - 1\n+      || jump_block->next_bb == EXIT_BLOCK_PTR\n       || !FORWARDER_BLOCK_P (jump_block))\n     return false;\n   jump_dest_block = jump_block->succ->dest;\n@@ -1615,7 +1615,7 @@ try_optimize_cfg (mode)\n \t      /* Delete trivially dead basic blocks.  */\n \t      while (b->pred == NULL)\n \t\t{\n-\t\t  c = BASIC_BLOCK (b->index - 1);\n+\t\t  c = b->prev_bb;\n \t\t  if (rtl_dump_file)\n \t\t    fprintf (rtl_dump_file, \"Deleting block %i.\\n\",\n \t\t\t     b->index);\n@@ -1669,7 +1669,7 @@ try_optimize_cfg (mode)\n \t\t\t     \"Deleting fallthru block %i.\\n\",\n \t\t\t     b->index);\n \n-\t\t  c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n+\t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n \t\t  redirect_edge_succ_nodup (b->pred, b->succ->dest);\n \t\t  flow_delete_block (b);\n \t\t  changed = true;"}, {"sha": "05eb97e9a3935f296c240b422be849e7be60c885", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -86,8 +86,8 @@ skip_insns_after_block (bb)\n   rtx insn, last_insn, next_head, prev;\n \n   next_head = NULL_RTX;\n-  if (bb->index + 1 != n_basic_blocks)\n-    next_head = BASIC_BLOCK (bb->index + 1)->head;\n+  if (bb->next_bb != EXIT_BLOCK_PTR)\n+    next_head = bb->next_bb->head;\n \n   for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)) != 0; )\n     {\n@@ -364,7 +364,7 @@ fixup_reorder_chain ()\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (bb = BASIC_BLOCK (0), index = 0;\n+  for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n        bb != 0;\n        bb = RBI (bb)->next, index++)\n     {\n@@ -412,7 +412,7 @@ fixup_reorder_chain ()\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n-  for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = RBI (bb)->next)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -527,7 +527,7 @@ fixup_reorder_chain ()\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-      for (bb = BASIC_BLOCK (0), index = 0; bb; bb = RBI (bb)->next, index ++)\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0; bb; bb = RBI (bb)->next, index ++)\n \t{\n \t  fprintf (rtl_dump_file, \" %i \", index);\n \t  if (RBI (bb)->original)\n@@ -542,7 +542,7 @@ fixup_reorder_chain ()\n     }\n \n   prev_bb = ENTRY_BLOCK_PTR;\n-  bb = BASIC_BLOCK (0);\n+  bb = ENTRY_BLOCK_PTR->next_bb;\n   index = 0;\n \n   for (; bb; prev_bb = bb, bb = RBI (bb)->next, index ++)\n@@ -611,7 +611,9 @@ cleanup_unconditional_jumps ()\n \t  rtx insn;\n \t  if (GET_CODE (bb->head) != CODE_LABEL && forwarder_block_p (bb) && i)\n \t    {\n-\t      basic_block prev = BASIC_BLOCK (--i);\n+\t      basic_block prev = bb->prev_bb;\n+\n+\t      i--;\n \n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Removing forwarder BB %i\\n\",\n@@ -672,7 +674,7 @@ fixup_fallthru_exit_predecessor ()\n \n   if (bb && RBI (bb)->next)\n     {\n-      basic_block c = BASIC_BLOCK (0);\n+      basic_block c = ENTRY_BLOCK_PTR->next_bb;\n \n       while (RBI (c)->next != bb)\n \tc = RBI (c)->next;\n@@ -822,14 +824,14 @@ cfg_layout_redirect_edge (e, dest)\n      edge e;\n      basic_block dest;\n {\n-  int old_index = dest->index;\n   basic_block src = e->src;\n+  basic_block old_next_bb = src->next_bb;\n \n   /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n      in the case the basic block appears to be in sequence.  Avoid this\n      transformation.  */\n \n-  dest->index = n_basic_blocks + 1;\n+  src->next_bb = NULL;\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       /* In case we are redirecting fallthru edge to the branch edge\n@@ -855,7 +857,7 @@ cfg_layout_redirect_edge (e, dest)\n       delete_barrier (NEXT_INSN (src->end));\n       src->succ->flags |= EDGE_FALLTHRU;\n     }\n-  dest->index = old_index;\n+  src->next_bb = old_next_bb;\n }\n \n /* Create an duplicate of the basic block BB and redirect edge E into it.  */"}, {"sha": "d2025b8226a906cdcfff3187efcdc48d4d9878c4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -1172,8 +1172,8 @@ tidy_fallthru_edges ()\n \n   for (i = 1; i < n_basic_blocks; i++)\n     {\n-      basic_block b = BASIC_BLOCK (i - 1);\n       basic_block c = BASIC_BLOCK (i);\n+      basic_block b = c->prev_bb;\n       edge s;\n \n       /* We care about simple conditional or unconditional jumps with\n@@ -1887,7 +1887,7 @@ verify_flow_info ()\n \t    {\n \t      rtx insn;\n \n-\t      if (e->src->index + 1 != e->dest->index)\n+\t      if (e->src->next_bb != e->dest)\n \t\t{\n \t\t  error\n \t\t    (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n@@ -1952,7 +1952,7 @@ verify_flow_info ()\n \t  err = 1;\n \t}\n       if (n_branch != 1 && any_condjump_p (bb->end)\n-\t  && JUMP_LABEL (bb->end) != BASIC_BLOCK (bb->index + 1)->head)\n+\t  && JUMP_LABEL (bb->end) != bb->next_bb->head)\n \t{\n \t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n \t  err = 1;"}, {"sha": "bdb130ca05575da61b8a6b09a92b1e1f31d8a621", "filename": "gcc/combine.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -192,8 +192,8 @@ static HARD_REG_SET newpat_used_regs;\n \n static rtx added_links_insn;\n \n-/* Basic block number of the block in which we are performing combines.  */\n-static int this_basic_block;\n+/* Basic block in which we are performing combines.  */\n+static basic_block this_basic_block;\n \n /* A bitmap indicating which blocks had registers go dead at entry.\n    After combine, we'll need to re-do global life analysis with\n@@ -610,7 +610,7 @@ combine_instructions (f, nregs)\n \n   /* Now scan all the insns in forward order.  */\n \n-  this_basic_block = -1;\n+  this_basic_block = ENTRY_BLOCK_PTR;\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n@@ -622,9 +622,9 @@ combine_instructions (f, nregs)\n       next = 0;\n \n       /* If INSN starts a new basic block, update our basic block number.  */\n-      if (this_basic_block + 1 < n_basic_blocks\n-\t  && BLOCK_HEAD (this_basic_block + 1) == insn)\n-\tthis_basic_block++;\n+      if (this_basic_block->next_bb != EXIT_BLOCK_PTR\n+\t  && this_basic_block->next_bb->head == insn)\n+\tthis_basic_block = this_basic_block->next_bb;\n \n       if (GET_CODE (insn) == CODE_LABEL)\n \tlabel_tick++;\n@@ -741,8 +741,8 @@ combine_instructions (f, nregs)\n     }\n   clear_bb_flags ();\n \n-  EXECUTE_IF_SET_IN_SBITMAP (refresh_blocks, 0, this_basic_block,\n-\t\t\t     BASIC_BLOCK (this_basic_block)->flags |= BB_DIRTY);\n+  EXECUTE_IF_SET_IN_SBITMAP (refresh_blocks, 0, i,\n+\t\t\t     BASIC_BLOCK (i)->flags |= BB_DIRTY);\n   new_direct_jump_p |= purge_all_dead_edges (0);\n   delete_noop_moves (f);\n \n@@ -860,7 +860,7 @@ set_nonzero_bits_and_sign_copies (x, set, data)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n-      && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, REGNO (x))\n+      && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -2388,8 +2388,8 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t     which we know will be a NOTE.  */\n \n \t  for (insn = NEXT_INSN (i3);\n-\t       insn && (this_basic_block == n_basic_blocks - 1\n-\t\t\t|| insn != BLOCK_HEAD (this_basic_block + 1));\n+\t       insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t\t\t|| insn != this_basic_block->next_bb->head);\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn) && reg_referenced_p (ni2dest, PATTERN (insn)))\n@@ -2606,8 +2606,8 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t      && ! find_reg_note (i2, REG_UNUSED,\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n \t    for (temp = NEXT_INSN (i2);\n-\t\t temp && (this_basic_block == n_basic_blocks - 1\n-\t\t\t  || BLOCK_HEAD (this_basic_block) != temp);\n+\t\t temp && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t\t\t  || this_basic_block->head != temp);\n \t\t temp = NEXT_INSN (temp))\n \t      if (temp != i3 && INSN_P (temp))\n \t\tfor (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n@@ -8068,7 +8068,7 @@ nonzero_bits (x, mode)\n \t  && (reg_last_set_label[REGNO (x)] == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n-\t\t  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n+\t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_nonzero_bits[REGNO (x)] & nonzero;\n@@ -8483,7 +8483,7 @@ num_sign_bit_copies (x, mode)\n \t  && (reg_last_set_label[REGNO (x)] == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n-\t\t  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n+\t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_sign_bit_copies[REGNO (x)];\n@@ -11492,7 +11492,7 @@ get_last_value_validate (loc, insn, tick, replace)\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n-\t\t       (BASIC_BLOCK (0)->global_live_at_start, regno)))\n+\t\t       (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))\n \t\t&& reg_last_set_label[j] > tick))\n \t  {\n \t    if (replace)\n@@ -11566,7 +11566,7 @@ get_last_value (x)\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || (REGNO_REG_SET_P\n-\t\t  (BASIC_BLOCK (0)->global_live_at_start, regno)))))\n+\t\t  (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))))\n     return 0;\n \n   /* If the value was set in a later insn than the ones we are processing,\n@@ -12375,7 +12375,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t  if (place == 0)\n \t    {\n-\t      basic_block bb = BASIC_BLOCK (this_basic_block);\n+\t      basic_block bb = this_basic_block;\n \n \t      for (tem = PREV_INSN (i3); place == 0; tem = PREV_INSN (tem))\n \t\t{\n@@ -12519,7 +12519,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  && REGNO_REG_SET_P (bb->global_live_at_start,\n \t\t\t\t      REGNO (XEXP (note, 0))))\n \t\t{\n-\t\t  SET_BIT (refresh_blocks, this_basic_block);\n+\t\t  SET_BIT (refresh_blocks, this_basic_block->index);\n \t\t  need_refresh = 1;\n \t\t}\n \t    }\n@@ -12539,7 +12539,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t after we remove them in delete_noop_moves.  */\n \t      if (noop_move_p (place))\n \t\t{\n-\t\t  SET_BIT (refresh_blocks, this_basic_block);\n+\t\t  SET_BIT (refresh_blocks, this_basic_block->index);\n \t\t  need_refresh = 1;\n \t\t}\n \n@@ -12589,7 +12589,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t   i += HARD_REGNO_NREGS (i, reg_raw_mode[i]))\n \t\t\t{\n \t\t\t  rtx piece = gen_rtx_REG (reg_raw_mode[i], i);\n-\t\t\t  basic_block bb = BASIC_BLOCK (this_basic_block);\n+\t\t\t  basic_block bb = this_basic_block;\n \n \t\t\t  if (! dead_or_set_p (place, piece)\n \t\t\t      && ! reg_bitfield_target_p (piece,\n@@ -12612,7 +12612,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t\t    if (tem == bb->head)\n \t\t\t\t      {\n \t\t\t\t\tSET_BIT (refresh_blocks,\n-\t\t\t\t\t\t this_basic_block);\n+\t\t\t\t\t\t this_basic_block->index);\n \t\t\t\t\tneed_refresh = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t      }\n@@ -12717,8 +12717,8 @@ distribute_links (links)\n \t since most links don't point very far away.  */\n \n       for (insn = NEXT_INSN (XEXP (link, 0));\n-\t   (insn && (this_basic_block == n_basic_blocks - 1\n-\t\t     || BLOCK_HEAD (this_basic_block + 1) != insn));\n+\t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t\t     || this_basic_block->next_bb->head != insn));\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn) && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \t  {"}, {"sha": "ad522aef2ce98547ae600e55b9ab327b2450bfe4", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -984,8 +984,8 @@ compute_alignments ()\n \n       if (!has_fallthru\n \t  && (branch_frequency > BB_FREQ_MAX / 10\n-\t      || (bb->frequency > BASIC_BLOCK (i - 1)->frequency * 10\n-\t\t  && (BASIC_BLOCK (i - 1)->frequency\n+\t      || (bb->frequency > bb->prev_bb->frequency * 10\n+\t\t  && (bb->prev_bb->frequency\n \t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n \t{\n \t  log = JUMP_ALIGN (label);"}, {"sha": "64d68dffca7fb7d731b3d029f4b02362aa4921ae", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -2349,7 +2349,7 @@ regno_uninitialized (regno)\n \t      || FUNCTION_ARG_REGNO_P (regno))))\n     return 0;\n \n-  return REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno);\n+  return REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno);\n }\n \n /* 1 if register REGNO was alive at a place where `setjmp' was called\n@@ -2364,7 +2364,7 @@ regno_clobbered_at_setjmp (regno)\n     return 0;\n \n   return ((REG_N_SETS (regno) > 1\n-\t   || REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))\n+\t   || REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno))\n \t  && REGNO_REG_SET_P (regs_live_at_setjmp, regno));\n }\n \f"}, {"sha": "669dd2ecf851f8ae8b4026d82f3f639b5701b721", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -7817,7 +7817,7 @@ thread_prologue_and_epilogue_insns (f)\n \t}\n \n       /* Find the last line number note in the first block.  */\n-      for (insn = BASIC_BLOCK (0)->end;\n+      for (insn = ENTRY_BLOCK_PTR->next_bb->end;\n \t   insn != prologue_end && insn;\n \t   insn = PREV_INSN (insn))\n \tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)"}, {"sha": "b2aad0515393b553b4d94aeb05ce5877338bfad3", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -5586,7 +5586,7 @@ compute_code_hoist_vbeinout ()\n \t{\n \t  changed |= sbitmap_a_or_b_and_c_cg (hoist_vbein[bb], antloc[bb],\n \t\t\t\t\t      hoist_vbeout[bb], transp[bb]);\n-\t  if (bb != n_basic_blocks - 1)\n+\t  if (BASIC_BLOCK (bb)->next_bb != EXIT_BLOCK_PTR)\n \t    sbitmap_intersection_of_succs (hoist_vbeout[bb], hoist_vbein, bb);\n \t}\n "}, {"sha": "b75ef21652871bb970365c361b42cfba01b0ec7e", "filename": "gcc/global.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -1794,7 +1794,7 @@ build_insn_chain (first)\n {\n   struct insn_chain **p = &reload_insn_chain;\n   struct insn_chain *prev = 0;\n-  int b = 0;\n+  basic_block b = ENTRY_BLOCK_PTR->next_bb;\n   regset_head live_relevant_regs_head;\n \n   live_relevant_regs = INITIALIZE_REG_SET (live_relevant_regs_head);\n@@ -1803,14 +1803,14 @@ build_insn_chain (first)\n     {\n       struct insn_chain *c;\n \n-      if (first == BLOCK_HEAD (b))\n+      if (first == b->head)\n \t{\n \t  int i;\n \n \t  CLEAR_REG_SET (live_relevant_regs);\n \n \t  EXECUTE_IF_SET_IN_BITMAP\n-\t    (BASIC_BLOCK (b)->global_live_at_start, 0, i,\n+\t    (b->global_live_at_start, 0, i,\n \t     {\n \t       if (i < FIRST_PSEUDO_REGISTER\n \t\t   ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n@@ -1827,7 +1827,7 @@ build_insn_chain (first)\n \t  *p = c;\n \t  p = &c->next;\n \t  c->insn = first;\n-\t  c->block = b;\n+\t  c->block = b->index;\n \n \t  if (INSN_P (first))\n \t    {\n@@ -1865,16 +1865,16 @@ build_insn_chain (first)\n \t    }\n \t}\n \n-      if (first == BLOCK_END (b))\n-\tb++;\n+      if (first == b->end)\n+\tb = b->next_bb;\n \n       /* Stop after we pass the end of the last basic block.  Verify that\n \t no real insns are after the end of the last basic block.\n \n \t We may want to reorganize the loop somewhat since this test should\n \t always be the right exit test.  Allow an ADDR_VEC or ADDR_DIF_VEC if\n \t the previous real insn is a JUMP_INSN.  */\n-      if (b == n_basic_blocks)\n+      if (b == EXIT_BLOCK_PTR)\n \t{\n \t  for (first = NEXT_INSN (first) ; first; first = NEXT_INSN (first))\n \t    if (INSN_P (first)"}, {"sha": "408f7aff4fe31bd48c6fc58c61beaad7b532a178", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -1973,7 +1973,7 @@ find_if_block (test_bb, then_edge, else_edge)\n   basic_block join_bb = NULL_BLOCK;\n   edge then_succ = then_bb->succ;\n   edge else_succ = else_bb->succ;\n-  int next_index;\n+  basic_block next;\n \n   /* The THEN block of an IF-THEN combo must have exactly one predecessor.  */\n   if (then_bb->pred->pred_next != NULL_EDGE)\n@@ -2057,10 +2057,10 @@ find_if_block (test_bb, then_edge, else_edge)\n   /* ??? As an enhancement, move the ELSE block.  Have to deal with\n      BLOCK notes, if by no other means than aborting the merge if they\n      exist.  Sticky enough I don't want to think about it now.  */\n-  next_index = then_bb->index;\n-  if (else_bb && ++next_index != else_bb->index)\n+  next = then_bb;\n+  if (else_bb && (next = next->next_bb) != else_bb)\n     return FALSE;\n-  if (++next_index != join_bb->index && join_bb->index != EXIT_BLOCK)\n+  if ((next = next->next_bb) != join_bb && join_bb != EXIT_BLOCK_PTR)\n     {\n       if (else_bb)\n \tjoin_bb = NULL;\n@@ -2146,7 +2146,7 @@ find_cond_trap (test_bb, then_edge, else_edge)\n \n   /* If the non-trap block and the test are now adjacent, merge them.\n      Otherwise we must insert a direct branch.  */\n-  if (test_bb->index + 1 == other_bb->index)\n+  if (test_bb->next_bb == other_bb)\n     {\n       delete_insn (jump);\n       merge_if_block (test_bb, NULL, NULL, other_bb);"}, {"sha": "ce8ed2d04496c4a0813f871448fc03b97e12da97", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -695,10 +695,13 @@ static bool\n last_basic_block_p (bb)\n      basic_block bb;\n {\n-  return (bb->index == n_basic_blocks - 1\n-\t  || (bb->index == n_basic_blocks - 2\n+  if (bb == EXIT_BLOCK_PTR)\n+    return false;\n+\n+  return (bb->next_bb == EXIT_BLOCK_PTR\n+\t  || (bb->next_bb->next_bb == EXIT_BLOCK_PTR\n \t      && bb->succ && !bb->succ->succ_next\n-\t      && bb->succ->dest->index == n_basic_blocks - 1));\n+\t      && bb->succ->dest->next_bb == EXIT_BLOCK_PTR));\n }\n \n /* Sets branch probabilities according to PREDiction and FLAGS. HEADS[bb->index]\n@@ -847,7 +850,7 @@ note_prediction_to_br_prob ()\n \n   heads = xmalloc (sizeof (int) * n_basic_blocks);\n   memset (heads, -1, sizeof (int) * n_basic_blocks);\n-  heads[0] = n_basic_blocks;\n+  heads[ENTRY_BLOCK_PTR->next_bb->index] = n_basic_blocks;\n \n   /* Process all prediction notes.  */\n "}, {"sha": "7dc808cc3641fe937078f647ecaa6ff6187728b2", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -1506,13 +1506,14 @@ regmove_optimize (f, nregs, regmove_dump_file)\n      ends.  Fix that here.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      rtx end = BLOCK_END (i);\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx end = bb->end;\n       rtx new = end;\n       rtx next = NEXT_INSN (new);\n       while (next != 0 && INSN_UID (next) >= old_max_uid\n-\t     && (i == n_basic_blocks - 1 || BLOCK_HEAD (i + 1) != next))\n+\t     && (bb->next_bb == EXIT_BLOCK_PTR || bb->next_bb->head != next))\n \tnew = next, next = NEXT_INSN (new);\n-      BLOCK_END (i) = new;\n+      bb->end = new;\n     }\n \n  done:"}, {"sha": "ea915831547f2026b22eed4bc2d22115901dfaec", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -146,9 +146,9 @@ find_basic_block (insn, search_limit)\n   if (search_limit == 0)\n     return -1;\n \n-  /* The start of the function is basic block zero.  */\n+  /* The start of the function.  */\n   else if (insn == 0)\n-    return 0;\n+    return ENTRY_BLOCK_PTR->next_bb->index;\n \n   /* See if any of the upcoming CODE_LABELs start a basic block.  If we reach\n      anything other than a CODE_LABEL or note, we can't find this code.  */"}, {"sha": "4a08b3e96c2dcc0454d8795213f70903307ff219", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -306,8 +306,8 @@ schedule_ebbs (dump_file)\n \t  basic_block b = BASIC_BLOCK (i);\n \t  edge e;\n \t  tail = b->end;\n-\t  if (i + 1 == n_basic_blocks\n-\t      || GET_CODE (BLOCK_HEAD (i + 1)) == CODE_LABEL)\n+\t  if (b->next_bb == EXIT_BLOCK_PTR\n+\t      || GET_CODE (b->next_bb->head) == CODE_LABEL)\n \t    break;\n \t  for (e = b->succ; e; e = e->succ_next)\n \t    if ((e->flags & EDGE_FALLTHRU) != 0)"}, {"sha": "46ae1c142ec53d42a288b641cf3b30912df82007", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6366fc7ad6938f236cb176977aa57dcd97a8e6f/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "patch": "@@ -247,7 +247,7 @@ find_control_dependence (el, edge_index, pdom, cdbte)\n     abort ();\n   ending_block =\n     (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n-    ? BASIC_BLOCK (0)\n+    ? ENTRY_BLOCK_PTR->next_bb\n     : find_pdom (pdom, INDEX_EDGE_PRED_BB (el, edge_index));\n \n   for (current_block = INDEX_EDGE_SUCC_BB (el, edge_index);\n@@ -275,7 +275,7 @@ find_pdom (pdom, block)\n     abort ();\n \n   if (block == ENTRY_BLOCK_PTR)\n-    return BASIC_BLOCK (0);\n+    return ENTRY_BLOCK_PTR->next_bb;\n   else if (block == EXIT_BLOCK_PTR || pdom[block->index] == EXIT_BLOCK)\n     return EXIT_BLOCK_PTR;\n   else"}]}