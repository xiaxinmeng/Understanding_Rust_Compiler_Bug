{"sha": "e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "node_id": "C_kwDOANBUbNoAKGU0Y2JhNDk0MTNjYTQyOWRjODJmNmFhMmU4ODEyOWVjYjNmZGQ5NDM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-10-17T20:19:55Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-11-04T09:51:01Z"}, "message": "Remove support for Intel MIC offloading\n\n... after its deprecation in GCC 12.\n\n\t* Makefile.def: Remove module 'liboffloadmic'.\n\t* Makefile.in: Regenerate.\n\t* configure.ac: Remove 'liboffloadmic' handling.\n\t* configure: Regenerate.\n\tcontrib/\n\t* gcc-changelog/git_commit.py (default_changelog_locations):\n\tRemove 'liboffloadmic'.\n\t* gcc_update (files_and_dependencies): Remove 'liboffloadmic'\n\tfiles.\n\t* update-copyright.py (GCCCmdLine): Remove 'liboffloadmic'\n\tcomment.\n\tgcc/\n\t* config.gcc [target *-intelmic-* | *-intelmicemul-*]: Remove.\n\t* config/i386/i386-options.cc (ix86_omp_device_kind_arch_isa)\n\t[ACCEL_COMPILER]: Remove.\n\t* config/i386/intelmic-mkoffload.cc: Remove.\n\t* config/i386/intelmic-offload.h: Likewise.\n\t* config/i386/t-intelmic: Likewise.\n\t* config/i386/t-omp-device: Likewise.\n\t* configure.ac [target *-intelmic-* | *-intelmicemul-*]: Remove.\n\t* configure: Regenerate.\n\t* doc/install.texi (--enable-offload-targets=[...]): Update.\n\t* doc/sourcebuild.texi: Remove 'liboffloadmic' documentation.\n\tinclude/\n\t* gomp-constants.h (GOMP_DEVICE_INTEL_MIC): Comment out.\n\t(GOMP_VERSION_INTEL_MIC): Remove.\n\tlibgomp/\n\t* libgomp-plugin.h (OFFLOAD_TARGET_TYPE_INTEL_MIC): Remove.\n\t* libgomp.texi (OpenMP Context Selectors): Remove Intel MIC\n\tdocumentation.\n\t* plugin/configfrag.ac <enable_offload_targets>\n\t[*-intelmic-* | *-intelmicemul-*]: Remove.\n\t* configure: Regenerate.\n\t* testsuite/lib/libgomp.exp (libgomp_init): Remove 'liboffloadmic'\n\thandling.\n\t(offload_target_to_openacc_device_type)\n\t[$offload_target = *-intelmic*]: Remove.\n\t(check_effective_target_offload_device_intel_mic)\n\t(check_effective_target_offload_device_any_intel_mic): Remove.\n\t* testsuite/libgomp.c-c++-common/on_device_arch.h\n\t(device_arch_intel_mic, on_device_arch_intel_mic, any_device_arch)\n\t(any_device_arch_intel_mic): Remove.\n\t* testsuite/libgomp.c-c++-common/target-45.c: Remove\n\t'offload_device_any_intel_mic' XFAIL.\n\t* testsuite/libgomp.fortran/target10.f90: Likewise.\n\tliboffloadmic/\n\t* ChangeLog: Remove.\n\t* Makefile.am: Likewise.\n\t* Makefile.in: Likewise.\n\t* aclocal.m4: Likewise.\n\t* configure: Likewise.\n\t* configure.ac: Likewise.\n\t* configure.tgt: Likewise.\n\t* doc/doxygen/config: Likewise.\n\t* doc/doxygen/header.tex: Likewise.\n\t* include/coi/common/COIEngine_common.h: Likewise.\n\t* include/coi/common/COIEvent_common.h: Likewise.\n\t* include/coi/common/COIMacros_common.h: Likewise.\n\t* include/coi/common/COIPerf_common.h: Likewise.\n\t* include/coi/common/COIResult_common.h: Likewise.\n\t* include/coi/common/COISysInfo_common.h: Likewise.\n\t* include/coi/common/COITypes_common.h: Likewise.\n\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n\t* include/coi/sink/COIProcess_sink.h: Likewise.\n\t* include/coi/source/COIBuffer_source.h: Likewise.\n\t* include/coi/source/COIEngine_source.h: Likewise.\n\t* include/coi/source/COIEvent_source.h: Likewise.\n\t* include/coi/source/COIPipeline_source.h: Likewise.\n\t* include/coi/source/COIProcess_source.h: Likewise.\n\t* liboffloadmic_host.spec.in: Likewise.\n\t* liboffloadmic_target.spec.in: Likewise.\n\t* plugin/Makefile.am: Likewise.\n\t* plugin/Makefile.in: Likewise.\n\t* plugin/aclocal.m4: Likewise.\n\t* plugin/configure: Likewise.\n\t* plugin/configure.ac: Likewise.\n\t* plugin/libgomp-plugin-intelmic.cpp: Likewise.\n\t* plugin/offload_target_main.cpp: Likewise.\n\t* runtime/cean_util.cpp: Likewise.\n\t* runtime/cean_util.h: Likewise.\n\t* runtime/coi/coi_client.cpp: Likewise.\n\t* runtime/coi/coi_client.h: Likewise.\n\t* runtime/coi/coi_server.cpp: Likewise.\n\t* runtime/coi/coi_server.h: Likewise.\n\t* runtime/compiler_if_host.cpp: Likewise.\n\t* runtime/compiler_if_host.h: Likewise.\n\t* runtime/compiler_if_target.cpp: Likewise.\n\t* runtime/compiler_if_target.h: Likewise.\n\t* runtime/dv_util.cpp: Likewise.\n\t* runtime/dv_util.h: Likewise.\n\t* runtime/emulator/coi_common.h: Likewise.\n\t* runtime/emulator/coi_device.cpp: Likewise.\n\t* runtime/emulator/coi_device.h: Likewise.\n\t* runtime/emulator/coi_host.cpp: Likewise.\n\t* runtime/emulator/coi_host.h: Likewise.\n\t* runtime/emulator/coi_version_asm.h: Likewise.\n\t* runtime/emulator/coi_version_linker_script.map: Likewise.\n\t* runtime/liboffload_error.c: Likewise.\n\t* runtime/liboffload_error_codes.h: Likewise.\n\t* runtime/liboffload_msg.c: Likewise.\n\t* runtime/liboffload_msg.h: Likewise.\n\t* runtime/mic_lib.f90: Likewise.\n\t* runtime/offload.h: Likewise.\n\t* runtime/offload_common.cpp: Likewise.\n\t* runtime/offload_common.h: Likewise.\n\t* runtime/offload_engine.cpp: Likewise.\n\t* runtime/offload_engine.h: Likewise.\n\t* runtime/offload_env.cpp: Likewise.\n\t* runtime/offload_env.h: Likewise.\n\t* runtime/offload_host.cpp: Likewise.\n\t* runtime/offload_host.h: Likewise.\n\t* runtime/offload_iterator.h: Likewise.\n\t* runtime/offload_omp_host.cpp: Likewise.\n\t* runtime/offload_omp_target.cpp: Likewise.\n\t* runtime/offload_orsl.cpp: Likewise.\n\t* runtime/offload_orsl.h: Likewise.\n\t* runtime/offload_table.cpp: Likewise.\n\t* runtime/offload_table.h: Likewise.\n\t* runtime/offload_target.cpp: Likewise.\n\t* runtime/offload_target.h: Likewise.\n\t* runtime/offload_target_main.cpp: Likewise.\n\t* runtime/offload_timer.h: Likewise.\n\t* runtime/offload_timer_host.cpp: Likewise.\n\t* runtime/offload_timer_target.cpp: Likewise.\n\t* runtime/offload_trace.cpp: Likewise.\n\t* runtime/offload_trace.h: Likewise.\n\t* runtime/offload_util.cpp: Likewise.\n\t* runtime/offload_util.h: Likewise.\n\t* runtime/ofldbegin.cpp: Likewise.\n\t* runtime/ofldend.cpp: Likewise.\n\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n\t* runtime/orsl-lite/version.txt: Likewise.", "tree": {"sha": "c949e231f1a973cb7cb5aad1985c2aab9c653378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c949e231f1a973cb7cb5aad1985c2aab9c653378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e724b0480bfa5ec04f39be8c7290330b495c59de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e724b0480bfa5ec04f39be8c7290330b495c59de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e724b0480bfa5ec04f39be8c7290330b495c59de"}], "stats": {"total": 75959, "additions": 10, "deletions": 75949}, "files": [{"sha": "02e63c57177ed6e9b0f3546a43a57dbf7474c0c0", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -158,9 +158,6 @@ target_modules = { module= libvtv;\n \t\t   bootstrap=true;\n \t\t   lib_path=.libs;\n \t\t   raw_cxx=true; };\n-target_modules = { module= liboffloadmic;\n-\t\t   lib_path=.libs;\n-\t\t   extra_configure_flags='@extra_liboffloadmic_configure_flags@'; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true;\n@@ -603,7 +600,6 @@ dependencies = { module=all-m4; on=all-build-texinfo; };\n // on libgcc and newlib/libgloss.\n lang_env_dependencies = { module=libitm; cxx=true; };\n lang_env_dependencies = { module=libffi; cxx=true; };\n-lang_env_dependencies = { module=liboffloadmic; cxx=true; };\n lang_env_dependencies = { module=newlib; no_c=true; };\n lang_env_dependencies = { module=libgloss; no_c=true; };\n lang_env_dependencies = { module=libgcc; no_gcc=true; no_c=true; };\n@@ -625,14 +621,12 @@ dependencies = { module=all-target-libphobos; on=all-target-libbacktrace; };\n dependencies = { module=all-target-libphobos; on=all-target-zlib; };\n dependencies = { module=all-target-libphobos; on=all-target-libatomic; };\n dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };\n-dependencies = { module=configure-target-liboffloadmic; on=configure-target-libgomp; };\n dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };\n dependencies = { module=configure-target-libvtv; on=all-target-libstdc++-v3; };\n // parallel_list.o and parallel_settings.o depend on omp.h, which is\n // generated by the libgomp configure.  Unfortunately, due to the use of\n //  recursive make, we can't be that specific.\n dependencies = { module=all-target-libstdc++-v3; on=configure-target-libgomp; };\n-dependencies = { module=all-target-liboffloadmic; on=all-target-libgomp; };\n \n dependencies = { module=install-target-libgo; on=install-target-libatomic; };\n dependencies = { module=install-target-libgfortran; on=install-target-libquadmath; };\n@@ -642,8 +636,6 @@ dependencies = { module=install-target-libsanitizer; on=install-target-libstdc++\n dependencies = { module=install-target-libsanitizer; on=install-target-libgcc; };\n dependencies = { module=install-target-libvtv; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-libvtv; on=install-target-libgcc; };\n-dependencies = { module=install-target-liboffloadmic; on=install-target-libstdc++-v3; };\n-dependencies = { module=install-target-liboffloadmic; on=install-target-libgcc; };\n dependencies = { module=install-target-libitm; on=install-target-libgcc; };\n dependencies = { module=install-target-libobjc; on=install-target-libgcc; };\n dependencies = { module=install-target-libstdc++-v3; on=install-target-libgcc; };"}, {"sha": "6ffa9660c2572d5d86374b8aeef58e0d66010897", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 519, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -706,7 +706,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_liboffloadmic)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libphobos)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libphobos)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -720,10 +720,6 @@ TARGET_LIB_PATH_libsanitizer = $$r/$(TARGET_SUBDIR)/libsanitizer/.libs:\n TARGET_LIB_PATH_libvtv = $$r/$(TARGET_SUBDIR)/libvtv/.libs:\n @endif target-libvtv\n \n-@if target-liboffloadmic\n-TARGET_LIB_PATH_liboffloadmic = $$r/$(TARGET_SUBDIR)/liboffloadmic/.libs:\n-@endif target-liboffloadmic\n-\n @if target-libssp\n TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n @endif target-libssp\n@@ -1107,7 +1103,6 @@ configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n     maybe-configure-target-libsanitizer \\\n     maybe-configure-target-libvtv \\\n-    maybe-configure-target-liboffloadmic \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libgcc \\\n@@ -1290,7 +1285,6 @@ all-target: maybe-all-target-libsanitizer\n @if target-libvtv-no-bootstrap\n all-target: maybe-all-target-libvtv\n @endif target-libvtv-no-bootstrap\n-all-target: maybe-all-target-liboffloadmic\n all-target: maybe-all-target-libssp\n all-target: maybe-all-target-newlib\n @if target-libgcc-no-bootstrap\n@@ -1396,7 +1390,6 @@ info-host: maybe-info-libctf\n info-target: maybe-info-target-libstdc++-v3\n info-target: maybe-info-target-libsanitizer\n info-target: maybe-info-target-libvtv\n-info-target: maybe-info-target-liboffloadmic\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n info-target: maybe-info-target-libgcc\n@@ -1485,7 +1478,6 @@ dvi-host: maybe-dvi-libctf\n dvi-target: maybe-dvi-target-libstdc++-v3\n dvi-target: maybe-dvi-target-libsanitizer\n dvi-target: maybe-dvi-target-libvtv\n-dvi-target: maybe-dvi-target-liboffloadmic\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n dvi-target: maybe-dvi-target-libgcc\n@@ -1574,7 +1566,6 @@ pdf-host: maybe-pdf-libctf\n pdf-target: maybe-pdf-target-libstdc++-v3\n pdf-target: maybe-pdf-target-libsanitizer\n pdf-target: maybe-pdf-target-libvtv\n-pdf-target: maybe-pdf-target-liboffloadmic\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n pdf-target: maybe-pdf-target-libgcc\n@@ -1663,7 +1654,6 @@ html-host: maybe-html-libctf\n html-target: maybe-html-target-libstdc++-v3\n html-target: maybe-html-target-libsanitizer\n html-target: maybe-html-target-libvtv\n-html-target: maybe-html-target-liboffloadmic\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n html-target: maybe-html-target-libgcc\n@@ -1752,7 +1742,6 @@ TAGS-host: maybe-TAGS-libctf\n TAGS-target: maybe-TAGS-target-libstdc++-v3\n TAGS-target: maybe-TAGS-target-libsanitizer\n TAGS-target: maybe-TAGS-target-libvtv\n-TAGS-target: maybe-TAGS-target-liboffloadmic\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n TAGS-target: maybe-TAGS-target-libgcc\n@@ -1841,7 +1830,6 @@ install-info-host: maybe-install-info-libctf\n install-info-target: maybe-install-info-target-libstdc++-v3\n install-info-target: maybe-install-info-target-libsanitizer\n install-info-target: maybe-install-info-target-libvtv\n-install-info-target: maybe-install-info-target-liboffloadmic\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n install-info-target: maybe-install-info-target-libgcc\n@@ -1930,7 +1918,6 @@ install-dvi-host: maybe-install-dvi-libctf\n install-dvi-target: maybe-install-dvi-target-libstdc++-v3\n install-dvi-target: maybe-install-dvi-target-libsanitizer\n install-dvi-target: maybe-install-dvi-target-libvtv\n-install-dvi-target: maybe-install-dvi-target-liboffloadmic\n install-dvi-target: maybe-install-dvi-target-libssp\n install-dvi-target: maybe-install-dvi-target-newlib\n install-dvi-target: maybe-install-dvi-target-libgcc\n@@ -2019,7 +2006,6 @@ install-pdf-host: maybe-install-pdf-libctf\n install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n install-pdf-target: maybe-install-pdf-target-libsanitizer\n install-pdf-target: maybe-install-pdf-target-libvtv\n-install-pdf-target: maybe-install-pdf-target-liboffloadmic\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n install-pdf-target: maybe-install-pdf-target-libgcc\n@@ -2108,7 +2094,6 @@ install-html-host: maybe-install-html-libctf\n install-html-target: maybe-install-html-target-libstdc++-v3\n install-html-target: maybe-install-html-target-libsanitizer\n install-html-target: maybe-install-html-target-libvtv\n-install-html-target: maybe-install-html-target-liboffloadmic\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n install-html-target: maybe-install-html-target-libgcc\n@@ -2197,7 +2182,6 @@ installcheck-host: maybe-installcheck-libctf\n installcheck-target: maybe-installcheck-target-libstdc++-v3\n installcheck-target: maybe-installcheck-target-libsanitizer\n installcheck-target: maybe-installcheck-target-libvtv\n-installcheck-target: maybe-installcheck-target-liboffloadmic\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n installcheck-target: maybe-installcheck-target-libgcc\n@@ -2286,7 +2270,6 @@ mostlyclean-host: maybe-mostlyclean-libctf\n mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n mostlyclean-target: maybe-mostlyclean-target-libvtv\n-mostlyclean-target: maybe-mostlyclean-target-liboffloadmic\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n mostlyclean-target: maybe-mostlyclean-target-libgcc\n@@ -2375,7 +2358,6 @@ clean-host: maybe-clean-libctf\n clean-target: maybe-clean-target-libstdc++-v3\n clean-target: maybe-clean-target-libsanitizer\n clean-target: maybe-clean-target-libvtv\n-clean-target: maybe-clean-target-liboffloadmic\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n clean-target: maybe-clean-target-libgcc\n@@ -2464,7 +2446,6 @@ distclean-host: maybe-distclean-libctf\n distclean-target: maybe-distclean-target-libstdc++-v3\n distclean-target: maybe-distclean-target-libsanitizer\n distclean-target: maybe-distclean-target-libvtv\n-distclean-target: maybe-distclean-target-liboffloadmic\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n distclean-target: maybe-distclean-target-libgcc\n@@ -2553,7 +2534,6 @@ maintainer-clean-host: maybe-maintainer-clean-libctf\n maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n maintainer-clean-target: maybe-maintainer-clean-target-libvtv\n-maintainer-clean-target: maybe-maintainer-clean-target-liboffloadmic\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n maintainer-clean-target: maybe-maintainer-clean-target-libgcc\n@@ -2700,7 +2680,6 @@ check-target:  \\\n     maybe-check-target-libstdc++-v3 \\\n     maybe-check-target-libsanitizer \\\n     maybe-check-target-libvtv \\\n-    maybe-check-target-liboffloadmic \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libgcc \\\n@@ -2890,7 +2869,6 @@ install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n     maybe-install-target-libsanitizer \\\n     maybe-install-target-libvtv \\\n-    maybe-install-target-liboffloadmic \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libgcc \\\n@@ -2999,7 +2977,6 @@ install-strip-target:  \\\n     maybe-install-strip-target-libstdc++-v3 \\\n     maybe-install-strip-target-libsanitizer \\\n     maybe-install-strip-target-libvtv \\\n-    maybe-install-strip-target-liboffloadmic \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n     maybe-install-strip-target-libgcc \\\n@@ -46216,491 +46193,6 @@ maintainer-clean-target-libvtv:\n \n \n \n-.PHONY: configure-target-liboffloadmic maybe-configure-target-liboffloadmic\n-maybe-configure-target-liboffloadmic:\n-@if gcc-bootstrap\n-configure-target-liboffloadmic: stage_current\n-@endif gcc-bootstrap\n-@if target-liboffloadmic\n-maybe-configure-target-liboffloadmic: configure-target-liboffloadmic\n-configure-target-liboffloadmic: \n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\techo \"Checking multilib configuration for liboffloadmic...\"; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/liboffloadmic; \\\n-\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp 2> /dev/null; \\\n-\tif test -r $(TARGET_SUBDIR)/liboffloadmic/multilib.out; then \\\n-\t  if cmp -s $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; then \\\n-\t    rm -f $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp; \\\n-\t  else \\\n-\t    rm -f $(TARGET_SUBDIR)/liboffloadmic/Makefile; \\\n-\t    mv $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; \\\n-\t  fi; \\\n-\telse \\\n-\t  mv $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; \\\n-\tfi; \\\n-\ttest ! -f $(TARGET_SUBDIR)/liboffloadmic/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/liboffloadmic; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\techo Configuring in $(TARGET_SUBDIR)/liboffloadmic; \\\n-\tcd \"$(TARGET_SUBDIR)/liboffloadmic\" || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(TARGET_SUBDIR)/liboffloadmic/ | \\\n-\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n-\tesac; \\\n-\tmodule_srcdir=liboffloadmic; \\\n-\trm -f no-such-file || : ; \\\n-\tCONFIG_SITE=no-such-file $(SHELL) \\\n-\t  $$s/$$module_srcdir/configure \\\n-\t  --srcdir=$${topdir}/$$module_srcdir \\\n-\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n-\t  --target=${target_alias} @extra_liboffloadmic_configure_flags@ \\\n-\t  || exit 1\n-@endif target-liboffloadmic\n-\n-\n-\n-\n-\n-.PHONY: all-target-liboffloadmic maybe-all-target-liboffloadmic\n-maybe-all-target-liboffloadmic:\n-@if gcc-bootstrap\n-all-target-liboffloadmic: stage_current\n-@endif gcc-bootstrap\n-@if target-liboffloadmic\n-TARGET-target-liboffloadmic=all\n-maybe-all-target-liboffloadmic: all-target-liboffloadmic\n-all-target-liboffloadmic: configure-target-liboffloadmic\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n-\t\t$(TARGET-target-liboffloadmic))\n-@endif target-liboffloadmic\n-\n-\n-\n-\n-\n-.PHONY: check-target-liboffloadmic maybe-check-target-liboffloadmic\n-maybe-check-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-check-target-liboffloadmic: check-target-liboffloadmic\n-\n-check-target-liboffloadmic:\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: install-target-liboffloadmic maybe-install-target-liboffloadmic\n-maybe-install-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-target-liboffloadmic: install-target-liboffloadmic\n-\n-install-target-liboffloadmic: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: install-strip-target-liboffloadmic maybe-install-strip-target-liboffloadmic\n-maybe-install-strip-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-strip-target-liboffloadmic: install-strip-target-liboffloadmic\n-\n-install-strip-target-liboffloadmic: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n-\n-@endif target-liboffloadmic\n-\n-# Other targets (info, dvi, pdf, etc.)\n-\n-.PHONY: maybe-info-target-liboffloadmic info-target-liboffloadmic\n-maybe-info-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-info-target-liboffloadmic: info-target-liboffloadmic\n-\n-info-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing info in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           info) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-dvi-target-liboffloadmic dvi-target-liboffloadmic\n-maybe-dvi-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-dvi-target-liboffloadmic: dvi-target-liboffloadmic\n-\n-dvi-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing dvi in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           dvi) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-pdf-target-liboffloadmic pdf-target-liboffloadmic\n-maybe-pdf-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-pdf-target-liboffloadmic: pdf-target-liboffloadmic\n-\n-pdf-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing pdf in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           pdf) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-html-target-liboffloadmic html-target-liboffloadmic\n-maybe-html-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-html-target-liboffloadmic: html-target-liboffloadmic\n-\n-html-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing html in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           html) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-TAGS-target-liboffloadmic TAGS-target-liboffloadmic\n-maybe-TAGS-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-TAGS-target-liboffloadmic: TAGS-target-liboffloadmic\n-\n-TAGS-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing TAGS in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           TAGS) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-install-info-target-liboffloadmic install-info-target-liboffloadmic\n-maybe-install-info-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-info-target-liboffloadmic: install-info-target-liboffloadmic\n-\n-install-info-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \\\n-    info-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-info in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-info) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-install-dvi-target-liboffloadmic install-dvi-target-liboffloadmic\n-maybe-install-dvi-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-dvi-target-liboffloadmic: install-dvi-target-liboffloadmic\n-\n-install-dvi-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \\\n-    dvi-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-dvi in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-dvi) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-install-pdf-target-liboffloadmic install-pdf-target-liboffloadmic\n-maybe-install-pdf-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-pdf-target-liboffloadmic: install-pdf-target-liboffloadmic\n-\n-install-pdf-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \\\n-    pdf-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-pdf in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-pdf) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-install-html-target-liboffloadmic install-html-target-liboffloadmic\n-maybe-install-html-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-install-html-target-liboffloadmic: install-html-target-liboffloadmic\n-\n-install-html-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \\\n-    html-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-html in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-html) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-installcheck-target-liboffloadmic installcheck-target-liboffloadmic\n-maybe-installcheck-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-installcheck-target-liboffloadmic: installcheck-target-liboffloadmic\n-\n-installcheck-target-liboffloadmic: \\\n-    configure-target-liboffloadmic \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing installcheck in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           installcheck) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-mostlyclean-target-liboffloadmic mostlyclean-target-liboffloadmic\n-maybe-mostlyclean-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-mostlyclean-target-liboffloadmic: mostlyclean-target-liboffloadmic\n-\n-mostlyclean-target-liboffloadmic: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           mostlyclean) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-clean-target-liboffloadmic clean-target-liboffloadmic\n-maybe-clean-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-clean-target-liboffloadmic: clean-target-liboffloadmic\n-\n-clean-target-liboffloadmic: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing clean in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           clean) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-distclean-target-liboffloadmic distclean-target-liboffloadmic\n-maybe-distclean-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-distclean-target-liboffloadmic: distclean-target-liboffloadmic\n-\n-distclean-target-liboffloadmic: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing distclean in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           distclean) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-.PHONY: maybe-maintainer-clean-target-liboffloadmic maintainer-clean-target-liboffloadmic\n-maybe-maintainer-clean-target-liboffloadmic:\n-@if target-liboffloadmic\n-maybe-maintainer-clean-target-liboffloadmic: maintainer-clean-target-liboffloadmic\n-\n-maintainer-clean-target-liboffloadmic: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/liboffloadmic\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           maintainer-clean) \\\n-\t  || exit 1\n-\n-@endif target-liboffloadmic\n-\n-\n-\n-\n-\n .PHONY: configure-target-libssp maybe-configure-target-libssp\n maybe-configure-target-libssp:\n @if gcc-bootstrap\n@@ -63863,7 +63355,6 @@ configure-stagetrain-target-libvtv: maybe-all-stagetrain-gcc\n configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-gcc\n configure-stageautoprofile-target-libvtv: maybe-all-stageautoprofile-gcc\n configure-stageautofeedback-target-libvtv: maybe-all-stageautofeedback-gcc\n-configure-target-liboffloadmic: stage_last\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n configure-stage1-target-libgcc: maybe-all-stage1-gcc\n@@ -63937,7 +63428,6 @@ configure-stageautofeedback-target-libatomic: maybe-all-stageautofeedback-gcc\n configure-target-libstdc++-v3: maybe-all-gcc\n configure-target-libsanitizer: maybe-all-gcc\n configure-target-libvtv: maybe-all-gcc\n-configure-target-liboffloadmic: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n configure-target-libgcc: maybe-all-gcc\n@@ -65163,8 +64653,6 @@ install-target-libsanitizer: maybe-install-target-libstdc++-v3\n install-target-libsanitizer: maybe-install-target-libgcc\n install-target-libvtv: maybe-install-target-libstdc++-v3\n install-target-libvtv: maybe-install-target-libgcc\n-install-target-liboffloadmic: maybe-install-target-libstdc++-v3\n-install-target-liboffloadmic: maybe-install-target-libgcc\n install-target-libitm: maybe-install-target-libgcc\n install-target-libobjc: maybe-install-target-libgcc\n install-target-libstdc++-v3: maybe-install-target-libgcc\n@@ -65232,8 +64720,6 @@ all-target-fastjar: maybe-all-target-zlib\n configure-target-libgo: maybe-all-target-libstdc++-v3\n all-target-libgo: maybe-all-target-libbacktrace\n all-target-libgo: maybe-all-target-libatomic\n-configure-target-liboffloadmic: maybe-configure-target-libgomp\n-all-target-liboffloadmic: maybe-all-target-libgomp\n configure-target-newlib: maybe-all-binutils\n configure-target-newlib: maybe-all-ld\n configure-target-libgfortran: maybe-all-target-libbacktrace\n@@ -65324,7 +64810,6 @@ configure-stageautofeedback-target-libatomic: maybe-all-stageautofeedback-target\n configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libvtv: maybe-all-target-libgcc\n-configure-target-liboffloadmic: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n configure-target-libbacktrace: maybe-all-target-libgcc\n@@ -65352,9 +64837,6 @@ configure-target-libsanitizer: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libvtv: maybe-all-target-newlib maybe-all-target-libgloss\n \n-configure-target-liboffloadmic: maybe-all-target-newlib maybe-all-target-libgloss\n-configure-target-liboffloadmic: maybe-all-target-libstdc++-v3\n-\n configure-target-libssp: maybe-all-target-newlib maybe-all-target-libgloss\n \n "}, {"sha": "8899a67040b35fce0abf81153d6fd0dd14001b1b", "filename": "configure", "status": "modified", "additions": 2, "deletions": 64, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -719,7 +719,6 @@ CPPFLAGS\n LDFLAGS\n CFLAGS\n CC\n-extra_liboffloadmic_configure_flags\n target_subdir\n host_subdir\n build_subdir\n@@ -805,7 +804,6 @@ enable_libquadmath_support\n enable_libada\n enable_libssp\n enable_libstdcxx\n-enable_liboffloadmic\n enable_bootstrap\n enable_pgo_build\n with_mpc\n@@ -1543,8 +1541,6 @@ Optional Features:\n   --enable-libada         build libada directory\n   --enable-libssp         build libssp directory\n   --disable-libstdcxx     do not build libstdc++-v3 directory\n-  --enable-liboffloadmic=ARG\n-                          build liboffloadmic [ARG={no,host,target}]\n   --enable-bootstrap      enable bootstrapping [yes if native build]\n   --enable-pgo-build[=lto]\n                           enable the PGO build\n@@ -2825,7 +2821,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n-\t\ttarget-liboffloadmic \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -3199,44 +3194,6 @@ if test \"${ENABLE_LIBSTDCXX}\" = \"no\" ; then\n   noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n fi\n \n-# If this is accelerator compiler and its target is intelmic we enable\n-# target liboffloadmic by default.  If this is compiler with offloading\n-# for intelmic we enable host liboffloadmic by default.  Otherwise\n-# liboffloadmic is disabled by default.\n-# Check whether --enable-liboffloadmic was given.\n-if test \"${enable_liboffloadmic+set}\" = set; then :\n-  enableval=$enable_liboffloadmic; case \"$enableval\" in\n-  no | host | target)\n-    enable_liboffloadmic=$enableval ;;\n-  *)\n-    as_fn_error $? \"--enable-liboffloadmic=no/host/target\" \"$LINENO\" 5 ;;\n-esac\n-else\n-  if test x\"$enable_as_accelerator_for\" != x; then\n-  case \"${target}\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-      enable_liboffloadmic=target\n-      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=target\"\n-      ;;\n-    *)\n-      enable_liboffloadmic=no\n-      ;;\n-  esac\n-else\n-  case \"${enable_offload_targets}\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-      enable_liboffloadmic=host\n-      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=host\"\n-      ;;\n-    *)\n-      enable_liboffloadmic=no\n-      ;;\n-    esac\n-fi\n-fi\n-\n-\n-\n # Enable libgomp by default on hosted POSIX systems, and a few others.\n if test x$enable_libgomp = x ; then\n     case \"${target}\" in\n@@ -3275,25 +3232,6 @@ $as_echo \"yes\" >&6; }\n     fi\n fi\n \n-# Disable liboffloadmic on unsupported systems.\n-if test -d ${srcdir}/liboffloadmic; then\n-    if test x$enable_liboffloadmic != xno; then\n-\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for liboffloadmic support\" >&5\n-$as_echo_n \"checking for liboffloadmic support... \" >&6; }\n-\tif (srcdir=${srcdir}/liboffloadmic; \\\n-\t\t. ${srcdir}/configure.tgt; \\\n-\t\ttest -n \"$UNSUPPORTED\")\n-\tthen\n-\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; }\n-\t    noconfigdirs=\"$noconfigdirs target-liboffloadmic\"\n-\telse\n-\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n-$as_echo \"yes\" >&6; }\n-\tfi\n-    fi\n-fi\n-\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then\n@@ -9083,7 +9021,7 @@ $as_echo \"using paths configured with --with-target-bdw-gc options\" >&6; }\n   fi\n esac\n \n-# Disable libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n+# Disable libitm, libsanitizer, libvtv if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n     # Disable libitm, libsanitizer if we're not building libstdc++\n@@ -9095,7 +9033,7 @@ case ,${enable_languages}, in\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "1eb689d68b1ce59f3ce8fb8c240cd9a1ff3f1be0", "filename": "configure.ac", "status": "modified", "additions": 2, "deletions": 55, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -150,7 +150,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n-\t\ttarget-liboffloadmic \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -479,42 +478,6 @@ ENABLE_LIBSTDCXX=default)\n   noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n fi]\n \n-# If this is accelerator compiler and its target is intelmic we enable\n-# target liboffloadmic by default.  If this is compiler with offloading\n-# for intelmic we enable host liboffloadmic by default.  Otherwise\n-# liboffloadmic is disabled by default.\n-AC_ARG_ENABLE([liboffloadmic],\n-AC_HELP_STRING([[--enable-liboffloadmic[=ARG]]],\n-\t       [build liboffloadmic @<:@ARG={no,host,target}@:>@]),\n-[case \"$enableval\" in\n-  no | host | target)\n-    enable_liboffloadmic=$enableval ;;\n-  *)\n-    AC_MSG_ERROR([--enable-liboffloadmic=no/host/target]) ;;\n-esac],\n-[if test x\"$enable_as_accelerator_for\" != x; then\n-  case \"${target}\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-      enable_liboffloadmic=target\n-      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=target\"\n-      ;;\n-    *)\n-      enable_liboffloadmic=no\n-      ;;\n-  esac\n-else\n-  case \"${enable_offload_targets}\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-      enable_liboffloadmic=host\n-      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=host\"\n-      ;;\n-    *)\n-      enable_liboffloadmic=no\n-      ;;\n-    esac\n-fi])\n-AC_SUBST(extra_liboffloadmic_configure_flags)\n-\n # Enable libgomp by default on hosted POSIX systems, and a few others.\n if test x$enable_libgomp = x ; then\n     case \"${target}\" in\n@@ -550,22 +513,6 @@ if test -d ${srcdir}/libatomic; then\n     fi\n fi\n \n-# Disable liboffloadmic on unsupported systems.\n-if test -d ${srcdir}/liboffloadmic; then\n-    if test x$enable_liboffloadmic != xno; then\n-\tAC_MSG_CHECKING([for liboffloadmic support])\n-\tif (srcdir=${srcdir}/liboffloadmic; \\\n-\t\t. ${srcdir}/configure.tgt; \\\n-\t\ttest -n \"$UNSUPPORTED\")\n-\tthen\n-\t    AC_MSG_RESULT([no])\n-\t    noconfigdirs=\"$noconfigdirs target-liboffloadmic\"\n-\telse\n-\t    AC_MSG_RESULT([yes])\n-\tfi\n-    fi\n-fi\n-\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then\n@@ -2334,7 +2281,7 @@ case ,${enable_languages},:${enable_objc_gc} in *,objc,*:yes|*,objc,*:auto)\n   fi\n esac\n \n-# Disable libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n+# Disable libitm, libsanitizer, libvtv if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n     # Disable libitm, libsanitizer if we're not building libstdc++\n@@ -2346,7 +2293,7 @@ case ,${enable_languages}, in\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "1f6e192082969f72a1a57d87007b3ef9036b5fe0", "filename": "contrib/gcc-changelog/git_commit.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fgcc-changelog%2Fgit_commit.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fgcc-changelog%2Fgit_commit.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_commit.py?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -67,7 +67,6 @@\n     'libiberty',\n     'libitm',\n     'libobjc',\n-    'liboffloadmic',\n     'libphobos',\n     'libquadmath',\n     'libsanitizer',"}, {"sha": "c5630df6c4cee84173c815c55e2963c0cb5657f7", "filename": "contrib/gcc_update", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -162,12 +162,6 @@ libsanitizer/sanitizer_common/Makefile.in: libsanitizer/sanitizer_common/Makefil\n libvtv/aclocal.m4: libvtv/configure.ac libvtv/acinclude.m4\n libvtv/Makefile.in: libvtv/Makefile.am libvtv/aclocal.m4\n libvtv/configure: libvtv/configure.ac libvtv/aclocal.m4\n-liboffloadmic/aclocal.m4: liboffloadmic/configure.ac\n-liboffloadmic/Makefile.in: liboffloadmic/Makefile.am\n-liboffloadmic/configure: liboffloadmic/configure.ac\n-liboffloadmic/plugin/aclocal.m4: liboffloadmic/plugin/configure.ac\n-liboffloadmic/plugin/Makefile.in: liboffloadmic/plugin/Makefile.am\n-liboffloadmic/plugin/configure: liboffloadmic/plugin/configure.ac\n libbacktrace/aclocal.m4: libbacktrace/configure.ac\n libbacktrace/Makefile.in: libbacktrace/Makefile.am libbacktrace/aclocal.m4\n libbacktrace/configure: libbacktrace/configure.ac libbacktrace/aclocal.m4"}, {"sha": "76614ffc4ea4e0ae062cd3366aaf27eb8767f3ba", "filename": "contrib/update-copyright.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fupdate-copyright.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/contrib%2Fupdate-copyright.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fupdate-copyright.py?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -760,7 +760,6 @@ def __init__ (self):\n         self.add_dir ('libiberty')\n         self.add_dir ('libitm')\n         self.add_dir ('libobjc')\n-        # liboffloadmic is imported from upstream.\n         self.add_dir ('libphobos', LibPhobosFilter())\n         self.add_dir ('libquadmath')\n         # libsanitizer is imported from upstream."}, {"sha": "f41c0959fbe72b3659a2d9100e26b7bd3d9276d9", "filename": "gcc/config.gcc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -3552,14 +3552,6 @@ case ${target} in\n \t;;\n esac\n \n-# Build mkoffload tool\n-case ${target} in\n-*-intelmic-* | *-intelmicemul-*)\n-\ttmake_file=\"${tmake_file} i386/t-intelmic\"\n-\ttm_file=\"${tm_file} i386/intelmic-offload.h\"\n-\t;;\n-esac\n-\n if [ \"$target_has_targetcm\" = \"no\" ]; then\n   c_target_objs=\"$c_target_objs default-c.o\"\n   cxx_target_objs=\"$cxx_target_objs default-c.o\""}, {"sha": "2c16dc0cf96d4412d22c887e30c81daecbc69936", "filename": "gcc/config/i386/i386-options.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.cc?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -314,10 +314,6 @@ ix86_omp_device_kind_arch_isa (enum omp_device_kind_arch_isa trait,\n     case omp_device_kind:\n       return strcmp (name, \"cpu\") == 0;\n     case omp_device_arch:\n-#ifdef ACCEL_COMPILER\n-      if (strcmp (name, \"intel_mic\") == 0)\n-\treturn 1;\n-#endif\n       if (strcmp (name, \"x86\") == 0)\n \treturn 1;\n       if (TARGET_64BIT)"}, {"sha": "5deddff6ca213d47adb8aaad5cde141b4653e488", "filename": "gcc/config/i386/intelmic-mkoffload.cc", "status": "removed", "additions": 0, "deletions": 728, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.cc?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,728 +0,0 @@\n-/* Offload image generation tool for Intel MIC devices.\n-\n-   Copyright (C) 2014-2022 Free Software Foundation, Inc.\n-\n-   Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define IN_TARGET_CODE 1\n-\n-#include \"config.h\"\n-#include <libgen.h>\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"obstack.h\"\n-#include \"intl.h\"\n-#include \"diagnostic.h\"\n-#include \"collect-utils.h\"\n-#include \"intelmic-offload.h\"\n-\n-const char tool_name[] = \"intelmic mkoffload\";\n-\n-const char image_section_name[] = \".gnu.offload_images\";\n-const char *symbols[3] = { \"__offload_image_intelmic_start\",\n-\t\t\t   \"__offload_image_intelmic_end\",\n-\t\t\t   \"__offload_image_intelmic_size\" };\n-const char *out_obj_filename = NULL;\n-\n-int num_temps = 0;\n-const int MAX_NUM_TEMPS = 10;\n-const char *temp_files[MAX_NUM_TEMPS];\n-\n-enum offload_abi offload_abi = OFFLOAD_ABI_UNSET;\n-\n-/* Delete tempfiles and exit function.  */\n-\n-void\n-tool_cleanup (bool from_signal ATTRIBUTE_UNUSED)\n-{\n-  for (int i = 0; i < num_temps; i++)\n-    maybe_unlink (temp_files[i]);\n-}\n-\n-static void\n-mkoffload_cleanup (void)\n-{\n-  tool_cleanup (false);\n-}\n-\n-/* Unlink FILE unless requested otherwise.  */\n-\n-void\n-maybe_unlink (const char *file)\n-{\n-  if (!save_temps)\n-    {\n-      if (unlink_if_ordinary (file)\n-\t  && errno != ENOENT)\n-\tfatal_error (input_location, \"deleting file %s: %m\", file);\n-    }\n-  else if (verbose)\n-    fprintf (stderr, \"[Leaving %s]\\n\", file);\n-}\n-\n-/* Add or change the value of an environment variable, outputting the\n-   change to standard error if in verbose mode.  */\n-static void\n-xputenv (const char *string)\n-{\n-  if (verbose)\n-    fprintf (stderr, \"%s\\n\", string);\n-  putenv (CONST_CAST (char *, string));\n-}\n-\n-/* Parse STR, saving found tokens into PVALUES and return their number.\n-   Tokens are assumed to be delimited by ':'.  */\n-static unsigned\n-parse_env_var (const char *str, char ***pvalues)\n-{\n-  const char *curval, *nextval;\n-  char **values;\n-  unsigned num = 1, i;\n-\n-  curval = strchr (str, ':');\n-  while (curval)\n-    {\n-      num++;\n-      curval = strchr (curval + 1, ':');\n-    }\n-\n-  values = (char **) xmalloc (num * sizeof (char *));\n-  curval = str;\n-  nextval = strchr (curval, ':');\n-  if (nextval == NULL)\n-    nextval = strchr (curval, '\\0');\n-\n-  for (i = 0; i < num; i++)\n-    {\n-      int l = nextval - curval;\n-      values[i] = (char *) xmalloc (l + 1);\n-      memcpy (values[i], curval, l);\n-      values[i][l] = 0;\n-      curval = nextval + 1;\n-      nextval = strchr (curval, ':');\n-      if (nextval == NULL)\n-\tnextval = strchr (curval, '\\0');\n-    }\n-  *pvalues = values;\n-  return num;\n-}\n-\n-/* Auxiliary function that frees elements of PTR and PTR itself.\n-   N is number of elements to be freed.  If PTR is NULL, nothing is freed.\n-   If an element is NULL, subsequent elements are not freed.  */\n-static void\n-free_array_of_ptrs (void **ptr, unsigned n)\n-{\n-  unsigned i;\n-  if (!ptr)\n-    return;\n-  for (i = 0; i < n; i++)\n-    {\n-      if (!ptr[i])\n-\tbreak;\n-      free (ptr[i]);\n-    }\n-  free (ptr);\n-  return;\n-}\n-\n-/* Check whether NAME can be accessed in MODE.  This is like access,\n-   except that it never considers directories to be executable.  */\n-static int\n-access_check (const char *name, int mode)\n-{\n-  if (mode == X_OK)\n-    {\n-      struct stat st;\n-\n-      if (stat (name, &st) < 0 || S_ISDIR (st.st_mode))\n-\treturn -1;\n-    }\n-\n-  return access (name, mode);\n-}\n-\n-/* Find target compiler using a path from COLLECT_GCC or COMPILER_PATH.  */\n-static char *\n-find_target_compiler (const char *name)\n-{\n-  bool found = false;\n-  char **paths = NULL;\n-  unsigned n_paths, i;\n-  char *target_compiler;\n-  const char *collect_gcc = getenv (\"COLLECT_GCC\");\n-  const char *gcc_path = dirname (ASTRDUP (collect_gcc));\n-  const char *gcc_exec = basename (ASTRDUP (collect_gcc));\n-\n-  if (strcmp (gcc_exec, collect_gcc) == 0)\n-    {\n-      /* collect_gcc has no path, so it was found in PATH.  Make sure we also\n-\t find accel-gcc in PATH.  */\n-      target_compiler = XDUPVEC (char, name, strlen (name) + 1);\n-      found = true;\n-      goto out;\n-    }\n-\n-  target_compiler = concat (gcc_path, \"/\", name, NULL);\n-  if (access_check (target_compiler, X_OK) == 0)\n-    {\n-      found = true;\n-      goto out;\n-    }\n-\n-  n_paths = parse_env_var (getenv (\"COMPILER_PATH\"), &paths);\n-  for (i = 0; i < n_paths; i++)\n-    {\n-      size_t len = strlen (paths[i]) + 1 + strlen (name) + 1;\n-      target_compiler = XRESIZEVEC (char, target_compiler, len);\n-      sprintf (target_compiler, \"%s/%s\", paths[i], name);\n-      if (access_check (target_compiler, X_OK) == 0)\n-\t{\n-\t  found = true;\n-\t  break;\n-\t}\n-    }\n-\n-out:\n-  free_array_of_ptrs ((void **) paths, n_paths);\n-  return found ? target_compiler : NULL;\n-}\n-\n-static void\n-compile_for_target (struct obstack *argv_obstack)\n-{\n-  switch (offload_abi)\n-    {\n-    case OFFLOAD_ABI_LP64:\n-      obstack_ptr_grow (argv_obstack, \"-m64\");\n-      break;\n-    case OFFLOAD_ABI_ILP32:\n-      obstack_ptr_grow (argv_obstack, \"-m32\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  obstack_ptr_grow (argv_obstack, NULL);\n-  char **argv = XOBFINISH (argv_obstack, char **);\n-\n-  /* Save environment variables.  */\n-  const char *epath = getenv (\"GCC_EXEC_PREFIX\");\n-  const char *cpath = getenv (\"COMPILER_PATH\");\n-  const char *lpath = getenv (\"LIBRARY_PATH\");\n-  const char *rpath = getenv (\"LD_RUN_PATH\");\n-  unsetenv (\"GCC_EXEC_PREFIX\");\n-  unsetenv (\"COMPILER_PATH\");\n-  unsetenv (\"LIBRARY_PATH\");\n-  unsetenv (\"LD_RUN_PATH\");\n-\n-  fork_execute (argv[0], argv, false, NULL);\n-  obstack_free (argv_obstack, NULL);\n-\n-  /* Restore environment variables.  */\n-  xputenv (concat (\"GCC_EXEC_PREFIX=\", epath, NULL));\n-  xputenv (concat (\"COMPILER_PATH=\", cpath, NULL));\n-  xputenv (concat (\"LIBRARY_PATH=\", lpath, NULL));\n-  xputenv (concat (\"LD_RUN_PATH=\", rpath, NULL));\n-}\n-\n-/* Generates object file with the descriptor for the target library.  */\n-static const char *\n-generate_target_descr_file (const char *target_compiler)\n-{\n-  char *dump_filename = concat (dumppfx, \"_target_descr.c\", NULL);\n-  const char *src_filename = save_temps\n-    ? dump_filename\n-    : make_temp_file (\"_target_descr.c\");\n-  const char *obj_filename = save_temps\n-    ? concat (dumppfx, \"_target_descr.o\", NULL)\n-    : make_temp_file (\"_target_descr.o\");\n-  temp_files[num_temps++] = src_filename;\n-  temp_files[num_temps++] = obj_filename;\n-  FILE *src_file = fopen (src_filename, \"w\");\n-\n-  if (!src_file)\n-    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n-\n-  fprintf (src_file,\n-\t   \"extern const void *const __offload_funcs_end[];\\n\"\n-\t   \"extern const void *const __offload_vars_end[];\\n\\n\"\n-\n-\t   \"const void *const __offload_func_table[0]\\n\"\n-\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n-\t   \"section (\\\".gnu.offload_funcs\\\"))) = { };\\n\\n\"\n-\n-\t   \"const void *const __offload_var_table[0]\\n\"\n-\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n-\t   \"section (\\\".gnu.offload_vars\\\"))) = { };\\n\\n\"\n-\n-\t   \"const void *const __OFFLOAD_TARGET_TABLE__[]\\n\"\n-\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"))) = {\\n\"\n-\t   \"  &__offload_func_table, &__offload_funcs_end,\\n\"\n-\t   \"  &__offload_var_table, &__offload_vars_end\\n\"\n-\t   \"};\\n\\n\");\n-\n-  fprintf (src_file,\n-\t   \"#ifdef __cplusplus\\n\"\n-\t   \"extern \\\"C\\\"\\n\"\n-\t   \"#endif\\n\"\n-\t   \"void target_register_lib (const void *);\\n\\n\"\n-\n-\t   \"__attribute__((constructor))\\n\"\n-\t   \"static void\\n\"\n-\t   \"init (void)\\n\"\n-\t   \"{\\n\"\n-\t   \"  target_register_lib (__OFFLOAD_TARGET_TABLE__);\\n\"\n-\t   \"}\\n\");\n-  fclose (src_file);\n-\n-  struct obstack argv_obstack;\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, target_compiler);\n-  if (save_temps)\n-    obstack_ptr_grow (&argv_obstack, \"-save-temps\");\n-  if (verbose)\n-    obstack_ptr_grow (&argv_obstack, \"-v\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpdir\");\n-  obstack_ptr_grow (&argv_obstack, \"\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase\");\n-  obstack_ptr_grow (&argv_obstack, dump_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase-ext\");\n-  obstack_ptr_grow (&argv_obstack, \".c\");\n-  obstack_ptr_grow (&argv_obstack, \"-c\");\n-  obstack_ptr_grow (&argv_obstack, \"-shared\");\n-  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n-  obstack_ptr_grow (&argv_obstack, src_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-o\");\n-  obstack_ptr_grow (&argv_obstack, obj_filename);\n-  compile_for_target (&argv_obstack);\n-\n-  return obj_filename;\n-}\n-\n-/* Generates object file with __offload_*_end symbols for the target\n-   library.  */\n-static const char *\n-generate_target_offloadend_file (const char *target_compiler)\n-{\n-  char *dump_filename = concat (dumppfx, \"_target_offloadend.c\", NULL);\n-  const char *src_filename = save_temps\n-    ? dump_filename\n-    : make_temp_file (\"_target_offloadend.c\");\n-  const char *obj_filename = save_temps\n-    ? concat (dumppfx, \"_target_offloadend.o\", NULL)\n-    : make_temp_file (\"_target_offloadend.o\");\n-  temp_files[num_temps++] = src_filename;\n-  temp_files[num_temps++] = obj_filename;\n-  FILE *src_file = fopen (src_filename, \"w\");\n-\n-  if (!src_file)\n-    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n-\n-  fprintf (src_file,\n-\t   \"const void *const __offload_funcs_end[0]\\n\"\n-\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n-\t   \"section (\\\".gnu.offload_funcs\\\"))) = { };\\n\\n\"\n-\n-\t   \"const void *const __offload_vars_end[0]\\n\"\n-\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n-\t   \"section (\\\".gnu.offload_vars\\\"))) = { };\\n\");\n-  fclose (src_file);\n-\n-  struct obstack argv_obstack;\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, target_compiler);\n-  if (save_temps)\n-    obstack_ptr_grow (&argv_obstack, \"-save-temps\");\n-  if (verbose)\n-    obstack_ptr_grow (&argv_obstack, \"-v\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpdir\");\n-  obstack_ptr_grow (&argv_obstack, \"\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase\");\n-  obstack_ptr_grow (&argv_obstack, dump_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase-ext\");\n-  obstack_ptr_grow (&argv_obstack, \".c\");\n-  obstack_ptr_grow (&argv_obstack, \"-c\");\n-  obstack_ptr_grow (&argv_obstack, \"-shared\");\n-  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n-  obstack_ptr_grow (&argv_obstack, src_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-o\");\n-  obstack_ptr_grow (&argv_obstack, obj_filename);\n-  compile_for_target (&argv_obstack);\n-\n-  return obj_filename;\n-}\n-\n-/* Generates object file with the host side descriptor.  */\n-static const char *\n-generate_host_descr_file (const char *host_compiler, uint32_t omp_requires)\n-{\n-  char *dump_filename = concat (dumppfx, \"_host_descr.c\", NULL);\n-  const char *src_filename = save_temps\n-    ? dump_filename\n-    : make_temp_file (\"_host_descr.c\");\n-  const char *obj_filename = save_temps\n-    ? concat (dumppfx, \"_host_descr.o\", NULL)\n-    : make_temp_file (\"_host_descr.o\");\n-  temp_files[num_temps++] = src_filename;\n-  temp_files[num_temps++] = obj_filename;\n-  FILE *src_file = fopen (src_filename, \"w\");\n-\n-  if (!src_file)\n-    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n-\n-  fprintf (src_file, \"#include <stdint.h>\\n\\n\");\n-\n-  fprintf (src_file,\n-\t   \"extern const void *const __OFFLOAD_TABLE__;\\n\"\n-\t   \"extern const void *const __offload_image_intelmic_start;\\n\"\n-\t   \"extern const void *const __offload_image_intelmic_end;\\n\\n\"\n-\n-\t   \"static const struct intelmic_data {\\n\"\n-\t   \"  uintptr_t omp_requires_mask;\\n\"\n-\t   \"  const void *const image_start;\\n\"\n-\t   \"  const void *const image_end;\\n\"\n-\t   \"} intelmic_data = {\\n\"\n-\t   \"  %d,\\n\"\n-\t   \"  &__offload_image_intelmic_start, &__offload_image_intelmic_end\\n\"\n-\t   \"};\\n\\n\", omp_requires);\n-\n-  fprintf (src_file,\n-\t   \"#ifdef __cplusplus\\n\"\n-\t   \"extern \\\"C\\\"\\n\"\n-\t   \"#endif\\n\"\n-\t   \"void GOMP_offload_register_ver (unsigned, const void *, int, const void *);\\n\"\n-\t   \"#ifdef __cplusplus\\n\"\n-\t   \"extern \\\"C\\\"\\n\"\n-\t   \"#endif\\n\"\n-\t   \"void GOMP_offload_unregister_ver (unsigned, const void *, int, const void *);\\n\\n\"\n-\n-\t   \"__attribute__((constructor))\\n\"\n-\t   \"static void\\n\"\n-\t   \"init (void)\\n\"\n-\t   \"{\\n\"\n-\t   \"  GOMP_offload_register_ver (%#x, &__OFFLOAD_TABLE__, %d, &intelmic_data);\\n\"\n-\t   \"}\\n\\n\",\n-\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_INTEL_MIC),\n-\t   GOMP_DEVICE_INTEL_MIC);\n-\n-  fprintf (src_file,\n-\t   \"__attribute__((destructor))\\n\"\n-\t   \"static void\\n\"\n-\t   \"fini (void)\\n\"\n-\t   \"{\\n\"\n-\t   \"  GOMP_offload_unregister_ver (%#x, &__OFFLOAD_TABLE__, %d, &intelmic_data);\\n\"\n-\t   \"}\\n\",\n-\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_INTEL_MIC),\n-\t   GOMP_DEVICE_INTEL_MIC);\n-\n-  fclose (src_file);\n-\n-  struct obstack argv_obstack;\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, host_compiler);\n-  if (save_temps)\n-    obstack_ptr_grow (&argv_obstack, \"-save-temps\");\n-  if (verbose)\n-    obstack_ptr_grow (&argv_obstack, \"-v\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpdir\");\n-  obstack_ptr_grow (&argv_obstack, \"\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase\");\n-  obstack_ptr_grow (&argv_obstack, dump_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase-ext\");\n-  obstack_ptr_grow (&argv_obstack, \".c\");\n-  obstack_ptr_grow (&argv_obstack, \"-c\");\n-  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n-  obstack_ptr_grow (&argv_obstack, \"-shared\");\n-  switch (offload_abi)\n-    {\n-    case OFFLOAD_ABI_LP64:\n-      obstack_ptr_grow (&argv_obstack, \"-m64\");\n-      break;\n-    case OFFLOAD_ABI_ILP32:\n-      obstack_ptr_grow (&argv_obstack, \"-m32\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  obstack_ptr_grow (&argv_obstack, src_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-o\");\n-  obstack_ptr_grow (&argv_obstack, obj_filename);\n-  obstack_ptr_grow (&argv_obstack, NULL);\n-\n-  char **argv = XOBFINISH (&argv_obstack, char **);\n-  fork_execute (argv[0], argv, false, NULL);\n-  obstack_free (&argv_obstack, NULL);\n-\n-  return obj_filename;\n-}\n-\n-static const char *\n-prepare_target_image (const char *target_compiler, int argc, char **argv, uint32_t *omp_requires)\n-{\n-  const char *target_descr_filename\n-    = generate_target_descr_file (target_compiler);\n-  const char *target_offloadend_filename\n-    = generate_target_offloadend_file (target_compiler);\n-\n-  char *opt1\n-    = XALLOCAVEC (char, sizeof (\"-Wl,\") + strlen (target_descr_filename));\n-  char *opt2\n-    = XALLOCAVEC (char, sizeof (\"-Wl,\") + strlen (target_offloadend_filename));\n-  sprintf (opt1, \"-Wl,%s\", target_descr_filename);\n-  sprintf (opt2, \"-Wl,%s\", target_offloadend_filename);\n-\n-  char *dump_filename = concat (dumppfx, \".mkoffload\", NULL);\n-  const char *target_so_filename = save_temps\n-    ? concat (dumppfx, \"_offload_intelmic.so\", NULL)\n-    : make_temp_file (\"_offload_intelmic.so\");\n-  temp_files[num_temps++] = target_so_filename;\n-  struct obstack argv_obstack;\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, target_compiler);\n-  if (save_temps)\n-    obstack_ptr_grow (&argv_obstack, \"-save-temps\");\n-  if (verbose)\n-    obstack_ptr_grow (&argv_obstack, \"-v\");\n-  obstack_ptr_grow (&argv_obstack, \"-xlto\");\n-  obstack_ptr_grow (&argv_obstack, opt1);\n-  for (int i = 1; i < argc; i++)\n-    {\n-      if (!strcmp (argv[i], \"-o\") && i + 1 != argc)\n-\t++i;\n-      else\n-\tobstack_ptr_grow (&argv_obstack, argv[i]);\n-    }\n-  obstack_ptr_grow (&argv_obstack, opt2);\n-  /* NB: Put -fPIC and -shared the last to create shared library.  */\n-  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n-  obstack_ptr_grow (&argv_obstack, \"-shared\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpdir\");\n-  obstack_ptr_grow (&argv_obstack, \"\");\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase\");\n-  obstack_ptr_grow (&argv_obstack, dump_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-dumpbase-ext\");\n-  obstack_ptr_grow (&argv_obstack, \"\");\n-  obstack_ptr_grow (&argv_obstack, \"-o\");\n-  obstack_ptr_grow (&argv_obstack, target_so_filename);\n-\n-  char *omp_requires_file;\n-  if (save_temps)\n-    omp_requires_file = concat (dumppfx, \".mkoffload.omp_requires\", NULL);\n-  else\n-    omp_requires_file = make_temp_file (\".mkoffload.omp_requires\");\n-  temp_files[num_temps++] = omp_requires_file;\n-  xputenv (concat (\"GCC_OFFLOAD_OMP_REQUIRES_FILE=\", omp_requires_file, NULL));\n-\n-  compile_for_target (&argv_obstack);\n-\n-  unsetenv(\"GCC_OFFLOAD_OMP_REQUIRES_FILE\");\n-  FILE *in = fopen (omp_requires_file, \"rb\");\n-  if (!in)\n-    fatal_error (input_location, \"cannot open omp_requires file %qs\",\n-\t\t omp_requires_file);\n-  if (fread (omp_requires, sizeof (*omp_requires), 1, in) != 1)\n-    fatal_error (input_location, \"cannot read omp_requires file %qs\",\n-\t\t omp_requires_file);\n-  fclose (in);\n-\n-  /* Run objcopy.  */\n-  char *rename_section_opt\n-    = XALLOCAVEC (char, sizeof (\".data=\") + strlen (image_section_name));\n-  sprintf (rename_section_opt, \".data=%s\", image_section_name);\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, \"objcopy\");\n-  obstack_ptr_grow (&argv_obstack, \"-B\");\n-  obstack_ptr_grow (&argv_obstack, \"i386\");\n-  obstack_ptr_grow (&argv_obstack, \"-I\");\n-  obstack_ptr_grow (&argv_obstack, \"binary\");\n-  obstack_ptr_grow (&argv_obstack, \"-O\");\n-  switch (offload_abi)\n-    {\n-    case OFFLOAD_ABI_LP64:\n-      obstack_ptr_grow (&argv_obstack, \"elf64-x86-64\");\n-      break;\n-    case OFFLOAD_ABI_ILP32:\n-      obstack_ptr_grow (&argv_obstack, \"elf32-i386\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  obstack_ptr_grow (&argv_obstack, target_so_filename);\n-  obstack_ptr_grow (&argv_obstack, \"--rename-section\");\n-  obstack_ptr_grow (&argv_obstack, rename_section_opt);\n-  obstack_ptr_grow (&argv_obstack, NULL);\n-  char **new_argv = XOBFINISH (&argv_obstack, char **);\n-  fork_execute (new_argv[0], new_argv, false, NULL);\n-  obstack_free (&argv_obstack, NULL);\n-\n-  /* Objcopy has created symbols, containing the input file name with\n-     non-alphanumeric characters replaced by underscores.\n-     We are going to rename these new symbols.  */\n-  size_t symbol_name_len = strlen (target_so_filename);\n-  char *symbol_name = XALLOCAVEC (char, symbol_name_len + 1);\n-  for (size_t i = 0; i < symbol_name_len; i++)\n-    {\n-      char c = target_so_filename[i];\n-      if (!ISALNUM (c))\n-\tc = '_';\n-      symbol_name[i] = c;\n-    }\n-  symbol_name[symbol_name_len] = '\\0';\n-\n-  char *opt_for_objcopy[3];\n-  opt_for_objcopy[0] = XALLOCAVEC (char, sizeof (\"_binary__start=\")\n-\t\t\t\t\t + symbol_name_len\n-\t\t\t\t\t + strlen (symbols[0]));\n-  opt_for_objcopy[1] = XALLOCAVEC (char, sizeof (\"_binary__end=\")\n-\t\t\t\t\t + symbol_name_len\n-\t\t\t\t\t + strlen (symbols[1]));\n-  opt_for_objcopy[2] = XALLOCAVEC (char, sizeof (\"_binary__size=\")\n-\t\t\t\t\t + symbol_name_len\n-\t\t\t\t\t + strlen (symbols[2]));\n-  sprintf (opt_for_objcopy[0], \"_binary_%s_start=%s\", symbol_name, symbols[0]);\n-  sprintf (opt_for_objcopy[1], \"_binary_%s_end=%s\", symbol_name, symbols[1]);\n-  sprintf (opt_for_objcopy[2], \"_binary_%s_size=%s\", symbol_name, symbols[2]);\n-\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, \"objcopy\");\n-  obstack_ptr_grow (&argv_obstack, target_so_filename);\n-  obstack_ptr_grow (&argv_obstack, \"--redefine-sym\");\n-  obstack_ptr_grow (&argv_obstack, opt_for_objcopy[0]);\n-  obstack_ptr_grow (&argv_obstack, \"--redefine-sym\");\n-  obstack_ptr_grow (&argv_obstack, opt_for_objcopy[1]);\n-  obstack_ptr_grow (&argv_obstack, \"--redefine-sym\");\n-  obstack_ptr_grow (&argv_obstack, opt_for_objcopy[2]);\n-  obstack_ptr_grow (&argv_obstack, NULL);\n-  new_argv = XOBFINISH (&argv_obstack, char **);\n-  fork_execute (new_argv[0], new_argv, false, NULL);\n-  obstack_free (&argv_obstack, NULL);\n-\n-  return target_so_filename;\n-}\n-\n-int\n-main (int argc, char **argv)\n-{\n-  progname = \"mkoffload-intelmic\";\n-  gcc_init_libintl ();\n-  diagnostic_initialize (global_dc, 0);\n-\n-  if (atexit (mkoffload_cleanup) != 0)\n-    fatal_error (input_location, \"atexit failed\");\n-\n-  const char *host_compiler = getenv (\"COLLECT_GCC\");\n-  if (!host_compiler)\n-    fatal_error (input_location, \"COLLECT_GCC must be set\");\n-\n-  const char *target_driver_name = GCC_INSTALL_NAME;\n-  char *target_compiler = find_target_compiler (target_driver_name);\n-  if (target_compiler == NULL)\n-    fatal_error (input_location, \"offload compiler %s not found\",\n-\t\t target_driver_name);\n-\n-  /* We may be called with all the arguments stored in some file and\n-     passed with @file.  Expand them into argv before processing.  */\n-  expandargv (&argc, &argv);\n-\n-  /* Scan the argument vector.  */\n-  for (int i = 1; i < argc; i++)\n-    {\n-#define STR \"-foffload-abi=\"\n-      if (startswith (argv[i], STR))\n-\t{\n-\t  if (strcmp (argv[i] + strlen (STR), \"lp64\") == 0)\n-\t    offload_abi = OFFLOAD_ABI_LP64;\n-\t  else if (strcmp (argv[i] + strlen (STR), \"ilp32\") == 0)\n-\t    offload_abi = OFFLOAD_ABI_ILP32;\n-\t  else\n-\t    fatal_error (input_location,\n-\t\t\t \"unrecognizable argument of option \" STR);\n-\t}\n-#undef STR\n-      else if (strcmp (argv[i], \"-save-temps\") == 0)\n-\tsave_temps = true;\n-      else if (strcmp (argv[i], \"-v\") == 0)\n-\tverbose = true;\n-      else if (strcmp (argv[i], \"-dumpbase\") == 0\n-\t       && i + 1 < argc)\n-\tdumppfx = argv[++i];\n-      else if (strcmp (argv[i], \"-o\") == 0\n-\t       && i + 1 < argc)\n-\tout_obj_filename = argv[++i];\n-    }\n-\n-  if (!out_obj_filename)\n-    fatal_error (input_location, \"output file not specified\");\n-\n-  if (!dumppfx)\n-    dumppfx = out_obj_filename;\n-\n-  uint32_t omp_requires;\n-\n-  const char *target_so_filename\n-    = prepare_target_image (target_compiler, argc, argv, &omp_requires);\n-\n-  const char *host_descr_filename\n-    = generate_host_descr_file (host_compiler, omp_requires);\n-\n-  /* Perform partial linking for the target image and host side descriptor.\n-     As a result we'll get a finalized object file with all offload data.  */\n-  struct obstack argv_obstack;\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, \"ld\");\n-  obstack_ptr_grow (&argv_obstack, \"-m\");\n-  switch (offload_abi)\n-    {\n-    case OFFLOAD_ABI_LP64:\n-      obstack_ptr_grow (&argv_obstack, \"elf_x86_64\");\n-      break;\n-    case OFFLOAD_ABI_ILP32:\n-      obstack_ptr_grow (&argv_obstack, \"elf_i386\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  obstack_ptr_grow (&argv_obstack, \"--relocatable\");\n-  obstack_ptr_grow (&argv_obstack, host_descr_filename);\n-  obstack_ptr_grow (&argv_obstack, target_so_filename);\n-  obstack_ptr_grow (&argv_obstack, \"-o\");\n-  obstack_ptr_grow (&argv_obstack, out_obj_filename);\n-  obstack_ptr_grow (&argv_obstack, NULL);\n-  char **new_argv = XOBFINISH (&argv_obstack, char **);\n-  fork_execute (new_argv[0], new_argv, false, NULL);\n-  obstack_free (&argv_obstack, NULL);\n-\n-  /* Run objcopy on the resultant object file to localize generated symbols\n-     to avoid conflicting between different DSO and an executable.  */\n-  obstack_init (&argv_obstack);\n-  obstack_ptr_grow (&argv_obstack, \"objcopy\");\n-  obstack_ptr_grow (&argv_obstack, \"-L\");\n-  obstack_ptr_grow (&argv_obstack, symbols[0]);\n-  obstack_ptr_grow (&argv_obstack, \"-L\");\n-  obstack_ptr_grow (&argv_obstack, symbols[1]);\n-  obstack_ptr_grow (&argv_obstack, \"-L\");\n-  obstack_ptr_grow (&argv_obstack, symbols[2]);\n-  obstack_ptr_grow (&argv_obstack, out_obj_filename);\n-  obstack_ptr_grow (&argv_obstack, NULL);\n-  new_argv = XOBFINISH (&argv_obstack, char **);\n-  fork_execute (new_argv[0], new_argv, false, NULL);\n-  obstack_free (&argv_obstack, NULL);\n-\n-  return 0;\n-}"}, {"sha": "42ce0d8d57a801a36996f3b586d1ec2b364db4a9", "filename": "gcc/config/i386/intelmic-offload.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,35 +0,0 @@\n-/* Support for Intel MIC offloading.\n-\n-   Copyright (C) 2014-2022 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef INTELMIC_OFFLOAD_H\n-#define INTELMIC_OFFLOAD_H\n-\n-/* Support for OpenACC acc_on_device.  */\n-\n-#include \"gomp-constants.h\"\n-\n-#define ACCEL_COMPILER_acc_device GOMP_DEVICE_INTEL_MIC\n-\n-#endif"}, {"sha": "95d7e53231516726958191f83cc684353896259d", "filename": "gcc/config/i386/t-intelmic", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Ft-intelmic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Ft-intelmic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-intelmic?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,10 +0,0 @@\n-CFLAGS-mkoffload.o += $(DRIVER_DEFINES) -DGCC_INSTALL_NAME=\\\"$(GCC_INSTALL_NAME)\\\"\n-\n-mkoffload.o: $(srcdir)/config/i386/intelmic-mkoffload.cc\n-\t$(COMPILE) $<\n-\t$(POSTCOMPILE)\n-ALL_HOST_OBJS += mkoffload.o\n-\n-mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBDEPS)\n-\t$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)"}, {"sha": "cfb41ed71ce2537370e934586196abd90c8fa4ea", "filename": "gcc/config/i386/t-omp-device", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Ft-omp-device", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/gcc%2Fconfig%2Fi386%2Ft-omp-device", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-omp-device?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,6 +0,0 @@\n-omp-device-properties-i386: $(srcdir)/config/i386/i386-options.cc\n-\techo kind: cpu > $@\n-\techo arch: intel_mic x86 x86_64 i386 i486 i586 i686 ia32 >> $@\n-\techo isa: sse4 `sed -n '/^static struct ix86_target_opts isa2\\?_opts\\[\\] =/,/^};/p' \\\n-\t  $(srcdir)/config/i386/i386-options.cc | \\\n-\t  sed -n 's/\",.*$$//;s/^  { \"-m//p'` >> $@"}, {"sha": "aa0960991c92f130f53edcf70cc959b106efefe1", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -8253,12 +8253,6 @@ if test x\"$enable_as_accelerator_for\" != x; then\n $as_echo \"#define ACCEL_COMPILER 1\" >>confdefs.h\n \n   enable_as_accelerator=yes\n-  case \"${target}\" in\n-    *-intelmicemul-*)\n-      # In this case we expect offload compiler to be built as native, so we\n-      # need to rename the driver to avoid clashes with host's drivers.\n-      program_transform_name=\"s&^&${target}-&\" ;;\n-  esac\n   sedscript=\"s#${target_noncanonical}#${enable_as_accelerator_for}-accel-${target_noncanonical}#\"\n   program_transform_name=`echo $program_transform_name | sed $sedscript`\n   accel_dir_suffix=/accel/${target_noncanonical}\n@@ -8273,10 +8267,6 @@ for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n \n   enable_offloading=1\n   case \"$tgt\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-  \tomp_device_property=omp-device-properties-i386\n-  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n-  \t;;\n     amdgcn*)\n   \tomp_device_property=omp-device-properties-gcn\n   \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\"\n@@ -19720,7 +19710,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19723 \"configure\"\n+#line 19713 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19826,7 +19816,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19829 \"configure\"\n+#line 19819 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "7c55bff6cb0621a49f3d2fa95e5b6532344e64c3", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -1136,12 +1136,6 @@ if test x\"$enable_as_accelerator_for\" != x; then\n   AC_DEFINE(ACCEL_COMPILER, 1,\n     [Define if this compiler should be built as the offload target compiler.])\n   enable_as_accelerator=yes\n-  case \"${target}\" in\n-    *-intelmicemul-*)\n-      # In this case we expect offload compiler to be built as native, so we\n-      # need to rename the driver to avoid clashes with host's drivers.\n-      program_transform_name=\"s&^&${target}-&\" ;;\n-  esac\n   sedscript=\"s#${target_noncanonical}#${enable_as_accelerator_for}-accel-${target_noncanonical}#\"\n   program_transform_name=`echo $program_transform_name | sed $sedscript`\n   accel_dir_suffix=/accel/${target_noncanonical}\n@@ -1156,10 +1150,6 @@ for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n \n   enable_offloading=1\n   case \"$tgt\" in\n-    *-intelmic-* | *-intelmicemul-*)\n-  \tomp_device_property=omp-device-properties-i386\n-  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n-  \t;;\n     amdgcn*)\n   \tomp_device_property=omp-device-properties-gcn\n   \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\""}, {"sha": "a01b8053afef58f5553e9c6c888f6ae9b364773a", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -2337,7 +2337,7 @@ specifying paths @var{path1}, @dots{}, @var{pathN}.\n \n @smallexample\n % @var{srcdir}/configure \\\n-    --enable-offload-targets=x86_64-intelmicemul-linux-gnu=/path/to/x86_64/compiler,nvptx-none\n+    --enable-offload-targets=amdgcn-amdhsa,nvptx-none\n @end smallexample\n \n @item --enable-offload-defaulted"}, {"sha": "17a6f21f7b055a4805684c38efc67b4d61a43ad0", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -116,9 +116,6 @@ The runtime support library for transactional memory.\n @item libobjc\n The Objective-C and Objective-C++ runtime library.\n \n-@item liboffloadmic\n-A library to allow OpenMP to Intel MIC targets.\n-\n @item libphobos\n The D standard and runtime library.  The bulk of this library is mirrored\n from the @uref{https://github.com/@/dlang, master D repositories}."}, {"sha": "dfee037f40ec059c7258e67ca906822fa025aaa4", "filename": "include/gomp-constants.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -229,7 +229,7 @@ enum gomp_map_kind\n /* #define GOMP_DEVICE_HOST_NONSHM\t3 removed.  */\n #define GOMP_DEVICE_NOT_HOST\t\t4\n #define GOMP_DEVICE_NVIDIA_PTX\t\t5\n-#define GOMP_DEVICE_INTEL_MIC\t\t6\n+/* #define GOMP_DEVICE_INTEL_MIC\t6 removed.  */\n /* #define GOMP_DEVICE_HSA\t\t7 removed.  */\n #define GOMP_DEVICE_GCN\t\t\t8\n \n@@ -284,7 +284,6 @@ enum gomp_map_kind\n    to the plugin interface defined in libgomp/libgomp.h.  */\n #define GOMP_VERSION\t2\n #define GOMP_VERSION_NVIDIA_PTX 1\n-#define GOMP_VERSION_INTEL_MIC 0\n #define GOMP_VERSION_GCN 2\n \n #define GOMP_VERSION_PACK(LIB, DEV) (((LIB) << 16) | (DEV))"}, {"sha": "45a769eb10a4294be62a872a844c021b419513a9", "filename": "libgomp/configure", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -15200,9 +15200,6 @@ if test x\"$enable_offload_targets\" != x; then\n     tgt=`echo $tgt | sed 's/=.*//'`\n     tgt_plugin=\n     case $tgt in\n-      *-intelmic-* | *-intelmicemul-*)\n-\ttgt_plugin=intelmic\n-\t;;\n       nvptx*)\n \tcase \"${target}\" in\n \t  aarch64*-*-* | powerpc64le-*-* | x86_64-*-*)"}, {"sha": "ac387828950620a9f5f02d64ddc8441e868b2a6d", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -49,7 +49,6 @@ enum offload_target_type\n   OFFLOAD_TARGET_TYPE_HOST = 2,\n   /* OFFLOAD_TARGET_TYPE_HOST_NONSHM = 3 removed.  */\n   OFFLOAD_TARGET_TYPE_NVIDIA_PTX = 5,\n-  OFFLOAD_TARGET_TYPE_INTEL_MIC = 6,\n   OFFLOAD_TARGET_TYPE_HSA = 7,\n   OFFLOAD_TARGET_TYPE_GCN = 8\n };"}, {"sha": "10fefa97922c9370ba3dd24c4a880072db8b4b8b", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -4303,7 +4303,7 @@ offloading devices (it's not clear if they should be):\n \n @multitable @columnfractions .60 .10 .25\n @headitem @code{arch} @tab @code{kind} @tab @code{isa}\n-@item @code{intel_mic}, @code{x86}, @code{x86_64}, @code{i386}, @code{i486},\n+@item @code{x86}, @code{x86_64}, @code{i386}, @code{i486},\n       @code{i586}, @code{i686}, @code{ia32}\n       @tab @code{host}\n       @tab See @code{-m...} flags in ``x86 Options'' (without @code{-m})"}, {"sha": "d3b258901effb131ee9030cd4d96581295a428cf", "filename": "libgomp/plugin/configfrag.ac", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Fplugin%2Fconfigfrag.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Fplugin%2Fconfigfrag.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fconfigfrag.ac?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -59,9 +59,6 @@ if test x\"$enable_offload_targets\" != x; then\n     tgt=`echo $tgt | sed 's/=.*//'`\n     tgt_plugin=\n     case $tgt in\n-      *-intelmic-* | *-intelmicemul-*)\n-\ttgt_plugin=intelmic\n-\t;;\n       nvptx*)\n \tcase \"${target}\" in\n \t  aarch64*-*-* | powerpc64le-*-* | x86_64-*-*)"}, {"sha": "1801fdc822414e11ae56f67a670606f6901a3d7a", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -119,18 +119,6 @@ proc libgomp_init { args } {\n     # Compute what needs to be put into LD_LIBRARY_PATH\n     set always_ld_library_path \".:${blddir}/.libs\"\n \n-    # Add liboffloadmic build directory in LD_LIBRARY_PATH to support\n-    # Intel MIC offloading testing.\n-    global offload_plugins\n-    if { [string match \"*,intelmic,*\" \",$offload_plugins,\"] } {\n-\tappend always_ld_library_path \":${blddir}/../liboffloadmic/.libs\"\n-\tappend always_ld_library_path \":${blddir}/../liboffloadmic/plugin/.libs\"\n-\t# libstdc++ is required by liboffloadmic\n-\tappend always_ld_library_path \":${blddir}/../libstdc++-v3/src/.libs\"\n-\t# libgcc_s is required by libstdc++\n-\tappend always_ld_library_path \":${blddir}/../libgcc\"\n-    }\n-\n     global offload_additional_lib_paths\n     if { $offload_additional_lib_paths != \"\" } {\n \tappend always_ld_library_path \"${offload_additional_lib_paths}\"\n@@ -313,9 +301,6 @@ proc offload_target_to_openacc_device_type { offload_target } {\n \tdisable {\n \t    return \"host\"\n \t}\n-\t*-intelmic* {\n-\t    return \"\"\n-\t}\n \tnvptx* {\n \t    return \"nvidia\"\n \t}\n@@ -449,28 +434,6 @@ proc check_effective_target_openacc_nvidia_accel_selected { } {\n     return [string match \"nvidia\" $openacc_device_type]\n }\n \n-# Return 1 if using Intel MIC offload device.\n-proc check_effective_target_offload_device_intel_mic { } {\n-    return [check_runtime_nocache offload_device_intel_mic {\n-      #include \"testsuite/libgomp.c-c++-common/on_device_arch.h\"\n-      int main ()\n-\t{\n-\t  return !on_device_arch_intel_mic ();\n-\t}\n-    } ]\n-}\n-\n-# Return 1 if any Intel MIC offload device is available.\n-proc check_effective_target_offload_device_any_intel_mic { } {\n-    return [check_runtime_nocache offload_device_any_intel_mic {\n-      #include \"testsuite/libgomp.c-c++-common/on_device_arch.h\"\n-      int main ()\n-\t{\n-\t  return !any_device_arch_intel_mic ();\n-\t}\n-    } ]\n-}\n-\n # Return 1 if the OpenACC 'host' device type is selected.\n \n proc check_effective_target_openacc_host_selected { } {"}, {"sha": "3fb5021d67ea277a9cf9fe6f0128378340a9466f", "filename": "libgomp/testsuite/libgomp.c-c++-common/on_device_arch.h", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fon_device_arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fon_device_arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fon_device_arch.h?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -13,15 +13,8 @@ device_arch_gcn (void)\n   return GOMP_DEVICE_GCN;\n }\n \n-/* static */ int\n-device_arch_intel_mic (void)\n-{\n-  return GOMP_DEVICE_INTEL_MIC;\n-}\n-\n #pragma omp declare variant (device_arch_nvptx) match(construct={target},device={arch(nvptx)})\n #pragma omp declare variant (device_arch_gcn) match(construct={target},device={arch(gcn)})\n-#pragma omp declare variant (device_arch_intel_mic) match(construct={target},device={arch(intel_mic)})\n /* static */ int\n device_arch (void)\n {\n@@ -49,31 +42,3 @@ on_device_arch_gcn ()\n {\n   return on_device_arch (GOMP_DEVICE_GCN);\n }\n-\n-int\n-on_device_arch_intel_mic ()\n-{\n-  return on_device_arch (GOMP_DEVICE_INTEL_MIC);\n-}\n-\n-static int\n-any_device_arch (int d)\n-{\n-  int nd = omp_get_num_devices ();\n-  for (int i = 0; i < nd; ++i)\n-    {\n-      int d_cur;\n-      #pragma omp target device(i) map(from:d_cur)\n-      d_cur = device_arch ();\n-      if (d_cur == d)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-any_device_arch_intel_mic ()\n-{\n-  return any_device_arch (GOMP_DEVICE_INTEL_MIC);\n-}"}, {"sha": "73c105d58741be3fed54917227d8461b06d95773", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-45.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-45.c?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-xfail-run-if TODO { offload_device_any_intel_mic } } */\n-\n #include <omp.h>\n #include <stdlib.h>\n "}, {"sha": "4876ccea330bab110700fd80c7e7baa5c3357246", "filename": "libgomp/testsuite/libgomp.fortran/target10.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cba49413ca429dc82f6aa2e88129ecb3fdd943/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget10.f90?ref=e4cba49413ca429dc82f6aa2e88129ecb3fdd943", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do run }\n-! { dg-xfail-run-if TODO { offload_device_any_intel_mic } }\n \n program main\n   use omp_lib"}, {"sha": "90e7c4d11919223e26adbf28b9743ecdb124208e", "filename": "liboffloadmic/ChangeLog", "status": "removed", "additions": 0, "deletions": 765, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,765 +0,0 @@\n-2022-10-12  Martin Liska  <mliska@suse.cz>\n-\n-\t* configure: Regenerate.\n-\t* plugin/configure: Regenerate.\n-\n-2022-10-11  Olivier Hainque  <hainque@adacore.com>\n-\t    Olivier Hainque  <hainque@adacore.com>\n-\n-\t* plugin/configure: Regenerate.\n-\n-2022-10-11  Olivier Hainque  <hainque@adacore.com>\n-\t    Olivier Hainque  <hainque@adacore.com>\n-\n-\t* configure: Regenerate.\n-\n-2022-09-09  Tobias Burnus  <tobias@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_load_image):\n-\tAdd (unused) uint64_t **rev_fn_table argument.\n-\n-2022-08-25  Martin Liska  <mliska@suse.cz>\n-\n-\t* configure: Regenerate.\n-\t* plugin/configure: Regenerate.\n-\n-2022-07-04  Tobias Burnus  <tobias@codesourcery.com>\n-\t    Chung-Lin Tang  <cltang@codesourcery.com>\n-\t    Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_num_devices):\n-\tReturn -1 when device available but omp_requires_mask != 0.\n-\n-2021-10-19  Martin Liska  <mliska@suse.cz>\n-\n-\t* include/coi/source/COIBuffer_source.h: Convert 2 chars to\n-\tunicode.\n-\n-2021-05-25  Richard Biener  <rguenther@suse.de>\n-\n-\tPR libgomp/100747\n-\t* configure: Make executable.\n-\t* plugin/configure: Likewise.\n-\n-2021-01-05  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n-\n-\t* configure: Re-generate.\n-\t* plugin/configure: Re-generate.\n-\n-2020-11-29  John David Anglin  <danglin@gcc.gnu.org>\n-\n-\t* configure: Regenerate.\n-\t* plugin/configure: Regenerate.\n-\n-2020-05-05  Martin Liska  <mliska@suse.cz>\n-\n-\tPR other/89860\n-\t* runtime/offload_target.cpp: Put index check\n-\tbefore its use.\n-\n-2020-01-24  Maciej W. Rozycki  <macro@wdc.com>\n-\n-\t* plugin/configure.ac: Handle `--with-toolexeclibdir='.\n-\t* plugin/Makefile.in: Regenerate.\n-\t* plugin/aclocal.m4: Regenerate.\n-\t* plugin/configure: Regenerate.\n-\t* configure.ac: Handle `--with-toolexeclibdir='.\n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\n-2020-01-10  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_property):\n-\tRemove.\n-\n-2019-12-22  Maciej W. Rozycki  <macro@codesourcery.com>\n-\t    Frederik Harwath  <frederik@codesourcery.com>\n-\t    Thomas Schwinge  <tschwinge@codesourcery.com>\n-\n-\tliboffloadmic/\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_property):\n-\tNew function.\n-\n-2019-10-01  Maciej W. Rozycki  <macro@wdc.com>\n-\n-\t* plugin/configure: Regenerate.\n-\n-2019-09-27  Maciej W. Rozycki  <macro@wdc.com>\n-\n-\t* configure: Regenerate.\n-\n-2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n-\n-\tPR other/16615\n-\n-\t* include/coi/common/COIResult_common.h: Mechanically replace\n-\t\"can not\" with \"cannot\".\n-\t* include/coi/source/COIBuffer_source.h: Likewise.\n-\n-2018-12-14  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* runtime/offload.h (omp_target_is_present, omp_target_memcpy)\n-\t(omp_target_memcpy_rect, omp_target_associate_ptr)\n-\t(omp_target_disassociate_ptr): Adjust to libgomp changes.\n-\n-2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n-\n-\tPR bootstrap/82856\n-\t* Makefile.am: Include multilib.am.\n-\t* configure.ac: Remove AC_PREREQ.\n-\t* plugin/Makefile.am: Include multilib.am.\n-\t* plugin/configure.ac: Remove AC_PREREQ.\n-\t* Makefile.in, aclocal.m4, configure, plugin/Makefile.in,\n-\tplugin/aclocal.m4, plugin/configure: Regenerate.\n-\n-2018-04-18  David Malcolm  <dmalcolm@redhat.com>\n-\n-\tPR jit/85384\n-\t* configure: Regenerate.\n-\t* plugin/configure: Regenerate.\n-\n-2017-01-31  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_type): Fix\n-\treturn type.\n-\t(GOMP_OFFLOAD_load_image): Fix argument types.\n-\n-2017-01-21  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/79046\n-\t* plugin/configure.ac: Add GCC_BASE_VER.\n-\t* plugin/Makefile.am (gcc_version): Use @get_gcc_base_ver@ instead\n-\tof cat to get version from BASE-VER file.\n-\t* plugin/configure: Regenerated.\n-\t* plugin/aclocal.m4: Regenerated.\n-\t* plugin/Makefile.in: Regenerated.\n-\n-2017-01-20  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/79046\n-\t* aclocal.m4: Regenerated.\n-\t* Makefile.in: Regenerated.\n-\n-2017-01-17  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/79046\n-\t* configure.ac: Add GCC_BASE_VER.\n-\t* Makefile.am (gcc_version): Use @get_gcc_base_ver@ instead of cat to\n-\tget version from BASE-VER file.\n-\t* aclocal.m4: Include ../config/acx.m4.\n-\t* configure: Regenerated.\n-\t* Makefile.in: Regenerated.\n-\n-2016-11-15  Matthias Klose  <doko@ubuntu.com>\n-\n-\t* configure: Regenerate.\n-\n-2016-07-21  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* Makefile.am (myo_inc_dir): Remove.\n-\t(toolexeclib_LTLIBRARIES): Remove libmyo-client.la and\n-\tlibmyo-service.la.\n-\t(liboffloadmic_cppflags): Remove -DMYO_SUPPORT.\n-\t(liboffloadmic_host_la_SOURCES): Remove offload_myo_host.cpp.\n-\t(liboffloadmic_target_la_SOURCES): Remove offload_myo_target.cpp.\n-\t(liboffloadmic_target_la_LIBADD): Remove libmyo-service.la.\n-\t(libmyo_client_la_SOURCES, libmyo_service_la_SOURCES): Remove.\n-\t(libmyo_client_la_DEPENDENCIES, libmyo_service_la_DEPENDENCIES): Remove.\n-\t(libmyo_client_la_CPPFLAGS, libmyo_service_la_CPPFLAGS): Remove.\n-\t(libmyo_client_la_LDFLAGS, libmyo_service_la_LDFLAGS): Remove.\n-\t* Makefile.in: Regenerate.\n-\t* doc/doxygen/header.tex: Merge from upstream, version 20160715\n-\t<https://openmprtl.org/sites/default/files/liboffload_oss_20160715.tgz>.\n-\t* runtime/cean_util.cpp: Likewise.\n-\t* runtime/cean_util.h: Likewise.\n-\t* runtime/coi/coi_client.cpp: Likewise.\n-\t* runtime/coi/coi_client.h: Likewise.\n-\t* runtime/coi/coi_server.cpp: Likewise.\n-\t* runtime/coi/coi_server.h: Likewise.\n-\t* runtime/compiler_if_host.cpp: Likewise.\n-\t* runtime/compiler_if_host.h: Likewise.\n-\t* runtime/compiler_if_target.cpp: Likewise.\n-\t* runtime/compiler_if_target.h: Likewise.\n-\t* runtime/dv_util.cpp: Likewise.\n-\t* runtime/dv_util.h: Likewise.\n-\t* runtime/liboffload_error.c: Likewise.\n-\t* runtime/liboffload_error_codes.h: Likewise.\n-\t* runtime/liboffload_msg.c: Likewise.\n-\t* runtime/liboffload_msg.h: Likewise.\n-\t* runtime/mic_lib.f90: Likewise.\n-\t* runtime/offload.h: Likewise.\n-\t* runtime/offload_common.cpp: Likewise.\n-\t* runtime/offload_common.h: Likewise.\n-\t* runtime/offload_engine.cpp: Likewise.\n-\t* runtime/offload_engine.h: Likewise.\n-\t* runtime/offload_env.cpp: Likewise.\n-\t* runtime/offload_env.h: Likewise.\n-\t* runtime/offload_host.cpp: Likewise.\n-\t* runtime/offload_host.h: Likewise.\n-\t* runtime/offload_iterator.h: Likewise.\n-\t* runtime/offload_myo_host.cpp: Likewise.\n-\t* runtime/offload_myo_host.h: Likewise.\n-\t* runtime/offload_myo_target.cpp: Likewise.\n-\t* runtime/offload_myo_target.h: Likewise.\n-\t* runtime/offload_omp_host.cpp: Likewise.\n-\t* runtime/offload_omp_target.cpp: Likewise.\n-\t* runtime/offload_orsl.cpp: Likewise.\n-\t* runtime/offload_orsl.h: Likewise.\n-\t* runtime/offload_table.cpp: Likewise.\n-\t* runtime/offload_table.h: Likewise.\n-\t* runtime/offload_target.cpp: Likewise.\n-\t* runtime/offload_target.h: Likewise.\n-\t* runtime/offload_target_main.cpp: Likewise.\n-\t* runtime/offload_timer.h: Likewise.\n-\t* runtime/offload_timer_host.cpp: Likewise.\n-\t* runtime/offload_timer_target.cpp: Likewise.\n-\t* runtime/offload_trace.cpp: Likewise.\n-\t* runtime/offload_trace.h: Likewise.\n-\t* runtime/offload_util.cpp: Likewise.\n-\t* runtime/offload_util.h: Likewise.\n-\t* runtime/ofldbegin.cpp: Likewise.\n-\t* runtime/ofldend.cpp: Likewise.\n-\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n-\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n-\t* runtime/use_mpss2.txt: Remove.\n-\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n-\tversion 3.7.1\n-\t<http://registrationcenter-download.intel.com/akdlm/irc_nas/9226/\n-\tmpss-3.7.1-linux.tar>.\n-\t* include/coi/common/COIEvent_common.h: Likewise.\n-\t* include/coi/common/COIMacros_common.h: Likewise.\n-\t* include/coi/common/COIPerf_common.h: Likewise.\n-\t* include/coi/common/COIResult_common.h: Likewise.\n-\t* include/coi/common/COISysInfo_common.h: Likewise.\n-\t* include/coi/common/COITypes_common.h: Likewise.\n-\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n-\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n-\t* include/coi/sink/COIProcess_sink.h: Likewise.\n-\t* include/coi/source/COIBuffer_source.h: Likewise.\n-\t* include/coi/source/COIEngine_source.h: Likewise.\n-\t* include/coi/source/COIEvent_source.h: Likewise.\n-\t* include/coi/source/COIPipeline_source.h: Likewise.\n-\t* include/coi/source/COIProcess_source.h: Likewise.\n-\t* include/myo/myo.h: Remove.\n-\t* include/myo/myoimpl.h: Remove.\n-\t* include/myo/myotypes.h: Remove.\n-\t* plugin/Makefile.am (AM_LDFLAGS): Remove -lmyo-service.\n-\t* plugin/Makefile.in: Regenerate.\n-\t* plugin/libgomp-plugin-intelmic.cpp (LD_LIBRARY_PATH_ENV): Remove.\n-\t(MIC_LD_LIBRARY_PATH_ENV): Remove.\n-\t(init): Do not set MIC_LD_LIBRARY_PATH.  Now liboffloadmic uses only\n-\tLD_LIBRARY_PATH.\n-\t* plugin/offload_target_main.cpp: Update copyright years.\n-\t* runtime/emulator/coi_common.h: Likewise.\n-\t* runtime/emulator/coi_device.cpp: Likewise.\n-\t* runtime/emulator/coi_device.h: Likewise.\n-\t* runtime/emulator/coi_host.cpp: Likewise.\n-\t(COIBufferCreate): Allow COI_BUFFER_OPENCL.\n-\t(COIEngineGetInfo): Return COI_DEVICE_KNL instead of COI_ISA_x86_64.\n-\t* runtime/emulator/coi_host.h: Update copyright years.\n-\t* runtime/emulator/coi_version_asm.h: Likewise.\n-\t* runtime/emulator/coi_version_linker_script.map: Likewise.\n-\t* runtime/emulator/myo_client.cpp: Remove.\n-\t* runtime/emulator/myo_service.cpp: Remove.\n-\t* runtime/emulator/myo_service.h: Remove.\n-\t* runtime/emulator/myo_version_asm.h: Remove.\n-\t* runtime/emulator/myo_version_linker_script.map: Remove.\n-\n-2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (offload): Change return type\n-\tto bool, adjust return code.\n-\t(GOMP_OFFLOAD_init_device): Likewise.\n-\t(GOMP_OFFLOAD_fini_device): Likewise.\n-\t(get_target_table): Likewise.\n-\t(offload_image): Likwise.\n-\t(GOMP_OFFLOAD_load_image): Adjust call to offload_image(), change\n-\tto return -1 on error.\n-\t(GOMP_OFFLOAD_unload_image): Change return type to bool, adjust return\n-\tcode.\n-\t(GOMP_OFFLOAD_alloc): Likewise.\n-\t(GOMP_OFFLOAD_free): Likewise.\n-\t(GOMP_OFFLOAD_host2dev): Likewise.\n-\t(GOMP_OFFLOAD_dev2host): Likewise.\n-\t(GOMP_OFFLOAD_dev2dev): Likewise.\n-\n-2016-01-20  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_run): Pass extra NULL\n-\tto GOMP_OFFLOAD_async_run.\n-\n-2016-01-19  Martin Jambor  <mjambor@suse.cz>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_async_run): New\n-\tunused parameter.\n-\t(GOMP_OFFLOAD_run): Likewise.\n-\n-2015-12-14  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (unregister_main_image): Remove.\n-\t(register_main_image): Do not call unregister_main_image at exit.\n-\t(GOMP_OFFLOAD_fini_device): Allow for OpenMP.  Unregister main image.\n-\n-2015-11-19  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (struct TargetImageDesc): New.\n-\t(ImgDescMap): New typedef.\n-\t(image_descriptors): New static var.\n-\t(init): Allocate image_descriptors.\n-\t(offload): Remove vars2 argument.  Pass NULL to __offload_offload1\n-\tinstead of vars2.\n-\t(unregister_main_image): New static function.\n-\t(register_main_image): Call unregister_main_image at exit.\n-\t(GOMP_OFFLOAD_init_device): Print device number, fix offload args.\n-\t(GOMP_OFFLOAD_fini_device): Likewise.\n-\t(get_target_table): Remove vd1g and vd2g, don't pass them to offload.\n-\t(offload_image): Remove declaration of the struct TargetImage.\n-\tFree table.  Insert new descriptor into image_descriptors.\n-\t(GOMP_OFFLOAD_unload_image): Call __offload_unregister_image, free\n-\tthe corresponding descriptor, and remove it from address_table and\n-\timage_descriptors.\n-\t(GOMP_OFFLOAD_alloc): Print device number, remove vd1g.\n-\t(GOMP_OFFLOAD_free): Likewise.\n-\t(GOMP_OFFLOAD_host2dev): Print device number, remove vd1g and vd2g.\n-\t(GOMP_OFFLOAD_dev2host): Likewise.\n-\t(GOMP_OFFLOAD_run): Print device number, remove vd1g.\n-\t* plugin/offload_target_main.cpp (__offload_target_table_p1): Remove\n-\tvd2, don't pass it to __offload_target_enter.\n-\t(__offload_target_table_p2): Likewise.\n-\t(__offload_target_alloc): Likewise.\n-\t(__offload_target_free): Likewise.\n-\t(__offload_target_host2tgt_p1): Likewise.\n-\t(__offload_target_host2tgt_p2): Likewise.\n-\t(__offload_target_tgt2host_p1): Likewise.\n-\t(__offload_target_tgt2host_p2): Likewise.\n-\t(__offload_target_run): Likewise.\n-\t(__offload_target_tgt2tgt): Remove vd1g, don't pass it to\n-\t__offload_target_enter.\n-\n-2015-11-14  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* runtime/offload_host.cpp (task_completion_callback): New\n-\tvariable.\n-\t(offload_proxy_task_completed_ooo): Call task_completion_callback.\n-\t(__offload_register_task_callback): New function.\n-\t* runtime/offload_host.h (__offload_register_task_callback): New\n-\tdeclaration.\n-\t* plugin/libgomp-plugin-intelmic.cpp (offload): Add async_data\n-\targument, handle async offloading.\n-\t(register_main_image): Call register_main_image.\n-\t(GOMP_OFFLOAD_init_device, get_target_table, GOMP_OFFLOAD_alloc,\n-\tGOMP_OFFLOAD_free, GOMP_OFFLOAD_host2dev, GOMP_OFFLOAD_dev2host,\n-\tGOMP_OFFLOAD_dev2dev): Adjust offload callers.\n-\t(GOMP_OFFLOAD_async_run): New function.\n-\t(GOMP_OFFLOAD_run): Implement using GOMP_OFFLOAD_async_run.\n-\n-2015-10-26  Ilya Verbin  <ilya.verbin@intel.com>\n-\t    Aleksander Ivanushenko  <aleksander.ivanushenko@intel.com>\n-\n-\t* runtime/offload_host.cpp (OffloadDescriptor::setup_misc_data): Use\n-\tcalloc instead of malloc.\n-\t(__offload_fini_library): Set mic_engines_total to zero.\n-\n-2015-10-13  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_dev2dev): New\n-\tfunction.\n-\t* plugin/offload_target_main.cpp (__offload_target_tgt2tgt): New\n-\tstatic function, register it in liboffloadmic.\n-\n-2015-10-08  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* runtime/offload_engine.cpp (Engine::init_process): Use strdup instead\n-\tof sizeof+malloc+sprintf, check for return value.\n-\t* runtime/offload_env.cpp (MicEnvVar::get_env_var_kind): Check for\n-\tstrdup return value.\n-\t* runtime/offload_host.cpp (__offload_init_library_once): Check for\n-\tstrdup return value.  Fix size calculation of COI_HOST_THREAD_AFFINITY.\n-\t* runtime/emulator/coi_device.cpp (COIProcessWaitForShutdown): Check for\n-\tmalloc return value.\n-\n-2015-09-29  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (OFFLOAD_ACTIVE_WAIT_ENV): New\n-\tdefine.\n-\t(init): Set OFFLOAD_ACTIVE_WAIT env var to 0, if it is not set.\n-\t* runtime/emulator/coi_common.h (PIPE_HOST_PATH): Replace with ...\n-\t(PIPE_HOST2TGT_NAME): ... this.\n-\t(PIPE_TARGET_PATH): Replace with ...\n-\t(PIPE_TGT2HOST_NAME): ... this.\n-\t(MALLOCN): New define.\n-\t(READN): Likewise.\n-\t(WRITEN): Likewise.\n-\t(enum cmd_t): Replace CMD_RUN_FUNCTION with CMD_PIPELINE_RUN_FUNCTION.\n-\tAdd CMD_PIPELINE_CREATE, CMD_PIPELINE_DESTROY.\n-\t* runtime/emulator/coi_device.cpp (engine_dir): New static variable.\n-\t(pipeline_thread_routine): New static function.\n-\t(COIProcessWaitForShutdown): Use global engine_dir instead of mic_dir.\n-\tRename pipe_host and pipe_target to pipe_host2tgt and pipe_tgt2host.\n-\tIf cmd is CMD_PIPELINE_CREATE, create a new thread for the pipeline.\n-\tRemove cmd == CMD_RUN_FUNCTION case.\n-\t* runtime/emulator/coi_device.h (COIERRORN): New define.\n-\t* runtime/emulator/coi_host.cpp: Include set, map, queue.\n-\tReplace typedefs with enums and structs.\n-\t(struct Function): Remove name, add num_buffers, bufs_size,\n-\tbufs_data_target, misc_data_len, misc_data, return_value_len,\n-\treturn_value, completion_event.\n-\t(struct Callback): New.\n-\t(struct Process): Remove pipeline.  Add pipe_host2tgt and pipe_tgt2host.\n-\t(struct Pipeline): Remove pipe_host and pipe_target.  Add thread,\n-\tdestroy, is_destroyed, pipe_host2tgt_path, pipe_tgt2host_path,\n-\tpipe_host2tgt, pipe_tgt2host, queue, process.\n-\t(max_pipeline_num): New static variable.\n-\t(pipelines): Likewise.\n-\t(max_event_num): Likewise.\n-\t(non_signalled_events): Likewise.\n-\t(errored_events): Likewise.\n-\t(callbacks): Likewise.\n-\t(cleanup): Do not check tmp_dirs before free.\n-\t(start_critical_section): New static function.\n-\t(finish_critical_section): Likewise.\n-\t(pipeline_is_destroyed): Likewise.\n-\t(maybe_invoke_callback): Likewise.\n-\t(signal_event): Likewise.\n-\t(get_event_result): Likewise.\n-\t(COIBufferCopy): Rename arguments according to headers.  Add asserts.\n-\tUse process' main pipes, instead of pipeline's pipes.  Signal completion\n-\tevent.\n-\t(COIBufferCreate): Rename arguments according to headers.  Add asserts.\n-\tUse process' main pipes, instead of pipeline's pipes.\n-\t(COIBufferCreateFromMemory): Rename arguments according to headers.\n-\tAdd asserts.\n-\t(COIBufferDestroy): Rename arguments according to headers.  Add asserts.\n-\tUse process' main pipes, instead of pipeline's pipes.\n-\t(COIBufferGetSinkAddress): Rename arguments according to headers.\n-\tAdd asserts.\n-\t(COIBufferMap): Rename arguments according to headers.  Add asserts.\n-\tSignal completion event.\n-\t(COIBufferRead): Likewise.\n-\t(COIBufferSetState): Likewise.\n-\t(COIBufferUnmap): Likewise.\n-\t(COIBufferWrite): Likewise.\n-\t(COIEngineGetCount): Add assert.\n-\t(COIEngineGetHandle): Rename arguments according to headers.\n-\tAdd assert.\n-\t(COIEventWait): Rename arguments according to headers.  Add asserts.\n-\tImplement waiting for events with zero or infinite timeout.\n-\t(COIEventRegisterCallback): New function.\n-\t(pipeline_thread_routine): New static function.\n-\t(COIPipelineCreate): Create a new thread for the pipeline.\n-\t(COIPipelineDestroy): Exit pipeline thread.\n-\t(COIPipelineRunFunction): Add the function into pipeline's queue,\n-\tinstead running it here.  Wait for it's completion in case of\n-\tsynchronous execution.\n-\t(COIProcessCreateFromMemory): Rename arguments according to headers.\n-\tAdd asserts.  Create process' main pipes, instead of pipeline's pipes.\n-\t(COIProcessDestroy): Rename arguments according to headers.\n-\tAdd asserts.  Destroy all undestroyed pipelines.\n-\t(COIProcessGetFunctionHandles): Rename arguments according to headers.\n-\tAdd asserts.  Use process' main pipes, instead of pipeline's pipes.\n-\tRemove useless function names.\n-\t(COIProcessLoadLibraryFromMemory): Add asserts.  Use process' main\n-\tpipes, instead of pipeline's pipes.\n-\t(COIProcessUnloadLibrary): Likewise.\n-\t(COIEngineGetInfo): Add assert.\n-\t* runtime/emulator/coi_host.h (COIERRORN): New define.\n-\n-2015-09-28  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\tPR other/67652\n-\t* runtime/offload_engine.cpp (Engine::init_process): Fix sizeof.\n-\n-2015-09-08  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* Makefile.am (liboffloadmic_host_la_DEPENDENCIES): Remove libcoi_host\n-\tand libmyo-client.  liboffloadmic_host loads them dynamically.\n-\t* Makefile.in: Regenerate.\n-\t* doc/doxygen/header.tex: Merge from upstream, version 20150803\n-\t<https://openmprtl.org/sites/default/files/liboffload_oss_20150803.tgz>.\n-\t* runtime/cean_util.cpp: Likewise.\n-\t* runtime/cean_util.h: Likewise.\n-\t* runtime/coi/coi_client.cpp: Likewise.\n-\t* runtime/coi/coi_client.h: Likewise.\n-\t* runtime/coi/coi_server.cpp: Likewise.\n-\t* runtime/coi/coi_server.h: Likewise.\n-\t* runtime/compiler_if_host.cpp: Likewise.\n-\t* runtime/compiler_if_host.h: Likewise.\n-\t* runtime/compiler_if_target.cpp: Likewise.\n-\t* runtime/compiler_if_target.h: Likewise.\n-\t* runtime/dv_util.cpp: Likewise.\n-\t* runtime/dv_util.h: Likewise.\n-\t* runtime/liboffload_error.c: Likewise.\n-\t* runtime/liboffload_error_codes.h: Likewise.\n-\t* runtime/liboffload_msg.c: Likewise.\n-\t* runtime/liboffload_msg.h: Likewise.\n-\t* runtime/mic_lib.f90: Likewise.\n-\t* runtime/offload.h: Likewise.\n-\t* runtime/offload_common.cpp: Likewise.\n-\t* runtime/offload_common.h: Likewise.\n-\t* runtime/offload_engine.cpp: Likewise.\n-\t* runtime/offload_engine.h: Likewise.\n-\t* runtime/offload_env.cpp: Likewise.\n-\t* runtime/offload_env.h: Likewise.\n-\t* runtime/offload_host.cpp: Likewise.\n-\t* runtime/offload_host.h: Likewise.\n-\t* runtime/offload_iterator.h: Likewise.\n-\t* runtime/offload_myo_host.cpp: Likewise.\n-\t* runtime/offload_myo_host.h: Likewise.\n-\t* runtime/offload_myo_target.cpp: Likewise.\n-\t* runtime/offload_myo_target.h: Likewise.\n-\t* runtime/offload_omp_host.cpp: Likewise.\n-\t* runtime/offload_omp_target.cpp: Likewise.\n-\t* runtime/offload_orsl.cpp: Likewise.\n-\t* runtime/offload_orsl.h: Likewise.\n-\t* runtime/offload_table.cpp: Likewise.\n-\t* runtime/offload_table.h: Likewise.\n-\t* runtime/offload_target.cpp: Likewise.\n-\t* runtime/offload_target.h: Likewise.\n-\t* runtime/offload_target_main.cpp: Likewise.\n-\t* runtime/offload_timer.h: Likewise.\n-\t* runtime/offload_timer_host.cpp: Likewise.\n-\t* runtime/offload_timer_target.cpp: Likewise.\n-\t* runtime/offload_trace.cpp: Likewise.\n-\t* runtime/offload_trace.h: Likewise.\n-\t* runtime/offload_util.cpp: Likewise.\n-\t* runtime/offload_util.h: Likewise.\n-\t* runtime/ofldbegin.cpp: Likewise.\n-\t* runtime/ofldend.cpp: Likewise.\n-\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n-\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n-\t* runtime/use_mpss2.txt: Likewise.\n-\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n-\tversion 3.5\n-\t<http://registrationcenter.intel.com/irc_nas/7445/mpss-src-3.5.tar>.\n-\t* include/coi/common/COIEvent_common.h: Likewise.\n-\t* include/coi/common/COIMacros_common.h: Likewise.\n-\t* include/coi/common/COIPerf_common.h: Likewise.\n-\t* include/coi/common/COIResult_common.h: Likewise.\n-\t* include/coi/common/COISysInfo_common.h: Likewise.\n-\t* include/coi/common/COITypes_common.h: Likewise.\n-\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n-\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n-\t* include/coi/sink/COIProcess_sink.h: Likewise.\n-\t* include/coi/source/COIBuffer_source.h: Likewise.\n-\t* include/coi/source/COIEngine_source.h: Likewise.\n-\t* include/coi/source/COIEvent_source.h: Likewise.\n-\t* include/coi/source/COIPipeline_source.h: Likewise.\n-\t* include/coi/source/COIProcess_source.h: Likewise.\n-\t* include/myo/myo.h: Likewise.\n-\t* include/myo/myoimpl.h: Likewise.\n-\t* include/myo/myotypes.h: Likewise.\n-\t* plugin/Makefile.am (myo_inc_dir): Remove.\n-\t(libgomp_plugin_intelmic_la_CPPFLAGS): Do not define MYO_SUPPORT.\n-\t(AM_CPPFLAGS): Likewise for offload_target_main.\n-\t* plugin/Makefile.in: Regenerate.\n-\t* runtime/emulator/coi_common.h: Update copyright years.\n-\t(OFFLOAD_EMUL_KNC_NUM_ENV): Replace with ...\n-\t(OFFLOAD_EMUL_NUM_ENV): ... this.\n-\t(enum cmd_t): Add CMD_CLOSE_LIBRARY.\n-\t* runtime/emulator/coi_device.cpp: Update copyright years.\n-\t(COIProcessWaitForShutdown): Add space between string constants.\n-\tReturn handle to host in CMD_OPEN_LIBRARY.\n-\tSupport CMD_CLOSE_LIBRARY.\n-\t* runtime/emulator/coi_device.h: Update copyright years.\n-\t* runtime/emulator/coi_host.cpp: Update copyright years.\n-\t(knc_engines_num): Replace with ...\n-\t(num_engines): ... this.\n-\t(init): Replace OFFLOAD_EMUL_KNC_NUM_ENV with OFFLOAD_EMUL_NUM_ENV.\n-\t(COIEngineGetCount): Replace COI_ISA_KNC with COI_ISA_MIC, and\n-\tknc_engines_num with num_engines.\n-\t(COIEngineGetHandle): Likewise.\n-\t(COIProcessCreateFromMemory): Add space between string constants.\n-\t(COIProcessCreateFromFile): New function.\n-\t(COIProcessLoadLibraryFromMemory): Rename arguments according to\n-\tCOIProcess_source.h.  Return handle, received from target.\n-\t(COIProcessUnloadLibrary): New function.\n-\t(COIPipelineClearCPUMask): New function.\n-\t(COIPipelineSetCPUMask): New function.\n-\t(COIEngineGetInfo): New function.\n-\t* runtime/emulator/coi_host.h: Update copyright years.\n-\t* runtime/emulator/coi_version_asm.h: Regenerate.\n-\t* runtime/emulator/coi_version_linker_script.map: Regenerate.\n-\t* runtime/emulator/myo_client.cpp: Update copyright years.\n-\t* runtime/emulator/myo_service.cpp: Update copyright years.\n-\t(myoArenaRelease): New function.\n-\t(myoArenaAcquire): New function.\n-\t(myoArenaAlignedFree): New function.\n-\t(myoArenaAlignedMalloc): New function.\n-\t* runtime/emulator/myo_service.h: Update copyright years.\n-\t* runtime/emulator/myo_version_asm.h: Regenerate.\n-\t* runtime/emulator/myo_version_linker_script.map: Regenerate.\n-\n-2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_version): New.\n-\t(GOMP_OFFLOAD_load_image): Add version arg and check it.\n-\t(GOMP_OFFLOAD_unload_image): Likewise.\n-\n-2015-08-24  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/Makefile.am (include_src_dir): Set.\n-\t[PLUGIN_HOST] (libgomp_plugin_intelmic_la_CPPFLAGS): Use it.\n-\t* plugin/Makefile.in: Regenerate.\n-\t* plugin/libgomp-plugin-intelmic.cpp: Include \"gomp-constants.h\".\n-\n-2015-07-24  Micahel Darling  <darlingm@gmail.com>\n-\n-\tPR other/66259\n-\t* configure: Reflects renaming of configure.in to configure.ac\n-\n-2015-07-17  Nathan Sidwell  <nathan@acm.org>\n-\t    Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (ImgDevAddrMap): Constify.\n-\t(offload_image, GOMP_OFFLOAD_load_image,\n-\tGOMP_OFFLOAD_unload_image): Constify target data.\n-\n-2015-07-08  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/Makefile.am (main_target_image.h): Change type of data\n-\tmember of struct MainTargetImage to uint8_t.\n-\t* plugin/Makefile.in: Regenerate.\n-\n-2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n-\n-\t* Makefile.in: Regenerated with automake-1.11.6.\n-\t* aclocal.m4: Likewise.\n-\t* configure: Likewise.\n-\t* plugin/Makefile.in: Likewise.\n-\t* plugin/aclocal.m4: Likewise.\n-\t* plugin/configure: Likewise.\n-\n-2015-04-06  Ilya Verbin  <ilya.verbin@intel.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp: Include map.\n-\t(AddrVect, DevAddrVect, ImgDevAddrMap): New typedefs.\n-\t(num_devices, num_images, address_table): New static vars.\n-\t(num_libraries, lib_descrs): Remove static vars.\n-\t(set_mic_lib_path): Rename to ...\n-\t(init): ... this.  Allocate address_table and get num_devices.\n-\t(GOMP_OFFLOAD_get_num_devices): return num_devices.\n-\t(load_lib_and_get_table): Remove static function.\n-\t(offload_image): New static function.\n-\t(GOMP_OFFLOAD_get_table): Remove function.\n-\t(GOMP_OFFLOAD_load_image, GOMP_OFFLOAD_unload_image): New functions.\n-\n-2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_name)\n-\t(GOMP_OFFLOAD_get_caps, GOMP_OFFLOAD_fini_device): New functions.\n-\n-2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n-\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* configure.ac: Add subdirectory 'plugin'.\n-\t* plugin/Makefile.am: New file.\n-\t* plugin/Makefile.in: New file, generated by automake.\n-\t* plugin/aclocal.m4: New file, generated by aclocal.\n-\t* plugin/configure: New file, generated by autoconf.\n-\t* plugin/configure.ac: New file.\n-\t* plugin/libgomp-plugin-intelmic.cpp: New file.\n-\t* plugin/offload_target_main.cpp: New file.\n-\n-2014-11-13  Kirill Yukhin  <kirill.yukhin@intel.com>\n-\n-\tInitial commit.  Imported from upstream:\n-\thttps://www.openmprtl.org/sites/default/files/liboffload_oss.tgz\n-\t* Makefile.am: New file.\n-\t* Makefile.in: New file, generated by automake.\n-\t* aclocal.m4: New file, generated by aclocal.\n-\t* configure: New file, generated by autoconf.\n-\t* configure.ac: New file.\n-\t* configure.tgt: Ditto.\n-\t* doc/doxygen/config: Ditto.\n-\t* doc/doxygen/header.tex: Ditto.\n-\t* include/coi/common/COIEngine_common.h: Ditto.\n-\t* include/coi/common/COIMacros_common.h: Ditto.\n-\t* include/coi/common/COIPerf_common.h : Ditto.\n-\t* include/coi/common/COIResult_common.h : Ditto.\n-\t* include/coi/common/COITypes_common.h: Ditto.\n-\t* include/coi/sink/COIBuffer_sink.h: Ditto.\n-\t* include/coi/sink/COIPipeline_sink.h: Ditto.\n-\t* include/coi/sink/COIProcess_sink.h: Ditto.\n-\t* include/coi/source/COIBuffer_source.h: Ditto.\n-\t* include/coi/source/COIEngine_source.h: Ditto.\n-\t* include/coi/source/COIEvent_source.h: Ditto.\n-\t* include/coi/source/COIPipeline_source.h: Ditto.\n-\t* include/coi/source/COIProcess_source.h: Ditto.\n-\t* include/myo/myo.h: Ditto.\n-\t* include/myo/myoimpl.h: Ditto.\n-\t* include/myo/myotypes.h: Ditto.\n-\t* liboffloadmic_host.spec.in: Ditto.\n-\t* liboffloadmic_target.spec.in: Ditto.\n-\t* runtime/cean_util.cpp: Ditto.\n-\t* runtime/cean_util.h: Ditto.\n-\t* runtime/coi/coi_client.cpp: Ditto.\n-\t* runtime/coi/coi_client.h: Ditto.\n-\t* runtime/coi/coi_server.cpp: Ditto.\n-\t* runtime/coi/coi_server.h: Ditto.\n-\t* runtime/compiler_if_host.cpp: Ditto.\n-\t* runtime/compiler_if_host.h: Ditto.\n-\t* runtime/compiler_if_target.cpp: Ditto.\n-\t* runtime/compiler_if_target.h: Ditto.\n-\t* runtime/dv_util.cpp: Ditto.\n-\t* runtime/dv_util.h: Ditto.\n-\t* runtime/emulator/coi_common.h: Ditto.\n-\t* runtime/emulator/coi_device.cpp: Ditto.\n-\t* runtime/emulator/coi_device.h: Ditto.\n-\t* runtime/emulator/coi_host.cpp: Ditto.\n-\t* runtime/emulator/coi_host.h: Ditto.\n-\t* runtime/emulator/coi_version_asm.h: Ditto.\n-\t* runtime/emulator/coi_version_linker_script.map: Ditto.\n-\t* runtime/emulator/myo_client.cpp: Ditto.\n-\t* runtime/emulator/myo_service.cpp: Ditto.\n-\t* runtime/emulator/myo_service.h: Ditto.\n-\t* runtime/emulator/myo_version_asm.h: Ditto.\n-\t* runtime/emulator/myo_version_linker_script.map: Ditto.\n-\t* runtime/liboffload_error.c: Ditto.\n-\t* runtime/liboffload_error_codes.h: Ditto.\n-\t* runtime/liboffload_msg.c: Ditto.\n-\t* runtime/liboffload_msg.h: Ditto.\n-\t* runtime/mic_lib.f90: Ditto.\n-\t* runtime/offload.h: Ditto.\n-\t* runtime/offload_common.cpp: Ditto.\n-\t* runtime/offload_common.h: Ditto.\n-\t* runtime/offload_engine.cpp: Ditto.\n-\t* runtime/offload_engine.h: Ditto.\n-\t* runtime/offload_env.cpp: Ditto.\n-\t* runtime/offload_env.h: Ditto.\n-\t* runtime/offload_host.cpp: Ditto.\n-\t* runtime/offload_host.h: Ditto.\n-\t* runtime/offload_myo_host.cpp: Ditto.\n-\t* runtime/offload_myo_host.h: Ditto.\n-\t* runtime/offload_myo_target.cpp: Ditto.\n-\t* runtime/offload_myo_target.h: Ditto.\n-\t* runtime/offload_omp_host.cpp: Ditto.\n-\t* runtime/offload_omp_target.cpp: Ditto.\n-\t* runtime/offload_orsl.cpp: Ditto.\n-\t* runtime/offload_orsl.h: Ditto.\n-\t* runtime/offload_table.cpp: Ditto.\n-\t* runtime/offload_table.h: Ditto.\n-\t* runtime/offload_target.cpp: Ditto.\n-\t* runtime/offload_target.h: Ditto.\n-\t* runtime/offload_target_main.cpp: Ditto.\n-\t* runtime/offload_timer.h: Ditto.\n-\t* runtime/offload_timer_host.cpp: Ditto.\n-\t* runtime/offload_timer_target.cpp: Ditto.\n-\t* runtime/offload_trace.cpp: Ditto.\n-\t* runtime/offload_trace.h: Ditto.\n-\t* runtime/offload_util.cpp: Ditto.\n-\t* runtime/offload_util.h: Ditto.\n-\t* runtime/ofldbegin.cpp: Ditto.\n-\t* runtime/ofldend.cpp: Ditto.\n-\t* runtime/orsl-lite/include/orsl-lite.h: Ditto.\n-\t* runtime/orsl-lite/lib/orsl-lite.c: Ditto.\n-\t* runtime/orsl-lite/version.txt: Ditto.\n-\t* runtime/use_mpss2.txt: Ditto.\n-\f\n-Copyright (C) 2014-2018 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "4a15322b1c924d33f3363ad872aa11d5ee503359", "filename": "liboffloadmic/Makefile.am", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.am?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,160 +0,0 @@\n-#\n-#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n-#\n-#    Redistribution and use in source and binary forms, with or without\n-#    modification, are permitted provided that the following conditions\n-#    are met:\n-#\n-#      * Redistributions of source code must retain the above copyright\n-#        notice, this list of conditions and the following disclaimer.\n-#      * Redistributions in binary form must reproduce the above copyright\n-#        notice, this list of conditions and the following disclaimer in the\n-#        documentation and/or other materials provided with the distribution.\n-#      * Neither the name of Intel Corporation nor the names of its\n-#        contributors may be used to endorse or promote products derived\n-#        from this software without specific prior written permission.\n-#\n-#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-#\n-\n-\n-AUTOMAKE_OPTIONS = foreign\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-\n-# Build plugin for Intel MIC\n-SUBDIRS = . plugin\n-\n-# Directories.\n-build_dir = $(top_builddir)\n-coi_inc_dir = $(top_srcdir)/include/coi\n-libgomp_dir = $(build_dir)/../libgomp\n-source_dir = $(top_srcdir)/runtime\n-\n-# May be used by toolexeclibdir.\n-gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n-\n-# Target list.\n-if LIBOFFLOADMIC_HOST\n-  nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n-  toolexeclib_LTLIBRARIES = libcoi_host.la liboffloadmic_host.la\n-  nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n-  ofld_obj =\n-else # LIBOFFLOADMIC_TARGET\n-  nodist_toolexeclib_HEADERS = liboffloadmic_target.spec\n-  toolexeclib_LTLIBRARIES = libcoi_device.la liboffloadmic_target.la\n-  nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n-  ofld_obj = ofldbegin.o ofldend.o\n-endif\n-\n-# Liboffloadmic.\n-liboffloadmic_sources = runtime/dv_util.cpp \\\n-\t\t\truntime/liboffload_error.c \\\n-\t\t\truntime/liboffload_msg.c \\\n-\t\t\truntime/offload_common.cpp \\\n-\t\t\truntime/offload_table.cpp \\\n-\t\t\truntime/offload_trace.cpp \\\n-\t\t\truntime/offload_util.cpp\n-\n-liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n-\n-liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n-\t\t\t\truntime/cean_util.cpp \\\n-\t\t\t\truntime/coi/coi_client.cpp \\\n-\t\t\t\truntime/compiler_if_host.cpp \\\n-\t\t\t\truntime/offload_engine.cpp \\\n-\t\t\t\truntime/offload_env.cpp \\\n-\t\t\t\truntime/offload_host.cpp \\\n-\t\t\t\truntime/offload_omp_host.cpp \\\n-\t\t\t\truntime/offload_orsl.cpp \\\n-\t\t\t\truntime/offload_timer_host.cpp \\\n-\t\t\t\truntime/orsl-lite/lib/orsl-lite.c\n-\n-liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n-liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-\n-liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n-\t\t\t\t  runtime/coi/coi_server.cpp \\\n-\t\t\t\t  runtime/compiler_if_target.cpp \\\n-\t\t\t\t  runtime/offload_omp_target.cpp \\\n-\t\t\t\t  runtime/offload_target.cpp \\\n-\t\t\t\t  runtime/offload_timer_target.cpp\n-\n-liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n-liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_target_la_LIBADD = libcoi_device.la\n-liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n-\n-# Emulator.\n-libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n-libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n-\n-libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-\n-libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n-libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n-\n-libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-\n-# ofldbegin, ofldend\n-all-local: $(ofld_obj)\n-\n-ofldbegin.o: runtime/ofldbegin.cpp\n-\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n-\n-ofldend.o: runtime/ofldend.cpp\n-\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-       \"AR_FLAGS=$(AR_FLAGS)\" \\\n-       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-       \"CFLAGS=$(CFLAGS)\" \\\n-       \"CXXFLAGS=$(CXXFLAGS)\" \\\n-       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-       \"INSTALL=$(INSTALL)\" \\\n-       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-       \"JC1FLAGS=$(JC1FLAGS)\" \\\n-       \"LDFLAGS=$(LDFLAGS)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-       \"MAKE=$(MAKE)\" \\\n-       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-       \"SHELL=$(SHELL)\" \\\n-       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-       \"exec_prefix=$(exec_prefix)\" \\\n-       \"infodir=$(infodir)\" \\\n-       \"libdir=$(libdir)\" \\\n-       \"prefix=$(prefix)\" \\\n-       \"includedir=$(includedir)\" \\\n-       \"AR=$(AR)\" \\\n-       \"AS=$(AS)\" \\\n-       \"LD=$(LD)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"NM=$(NM)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"RANLIB=$(RANLIB)\" \\\n-       \"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES =\n-\n-include $(top_srcdir)/../multilib.am"}, {"sha": "43abc5a40e8dce06987a2c81690c27a999062ae2", "filename": "liboffloadmic/Makefile.in", "status": "removed", "additions": 0, "deletions": 1310, "changes": 1310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.in?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1310 +0,0 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n-\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-#\n-#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n-#\n-#    Redistribution and use in source and binary forms, with or without\n-#    modification, are permitted provided that the following conditions\n-#    are met:\n-#\n-#      * Redistributions of source code must retain the above copyright\n-#        notice, this list of conditions and the following disclaimer.\n-#      * Redistributions in binary form must reproduce the above copyright\n-#        notice, this list of conditions and the following disclaimer in the\n-#        documentation and/or other materials provided with the distribution.\n-#      * Neither the name of Intel Corporation nor the names of its\n-#        contributors may be used to endorse or promote products derived\n-#        from this software without specific prior written permission.\n-#\n-#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-#\n-\n-\n-VPATH = @srcdir@\n-am__is_gnu_make = { \\\n-  if test -z '$(MAKELEVEL)'; then \\\n-    false; \\\n-  elif test -n '$(MAKE_HOST)'; then \\\n-    true; \\\n-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n-    true; \\\n-  else \\\n-    false; \\\n-  fi; \\\n-}\n-am__make_running_with_option = \\\n-  case $${target_option-} in \\\n-      ?) ;; \\\n-      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n-              \"target option '$${target_option-}' specified\" >&2; \\\n-         exit 1;; \\\n-  esac; \\\n-  has_opt=no; \\\n-  sane_makeflags=$$MAKEFLAGS; \\\n-  if $(am__is_gnu_make); then \\\n-    sane_makeflags=$$MFLAGS; \\\n-  else \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        bs=\\\\; \\\n-        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n-          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n-    esac; \\\n-  fi; \\\n-  skip_next=no; \\\n-  strip_trailopt () \\\n-  { \\\n-    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n-  }; \\\n-  for flg in $$sane_makeflags; do \\\n-    test $$skip_next = yes && { skip_next=no; continue; }; \\\n-    case $$flg in \\\n-      *=*|--*) continue;; \\\n-        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n-      -*I?*) strip_trailopt 'I';; \\\n-        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n-      -*O?*) strip_trailopt 'O';; \\\n-        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n-      -*l?*) strip_trailopt 'l';; \\\n-      -[dEDm]) skip_next=yes;; \\\n-      -[JT]) skip_next=yes;; \\\n-    esac; \\\n-    case $$flg in \\\n-      *$$target_option*) has_opt=yes; break;; \\\n-    esac; \\\n-  done; \\\n-  test $$has_opt = yes\n-am__make_dryrun = (target_option=n; $(am__make_running_with_option))\n-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = .\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/toolexeclibdir.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_CLEAN_FILES = liboffloadmic_host.spec liboffloadmic_target.spec\n-CONFIG_CLEAN_VPATH_FILES =\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n-\t\"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"\n-LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n-libcoi_device_la_LIBADD =\n-am_libcoi_device_la_OBJECTS = libcoi_device_la-coi_device.lo\n-libcoi_device_la_OBJECTS = $(am_libcoi_device_la_OBJECTS)\n-AM_V_lt = $(am__v_lt_@AM_V@)\n-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\n-am__v_lt_0 = --silent\n-am__v_lt_1 = \n-libcoi_device_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\\n-\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(libcoi_device_la_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_FALSE@am_libcoi_device_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n-libcoi_host_la_LIBADD =\n-am_libcoi_host_la_OBJECTS = libcoi_host_la-coi_host.lo\n-libcoi_host_la_OBJECTS = $(am_libcoi_host_la_OBJECTS)\n-libcoi_host_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\\n-\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(libcoi_host_la_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_TRUE@am_libcoi_host_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n-liboffloadmic_host_la_LIBADD =\n-am__objects_1 = liboffloadmic_host_la-dv_util.lo \\\n-\tliboffloadmic_host_la-liboffload_error.lo \\\n-\tliboffloadmic_host_la-liboffload_msg.lo \\\n-\tliboffloadmic_host_la-offload_common.lo \\\n-\tliboffloadmic_host_la-offload_table.lo \\\n-\tliboffloadmic_host_la-offload_trace.lo \\\n-\tliboffloadmic_host_la-offload_util.lo\n-am_liboffloadmic_host_la_OBJECTS = $(am__objects_1) \\\n-\tliboffloadmic_host_la-cean_util.lo \\\n-\tliboffloadmic_host_la-coi_client.lo \\\n-\tliboffloadmic_host_la-compiler_if_host.lo \\\n-\tliboffloadmic_host_la-offload_engine.lo \\\n-\tliboffloadmic_host_la-offload_env.lo \\\n-\tliboffloadmic_host_la-offload_host.lo \\\n-\tliboffloadmic_host_la-offload_omp_host.lo \\\n-\tliboffloadmic_host_la-offload_orsl.lo \\\n-\tliboffloadmic_host_la-offload_timer_host.lo \\\n-\tliboffloadmic_host_la-orsl-lite.lo\n-liboffloadmic_host_la_OBJECTS = $(am_liboffloadmic_host_la_OBJECTS)\n-liboffloadmic_host_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\\n-\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(liboffloadmic_host_la_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_TRUE@am_liboffloadmic_host_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n-am__objects_2 = liboffloadmic_target_la-dv_util.lo \\\n-\tliboffloadmic_target_la-liboffload_error.lo \\\n-\tliboffloadmic_target_la-liboffload_msg.lo \\\n-\tliboffloadmic_target_la-offload_common.lo \\\n-\tliboffloadmic_target_la-offload_table.lo \\\n-\tliboffloadmic_target_la-offload_trace.lo \\\n-\tliboffloadmic_target_la-offload_util.lo\n-am_liboffloadmic_target_la_OBJECTS = $(am__objects_2) \\\n-\tliboffloadmic_target_la-coi_server.lo \\\n-\tliboffloadmic_target_la-compiler_if_target.lo \\\n-\tliboffloadmic_target_la-offload_omp_target.lo \\\n-\tliboffloadmic_target_la-offload_target.lo \\\n-\tliboffloadmic_target_la-offload_timer_target.lo\n-liboffloadmic_target_la_OBJECTS =  \\\n-\t$(am_liboffloadmic_target_la_OBJECTS)\n-liboffloadmic_target_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\\n-\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(liboffloadmic_target_la_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_FALSE@am_liboffloadmic_target_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n-AM_V_P = $(am__v_P_@AM_V@)\n-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n-am__v_P_0 = false\n-am__v_P_1 = :\n-AM_V_GEN = $(am__v_GEN_@AM_V@)\n-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\n-am__v_GEN_0 = @echo \"  GEN     \" $@;\n-am__v_GEN_1 = \n-AM_V_at = $(am__v_at_@AM_V@)\n-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\n-am__v_at_0 = @\n-am__v_at_1 = \n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CFLAGS) $(CFLAGS)\n-AM_V_CC = $(am__v_CC_@AM_V@)\n-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\n-am__v_CC_0 = @echo \"  CC      \" $@;\n-am__v_CC_1 = \n-CCLD = $(CC)\n-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-AM_V_CCLD = $(am__v_CCLD_@AM_V@)\n-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\n-am__v_CCLD_0 = @echo \"  CCLD    \" $@;\n-am__v_CCLD_1 = \n-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS)\n-AM_V_CXX = $(am__v_CXX_@AM_V@)\n-am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)\n-am__v_CXX_0 = @echo \"  CXX     \" $@;\n-am__v_CXX_1 = \n-CXXLD = $(CXX)\n-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n-\t$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n-AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)\n-am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)\n-am__v_CXXLD_0 = @echo \"  CXXLD   \" $@;\n-am__v_CXXLD_1 = \n-SOURCES = $(libcoi_device_la_SOURCES) $(libcoi_host_la_SOURCES) \\\n-\t$(liboffloadmic_host_la_SOURCES) \\\n-\t$(liboffloadmic_target_la_SOURCES)\n-RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \\\n-\tctags-recursive dvi-recursive html-recursive info-recursive \\\n-\tinstall-data-recursive install-dvi-recursive \\\n-\tinstall-exec-recursive install-html-recursive \\\n-\tinstall-info-recursive install-pdf-recursive \\\n-\tinstall-ps-recursive install-recursive installcheck-recursive \\\n-\tinstalldirs-recursive pdf-recursive ps-recursive \\\n-\ttags-recursive uninstall-recursive\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-HEADERS = $(nodist_libsubinclude_HEADERS) \\\n-\t$(nodist_toolexeclib_HEADERS)\n-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n-  distclean-recursive maintainer-clean-recursive\n-am__recursive_targets = \\\n-  $(RECURSIVE_TARGETS) \\\n-  $(RECURSIVE_CLEAN_TARGETS) \\\n-  $(am__extra_recursive_targets)\n-AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \\\n-\tcscope\n-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n-# Read a list of newline-separated strings from the standard input,\n-# and print each of them once, without duplicates.  Input order is\n-# *not* preserved.\n-am__uniquify_input = $(AWK) '\\\n-  BEGIN { nonempty = 0; } \\\n-  { items[$$0] = 1; nonempty = 1; } \\\n-  END { if (nonempty) { for (i in items) print i; }; } \\\n-'\n-# Make sure the list of sources is unique.  This is necessary because,\n-# e.g., the same source file might be shared among _SOURCES variables\n-# for different programs/libraries.\n-am__define_uniq_tagged_files = \\\n-  list='$(am__tagged_files)'; \\\n-  unique=`for i in $$list; do \\\n-    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-  done | $(am__uniquify_input)`\n-ETAGS = etags\n-CTAGS = ctags\n-CSCOPE = cscope\n-DIST_SUBDIRS = $(SUBDIRS)\n-ACLOCAL = @ACLOCAL@\n-ALLOCA = @ALLOCA@\n-AMTAR = @AMTAR@\n-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-get_gcc_base_ver = @get_gcc_base_ver@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-link_offloadmic_host = @link_offloadmic_host@\n-link_offloadmic_target = @link_offloadmic_target@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-lt_cv_dlopen_libs = @lt_cv_dlopen_libs@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-subdirs = @subdirs@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-\n-# Build plugin for Intel MIC\n-SUBDIRS = . plugin\n-\n-# Directories.\n-build_dir = $(top_builddir)\n-coi_inc_dir = $(top_srcdir)/include/coi\n-libgomp_dir = $(build_dir)/../libgomp\n-source_dir = $(top_srcdir)/runtime\n-\n-# May be used by toolexeclibdir.\n-gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n-@LIBOFFLOADMIC_HOST_FALSE@nodist_toolexeclib_HEADERS = liboffloadmic_target.spec\n-\n-# Target list.\n-@LIBOFFLOADMIC_HOST_TRUE@nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n-@LIBOFFLOADMIC_HOST_FALSE@toolexeclib_LTLIBRARIES = libcoi_device.la liboffloadmic_target.la\n-@LIBOFFLOADMIC_HOST_TRUE@toolexeclib_LTLIBRARIES = libcoi_host.la liboffloadmic_host.la\n-@LIBOFFLOADMIC_HOST_FALSE@nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n-@LIBOFFLOADMIC_HOST_TRUE@nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n-@LIBOFFLOADMIC_HOST_FALSE@ofld_obj = ofldbegin.o ofldend.o\n-@LIBOFFLOADMIC_HOST_TRUE@ofld_obj = \n-\n-# Liboffloadmic.\n-liboffloadmic_sources = runtime/dv_util.cpp \\\n-\t\t\truntime/liboffload_error.c \\\n-\t\t\truntime/liboffload_msg.c \\\n-\t\t\truntime/offload_common.cpp \\\n-\t\t\truntime/offload_table.cpp \\\n-\t\t\truntime/offload_trace.cpp \\\n-\t\t\truntime/offload_util.cpp\n-\n-liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n-liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n-\t\t\t\truntime/cean_util.cpp \\\n-\t\t\t\truntime/coi/coi_client.cpp \\\n-\t\t\t\truntime/compiler_if_host.cpp \\\n-\t\t\t\truntime/offload_engine.cpp \\\n-\t\t\t\truntime/offload_env.cpp \\\n-\t\t\t\truntime/offload_host.cpp \\\n-\t\t\t\truntime/offload_omp_host.cpp \\\n-\t\t\t\truntime/offload_orsl.cpp \\\n-\t\t\t\truntime/offload_timer_host.cpp \\\n-\t\t\t\truntime/orsl-lite/lib/orsl-lite.c\n-\n-liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n-liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n-\t\t\t\t  runtime/coi/coi_server.cpp \\\n-\t\t\t\t  runtime/compiler_if_target.cpp \\\n-\t\t\t\t  runtime/offload_omp_target.cpp \\\n-\t\t\t\t  runtime/offload_target.cpp \\\n-\t\t\t\t  runtime/offload_timer_target.cpp\n-\n-liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n-liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_target_la_LIBADD = libcoi_device.la\n-liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n-\n-# Emulator.\n-libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n-libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n-libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n-libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n-libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-       \"AR_FLAGS=$(AR_FLAGS)\" \\\n-       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-       \"CFLAGS=$(CFLAGS)\" \\\n-       \"CXXFLAGS=$(CXXFLAGS)\" \\\n-       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-       \"INSTALL=$(INSTALL)\" \\\n-       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-       \"JC1FLAGS=$(JC1FLAGS)\" \\\n-       \"LDFLAGS=$(LDFLAGS)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-       \"MAKE=$(MAKE)\" \\\n-       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-       \"SHELL=$(SHELL)\" \\\n-       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-       \"exec_prefix=$(exec_prefix)\" \\\n-       \"infodir=$(infodir)\" \\\n-       \"libdir=$(libdir)\" \\\n-       \"prefix=$(prefix)\" \\\n-       \"includedir=$(includedir)\" \\\n-       \"AR=$(AR)\" \\\n-       \"AS=$(AS)\" \\\n-       \"LD=$(LD)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"NM=$(NM)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"RANLIB=$(RANLIB)\" \\\n-       \"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES = \n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-all: all-recursive\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .cpp .lo .o .obj\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/../multilib.am $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-$(top_srcdir)/../multilib.am $(am__empty):\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-liboffloadmic_host.spec: $(top_builddir)/config.status $(srcdir)/liboffloadmic_host.spec.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-liboffloadmic_target.spec: $(top_builddir)/config.status $(srcdir)/liboffloadmic_target.spec.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-\n-install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tlist2=; for p in $$list; do \\\n-\t  if test -f $$p; then \\\n-\t    list2=\"$$list2 $$p\"; \\\n-\t  else :; fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n-\t}\n-\n-uninstall-toolexeclibLTLIBRARIES:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n-\tdone\n-\n-clean-toolexeclibLTLIBRARIES:\n-\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; \\\n-\tlocs=`for p in $$list; do echo $$p; done | \\\n-\t      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \\\n-\t      sort -u`; \\\n-\ttest -z \"$$locs\" || { \\\n-\t  echo rm -f $${locs}; \\\n-\t  rm -f $${locs}; \\\n-\t}\n-\n-libcoi_device.la: $(libcoi_device_la_OBJECTS) $(libcoi_device_la_DEPENDENCIES) $(EXTRA_libcoi_device_la_DEPENDENCIES) \n-\t$(AM_V_CXXLD)$(libcoi_device_la_LINK) $(am_libcoi_device_la_rpath) $(libcoi_device_la_OBJECTS) $(libcoi_device_la_LIBADD) $(LIBS)\n-\n-libcoi_host.la: $(libcoi_host_la_OBJECTS) $(libcoi_host_la_DEPENDENCIES) $(EXTRA_libcoi_host_la_DEPENDENCIES) \n-\t$(AM_V_CXXLD)$(libcoi_host_la_LINK) $(am_libcoi_host_la_rpath) $(libcoi_host_la_OBJECTS) $(libcoi_host_la_LIBADD) $(LIBS)\n-\n-liboffloadmic_host.la: $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_DEPENDENCIES) $(EXTRA_liboffloadmic_host_la_DEPENDENCIES) \n-\t$(AM_V_CXXLD)$(liboffloadmic_host_la_LINK) $(am_liboffloadmic_host_la_rpath) $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_LIBADD) $(LIBS)\n-\n-liboffloadmic_target.la: $(liboffloadmic_target_la_OBJECTS) $(liboffloadmic_target_la_DEPENDENCIES) $(EXTRA_liboffloadmic_target_la_DEPENDENCIES) \n-\t$(AM_V_CXXLD)$(liboffloadmic_target_la_LINK) $(am_liboffloadmic_target_la_rpath) $(liboffloadmic_target_la_OBJECTS) $(liboffloadmic_target_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_device_la-coi_device.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_host_la-coi_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-cean_util.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-coi_client.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-dv_util.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-liboffload_error.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_engine.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_env.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_orsl.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_table.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_trace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_util.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-orsl-lite.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-coi_server.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-dv_util.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_error.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_table.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_trace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_util.Plo@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<\n-\n-liboffloadmic_host_la-liboffload_error.lo: runtime/liboffload_error.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-liboffload_error.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Tpo -c -o liboffloadmic_host_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Tpo $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='runtime/liboffload_error.c' object='liboffloadmic_host_la-liboffload_error.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n-\n-liboffloadmic_host_la-liboffload_msg.lo: runtime/liboffload_msg.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-liboffload_msg.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Tpo -c -o liboffloadmic_host_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Tpo $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='runtime/liboffload_msg.c' object='liboffloadmic_host_la-liboffload_msg.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n-\n-liboffloadmic_host_la-orsl-lite.lo: runtime/orsl-lite/lib/orsl-lite.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-orsl-lite.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Tpo -c -o liboffloadmic_host_la-orsl-lite.lo `test -f 'runtime/orsl-lite/lib/orsl-lite.c' || echo '$(srcdir)/'`runtime/orsl-lite/lib/orsl-lite.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Tpo $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='runtime/orsl-lite/lib/orsl-lite.c' object='liboffloadmic_host_la-orsl-lite.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-orsl-lite.lo `test -f 'runtime/orsl-lite/lib/orsl-lite.c' || echo '$(srcdir)/'`runtime/orsl-lite/lib/orsl-lite.c\n-\n-liboffloadmic_target_la-liboffload_error.lo: runtime/liboffload_error.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_target_la-liboffload_error.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Tpo -c -o liboffloadmic_target_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Tpo $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='runtime/liboffload_error.c' object='liboffloadmic_target_la-liboffload_error.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_target_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n-\n-liboffloadmic_target_la-liboffload_msg.lo: runtime/liboffload_msg.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_target_la-liboffload_msg.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Tpo -c -o liboffloadmic_target_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Tpo $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='runtime/liboffload_msg.c' object='liboffloadmic_target_la-liboffload_msg.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_target_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n-\n-.cpp.o:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n-\n-.cpp.obj:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.cpp.lo:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<\n-\n-libcoi_device_la-coi_device.lo: runtime/emulator/coi_device.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_device_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libcoi_device_la-coi_device.lo -MD -MP -MF $(DEPDIR)/libcoi_device_la-coi_device.Tpo -c -o libcoi_device_la-coi_device.lo `test -f 'runtime/emulator/coi_device.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_device.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libcoi_device_la-coi_device.Tpo $(DEPDIR)/libcoi_device_la-coi_device.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/emulator/coi_device.cpp' object='libcoi_device_la-coi_device.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_device_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libcoi_device_la-coi_device.lo `test -f 'runtime/emulator/coi_device.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_device.cpp\n-\n-libcoi_host_la-coi_host.lo: runtime/emulator/coi_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libcoi_host_la-coi_host.lo -MD -MP -MF $(DEPDIR)/libcoi_host_la-coi_host.Tpo -c -o libcoi_host_la-coi_host.lo `test -f 'runtime/emulator/coi_host.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libcoi_host_la-coi_host.Tpo $(DEPDIR)/libcoi_host_la-coi_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/emulator/coi_host.cpp' object='libcoi_host_la-coi_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libcoi_host_la-coi_host.lo `test -f 'runtime/emulator/coi_host.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_host.cpp\n-\n-liboffloadmic_host_la-dv_util.lo: runtime/dv_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-dv_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo -c -o liboffloadmic_host_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo $(DEPDIR)/liboffloadmic_host_la-dv_util.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/dv_util.cpp' object='liboffloadmic_host_la-dv_util.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n-\n-liboffloadmic_host_la-offload_common.lo: runtime/offload_common.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_common.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_common.Tpo -c -o liboffloadmic_host_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_common.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_common.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_common.cpp' object='liboffloadmic_host_la-offload_common.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n-\n-liboffloadmic_host_la-offload_table.lo: runtime/offload_table.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_table.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_table.Tpo -c -o liboffloadmic_host_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_table.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_table.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_table.cpp' object='liboffloadmic_host_la-offload_table.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n-\n-liboffloadmic_host_la-offload_trace.lo: runtime/offload_trace.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_trace.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_trace.Tpo -c -o liboffloadmic_host_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_trace.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_trace.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_trace.cpp' object='liboffloadmic_host_la-offload_trace.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n-\n-liboffloadmic_host_la-offload_util.lo: runtime/offload_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_util.Tpo -c -o liboffloadmic_host_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_util.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_util.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_util.cpp' object='liboffloadmic_host_la-offload_util.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n-\n-liboffloadmic_host_la-cean_util.lo: runtime/cean_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-cean_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-cean_util.Tpo -c -o liboffloadmic_host_la-cean_util.lo `test -f 'runtime/cean_util.cpp' || echo '$(srcdir)/'`runtime/cean_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-cean_util.Tpo $(DEPDIR)/liboffloadmic_host_la-cean_util.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/cean_util.cpp' object='liboffloadmic_host_la-cean_util.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-cean_util.lo `test -f 'runtime/cean_util.cpp' || echo '$(srcdir)/'`runtime/cean_util.cpp\n-\n-liboffloadmic_host_la-coi_client.lo: runtime/coi/coi_client.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-coi_client.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-coi_client.Tpo -c -o liboffloadmic_host_la-coi_client.lo `test -f 'runtime/coi/coi_client.cpp' || echo '$(srcdir)/'`runtime/coi/coi_client.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-coi_client.Tpo $(DEPDIR)/liboffloadmic_host_la-coi_client.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/coi/coi_client.cpp' object='liboffloadmic_host_la-coi_client.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-coi_client.lo `test -f 'runtime/coi/coi_client.cpp' || echo '$(srcdir)/'`runtime/coi/coi_client.cpp\n-\n-liboffloadmic_host_la-compiler_if_host.lo: runtime/compiler_if_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-compiler_if_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Tpo -c -o liboffloadmic_host_la-compiler_if_host.lo `test -f 'runtime/compiler_if_host.cpp' || echo '$(srcdir)/'`runtime/compiler_if_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Tpo $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/compiler_if_host.cpp' object='liboffloadmic_host_la-compiler_if_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-compiler_if_host.lo `test -f 'runtime/compiler_if_host.cpp' || echo '$(srcdir)/'`runtime/compiler_if_host.cpp\n-\n-liboffloadmic_host_la-offload_engine.lo: runtime/offload_engine.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_engine.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_engine.Tpo -c -o liboffloadmic_host_la-offload_engine.lo `test -f 'runtime/offload_engine.cpp' || echo '$(srcdir)/'`runtime/offload_engine.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_engine.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_engine.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_engine.cpp' object='liboffloadmic_host_la-offload_engine.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_engine.lo `test -f 'runtime/offload_engine.cpp' || echo '$(srcdir)/'`runtime/offload_engine.cpp\n-\n-liboffloadmic_host_la-offload_env.lo: runtime/offload_env.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_env.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_env.Tpo -c -o liboffloadmic_host_la-offload_env.lo `test -f 'runtime/offload_env.cpp' || echo '$(srcdir)/'`runtime/offload_env.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_env.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_env.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_env.cpp' object='liboffloadmic_host_la-offload_env.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_env.lo `test -f 'runtime/offload_env.cpp' || echo '$(srcdir)/'`runtime/offload_env.cpp\n-\n-liboffloadmic_host_la-offload_host.lo: runtime/offload_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_host.Tpo -c -o liboffloadmic_host_la-offload_host.lo `test -f 'runtime/offload_host.cpp' || echo '$(srcdir)/'`runtime/offload_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_host.cpp' object='liboffloadmic_host_la-offload_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_host.lo `test -f 'runtime/offload_host.cpp' || echo '$(srcdir)/'`runtime/offload_host.cpp\n-\n-liboffloadmic_host_la-offload_omp_host.lo: runtime/offload_omp_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_omp_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo -c -o liboffloadmic_host_la-offload_omp_host.lo `test -f 'runtime/offload_omp_host.cpp' || echo '$(srcdir)/'`runtime/offload_omp_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_omp_host.cpp' object='liboffloadmic_host_la-offload_omp_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_omp_host.lo `test -f 'runtime/offload_omp_host.cpp' || echo '$(srcdir)/'`runtime/offload_omp_host.cpp\n-\n-liboffloadmic_host_la-offload_orsl.lo: runtime/offload_orsl.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_orsl.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Tpo -c -o liboffloadmic_host_la-offload_orsl.lo `test -f 'runtime/offload_orsl.cpp' || echo '$(srcdir)/'`runtime/offload_orsl.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_orsl.cpp' object='liboffloadmic_host_la-offload_orsl.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_orsl.lo `test -f 'runtime/offload_orsl.cpp' || echo '$(srcdir)/'`runtime/offload_orsl.cpp\n-\n-liboffloadmic_host_la-offload_timer_host.lo: runtime/offload_timer_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_timer_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Tpo -c -o liboffloadmic_host_la-offload_timer_host.lo `test -f 'runtime/offload_timer_host.cpp' || echo '$(srcdir)/'`runtime/offload_timer_host.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_timer_host.cpp' object='liboffloadmic_host_la-offload_timer_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_timer_host.lo `test -f 'runtime/offload_timer_host.cpp' || echo '$(srcdir)/'`runtime/offload_timer_host.cpp\n-\n-liboffloadmic_target_la-dv_util.lo: runtime/dv_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-dv_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-dv_util.Tpo -c -o liboffloadmic_target_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-dv_util.Tpo $(DEPDIR)/liboffloadmic_target_la-dv_util.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/dv_util.cpp' object='liboffloadmic_target_la-dv_util.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n-\n-liboffloadmic_target_la-offload_common.lo: runtime/offload_common.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_common.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_common.Tpo -c -o liboffloadmic_target_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_common.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_common.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_common.cpp' object='liboffloadmic_target_la-offload_common.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n-\n-liboffloadmic_target_la-offload_table.lo: runtime/offload_table.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_table.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_table.Tpo -c -o liboffloadmic_target_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_table.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_table.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_table.cpp' object='liboffloadmic_target_la-offload_table.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n-\n-liboffloadmic_target_la-offload_trace.lo: runtime/offload_trace.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_trace.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_trace.Tpo -c -o liboffloadmic_target_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_trace.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_trace.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_trace.cpp' object='liboffloadmic_target_la-offload_trace.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n-\n-liboffloadmic_target_la-offload_util.lo: runtime/offload_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_util.Tpo -c -o liboffloadmic_target_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_util.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_util.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_util.cpp' object='liboffloadmic_target_la-offload_util.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n-\n-liboffloadmic_target_la-coi_server.lo: runtime/coi/coi_server.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-coi_server.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-coi_server.Tpo -c -o liboffloadmic_target_la-coi_server.lo `test -f 'runtime/coi/coi_server.cpp' || echo '$(srcdir)/'`runtime/coi/coi_server.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-coi_server.Tpo $(DEPDIR)/liboffloadmic_target_la-coi_server.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/coi/coi_server.cpp' object='liboffloadmic_target_la-coi_server.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-coi_server.lo `test -f 'runtime/coi/coi_server.cpp' || echo '$(srcdir)/'`runtime/coi/coi_server.cpp\n-\n-liboffloadmic_target_la-compiler_if_target.lo: runtime/compiler_if_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-compiler_if_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Tpo -c -o liboffloadmic_target_la-compiler_if_target.lo `test -f 'runtime/compiler_if_target.cpp' || echo '$(srcdir)/'`runtime/compiler_if_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Tpo $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/compiler_if_target.cpp' object='liboffloadmic_target_la-compiler_if_target.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-compiler_if_target.lo `test -f 'runtime/compiler_if_target.cpp' || echo '$(srcdir)/'`runtime/compiler_if_target.cpp\n-\n-liboffloadmic_target_la-offload_omp_target.lo: runtime/offload_omp_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_omp_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo -c -o liboffloadmic_target_la-offload_omp_target.lo `test -f 'runtime/offload_omp_target.cpp' || echo '$(srcdir)/'`runtime/offload_omp_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_omp_target.cpp' object='liboffloadmic_target_la-offload_omp_target.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_omp_target.lo `test -f 'runtime/offload_omp_target.cpp' || echo '$(srcdir)/'`runtime/offload_omp_target.cpp\n-\n-liboffloadmic_target_la-offload_target.lo: runtime/offload_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_target.Tpo -c -o liboffloadmic_target_la-offload_target.lo `test -f 'runtime/offload_target.cpp' || echo '$(srcdir)/'`runtime/offload_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_target.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_target.cpp' object='liboffloadmic_target_la-offload_target.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_target.lo `test -f 'runtime/offload_target.cpp' || echo '$(srcdir)/'`runtime/offload_target.cpp\n-\n-liboffloadmic_target_la-offload_timer_target.lo: runtime/offload_timer_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_timer_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Tpo -c -o liboffloadmic_target_la-offload_timer_target.lo `test -f 'runtime/offload_timer_target.cpp' || echo '$(srcdir)/'`runtime/offload_timer_target.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='runtime/offload_timer_target.cpp' object='liboffloadmic_target_la-offload_timer_target.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_timer_target.lo `test -f 'runtime/offload_timer_target.cpp' || echo '$(srcdir)/'`runtime/offload_timer_target.cpp\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-install-nodist_libsubincludeHEADERS: $(nodist_libsubinclude_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(libsubincludedir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(libsubincludedir)'\"; \\\n-\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(libsubincludedir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-nodist_libsubincludeHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(libsubincludedir)'; $(am__uninstall_files_from_dir)\n-install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(toolexeclibdir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-nodist_toolexeclibHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)\n-\n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run 'make' without going through this Makefile.\n-# To change the values of 'make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in 'config.status', edit 'config.status'\n-#     (which will cause the Makefiles to be regenerated when you run 'make');\n-# (2) otherwise, pass the desired values on the 'make' command line.\n-$(am__recursive_targets):\n-\t@fail=; \\\n-\tif $(am__make_keepgoing); then \\\n-\t  failcom='fail=yes'; \\\n-\telse \\\n-\t  failcom='exit 1'; \\\n-\tfi; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tcase \"$@\" in \\\n-\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n-\t  *) list='$(SUBDIRS)' ;; \\\n-\tesac; \\\n-\tfor subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-ID: $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); mkid -fID $$unique\n-tags: tags-recursive\n-TAGS: tags\n-\n-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n-\t  include_option=--etags-include; \\\n-\t  empty_fix=.; \\\n-\telse \\\n-\t  include_option=--include; \\\n-\t  empty_fix=; \\\n-\tfi; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test ! -f $$subdir/TAGS || \\\n-\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\t$(am__define_uniq_tagged_files); \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: ctags-recursive\n-\n-CTAGS: ctags\n-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-cscope: cscope.files\n-\ttest ! -s cscope.files \\\n-\t  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)\n-clean-cscope:\n-\t-rm -f cscope.files\n-cscope.files: clean-cscope cscopelist\n-cscopelist: cscopelist-recursive\n-\n-cscopelist-am: $(am__tagged_files)\n-\tlist='$(am__tagged_files)'; \\\n-\tcase \"$(srcdir)\" in \\\n-\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n-\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n-\tesac; \\\n-\tfor i in $$list; do \\\n-\t  if test -f \"$$i\"; then \\\n-\t    echo \"$(subdir)/$$i\"; \\\n-\t  else \\\n-\t    echo \"$$sdir/$$i\"; \\\n-\t  fi; \\\n-\tdone >> $(top_builddir)/cscope.files\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\t-rm -f cscope.out cscope.in.out cscope.po.out cscope.files\n-check-am: all-am\n-check: check-recursive\n-all-am: Makefile $(LTLIBRARIES) $(HEADERS) all-local\n-installdirs: installdirs-recursive\n-installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-recursive\n-install-exec: install-exec-recursive\n-install-data: install-data-recursive\n-uninstall: uninstall-recursive\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-recursive\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-recursive\n-\n-clean-am: clean-generic clean-libtool clean-local \\\n-\tclean-toolexeclibLTLIBRARIES mostlyclean-am\n-\n-distclean: distclean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-local distclean-tags\n-\n-dvi: dvi-recursive\n-\n-dvi-am:\n-\n-html: html-recursive\n-\n-html-am:\n-\n-info: info-recursive\n-\n-info-am:\n-\n-install-data-am: install-nodist_libsubincludeHEADERS\n-\n-install-dvi: install-dvi-recursive\n-\n-install-dvi-am:\n-\n-install-exec-am: install-exec-local install-nodist_toolexeclibHEADERS \\\n-\tinstall-toolexeclibLTLIBRARIES\n-\n-install-html: install-html-recursive\n-\n-install-html-am:\n-\n-install-info: install-info-recursive\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-recursive\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-recursive\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic \\\n-\tmaintainer-clean-local\n-\n-mostlyclean: mostlyclean-recursive\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool mostlyclean-local\n-\n-pdf: pdf-recursive\n-\n-pdf-am:\n-\n-ps: ps-recursive\n-\n-ps-am:\n-\n-uninstall-am: uninstall-nodist_libsubincludeHEADERS \\\n-\tuninstall-nodist_toolexeclibHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.MAKE: $(am__recursive_targets) install-am install-strip\n-\n-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am all-local \\\n-\tam--refresh check check-am clean clean-cscope clean-generic \\\n-\tclean-libtool clean-local clean-toolexeclibLTLIBRARIES cscope \\\n-\tcscopelist-am ctags ctags-am distclean distclean-compile \\\n-\tdistclean-generic distclean-libtool distclean-local \\\n-\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n-\tinstall-am install-data install-data-am install-dvi \\\n-\tinstall-dvi-am install-exec install-exec-am install-exec-local \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-nodist_libsubincludeHEADERS \\\n-\tinstall-nodist_toolexeclibHEADERS install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip \\\n-\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n-\tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-local mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-local pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am uninstall-nodist_libsubincludeHEADERS \\\n-\tuninstall-nodist_toolexeclibHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.PRECIOUS: Makefile\n-\n-\n-# ofldbegin, ofldend\n-all-local: $(ofld_obj)\n-\n-ofldbegin.o: runtime/ofldbegin.cpp\n-\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n-\n-ofldend.o: runtime/ofldend.cpp\n-\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-.MAKE .PHONY: all-multi clean-multi distclean-multi install-am \\\n-\t      install-multi maintainer-clean-multi mostlyclean-multi\n-\n-install-exec-local: install-multi\n-\n-all-local: all-multi\n-mostlyclean-local: mostlyclean-multi\n-clean-local: clean-multi\n-distclean-local: distclean-multi\n-maintainer-clean-local: maintainer-clean-multi\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "31a2695c10ebc2246492941e3468a56ebd842061", "filename": "liboffloadmic/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1180, "changes": 1180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Faclocal.m4?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1180 +0,0 @@\n-# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,\n-[m4_warning([this file was generated for autoconf 2.69.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n-\n-# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.15'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.15.1], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.15.1])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to\n-# '$srcdir', '$srcdir/..', or '$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is '.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\n-# Expand $ac_aux_dir to an absolute path.\n-am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ([2.52])dnl\n- m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"OBJC\", \"OBJCXX\", \"UPC\", or \"GJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-m4_if([$1], [CC],   [depcc=\"$CC\"   am_compiler_list=],\n-      [$1], [CXX],  [depcc=\"$CXX\"  am_compiler_list=],\n-      [$1], [OBJC], [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-      [$1], [OBJCXX], [depcc=\"$OBJCXX\" am_compiler_list='gcc3 gcc'],\n-      [$1], [UPC],  [depcc=\"$UPC\"  am_compiler_list=],\n-      [$1], [GCJ],  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                    [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named 'D' -- because '-MD' means \"put the output\n-  # in D\".\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n-      # Solaris 10 /bin/sh.\n-      echo '/* dummy */' > sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle '-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs.\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # After this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested.\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n-      # This compiler won't grok '-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES.\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE([dependency-tracking], [dnl\n-AS_HELP_STRING(\n-  [--enable-dependency-tracking],\n-  [do not reject slow dependency extractors])\n-AS_HELP_STRING(\n-  [--disable-dependency-tracking],\n-  [speeds up one-time build])])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-AC_SUBST([am__nodep])dnl\n-_AM_SUBST_NOTMAKE([am__nodep])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Older Autoconf quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each '.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.\n-m4_define([AC_PROG_CC],\n-m4_defn([AC_PROG_CC])\n-[_AM_PROG_CC_C_O\n-])\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.65])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[AC_DIAGNOSE([obsolete],\n-             [$0: two- and three-arguments forms are deprecated.])\n-m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(\n-  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),\n-  [ok:ok],,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED([PACKAGE], [\"$PACKAGE\"], [Name of package])\n- AC_DEFINE_UNQUOTED([VERSION], [\"$VERSION\"], [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])\n-AM_MISSING_PROG([AUTOCONF], [autoconf])\n-AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])\n-AM_MISSING_PROG([AUTOHEADER], [autoheader])\n-AM_MISSING_PROG([MAKEINFO], [makeinfo])\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-# For better backward compatibility.  To be removed once Automake 1.9.x\n-# dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n-AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n-# We need awk for the \"check\" target (and possibly the TAP driver).  The\n-# system \"awk\" is bad on some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES([CC])],\n-\t\t  [m4_define([AC_PROG_CC],\n-\t\t\t     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES([CXX])],\n-\t\t  [m4_define([AC_PROG_CXX],\n-\t\t\t     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES([OBJC])],\n-\t\t  [m4_define([AC_PROG_OBJC],\n-\t\t\t     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],\n-\t\t  [_AM_DEPENDENCIES([OBJCXX])],\n-\t\t  [m4_define([AC_PROG_OBJCXX],\n-\t\t\t     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl\n-])\n-AC_REQUIRE([AM_SILENT_RULES])dnl\n-dnl The testsuite driver may need to know about EXEEXT, so add the\n-dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This\n-dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-\n-# POSIX will say in a future version that running \"rm -f\" with no argument\n-# is OK; and we want to be able to make that assumption in our Makefile\n-# recipes.  So use an aggressive probe to check that the usage we want is\n-# actually supported \"in the wild\" to an acceptable degree.\n-# See automake bug#10828.\n-# To make any issue more visible, cause the running configure to be aborted\n-# by default if the 'rm' program in use doesn't match our expectations; the\n-# user can still override this though.\n-if rm -f && rm -fr && rm -rf; then : OK; else\n-  cat >&2 <<'END'\n-Oops!\n-\n-Your 'rm' program seems unable to run without file operands specified\n-on the command line, even when the '-f' option is present.  This is contrary\n-to the behaviour of most rm programs out there, and not conforming with\n-the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>\n-\n-Please tell bug-automake@gnu.org about your system, including the value\n-of your $PATH and any error possibly output before this message.  This\n-can help us improve future automake versions.\n-\n-END\n-  if test x\"$ACCEPT_INFERIOR_RM_PROGRAM\" = x\"yes\"; then\n-    echo 'Configuration will proceed anyway, since you have set the' >&2\n-    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to \"yes\"' >&2\n-    echo >&2\n-  else\n-    cat >&2 <<'END'\n-Aborting the configuration process, to ensure you take notice of the issue.\n-\n-You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n-\n-If you want to complete the configuration process using your problematic\n-'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n-to \"yes\", and re-run configure.\n-\n-END\n-    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])\n-  fi\n-fi\n-dnl The trailing newline in this macro's definition is deliberate, for\n-dnl backward compatibility and to allow trailing 'dnl'-style comments\n-dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.\n-])\n-\n-dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST([install_sh])])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless 'enable' is passed literally.\n-# For symmetry, 'disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n-      am_maintainer_other[ make rules and dependencies not useful\n-      (and sometimes confusing) to the casual installer])],\n-    [USE_MAINTAINER_MODE=$enableval],\n-    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it is modern enough.\n-# If it is, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --is-lightweight\"; then\n-  am_missing_run=\"$MISSING \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN(['missing' script is too old or missing])\n-fi\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), [1])])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_CC_C_O\n-# ---------------\n-# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC\n-# to automatically call this.\n-AC_DEFUN([_AM_PROG_CC_C_O],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([compile])dnl\n-AC_LANG_PUSH([C])dnl\n-AC_CACHE_CHECK(\n-  [whether $CC understands -c and -o together],\n-  [am_cv_prog_cc_c_o],\n-  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])\n-  # Make sure it works both with $CC and with simple cc.\n-  # Following AC_PROG_CC_C_O, we do the test twice because some\n-  # compilers refuse to overwrite an existing .o file with -o,\n-  # though they will create one.\n-  am_cv_prog_cc_c_o=yes\n-  for am_i in 1 2; do\n-    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \\\n-         && test -f conftest2.$ac_objext; then\n-      : OK\n-    else\n-      am_cv_prog_cc_c_o=no\n-      break\n-    fi\n-  done\n-  rm -f core conftest*\n-  unset am_i])\n-if test \"$am_cv_prog_cc_c_o\" != yes; then\n-   # Losing compiler, so override with the script.\n-   # FIXME: It is wrong to rewrite CC.\n-   # But if we don't then we get into trouble of one sort or another.\n-   # A longer-term fix would be to have automake use am__CC in this case,\n-   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n-   CC=\"$am_aux_dir/compile $CC\"\n-fi\n-AC_LANG_POP([C])])\n-\n-# For backward compatibility.\n-AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_RUN_LOG(COMMAND)\n-# -------------------\n-# Run COMMAND, save the exit status in ac_status, and log it.\n-# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)\n-AC_DEFUN([AM_RUN_LOG],\n-[{ echo \"$as_me:$LINENO: $1\" >&AS_MESSAGE_LOG_FD\n-   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD\n-   ac_status=$?\n-   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n-   (exit $ac_status); }])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;\n-esac\n-\n-# Do 'set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   am_has_slept=no\n-   for am_try in 1 2; do\n-     echo \"timestamp, slept: $am_has_slept\" > conftest.file\n-     set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-     if test \"$[*]\" = \"X\"; then\n-\t# -L didn't work.\n-\tset X `ls -t \"$srcdir/configure\" conftest.file`\n-     fi\n-     if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-\t&& test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-\t# If neither matched, then we have a broken ls.  This can happen\n-\t# if, for instance, CONFIG_SHELL is bash and it inherits a\n-\t# broken ls alias from the environment.  This has actually\n-\t# happened.  Such a system could not be considered \"sane\".\n-\tAC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-  alias in your environment])\n-     fi\n-     if test \"$[2]\" = conftest.file || test $am_try -eq 2; then\n-       break\n-     fi\n-     # Just in case.\n-     sleep 1\n-     am_has_slept=yes\n-   done\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT([yes])\n-# If we didn't sleep, we still need to ensure time stamps of config.status and\n-# generated files are strictly newer.\n-am_sleep_pid=\n-if grep 'slept: no' conftest.file >/dev/null 2>&1; then\n-  ( sleep 1 ) &\n-  am_sleep_pid=$!\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-  [AC_MSG_CHECKING([that generated files are newer than configure])\n-   if test -n \"$am_sleep_pid\"; then\n-     # Hide warnings about reused PIDs.\n-     wait $am_sleep_pid 2>/dev/null\n-   fi\n-   AC_MSG_RESULT([done])])\n-rm -f conftest.file\n-])\n-\n-# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SILENT_RULES([DEFAULT])\n-# --------------------------\n-# Enable less verbose build rules; with the default set to DEFAULT\n-# (\"yes\" being less verbose, \"no\" or empty being verbose).\n-AC_DEFUN([AM_SILENT_RULES],\n-[AC_ARG_ENABLE([silent-rules], [dnl\n-AS_HELP_STRING(\n-  [--enable-silent-rules],\n-  [less verbose build output (undo: \"make V=1\")])\n-AS_HELP_STRING(\n-  [--disable-silent-rules],\n-  [verbose build output (undo: \"make V=0\")])dnl\n-])\n-case $enable_silent_rules in @%:@ (((\n-  yes) AM_DEFAULT_VERBOSITY=0;;\n-   no) AM_DEFAULT_VERBOSITY=1;;\n-    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;\n-esac\n-dnl\n-dnl A few 'make' implementations (e.g., NonStop OS and NextStep)\n-dnl do not support nested variable expansions.\n-dnl See automake bug#9928 and bug#10237.\n-am_make=${MAKE-make}\n-AC_CACHE_CHECK([whether $am_make supports nested variables],\n-   [am_cv_make_support_nested_variables],\n-   [if AS_ECHO([['TRUE=$(BAR$(V))\n-BAR0=false\n-BAR1=true\n-V=1\n-am__doit:\n-\t@$(TRUE)\n-.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then\n-  am_cv_make_support_nested_variables=yes\n-else\n-  am_cv_make_support_nested_variables=no\n-fi])\n-if test $am_cv_make_support_nested_variables = yes; then\n-  dnl Using '$V' instead of '$(V)' breaks IRIX make.\n-  AM_V='$(V)'\n-  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\n-else\n-  AM_V=$AM_DEFAULT_VERBOSITY\n-  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\n-fi\n-AC_SUBST([AM_V])dnl\n-AM_SUBST_NOTMAKE([AM_V])dnl\n-AC_SUBST([AM_DEFAULT_V])dnl\n-AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl\n-AC_SUBST([AM_DEFAULT_VERBOSITY])dnl\n-AM_BACKSLASH='\\'\n-AC_SUBST([AM_BACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n-])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor 'install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in \"make install-strip\", and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using 'strip' when the user\n-# run \"make install-strip\".  However 'strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the 'STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of 'v7', 'ustar', or 'pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-#\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-\n-# We'll loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-\n-m4_if([$1], [v7],\n-  [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-\n-  [m4_case([$1],\n-    [ustar],\n-     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.\n-      # There is notably a 21 bits limit for the UID and the GID.  In fact,\n-      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343\n-      # and bug#13588).\n-      am_max_uid=2097151 # 2^21 - 1\n-      am_max_gid=$am_max_uid\n-      # The $UID and $GID variables are not portable, so we need to resort\n-      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls\n-      # below are definitely unexpected, so allow the users to see them\n-      # (that is, avoid stderr redirection).\n-      am_uid=`id -u || echo unknown`\n-      am_gid=`id -g || echo unknown`\n-      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])\n-      if test $am_uid -le $am_max_uid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-         AC_MSG_RESULT([no])\n-         _am_tools=none\n-      fi\n-      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])\n-      if test $am_gid -le $am_max_gid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-        AC_MSG_RESULT([no])\n-        _am_tools=none\n-      fi],\n-\n-  [pax],\n-    [],\n-\n-  [m4_fatal([Unknown tar format])])\n-\n-  AC_MSG_CHECKING([how to create a $1 tar archive])\n-\n-  # Go ahead even if we have the value already cached.  We do so because we\n-  # need to set the values for the 'am__tar' and 'am__untar' variables.\n-  _am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-\n-  for _am_tool in $_am_tools; do\n-    case $_am_tool in\n-    gnutar)\n-      for _am_tar in tar gnutar gtar; do\n-        AM_RUN_LOG([$_am_tar --version]) && break\n-      done\n-      am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-      am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-      am__untar=\"$_am_tar -xf -\"\n-      ;;\n-    plaintar)\n-      # Must skip GNU tar: if it does not support --format= it doesn't create\n-      # ustar tarball either.\n-      (tar --version) >/dev/null 2>&1 && continue\n-      am__tar='tar chf - \"$$tardir\"'\n-      am__tar_='tar chf - \"$tardir\"'\n-      am__untar='tar xf -'\n-      ;;\n-    pax)\n-      am__tar='pax -L -x $1 -w \"$$tardir\"'\n-      am__tar_='pax -L -x $1 -w \"$tardir\"'\n-      am__untar='pax -r'\n-      ;;\n-    cpio)\n-      am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-      am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-      am__untar='cpio -i -H $1 -d'\n-      ;;\n-    none)\n-      am__tar=false\n-      am__tar_=false\n-      am__untar=false\n-      ;;\n-    esac\n-\n-    # If the value was cached, stop now.  We just wanted to have am__tar\n-    # and am__untar set.\n-    test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-    # tar/untar a dummy directory, and stop if the command works.\n-    rm -rf conftest.dir\n-    mkdir conftest.dir\n-    echo GrepMe > conftest.dir/file\n-    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-    rm -rf conftest.dir\n-    if test -s conftest.tar; then\n-      AM_RUN_LOG([$am__untar <conftest.tar])\n-      AM_RUN_LOG([cat conftest.dir/file])\n-      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-    fi\n-  done\n-  rm -rf conftest.dir\n-\n-  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-  AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/acx.m4])\n-m4_include([../config/depstand.m4])\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/override.m4])\n-m4_include([../config/toolexeclibdir.m4])\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])"}, {"sha": "b3cfff76f719cb6cb2aee71549bc5aee552ac523", "filename": "liboffloadmic/configure", "status": "removed", "additions": 0, "deletions": 17512, "changes": 17512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "f64f182e8efa72d68499c59eb38c00e226274d8a", "filename": "liboffloadmic/configure.ac", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure.ac?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,143 +0,0 @@\n-#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n-#\n-#    Redistribution and use in source and binary forms, with or without\n-#    modification, are permitted provided that the following conditions\n-#    are met:\n-#\n-#      * Redistributions of source code must retain the above copyright\n-#        notice, this list of conditions and the following disclaimer.\n-#      * Redistributions in binary form must reproduce the above copyright\n-#        notice, this list of conditions and the following disclaimer in the\n-#        documentation and/or other materials provided with the distribution.\n-#      * Neither the name of Intel Corporation nor the names of its\n-#        contributors may be used to endorse or promote products derived\n-#        from this software without specific prior written permission.\n-#\n-#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-# Process this file with autoconf to produce a configure script, like so:\n-# aclocal -I .. -I ../config && autoconf && automake\n-\n-AC_INIT([MIC Offload Runtime Library], [1.0], ,[liboffloadmic])\n-\n-AC_CANONICAL_SYSTEM\n-target_alias=${target_alias-$host_alias}\n-AC_SUBST(target_alias)\n-\n-AM_INIT_AUTOMAKE(foreign no-dist)\n-AM_MAINTAINER_MODE\n-\n-AC_PROG_CC\n-AC_PROG_CXX\n-AC_CONFIG_FILES([Makefile liboffloadmic_host.spec liboffloadmic_target.spec])\n-AM_ENABLE_MULTILIB(, ..)\n-AC_CONFIG_SUBDIRS(plugin)\n-AC_FUNC_ALLOCA\n-AC_CHECK_HEADERS([mm_malloc.h], [], [AC_MSG_ERROR([\"Couldn't find mm_malloc.h\"])])\n-AC_CHECK_FUNCS([__secure_getenv secure_getenv])\n-\n-# Get target configure.\n-. ${srcdir}/configure.tgt\n-if test -n \"$UNSUPPORTED\"; then\n-  AC_MSG_ERROR([Configuration ${target} is unsupported])\n-fi\n-\n-if test \"${multilib}\" = \"yes\"; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n-AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n-AC_ARG_ENABLE([version-specific-runtime-libs],\n-  AC_HELP_STRING([--enable-version-specific-runtime-libs],\n-\t\t [Specify that runtime libraries should be installed in a compiler-specific directory]),\n-  [case \"$enableval\" in\n-    yes) enable_version_specific_runtime_libs=yes ;;\n-    no)  enable_version_specific_runtime_libs=no ;;\n-    *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n-   esac],\n-  [enable_version_specific_runtime_libs=no])\n-AC_MSG_RESULT($enable_version_specific_runtime_libs)\n-\n-# Make sure liboffloadmic is enabled\n-case \"$enable_liboffloadmic\" in\n-  host | target)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([Liboffloadmic is disabled]) ;;\n-esac\n-AM_CONDITIONAL(LIBOFFLOADMIC_HOST, [test x\"$enable_liboffloadmic\" = xhost])\n-\n-GCC_WITH_TOOLEXECLIBDIR\n-\n-# Calculate toolexeclibdir.\n-# Also toolexecdir, though it's only used in toolexeclibdir.\n-case ${enable_version_specific_runtime_libs} in\n-  yes)\n-    # Need the gcc compiler version to know where to install libraries\n-    # and header files if --enable-version-specific-runtime-libs option\n-    # is selected.\n-    toolexecdir='$(libdir)/gcc/$(target_alias)'\n-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n-    ;;\n-  no)\n-    if test -n \"$with_cross_host\" &&\n-       test x\"$with_cross_host\" != x\"no\"; then\n-      # Install a library built with a cross compiler in tooldir, not libdir.\n-      toolexecdir='$(exec_prefix)/$(target_alias)'\n-      case ${with_toolexeclibdir} in\n-\tno)\n-\t  toolexeclibdir='$(toolexecdir)/lib'\n-\t  ;;\n-\t*)\n-\t  toolexeclibdir=${with_toolexeclibdir}\n-\t  ;;\n-      esac\n-    else\n-      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n-      toolexeclibdir='$(libdir)'\n-    fi\n-    multi_os_directory=`$CC -print-multi-os-directory`\n-    case $multi_os_directory in\n-      .) ;; # Avoid trailing /.\n-      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n-    esac\n-    ;;\n-esac\n-\n-AC_LIBTOOL_DLOPEN\n-AM_PROG_LIBTOOL\n-# Forbid libtool to hardcode RPATH, because we want to be able to specify\n-# library search directory using LD_LIBRARY_PATH\n-hardcode_into_libs=no\n-AC_SUBST(toolexecdir)\n-AC_SUBST(toolexeclibdir)\n-\n-AC_SUBST(lt_cv_dlopen_libs)\n-\n-if test $enable_shared = yes; then\n-  link_offloadmic_host=\"-loffloadmic_host %{static: $LIBS}\"\n-  link_offloadmic_target=\"-loffloadmic_target %{static: $LIBS}\"\n-else\n-  link_offloadmic_host=\"-loffloadmic_host $LIBS\"\n-  link_offloadmic_target=\"-loffloadmic_target $LIBS\"\n-fi\n-AC_SUBST(link_offloadmic_host)\n-AC_SUBST(link_offloadmic_target)\n-\n-# Determine what GCC version number to use in filesystem paths.\n-GCC_BASE_VER\n-\n-# Must be last\n-AC_OUTPUT"}, {"sha": "3c0310cb4777b87d6befdedaa6d36b0674e33df7", "filename": "liboffloadmic/configure.tgt", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure.tgt?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,39 +0,0 @@\n-#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n-#\n-#    Redistribution and use in source and binary forms, with or without\n-#    modification, are permitted provided that the following conditions\n-#    are met:\n-#\n-#      * Redistributions of source code must retain the above copyright\n-#        notice, this list of conditions and the following disclaimer.\n-#      * Redistributions in binary form must reproduce the above copyright\n-#        notice, this list of conditions and the following disclaimer in the\n-#        documentation and/or other materials provided with the distribution.\n-#      * Neither the name of Intel Corporation nor the names of its\n-#        contributors may be used to endorse or promote products derived\n-#        from this software without specific prior written permission.\n-#\n-#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-# Disable Offload Runtime library for non x86 architecture.\n-case \"${target}\" in\n-  x86_64-*-linux*)\n-    ;;\n-  i?86-*-linux*)\n-    ;;\n-  *-*-*)\n-    UNSUPPORTED=1 ;;\n-esac\n-\n-# Disable liboffloadmic on non POSIX hosted systems.\n-. ${srcdir}/../config/target-posix"}, {"sha": "3ef1019b5ce1b9ed6361657c3017ec6b1563a981", "filename": "liboffloadmic/doc/doxygen/config", "status": "removed", "additions": 0, "deletions": 2328, "changes": 2328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "e91d4be29d66b3bde980900d9ef60fe9f4f3c036", "filename": "liboffloadmic/doc/doxygen/header.tex", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,90 +0,0 @@\n-% Latex header for doxygen 1.8.3.1\n-\\documentclass{book}\n-\\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm]{geometry}\n-\\usepackage{makeidx}\n-\\usepackage{natbib}\n-\\usepackage{graphicx}\n-\\usepackage{multicol}\n-\\usepackage{float}\n-\\usepackage{listings}\n-\\usepackage{color}\n-\\usepackage{ifthen}\n-\\usepackage[table]{xcolor}\n-\\usepackage{textcomp}\n-\\usepackage{alltt}\n-\\usepackage{ifpdf}\n-\\ifpdf\n-\\usepackage[pdftex,\n-            pagebackref=true,\n-            colorlinks=true,\n-            linkcolor=blue,\n-            unicode\n-           ]{hyperref}\n-\\else\n-\\usepackage[ps2pdf,\n-            pagebackref=true,\n-            colorlinks=true,\n-            linkcolor=blue,\n-            unicode\n-           ]{hyperref}\n-\\usepackage{pspicture}\n-\\fi\n-\\usepackage[utf8]{inputenc}\n-\\usepackage{mathptmx}\n-\\usepackage[scaled=.90]{helvet}\n-\\usepackage{courier}\n-\\usepackage{sectsty}\n-\\usepackage{amssymb}\n-\\usepackage[titles]{tocloft}\n-\\usepackage{doxygen}\n-\\usepackage{fancyhdr}\n-\\pagestyle{fancy}\n-\\lstset{language=C++,inputencoding=utf8,basicstyle=\\footnotesize,breaklines=true,breakatwhitespace=true,tabsize=4,numbers=left }\n-\\makeindex\n-\\setcounter{tocdepth}{3}\n-\\renewcommand{\\footrulewidth}{0.4pt}\n-\\renewcommand{\\familydefault}{\\sfdefault}\n-\\hfuzz=15pt\n-\\setlength{\\emergencystretch}{15pt}\n-\\hbadness=750\n-\\tolerance=750\n-\\begin{document}\n-\\hypersetup{pageanchor=false,citecolor=blue}\n-\\begin{titlepage}\n-\\vspace*{7cm}\n-\\begin{center}\n-{\\Large Intel\\textsuperscript{\\textregistered} Offload Runtime Library }\\\\\n-\\vspace*{1cm}\n-{\\large Generated by Doxygen $doxygenversion }\\\\\n-\\vspace*{0.5cm}\n-{\\small $datetime }\\\\\n-\\end{center}\n-\\end{titlepage}\n-\n-{\\bf FTC Optimization Notice}\n-\n-Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for\n-optimizations that are not unique to Intel microprocessors. These optimizations include SSE2,\n-SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the\n-availability, functionality, or effectiveness of any optimization on microprocessors not\n-manufactured by Intel.\n-\n-Microprocessor-dependent optimizations in this product are intended for use with Intel\n-microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for\n-Intel microprocessors. Please refer to the applicable product User and Reference Guides for\n-more information regarding the specific instruction sets covered by this notice.\n-\n-Notice revision \\#20110804\n-\n-\\vspace*{0.5cm}\n-\n-{\\bf Trademarks}\n-\n-Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.\n-\n-This document is Copyright \\textcopyright 2014-2016, Intel Corporation. All rights reserved.\n-\n-\\pagenumbering{roman}\n-\\tableofcontents\n-\\pagenumbering{arabic}\n-\\hypersetup{pageanchor=true,citecolor=blue}"}, {"sha": "836e3e830d43ba294a01c01f6d6c4a74e3c582d6", "filename": "liboffloadmic/include/coi/common/COIEngine_common.h", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,121 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIENGINE_COMMON_H\n-#define _COIENGINE_COMMON_H\n-\n-/** @ingroup COIEngine\n- *  @addtogroup COIEnginecommon\n-@{\n-* @file common/COIEngine_common.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-#define COI_MAX_ISA_x86_64_DEVICES 128\n-#define COI_MAX_ISA_MIC_DEVICES    128\n-#define COI_MAX_ISA_KNF_DEVICES    0\n-#define COI_MAX_ISA_KNC_DEVICES    COI_MAX_ISA_MIC_DEVICES\n-#define COI_MAX_ISA_KNL_DEVICES    COI_MAX_ISA_MIC_DEVICES\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// List of ISA types of supported engines.\n-///\n-typedef enum\n-{\n-    COI_DEVICE_INVALID = 0,        ///< Represents an invalid device type.\n-    COI_DEVICE_SOURCE,             ///< The engine from which offload originates\n-    COI_DEVICE_MIC,                ///< Special value used to represent any device\n-    ///< in the Intel(R) Many Integrated Core family.\n-    COI_DEVICE_DEPRECATED_0,       ///< Placeholder for L1OM devices (deprecated).\n-    COI_DEVICE_KNC,                ///< K1OM devices (Knigts Corner).\n-    COI_DEVICE_KNL,                ///< Knights Landing devices\n-    COI_DEVICE_MAX,\n-    COI_DEVICE_KNF = COI_DEVICE_DEPRECATED_0\n-} COI_DEVICE_TYPE;\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// List of deprecated device types for backward compatibility\n-///\n-#define COI_ISA_INVALID COI_DEVICE_INVALID\n-#define COI_ISA_x86_64  COI_DEVICE_SOURCE\n-#define COI_ISA_MIC     COI_DEVICE_MIC\n-#define COI_ISA_KNF     COI_DEVICE_KNF\n-#define COI_ISA_KNC     COI_DEVICE_KNC\n-\n-typedef COI_DEVICE_TYPE COI_ISA_TYPE;\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Get the information about the COIEngine executing this function call.\n-///\n-/// @param  out_pType\n-///         [out] The COI_DEVICE_TYPE of the engine.\n-///\n-/// @param  out_pIndex\n-///         [out] The zero-based index of this engine in the collection of\n-///         engines of the ISA returned in out_pType.\n-///\n-/// @return COI_INVALID_POINTER if any of the parameters are NULL.\n-///\n-/// @return COI_SUCCESS\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEngineGetIndex(\n-    COI_DEVICE_TYPE    *out_pType,\n-    uint32_t           *out_pIndex);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIENGINE_COMMON_H */\n-\n-/*! @} */"}, {"sha": "9d5623d6edde0414c4bbd55bc26857edc4100390", "filename": "liboffloadmic/include/coi/common/COIEvent_common.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,84 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIEVENT_COMMON_H\n-#define _COIEVENT_COMMON_H\n-\n-/** @ingroup COIEvent\n- *  @addtogroup COIEventcommon\n-@{\n-* @file common/COIEvent_common.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Signal one shot user event. User events created on source can be\n-/// signaled from both sink and source. This fires the event and wakes up\n-/// threads waiting on COIEventWait.\n-///\n-/// Note: For events that are not registered or already signaled this call\n-///       will behave as a NOP. Users need to make sure that they pass valid\n-///       events on the sink side.\n-///\n-/// @param  in_Event\n-///         Event Handle to be signaled.\n-///\n-/// @return COI_INVAILD_HANDLE if in_Event was not a User event.\n-///\n-/// @return COI_ERROR if the signal fails to be sent from the sink.\n-///\n-/// @return COI_SUCCESS if the event was successfully signaled or ignored.\n-///\n-COIACCESSAPI\n-COIRESULT COIEventSignalUserEvent(COIEVENT in_Event);\n-///\n-///\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIEVENT_COMMON_H */\n-\n-/*! @} */"}, {"sha": "d6811c1cd214a5d5d4e48cf8886931828407bae5", "filename": "liboffloadmic/include/coi/common/COIMacros_common.h", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,229 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIMACROS_COMMON_H\n-#define _COIMACROS_COMMON_H\n-\n-#include <string.h>\n-#include \"../source/COIPipeline_source.h\"\n-#include \"../common/COITypes_common.h\"\n-\n-/// @file common/COIMacros_common.h\n-/// Commonly used macros\n-\n-// Note that UNUSUED_ATTR means that it is \"possibly\" unused, not \"definitely\".\n-// This should compile out in release mode if indeed it is unused.\n-    #define UNUSED_ATTR __attribute__((unused))\n-    #include <sched.h>\n-#ifndef UNREFERENCED_CONST_PARAM\n-#define UNREFERENCED_CONST_PARAM(P)     { void* x UNUSED_ATTR = \\\n-            (void*)(uint64_t)P; \\\n-}\n-#endif\n-\n-// This seems to work on everything.\n-#ifndef UNREFERENCED_PARAM\n-    #define UNREFERENCED_PARAM(P)          (P = P)\n-#endif\n-\n-#ifndef SYMBOL_VERSION\n-\n-        /* Linux support: */\n-\n-        #define SYMBOL_VERSION( SYMBOL , VERSION ) SYMBOL ## VERSION\n-\n-#endif\n-\n-/* The following are static inline definitions of functions used for manipulating\n-   COI_CPU_MASK info (The COI_CPU_MASK type is declared as an array of 16 uint64_t's\n-   in COITypes_common.h \"typedef uint64_t COI_CPU_MASK[16]\").\n-\n-   These static inlined functions are intended on being roughly the same as the Linux\n-   CPU_* macros defined in sched.h - with the important difference being a different\n-   fundamental type difference: cpu_set_t versus COI_CPU_MASK.\n-\n-   The motivation for writing this code was to ease portability on the host side of COI\n-   applications to both Windows and Linux.\n-*/\n-\n-/* Roughly equivalent to CPU_ISSET(). */\n-static inline uint64_t COI_CPU_MASK_ISSET(int bitNumber, const COI_CPU_MASK cpu_mask)\n-{\n-    if ((size_t)bitNumber < sizeof(COI_CPU_MASK) * 8)\n-        return ((cpu_mask)[bitNumber / 64] & (((uint64_t)1) << (bitNumber % 64)));\n-    return 0;\n-}\n-\n-/* Roughly equivalent to CPU_SET(). */\n-static inline void COI_CPU_MASK_SET(int bitNumber, COI_CPU_MASK cpu_mask)\n-{\n-    if ((size_t)bitNumber < sizeof(COI_CPU_MASK) * 8)\n-        ((cpu_mask)[bitNumber / 64] |= (((uint64_t)1) << (bitNumber % 64)));\n-}\n-\n-/* Roughly equivalent to CPU_ZERO(). */\n-static inline void COI_CPU_MASK_ZERO(COI_CPU_MASK cpu_mask)\n-{\n-    memset(cpu_mask, 0, sizeof(COI_CPU_MASK));\n-}\n-\n-/* Roughly equivalent to CPU_AND(). */\n-static inline void COI_CPU_MASK_AND(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n-{\n-    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n-    unsigned int i = 0;\n-\n-    for (; i < loopIterations; ++i)\n-        dst[i] = src1[i] & src2[i];\n-}\n-\n-/* Roughly equivalent to CPU_XOR(). */\n-static inline void COI_CPU_MASK_XOR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n-{\n-    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n-    unsigned int i = 0;\n-\n-    for (; i < loopIterations; ++i)\n-        dst[i] = src1[i] ^ src2[i];\n-}\n-\n-/* Roughly equivalent to CPU_OR(). */\n-static inline void COI_CPU_MASK_OR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n-{\n-    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n-    unsigned int i = 0;\n-\n-    for (; i < loopIterations; ++i)\n-        dst[i] = src1[i] | src2[i];\n-}\n-\n-/* Utility function for COI_CPU_MASK_COUNT() below. */\n-static inline int __COI_CountBits(uint64_t n)\n-{\n-    int cnt = 0;\n-\n-    for (; n; cnt++)\n-        n &= (n - 1);\n-    return cnt;\n-}\n-\n-/* Roughly equivalent to CPU_COUNT(). */\n-static inline int COI_CPU_MASK_COUNT(const COI_CPU_MASK cpu_mask)\n-{\n-    int cnt = 0;\n-    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask[0]);\n-    unsigned int i = 0;\n-\n-    for (; i < loopIterations; ++i)\n-    {\n-        cnt += __COI_CountBits(cpu_mask[i]);\n-    }\n-    return cnt;\n-}\n-\n-/* Roughly equivalent to CPU_EQUAL(). */\n-static inline int COI_CPU_MASK_EQUAL(const COI_CPU_MASK cpu_mask1, const COI_CPU_MASK cpu_mask2)\n-{\n-    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask1[0]);\n-    unsigned int i = 0;\n-\n-    for (; i < loopIterations; ++i)\n-    {\n-        if (cpu_mask1[i] != cpu_mask2[i])\n-            return 0;\n-    }\n-    return 1;\n-}\n-\n-\n-/* Utility function to translate from cpu_set * to COI_CPU_MASK. */\n-static inline void COI_CPU_MASK_XLATE(COI_CPU_MASK dest, const cpu_set_t *src)\n-{\n-    unsigned int i;\n-    unsigned int j;\n-    COI_CPU_MASK_ZERO(dest);\n-    #if 0\n-    /* Slightly slower version than the following #else/#endif block. Left here only to\n-         document the intent of the code. */\n-    for (i = 0; i < sizeof(cpu_set_t) * 8; ++i)\n-        if (CPU_ISSET(i, src))\n-            COI_CPU_MASK_SET(i, dest);\n-    #else\n-    for (i = 0; i < sizeof(COI_CPU_MASK) / sizeof(dest[0]); ++i)\n-    {\n-        for (j = 0; j < 64; ++j)\n-        {\n-            if (CPU_ISSET(i * 64 + j, src))\n-                dest[i] |= ((uint64_t)1) << j;\n-        }\n-    }\n-    #endif\n-}\n-\n-/* Utility function to translate from COI_CPU_MASK to cpu_set *. */\n-static inline void COI_CPU_MASK_XLATE_EX(cpu_set_t *dest, const COI_CPU_MASK src)\n-{\n-    unsigned int i;\n-    unsigned int j;\n-    CPU_ZERO(dest);\n-    #if 0\n-    /* Slightly slower version than the following #else/#endif block. Left here only to\n-         document the intent of the code. */\n-    for (i = 0; i < sizeof(COI_CPU_MASK) * 8; ++i)\n-        if (COI_CPU_MASK_ISSET(i, src))\n-            CPU_SET(i, dest);\n-    #else\n-    for (i = 0; i < sizeof(COI_CPU_MASK) / sizeof(src[0]); ++i)\n-    {\n-        const uint64_t cpu_mask = src[i];\n-\n-        for (j = 0; j < 64; ++j)\n-        {\n-            const uint64_t bit = ((uint64_t)1) << j;\n-\n-            if (bit & cpu_mask)\n-                CPU_SET(i * 64 + j, dest);\n-        }\n-    }\n-    #endif\n-}\n-\n-\n-#endif /* _COIMACROS_COMMON_H */"}, {"sha": "0b17e13d670432a16ad26a49f702ab0900d9fece", "filename": "liboffloadmic/include/coi/common/COIPerf_common.h", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,87 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIPERF_COMMON_H\n-#define _COIPERF_COMMON_H\n-\n-/** @ingroup COIPerf\n- *  @addtogroup COIPerfCommon\n-@{\n-\n-* @file common/COIPerf_common.h\n-* Performance Analysis API */\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#include \"../common/COITypes_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns a performance counter value\n-///\n-/// This function returns a performance counter value that increments\n-/// at a constant rate for all time and is coherent across all cores.\n-///\n-/// @return Current performance counter value or 0 if no performance counter\n-/////         is available\n-///\n-///\n-COIACCESSAPI\n-uint64_t COIPerfGetCycleCounter(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns the calculated system frequency in hertz.\n-///\n-/// @return Current system frequency in hertz.\n-///\n-COIACCESSAPI\n-uint64_t COIPerfGetCycleFrequency(void);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-/*! @} */\n-\n-#endif /* _COIPERF_COMMON_H */"}, {"sha": "d40c0b0d3ea484c842f8f4c7b536640ed3cbe65a", "filename": "liboffloadmic/include/coi/common/COIResult_common.h", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,148 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIRESULT_COMMON_H\n-#define _COIRESULT_COMMON_H\n-\n-/** @ingroup COIResult\n- *  @addtogroup COIResultCommon\n-@{\n-\n-* @file common/COIResult_common.h\n-* Result codes and definitions. */\n-\n-#include \"../common/COITypes_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-typedef enum COIRESULT\n-{\n-    COI_SUCCESS = 0,                  ///< The function succeeded without error.\n-    COI_ERROR,                        ///< Unspecified error.\n-    COI_NOT_INITIALIZED,              ///< The function was called before the\n-    ///< system was initialized.\n-    COI_ALREADY_INITIALIZED,          ///< The function was called after the\n-    ///< system was initialized.\n-    COI_ALREADY_EXISTS,               ///< Cannot complete the request due to\n-    ///< the existence of a similar object.\n-    COI_DOES_NOT_EXIST,               ///< The specified object was not found.\n-    COI_INVALID_POINTER,              ///< One of the provided addresses was not\n-    ///< valid.\n-    COI_OUT_OF_RANGE,                 ///< One of the arguments contains a value\n-    ///< that is invalid.\n-    COI_NOT_SUPPORTED,                ///< This function is not currently\n-    ///< supported as used.\n-    COI_TIME_OUT_REACHED,             ///< The specified time out caused the\n-    ///< function to abort.\n-    COI_MEMORY_OVERLAP,               ///< The source and destination range\n-    ///< specified overlaps for the same\n-    ///< buffer.\n-    COI_ARGUMENT_MISMATCH,            ///< The specified arguments are not\n-    ///< compatible.\n-    COI_SIZE_MISMATCH,                ///< The specified size does not match the\n-    ///< expected size.\n-    COI_OUT_OF_MEMORY,                ///< The function was unable to allocate\n-    ///< the required memory.\n-    COI_INVALID_HANDLE,               ///< One of the provided handles was not\n-    ///< valid.\n-    COI_RETRY,                        ///< This function currently can't\n-    ///< complete, but might be able to later.\n-    COI_RESOURCE_EXHAUSTED,           ///< The resource was not large enough.\n-    COI_ALREADY_LOCKED,               ///< The object was expected to be\n-    ///< unlocked, but was locked.\n-    COI_NOT_LOCKED,                   ///< The object was expected to be locked,\n-    ///< but was unlocked.\n-    COI_MISSING_DEPENDENCY,           ///< One or more dependent components\n-    ///< could not be found.\n-    COI_UNDEFINED_SYMBOL,             ///< One or more symbols the component\n-    ///< required was not defined in any\n-    ///< library.\n-    COI_PENDING,                      ///< Operation is not finished\n-    COI_BINARY_AND_HARDWARE_MISMATCH, ///< A specified binary will not run on\n-    ///< the specified hardware.\n-    COI_PROCESS_DIED,\n-    COI_INVALID_FILE,                 ///< The file is invalid for its intended\n-    ///< usage in the function.\n-    COI_EVENT_CANCELED,               ///< Event wait on a user event that\n-    ///< was unregistered or is being\n-    ///< unregistered returns\n-    ///< COI_EVENT_CANCELED.\n-    COI_VERSION_MISMATCH,             ///< The version of Intel(R) Coprocessor\n-    ///< Offload Infrastructure on the host\n-    ///< is not compatible with the version\n-    ///< on the device.\n-    COI_BAD_PORT,                     ///< The port that the host is set to\n-    ///< connect to is invalid.\n-    COI_AUTHENTICATION_FAILURE,       ///< The daemon was unable to authenticate\n-    ///< the user that requested an engine.\n-    ///< Only reported if daemon is set up for\n-    ///< authorization. Is also reported in\n-    ///< Windows if host cannot find user.\n-    COI_COMM_NOT_INITIALIZED,         ///< The function was called before the\n-    ///< comm was initialized.\n-    COI_INCORRECT_FORMAT,             ///< Format of data is incorrect\n-    COI_NUM_RESULTS                   ///< Reserved, do not use.\n-} COIRESULT;\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns the string version of the passed in COIRESULT. Thus if\n-/// COI_RETRY is passed in, this function returns the string \"COI_RETRY\". If\n-/// the error code passed ins is not valid then \"COI_ERROR\" will be returned.\n-///\n-/// @param in_ResultCode\n-///        [in] COIRESULT code to return the string version of.\n-///\n-/// @return String version of the passed in COIRESULT code.\n-///\n-COIACCESSAPI\n-const char *\n-COIResultGetName(\n-    COIRESULT       in_ResultCode);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIRESULT_COMMON_H */\n-\n-/*! @} */"}, {"sha": "cc37647b0c02f81d8f177018bf20724c1a2e8ca2", "filename": "liboffloadmic/include/coi/common/COISysInfo_common.h", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,126 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COISYSINFO_COMMON_H\n-#define _COISYSINFO_COMMON_H\n-\n-/** @ingroup COISysInfo\n- *  @addtogroup COISysInfoCommon\n-@{\n-* @file common/COISysInfo_common.h\n-* This interface allows developers to query the platform for system level\n-* information. */\n-\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#include \"../common/COITypes_common.h\"\n-#include <assert.h>\n-#include <string.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-#define INITIAL_APIC_ID_BITS 0xFF000000   // EBX[31:24] unique APIC ID\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// \\fn uint32_t COISysGetAPICID(void)\n-/// @return The Advanced Programmable Interrupt Controller (APIC) ID of\n-/// the hardware thread on which the caller is running.\n-///\n-/// @warning APIC IDs are unique to each hardware thread within a processor,\n-/// but may not be sequential.\n-COIACCESSAPI\n-uint32_t COISysGetAPICID(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The number of cores exposed by the processor on which the caller is\n-/// running. Returns 0 if there is an error loading the processor info.\n-COIACCESSAPI\n-uint32_t COISysGetCoreCount(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The number of hardware threads exposed by the processor on which\n-/// the caller is running. Returns 0 if there is an error loading processor\n-/// info.\n-COIACCESSAPI\n-uint32_t COISysGetHardwareThreadCount(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The index of the hardware thread on which the caller is running.\n-///\n-/// The indexes of neighboring hardware threads will differ by a value of one\n-/// and are within the range zero through COISysGetHardwareThreadCount()-1.\n-/// Returns ((uint32_t)-1) if there was an error loading processor info.\n-COIACCESSAPI\n-uint32_t COISysGetHardwareThreadIndex(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The index of the core on which the caller is running.\n-///\n-/// The indexes of neighboring cores will differ by a value of one and are\n-/// within the range zero through COISysGetCoreCount()-1. Returns ((uint32_t)-1)\n-/// if there was an error loading processor info.\n-COIACCESSAPI\n-uint32_t COISysGetCoreIndex(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The number of level 2 caches within the processor on which the\n-/// caller is running. Returns ((uint32_t)-1) if there was an error loading\n-/// processor info.\n-COIACCESSAPI\n-uint32_t COISysGetL2CacheCount(void);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// @return The index of the level 2 cache on which the caller is running.\n-/// Returns ((uint32_t)-1) if there was an error loading processor info.\n-///\n-/// The indexes of neighboring cores will differ by a value of one and are\n-/// within the range zero through COISysGetL2CacheCount()-1.\n-COIACCESSAPI\n-uint32_t COISysGetL2CacheIndex(void);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-/*! @} */\n-\n-#endif /* _COISYSINFO_COMMON_H */"}, {"sha": "6018b7d0eded2159eedf8867e877ac343ea47f84", "filename": "liboffloadmic/include/coi/common/COITypes_common.h", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,88 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COITYPES_COMMON_H\n-#define _COITYPES_COMMON_H\n-\n-/** @ingroup COITypes\n- *  @addtogroup COITypesSource\n-@{\n-\n-* @file common/COITypes_common.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-        #include <stdint.h>\n-        #include <wchar.h>\n-        #define COIACCESSAPI /* nothing */\n-        #define COIACCESSAPI2 /* nothing */\n-#endif /* DOXYGEN_SHOULD_SKIP_THIS */\n-\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\n-struct coievent\n-{\n-    uint64_t opaque[2];\n-};\n-\n-typedef struct coiprocess   *COIPROCESS;\n-typedef struct coipipeline *COIPIPELINE;\n-typedef struct coifunction *COIFUNCTION;\n-typedef struct coiengine    *COIENGINE;\n-typedef struct coievent      COIEVENT;\n-typedef struct coibuffer    *COIBUFFER;\n-typedef struct coilibrary   *COILIBRARY;\n-typedef struct coimapinst   *COIMAPINSTANCE;\n-\n-typedef uint64_t COI_CPU_MASK[16];\n-\n-/**\n- * On Windows, coi_wchar_t is a uint32_t. On Windows, wchar_t is 16 bits wide, and on Linux it is 32 bits wide, so uint32_t is used for portability.\n- */\n-typedef wchar_t  coi_wchar_t;\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COITYPES_COMMON_H */"}, {"sha": "d36d5860b3e9164273b044c8a017021534d04c30", "filename": "liboffloadmic/include/coi/sink/COIBuffer_sink.h", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIBUFFER_SINK_H\n-#define _COIBUFFER_SINK_H\n-\n-/** @ingroup COIBuffer\n- *  @addtogroup COIBufferSink\n-@{\n-\n-* @file sink\\COIBuffer_sink.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-    #include \"../common/COITypes_common.h\"\n-    #include \"../common/COIResult_common.h\"\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Adds a reference to the memory of a buffer. The memory of the buffer\n-/// will remain on the device until both a corresponding COIBufferReleaseRef()\n-/// call is made and the run function that delivered the buffer returns.\n-///\n-/// Running this API in a thread spawned within the run function is not\n-/// supported and will cause unpredictable results and may cause data corruption.\n-///\n-/// @warning 1.It is possible for enqueued run functions to be unable to\n-///            execute due to all card memory being occupied by AddRef'd\n-///            buffers. As such, it is important that whenever a buffer is\n-///            AddRef'd that there be no dependencies on future run functions\n-///            for progress to be made towards releasing the buffer.\n-///          2.It is important that AddRef is called within the scope of\n-///            run function that carries the buffer to be AddRef'd.\n-///\n-/// @param  in_pBuffer\n-///         [in] Pointer to the start of a buffer being AddRef'd, that was\n-///         passed in at the start of the run function.\n-///\n-/// @return COI_SUCCESS if the buffer ref count was successfully incremented.\n-///\n-/// @return COI_INVALID_POINTER if the buffer pointer is NULL.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer pointer is invalid.\n-///\n-COIRESULT\n-COIBufferAddRef(\n-    void           *in_pBuffer);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Removes a reference to the memory of a buffer. The memory of the buffer\n-/// will be eligible for being freed on the device when the following\n-/// conditions are met: the run function that delivered the buffer\n-/// returns, and the number of calls to COIBufferReleaseRef() matches the\n-/// number of calls to COIBufferAddRef().\n-//\n-/// Running this API in a thread spawned within the run function is not\n-/// supported and will cause unpredictable results and may cause data corruption.\n-///\n-/// @warning When a buffer is AddRef'd it is assumed that it is in use and all\n-///          other operations on that buffer waits for ReleaseRef() to happen.\n-///          So you cannot pass the AddRef'd buffer's handle to RunFunction\n-///          that calls ReleaseRef(). This is a circular dependency and will\n-///          cause a deadlock. Buffer's pointer (buffer's sink side\n-///          address/pointer which is different than source side BUFFER handle)\n-///          needs to be stored somewhere to retrieve it later to use in\n-///          ReleaseRef.\n-///\n-/// @param  in_pBuffer\n-///         [in] Pointer to the start of a buffer previously AddRef'd, that\n-///         was passed in at the start of the run function.\n-///\n-/// @return COI_SUCCESS if the buffer refcount was successfully decremented.\n-///\n-/// @return COI_INVALID_POINTER if the buffer pointer was invalid.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer did not have COIBufferAddRef()\n-///         previously called on it.\n-///\n-COIRESULT\n-COIBufferReleaseRef(\n-    void           *in_pBuffer);\n-\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIBUFFER_SINK_H */\n-\n-/*! @} */"}, {"sha": "9cb1087ab6facf0e9ae789e33f2cc1e6418e38d8", "filename": "liboffloadmic/include/coi/sink/COIPipeline_sink.h", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,137 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIPIPELINE_SINK_H\n-#define _COIPIPELINE_SINK_H\n-\n-/** @ingroup COIPipeline\n- *  @addtogroup COIPipelineSink\n-@{\n-* @file sink/COIPipeline_sink.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __FreeBSD__\n-    #define COINATIVELIBEXPORT_VISIBILITY \"extern\"\n-#else\n-    #define COINATIVELIBEXPORT_VISIBILITY \"default\"\n-#endif\n-\n-#ifdef __cplusplus\n-#define COINATIVELIBEXPORT \\\n-    extern \"C\" __attribute__ ((visibility(COINATIVELIBEXPORT_VISIBILITY)))\n-#else\n-#define COINATIVELIBEXPORT \\\n-    __attribute__ ((visibility(COINATIVELIBEXPORT_VISIBILITY)))\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This is the prototype that run functions should follow.\n-///\n-/// @param   in_BufferCount\n-///          The number of buffers passed to the run function.\n-///\n-/// @param   in_ppBufferPointers\n-///          An array that is in_BufferCount in length that contains the\n-///          sink side virtual addresses for each buffer passed in to\n-///          the run function.\n-///\n-/// @param   in_pBufferLengths\n-///          An array that is in_BufferCount in length of uint32_t integers\n-///          describing the length of each passed in buffer in bytes.\n-///\n-/// @param   in_pMiscData\n-///          Pointer to the MiscData passed in when the run function\n-///          was enqueued on the source.\n-///\n-/// @param   in_MiscDataLen\n-///          Length in bytes of the MiscData passed in when the run function\n-///          was enqueued on the source.\n-///\n-/// @param   in_pReturnValue\n-///          Pointer to the location where the return value from this run\n-///          function will be stored.\n-///\n-/// @param   in_ReturnValueLength\n-///          Length in bytes of the user-allocated ReturnValue pointer.\n-///\n-/// @return  A uint64_t that can be retrieved in the out_UserData parameter\n-///          from the COIPipelineWaitForEvent function.\n-///\n-typedef void\n-(*RunFunctionPtr_t)(\n-    uint32_t        in_BufferCount,\n-    void          **in_ppBufferPointers,\n-    uint64_t       *in_pBufferLengths,\n-    void           *in_pMiscData,\n-    uint16_t        in_MiscDataLength,\n-    void           *in_pReturnValue,\n-    uint16_t        in_ReturnValueLength);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Start processing pipelines on the Sink. This should be done after any\n-/// required initialization in the Sink's application has finished. No\n-/// run functions will actually be executed (although they may be queued)\n-/// until this function is called.\n-///\n-///\n-/// @return COI_SUCCESS if the pipelines were successfully started.\n-///\n-COIRESULT\n-COIPipelineStartExecutingRunFunctions();\n-\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIPIPELINE_SINK_H */\n-\n-/*! @} */"}, {"sha": "9438925391e67f114a057078ced1088531f49070", "filename": "liboffloadmic/include/coi/sink/COIProcess_sink.h", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,174 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIPROCESS_SINK_H\n-#define _COIPROCESS_SINK_H\n-\n-/** @ingroup COIProcess\n- *  @addtogroup COIProcessSink\n-@{\n-* @file sink/COIProcess_sink.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This call will block while waiting for the source to send a process destroy\n-/// message. This provides the sink side application with an event to keep the\n-/// main() function from exiting until it is directed to by the source. When\n-/// the shutdown message is received this function will stop any future run\n-/// functions from executing but will wait for any current run functions to\n-/// complete. All Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n-/// resources will be cleaned up and no additional Intel\u00ae Coprocessor Offload\n-/// Infrastructure (Intel\u00ae COI) APIs should be called after this function\n-/// returns. This function does not invoke exit() so the application\n-/// can perform any of its own cleanup once this call returns.\n-///\n-/// @return COI_SUCCESS once the process receives the shutdown message.\n-///\n-COIRESULT\n-COIProcessWaitForShutdown();\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This call will block until all stdout and stderr output has been proxied\n-/// to and written by the source. This call guarantees that any output in a\n-/// run function is transmitted to the source before the run function signals\n-/// its completion event back to the source.\n-///\n-/// Note that having an additional thread printing forever while another\n-/// calls COIProxyFlush may lead to a hang because the process will be forced\n-/// to wait until all that output can be flushed to the source before returning\n-/// from this call.\n-///\n-/// @return COI_SUCCESS once the proxy output has been flushed to and written\n-///         written by the host. Note that Intel\u00ae Coprocessor Offload\n-///         Infrastructure (Intel\u00ae COI) on the source writes to stdout and\n-///         stderr, but does not flush this output.\n-/// @return COI_SUCCESS if the process was created without enabling\n-///         proxy IO this function.\n-///\n-COIRESULT\n-COIProcessProxyFlush();\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Loads a shared library from host filesystem into the current sink\n-/// process, akin to using dlopen() on a local process in Linux or\n-/// LoadLibrary() in Windows.\n-///\n-/// @param  in_pFileName\n-///         [in] The name of the shared library file on the source's file\n-///         system that is being loaded. If the file name is not an absolute\n-///         path, the file is searched for in the same manner as dependencies.\n-///\n-/// @param  in_pLibraryName\n-///         [in] Name for the shared library. This optional parameter can\n-///         be specified in case the dynamic library doesn't have an\n-///         SO_NAME field. If specified, it will take precedence over\n-///         the SO_NAME if it exists. If it is not specified then\n-///         the library must have a valid SO_NAME field.\n-///\n-///@param   in_LibrarySearchPath\n-///         [in] a path to locate dynamic libraries dependencies for the\n-///         library being loaded. If not NULL, this path will override the\n-///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-/// @param  in_Flags\n-///         [in] Bitmask of the flags that will be passed in as the dlopen()\n-///         \"flag\" parameter on the sink.\n-///\n-/// @param  out_pLibrary\n-///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n-///         that uniquely identifies the loaded library.\n-///\n-/// @return COI_SUCCESS if the library was successfully loaded.\n-///\n-/// @return COI_INVALID_POINTER if in_pFileName is NULL.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_pFileName cannot be found.\n-///\n-/// @return COI_INVALID_FILE if the file is not a valid shared library.\n-///\n-/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n-///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the shared library is missing an SONAME\n-///         and in_pLibraryName is NULL.\n-///\n-/// @return COI_UNDEFINED_SYMBOL if we are unable to load the library due to\n-///         an undefined symbol.\n-///\n-/// @return COI_ALREADY_EXISTS if there is an existing COILIBRARY handle\n-///         that identifies this library, and this COILIBRARY hasn't been\n-///         unloaded yet.\n-///\n-/// @return COI_BINARY_AND_HARDWARE_MISMATCH if the target machine of the\n-///         binary or any of its recursive dependencies does not match the\n-///         engine associated with Process.\n-///\n-/// @return COI_NOT_INITIALIZED if setup of remote process on host is not\n-///         completed yet.\n-///\n-COIRESULT\n-COIProcessLoadSinkLibraryFromFile(\n-    const   char               *in_pFileName,\n-    const   char               *in_pLibraryName,\n-    const   char               *in_LibrarySearchPath,\n-    uint32_t            in_Flags,\n-    COILIBRARY         *out_pLibrary);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIPROCESS_SINK_H */\n-\n-/*! @} */"}, {"sha": "b90d50554bf2c52de4c11b8b904a857641c1b1e4", "filename": "liboffloadmic/include/coi/source/COIBuffer_source.h", "status": "removed", "additions": 0, "deletions": 1806, "changes": 1806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1806 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIBUFFER_SOURCE_H\n-#define _COIBUFFER_SOURCE_H\n-\n-/** @ingroup COIBuffer\n- *  @addtogroup COIBufferSource\n-@{\n-\n-* @file source\\COIBuffer_source.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-    #include \"../common/COITypes_common.h\"\n-    #include \"../common/COIResult_common.h\"\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// The valid buffer types that may be created using COIBufferCreate.\n-/// Please see the COI_VALID_BUFFER_TYPES_AND_FLAGS matrix\n-/// below which describes the valid combinations of buffer types and flags.\n-///\n-typedef enum COI_BUFFER_TYPE\n-{\n-    /// Normal buffers exist as a single physical buffer in either Source or\n-    /// Sink physical memory. Mapping the buffer may stall the pipelines.\n-    COI_BUFFER_NORMAL = 1,\n-\n-    // Reserved values, not used by COI any more\n-    COI_BUFFER_RESERVED_1,\n-    COI_BUFFER_RESERVED_2,\n-    COI_BUFFER_RESERVED_3,\n-\n-    /// OpenCL buffers are similar to Normal buffers except they don't\n-    /// stall pipelines and don't follow any read write dependencies.\n-    COI_BUFFER_OPENCL\n-\n-} COI_BUFFER_TYPE;\n-\n-\n-/// @name COIBUFFER creation flags.\n-/// Please see the COI_VALID_BUFFER_TYPES_AND_FLAGS matrix\n-/// below which describes the valid combinations of buffer types and flags.\n-//@{\n-\n-/// Create the buffer such that it has the same virtual address on all of the\n-/// sink processes with which it is associated.\n-#define COI_SAME_ADDRESS_SINKS             0x00000001\n-\n-/// Create the buffer such that it has the same virtual address on all of the\n-/// sink processes with which it is associated and in the source process.\n-#define COI_SAME_ADDRESS_SINKS_AND_SOURCE  0x00000002\n-\n-/// Hint to the runtime that the source will frequently read the buffer\n-#define COI_OPTIMIZE_SOURCE_READ           0x00000004\n-\n-/// Hint to the runtime that the source will frequently write the buffer\n-#define COI_OPTIMIZE_SOURCE_WRITE          0x00000008\n-\n-/// Hint to the runtime that the sink will frequently read the buffer\n-#define COI_OPTIMIZE_SINK_READ             0x00000010\n-\n-/// Hint to the runtime that the sink will frequently write the buffer\n-#define COI_OPTIMIZE_SINK_WRITE            0x00000020\n-\n-/// Used to delay the pinning of memory into physical pages, until required\n-/// for DMA. This can be used to delay the cost of time spent pinning memory\n-/// until absolutely necessary. Might speed up the execution of COIBufferCreate\n-/// calls, but slow down the first access of the buffer in\n-/// COIPipelineRunFunction(s) or other COIBuffer access API's.\n-/// Also of important note, that with this flag enabled COI will not be able to\n-/// check to see if this memory is read only. Ordinarily this is checked\n-/// and an error is thrown upon buffer creation. With this flag, the error\n-/// might occur later, and cause undetermined behavior. Be sure to always\n-/// use writable memory for COIBuffers.\n-#define COI_OPTIMIZE_NO_DMA                0x00000040\n-\n-/// Hint to the runtime to try to use huge page sizes for backing store on the\n-/// sink. Is currently not compatible with the SAME_ADDRESS\n-/// flags or the SINK_MEMORY flag. It is important to note that this is a hint\n-/// and internally the runtime may not actually promote to huge pages.\n-/// Specifically if the buffer is too small (less than 4KiB for example) then\n-/// the runtime will not promote the buffer to use huge pages.\n-#define COI_OPTIMIZE_HUGE_PAGE_SIZE        0x00000080\n-\n-/// Used to tell Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// to create a buffer using memory that has already been\n-/// allocated on the sink. This flag is only valid when passed in to the\n-/// COIBufferCreateFromMemory API.\n-#define COI_SINK_MEMORY                    0x00000100\n-\n-//@}\n-\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-// Make the flag mask\n-#ifdef F\n-#undef F\n-#endif\n-#define F 0\n-#ifdef T\n-#undef T\n-#endif\n-#define T 1\n-#define MTM(_BUFFER, B1, B2, B3, B4, B5, B6, B7, B8, B9) \\\n-    (B1 | B2<<1 | B3<<2 | B4<<3 | B5<<4 | B6<<5 | B7<<6 | B8<<7 | B9<<8)\n-#endif\n-\n-/// \\enum COI_BUFFER_TYPE\n-/// This matrix shows the valid combinations of buffer types and buffer flags\n-/// that may be passed in to COIBufferCreate and COIBufferCreateFromMemory.\n-/// \\code\n-static const uint64_t\n-COI_VALID_BUFFER_TYPES_AND_FLAGS[COI_BUFFER_OPENCL + 1] =\n-{\n-    /*           |       | SAME |      |       |      |       |     |      |      |\n-                 | SAME  | ADDR | OPT  | OPT   | OPT  | OPT   | OPT | HUGE | COI  |\n-                 | ADDR  | SINK | SRC  | SRC   | SINK | SINK  | NO  | PAGE | SINK |\n-                 | SINKS | SRC  | READ | WRITE | READ | WRITE | DMA | SIZE | MEM  |\n-                 +-------+------+------+-------+------+-------+-----+------+-----*/\n-    MTM(INVALID   ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n-    MTM(NORMAL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T),\n-    MTM(RESERVED1 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n-    MTM(RESERVED2 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n-    MTM(RESERVED3 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n-    MTM(OPENCL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F),\n-};\n-///\\endcode\n-#undef MTM\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// These flags control how the buffer will be accessed on the source after\n-/// it is mapped.\n-/// Please see the COI_VALID_BUFFER_TYPES_AND_MAP matrix below for the\n-/// valid buffer type and map operation combinations.\n-typedef enum COI_MAP_TYPE\n-{\n-    /// Allows the application to read and write the contents of the buffer\n-    /// after it is mapped.\n-    COI_MAP_READ_WRITE = 1,\n-\n-    /// If this flag is set then the application must only read from the\n-    /// buffer after it is mapped. If the application writes to the buffer\n-    /// the contents will not be reflected back to the sink or stored for\n-    /// the next time the buffer is mapped on the source.\n-    /// This allows the runtime to make significant performance optimizations\n-    /// in buffer handling.\n-    COI_MAP_READ_ONLY,\n-\n-    /// Setting this flag means that the source will overwrite the entire\n-    /// buffer once it is mapped. The app must not read from the buffer and\n-    /// must not expect the contents of the buffer to be synchronized from\n-    /// the sink side during the map operation.\n-    /// This allows the runtime to make significant performance optimizations\n-    /// in buffer handling.\n-    COI_MAP_WRITE_ENTIRE_BUFFER\n-} COI_MAP_TYPE;\n-\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-// Make the flag mask\n-#define MMM(_BUFFER, B1, B2, B3) \\\n-    {  F  , B1, B2, B3}\n-#endif\n-/// \\enum COI_MAP_TYPE\n-/// This matrix shows the valid combinations of buffer types and map\n-/// operations that may be passed in to COIBufferMap.\n-/// \\code\n-static const uint64_t\n-COI_VALID_BUFFER_TYPES_AND_MAP\n-[COI_BUFFER_OPENCL + 1][COI_MAP_WRITE_ENTIRE_BUFFER + 1] =\n-{\n-    /*                      | MAP   | MAP   | MAP   |\n-                            | READ  | READ  | WRITE |\n-                            | WRITE | ONLY  | ENTIRE|\n-                            +-------+-------+-------+*/\n-    MMM(INVALID             ,   F   ,   F   ,   F),\n-    MMM(NORMAL              ,   T   ,   T   ,   T),\n-    MMM(RESERVED1           ,   F   ,   F   ,   F),\n-    MMM(RESERVED2           ,   F   ,   F   ,   F),\n-    MMM(RESERVED3           ,   F   ,   F   ,   F),\n-    MMM(OPENCL              ,   T   ,   T   ,   T),\n-};\n-///\\endcode\n-#undef MMM\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#undef F\n-#undef T\n-#endif\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// The valid copy operation types for the COIBufferWrite, COIBufferRead,\n-/// and COIBufferCopy APIs.\n-///\n-typedef enum COI_COPY_TYPE\n-{\n-    /// The runtime can pick the best suitable way to copy the data.\n-    COI_COPY_UNSPECIFIED = 0,\n-\n-    /// The runtime should use DMA to copy the data.\n-    COI_COPY_USE_DMA,\n-\n-    /// The runtime should use a CPU copy to copy the data.\n-    COI_COPY_USE_CPU,\n-\n-    /// Same as above, but forces moving entire buffer to target process in Ex\n-    /// extended APIs, even if the full buffer is not written.\n-    COI_COPY_UNSPECIFIED_MOVE_ENTIRE,\n-\n-    /// Same as above, but forces moving entire buffer to target process in Ex\n-    /// extended APIs, even if the full buffer is not written.\n-    COI_COPY_USE_DMA_MOVE_ENTIRE,\n-\n-    /// Same as above, but forces moving entire buffer to target process in Ex\n-    /// extended APIs, even if the full buffer is not written.\n-    COI_COPY_USE_CPU_MOVE_ENTIRE\n-\n-} COI_COPY_TYPE;\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// The buffer states are used to indicate whether a buffer is available for\n-/// access in a COIPROCESS. This is used with COIBufferSetState.\n-///\n-/// Rules on State Transition of the buffer:\n-/// -. When a Buffer is created by default it is valid only on the source,\n-///    except for buffers created with COI_SINK_MEMORY flag which are valid\n-///    only on the sink where the memory lies when created.\n-/// -. Apart from SetState following APIs also alters the state of the buffer\n-///    internally:\n-///\n-///    - COIBufferMap alters state of buffer depending on the COI_MAP_TYPE.\n-///      COI_MAP_READ_ONLY: Makes Valid on the Source. Doesn't affect the state\n-///                         of the buffer on the other devices.\n-///      COI_MAP_READ_WRITE: Makes it Valid only the Source and Invalid\n-///                         everywhere else. OPENCL buffers are invalidated\n-///                         only if it is not in use.\n-///      COI_MAP_WRITE_ENTIRE_BUFFER: Makes it valid only on the Source. OPENCL\n-///                         buffers are invalidated only if not in use.\n-///\n-///    - COIPipelineRunfunction alters the state of the buffer depending on the\n-///      COI_ACCESS_FLAGS\n-///      COI_SINK_READ: Makes it valid on the sink where RunFunction is being\n-///                     issued. Doesn't affect the state of the buffer on other\n-///                     devices.\n-///      COI_SINK_WRITE: Makes it valid only on the sink where Runfunction is\n-///                     being issued and invalid everywhere else. OPENCL\n-///                     buffers are invalidated only if the buffer is not in\n-///                     use.\n-///      COI_SINK_WRITE_ENTIRE: Makes it valid only on the sink where\n-///                     Runfunction is being issued and invalid everywhere else\n-///                     OPENCL buffers are invalidated only if the buffer is\n-///                     not in use.\n-///\n-///    - COIBufferWrite makes the buffer exclusively valid where the write\n-///      happens. Write gives preference to Source over Sink. In other words\n-///      if a buffer is valid on the Source and multiple Sinks, Write will\n-///      happen on the Source and will Invalidate all other Sinks. If the\n-///      buffer is valid on multiple Sinks ( and not on the Source) then\n-///      Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-///      selects process handle with the lowest numerical value to do the\n-///      exclusive write Again, OPENCL buffers are invalidated only if the\n-///      buffer is not in use on that SINK/SOURCE.\n-///\n-///      The preference rule mentioned above holds true even for SetState API,\n-///      when data needs to be moved from a valid location. The selection of\n-///      valid location happens as stated above.\n-///\n-/// - It is possible to alter only parts of the buffer and change it state\n-///   In other words it is possible for different parts of the buffer to have\n-///   different states on different devices. A byte is the minimum size at\n-///   which state can be maintained internally. Granularity level is completely\n-///   determined by how the buffer gets fragmented.\n-///\n-/// Note: Buffer is considered 'in use' if is\n-///         - Being used in RunFunction : In use on a Sink\n-///         - Mapped: In use on a Source\n-///         - AddRef'd: In use on Sink\n-///\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// The buffer states used with COIBufferSetState call to indicate the new\n-/// state of the buffer on a given process\n-///\n-typedef enum\n-{\n-    COI_BUFFER_VALID = 0,      // Buffer is valid and up-to-date on the process\n-    COI_BUFFER_INVALID ,       // Buffer is not valid, need valid data\n-    COI_BUFFER_VALID_MAY_DROP, // Same as valid but will drop the content when\n-    // evicted to avoid overwriting the shadow\n-    // memory\n-    COI_BUFFER_RESERVED        // Reserved for internal use\n-} COI_BUFFER_STATE;\n-///\n-/// Note: A VALID_MAY_DROP declares a buffer's copy as secondary on a given\n-/// process. This means that there needs to be at least one primary copy of the\n-/// the buffer somewhere in order to mark the buffer as VALID_MAY_DROP on a\n-/// process. In other words to make a buffer VALID_MAY_DROP on a given process\n-/// it needs to be in COI_BUFFER_VALID state somewhere else. The operation gets\n-/// ignored (or is a nop) if there is no primary copy of the buffer. The nature\n-/// of this state to \"drop the content\" when evicted is a side effect of\n-/// marking the buffer as secondary copy. So when a buffer marked\n-/// VALID_MAY_DROP is evicted Intel(R) Coprocessor Offload Infrastructure\n-/// (Intel(R) COI) doesn't back it up as it is assumed that\n-/// there is a primary copy somewhere.\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// The buffer move flags are used to indicate when a buffer should be moved\n-/// when it's state is changed. This is used with COIBufferSetState.\n-typedef enum\n-{\n-    COI_BUFFER_MOVE = 0,// Dirty data is moved if state change requires it\n-    COI_BUFFER_NO_MOVE  // Change state without moving data\n-} COI_BUFFER_MOVE_FLAG;\n-\n-// A process handle for COIBufferSetState call to indicate all the sink\n-// processes where the given buffer is valid\n-#define COI_SINK_OWNERS ((COIPROCESS)-2)\n-\n-// Matrix descriptors used with MultiD Read/Write\n-typedef struct dim_desc\n-{\n-    int64_t size;       // Size of data type\n-    int64_t lindex;     // Lower index, used in Fortran\n-    int64_t lower;      // Lower section bound\n-    int64_t upper;      // Upper section bound\n-    int64_t stride;     // Stride, or number of bytes between the start\n-    // of one element and start of next one divided\n-    // by size.\n-} dim_desc;\n-\n-typedef struct arr_desc\n-{\n-    int64_t base;       // Base address\n-    int64_t rank;       // Rank of array, i.e. number of dimensions\n-    dim_desc dim[3];    // This array has as many elements as 'rank'\n-    // currently limited to 3.\n-} arr_desc;\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Creates a buffer that can be used in RunFunctions that are queued in\n-/// pipelines. The address space for the buffer is reserved when it is\n-/// created although the memory may not be committed until the buffer is\n-/// used for the first time. Please note that the Intel(R) Coprocessor Offload\n-/// Infrastructure (Intel(R) COI) runtime may also allocate space for the\n-/// source process to use as shadow memory for certain types of buffers.\n-/// If Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// does allocate this memory it will not be released or reallocated\n-/// until the COIBuffer is destroyed.\n-///\n-/// @param  in_Size\n-///         [in] The number of bytes to allocate for the buffer. If in_Size\n-///         is not page aligned, it will be rounded up.\n-///\n-/// @param  in_Type\n-///         [in] The type of the buffer to create.\n-///\n-/// @param  in_Flags\n-///         [in] A bitmask of attributes for the newly created buffer.\n-///         Some of these flags are required for correctness while others\n-///         are provided as hints to the runtime system so it can make\n-///         certain performance optimizations.\n-///\n-/// @param  in_pInitData\n-///         [in] If non-NULL the buffer will be initialized with the data\n-///         pointed to by pInitData. The memory at in_pInitData must hold\n-///         at least in_Size bytes.\n-///\n-/// @param  in_NumProcesses\n-///         [in] The number of processes with which this buffer might be used.\n-///\n-/// @param  in_pProcesses\n-///         [in] An array of COIPROCESS handles identifying the processes with\n-///         which this buffer might be used.\n-///\n-/// @param  out_pBuffer\n-///         [out] Pointer to a buffer handle. The handle will be filled in\n-///         with a value that uniquely identifies the newly created buffer.\n-///         This handle should be disposed of via COIBufferDestroy()\n-///         once it is no longer needed.\n-///\n-/// @return COI_SUCCESS if the buffer was created\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_Type and in_Flags parameters\n-///         are not compatible with one another. Please see the\n-///         COI_VALID_BUFFER_TYPES_AND_FLAGS map above for information about\n-///         which flags and types are compatible.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n-///         the in_Flags parameter are not recognized flags, or if in_NumProcesses is zero.\n-///\n-/// @return COI_INVALID_POINTER if the in_pProcesses or out_pBuffer parameter\n-///         is NULL.\n-///\n-/// @return COI_NOT_SUPPORTED if in_Type has invalid value or if\n-///        one of the in_Flags is COI_SINK_MEMORY.\n-///\n-/// @return COI_NOT_SUPPORTED if the flags include either\n-///         COI_SAME_ADDRESS_SINKS or COI_SAME_ADDRESS_SINKS_AND_SOURCE and\n-///         COI_OPTIMIZE_HUGE_PAGE_SIZE.\n-///\n-/// @return COI_INVALID_HANDLE if one of the COIPROCESS handles in the\n-///         in_pProcesses array does not identify a valid process.\n-///\n-/// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n-///\n-/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferCreate(\n-    uint64_t            in_Size,\n-    COI_BUFFER_TYPE     in_Type,\n-    uint32_t            in_Flags,\n-    const   void               *in_pInitData,\n-    uint32_t            in_NumProcesses,\n-    const   COIPROCESS         *in_pProcesses,\n-    COIBUFFER          *out_pBuffer);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Creates a buffer from some existing memory that can be used in\n-/// RunFunctions that are queued in pipelines. If the flag COI_SINK_MEMORY\n-/// is specified then Intel(R) Coprocessor Offload\n-/// Infrastructure (Intel(R) COI) will use that memory for the buffer on the sink.\n-/// If that flag isn't set then the memory provided is used as backing store\n-/// for the buffer on the source. In either case the memory must not be freed\n-/// before the buffer is destroyed.\n-/// While the user still owns the memory passed in they must use the\n-/// appropriate access flags when accessing the buffer in COIPipelinRunFunction\n-/// or COIBufferMap calls so that the runtime knows when the\n-/// memory has been modified. If the user just writes directly to the memory\n-/// location then those changes may not be visible when the corresponding\n-/// buffer is accessed.\n-/// Whatever values are already present in the memory location when this call\n-/// is made are preserved. The memory values are also preserved when\n-/// COIBufferDestroy is called.\n-///\n-/// @warning: Use of this function is highly discouraged if the calling\n-/// program forks at all (including calls to system(3), popen(3), or similar\n-/// functions) during the life of this buffer. See the discussion around the\n-/// in_Memory parameter below regarding this.\n-///\n-/// @param  in_Size\n-///         [in] The size of in_Memory in bytes. If in_Size\n-///         is not page aligned, it will be rounded up.\n-///\n-/// @param  in_Type\n-///         [in] The type of the buffer to create. Only COI_BUFFER_NORMAL\n-///         buffer type is supported.\n-///\n-/// @param  in_Flags\n-///         [in] A bitmask of attributes for the newly created buffer.\n-///         Some of these flags are required for correctness while others\n-///         are provided as hints to the runtime system so it can make\n-///         certain performance optimizations. Note that the flag\n-///         COI_SAME_ADDRESS_SINKS_AND_SOURCE is still valid but may fail\n-///         if the same address as in_Memory cannot be allocated on the sink.\n-///\n-/// @param  in_Memory\n-///         [in] A pointer to an already allocated memory region\n-///         that should be turned into a COIBUFFER. Although the user still\n-///         owns this memory they should not free it before calling\n-///         COIBufferDestroy. They must also only access the memory using\n-///         COIBUFFER semantics, for example using COIBufferMap/COIBufferUnmap\n-///         when they wish to read or write the data. There are no alignment\n-///         or size requirements for this memory region.\n-///\n-///         WARNING:\n-///         Since the backing memory passed in can be the target of a DMA\n-///         the caller must ensure that there is no call to clone(2) (without\n-///         the CLONE_VM argument) during the life of this buffer. This\n-///         includes higher level functions that call clone such as fork(2),\n-///         system(3), popen(3), among others).\n-///\n-///         For forked processes, Linux uses copy-on-write semantics for\n-///         performance reasons. Consequently, if the parent forks and then\n-///         writes to this memory, the physical page mapping changes causing\n-///         the DMA to fail (and thus data corruption).\n-///\n-///         In Linux you can mark a set of pages to not be copied across\n-///         across the clone by calling madvise(2) with an argument of\n-///         MADV_DONTFORK and then safely use that memory in this scenario.\n-///         Alternately, if the memory is from a region marked MAP_SHARED,\n-///         this will work.\n-///\n-/// @param  in_NumProcesses\n-///         [in] The number of processes with which this buffer might be used.\n-///         If the flag COI_SINK_MEMORY is specified then this must be 1.\n-///\n-/// @param  in_pProcesses\n-///         [in] An array of COIPROCESS handles identifying the processes with\n-///         which this buffer might be used.\n-///\n-/// @param  out_pBuffer\n-///         [out] Pointer to a buffer handle. The handle will be filled in\n-///         with a value that uniquely identifies the newly created buffer.\n-///         This handle should be disposed of via COIBufferDestroy()\n-///         once it is no longer needed.\n-///\n-/// @return COI_SUCCESS if the buffer was created\n-///\n-/// @return COI_NOT_SUPPORTED if the in_Type value is not COI_BUFFER_NORMAL,\n-///         or COI_BUFFER_OPENCL.\n-///\n-/// @return COI_NOT_SUPPORTED if in_Memory is read-only memory\n-///\n-/// @return COI_NOT_SUPPORTED if one of the in_Flags is COI_SINK_MEMORY and\n-///         in_Type is not COI_BUFFER_NORMAL\n-///\n-/// @return COI_NOT_SUPPORTED if the flag COI_SAME_ADDRESS_SINKS is set\n-///\n-/// @return COI_NOT_SUPPORTED if the flag COI_SAME_ADDRESS_SINKS_AND_SOURCE is\n-///         set\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_Type and in_Flags parameters\n-///         are not compatible with one another. Please see the\n-///         COI_VALID_BUFFER_TYPES_AND_FLAGS map above for information about\n-///         which flags and types are compatible.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the flag COI_SINK_MEMORY is specified and\n-///         in_NumProcesses > 1.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the flags COI_SINK_MEMORY and\n-///         COI_OPTIMIZE_HUGE_PAGE_SIZE are both set.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n-///         the in_Flags parameter are not recognized flags,  or if in_NumProcesses is zero.\n-///\n-/// @return COI_INVALID_POINTER if in_Memory, in_pProcesses or\n-///         out_pBuffer parameter is NULL.\n-///\n-/// @return COI_INVALID_HANDLE if one of the COIPROCESS handles in the\n-///         in_pProcesses array does not identify a valid process.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferCreateFromMemory(\n-    uint64_t            in_Size,\n-    COI_BUFFER_TYPE     in_Type,\n-    uint32_t            in_Flags,\n-    void               *in_Memory,\n-    uint32_t            in_NumProcesses,\n-    const   COIPROCESS         *in_pProcesses,\n-    COIBUFFER          *out_pBuffer);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Destroys a buffer. Will block on completion of any operations on the\n-/// buffer, such as COIPipelineRunFunction or COIBufferCopy. Will block until\n-/// all COIBufferAddRef calls have had a matching COIBufferReleaseRef call\n-/// made. will not block on an outstanding COIBufferUnmap but will instead\n-/// return COI_RETRY.\n-///\n-/// @param  in_Buffer\n-///         [in] Handle of the buffer to destroy.\n-///\n-/// @return COI_SUCCESS if the buffer was destroyed.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n-///\n-/// @return COI_RETRY if the buffer is currently mapped. The buffer must\n-///         first be unmapped before it can be destroyed.\n-///\n-/// @return COI_RETRY if the sub-buffers created from this buffer are not yet\n-///         destroyed\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferDestroy(\n-    COIBUFFER           in_Buffer);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This call initiates a request to access a region of a buffer. Multiple\n-/// overlapping (or non overlapping) regions can be mapped simultaneously for\n-/// any given buffer. If a completion event is specified this call will\n-/// queue a request for the data which will be satisfied when the buffer is\n-/// available. Once all conditions are met the completion event will be\n-/// signaled and the user can access the data at out_ppData. The user can call\n-/// COIEventWait with out_pCompletion to find out when the map operation has\n-/// completed. If the user accesses the data before the map operation is\n-/// complete the results are undefined. If out_pCompletion is NULL then this\n-/// call blocks until the map operation completes and when this call returns\n-/// out_ppData can be safely accessed. This call returns a map instance handle\n-/// in an out parameter which must be passed into COIBufferUnmap when the user\n-/// no longer needs access to that region of the buffer.\n-///\n-/// The address returned from COIBufferMap may point to memory that\n-/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// manages on behalf of the user. The user must not free or reallocate this\n-/// memory, Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// will perform any necessary cleanup when the buffer is\n-/// destroyed.\n-///\n-/// Note that different types of buffers behave differently when mapped.\n-/// For instance, mapping a COI_BUFFER_NORMAL for write must stall if the\n-/// buffer is currently being written to by a run function.\n-/// The asynchronous operation of COIBufferMap will likely be most useful when\n-/// paired with a COI_BUFFER_NORMAL.\n-///\n-/// @param  in_Buffer\n-///         [in] Handle for the buffer to map.\n-///\n-/// @param  in_Offset\n-///         [in] Offset into the buffer that a pointer should be returned\n-///         for. The value 0 can be passed in to signify that the mapped\n-///         region should start at the beginning of the buffer.\n-///\n-/// @param  in_Length\n-///         [in] Length of the buffer area to map. This parameter, in\n-///         combination with in_Offset, allows the caller to specify\n-///         that only a subset of an entire buffer need be mapped. A\n-///         value of 0 can be passed in only if in_Offset is 0, to signify\n-///         that the mapped region is the entire buffer.\n-///\n-/// @param  in_Type\n-///         [in] The access type that is needed by the application. This will\n-///         affect how the data can be accessed once the map operation\n-///         completes. See the COI_MAP_TYPE enum for more details.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the map\n-///         call initiation to wait for any events to be signaled before\n-///         starting the map operations.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this map operation will wait for before starting.\n-///         This allows the user to create dependencies between asynchronous\n-///         map calls and other operations such as run functions or other\n-///         asynchronous map calls. The user may pass in NULL if they do not\n-///         wish to wait for any dependencies to complete before initiating map\n-///         operations.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional pointer to a COIEVENT object\n-///         that will be signaled when a map call with the passed in buffer\n-///         would complete immediately, that is, the buffer memory has been\n-///         allocated on the source and its contents updated. The user may pass\n-///         in NULL if the user wants COIBufferMap to perform a blocking map\n-///         operation.\n-///\n-/// @param  out_pMapInstance\n-///         [out] A pointer to a COIMAPINSTANCE which represents this mapping\n-///         of the buffer and must be passed in to COIBufferUnmap when access\n-///         to this region of the buffer data is no longer needed.\n-///\n-/// @param  out_ppData\n-///         [out] Pointer to the buffer data. The data will only be valid\n-///         when the completion object is signaled, or for a synchronous\n-///         map operation with the call to map returns.\n-///\n-///\n-/// @return COI_SUCCESS if the map request succeeds.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset of (in_Offset + in_Length) exceeds\n-///         the size of the buffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Length is 0, but in_Offset is not 0.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Type is not a valid COI_MAP_TYPE.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n-///         in_pDependencies was passed in as NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is non-NULL but\n-///         in_NumDependencies is zero.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_Type of map is not a valid type\n-///         for in_Buffer's type of buffer.\n-///\n-/// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n-///\n-/// @return COI_INVALID_POINTER if out_pMapInstance or out_ppData is NULL.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferMap(\n-    COIBUFFER           in_Buffer,\n-    uint64_t            in_Offset,\n-    uint64_t            in_Length,\n-    COI_MAP_TYPE        in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion,\n-    COIMAPINSTANCE     *out_pMapInstance,\n-    void              **out_ppData);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Disables Source access to the region of the buffer that was provided\n-/// through the corresponding call to COIBufferMap. The number of calls to\n-/// COIBufferUnmap() should always match the number of calls made to\n-/// COIBufferMap(). The data pointer returned from the COIBufferMap() call\n-/// will be invalid after this call.\n-///\n-/// @param  in_MapInstance\n-///         [in] buffer map instance handle to unmap.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the unmap call to\n-///         wait for any events to be signaled before performing the unmap\n-///         operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this unmap operation will wait for before starting.\n-///         This allows the user to create dependencies between asynchronous\n-///         unmap calls and other operations such as run functions or other\n-///         asynchronous unmap calls. The user may pass in NULL if they do not\n-///         wish to wait for any dependencies to complete before initiating\n-///         unmap operations.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional pointer to a COIEVENT object that will be\n-///         signaled when the unmap is complete. The user may pass in NULL if\n-///         the user wants COIBufferUnmap to perform a blocking unmap\n-///         operation.\n-///\n-/// @return COI_SUCCESS upon successful unmapping of the buffer instance.\n-///\n-/// @return COI_INVALID_HANDLE if the passed in map instance handle was NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferUnmap(\n-    COIMAPINSTANCE      in_MapInstance,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Gets the Sink's virtual address of the buffer for the first process\n-/// that is using the buffer. This is the same address\n-/// that is passed to the run function on the Sink. The virtual\n-/// address assigned to the buffer for use on the sink is fixed;\n-/// the buffer will always be present at that virtual address on the sink\n-/// and will not get a different virtual address across different\n-/// RunFunctions.\n-/// This address is only valid on the Sink and should not be dereferenced on\n-/// the Source (except for the special case of buffers created with the\n-/// COI_SAME_ADDRESS flag).\n-///\n-/// @param  in_Buffer\n-///         [in] Buffer handle\n-///\n-/// @param  out_pAddress\n-///         [out] pointer to a uint64_t* that will be filled with the address.\n-///\n-/// @return COI_SUCCESS upon successful return of the buffer's address.\n-///\n-/// @return COI_INVALID_HANDLE if the passed in buffer handle was invalid.\n-///\n-/// @return COI_INVALID_POINTER if the out_pAddress parameter was invalid.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferGetSinkAddress(\n-    COIBUFFER           in_Buffer,\n-    uint64_t           *out_pAddress);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Gets the Sink's virtual address of the buffer. This is the same\n-/// address that is passed to the run function on the Sink. The virtual\n-/// address assigned to the buffer for use on the sink is fixed;\n-/// the buffer will always be present at that virtual address on the sink\n-/// and will not get a different virtual address across different\n-/// RunFunctions.\n-/// This address is only valid on the Sink and should not be dereferenced on\n-/// the Source (except for the special case of buffers created with the\n-/// COI_SAME_ADDRESS flag).\n-///\n-/// @param  in_Process\n-///         [in] The process for which the address should be returned.\n-///         Special handle value 0 can be passed to the function;\n-///         in this case, address for the first valid process will be returned\n-///\n-/// @param  in_Buffer\n-///         [in] Buffer handle\n-///\n-/// @param  out_pAddress\n-///         [out] pointer to a uint64_t* that will be filled with the address.\n-///\n-/// @return COI_SUCCESS upon successful return of the buffer's address.\n-///\n-/// @return COI_INVALID_HANDLE if the passed in buffer or process\n-///         handle was invalid.\n-///\n-/// @return COI_INVALID_POINTER if the out_pAddress parameter was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if the in_Process is not valid for in_Buffer at the\n-///         moment of calling the function.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferGetSinkAddressEx(\n-    COIPROCESS          in_Process,\n-    COIBUFFER           in_Buffer,\n-    uint64_t           *out_pAddress);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data from a normal virtual address into an existing COIBUFFER.\n-/// Please note that COIBufferWrite does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferWrite will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-///\n-/// @param  in_DestBuffer\n-///         [in] Buffer to write into.\n-///\n-/// @param  in_DestProcess\n-///         [in] A pointer to the process to which the data will be written.\n-///         Buffer is updated only in this process and invalidated in other\n-///         processes. Only a single process can be specified.\n-///         Can be left NULL and default behavior will be chosen, which\n-///         chooses the first valid process in which regions are found. Other\n-///         buffer regions are invalidated if not updated.\n-///\n-/// @param  in_Offset\n-///         [in] Location in the buffer to start writing to.\n-///\n-/// @param  in_pSourceData\n-///         [in] A pointer to local memory that should be copied into the\n-///         provided buffer.\n-///\n-/// @param  in_Length\n-///         [in] The number of bytes to write from in_pSourceData into\n-///         in_DestBuffer. Must not be larger than the size of in_DestBuffer\n-///         and must not over run in_DestBuffer if an in_Offset is provided.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the write call to\n-///         wait for any additional events to be signaled before starting the\n-///         write operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this write operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer write\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the write.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the write has\n-///         completed. This event can be used as a dependency to order\n-///         the write with regard to future operations.\n-///         If no completion event is passed in then the write is\n-///         synchronous and will block until the transfer is complete.\n-///\n-///\n-/// @return COI_SUCCESS if the buffer was written successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_INVALID_POINTER if the in_pSourceData pointer is NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n-///         the buffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Length is 0.\n-///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not COI_BUFFER_OPENCL\n-///         buffer.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferWriteEx(\n-    COIBUFFER           in_DestBuffer,\n-    const   COIPROCESS          in_DestProcess,\n-    uint64_t            in_Offset,\n-    const   void               *in_pSourceData,\n-    uint64_t            in_Length,\n-    COI_COPY_TYPE       in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data specified by multi-dimensional array data structure into another\n-/// multi-dimensional array in an existing COIBUFFER.\n-/// Arrays with more than 3 dimensions are not supported.\n-/// Different numbers of elements between src and destination is not supported.\n-/// Please note that COIBufferWriteMultiD does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferWriteMultiD will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-///\n-///\n-/// @param  in_DestBuffer\n-///         [in] Buffer to write into.\n-///\n-/// @param  in_DestProcess\n-///         [in] A pointer to the process to which the data will be written.\n-///         Buffer is updated only in this process and invalidated in other\n-///         processes. Only a single process can be specified.\n-///         Can be left NULL and default behavior will be chosen, which\n-///         chooses the first valid process in which regions are found. Other\n-///         buffer regions are invalidated if not updated.\n-///\n-/// @param  in_Offset\n-///         [in] Start location of the destination array within the buffer.\n-///\n-/// @param  in_DestArray\n-///         [in] A pointer to a data structure describing the structure of\n-///         the data array in the buffer. Total size must not be larger than\n-///         the size of in_DestBuffer. The base field of this structure will\n-///         be ignored.\n-///\n-/// @param  in_SrcArray\n-///         [in] A pointer to a data structure describing the structure of\n-///         the data array in local memory that should be copied. in_SrcArray\n-///         and in_DestArry must have the same number of elements. The base\n-///         field of this structure should be the virtual pointer to the local\n-///         memory in which this array is located.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the write call to\n-///         wait for any additional events to be signaled before starting the\n-///         write operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this write operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer write\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the write.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the write has\n-///         completed. This event can be used as a dependency to order\n-///         the write with regard to future operations.\n-///         If no completion event is passed in then the write is\n-///         synchronous and will block until the transfer is complete.\n-///\n-///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer or process handle was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_NOT_SUPPORTED or dimension of destination or source arrays\n-///         are greater than 3 or less than 1\n-///\n-/// @return COI_INVALID_POINTER if the pointer in_SrcArray->base is NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset + size of in_DestArray exceeds the\n-///         size of the buffer.\n-///\n-/// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n-///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not\n-///         a COI_BUFFER_OPENCL buffer.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferWriteMultiD(\n-    COIBUFFER          in_DestBuffer,\n-    const   COIPROCESS         in_DestProcess,\n-    uint64_t           in_Offset,\n-    struct arr_desc   *in_DestArray,\n-    struct arr_desc   *in_SrcArray,\n-    COI_COPY_TYPE      in_Type,\n-    uint32_t           in_NumDependencies,\n-    const   COIEVENT          *in_pDependencies,\n-    COIEVENT          *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data specified by multi-dimensional array data structure from an\n-/// existing COIBUFFER to another multi-dimensional array located in memory.\n-/// Arrays with more than 3 dimensions are not supported.\n-/// Different numbers of elements between source and destination are not supported.\n-/// Please note that COIBufferReadMultiD does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferReadMultiD will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-///\n-///\n-/// @param  in_SourceBuffer\n-///         [in] Buffer to read from.\n-///\n-/// @param  in_Offset\n-///         [in] Start location of the source array within the buffer.\n-///\n-/// @param  in_DestArray\n-///         [in] A pointer to a data structure describing the structure of\n-///         the data array in the buffer. Total size must not be larger than\n-///         the size of in_DestBuffer. The base field of this structure will\n-///         be ignored.\n-///\n-/// @param  in_SrcArray\n-///         [in] A pointer to a data structure describing the structure of\n-///         the data array in local memory that should be copied. in_SrcArray\n-///         and in_DestArry must have the same number of elements. The base\n-///         field of this structure should be the virtual pointer to the local\n-///         memory in which this array is located.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the write call to\n-///         wait for any additional events to be signaled before starting the\n-///         write operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this write operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer write\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the write.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the write has\n-///         completed. This event can be used as a dependency to order\n-///         the write with regard to future operations.\n-///         If no completion event is passed in then the write is\n-///         synchronous and will block until the transfer is complete.\n-///\n-///\n-/// @return COI_SUCCESS if the buffer was written successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer or process handle was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_NOT_SUPPORTED or dimension of destination or source arrays\n-///         are greater than 3 or less than 1\n-///\n-/// @return COI_INVALID_POINTER if the pointer in_DestArray->base is NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset + size of in_SourceArray exceeds the\n-///         size of the buffer.\n-///\n-/// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n-///\n-/// @return COI_RETRY if in_SourceBuffer is mapped and is not\n-///         a COI_BUFFER_OPENCL buffer.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferReadMultiD(\n-    COIBUFFER          in_SourceBuffer,\n-    uint64_t           in_Offset,\n-    struct arr_desc   *in_DestArray,\n-    struct arr_desc   *in_SrcArray,\n-    COI_COPY_TYPE      in_Type,\n-    uint32_t           in_NumDependencies,\n-    const   COIEVENT          *in_pDependencies,\n-    COIEVENT          *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data from a normal virtual address into an existing COIBUFFER.\n-/// Please note that COIBufferWrite does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferWrite will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-///\n-/// @param  in_DestBuffer\n-///         [in] Buffer to write into.\n-///\n-/// @param  in_Offset\n-///         [in] Location in the buffer to start writing to.\n-///\n-/// @param  in_pSourceData\n-///         [in] A pointer to local memory that should be copied into the\n-///         provided buffer.\n-///\n-/// @param  in_Length\n-///         [in] The number of bytes to write from in_pSourceData into\n-///         in_DestBuffer. Must not be larger than the size of in_DestBuffer\n-///         and must not over run in_DestBuffer if an in_Offset is provided.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the write call to\n-///         wait for any additional events to be signaled before starting the\n-///         write operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this write operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer write\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the write.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the write has\n-///         completed. This event can be used as a dependency to order\n-///         the write with regard to future operations.\n-///         If no completion event is passed in then the write is\n-///         synchronous and will block until the transfer is complete.\n-///\n-///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_INVALID_POINTER if the in_pSourceData pointer is NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n-///         the buffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Length is 0.\n-///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not\n-///         a COI_BUFFER_OPENCL buffer.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferWrite(\n-    COIBUFFER           in_DestBuffer,\n-    uint64_t            in_Offset,\n-    const   void               *in_pSourceData,\n-    uint64_t            in_Length,\n-    COI_COPY_TYPE       in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data from a buffer into local memory.\n-/// Please note that COIBufferRead does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferRead will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-///\n-///\n-/// @param  in_SourceBuffer\n-///         [in] Buffer to read from.\n-///\n-/// @param  in_Offset\n-///         [in] Location in the buffer to start reading from.\n-///\n-/// @param  in_pDestData\n-///         [in] A pointer to local memory that should be written into from\n-///         the provided buffer.\n-///\n-/// @param  in_Length\n-///         [in] The number of bytes to write from in_SourceBuffer into\n-///         in_pDestData. Must not be larger than the size of in_SourceBuffer\n-///         and must not over run in_SourceBuffer if an in_Offset is provided.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the read call to\n-///         wait for any additional events to be signaled before starting the\n-///         read operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this read operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer read\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the read.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the read has\n-///         completed. This event can be used as a dependency to order\n-///         the read with regard to future operations.\n-///         If no completion event is passed in then the read is\n-///         synchronous and will block until the transfer is complete.\n-///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n-///         the buffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Length is 0.\n-///\n-/// @return COI_INVALID_POINTER if the in_pDestData pointer is NULL.\n-///\n-/// @return COI_RETRY if in_SourceBuffer is mapped and is not\n-///         a COI_BUFFER_OPENCL buffer.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferRead(\n-    COIBUFFER           in_SourceBuffer,\n-    uint64_t            in_Offset,\n-    void               *in_pDestData,\n-    uint64_t            in_Length,\n-    COI_COPY_TYPE       in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data between two buffers. It also allows copying within the same\n-/// buffer. For copy within the same buffer, if source and destination regions\n-/// overlap then this API returns error.\n-/// Please note that COIBufferCopy does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferCopy will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-/// When a destroyed buffer (destination or source) is provided to the\n-/// function, then behavior is unspecified.\n-///\n-/// @param  in_DestBuffer\n-///         [in] Buffer to copy into.\n-///\n-/// @param  in_DestProcess\n-///         [in] A pointer to the process to which the data will be written.\n-///         Buffer is updated only in this process and invalidated in other\n-///         processes. Only a single process can be specified.\n-///         Can be left NULL and default behavior will be chosen, which\n-///         chooses the first valid process in which regions are found. Other\n-///         buffer regions are invalidated if not updated.\n-///\n-/// @param  in_SourceBuffer\n-///         [in] Buffer to copy from.\n-///\n-/// @param  in_DestOffset\n-///         [in] Location in the destination buffer to start writing to.\n-///\n-/// @param  in_SourceOffset\n-///         [in] Location in the source buffer to start reading from.\n-///\n-/// @param  in_Length\n-///         [in] The number of bytes to copy from in_SourceBuffer into\n-///         in_DestinationBuffer.\n-///         If the length is specified as zero then length to be copied\n-//          is entire destination buffer's length.\n-///         Must not be larger than the size of in_SourceBuffer or\n-///         in_DestBuffer and must not over run in_SourceBuffer or\n-///         in_DestBuffer if offsets are specified.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the copy call to\n-///         wait for any additional events to be signaled before starting the\n-///         copy operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this copy operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer copy\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the copy.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the copy has\n-///         completed. This event can be used as a dependency to order\n-///         the copy with regard to future operations.\n-///         If no completion event is passed in then the copy is\n-///         synchronous and will block until the transfer is complete.\n-///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n-///\n-/// @return COI_INVALID_HANDLE if either buffer handle was invalid.\n-///\n-/// @return COI_MEMORY_OVERLAP if in_SourceBuffer and in_DestBuffer are the\n-///         same buffer(or have the same parent buffer) and the source and\n-///         destination regions overlap\n-///\n-/// @return COI_OUT_OF_RANGE if in_DestOffset is is beyond the end of\n-///         in_DestBuffer\n-///\n-/// @return COI_OUT_OF_RANGE if in_SourceOffset is beyond the end of\n-///         in_SourceBuffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_DestOffset + in_Length exceeds the size of\n-///         the in_DestBuffer\n-///\n-/// @return COI_OUT_OF_RANGE if in_SourceOffset + in_Length exceeds\n-///         the size of in_SourceBuffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n-///         COI_BUFFER_OPENCL buffers.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferCopyEx(\n-    COIBUFFER           in_DestBuffer,\n-    const   COIPROCESS          in_DestProcess,\n-    COIBUFFER           in_SourceBuffer,\n-    uint64_t            in_DestOffset,\n-    uint64_t            in_SourceOffset,\n-    uint64_t            in_Length,\n-    COI_COPY_TYPE       in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Copy data between two buffers. It also allows copying within the same\n-/// buffer. For copy within the same buffer, if source and destination regions\n-/// overlap then this API returns error.\n-/// Please note that COIBufferCopy does not follow implicit buffer\n-/// dependencies. If a buffer is in use in a run function or has been added\n-/// to a process using COIBufferAddRef the call to COIBufferCopy will not\n-/// wait, it will still copy data immediately.\n-/// This is to facilitate a usage model where a buffer is being used outside\n-/// of a run function, for example in a spawned thread, but data still needs\n-/// to be transferred to or from the buffer.\n-/// Additionally this means that if more than one DMA channel is enabled,\n-/// (See COIProcessConfigureDMA) operations to the same buffer may\n-/// happen in parallel if they can be assigned to different DMA hardware.\n-/// So it is highly recommended to use explicit event dependencies to\n-/// order operations where needed.\n-/// When a destroyed buffer (destination or source) is provided to the\n-/// function, then behavior is unspecified.\n-///\n-/// @param  in_DestBuffer\n-///         [in] Buffer to copy into.\n-///\n-/// @param  in_SourceBuffer\n-///         [in] Buffer to copy from.\n-///\n-/// @param  in_DestOffset\n-///         [in] Location in the destination buffer to start writing to.\n-///\n-/// @param  in_SourceOffset\n-///         [in] Location in the source buffer to start reading from.\n-///\n-/// @param  in_Length\n-///         [in] The number of bytes to copy from in_SourceBuffer into\n-///         in_DestinationBuffer.\n-///         If the length is specified as zero then length to be copied\n-///         is entire destination buffer's length.\n-///         Must not be larger than the size of in_SourceBuffer or\n-///         in_DestBuffer and must not over run in_SourceBuffer or\n-///         in_DestBuffer if offsets are specified.\n-///\n-/// @param  in_Type\n-///         [in] The type of copy operation to use, one of either\n-///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the copy call to\n-///         wait for any additional events to be signaled before starting the\n-///         copy operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this copy operation will wait for before starting.\n-///         This allows the user to create dependencies between buffer copy\n-///         calls and other operations such as run functions and map calls. The\n-///         user may pass in NULL if they do not wish to wait for any\n-///         additional dependencies to complete before doing the copy.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the copy has\n-///         completed. This event can be used as a dependency to order\n-///         the copy with regard to future operations.\n-///         If no completion event is passed in then the copy is\n-///         synchronous and will block until the transfer is complete.\n-///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n-///\n-/// @return COI_INVALID_HANDLE if either buffer handle was invalid.\n-///\n-/// @return COI_MEMORY_OVERLAP if in_SourceBuffer and in_DestBuffer are the\n-///         same buffer(or have the same parent buffer) and the source and\n-///         destination regions overlap\n-///\n-/// @return COI_OUT_OF_RANGE if in_DestOffset is is beyond the end of\n-///         in_DestBuffer\n-///\n-/// @return COI_OUT_OF_RANGE if in_SourceOffset is beyond the end of\n-///         in_SourceBuffer.\n-///\n-/// @return COI_OUT_OF_RANGE if in_DestOffset + in_Length exceeds the size of\n-///         the in_DestBuffer\n-///\n-/// @return COI_OUT_OF_RANGE if in_SourceOffset + in_Length exceeds\n-///         the size of in_SourceBuffer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n-///         in_NumDependencies is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n-///         in_NumDependencies is not 0.\n-///\n-/// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n-///         COI_BUFFER_OPENCL buffers.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferCopy(\n-    COIBUFFER           in_DestBuffer,\n-    COIBUFFER           in_SourceBuffer,\n-    uint64_t            in_DestOffset,\n-    uint64_t            in_SourceOffset,\n-    uint64_t            in_Length,\n-    COI_COPY_TYPE       in_Type,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This API allows an experienced Intel(R) Coprocessor Offload Infrastructure\n-/// (Intel(R) COI) developer to set where a COIBUFFER is\n-/// located and when the COIBUFFER's data is moved. This functionality is\n-/// useful when the developer knows when and where a buffer is going to be\n-/// accessed. It allows the data movement to happen sooner than if the\n-/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// runtime tried to manage the buffer placement itself. The advantage of\n-/// this API is that the developer knows much more about their own\n-/// application's data access patterns and can therefore optimize the data\n-/// access to be much more efficient than the Intel(R)Coprocessor Offload\n-/// Infrastructure (Intel(R) COI) runtime. Using this API may yield better\n-/// memory utilization, lower latency and overall improved workload\n-/// throughput.\n-/// This API does respect implicit dependencies for buffer read/write hazards.\n-/// For example, if the buffer is being written in one COIPROCESS and the user\n-/// requests the buffer be placed in another COIPROCESS then this API will wait\n-/// for the first access to complete before moving the buffer.\n-/// This API is not required for program correctness. It is intended solely\n-/// for advanced Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// developers who wish to fine tune their application performance\n-/// Cases where \"a change in state\" is an error condition the change just gets\n-/// ignored without any error. This is because the SetState can be a\n-/// nonblocking call and in such cases we can't rely on the state of the buffer\n-/// at the time of the call. We can do the transition checks only at the time\n-/// when the actual state change happens (which is something in future).\n-/// Currently there is no way to report an error from something that happens in\n-/// future and that is why such state transitions are nop. One example is using\n-/// VALID_MAY_DROP with COI_SINK_OWNERS when buffer is not valid at source.\n-/// This operation will be a nop if at the time of actual state change the\n-/// buffer is not valid at source.\n-///\n-/// @param  in_Buffer\n-///         [in] The buffer to modify.\n-///\n-/// @param  in_Process\n-///         [in] The process where the state is being modified for this\n-///         buffer. To modify buffer's state on source process use\n-///         COI_PROCESS_SOURCE as process handle. To modify buffer's\n-///         state on all processes where buffer is valid use COI_SINK_OWNERS\n-///         as the process handle.\n-///\n-/// @param  in_State\n-///         [in] The new state for the buffer. The buffer's state could be\n-///         set to invalid on one of the sink processes where it is being\n-///         used.\n-///\n-/// @param  in_DataMove\n-///         [in] A flag to indicate if the buffer's data should be moved\n-///         when the state is changed. For instance, a buffer's state may\n-///         be set to valid on a process and the data move flag may be set to\n-///         COI_BUFFER_MOVE which would cause the buffer contents to be\n-///         copied to the process where it is now valid.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the SetState call\n-///         to wait for any additional events to be signaled before starting\n-///         this operation.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this SetState operation will wait for before starting\n-///         This allows the user to create dependencies between buffer\n-///         SetState calls and other operations such as run functions and map\n-///         calls. The user may pass in NULL if they do not wish to wait for\n-///         any additional dependencies to complete before doing the SetState\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional event to be signaled when the SetState has\n-///         completed. This event can be used as a dependency to order\n-///         the SetState with regard to future operations.\n-///         If no completion event is passed in then the state changing is\n-///         synchronous and will block until the SetState and dma transfers\n-///         related to this operation are complete.\n-///\n-/// @return COI_SUCCESS if the buffer's state was changed successfully.\n-///\n-/// @return COI_INVALID_HANDLE if in_Buffer or in_Process is invalid.\n-///\n-/// @return COI_NOT_SUPPORTED if the in_Buffer is of any type other than\n-///         COI_BUFFER_NORMAL or COI_BUFFER_OPENCL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_State is COI_BUFFER_VALID_MAY_DROP\n-///         and the in_Process is COI_PROCESS_SOURCE.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_Process is COI_SINK_OWNERS and the\n-///         COI_BUFFER_MOVE is passed as move flag.\n-///\n-/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process\n-///         handle that was passed in.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferSetState(\n-    COIBUFFER               in_Buffer,\n-    COIPROCESS              in_Process,\n-    COI_BUFFER_STATE        in_State,\n-    COI_BUFFER_MOVE_FLAG    in_DataMove,\n-    uint32_t                in_NumDependencies,\n-    const   COIEVENT               *in_pDependencies,\n-    COIEVENT               *out_pCompletion);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Creates a sub-buffer that is a reference to a portion of an existing\n-/// buffer. The returned buffer handle can be used in all API calls that the\n-/// original buffer handle could be used in except COIBufferCreateSubBuffer.\n-/// Sub buffers out of Huge Page Buffer are also supported but the original\n-/// buffer needs to be a OPENCL buffer created with COI_OPTIMIZE_HUGE_PAGE_SIZE\n-/// flag.\n-///\n-/// When the sub-buffer is used only the corresponding sub-section of the\n-/// original buffer is used or affected.\n-///\n-/// @param  in_Buffer\n-///         [in] The original buffer that this new sub-buffer is a reference\n-///         to.\n-///\n-/// @param  in_Length\n-///         [in] The length of the sub-buffer in number of bytes.\n-///\n-/// @param  in_Offset\n-///         [in] Where in the original buffer to start this sub-buffer.\n-///\n-/// @param  out_pSubBuffer\n-///         [out] Pointer to a buffer handle that is filled in with the newly\n-///         created sub-buffer.\n-///\n-/// @return COI_SUCCESS if the sub-buffer was created\n-///\n-/// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Length is zero, or if in_Offset + in_Length\n-///         is greater than the size of the original buffer.\n-///\n-/// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n-///\n-/// @return COI_INVALID_POINTER if the out_pSubBuffer pointer is NULL.\n-///\n-/// @return COI_NOT_SUPPORTED if the in_Buffer is of any type other than\n-///         COI_BUFFER_OPENCL\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferCreateSubBuffer(\n-    COIBUFFER   in_Buffer,\n-    uint64_t    in_Length,\n-    uint64_t    in_Offset,\n-    COIBUFFER  *out_pSubBuffer);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Releases the reference count on the specified buffer and process by\n-/// in_ReleaseRefcnt. The returned result being COI_SUCCESS indicates that the\n-/// specified process contains a reference to the specified buffer that has a\n-/// refcnt that can be decremented. Otherwise, if the buffer or process\n-/// specified do not exist, then COI_INVALID_HANDLE will be returned. If the\n-/// process does not contain a reference to the specified buffer then\n-/// COI_OUT_OF_RANGE will be returned.\n-///\n-///\n-/// @param  in_Process\n-///         [in] The COI Process whose reference count for the specified buffer\n-///         the user wants to decrement.\n-///\n-/// @param  in_Buffer\n-///         [in] The buffer used in the specified coi process in which the user\n-///         wants to decrement the reference count.\n-///\n-/// @param  in_ReleaseRefcnt\n-///         [in] The value the reference count will be decremented by.\n-///\n-/// @return COI_SUCCESS if the reference count was successfully decremented.\n-///\n-/// @return COI_INVALID_HANDLE if in_Buffer or in_Process are invalid handles.\n-///\n-/// @return COI_OUT_OF_RANGE if the reference for the specified buffer or\n-///         process does not exist.\n-///\n-\n-COIACCESSAPI\n-COIRESULT\n-COIBufferReleaseRefcnt(\n-    COIPROCESS          in_Process,\n-    COIBUFFER           in_Buffer,\n-    uint64_t            in_ReleaseRefcnt);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Increments the reference count on the specified buffer and process by\n-/// in_AddRefcnt. The returned result being COI_SUCCESS indicates that the\n-/// specified process contains a reference to the specified buffer or a new\n-/// reference has been created and that reference has a new refcnt. Otherwise,\n-/// if the buffer or process specified do not exist, then COI_INVALID_HANDLE\n-/// will be returned. If the input buffer is not valid on the target process\n-/// then COI_NOT_INITIALIZED will be returned since the buffer is not current\n-/// or allocated on the process.\n-///\n-/// @param  in_Process\n-///         [in] The COI Process whose reference count for the specified buffer\n-///         the user wants to increment.\n-///\n-/// @param  in_Buffer\n-///         [in] The buffer used in the specified coi process in which the user\n-///         wants to increment the reference count.\n-///\n-/// @param  in_AddRefcnt\n-///         [in] The value the reference count will be incremented by.\n-///\n-/// @return COI_SUCCESS if the reference count was successfully incremented.\n-///\n-/// @return COI_INVALID_HANDLE if in_Buffer or in_Process are invalid handles.\n-///\n-/// @return COI_NOT_INITIALIZED if in_Buffer does not have a buffer state of\n-///         COI_BUFFER_VALID on the in_Process.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIBufferAddRefcnt(\n-    COIPROCESS          in_Process,\n-    COIBUFFER           in_Buffer,\n-    uint64_t            in_AddRefcnt);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIBUFFER_SOURCE_H */\n-\n-/*! @} */"}, {"sha": "d4f6c1bd11f574c561ef1b53c0fcb5cac16b5845", "filename": "liboffloadmic/include/coi/source/COIEngine_source.h", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,273 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIENGINE_SOURCE_H\n-#define _COIENGINE_SOURCE_H\n-\n-/** @ingroup COIEngine\n- *  @addtogroup COIEngineSource\n-@{\n-\n-* @file source\\COIEngine_source.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-    #include <wchar.h>\n-    #include \"../common/COITypes_common.h\"\n-    #include \"../common/COIResult_common.h\"\n-    #include \"../common/COIEngine_common.h\"\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#define COI_MAX_DRIVER_VERSION_STR_LEN 255\n-\n-#define COI_MAX_HW_THREADS 1024\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// This enum defines miscellaneous information returned from the\n-/// COIGetEngineInfo() function.\n-///\n-typedef enum\n-{\n-    COI_ENG_ECC_DISABLED = 0,            //ECC is not enabled on this engine\n-    COI_ENG_ECC_ENABLED = 0x00000001,    //ECC is enabled on this engine\n-    COI_ENG_ECC_UNKNOWN = 0x00000002     //ECC is mode is unknown\n-} coi_eng_misc;\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// This structure returns information about an Intel(R) Xeon Phi(TM)\n-/// coprocessor.\n-/// A pointer to this structure is passed into the COIGetEngineInfo() function,\n-/// which fills in the data before returning to the caller.\n-///\n-typedef struct COI_ENGINE_INFO\n-{\n-    /// The version string identifying the driver.\n-    coi_wchar_t  DriverVersion[COI_MAX_DRIVER_VERSION_STR_LEN];\n-\n-    /// The DeviceType supported by the engine.\n-    COI_DEVICE_TYPE ISA;\n-\n-    /// The number of cores on the engine.\n-    uint32_t     NumCores;\n-\n-    /// Miscellaneous fields\n-    coi_eng_misc MiscFlags;\n-\n-    /// The number of hardware threads on the engine.\n-    uint32_t     NumThreads;\n-\n-    /// The maximum frequency (in MHz) of the cores on the engine.\n-    uint32_t     CoreMaxFrequency;\n-\n-    /// The load percentage for each of the hardware threads on the engine.\n-    /// Currently this is limited to reporting out a maximum of 1024 HW threads\n-    uint32_t     Load[COI_MAX_HW_THREADS];\n-\n-    /// The amount of physical memory managed by the OS.\n-    uint64_t     PhysicalMemory;\n-\n-    /// The amount of free physical memory in the OS.\n-    uint64_t     PhysicalMemoryFree;\n-\n-    /// The amount of swap memory managed by the OS.\n-    uint64_t     SwapMemory;\n-\n-    /// The amount of free swap memory in the OS.\n-    uint64_t     SwapMemoryFree;\n-\n-    /// The pci config vendor id\n-    uint16_t     VendorId;\n-\n-    /// The pci config device id\n-    uint16_t     DeviceId;\n-\n-    /// The pci config subsystem id\n-    uint16_t     SubSystemId;\n-\n-    /// The stepping of the board, A0, A1, C0, D0 etc.\n-    uint16_t     BoardStepping;\n-\n-    /// The SKU of the stepping, EB, ED, etc.\n-    uint16_t     BoardSKU;\n-} COI_ENGINE_INFO;\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns information related to a specified engine. Note that if the runtime\n-/// is unable to query a value it will be returned as zero but the call will\n-/// still succeed.\n-///\n-///\n-/// @param  in_EngineHandle\n-///         [in] The COIENGINE structure as provided from COIEngineGetHandle()\n-///         which to query for device level information.\n-///\n-/// @param  in_EngineInfoSize\n-///         [in] The size of the structure that out_pEngineInfo points to.\n-///         Used for version safety of the function call.\n-///\n-/// @param  out_pEngineInfo\n-///         [out] The address of a user allocated COI_ENGINE_INFO structure.\n-///         Upon success, the contents of the structure will be updated\n-///         to contain information related to the specified engine.\n-///\n-///\n-/// @return  COI_SUCCESS if the function completed without error.\n-///\n-/// @return  COI_INVALID_HANDLE if the in_EngineHandle handle is not valid.\n-///\n-/// @return  COI_SIZE_MISMATCH if in_EngineInfoSize does not match any current\n-///          or previous COI_ENGINE_INFO structure sizes.\n-///\n-/// @return  COI_INVALID_POINTER if the out_pEngineInfo pointer is NULL.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEngineGetInfo(\n-    COIENGINE           in_EngineHandle,\n-    uint32_t            in_EngineInfoSize,\n-    COI_ENGINE_INFO    *out_pEngineInfo);\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns the number of engines in the system that match the provided device type.\n-///\n-/// The number of available coprocessor devices (i.e. cards connected via PCIe)\n-/// is detected by the COI runtime.\n-///\n-/// @param  in_DeviceType\n-///         [in] Specifies the ISA type of the engine requested.\n-///\n-/// @param  out_pNumEngines\n-///         [out] The number of engines available. This can be used to index\n-///         into the engines using COIEngineGetHandle().\n-///\n-/// @return COI_SUCCESS if the function completed without error.\n-///\n-/// @return COI_DOES_NOT_EXIST if the in_DeviceType parameter is not valid.\n-///\n-/// @return COI_INVALID_POINTER if the out_pNumEngines parameter is NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if number of selected devices is greater than 8.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEngineGetCount(\n-    COI_DEVICE_TYPE in_DeviceType,\n-    uint32_t       *out_pNumEngines);\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns the handle of a user specified engine.\n-///\n-/// @param  in_DeviceType\n-///         [in] Specifies the ISA type of the engine requested.\n-///\n-/// @param  in_EngineIndex\n-///         [in] A unsigned integer which specifies the zero-based position of\n-///         the engine in a collection of engines. The makeup of this\n-///         collection is defined by the in_DeviceType parameter.\n-///\n-/// @param  out_pEngineHandle\n-///         [out] The address of a COIENGINE handle.\n-///\n-/// @return COI_SUCCESS if the function completed without error.\n-///\n-/// @return COI_DOES_NOT_EXIST if the in_DeviceType parameter is not valid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_EngineIndex is greater than or equal to\n-///         the number of engines that match the in_DeviceType parameter.\n-///\n-/// @return COI_INVALID_POINTER if the out_pEngineHandle parameter is NULL.\n-///\n-/// @return COI_VERSION_MISMATCH if the version of Intel(R) Coprocessor Offload\n-///         Infrastructure (Intel(R) COI) on the host is not\n-///         compatible with the version on the device.\n-///\n-/// @return COI_NOT_INITIALIZED if the engine requested exists but is offline.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEngineGetHandle(\n-    COI_DEVICE_TYPE in_DeviceType,\n-    uint32_t        in_EngineIndex,\n-    COIENGINE      *out_pEngineHandle);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Returns the hostname for a specified COIEngine.\n-///\n-/// @param  in_EngineHandle\n-///         [in] The connected COI Engine Handle passed in by the user that is\n-///         used to request the hostname of the device connected by this COIEngine.\n-///\n-/// @param  out_Hostname\n-///         [out] The hostname of the device connected by this COIEngine.\n-///         COI will write at most 4096 bytes and the user must make sure that the size\n-///         of the memory pointed by this argument is large enough.\n-///\n-/// @return COI_SUCCESS if the hostname was retrieved without error.\n-///\n-/// @return COI_ERROR if the function was unable to retrieve the hostname and/or\n-///         the retrieved out_Hostname is NULL.\n-///\n-/// @return COI_INVALID_HANDLE if the in_EngineHandle is invalid.\n-///\n-/// @return COI_INVALID_POINTER if the out_Hostname is NULL.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEngineGetHostname(\n-    COIENGINE in_EngineHandle,\n-    char     *out_Hostname);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIENGINE_SOURCE_H */\n-\n-/*! @} */"}, {"sha": "8c6ad25c76f1785b40f17f96762018da33c5a930", "filename": "liboffloadmic/include/coi/source/COIEvent_source.h", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,301 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIEVENT_SOURCE_H\n-#define _COIEVENT_SOURCE_H\n-\n-/** @ingroup COIEvent\n- *  @addtogroup COIEventSource\n-@{\n-* @file source/COIEvent_source.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Special case event values which can be passed in to APIs to specify\n-/// how the API should behave. In COIBuffer APIs passing in NULL for the\n-/// completion event is the equivalent of passing COI_EVENT_SYNC.\n-/// Note that passing COI_EVENT_ASYNC can be used when the caller wishes the\n-/// operation to be performed asynchronously but does not care when the\n-/// operation completes. This can be useful for operations that by definition\n-/// must complete in order (DMAs, run functions on a single pipeline). If\n-/// the caller does care when the operation completes then they should pass\n-/// in a valid completion event which they can later wait on.\n-///\n-#define COI_EVENT_ASYNC ((COIEVENT*)1)\n-#define COI_EVENT_SYNC  ((COIEVENT*)2)\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// This can be used to initialize a COIEVENT to a known invalid state.\n-/// This is not required to use, but can be useful in some cases\n-/// if a program is unsure if the event will be initialized by the runtime.\n-/// Simply set the event to this value: COIEVENT event = COI_EVENT_INITIALIZER;\n-///\n-#define COI_EVENT_INITIALIZER   { { 0, -1 } }\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Wait for an arbitrary number of COIEVENTs to be signaled as completed,\n-/// eg when the run function or asynchronous map call associated with an event\n-/// has finished execution.\n-/// If the user sets in_WaitForAll = True and not all of the events are\n-/// signaled when the timeout period is reached then COI_TIME_OUT_REACHED will\n-/// be returned.\n-/// If the user sets in_WaitForAll = False then if at least one event is\n-/// signaled when the timeout is reached then COI_SUCCESS is returned.\n-///\n-/// @param  in_NumEvents\n-///         [in] The number of events to wait for.\n-///\n-/// @param  in_pEvents\n-///         [in] The array of COIEVENT handles to wait for.\n-///\n-/// @param  in_Timeout\n-///         [in] The time in milliseconds to wait for the event. 0 polls\n-///         and returns immediately, -1 blocks indefinitely.\n-///\n-/// @param  in_WaitForAll\n-///         [in] Boolean value specifying behavior. If true, wait for all\n-///         events to be signaled, or for timeout, whichever happens first.\n-///         If false, return when any event is signaled, or at timeout.\n-///\n-/// @param  out_pNumSignaled\n-///         [out] The number of events that were signaled. If in_NumEvents\n-///         is 1 or in_WaitForAll = True, this parameter is optional.\n-///\n-/// @param  out_pSignaledIndices\n-///         [out] Pointer to an array of indices into the original event\n-///         array. Those denoted have been signaled. The user must provide an\n-///         array that is no smaller than the in_Events array. If in_NumEvents\n-///         is 1 or in_WaitForAll = True, this parameter is optional.\n-///\n-/// @return COI_SUCCESS once an event has been signaled completed.\n-///\n-/// @return COI_TIME_OUT_REACHED if the events are still in use when the\n-///         timeout is reached or timeout is zero (a poll).\n-///\n-/// @return COI_OUT_OF_RANGE if a negative value other than -1 is passed in to\n-///         the in_Timeout parameter.\n-///\n-/// @return COI_OUT_OF_RANGE if in_NumEvents is 0.\n-///\n-/// @return COI_INVALID_POINTER if in_pEvents is NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_NumEvents > 1 and if in_WaitForAll\n-///         is not true and out_pSignaled or out_pSignaledIndicies are NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if out_pNumSignaled is not NULL\n-///         and out_pSignaledIndices is NULL (or vice versa).\n-///\n-/// @return COI_EVENT_CANCELED if while waiting on a user event, it gets\n-///         unregistered this returns COI_EVENT_CANCELED\n-///\n-/// @return COI_PROCESS_DIED if the remote process died. See COIProcessDestroy\n-///         for more details.\n-///\n-/// @return COI_<REAL ERROR> if only a single event is passed in, and that event\n-///         failed, COI will attempt to return the real error code that caused\n-///         the original operation to fail, otherwise COI_PROCESS_DIED is reported.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEventWait(\n-    uint16_t        in_NumEvents,\n-    const   COIEVENT       *in_pEvents,\n-    int32_t         in_TimeoutMilliseconds,\n-    uint8_t         in_WaitForAll,\n-    uint32_t       *out_pNumSignaled,\n-    uint32_t       *out_pSignaledIndices);\n-\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Register a User COIEVENT so that it can be fired. Registered event is\n-/// a one shot User event; in other words once signaled it cannot be used\n-/// again for signaling. You have to unregister and register again to enable\n-/// signaling. An event will be reset if it is re-registered without\n-/// unregistering, resulting in loss of all outstanding signals.\n-///\n-/// @param  out_pEvent\n-///         [out] Pointer to COIEVENT handle being Registered\n-///\n-/// @return COI_SUCCESS an event is successfully registered\n-///\n-/// @return COI_INVALID_POINTER if out_pEvent is NULL\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEventRegisterUserEvent(\n-    COIEVENT *out_pEvent);\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Unregister a User COIEVENT. Unregistering a unsignaled event is similar\n-/// to firing an event. Except Calling COIEventWait on an event that is\n-/// being unregistered returns COI_EVENT_CANCELED\n-///\n-/// @param  in_Event\n-///         [in] Event Handle to be unregistered.\n-///\n-/// @return COI_INVALID_HANDLE if in_Event is not a UserEvent\n-///\n-/// @return COI_SUCCESS if an event is successfully unregistered\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEventUnregisterUserEvent(\n-    COIEVENT in_Event);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// A callback that will be invoked to notify the user of an internal\n-/// runtime event completion.\n-///\n-/// As with any callback mechanism it is up to the user to make sure that\n-/// there are no possible deadlocks due to reentrancy (ie the callback being\n-/// invoked in the same context that triggered the notification) and also\n-/// that the callback does not slow down overall processing. If the user\n-/// performs too much work within the callback it could delay further\n-/// processing. The callback will be invoked prior to the signaling of\n-/// the corresponding COIEvent. For example, if a user is waiting\n-/// for a COIEvent associated with a run function completing they will\n-/// receive the callback before the COIEvent is marked as signaled.\n-///\n-/// @param  in_Event\n-///         [in] The completion event that is associated with the\n-///         operation that is being notified.\n-///\n-/// @param  in_Result\n-///         [in] The COIRESULT of the operation.\n-///\n-/// @param  in_UserData\n-///         [in] Opaque data that was provided when the callback was\n-///         registered. Intel(R) Coprocessor Offload Infrastructure\n-///         (Intel(R) COI) simply passes this back to the user so that\n-///         they can interpret it as they choose.\n-///\n-typedef void (*COI_EVENT_CALLBACK)(\n-    COIEVENT            in_Event,\n-    const   COIRESULT           in_Result,\n-    const   void               *in_UserData);\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Registers any COIEVENT to receive a one time callback, when the event\n-/// is marked complete in the offload runtime. If the event has completed\n-/// before the COIEventRegisterCallback() is called then the callback will\n-/// immediately be invoked by the calling thread. When the event is\n-/// registered before the event completes, the runtime gaurantees that\n-/// the callback will be invoked before COIEventWait() is notified of\n-/// the same event completing. In well written user code, this may provide\n-/// a slight performance advantage.\n-///\n-/// Users should treat the callback much like an interrupt routine, in regards\n-/// of performance. Specifically designing the callback to be as short and\n-/// non blocking as possible. Since the thread that runs the callback is\n-/// non deterministic blocking or stalling of the callback, may have severe\n-/// performance impacts on the offload runtime. Thus, it is important to not\n-/// create deadlocks between the callback and other signaling/waiting\n-/// mechanisms. It is recommended to never invoke COIEventWait() inside\n-/// a callback function, as this could lead to immediate deadlocks.\n-///\n-/// It is important to note that the runtime cannot distinguish between\n-/// already triggered events and invalid events. Thus the user needs to pass\n-/// in a valid event, or the callback will be invoked immediately.\n-/// Failed events will still receive a callback and the user can query\n-/// COIEventWait() after the callback for the failed return code.\n-///\n-/// If more than one callback is registered for the same event, only the\n-/// single most current callback will be used, i.e. the older one will\n-/// be replaced.\n-///\n-/// @param  in_Event\n-///         [in] A valid single event handle to be registered to receive a callback.\n-///\n-/// @param  in_Callback\n-///         [in] Pointer to a user function used to signal an\n-///         event completion.\n-///\n-/// @param  in_UserData\n-///         [in] Opaque data to pass to the callback when it is invoked.\n-///\n-/// @param  in_Flags\n-///         [in] Reserved parameter for future expansion, required to be zero for now.\n-///\n-/// @return COI_INVALID_HANDLE if in_Event is not a valid COIEVENT\n-///\n-/// @return COI_INVALID_HANDLE if in_Callback is not a valid pointer.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the in_Flags is not zero.\n-///\n-/// @return COI_SUCCESS an event is successfully registered\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIEventRegisterCallback(\n-    const COIEVENT                in_Event,\n-    COI_EVENT_CALLBACK      in_Callback,\n-    const void                   *in_UserData,\n-    const uint64_t                in_Flags);\n-\n-\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIEVENT_SOURCE_H */\n-\n-/*! @} */"}, {"sha": "c13404d7f6a76904f43bad6ddf121ef43a337326", "filename": "liboffloadmic/include/coi/source/COIPipeline_source.h", "status": "removed", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,437 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIPIPELINE_SOURCE_H\n-#define _COIPIPELINE_SOURCE_H\n-\n-/** @ingroup COIPipeline\n- *  @addtogroup COIPipelineSource\n-@{\n-* @file source/COIPipeline_source.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// These flags specify how a buffer will be used within a run function. They\n-/// allow the runtime to make optimizations in how it moves the data around.\n-/// These flags can affect the correctness of an application, so they must be\n-/// set properly. For example, if a buffer is used in a run function with the\n-/// COI_SINK_READ flag and then mapped on the source, the runtime may use a\n-/// previously cached version of the buffer instead of retrieving data from\n-/// the sink.\n-typedef enum COI_ACCESS_FLAGS\n-{\n-    /// Specifies that the run function will only read the associated buffer.\n-    COI_SINK_READ = 1,\n-\n-    /// Specifies that the run function will write to the associated buffer.\n-    COI_SINK_WRITE,\n-\n-    /// Specifies that the run function will overwrite the entire associated\n-    /// buffer and therefore the buffer will not be synchronized with the\n-    /// source before execution.\n-    COI_SINK_WRITE_ENTIRE,\n-\n-    /// Specifies that the run function will only read the associated buffer\n-    /// and will maintain the reference count on the buffer after\n-    /// run function exit.\n-    COI_SINK_READ_ADDREF,\n-\n-    /// Specifies that the run function will write to the associated buffer\n-    /// and will maintain the reference count on the buffer after\n-    /// run function exit.\n-    COI_SINK_WRITE_ADDREF,\n-\n-    /// Specifies that the run function will overwrite the entire associated\n-    /// buffer and therefore the buffer will not be synchronized with the\n-    /// source before execution and will maintain the reference count on the\n-    /// buffer after run function exit.\n-    COI_SINK_WRITE_ENTIRE_ADDREF\n-} COI_ACCESS_FLAGS;\n-\n-#define COI_PIPELINE_MAX_PIPELINES 512\n-#define COI_PIPELINE_MAX_IN_BUFFERS 16384\n-#define COI_PIPELINE_MAX_IN_MISC_DATA_LEN 32768\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Create a pipeline associated with a remote process. This pipeline can\n-/// then be used to execute remote functions and to share data using\n-/// COIBuffers.\n-///\n-/// @param  in_Process\n-///         [in] A handle to an already existing process that the pipeline\n-///         will be associated with.\n-///\n-/// @param  in_Mask\n-///         [in] An optional mask of the set of hardware threads on which the\n-///         sink pipeline command processing thread could run.\n-///\n-/// @param  in_StackSize\n-///         [in] An optional value that will be used when the pipeline\n-///         processing thread is created on the sink. If the user passes in\n-///         0 the OS default stack size will be used. Otherwise the value\n-///         must be PTHREAD_STACK_MIN (16384) bytes or larger and must be\n-///         a multiple of a page (4096 bytes).\n-///\n-/// @param  out_pPipeline\n-///         [out] Handle returned to uniquely identify the pipeline that was\n-///         created for use in later API calls.\n-///\n-///\n-/// @return COI_SUCCESS if the pipeline was successfully created.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n-///\n-/// @return COI_INVALID_POINTER if the out_pPipeline pointer was NULL.\n-///\n-/// @return COI_RESOURCE_EXHAUSTED if no more COIPipelines can be created. The\n-///         maximum number of pipelines allowed is COI_PIPELINE_MAX_PIPELINES.\n-///         It is recommended in most cases to not exceed the number of CPU's\n-///         that are reported on the offload device, performance will suffer.\n-///\n-///\n-/// @return COI_OUT_OF_RANGE if the in_StackSize > 0 &&\n-///         in_StackSize < PTHREAD_STACK_MIN or if in_StackSize is not a\n-///         multiple of a page (4096 bytes).\n-///\n-/// @return COI_OUT_OF_RANGE if the in_Mask is set to all zeroes. If no mask\n-///         is desired then the in_Mask should be passed as NULL, otherwise\n-///         at least one thread must be set.\n-///\n-/// @return COI_TIME_OUT_REACHED if establishing the communication channel with\n-///         the remote pipeline timed out.\n-///\n-/// @return COI_RETRY if the pipeline cannot be created due to the number of\n-///         source-to-sink connections in use. A subsequent call to\n-///         COIPipelineCreate may succeed if resources are freed up.\n-///\n-/// @return COI_PROCESS_DIED if in_Process died.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineCreate(\n-    COIPROCESS          in_Process,\n-    COI_CPU_MASK        in_Mask,\n-    uint32_t            in_StackSize,\n-    COIPIPELINE        *out_pPipeline);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Destroys the indicated pipeline, releasing its resources.\n-///\n-/// @param  in_Pipeline\n-///         [in] Pipeline to destroy.\n-///\n-///\n-/// @return COI_SUCCESS if the pipeline was destroyed\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineDestroy(\n-    COIPIPELINE         in_Pipeline);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Enqueues a function in the remote process binary to be executed. The\n-/// function execution is asynchronous in regards to the Source and all\n-/// run functions enqueued on a pipeline are executed in-order. The run\n-/// function will only execute when all of the required buffers are present\n-/// in the Sink's memory.\n-///\n-/// Potential Hazards while using Runfunctions:\n-///\n-/// 1. Proper care has to be taken while setting the input dependencies for\n-///    RunFunctions. Setting it incorrectly can lead to cyclic dependencies\n-///    and can cause the respective pipeline to stall.\n-/// 2. RunFunctions can also segfault if enough memory space is not available\n-///    on the sink for the buffers passed in. Buffers that are AddRef'd\n-///    need to be accounted for available memory space. In other\n-///    words, this memory is not available for use until it is freed up.\n-/// 3. Unexpected segmentation faults or erroneous behavior can occur if\n-///    handles or data passed in to Runfunction gets destroyed before the\n-///    RunFunction finishes.\n-///    For example, if a variable passed in as Misc data or the buffer gets\n-///    destroyed before the runtime receives the completion notification\n-///    of the Runfunction, it can cause unexpected behavior. So it is always\n-///    recommended to wait for RunFunction completion event before any related\n-///    destroy event occurs.\n-///\n-/// The runtime expects users to handle such scenarios. COIPipelineRunFunction\n-/// returns COI_SUCCESS for above cases because it was queued up successfully.\n-/// Also if you try to destroy a pipeline with a stalled function then the\n-/// destroy call will hang. COIPipelineDestroy waits until all the functions\n-/// enqueued are finished executing.\n-///\n-/// @param  in_Pipeline\n-///         [in] Handle to a previously created pipeline that this run\n-///         function should be enqueued to.\n-///\n-/// @param  in_Function\n-///         [in] Previously returned handle from a call to\n-///         COIPipelineGetFunctionHandle() that represents a function in the\n-///         application running on the Sink process.\n-///\n-/// @param  in_NumBuffers\n-///         [in] The number of buffers that are being passed to the run\n-///         function. This number must match the number of buffers in the\n-///         in_pBuffers and in_pBufferAccessFlags arrays. Must be less than\n-///         COI_PIPELINE_MAX_IN_BUFFERS.\n-///\n-/// @param  in_pBuffers\n-///         [in] An array of COIBUFFER handles that the function is expected\n-///         to use during its execution. Each buffer when it arrives at the\n-///         Sink process will be at least 4k page aligned, thus, using a very\n-///         large number of small buffers is memory inefficient and should be\n-///         avoided.\n-///\n-/// @param  in_pBufferAccessFlags\n-///         [in] An array of flag values which correspond to the buffers\n-///         passed in the in_pBuffers parameter. These flags are used to\n-///         track dependencies between different run functions being\n-///         executed from different pipelines.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the run function\n-///         to wait for any dependencies.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of COIEVENT objects that this run\n-///         function will wait for before executing. This allows the user to\n-///         create dependencies between run functions in different pipelines.\n-///         The user may pass in NULL if they do not wish to wait for any\n-///         dependencies to complete.\n-///\n-/// @param  in_pMiscData\n-///         [in] Pointer to user defined data, typically used to pass\n-///         parameters to Sink side functions. Should only be used for small\n-///         amounts data since the data will be placed directly in the\n-///         Driver's command buffer. COIBuffers should be used to pass large\n-///         amounts of data.\n-///\n-/// @param  in_MiscDataLen\n-///         [in] Size of the in_pMiscData in bytes. Must be less than\n-///         COI_PIPELINE_MAX_IN_MISC_DATA_LEN, and should usually be much\n-///         smaller, see documentation for the parameter in_pMiscData.\n-///\n-/// @param  out_pAsyncReturnValue\n-///         [out] Pointer to user-allocated memory where the return value from\n-///         the run function will be placed. This memory should not be read\n-///         until out_pCompletion has been signaled.\n-///\n-/// @param  in_AsyncReturnValueLen\n-///         [in] Size of the out_pAsyncReturnValue in bytes.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional pointer to a COIEVENT object\n-///         that will be signaled when this run function has completed\n-///         execution. The user may pass in NULL if they wish for this function\n-///         to be synchronous, otherwise if a COIEVENT object is passed in the\n-///         function is then asynchronous and closes after enqueuing the\n-///         RunFunction and passes back the COIEVENT that will be signaled\n-///         once the RunFunction has completed.\n-///\n-/// @return COI_SUCCESS if the function was successfully placed in a\n-///         pipeline for future execution. Note that the actual\n-///         execution of the function will occur in the future.\n-///\n-/// @return COI_OUT_OF_RANGE if in_NumBuffers is greater than\n-///         COI_PIPELINE_MAX_IN_BUFFERS or if in_MiscDataLen is greater than\n-///         COI_PIPELINE_MAX_IN_MISC_DATA_LEN.\n-///\n-/// @return COI_INVALID_HANDLE if the pipeline handle passed in was invalid.\n-///\n-/// @return COI_INVALID_HANDLE if the function handle passed in was invalid.\n-///\n-/// @return COI_INVALID_HANDLE if any of the buffers passed in are invalid.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n-///         in_pDependencies was passed in as NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is non-NULL but\n-///         in_NumDependencies is zero.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_MiscDataLen is non-zero while\n-///         in_pMiscData was passed in as NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pMiscData is non-NULL but\n-///         in_MiscDataLen is zero.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_NumBuffers is non-zero and in_pBuffers\n-///         or in_pBufferAccessFlags are NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pBuffers is non-NULL but\n-///         in_NumBuffers is zero.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pBufferAccessFlags is non-NULL but\n-///         in_NumBuffers is zero.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_ReturnValueLen is non-zero while\n-///         in_pReturnValue was passed in as NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pReturnValue is non-NULL but\n-///         in_ReturnValueLen is zero.\n-///\n-/// @return COI_RETRY if any input buffers are still mapped when\n-///         passed to the run function.\n-///\n-/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process\n-///         associated with the pipeline that was passed in.\n-///\n-/// @return COI_OUT_OF_RANGE if any of the access flags in\n-///         in_pBufferAccessFlags is not a valid COI_ACCESS_FLAGS.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineRunFunction(\n-    COIPIPELINE         in_Pipeline,\n-    COIFUNCTION         in_Function,\n-    uint32_t            in_NumBuffers,\n-    const   COIBUFFER          *in_pBuffers,\n-    const   COI_ACCESS_FLAGS   *in_pBufferAccessFlags,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    const   void               *in_pMiscData,\n-    uint16_t            in_MiscDataLen,\n-    void               *out_pAsyncReturnValue,\n-    uint16_t            in_AsyncReturnValueLen,\n-    COIEVENT           *out_pCompletion);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Retrieve the engine that the pipeline is associated with.\n-///\n-/// @param  in_Pipeline\n-///         [in] Pipeline to query.\n-///\n-/// @param  out_pEngine\n-///         [out] The handle of the Engine.\n-///\n-/// @return COI_SUCCESS if the engine was retrieved.\n-///\n-/// @return COI_INVALID_HANDLE if the pipeline handle passed in was invalid.\n-///\n-/// @return COI_INVALID_POINTER if the out_pEngine parameter is NULL.\n-///\n-/// @return COI_PROCESS_DIED if the process associated with this engine died.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineGetEngine(\n-    COIPIPELINE         in_Pipeline,\n-    COIENGINE          *out_pEngine);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Add a particular core:thread pair to a COI_CPU_MASK.\n-///\n-/// @param  in_Process\n-///         [in] A handle to an already existing process that the pipeline\n-///         will be associated with.\n-///\n-/// @param  in_CoreID\n-///         [in] Core to affinitize to; must be less than the number of cores\n-///         on the device.\n-///\n-/// @param  in_ThreadID\n-///         [in] Thread on the core to affinitize to (0 - 3).\n-///\n-/// @param  out_pMask\n-///         [out] Pointer to the mask to set.\n-///\n-/// @warning Unless it is explicitly done, the contents of the mask may not\n-///          be zero when creating or declaring a COI_CPU_MASK variable.\n-///\n-/// @return COI_SUCCESS if the mask was set.\n-///\n-/// @return COI_OUT_OF_RANGE if the in_CoreID or in_ThreadID is out of range.\n-///\n-/// @return COI_INVALID_POINTER if out_pMask is invalid.\n-///\n-/// @return COI_INVALID_HANDLE if in_Process is invalid.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineSetCPUMask(\n-    COIPROCESS          in_Process,\n-    uint32_t            in_CoreID,\n-    uint8_t             in_ThreadID,\n-    COI_CPU_MASK       *out_pMask);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Clears a given mask. Note that the memory contents of COI_CPU_MASK are not\n-/// guaranteed to be zero when declaring a COI_CPU_MASK variable. Thus, prior\n-/// to setting a specific affinity to in_Mask it is important to call this\n-/// function first.\n-///\n-/// @param  in_Mask\n-///         [in] Pointer to the mask to clear.\n-///\n-/// @return COI_SUCCESS if the mask was cleared.\n-///\n-/// @return COI_INVALID_POINTER if in_Mask is invalid.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIPipelineClearCPUMask(\n-    COI_CPU_MASK       *in_Mask);\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIPIPELINE_SOURCE_H */\n-\n-/*! @} */"}, {"sha": "1248a915fc38501cab7b97e61a18f098b18a6051", "filename": "liboffloadmic/include/coi/source/COIProcess_source.h", "status": "removed", "additions": 0, "deletions": 1235, "changes": 1235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1235 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-#ifndef _COIPROCESS_SOURCE_H\n-#define _COIPROCESS_SOURCE_H\n-\n-/** @ingroup COIProcess\n- *  @addtogroup COIProcessSource\n-@{\n-* @file source/COIProcess_source.h\n-*/\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS\n-\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#endif // DOXYGEN_SHOULD_SKIP_THIS\n-\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// This is a special COIPROCESS handle that can be used to indicate that\n-/// the source process should be used for an operation.\n-///\n-#define COI_PROCESS_SOURCE ((COIPROCESS)-1)\n-\n-#define COI_MAX_FILE_NAME_LENGTH 256\n-\n-///////////////////////////////////////////////////////////////////////////////\n-/// This is a flag for COIProcessCreateFromMemory that indicates the passed in\n-/// memory pointer is a fat binary file and should not have regular validation.\n-///\n-#define COI_FAT_BINARY ((uint64_t)-1)\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Create a remote process on the Sink and start executing its main()\n-/// function.\n-///\n-/// For more details about creating a process see COIProcessCreateFromMemory.\n-///\n-/// @param  in_Engine\n-///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n-///         indicates which device to create the process on. This is\n-///         necessary because there can be more than one device\n-///         within the system.\n-///\n-/// @param  in_pBinaryName\n-///         [in] Pointer to a null-terminated string that contains the\n-///         path to the program binary to be instantiated as a process on\n-///         the sink device. The file name will be accessed via\n-///         fopen and fread, as such, the passed in binary name must\n-///         be locatable via these commands. Also, the file name (without\n-///         directory information) will be used automatically by the system\n-///         to create the argv[0] of the new process.\n-///\n-/// @param  in_Argc\n-///         [in] The number of arguments being passed in to the process in the\n-///         in_ppArgv parameter.\n-///\n-/// @param  in_ppArgv\n-///         [in] An array of strings that represent the arguments being passed\n-///         in. The system will auto-generate argv[0] using in_pBinaryName and\n-///         thus that parameter cannot be passed in using in_ppArgv. Instead,\n-///         in_ppArgv contains the rest of the parameters being passed in.\n-///\n-/// @param  in_DupEnv\n-///         [in] A boolean that indicates whether the process that is being\n-///         created should inherit the environment of the caller.\n-///\n-/// @param  in_ppAdditionalEnv\n-///         [in] An array of strings that represent additional environment\n-///         variables. This parameter must terminate the array with a NULL\n-///         string. For convenience it is also allowed to be NULL if there are\n-///         no additional environment variables that need adding. Note that\n-///         any environment variables specified here will be in addition to\n-///         but override those that were inherited via in_DupEnv.\n-///\n-/// @param  in_ProxyActive\n-///         [in] A boolean that specifies whether the process that is to be\n-///         created wants I/O proxy support. If this flag is enabled, then\n-///         stdout and stderr are forwarded back to the calling process's\n-///         output and error streams.\n-///\n-/// @param  in_Reserved\n-///         Reserved for future use, best set at NULL.\n-///\n-/// @param  in_InitialBufferSpace\n-///         [in] The initial memory (in bytes) that will be pre-allocated at\n-///         process creation for use by buffers associated with this remote\n-///         process. In addition to allocating, Intel(R) Coprocessor Offload\n-///         Infrastructure (Intel(R) COI) will also fault in the\n-///         memory during process creation. If the total size of the buffers\n-///         in use by this process exceed this initial size, memory on the\n-///         sink may continue to be allocated on demand, as needed, subject\n-///         to the system constraints on the sink.\n-///\n-///@param   in_LibrarySearchPath\n-///         [in] a path to locate dynamic libraries dependencies for the sink\n-///         application. If not NULL, this path will override the environment\n-///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-/// @param  out_pProcess\n-///         [out] Handle returned to uniquely identify the process that was\n-///         created for use in later API calls.\n-///\n-/// @return COI_SUCCESS if the remote process was successfully created.\n-///\n-/// @return COI_INVALID_POINTER if in_pBinaryName was NULL.\n-///\n-/// @return COI_INVALID_FILE if in_pBinaryName is not a \"regular file\" as\n-///         determined by stat or if its size is 0.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_pBinaryName cannot be found.\n-///\n-/// @return See COIProcessCreateFromMemory for additional errors.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessCreateFromFile(\n-    COIENGINE           in_Engine,\n-    const   char               *in_pBinaryName,\n-    int                 in_Argc,\n-    const   char              **in_ppArgv,\n-    uint8_t             in_DupEnv,\n-    const   char              **in_ppAdditionalEnv,\n-    uint8_t             in_ProxyActive,\n-    const   char               *in_Reserved,\n-    uint64_t            in_InitialBufferSpace,\n-    const   char               *in_LibrarySearchPath,\n-    COIPROCESS         *out_pProcess);\n-\n-///////////////////////////////////////////////////////////////////////////////\n-///\n-/// Create a remote process on the Sink and start executing its main()\n-/// function. This will also automatically load any dependent shared objects\n-/// on to the device. Once the process is created, remote calls can be\n-/// initiated by using the RunFunction mechanism found in the COIPipeline APIs.\n-///\n-/// If instead of creating a process you only wish to check for dynamic\n-/// library dependencies set the environment variable\n-/// SINK_LD_TRACE_LOADED_OBJECTS to be non empty before making this call.\n-///\n-/// If there are dynamic link libraries on the source file system that need to\n-/// be preloaded when the process is created on the device, callers of this\n-/// API can set the environment variable SINK_LD_PRELOAD to a colon separated\n-/// list of libraries that need to be copied to the sink and preloaded as part\n-/// of process creation.\n-///\n-/// For more information on how dependencies are loaded, see\n-/// COIProcessLoadLibraryFromMemory.\n-///\n-/// @param  in_Engine\n-///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n-///         indicates which device to create the process on. This is\n-///         necessary because there can be more than one device\n-///         within the system.\n-///\n-/// @param  in_pBinaryName\n-///         [in] Pointer to a null-terminated string that contains the name to\n-///         give the process that will be created. Note that the final name\n-///         will strip out any directory information from in_pBinaryName and\n-///         use the file information to generate an argv[0] for the new\n-///         process.\n-///\n-/// @param  in_pBinaryBuffer\n-///         [in] Pointer to a buffer whose contents represent the sink-side\n-///         process that we want to create.\n-///\n-/// @param  in_BinaryBufferLength\n-///         [in] Number of bytes in in_pBinaryBuffer.\n-///\n-/// @param  in_Argc\n-///         [in] The number of arguments being passed in to the process in the\n-///         in_ppArgv parameter.\n-///\n-/// @param  in_ppArgv\n-///         [in] An array of strings that represent the arguments being passed\n-///         in. The system will auto-generate argv[0] using in_pBinaryName and\n-///         thus that parameter cannot be passed in using in_ppArgv. Instead,\n-///         in_ppArgv contains the rest of the parameters being passed in.\n-///\n-/// @param  in_DupEnv\n-///         [in] A boolean that indicates whether the process that is being\n-///         created should inherit the environment of the caller.\n-///\n-/// @param  in_ppAdditionalEnv\n-///         [in] An array of strings that represent additional environment\n-///         variables. This parameter must terminate the array with a NULL\n-///         string. For convenience it is also allowed to be NULL if there are\n-///         no additional environment variables that need adding. Note that\n-///         any environment variables specified here will be in addition to\n-///         but override those that were inherited via in_DupEnv.\n-///\n-/// @param  in_ProxyActive\n-///         [in] A boolean that specifies whether the process that is to be\n-///         created wants I/O proxy support.\n-///\n-/// @param  in_Reserved\n-///         Reserved for future use, best set to NULL.\n-///\n-/// @param  in_InitialBufferSpace\n-///         [in] The initial memory (in bytes) that will be pre-allocated at\n-///         process creation for use by buffers associated with this remote\n-///         process. In addition to allocating, Intel(R) Coprocessor\n-///         Offload Infrastructure (Intel(R) COI) will also fault in the\n-///         memory during process creation. If the total size of the buffers\n-///         in use by this process exceed this initial size, memory on the\n-///         sink may continue to be allocated on demand, as needed, subject\n-///         to the system constraints on the sink.\n-///\n-/// @param  in_LibrarySearchPath\n-///         [in] A path to locate dynamic libraries dependencies for the sink\n-///         application. If not NULL, this path will override the environment\n-///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-/// @param  in_FileOfOrigin\n-///         [in] If not NULL, this parameter indicates the file from which the\n-///         in_pBinaryBuffer was obtained. This parameter is optional.\n-///\n-/// @param  in_FileOfOriginOffset\n-///         [in] If in_FileOfOrigin is not NULL, this parameter indicates the\n-///         offset within that file where in_pBinaryBuffer begins.\n-///\n-/// @param  out_pProcess\n-///         [out] Handle returned to uniquely identify the process that was\n-///         created for use in later API calls.\n-///\n-/// @return COI_SUCCESS if the remote process was successfully created.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Engine handle passed in was invalid.\n-///\n-/// @return COI_INVALID_POINTER if out_pProcess was NULL.\n-///\n-/// @return COI_INVALID_POINTER if in_pBinaryName or in_pBinaryBuffer was NULL.\n-///\n-/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n-///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n-///\n-/// @return COI_BINARY_AND_HARDWARE_MISMATCH if in_pBinaryName or any of its\n-///         recursive dependencies were built for a target machine that does\n-///         not match the engine specified.\n-///\n-/// @return COI_RESOURCE_EXHAUSTED if no more COIProcesses can be created,\n-///         possibly, but not necessarily because in_InitialBufferSpace is too\n-///         large.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_Argc is 0 and in_ppArgv is not NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_Argc is greater than 0 and in_ppArgv is\n-///         NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if in_Argc is less than 0.\n-///\n-/// @return COI_OUT_OF_RANGE if the length of in_pBinaryName is greater than or\n-///         equal to COI_MAX_FILE_NAME_LENGTH.\n-///\n-/// @return COI_OUT_OF_RANGE if in_BinaryBufferLength is 0.\n-///\n-/// @return COI_TIME_OUT_REACHED if establishing the communication channel with\n-///         the remote process timed out.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_FileOfOrigin is not NULL and does not\n-///         exist.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_FileOfOrigin is NULL and\n-///         in_FileOfOriginOffset is not 0.\n-///\n-/// @return COI_INVALID_FILE if in_FileOfOrigin is not a \"regular file\" as\n-///         determined by stat or if its size is 0.\n-///\n-/// @return COI_OUT_OF_RANGE if in_FileOfOrigin exists but its size is\n-///         less than in_FileOfOriginOffset + in_BinaryBufferLength.\n-///\n-/// @return COI_NOT_INITIALIZED if the environment variable\n-///         SINK_LD_TRACE_LOADED_OBJECTS is set to a non empty string and there\n-///         are no errors locating the shared library dependencies.\n-///\n-/// @return COI_PROCESS_DIED if at some point during the loading of the remote\n-///         process the remote process terminated abnormally.\n-///\n-/// @return COI_VERSION_MISMATCH if the version of Intel(R) Coprocessor\n-///         Offload Infrastructure (Intel(R) COI) on the host is not\n-///         compatible with the version on the device.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessCreateFromMemory(\n-    COIENGINE           in_Engine,\n-    const   char               *in_pBinaryName,\n-    const   void               *in_pBinaryBuffer,\n-    uint64_t            in_BinaryBufferLength,\n-    int                 in_Argc,\n-    const   char              **in_ppArgv,\n-    uint8_t             in_DupEnv,\n-    const   char              **in_ppAdditionalEnv,\n-    uint8_t             in_ProxyActive,\n-    const   char               *in_Reserved,\n-    uint64_t            in_InitialBufferSpace,\n-    const   char               *in_LibrarySearchPath,\n-    const   char               *in_FileOfOrigin,\n-    uint64_t            in_FileOfOriginOffset,\n-    COIPROCESS         *out_pProcess);\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Destroys the indicated process, releasing its resources. Note, this\n-/// will destroy any outstanding pipelines created in this process as well.\n-///\n-/// @param  in_Process\n-///         [in] Process to destroy.\n-///\n-/// @param  in_WaitForMainTimeout\n-///         [in] The number of milliseconds to wait for the main() function\n-///         to return in the sink process before timing out. -1 means to wait\n-///         indefinitely.\n-///\n-/// @param  in_ForceDestroy\n-///         [in] If this flag is set to true, then the sink process will be\n-///         forcibly terminated after the timeout has been reached. A timeout\n-///         value of 0 will kill the process immediately, while a timeout of\n-///         -1 is invalid. If the flag is set to false then a message will\n-///         be sent to the sink process requesting a clean shutdown. A value\n-///         of false along with a timeout of 0 does not send a shutdown\n-///         message, instead simply polls the process to see if it is alive.\n-///         In most cases this flag should be set to false. If a sink process\n-///         is not responding then it may be necessary to set this flag to\n-///         true.\n-///\n-/// @param  out_pProcessReturn\n-///         [out] The value returned from the main() function executing in\n-///         the sink process. This is an optional parameter. If the caller\n-///         is not interested in the return value from the remote process\n-///         they may pass in NULL for this parameter. The output value of\n-///         this pointer is only meaningful if COI_SUCCESS is returned.\n-///\n-/// @param  out_pTerminationCode\n-///         [out] This parameter specifies the termination code. This will\n-///         be 0 if the remote process exited cleanly. If the remote process\n-///         exited abnormally this will contain the termination code given\n-///         by the operating system of the remote process. This is an optional\n-///         parameter and the caller may pass in NULL if they are not\n-///         interested in the termination code. The output value of this\n-///         pointer is only meaningful if COI_SUCCESS is returned.\n-///\n-/// @return COI_SUCCESS if the process was destroyed.\n-///\n-/// @return COI_INVALID_HANDLE if the process handle passed in was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE for any negative in_WaitForMainTimeout value\n-///         except -1.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_WaitForMainTimeout is -1 and\n-///         in_ForceDestroy is true.\n-///\n-/// @return COI_TIME_OUT_REACHED if the sink process is still running after\n-///         waiting in_WaitForMainTimeout milliseconds and in_ForceDestroy\n-///         is false. This is true even if in_WaitForMainTimeout was 0.\n-///         In this case, out_pProcessReturn and out_pTerminationCode\n-///         are undefined.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessDestroy(\n-    COIPROCESS              in_Process,\n-    int32_t                 in_WaitForMainTimeout,\n-    uint8_t                 in_ForceDestroy,\n-    int8_t                 *out_pProcessReturn,\n-    uint32_t               *out_pTerminationCode);\n-\n-\n-#define COI_MAX_FUNCTION_NAME_LENGTH 256\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Given a loaded native process, gets an array of function handles that can\n-/// be used to schedule run functions on a pipeline associated with that\n-/// process. See the documentation for COIPipelineRunFunction() for\n-/// additional information. All functions that are to be retrieved in this\n-/// fashion must have the define COINATIVEPROCESSEXPORT preceding their type\n-/// specification. For functions that are written in C++, either the entries\n-/// in in_pFunctionNameArray in must be pre-mangled, or the functions must be\n-/// declared as extern \"C\". It is also necessary to link the binary containing\n-/// the exported functions with the -rdynamic linker flag.\n-/// It is possible for this call to successfully find function handles for\n-/// some of the names passed in but not all of them. If this occurs\n-/// COI_DOES_NOT_EXIST will return and any handles not found will be returned\n-/// as NULL.\n-///\n-/// @param  in_Process\n-///         [in] Process handle previously returned via COIProcessCreate().\n-///\n-/// @param  in_NumFunctions\n-///         [in] Number of function names passed in to the in_pFunctionNames\n-///         array.\n-///\n-/// @param  in_ppFunctionNameArray\n-///         [in] Pointer to an array of null-terminated strings that match\n-///         the name of functions present in the code of the binary\n-///         previously loaded via COIProcessCreate(). Note that if a C++\n-///         function is used, then the string passed in must already be\n-///         properly name-mangled, or extern \"C\" must be used for where\n-///         the function is declared.\n-///\n-/// @param  out_pFunctionHandleArray\n-///         [in out] Pointer to a location created by the caller large\n-///         enough to hold an array of COIFUNCTION sized elements that has\n-///         in_numFunctions entries in the array.\n-///\n-/// @return COI_SUCCESS if all function names indicated were found.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_NumFunctions is zero.\n-///\n-/// @return COI_INVALID_POINTER if the in_ppFunctionNameArray or\n-///         out_pFunctionHandleArray pointers was NULL.\n-///\n-/// @return COI_DOES_NOT_EXIST if one or more function names were not\n-///         found. To determine the function names that were not found,\n-///         check which elements in the out_pFunctionHandleArray\n-///         are set to NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if any of the null-terminated strings passed in\n-///         via in_ppFunctionNameArray were more than\n-///         COI_MAX_FUNCTION_NAME_LENGTH characters in length including\n-///         the null.\n-///\n-/// @warning This operation can take several milliseconds so it is recommended\n-///          that it only be done at load time.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessGetFunctionHandles(\n-    COIPROCESS          in_Process,\n-    uint32_t            in_NumFunctions,\n-    const   char              **in_ppFunctionNameArray,\n-    COIFUNCTION        *out_pFunctionHandleArray);\n-\n-#if COI_LIBRARY_VERSION >= 2\n-/// @name COIProcessLoadLibrary* flags, named after the corresponding\n-/// RTLD flags that are passed into dlopen().\n-/// Please consult a Linux manual for more information about these flags.\n-//@{\n-#define COI_LOADLIBRARY_LOCAL      0x00000\n-#define COI_LOADLIBRARY_GLOBAL     0x00100\n-\n-#define COI_LOADLIBRARY_LAZY       0x00001\n-#define COI_LOADLIBRARY_NOW        0x00002\n-#define COI_LOADLIBRARY_NOLOAD     0x00004\n-#define COI_LOADLIBRARY_DEEPBIND   0x00008\n-#define COI_LOADLIBRARY_NODELETE   0x01000\n-\n-/// Flags to replicate the behaviour of the original version of\n-/// COIProcessLoadLibrary* APIs.\n-#define COI_LOADLIBRARY_V1_FLAGS   (COI_LOADLIBRARY_GLOBAL|COI_LOADLIBRARY_NOW)\n-\n-//@}\n-\n-#endif\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Loads a shared library into the specified remote process, akin to using\n-/// dlopen() on a local process in Linux or LoadLibrary() in Windows.\n-/// Dependencies for this library that are not listed with absolute paths\n-/// are searched for first in current working directory, then in the\n-/// colon-delimited paths in the environment variable SINK_LD_LIBRARY_PATH,\n-/// and finally on the sink in the standard search paths as defined by the\n-/// sink's operating system / dynamic loader.\n-///\n-/// @param  in_Process\n-///         [in] Process to load the library into.\n-///\n-/// @param  in_pLibraryBuffer\n-///         [in] The memory buffer containing the shared library to load.\n-///\n-/// @param  in_LibraryBufferLength\n-///         [in] The number of bytes in the memory buffer in_pLibraryBuffer.\n-///\n-/// @param  in_pLibraryName\n-///         [in] Name for the shared library. This optional parameter can\n-///         be specified in case the dynamic library doesn't have an\n-///         SO_NAME field. If specified, it will take precedence over\n-///         the SO_NAME if it exists. If it is not specified then\n-///         the library must have a valid SO_NAME field.\n-///\n-///@param   in_LibrarySearchPath\n-///         [in] A path to locate dynamic libraries dependencies for the\n-///         library being loaded. If not NULL, this path will override the\n-///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-///@param   in_LibrarySearchPath\n-///         [in] A path to locate dynamic libraries dependencies for the sink\n-///         application. If not NULL, this path will override the environment\n-///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-/// @param  in_FileOfOrigin\n-///         [in] If not NULL, this parameter indicates the file from which the\n-///         in_pBinaryBuffer was obtained. This parameter is optional.\n-///\n-/// @param  in_FileOfOriginOffset\n-///         [in] If in_FileOfOrigin is not NULL, this parameter indicates the\n-///         offset within that file where in_pBinaryBuffer begins.\n-///\n-#if COI_LIBRARY_VERSION >= 2\n-/// @param  in_Flags\n-///         [in] Bitmask of the flags that will be passed in as the dlopen()\n-///         \"flag\" parameter on the sink.\n-///\n-#endif\n-///\n-/// @param  out_pLibrary\n-///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n-///         that uniquely identifies the loaded library.\n-///\n-/// @return COI_SUCCESS if the library was successfully loaded.\n-///\n-/// @return COI_INVALID_HANDLE if the process handle passed in was invalid.\n-///\n-/// @return COI_OUT_OF_RANGE if in_LibraryBufferLength is 0.\n-///\n-/// @return COI_INVALID_FILE if in_pLibraryBuffer does not represent a valid\n-///         shared library file.\n-///\n-/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n-///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if the shared library is missing an SONAME\n-///         and in_pLibraryName is NULL.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_pLibraryName is the same as that of\n-///         any of the dependencies (recursive) of the library being loaded.\n-///\n-/// @return COI_ALREADY_EXISTS if there is an existing COILIBRARY handle\n-///         that identifies this library, and this COILIBRARY hasn't been\n-///         unloaded yet.\n-///\n-/// @return COI_BINARY_AND_HARDWARE_MISMATCH if the target machine of the\n-///         binary or any of its recursive dependencies does not match the\n-///         engine associated with in_Process.\n-///\n-/// @return COI_UNDEFINED_SYMBOL if we are unable to load the library due to\n-///         an undefined symbol.\n-///\n-/// @return COI_PROCESS_DIED if loading the library on the device caused\n-///         the remote process to terminate.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_FileOfOrigin is not NULL and does not\n-///         exist.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_FileOfOrigin is NULL and\n-///         in_FileOfOriginOffset is not 0.\n-///\n-/// @return COI_INVALID_FILE if in_FileOfOrigin is not a \"regular file\" as\n-///         determined by stat or if its size is 0.\n-///\n-/// @return COI_OUT_OF_RANGE if in_FileOfOrigin exists but its size is\n-///         less than in_FileOfOriginOffset + in_BinaryBufferLength.\n-///\n-/// @return COI_INVALID_POINTER if out_pLibrary or in_pLibraryBuffer are NULL.\n-///\n-#if COI_LIBRARY_VERSION >= 2\n-COIACCESSAPI\n-COIRESULT\n-COIProcessLoadLibraryFromMemory(\n-    COIPROCESS          in_Process,\n-    const   void               *in_pLibraryBuffer,\n-    uint64_t            in_LibraryBufferLength,\n-    const   char               *in_pLibraryName,\n-    const   char               *in_LibrarySearchPath,\n-    const   char               *in_FileOfOrigin,\n-    uint64_t            in_FileOfOriginOffset,\n-    uint32_t            in_Flags,\n-    COILIBRARY         *out_pLibrary);\n-__asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n-        \"COIProcessLoadLibraryFromMemory@COI_2.0\");\n-#else\n-\n-COIRESULT\n-COIProcessLoadLibraryFromMemory(\n-    COIPROCESS          in_Process,\n-    const   void               *in_pLibraryBuffer,\n-    uint64_t            in_LibraryBufferLength,\n-    const   char               *in_pLibraryName,\n-    const   char               *in_LibrarySearchPath,\n-    const   char               *in_FileOfOrigin,\n-    uint64_t            in_FileOfOriginOffset,\n-    COILIBRARY         *out_pLibrary);\n-__asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n-        \"COIProcessLoadLibraryFromMemory@COI_1.0\");\n-#endif\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Loads a shared library into the specified remote process, akin to using\n-/// dlopen() on a local process in Linux or LoadLibrary() in Windows.\n-///\n-/// For more details, see COIProcessLoadLibraryFromMemory.\n-///\n-/// @param  in_Process\n-///         [in] Process to load the library into.\n-///\n-/// @param  in_pFileName\n-///         [in] The name of the shared library file on the source's file\n-///         system that is being loaded. If the file name is not an absolute\n-///         path, the file is searched for in the same manner as dependencies.\n-///\n-/// @param  in_pLibraryName\n-///         [in] Name for the shared library. This optional parameter can\n-///         be specified in case the dynamic library doesn't have an\n-///         SO_NAME field. If specified, it will take precedence over\n-///         the SO_NAME if it exists. If it is not specified then\n-///         the library must have a valid SO_NAME field.\n-///\n-///@param   in_LibrarySearchPath\n-///         [in] a path to locate dynamic libraries dependencies for the\n-///         library being loaded. If not NULL, this path will override the\n-///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n-///         SINK_LD_LIBRARY_PATH to locate dependencies.\n-///\n-#if COI_LIBRARY_VERSION >= 2\n-/// @param  in_Flags\n-///         [in] Bitmask of the flags that will be passed in as the dlopen()\n-///         \"flag\" parameter on the sink.\n-///\n-#endif\n-///\n-/// @param  out_pLibrary\n-///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n-///         that uniquely identifies the loaded library.\n-///\n-/// @return COI_SUCCESS if the library was successfully loaded.\n-///\n-/// @return COI_INVALID_POINTER if in_pFileName is NULL.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_pFileName cannot be found.\n-///\n-/// @return COI_INVALID_FILE if the file is not a valid shared library.\n-///\n-/// @return See COIProcessLoadLibraryFromMemory for additional errors.\n-///\n-#if COI_LIBRARY_VERSION >= 2\n-\n-COIACCESSAPI\n-COIRESULT\n-COIProcessLoadLibraryFromFile(\n-    COIPROCESS          in_Process,\n-    const   char               *in_pFileName,\n-    const   char               *in_pLibraryName,\n-    const   char               *in_LibrarySearchPath,\n-    uint32_t            in_Flags,\n-    COILIBRARY         *out_pLibrary);\n-__asm__(\".symver COIProcessLoadLibraryFromFile,\"\n-        \"COIProcessLoadLibraryFromFile@COI_2.0\");\n-#else\n-\n-COIRESULT\n-COIProcessLoadLibraryFromFile(\n-    COIPROCESS          in_Process,\n-    const   char               *in_pFileName,\n-    const   char               *in_pLibraryName,\n-    const   char               *in_LibrarySearchPath,\n-    COILIBRARY         *out_pLibrary);\n-__asm__(\".symver COIProcessLoadLibraryFromFile,\"\n-        \"COIProcessLoadLibraryFromFile@COI_1.0\");\n-#endif\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Unloads a a previously loaded shared library from the specified\n-/// remote process.\n-///\n-/// @param  in_Process\n-///         [in] Process that we are unloading a library from.\n-///\n-/// @param  in_Library\n-///         [in] Library that we want to unload.\n-///\n-/// @return COI_SUCCESS if the library was successfully loaded.\n-///\n-/// @return COI_INVALID_HANDLE if the process or library handle were invalid.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessUnloadLibrary(\n-    COIPROCESS          in_Process,\n-    COILIBRARY          in_Library);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Registers shared libraries that are already in the host process's memory\n-/// to be used during the shared library dependency resolution steps that take\n-/// place during subsequent calls to COIProcessCreate* and\n-/// COIProcessLoadLibrary*. If listed as a dependency, the registered library\n-/// will be used to satisfy the dependency, even if there is another library\n-/// on disk that also satisfies that dependency.\n-///\n-/// Addresses registered must remain valid during subsequent calls to\n-/// COIProcessCreate* and COIProcessLoadLibrary*.\n-///\n-/// If the Sink is Linux, the shared libraries must have a library name\n-/// (DT_SONAME field). On most compilers this means built with -soname.\n-///\n-/// If successful, this API registers all the libraries. Otherwise none\n-/// are registered.\n-///\n-/// @param  in_NumLibraries\n-///         [in] The number of libraries that are being registered.\n-///\n-/// @param  in_ppLibraryArray\n-///         [in] An array of pointers that point to the starting addresses\n-///         of the libraries.\n-///\n-/// @param  in_pLibrarySizeArray\n-///         [in] An array of pointers that point to the number of bytes in\n-///         each of the libraries.\n-///\n-/// @param  in_ppFileOfOriginArray\n-///         [in] An array of strings indicating the file from which the\n-///         library was obtained. This parameter is optional. Elements\n-///         in the array may be set to NULL.\n-///\n-/// @param  in_pFileOfOriginOffSetArray\n-///         [in] If the corresponding entry in in_ppFileOfOriginArray is not\n-///         NULL, this parameter indicates the offsets within those files\n-///         where the corresponding libraries begin.\n-///\n-/// @return COI_SUCCESS if the libraries were registered successfully.\n-///\n-/// @return COI_OUT_OF_RANGE if in_NumLibraries is 0.\n-///\n-/// @return COI_INVALID_POINTER if in_ppLibraryArray or in_pLibrarySizeArray\n-///         are NULL.\n-///\n-/// @return COI_INVALID_POINTER if any of the pointers in in_ppLibraryArray\n-///         are NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if any of the values in in_pLibrarySizeArray is 0.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if either one of in_ppFileOfOriginArray\n-///         and in_pFileOfOriginOffSetArray is NULL and the other is not.\n-///\n-/// @return COI_OUT_OF_RANGE if one of the addresses being registered does not\n-///         represent a valid library.\n-///\n-COIACCESSAPI\n-COIRESULT\n-COIProcessRegisterLibraries(\n-    uint32_t            in_NumLibraries,\n-    const   void              **in_ppLibraryArray,\n-    const   uint64_t           *in_pLibrarySizeArray,\n-    const   char              **in_ppFileOfOriginArray,\n-    const   uint64_t           *in_pFileOfOriginOffSetArray);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// The user can choose to have notifications for these internal events\n-/// so that they can build their own profiling and performance layer on\n-/// top of Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI).\n-///\n-typedef enum COI_NOTIFICATIONS\n-{\n-    /// This event occurs when all explicit and implicit dependencies are\n-    /// satisfied and Intel(R) Coprocessor Offload Infrastructure\n-    /// (Intel(R) COI) schedules the run function to begin execution.\n-    RUN_FUNCTION_READY = 0,\n-\n-    /// This event occurs just before the run function actually starts\n-    /// executing. There may be some latency between the ready and start\n-    /// events if other run functions are already queued and ready to run.\n-    RUN_FUNCTION_START,\n-\n-    /// This event occurs when the run function finishes. This is when the\n-    /// completion event for that run function would be signaled.\n-    RUN_FUNCTION_COMPLETE,\n-\n-    /// This event occurs when all explicit and implicit dependencies are\n-    /// met for the pending buffer operation. Assuming buffer needs to be\n-    /// moved, copied, read, etc... Will not be invoked if no actual memory\n-    /// is moved, copied, read, etc. This means that COIBufferUnmap will\n-    /// never result in a callback as it simply updates the status of the\n-    /// buffer but doesn't initiate any data movement. COIBufferMap,\n-    /// COIBufferSetState, COIBufferWrite, COIBufferRead and COIBufferCopy\n-    /// do initiate data movement and therefore will invoke the callback.\n-    BUFFER_OPERATION_READY,\n-\n-    /// This event occurs when the buffer operation is completed.\n-    BUFFER_OPERATION_COMPLETE,\n-\n-    /// This event occurs when a user event is signaled from the remotely\n-    /// a sink process. Local (source triggered) events do not trigger this.\n-    USER_EVENT_SIGNALED\n-} COI_NOTIFICATIONS;\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// A callback that will be invoked to notify the user of an internal\n-/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// event. Note that the callback is registered per process so any of the\n-/// above notifications that happen on the registered process will receive\n-/// the callback.\n-/// As with any callback mechanism it is up to the user to make sure that\n-/// there are no possible deadlocks due to reentrancy (i.e. the callback being\n-/// invoked in the same context that triggered the notification) and also\n-/// that the callback does not slow down overall processing. If the user\n-/// performs too much work within the callback it could delay further\n-/// processing. The callback will be invoked prior to the signaling of\n-/// the corresponding COIEvent. For example, if a user is waiting\n-/// for a COIEvent associated with a run function completing they will\n-/// receive the callback before the COIEvent is marked as signaled.\n-///\n-///\n-/// @param  in_Type\n-///         [in] The type of internal event that has occurred.\n-///\n-/// @param  in_Process\n-///         [in] The process associated with the operation.\n-///\n-/// @param  in_Event\n-///         [in] The completion event that is associated with the\n-///         operation that is being notified.\n-///\n-/// @param  in_UserData\n-///         [in] Opaque data that was provided when the callback was\n-///         registered. Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-///         simply passes this back to the user so that\n-///         they can interpret it as they choose.\n-///\n-typedef void (*COI_NOTIFICATION_CALLBACK)(\n-    COI_NOTIFICATIONS   in_Type,\n-    COIPROCESS          in_Process,\n-    COIEVENT            in_Event,\n-    const   void               *in_UserData);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Register a callback to be invoked to notify that an internal\n-/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI) event\n-/// has occured on the process that is associated with the callback.\n-/// Note that it is legal to have more than one callback registered with\n-/// a given process but those must all be unique callback pointers.\n-/// Note that setting a UserData value with COINotificationCallbackSetContext\n-/// will override a value set when registering the callback.\n-///\n-/// @param  in_Process\n-///         [in] Process that the callback is associated with. The callback\n-///         will only be invoked to notify an event for this specific process.\n-///\n-/// @param  in_Callback\n-///         [in] Pointer to a user function used to signal a notification.\n-///\n-/// @param  in_UserData\n-///         [in] Opaque data to pass to the callback when it is invoked.\n-///\n-/// @return COI_SUCCESS if the callback was registered successfully.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Process parameter does not identify\n-///         a valid process.\n-///\n-/// @return COI_INVALID_POINTER if the in_Callback parameter is NULL.\n-///\n-/// @return COI_ALREADY_EXISTS if the user attempts to reregister the same\n-///         callback for a process.\n-///\n-COIACCESSAPI\n-COIRESULT COIRegisterNotificationCallback(\n-    COIPROCESS                  in_Process,\n-    COI_NOTIFICATION_CALLBACK   in_Callback,\n-    const   void               *in_UserData);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Unregisters a callback, notifications will no longer be signaled.\n-///\n-/// @param  in_Process\n-///         [in] Process that we are unregistering.\n-///\n-/// @param  in_Callback\n-///         [in] The specific callback to unregister.\n-///\n-/// @return COI_SUCCESS if the callback was unregistered.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Process parameter does not identify\n-///         a valid process.\n-///\n-/// @return COI_INVALID_POINTER if the in_Callback parameter is NULL.\n-///\n-/// @return COI_DOES_NOT_EXIST if in_Callback was not previously registered\n-///         for in_Process.\n-///\n-COIACCESSAPI\n-COIRESULT COIUnregisterNotificationCallback(\n-    COIPROCESS                  in_Process,\n-    COI_NOTIFICATION_CALLBACK   in_Callback);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Set the user data that will be returned in the notification callback.\n-/// This data is sticky and per thread so must be set prior to the\n-/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// operation being invoked. If you wish to set the context to be returned\n-/// for a specific instance of a user event notification then the context\n-/// must be set using this API prior to registering that user event with\n-/// COIEventRegisterUserEvent.\n-/// The value may be set prior to each Intel(R) Coprocessor Offload\n-/// Infrastructure (Intel(R) COI) operation being called to\n-/// effectively have a unique UserData per callback.\n-/// Setting this value overrides any value that was set when the\n-/// callback was registered and will also override any future registrations\n-/// that occur.\n-///\n-/// @param  in_UserData\n-///         [in] Opaque data to pass to the callback when it is invoked.\n-///         Note that this data is set per thread.\n-///\n-COIACCESSAPI\n-void COINotificationCallbackSetContext(\n-    const   void                       *in_UserData);\n-\n-\n-/// @name COIProcessSetCacheSize flags.\n-/// Flags are divided into two categories: _MODE_ and _ACTION_\n-/// only one of each is valid with each call.\n-/// _ACTIONS_ and _MODES_ should be bitwised OR'ed together, i.e. |\n-//@{\n-\n-/// Current set of DEFINED bits for _MODE_, can be used\n-/// to clear or check fields, not useful to pass into APIs. Used internally.\n-#define COI_CACHE_MODE_MASK                 0x00000007\n-\n-/// Flag to indicate to keep the previous mode of operation. By default\n-/// this would be COI_CACHE_MODE_ONDEMAND_SYNC. As of this release\n-/// This is the only mode available. This mode is valid with _ACTION_\n-/// flags.\n-#define COI_CACHE_MODE_NOCHANGE             0x00000001\n-\n-/// Mode of operation that indicates that COI will allocate physical\n-/// cache memory exactly when it is is needed. COIPipeline execution in\n-/// the given process will momentarily block until the allocation request\n-/// is completed. This is and has been the default mode.\n-#define COI_CACHE_MODE_ONDEMAND_SYNC        0x00000002\n-\n-/// Not yet implemented. Future mode that will not stall a COIPipeline\n-/// but prefer eviction/paging if possible as to immediately execute pipeline.\n-/// At the same time, enqueue background requests to allocate extra cache\n-/// so as to provide optimze behavior on subsequent runs.\n-#define COI_CACHE_MODE_ONDEMAND_ASYNC       0x00000004\n-\n-\n-/// Current set of DEFINED bits for _ACTION_ can be used\n-/// to clear fields, but not useful to pass into API's. Used internally.\n-#define COI_CACHE_ACTION_MASK               0x00070000\n-\n-/// No action requested. With this flag specified\n-/// it is recommended to NOT provide a out_pCompletion event,\n-/// as with this flag, modes and values are immediately set.\n-/// This is valid with _MODE_ flags.\n-#define COI_CACHE_ACTION_NONE               0x00010000\n-\n-/// This _ACTION_ flag will immediately attempt to increase the cache\n-/// physical memory size to the current set pool size(s). Used to\n-/// pre-allocate memory on remote processes, so that runfunction will\n-/// enqueue faster. Also may prevent unused buffer eviction from process\n-/// reducing overhead in trade for memory allocation cost.\n-#define COI_CACHE_ACTION_GROW_NOW           0x00020000\n-\n-/// Not yet implemented. Future _ACTION_ that will attempt to find unused\n-/// allocated cache and free it, with the express goal of reducing the\n-/// footprint on the remote process down to the value of the currently set\n-/// pool size(s).\n-#define COI_CACHE_ACTION_FREE_UNUSED        0x00040000\n-\n-//@}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Set the minimum preferred COIProcess cache size. By default these values\n-/// are set to 1GB. With the default size of 1GB, Intel(R) COI will only\n-/// grow the cache with each new buffer up until the set limit is consumed,\n-/// after which, only required to accommodate additional buffers.\n-/// This means that after the cache preference is met, a process will act\n-/// as conservative as possible for memory consumption.\n-/// This API will allow users to adjust memory consumption aggressiveness.\n-///\n-/// Additional performance may be gained if the user sets a value higher than\n-/// default. With high memory consumption user can choose to trade performance\n-/// between memory allocation cost and transfer speeds to and from the\n-/// remote process. A last consideration is that if buffers are used only\n-/// once, it may be best to keep a small cache size, or ensure buffers are\n-/// fully destroyed after their use.\n-///\n-/// Adjusting this value to high may result in out of resource conditions.\n-///\n-/// @param  in_pProcess\n-///         [in] Handle to uniquely identify the process for which the cache\n-///         is to be adjusted.\n-///\n-/// @param  in_HugePagePoolSize\n-///         [in] The suggested size of the remote huge page cache in bytes.\n-///         This value defaults to 1GB. A process will only allocate cache\n-///         memory if the current cache is smaller than this limit, or it is\n-///         absolutely necessary to fulfill a request, but preferring to\n-///         re-use existing memory and paging unused buffers back to the host\n-///         Increasing this value will cause a process to\n-///         aggressively allocate memory on demand up to this value, before\n-///         evicting/paging memory from the remote process back to the host\n-///         process.\n-///\n-///         The net result is that memory consumption is increased, but the\n-///         user can 'cache' more buffers on the remote process. More time\n-///         may be spent during first use of run functions as more memory\n-///         may be allocated, but subsequent run functions will likely\n-///         see an increase in queueing performance as the data is already\n-///         valid in the remote process.\n-///\n-///         Users should tune this value for optimum performance balanced\n-///         against memory consumption. This value does not affect 4K page\n-///         cache. Please use in_SmallPagePoolSize for 4K pages.\n-///\n-/// @param  in_HugeFlags\n-///         [in] Flags to select mode or action for huge page cache. One _MODE_\n-///         and one _ACTION_ flag are specified together. Default _MODE_ is\n-///         COI_CACHE_MODE_ONDEMAND_SYNC. See all COI_CACHE_MODE_* and\n-///         COI_CACHE_ACTION_* for other modes and actions. Default _ACTION_\n-///         is COI_CACHE_ACTION_NONE.\n-///\n-/// @param  in_SmallPagePoolSize\n-///         [in] The suggested size of the remote 4K cache in bytes. Same\n-///         function as in_HugePagePoolSize but affecting only 4K page cache.\n-///         Defaults to 1GB.\n-///\n-/// @param  in_SmallFlags\n-///         [in] Flags to select mode or action for 4K page cache. One _MODE_\n-///         and one _ACTION_ flag are be specified together. Default _MODE_ is\n-///         COI_CACHE_MODE_ONDEMAND_SYNC. See all COI_CACHE_MODE_* and\n-///         COI_CACHE_ACTION_* for other modes and actions.\n-///\n-/// @param  in_NumDependencies\n-///         [in] The number of dependencies specified in the in_pDependencies\n-///         array. This may be 0 if the caller does not want the call to\n-///         wait for any events to be signaled.\n-///\n-/// @param  in_pDependencies\n-///         [in] An optional array of handles to previously created COIEVENT\n-///         objects that this operation will wait for before starting.\n-///         This allows the user to create dependencies between asynchronous\n-///         calls and other operations such as run functions. The user may\n-///         pass in NULL if they do not wish to wait for any dependencies.\n-///         Only useful with _ACTION_ flags, otherwise there is no action\n-///         to wait on. All _MODE_ changes happen immediately.\n-///\n-/// @param  out_pCompletion\n-///         [out] An optional pointer to a COIEVENT object that will be\n-///         signaled when the operation is complete. The user may pass in\n-///         NULL if the user wants the operation to block until completed.\n-///         Note: This flag is not useful unless paired with a\n-///               valid _ACTION_ flag.\n-///\n-/// @return COI_SUCCESS if the cache was successfully adjusted. In case of\n-///         valid flags including _ACTION_, if out_pCompletion was specified,\n-///         this does not indicate the operation succeeded, but rather only\n-///         it was successfully queued. For further information see\n-///         that COIEventWait() for getting return values.\n-///\n-/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n-///\n-/// @return COI_RESOURCE_EXHAUSTED if no more cache can be created,\n-///         possibly, but not necessarily because a pool size was set to large\n-///         and COI_CACHE_ACTION_GROW_NOW was specified.\n-///\n-/// @return COI_NOT_SUPPORTED if more than one _MODE_ or _ACTION_ was\n-///         specified.\n-///\n-/// @return COI_NOT_SUPPORTED if an invalid _MODE_ or _ACTION_ was\n-///         specified.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n-///         in_pDependencies was passed in as NULL.\n-///\n-/// @return COI_OUT_OF_RANGE if one of the pool sizes was invalid.\n-///\n-/// @return COI_PROCESS_DIED if at some point during the mode or action the\n-///         remote process terminated abnormally. Possible due to an out of\n-///         memory condition.\n-///\n-COIACCESSAPI\n-COIRESULT COIProcessSetCacheSize(\n-    const   COIPROCESS          in_Process,\n-    const   uint64_t            in_HugePagePoolSize,\n-    const   uint32_t            in_HugeFlags,\n-    const   uint64_t            in_SmallPagePoolSize,\n-    const   uint32_t            in_SmallFlags,\n-    uint32_t            in_NumDependencies,\n-    const   COIEVENT           *in_pDependencies,\n-    COIEVENT           *out_pCompletion);\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-/// These are the different modes of operation that can be selected for\n-/// the COI_DMA_MODE by the API COIProcessConfigureDMA. They allow the user\n-/// to customize the DMA layer behaviour.\n-///\n-typedef enum COI_DMA_MODE\n-{\n-    /// This mode will use one common logical channel for all DMA operations.\n-    /// Using this mode requires a channel count of one.\n-    COI_DMA_MODE_SINGLE = 0,\n-\n-    /// This mode will dedicate on logical channel for write operations\n-    /// and one logical channel for read operations. Requires a minimum of\n-    /// two logical channels, if more than two are used they are ignored\n-    /// in the current implementation.\n-    COI_DMA_MODE_READ_WRITE,\n-\n-    /// This mode is not yet implemented and is a placeholder for future\n-    /// releases. Check here for updates when it is implemented.\n-    /// Will require a minimum of two logical channels and a maximum\n-    /// of four channels.\n-    COI_DMA_MODE_ROUND_ROBIN,\n-\n-    /// Reserved for internal use.\n-    COI_DMA_RESERVED\n-} COI_DMA_MODE;\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-///\n-/// Set the number and mode of the physical DMA channels that each COIProcess\n-/// will establish during COIProcess creation.\n-///\n-/// By default the runtime will operate in COI_DMA_MODE_SINGLE mode.\n-/// This API is intended to be called before COIProcessCreateFromFile() or\n-/// COIProcessCreateFromMemory(). The values are stored globally and will\n-/// be used by the creation API's. It is possible to call this API once\n-/// before each new COIPROCESS is created and thus have each COIPROCESS\n-/// run in different modes. It is not possible to change the mode on an\n-/// existing COIPROCESS.\n-///\n-/// The larger number of logical connections requested will impose a\n-/// performance penalty on the COIBUFFER creation API's, but unlock better\n-/// parallelism for DMA transfers during runtime.\n-///\n-/// A maximum value of four (4) channels is available today, but current\n-/// implementation will only take advantage of two DMA channels. The option\n-/// is left available for programmers to use in case future implementations\n-/// provide performance advantages.\n-///\n-/// It is important to note that for some operations that enabling this\n-/// options may increase parallelism and require the user to enforce\n-/// explicit dependencies for operations on the same buffers. See documentation\n-/// for COIBufferRead/Write/Copy operations for more details.\n-///\n-/// @param  in_Channels\n-///         [in] Number of logical connections to the remote COIProcess that\n-///         the runtime will establish and use for DMA transfer requests.\n-///         Will be ignored if in_Mode is set to COI_DMA_MODE_SINGLE.\n-///\n-/// @param  in_Mode\n-///         [in] The mode of operation in which the runtime will use the\n-///         logical connections to the remote COIProcess.\n-///\n-/// @return COI_SUCCESS if the mode and number of DMA channels requested\n-///         is valid. The actual create creation of channels and modes is\n-///         done during COIProcessCreateFromFile() and\n-///         COIProcessCreateFromMemory().\n-///\n-/// @return COI_NOT_SUPPORTED if an invalid value for in_Channels or\n-///         in_Mode was requested.\n-///\n-/// @return COI_ARGUMENT_MISMATCH if an invalid combination of in_Channels and\n-///          in_Mode was requested. Example could be 2 channels with\n-///          COI_DMA_MODE_SINGLE, or 1 channel with COI_DMA_MODE_READ_WRITE.\n-///\n-COIACCESSAPI\n-COIRESULT COIProcessConfigureDMA(\n-    const   uint64_t            in_Channels,\n-    const   COI_DMA_MODE        in_Mode);\n-\n-\n-#ifdef __cplusplus\n-} /* extern \"C\" */\n-#endif\n-\n-#endif /* _COIPROCESS_SOURCE_H */\n-\n-/*! @} */"}, {"sha": "3fd12e4d7d676698d2c79c6b0d80e8447f328bec", "filename": "liboffloadmic/liboffloadmic_host.spec.in", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fliboffloadmic_host.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fliboffloadmic_host.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fliboffloadmic_host.spec.in?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,3 +0,0 @@\n-# This spec file is read by gcc when linking.  It is used to specify the\n-# standard libraries we need in order to link with liboffloadmic_host.\n-*link_offloadmic_host: @link_offloadmic_host@"}, {"sha": "d679686684aa785179e075e345dc4e9fc4581c0d", "filename": "liboffloadmic/liboffloadmic_target.spec.in", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fliboffloadmic_target.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fliboffloadmic_target.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fliboffloadmic_target.spec.in?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,3 +0,0 @@\n-# This spec file is read by gcc when linking.  It is used to specify the\n-# standard libraries we need in order to link with liboffloadmic_target.\n-*link_offloadmic_target: @link_offloadmic_target@"}, {"sha": "7caea7894acd9069b4d483a39a8a5d915a34f6b4", "filename": "liboffloadmic/plugin/Makefile.am", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.am?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,125 +0,0 @@\n-# Plugin for offload execution on Intel MIC devices.\n-#\n-# Copyright (C) 2014-2017 Free Software Foundation, Inc.\n-#\n-# Contributed by Ilya Verbin <ilya.verbin@intel.com> and\n-# Andrey Turetskiy <andrey.turetskiy@intel.com>.\n-#\n-# This file is part of the GNU Offloading and Multi Processing Library\n-# (libgomp).\n-#\n-# Libgomp is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-# more details.\n-#\n-# Under Section 7 of GPL version 3, you are granted additional\n-# permissions described in the GCC Runtime Library Exception, version\n-# 3.1, as published by the Free Software Foundation.\n-#\n-# You should have received a copy of the GNU General Public License and\n-# a copy of the GCC Runtime Library Exception along with this program;\n-# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-# <http://www.gnu.org/licenses/>.\n-\n-\n-AUTOMAKE_OPTIONS = foreign\n-ACLOCAL_AMFLAGS = -I ../.. -I ../../config\n-\n-# Directories\n-build_dir = $(top_builddir)\n-source_dir = $(top_srcdir)\n-coi_inc_dir = $(top_srcdir)/../include/coi\n-include_src_dir = $(top_srcdir)/../../include\n-libgomp_src_dir = $(top_srcdir)/../../libgomp\n-libgomp_dir = $(build_dir)/../../libgomp\n-liboffload_src_dir = $(top_srcdir)/../runtime\n-liboffload_dir = $(top_builddir)/..\n-\n-# May be used by toolexeclibdir.\n-gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../../gcc/BASE-VER)\n-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/include\n-# Search for main_target_image.h in these directories\n-target_prefix_dir = $(libdir)/gcc/$(accel_target)/$(gcc_version)$(MULTISUBDIR)\n-target_build_dir = $(accel_search_dir)/$(accel_target)$(MULTISUBDIR)/liboffloadmic/plugin\n-target_install_dir = $(accel_search_dir)/lib/gcc/$(accel_target)/$(gcc_version)$(MULTISUBDIR)\n-\n-if PLUGIN_HOST\n-  toolexeclib_LTLIBRARIES = libgomp-plugin-intelmic.la\n-  libgomp_plugin_intelmic_la_SOURCES = libgomp-plugin-intelmic.cpp\n-  libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n-  libgomp_plugin_intelmic_la_LDFLAGS = -L$(liboffload_dir)/.libs -loffloadmic_host -version-info 1:0:0\n-else # PLUGIN_TARGET\n-  plugin_includedir = $(libsubincludedir)\n-  plugin_include_HEADERS = main_target_image.h\n-  AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n-  AM_CXXFLAGS = $(CXXFLAGS)\n-  AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lgomp -rdynamic\n-endif\n-\n-main_target_image.h: offload_target_main\n-\t@echo -n \"const int image_size = \" > $@\n-\t@stat -c '%s' $< >> $@\n-\t@echo \";\" >> $@\n-\t@echo \"struct MainTargetImage {\" >> $@\n-\t@echo \"  int64_t size;\" >> $@\n-\t@echo \"  char name[sizeof \\\"offload_target_main\\\"];\" >> $@\n-\t@echo \"  uint8_t data[image_size];\" >> $@\n-\t@echo \"};\" >> $@\n-\t@echo \"extern \\\"C\\\" const MainTargetImage main_target_image = {\" >> $@\n-\t@echo \"  image_size, \\\"offload_target_main\\\",\" >> $@\n-\t@cat $< | xxd -include >> $@\n-\t@echo \"};\" >> $@\n-\n-offload_target_main: $(liboffload_dir)/ofldbegin.o offload_target_main.o $(liboffload_dir)/ofldend.o\n-\t$(CXX) $(AM_LDFLAGS) $^ -o $@\n-\n-offload_target_main.o: offload_target_main.cpp\n-\t$(CXX) $(AM_CXXFLAGS) $(AM_CPPFLAGS) -c $< -o $@\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-       \"AR_FLAGS=$(AR_FLAGS)\" \\\n-       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-       \"CFLAGS=$(CFLAGS)\" \\\n-       \"CXXFLAGS=$(CXXFLAGS)\" \\\n-       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-       \"INSTALL=$(INSTALL)\" \\\n-       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-       \"JC1FLAGS=$(JC1FLAGS)\" \\\n-       \"LDFLAGS=$(LDFLAGS)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-       \"MAKE=$(MAKE)\" \\\n-       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-       \"SHELL=$(SHELL)\" \\\n-       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-       \"exec_prefix=$(exec_prefix)\" \\\n-       \"infodir=$(infodir)\" \\\n-       \"libdir=$(libdir)\" \\\n-       \"prefix=$(prefix)\" \\\n-       \"includedir=$(includedir)\" \\\n-       \"AR=$(AR)\" \\\n-       \"AS=$(AS)\" \\\n-       \"LD=$(LD)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"NM=$(NM)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"RANLIB=$(RANLIB)\" \\\n-       \"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES =\n-\n-include $(top_srcdir)/../../multilib.am"}, {"sha": "8d5ad0025c221fb1c10a331d49fe0d823b4442ef", "filename": "liboffloadmic/plugin/Makefile.in", "status": "removed", "additions": 0, "deletions": 840, "changes": 840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.in?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,840 +0,0 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n-\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-# Plugin for offload execution on Intel MIC devices.\n-#\n-# Copyright (C) 2014-2017 Free Software Foundation, Inc.\n-#\n-# Contributed by Ilya Verbin <ilya.verbin@intel.com> and\n-# Andrey Turetskiy <andrey.turetskiy@intel.com>.\n-#\n-# This file is part of the GNU Offloading and Multi Processing Library\n-# (libgomp).\n-#\n-# Libgomp is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-# more details.\n-#\n-# Under Section 7 of GPL version 3, you are granted additional\n-# permissions described in the GCC Runtime Library Exception, version\n-# 3.1, as published by the Free Software Foundation.\n-#\n-# You should have received a copy of the GNU General Public License and\n-# a copy of the GCC Runtime Library Exception along with this program;\n-# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-# <http://www.gnu.org/licenses/>.\n-\n-\n-VPATH = @srcdir@\n-am__is_gnu_make = { \\\n-  if test -z '$(MAKELEVEL)'; then \\\n-    false; \\\n-  elif test -n '$(MAKE_HOST)'; then \\\n-    true; \\\n-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n-    true; \\\n-  else \\\n-    false; \\\n-  fi; \\\n-}\n-am__make_running_with_option = \\\n-  case $${target_option-} in \\\n-      ?) ;; \\\n-      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n-              \"target option '$${target_option-}' specified\" >&2; \\\n-         exit 1;; \\\n-  esac; \\\n-  has_opt=no; \\\n-  sane_makeflags=$$MAKEFLAGS; \\\n-  if $(am__is_gnu_make); then \\\n-    sane_makeflags=$$MFLAGS; \\\n-  else \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        bs=\\\\; \\\n-        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n-          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n-    esac; \\\n-  fi; \\\n-  skip_next=no; \\\n-  strip_trailopt () \\\n-  { \\\n-    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n-  }; \\\n-  for flg in $$sane_makeflags; do \\\n-    test $$skip_next = yes && { skip_next=no; continue; }; \\\n-    case $$flg in \\\n-      *=*|--*) continue;; \\\n-        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n-      -*I?*) strip_trailopt 'I';; \\\n-        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n-      -*O?*) strip_trailopt 'O';; \\\n-        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n-      -*l?*) strip_trailopt 'l';; \\\n-      -[dEDm]) skip_next=yes;; \\\n-      -[JT]) skip_next=yes;; \\\n-    esac; \\\n-    case $$flg in \\\n-      *$$target_option*) has_opt=yes; break;; \\\n-    esac; \\\n-  done; \\\n-  test $$has_opt = yes\n-am__make_dryrun = (target_option=n; $(am__make_running_with_option))\n-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = .\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../../config/acx.m4 \\\n-\t$(top_srcdir)/../../config/depstand.m4 \\\n-\t$(top_srcdir)/../../config/toolexeclibdir.m4 \\\n-\t$(top_srcdir)/../../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../../config/multi.m4 \\\n-\t$(top_srcdir)/../../config/override.m4 \\\n-\t$(top_srcdir)/../../libtool.m4 \\\n-\t$(top_srcdir)/../../ltoptions.m4 \\\n-\t$(top_srcdir)/../../ltsugar.m4 \\\n-\t$(top_srcdir)/../../ltversion.m4 \\\n-\t$(top_srcdir)/../../lt~obsolete.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps) $(am__plugin_include_HEADERS_DIST)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../../mkinstalldirs\n-CONFIG_CLEAN_FILES =\n-CONFIG_CLEAN_VPATH_FILES =\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n-\t\"$(DESTDIR)$(plugin_includedir)\"\n-LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n-libgomp_plugin_intelmic_la_LIBADD =\n-@PLUGIN_HOST_TRUE@am_libgomp_plugin_intelmic_la_OBJECTS = libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo\n-libgomp_plugin_intelmic_la_OBJECTS =  \\\n-\t$(am_libgomp_plugin_intelmic_la_OBJECTS)\n-AM_V_lt = $(am__v_lt_@AM_V@)\n-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\n-am__v_lt_0 = --silent\n-am__v_lt_1 = \n-libgomp_plugin_intelmic_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \\\n-\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) \\\n-\t$(libgomp_plugin_intelmic_la_LDFLAGS) $(LDFLAGS) -o $@\n-@PLUGIN_HOST_TRUE@am_libgomp_plugin_intelmic_la_rpath = -rpath \\\n-@PLUGIN_HOST_TRUE@\t$(toolexeclibdir)\n-AM_V_P = $(am__v_P_@AM_V@)\n-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n-am__v_P_0 = false\n-am__v_P_1 = :\n-AM_V_GEN = $(am__v_GEN_@AM_V@)\n-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\n-am__v_GEN_0 = @echo \"  GEN     \" $@;\n-am__v_GEN_1 = \n-AM_V_at = $(am__v_at_@AM_V@)\n-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\n-am__v_at_0 = @\n-am__v_at_1 = \n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp = $(SHELL) $(top_srcdir)/../../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS)\n-AM_V_CXX = $(am__v_CXX_@AM_V@)\n-am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)\n-am__v_CXX_0 = @echo \"  CXX     \" $@;\n-am__v_CXX_1 = \n-CXXLD = $(CXX)\n-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n-\t$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n-AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)\n-am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)\n-am__v_CXXLD_0 = @echo \"  CXXLD   \" $@;\n-am__v_CXXLD_1 = \n-SOURCES = $(libgomp_plugin_intelmic_la_SOURCES)\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-am__plugin_include_HEADERS_DIST = main_target_image.h\n-HEADERS = $(plugin_include_HEADERS)\n-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n-# Read a list of newline-separated strings from the standard input,\n-# and print each of them once, without duplicates.  Input order is\n-# *not* preserved.\n-am__uniquify_input = $(AWK) '\\\n-  BEGIN { nonempty = 0; } \\\n-  { items[$$0] = 1; nonempty = 1; } \\\n-  END { if (nonempty) { for (i in items) print i; }; } \\\n-'\n-# Make sure the list of sources is unique.  This is necessary because,\n-# e.g., the same source file might be shared among _SOURCES variables\n-# for different programs/libraries.\n-am__define_uniq_tagged_files = \\\n-  list='$(am__tagged_files)'; \\\n-  unique=`for i in $$list; do \\\n-    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-  done | $(am__uniquify_input)`\n-ETAGS = etags\n-CTAGS = ctags\n-CSCOPE = cscope\n-AM_RECURSIVE_TARGETS = cscope\n-ACLOCAL = @ACLOCAL@\n-AMTAR = @AMTAR@\n-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-accel_search_dir = @accel_search_dir@\n-accel_target = @accel_target@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-get_gcc_base_ver = @get_gcc_base_ver@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign\n-ACLOCAL_AMFLAGS = -I ../.. -I ../../config\n-\n-# Directories\n-build_dir = $(top_builddir)\n-source_dir = $(top_srcdir)\n-coi_inc_dir = $(top_srcdir)/../include/coi\n-include_src_dir = $(top_srcdir)/../../include\n-libgomp_src_dir = $(top_srcdir)/../../libgomp\n-libgomp_dir = $(build_dir)/../../libgomp\n-liboffload_src_dir = $(top_srcdir)/../runtime\n-liboffload_dir = $(top_builddir)/..\n-\n-# May be used by toolexeclibdir.\n-gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../../gcc/BASE-VER)\n-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/include\n-# Search for main_target_image.h in these directories\n-target_prefix_dir = $(libdir)/gcc/$(accel_target)/$(gcc_version)$(MULTISUBDIR)\n-target_build_dir = $(accel_search_dir)/$(accel_target)$(MULTISUBDIR)/liboffloadmic/plugin\n-target_install_dir = $(accel_search_dir)/lib/gcc/$(accel_target)/$(gcc_version)$(MULTISUBDIR)\n-@PLUGIN_HOST_TRUE@toolexeclib_LTLIBRARIES = libgomp-plugin-intelmic.la\n-@PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_SOURCES = libgomp-plugin-intelmic.cpp\n-@PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n-@PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_LDFLAGS = -L$(liboffload_dir)/.libs -loffloadmic_host -version-info 1:0:0\n-@PLUGIN_HOST_FALSE@plugin_includedir = $(libsubincludedir)\n-@PLUGIN_HOST_FALSE@plugin_include_HEADERS = main_target_image.h\n-@PLUGIN_HOST_FALSE@AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n-@PLUGIN_HOST_FALSE@AM_CXXFLAGS = $(CXXFLAGS)\n-@PLUGIN_HOST_FALSE@AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lgomp -rdynamic\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-       \"AR_FLAGS=$(AR_FLAGS)\" \\\n-       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-       \"CFLAGS=$(CFLAGS)\" \\\n-       \"CXXFLAGS=$(CXXFLAGS)\" \\\n-       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-       \"INSTALL=$(INSTALL)\" \\\n-       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-       \"JC1FLAGS=$(JC1FLAGS)\" \\\n-       \"LDFLAGS=$(LDFLAGS)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-       \"MAKE=$(MAKE)\" \\\n-       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-       \"SHELL=$(SHELL)\" \\\n-       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-       \"exec_prefix=$(exec_prefix)\" \\\n-       \"infodir=$(infodir)\" \\\n-       \"libdir=$(libdir)\" \\\n-       \"prefix=$(prefix)\" \\\n-       \"includedir=$(includedir)\" \\\n-       \"AR=$(AR)\" \\\n-       \"AS=$(AS)\" \\\n-       \"LD=$(LD)\" \\\n-       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-       \"NM=$(NM)\" \\\n-       \"PICFLAG=$(PICFLAG)\" \\\n-       \"RANLIB=$(RANLIB)\" \\\n-       \"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES = \n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-all: all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .cpp .lo .o .obj\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/../../multilib.am $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-$(top_srcdir)/../../multilib.am $(am__empty):\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tlist2=; for p in $$list; do \\\n-\t  if test -f $$p; then \\\n-\t    list2=\"$$list2 $$p\"; \\\n-\t  else :; fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n-\t}\n-\n-uninstall-toolexeclibLTLIBRARIES:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n-\tdone\n-\n-clean-toolexeclibLTLIBRARIES:\n-\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; \\\n-\tlocs=`for p in $$list; do echo $$p; done | \\\n-\t      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \\\n-\t      sort -u`; \\\n-\ttest -z \"$$locs\" || { \\\n-\t  echo rm -f $${locs}; \\\n-\t  rm -f $${locs}; \\\n-\t}\n-\n-libgomp-plugin-intelmic.la: $(libgomp_plugin_intelmic_la_OBJECTS) $(libgomp_plugin_intelmic_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_intelmic_la_DEPENDENCIES) \n-\t$(AM_V_CXXLD)$(libgomp_plugin_intelmic_la_LINK) $(am_libgomp_plugin_intelmic_la_rpath) $(libgomp_plugin_intelmic_la_OBJECTS) $(libgomp_plugin_intelmic_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.Plo@am__quote@\n-\n-.cpp.o:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n-\n-.cpp.obj:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.cpp.lo:\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<\n-\n-libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo: libgomp-plugin-intelmic.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_intelmic_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo -MD -MP -MF $(DEPDIR)/libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.Tpo -c -o libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo `test -f 'libgomp-plugin-intelmic.cpp' || echo '$(srcdir)/'`libgomp-plugin-intelmic.cpp\n-@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.Tpo $(DEPDIR)/libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='libgomp-plugin-intelmic.cpp' object='libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_intelmic_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libgomp_plugin_intelmic_la-libgomp-plugin-intelmic.lo `test -f 'libgomp-plugin-intelmic.cpp' || echo '$(srcdir)/'`libgomp-plugin-intelmic.cpp\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-install-plugin_includeHEADERS: $(plugin_include_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(plugin_include_HEADERS)'; test -n \"$(plugin_includedir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(plugin_includedir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(plugin_includedir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(plugin_includedir)'\"; \\\n-\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(plugin_includedir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-plugin_includeHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(plugin_include_HEADERS)'; test -n \"$(plugin_includedir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(plugin_includedir)'; $(am__uninstall_files_from_dir)\n-\n-ID: $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); mkid -fID $$unique\n-tags: tags-am\n-TAGS: tags\n-\n-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\tset x; \\\n-\there=`pwd`; \\\n-\t$(am__define_uniq_tagged_files); \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: ctags-am\n-\n-CTAGS: ctags\n-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-cscope: cscope.files\n-\ttest ! -s cscope.files \\\n-\t  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)\n-clean-cscope:\n-\t-rm -f cscope.files\n-cscope.files: clean-cscope cscopelist\n-cscopelist: cscopelist-am\n-\n-cscopelist-am: $(am__tagged_files)\n-\tlist='$(am__tagged_files)'; \\\n-\tcase \"$(srcdir)\" in \\\n-\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n-\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n-\tesac; \\\n-\tfor i in $$list; do \\\n-\t  if test -f \"$$i\"; then \\\n-\t    echo \"$(subdir)/$$i\"; \\\n-\t  else \\\n-\t    echo \"$$sdir/$$i\"; \\\n-\t  fi; \\\n-\tdone >> $(top_builddir)/cscope.files\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\t-rm -f cscope.out cscope.in.out cscope.po.out cscope.files\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(LTLIBRARIES) $(HEADERS) all-local\n-installdirs:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(plugin_includedir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libtool clean-local \\\n-\tclean-toolexeclibLTLIBRARIES mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-local distclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am: install-plugin_includeHEADERS\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am: install-exec-local install-toolexeclibLTLIBRARIES\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic \\\n-\tmaintainer-clean-local\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool mostlyclean-local\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-plugin_includeHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.MAKE: install-am install-strip\n-\n-.PHONY: CTAGS GTAGS TAGS all all-am all-local am--refresh check \\\n-\tcheck-am clean clean-cscope clean-generic clean-libtool \\\n-\tclean-local clean-toolexeclibLTLIBRARIES cscope cscopelist-am \\\n-\tctags ctags-am distclean distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-local distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-exec-local install-html \\\n-\tinstall-html-am install-info install-info-am install-man \\\n-\tinstall-pdf install-pdf-am install-plugin_includeHEADERS \\\n-\tinstall-ps install-ps-am install-strip \\\n-\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmaintainer-clean-local mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool mostlyclean-local pdf \\\n-\tpdf-am ps ps-am tags tags-am uninstall uninstall-am \\\n-\tuninstall-plugin_includeHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.PRECIOUS: Makefile\n-\n-\n-main_target_image.h: offload_target_main\n-\t@echo -n \"const int image_size = \" > $@\n-\t@stat -c '%s' $< >> $@\n-\t@echo \";\" >> $@\n-\t@echo \"struct MainTargetImage {\" >> $@\n-\t@echo \"  int64_t size;\" >> $@\n-\t@echo \"  char name[sizeof \\\"offload_target_main\\\"];\" >> $@\n-\t@echo \"  uint8_t data[image_size];\" >> $@\n-\t@echo \"};\" >> $@\n-\t@echo \"extern \\\"C\\\" const MainTargetImage main_target_image = {\" >> $@\n-\t@echo \"  image_size, \\\"offload_target_main\\\",\" >> $@\n-\t@cat $< | xxd -include >> $@\n-\t@echo \"};\" >> $@\n-\n-offload_target_main: $(liboffload_dir)/ofldbegin.o offload_target_main.o $(liboffload_dir)/ofldend.o\n-\t$(CXX) $(AM_LDFLAGS) $^ -o $@\n-\n-offload_target_main.o: offload_target_main.cpp\n-\t$(CXX) $(AM_CXXFLAGS) $(AM_CPPFLAGS) -c $< -o $@\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-.MAKE .PHONY: all-multi clean-multi distclean-multi install-am \\\n-\t      install-multi maintainer-clean-multi mostlyclean-multi\n-\n-install-exec-local: install-multi\n-\n-all-local: all-multi\n-mostlyclean-local: mostlyclean-multi\n-clean-local: clean-multi\n-distclean-local: distclean-multi\n-maintainer-clean-local: maintainer-clean-multi\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "9fa1d1216c13e3d991f682b7fbde3663ac986446", "filename": "liboffloadmic/plugin/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1180, "changes": 1180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Faclocal.m4?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1180 +0,0 @@\n-# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,\n-[m4_warning([this file was generated for autoconf 2.69.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n-\n-# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.15'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.15.1], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.15.1])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to\n-# '$srcdir', '$srcdir/..', or '$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is '.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\n-# Expand $ac_aux_dir to an absolute path.\n-am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ([2.52])dnl\n- m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"OBJC\", \"OBJCXX\", \"UPC\", or \"GJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-m4_if([$1], [CC],   [depcc=\"$CC\"   am_compiler_list=],\n-      [$1], [CXX],  [depcc=\"$CXX\"  am_compiler_list=],\n-      [$1], [OBJC], [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-      [$1], [OBJCXX], [depcc=\"$OBJCXX\" am_compiler_list='gcc3 gcc'],\n-      [$1], [UPC],  [depcc=\"$UPC\"  am_compiler_list=],\n-      [$1], [GCJ],  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                    [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named 'D' -- because '-MD' means \"put the output\n-  # in D\".\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n-      # Solaris 10 /bin/sh.\n-      echo '/* dummy */' > sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle '-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs.\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # After this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested.\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n-      # This compiler won't grok '-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES.\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE([dependency-tracking], [dnl\n-AS_HELP_STRING(\n-  [--enable-dependency-tracking],\n-  [do not reject slow dependency extractors])\n-AS_HELP_STRING(\n-  [--disable-dependency-tracking],\n-  [speeds up one-time build])])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-AC_SUBST([am__nodep])dnl\n-_AM_SUBST_NOTMAKE([am__nodep])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Older Autoconf quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each '.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.\n-m4_define([AC_PROG_CC],\n-m4_defn([AC_PROG_CC])\n-[_AM_PROG_CC_C_O\n-])\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.65])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[AC_DIAGNOSE([obsolete],\n-             [$0: two- and three-arguments forms are deprecated.])\n-m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(\n-  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),\n-  [ok:ok],,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED([PACKAGE], [\"$PACKAGE\"], [Name of package])\n- AC_DEFINE_UNQUOTED([VERSION], [\"$VERSION\"], [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])\n-AM_MISSING_PROG([AUTOCONF], [autoconf])\n-AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])\n-AM_MISSING_PROG([AUTOHEADER], [autoheader])\n-AM_MISSING_PROG([MAKEINFO], [makeinfo])\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-# For better backward compatibility.  To be removed once Automake 1.9.x\n-# dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n-AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n-# We need awk for the \"check\" target (and possibly the TAP driver).  The\n-# system \"awk\" is bad on some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES([CC])],\n-\t\t  [m4_define([AC_PROG_CC],\n-\t\t\t     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES([CXX])],\n-\t\t  [m4_define([AC_PROG_CXX],\n-\t\t\t     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES([OBJC])],\n-\t\t  [m4_define([AC_PROG_OBJC],\n-\t\t\t     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],\n-\t\t  [_AM_DEPENDENCIES([OBJCXX])],\n-\t\t  [m4_define([AC_PROG_OBJCXX],\n-\t\t\t     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl\n-])\n-AC_REQUIRE([AM_SILENT_RULES])dnl\n-dnl The testsuite driver may need to know about EXEEXT, so add the\n-dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This\n-dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-\n-# POSIX will say in a future version that running \"rm -f\" with no argument\n-# is OK; and we want to be able to make that assumption in our Makefile\n-# recipes.  So use an aggressive probe to check that the usage we want is\n-# actually supported \"in the wild\" to an acceptable degree.\n-# See automake bug#10828.\n-# To make any issue more visible, cause the running configure to be aborted\n-# by default if the 'rm' program in use doesn't match our expectations; the\n-# user can still override this though.\n-if rm -f && rm -fr && rm -rf; then : OK; else\n-  cat >&2 <<'END'\n-Oops!\n-\n-Your 'rm' program seems unable to run without file operands specified\n-on the command line, even when the '-f' option is present.  This is contrary\n-to the behaviour of most rm programs out there, and not conforming with\n-the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>\n-\n-Please tell bug-automake@gnu.org about your system, including the value\n-of your $PATH and any error possibly output before this message.  This\n-can help us improve future automake versions.\n-\n-END\n-  if test x\"$ACCEPT_INFERIOR_RM_PROGRAM\" = x\"yes\"; then\n-    echo 'Configuration will proceed anyway, since you have set the' >&2\n-    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to \"yes\"' >&2\n-    echo >&2\n-  else\n-    cat >&2 <<'END'\n-Aborting the configuration process, to ensure you take notice of the issue.\n-\n-You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n-\n-If you want to complete the configuration process using your problematic\n-'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n-to \"yes\", and re-run configure.\n-\n-END\n-    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])\n-  fi\n-fi\n-dnl The trailing newline in this macro's definition is deliberate, for\n-dnl backward compatibility and to allow trailing 'dnl'-style comments\n-dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.\n-])\n-\n-dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST([install_sh])])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless 'enable' is passed literally.\n-# For symmetry, 'disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n-      am_maintainer_other[ make rules and dependencies not useful\n-      (and sometimes confusing) to the casual installer])],\n-    [USE_MAINTAINER_MODE=$enableval],\n-    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it is modern enough.\n-# If it is, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --is-lightweight\"; then\n-  am_missing_run=\"$MISSING \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN(['missing' script is too old or missing])\n-fi\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), [1])])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_CC_C_O\n-# ---------------\n-# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC\n-# to automatically call this.\n-AC_DEFUN([_AM_PROG_CC_C_O],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([compile])dnl\n-AC_LANG_PUSH([C])dnl\n-AC_CACHE_CHECK(\n-  [whether $CC understands -c and -o together],\n-  [am_cv_prog_cc_c_o],\n-  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])\n-  # Make sure it works both with $CC and with simple cc.\n-  # Following AC_PROG_CC_C_O, we do the test twice because some\n-  # compilers refuse to overwrite an existing .o file with -o,\n-  # though they will create one.\n-  am_cv_prog_cc_c_o=yes\n-  for am_i in 1 2; do\n-    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \\\n-         && test -f conftest2.$ac_objext; then\n-      : OK\n-    else\n-      am_cv_prog_cc_c_o=no\n-      break\n-    fi\n-  done\n-  rm -f core conftest*\n-  unset am_i])\n-if test \"$am_cv_prog_cc_c_o\" != yes; then\n-   # Losing compiler, so override with the script.\n-   # FIXME: It is wrong to rewrite CC.\n-   # But if we don't then we get into trouble of one sort or another.\n-   # A longer-term fix would be to have automake use am__CC in this case,\n-   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n-   CC=\"$am_aux_dir/compile $CC\"\n-fi\n-AC_LANG_POP([C])])\n-\n-# For backward compatibility.\n-AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_RUN_LOG(COMMAND)\n-# -------------------\n-# Run COMMAND, save the exit status in ac_status, and log it.\n-# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)\n-AC_DEFUN([AM_RUN_LOG],\n-[{ echo \"$as_me:$LINENO: $1\" >&AS_MESSAGE_LOG_FD\n-   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD\n-   ac_status=$?\n-   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n-   (exit $ac_status); }])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;\n-esac\n-\n-# Do 'set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   am_has_slept=no\n-   for am_try in 1 2; do\n-     echo \"timestamp, slept: $am_has_slept\" > conftest.file\n-     set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-     if test \"$[*]\" = \"X\"; then\n-\t# -L didn't work.\n-\tset X `ls -t \"$srcdir/configure\" conftest.file`\n-     fi\n-     if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-\t&& test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-\t# If neither matched, then we have a broken ls.  This can happen\n-\t# if, for instance, CONFIG_SHELL is bash and it inherits a\n-\t# broken ls alias from the environment.  This has actually\n-\t# happened.  Such a system could not be considered \"sane\".\n-\tAC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-  alias in your environment])\n-     fi\n-     if test \"$[2]\" = conftest.file || test $am_try -eq 2; then\n-       break\n-     fi\n-     # Just in case.\n-     sleep 1\n-     am_has_slept=yes\n-   done\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT([yes])\n-# If we didn't sleep, we still need to ensure time stamps of config.status and\n-# generated files are strictly newer.\n-am_sleep_pid=\n-if grep 'slept: no' conftest.file >/dev/null 2>&1; then\n-  ( sleep 1 ) &\n-  am_sleep_pid=$!\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-  [AC_MSG_CHECKING([that generated files are newer than configure])\n-   if test -n \"$am_sleep_pid\"; then\n-     # Hide warnings about reused PIDs.\n-     wait $am_sleep_pid 2>/dev/null\n-   fi\n-   AC_MSG_RESULT([done])])\n-rm -f conftest.file\n-])\n-\n-# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SILENT_RULES([DEFAULT])\n-# --------------------------\n-# Enable less verbose build rules; with the default set to DEFAULT\n-# (\"yes\" being less verbose, \"no\" or empty being verbose).\n-AC_DEFUN([AM_SILENT_RULES],\n-[AC_ARG_ENABLE([silent-rules], [dnl\n-AS_HELP_STRING(\n-  [--enable-silent-rules],\n-  [less verbose build output (undo: \"make V=1\")])\n-AS_HELP_STRING(\n-  [--disable-silent-rules],\n-  [verbose build output (undo: \"make V=0\")])dnl\n-])\n-case $enable_silent_rules in @%:@ (((\n-  yes) AM_DEFAULT_VERBOSITY=0;;\n-   no) AM_DEFAULT_VERBOSITY=1;;\n-    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;\n-esac\n-dnl\n-dnl A few 'make' implementations (e.g., NonStop OS and NextStep)\n-dnl do not support nested variable expansions.\n-dnl See automake bug#9928 and bug#10237.\n-am_make=${MAKE-make}\n-AC_CACHE_CHECK([whether $am_make supports nested variables],\n-   [am_cv_make_support_nested_variables],\n-   [if AS_ECHO([['TRUE=$(BAR$(V))\n-BAR0=false\n-BAR1=true\n-V=1\n-am__doit:\n-\t@$(TRUE)\n-.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then\n-  am_cv_make_support_nested_variables=yes\n-else\n-  am_cv_make_support_nested_variables=no\n-fi])\n-if test $am_cv_make_support_nested_variables = yes; then\n-  dnl Using '$V' instead of '$(V)' breaks IRIX make.\n-  AM_V='$(V)'\n-  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\n-else\n-  AM_V=$AM_DEFAULT_VERBOSITY\n-  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\n-fi\n-AC_SUBST([AM_V])dnl\n-AM_SUBST_NOTMAKE([AM_V])dnl\n-AC_SUBST([AM_DEFAULT_V])dnl\n-AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl\n-AC_SUBST([AM_DEFAULT_VERBOSITY])dnl\n-AM_BACKSLASH='\\'\n-AC_SUBST([AM_BACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n-])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor 'install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in \"make install-strip\", and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using 'strip' when the user\n-# run \"make install-strip\".  However 'strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the 'STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of 'v7', 'ustar', or 'pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-#\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-\n-# We'll loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-\n-m4_if([$1], [v7],\n-  [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-\n-  [m4_case([$1],\n-    [ustar],\n-     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.\n-      # There is notably a 21 bits limit for the UID and the GID.  In fact,\n-      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343\n-      # and bug#13588).\n-      am_max_uid=2097151 # 2^21 - 1\n-      am_max_gid=$am_max_uid\n-      # The $UID and $GID variables are not portable, so we need to resort\n-      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls\n-      # below are definitely unexpected, so allow the users to see them\n-      # (that is, avoid stderr redirection).\n-      am_uid=`id -u || echo unknown`\n-      am_gid=`id -g || echo unknown`\n-      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])\n-      if test $am_uid -le $am_max_uid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-         AC_MSG_RESULT([no])\n-         _am_tools=none\n-      fi\n-      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])\n-      if test $am_gid -le $am_max_gid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-        AC_MSG_RESULT([no])\n-        _am_tools=none\n-      fi],\n-\n-  [pax],\n-    [],\n-\n-  [m4_fatal([Unknown tar format])])\n-\n-  AC_MSG_CHECKING([how to create a $1 tar archive])\n-\n-  # Go ahead even if we have the value already cached.  We do so because we\n-  # need to set the values for the 'am__tar' and 'am__untar' variables.\n-  _am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-\n-  for _am_tool in $_am_tools; do\n-    case $_am_tool in\n-    gnutar)\n-      for _am_tar in tar gnutar gtar; do\n-        AM_RUN_LOG([$_am_tar --version]) && break\n-      done\n-      am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-      am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-      am__untar=\"$_am_tar -xf -\"\n-      ;;\n-    plaintar)\n-      # Must skip GNU tar: if it does not support --format= it doesn't create\n-      # ustar tarball either.\n-      (tar --version) >/dev/null 2>&1 && continue\n-      am__tar='tar chf - \"$$tardir\"'\n-      am__tar_='tar chf - \"$tardir\"'\n-      am__untar='tar xf -'\n-      ;;\n-    pax)\n-      am__tar='pax -L -x $1 -w \"$$tardir\"'\n-      am__tar_='pax -L -x $1 -w \"$tardir\"'\n-      am__untar='pax -r'\n-      ;;\n-    cpio)\n-      am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-      am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-      am__untar='cpio -i -H $1 -d'\n-      ;;\n-    none)\n-      am__tar=false\n-      am__tar_=false\n-      am__untar=false\n-      ;;\n-    esac\n-\n-    # If the value was cached, stop now.  We just wanted to have am__tar\n-    # and am__untar set.\n-    test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-    # tar/untar a dummy directory, and stop if the command works.\n-    rm -rf conftest.dir\n-    mkdir conftest.dir\n-    echo GrepMe > conftest.dir/file\n-    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-    rm -rf conftest.dir\n-    if test -s conftest.tar; then\n-      AM_RUN_LOG([$am__untar <conftest.tar])\n-      AM_RUN_LOG([cat conftest.dir/file])\n-      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-    fi\n-  done\n-  rm -rf conftest.dir\n-\n-  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-  AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../../config/acx.m4])\n-m4_include([../../config/depstand.m4])\n-m4_include([../../config/toolexeclibdir.m4])\n-m4_include([../../config/lead-dot.m4])\n-m4_include([../../config/multi.m4])\n-m4_include([../../config/override.m4])\n-m4_include([../../libtool.m4])\n-m4_include([../../ltoptions.m4])\n-m4_include([../../ltsugar.m4])\n-m4_include([../../ltversion.m4])\n-m4_include([../../lt~obsolete.m4])"}, {"sha": "de58b93d2f77efbcadbed077ccd48912847b81f0", "filename": "liboffloadmic/plugin/configure", "status": "removed", "additions": 0, "deletions": 17000, "changes": 17000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Fconfigure?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "cbcd0130d0517e3a69dd9ef457083635a091e22a", "filename": "liboffloadmic/plugin/configure.ac", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Fconfigure.ac?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,147 +0,0 @@\n-# Plugin for offload execution on Intel MIC devices.\n-#\n-# Copyright (C) 2014 Free Software Foundation, Inc.\n-#\n-# Contributed by Andrey Turetskiy <andrey.turetskiy@intel.com>.\n-#\n-# This file is part of the GNU Offloading and Multi Processing Library\n-# (libgomp).\n-#\n-# Libgomp is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-# more details.\n-#\n-# Under Section 7 of GPL version 3, you are granted additional\n-# permissions described in the GCC Runtime Library Exception, version\n-# 3.1, as published by the Free Software Foundation.\n-#\n-# You should have received a copy of the GNU General Public License and\n-# a copy of the GCC Runtime Library Exception along with this program;\n-# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Process this file with autoconf to produce a configure script, like so:\n-# aclocal -I ../.. -I ../../config && autoconf && automake\n-\n-AC_INIT([Intel MIC Offload Plugin], [1.0], ,[libgomp-plugin-intelmic])\n-\n-AC_CONFIG_AUX_DIR(../..)\n-\n-AC_CANONICAL_SYSTEM\n-target_alias=${target_alias-$host_alias}\n-AC_SUBST(target_alias)\n-\n-AM_INIT_AUTOMAKE([1.9.0 foreign no-dist])\n-\n-AM_MAINTAINER_MODE\n-\n-AC_PROG_CC\n-AC_PROG_CXX\n-AC_CONFIG_FILES([Makefile])\n-AM_ENABLE_MULTILIB(, ../..)\n-\n-if test \"${multilib}\" = \"yes\"; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n-# Make sure liboffloadmic is enabled\n-case \"$enable_liboffloadmic\" in\n-  host | target)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([Liboffloadmic is disabled]) ;;\n-esac\n-AM_CONDITIONAL(PLUGIN_HOST, [test x\"$enable_liboffloadmic\" = xhost])\n-\n-# Get accel target and path to build or install tree of accel compiler\n-accel_search_dir=\n-accel_target=\n-if test x\"$enable_liboffloadmic\" = xhost; then\n-  for accel in `echo $enable_offload_targets | sed -e 's#,# #g'`; do\n-    accel_name=`echo $accel | sed 's/=.*//'`\n-    accel_dir=`echo $accel | grep '=' | sed 's/.*=//'`\n-    case \"$accel_name\" in\n-      *-intelmic-* | *-intelmicemul-*)\n-\taccel_target=$accel_name\n-\taccel_search_dir=$accel_dir\n-\t;;\n-    esac\n-  done\n-  if test x\"$accel_target\" = x; then\n-    AC_MSG_ERROR([--enable-offload-targets does not contain intelmic target])\n-  fi\n-fi\n-AC_SUBST(accel_search_dir)\n-AC_SUBST(accel_target)\n-\n-AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n-AC_ARG_ENABLE([version-specific-runtime-libs],\n-  AC_HELP_STRING([--enable-version-specific-runtime-libs],\n-\t\t [Specify that runtime libraries should be installed in a compiler-specific directory]),\n-  [case \"$enableval\" in\n-    yes) enable_version_specific_runtime_libs=yes ;;\n-    no)  enable_version_specific_runtime_libs=no ;;\n-    *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n-   esac],\n-  [enable_version_specific_runtime_libs=no])\n-AC_MSG_RESULT($enable_version_specific_runtime_libs)\n-\n-\n-GCC_WITH_TOOLEXECLIBDIR\n-\n-# Calculate toolexeclibdir.\n-# Also toolexecdir, though it's only used in toolexeclibdir.\n-case ${enable_version_specific_runtime_libs} in\n-  yes)\n-    # Need the gcc compiler version to know where to install libraries\n-    # and header files if --enable-version-specific-runtime-libs option\n-    # is selected.\n-    toolexecdir='$(libdir)/gcc/$(target_alias)'\n-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n-    ;;\n-  no)\n-    if test -n \"$with_cross_host\" &&\n-       test x\"$with_cross_host\" != x\"no\"; then\n-      # Install a library built with a cross compiler in tooldir, not libdir.\n-      toolexecdir='$(exec_prefix)/$(target_alias)'\n-      case ${with_toolexeclibdir} in\n-\tno)\n-\t  toolexeclibdir='$(toolexecdir)/lib'\n-\t  ;;\n-\t*)\n-\t  toolexeclibdir=${with_toolexeclibdir}\n-\t  ;;\n-      esac\n-    else\n-      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n-      toolexeclibdir='$(libdir)'\n-    fi\n-    multi_os_directory=`$CC -print-multi-os-directory`\n-    case $multi_os_directory in\n-      .) ;; # Avoid trailing /.\n-      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n-    esac\n-    ;;\n-esac\n-\n-AC_LIBTOOL_DLOPEN\n-AM_PROG_LIBTOOL\n-# Forbid libtool to hardcode RPATH, because we want to be able to specify\n-# library search directory using LD_LIBRARY_PATH\n-hardcode_into_libs=no\n-AC_SUBST(toolexecdir)\n-AC_SUBST(toolexeclibdir)\n-\n-# Determine what GCC version number to use in filesystem paths.\n-GCC_BASE_VER\n-\n-# Must be last\n-AC_OUTPUT"}, {"sha": "7be27f0459db06a37c93427eec820f9f866c0671", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,545 +0,0 @@\n-/* Plugin for offload execution on Intel MIC devices.\n-\n-   Copyright (C) 2014-2016 Free Software Foundation, Inc.\n-\n-   Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n-\n-   This file is part of the GNU Offloading and Multi Processing Library\n-   (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Host side part of a libgomp plugin.  */\n-\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <utility>\n-#include <vector>\n-#include <map>\n-#include \"libgomp-plugin.h\"\n-#include \"compiler_if_host.h\"\n-#include \"main_target_image.h\"\n-#include \"gomp-constants.h\"\n-\n-#define OFFLOAD_ACTIVE_WAIT_ENV\t\"OFFLOAD_ACTIVE_WAIT\"\n-\n-#ifdef DEBUG\n-#define TRACE(...)\t\t\t\t\t    \\\n-{\t\t\t\t\t\t\t    \\\n-fprintf (stderr, \"HOST:\\t%s:%s \", __FILE__, __FUNCTION__);  \\\n-fprintf (stderr, __VA_ARGS__);\t\t\t\t    \\\n-fprintf (stderr, \"\\n\");\t\t\t\t\t    \\\n-}\n-#else\n-#define TRACE { }\n-#endif\n-\n-\n-/* Start/end addresses of functions and global variables on a device.  */\n-typedef std::vector<addr_pair> AddrVect;\n-\n-/* Addresses for one image and all devices.  */\n-typedef std::vector<AddrVect> DevAddrVect;\n-\n-/* Addresses for all images and all devices.  */\n-typedef std::map<const void *, DevAddrVect> ImgDevAddrMap;\n-\n-/* Image descriptor needed by __offload_[un]register_image.  */\n-struct TargetImageDesc {\n-  int64_t size;\n-  /* 10 characters is enough for max int value.  */\n-  char name[sizeof (\"lib0000000000.so\")];\n-  char data[];\n-};\n-\n-/* Image descriptors, indexed by a pointer obtained from libgomp.  */\n-typedef std::map<const void *, TargetImageDesc *> ImgDescMap;\n-\n-\n-/* Total number of available devices.  */\n-static int num_devices;\n-\n-/* Total number of shared libraries with offloading to Intel MIC.  */\n-static int num_images;\n-\n-/* Two dimensional array: one key is a pointer to image,\n-   second key is number of device.  Contains a vector of pointer pairs.  */\n-static ImgDevAddrMap *address_table;\n-\n-/* Descriptors of all images, registered in liboffloadmic.  */\n-static ImgDescMap *image_descriptors;\n-\n-/* Thread-safe registration of the main image.  */\n-static pthread_once_t main_image_is_registered = PTHREAD_ONCE_INIT;\n-\n-static VarDesc vd_host2tgt = {\n-  { 1, 1 },\t\t      /* dst, src\t\t\t      */\n-  { 1, 0 },\t\t      /* in, out\t\t\t      */\n-  1,\t\t\t      /* alloc_if\t\t\t      */\n-  1,\t\t\t      /* free_if\t\t\t      */\n-  4,\t\t\t      /* align\t\t\t\t      */\n-  0,\t\t\t      /* mic_offset\t\t\t      */\n-  { 0, 0, 0, 0, 0, 0, 0, 0 }, /* is_static, is_static_dstn, has_length,\n-\t\t\t\t is_stack_buf, sink_addr, alloc_disp,\n-\t\t\t\t is_noncont_src, is_noncont_dst\t      */\n-  0,\t\t\t      /* offset\t\t\t\t      */\n-  0,\t\t\t      /* size\t\t\t\t      */\n-  1,\t\t\t      /* count\t\t\t\t      */\n-  0,\t\t\t      /* alloc\t\t\t\t      */\n-  0,\t\t\t      /* into\t\t\t\t      */\n-  0\t\t\t      /* ptr\t\t\t\t      */\n-};\n-\n-static VarDesc vd_tgt2host = {\n-  { 1, 1 },\t\t      /* dst, src\t\t\t      */\n-  { 0, 1 },\t\t      /* in, out\t\t\t      */\n-  1,\t\t\t      /* alloc_if\t\t\t      */\n-  1,\t\t\t      /* free_if\t\t\t      */\n-  4,\t\t\t      /* align\t\t\t\t      */\n-  0,\t\t\t      /* mic_offset\t\t\t      */\n-  { 0, 0, 0, 0, 0, 0, 0, 0 }, /* is_static, is_static_dstn, has_length,\n-\t\t\t\t is_stack_buf, sink_addr, alloc_disp,\n-\t\t\t\t is_noncont_src, is_noncont_dst\t      */\n-  0,\t\t\t      /* offset\t\t\t\t      */\n-  0,\t\t\t      /* size\t\t\t\t      */\n-  1,\t\t\t      /* count\t\t\t\t      */\n-  0,\t\t\t      /* alloc\t\t\t\t      */\n-  0,\t\t\t      /* into\t\t\t\t      */\n-  0\t\t\t      /* ptr\t\t\t\t      */\n-};\n-\n-\n-__attribute__((constructor))\n-static void\n-init (void)\n-{\n-  const char *active_wait = getenv (OFFLOAD_ACTIVE_WAIT_ENV);\n-\n-  /* Disable active wait by default to avoid useless CPU usage.  */\n-  if (!active_wait)\n-    setenv (OFFLOAD_ACTIVE_WAIT_ENV, \"0\", 0);\n-\n-  address_table = new ImgDevAddrMap;\n-  image_descriptors = new ImgDescMap;\n-  num_devices = _Offload_number_of_devices ();\n-}\n-\n-extern \"C\" const char *\n-GOMP_OFFLOAD_get_name (void)\n-{\n-  const char *res = \"intelmic\";\n-  TRACE (\"(): return %s\", res);\n-  return res;\n-}\n-\n-extern \"C\" unsigned int\n-GOMP_OFFLOAD_get_caps (void)\n-{\n-  unsigned int res = GOMP_OFFLOAD_CAP_OPENMP_400;\n-  TRACE (\"(): return %x\", res);\n-  return res;\n-}\n-\n-extern \"C\" int\n-GOMP_OFFLOAD_get_type (void)\n-{\n-  enum offload_target_type res = OFFLOAD_TARGET_TYPE_INTEL_MIC;\n-  TRACE (\"(): return %d\", res);\n-  return res;\n-}\n-\n-extern \"C\" int\n-GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n-{\n-  /* Return -1 if no omp_requires_mask cannot be fulfilled but\n-     devices were present.  */\n-  if (num_devices > 0 && omp_requires_mask != 0)\n-    return -1;\n-  TRACE (\"(): return %d\", num_devices);\n-  return num_devices;\n-}\n-\n-static bool\n-offload (const char *file, uint64_t line, int device, const char *name,\n-\t int num_vars, VarDesc *vars, const void **async_data)\n-{\n-  OFFLOAD ofld = __offload_target_acquire1 (&device, file, line);\n-  if (ofld)\n-    {\n-      if (async_data == NULL)\n-\treturn __offload_offload1 (ofld, name, 0, num_vars, vars, NULL, 0,\n-\t\t\t\t   NULL, NULL);\n-      else\n-\t{\n-\t  OffloadFlags flags;\n-\t  flags.flags = 0;\n-\t  flags.bits.omp_async = 1;\n-\t  return __offload_offload3 (ofld, name, 0, num_vars, vars, NULL, 0,\n-\t\t\t\t     NULL, async_data, 0, NULL, flags, NULL);\n-\t}\n-    }\n-  else\n-    {\n-      GOMP_PLUGIN_error (\"%s:%d: Offload target acquire failed\\n\", file, line);\n-      return false;\n-    }\n-}\n-\n-static void\n-register_main_image ()\n-{\n-  /* Do not check the return value, because old versions of liboffloadmic did\n-     not have return values.  */\n-  __offload_register_image (&main_target_image);\n-\n-  /* liboffloadmic will call GOMP_PLUGIN_target_task_completion when\n-     asynchronous task on target is completed.  */\n-  __offload_register_task_callback (GOMP_PLUGIN_target_task_completion);\n-}\n-\n-/* liboffloadmic loads and runs offload_target_main on all available devices\n-   during a first call to offload ().  */\n-extern \"C\" bool\n-GOMP_OFFLOAD_init_device (int device)\n-{\n-  TRACE (\"(device = %d)\", device);\n-  pthread_once (&main_image_is_registered, register_main_image);\n-  return offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0,\n-\t\t  NULL, NULL);\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_fini_device (int device)\n-{\n-  TRACE (\"(device = %d)\", device);\n-\n-  /* liboffloadmic will finalize target processes on all available devices.  */\n-  __offload_unregister_image (&main_target_image);\n-  return true;\n-}\n-\n-static bool\n-get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n-{\n-  VarDesc vd1[2] = { vd_tgt2host, vd_tgt2host };\n-  vd1[0].ptr = &num_funcs;\n-  vd1[0].size = sizeof (num_funcs);\n-  vd1[1].ptr = &num_vars;\n-  vd1[1].size = sizeof (num_vars);\n-\n-  if (!offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2,\n-\t\tvd1, NULL))\n-    return false;\n-\n-  int table_size = num_funcs + 2 * num_vars;\n-  if (table_size > 0)\n-    {\n-      table = new void * [table_size];\n-\n-      VarDesc vd2;\n-      vd2 = vd_tgt2host;\n-      vd2.ptr = table;\n-      vd2.size = table_size * sizeof (void *);\n-\n-      return offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\",\n-\t\t      1, &vd2, NULL);\n-    }\n-  return true;\n-}\n-\n-/* Offload TARGET_IMAGE to all available devices and fill address_table with\n-   corresponding target addresses.  */\n-\n-static bool\n-offload_image (const void *target_image)\n-{\n-  void *image_start = ((void **) target_image)[0];\n-  void *image_end   = ((void **) target_image)[1];\n-\n-  TRACE (\"(target_image = %p { %p, %p })\",\n-\t target_image, image_start, image_end);\n-\n-  int64_t image_size = (uintptr_t) image_end - (uintptr_t) image_start;\n-  TargetImageDesc *image = (TargetImageDesc *) malloc (offsetof (TargetImageDesc, data)\n-\t\t\t\t\t\t       + image_size);\n-  if (!image)\n-    {\n-      GOMP_PLUGIN_error (\"%s: Can't allocate memory\\n\", __FILE__);\n-      return false;\n-    }\n-\n-  image->size = image_size;\n-  sprintf (image->name, \"lib%010d.so\", num_images++);\n-  memcpy (image->data, image_start, image->size);\n-\n-  TRACE (\"() __offload_register_image %s { %p, %d }\",\n-\t image->name, image_start, image->size);\n-  /* Do not check the return value, because old versions of liboffloadmic did\n-     not have return values.  */\n-  __offload_register_image (image);\n-\n-  /* Receive tables for target_image from all devices.  */\n-  DevAddrVect dev_table;\n-  bool ret = true;\n-  for (int dev = 0; dev < num_devices; dev++)\n-    {\n-      int num_funcs = 0;\n-      int num_vars = 0;\n-      void **table = NULL;\n-\n-      ret &= get_target_table (dev, num_funcs, num_vars, table);\n-\n-      AddrVect curr_dev_table;\n-\n-      for (int i = 0; i < num_funcs; i++)\n-\t{\n-\t  addr_pair tgt_addr;\n-\t  tgt_addr.start = (uintptr_t) table[i];\n-\t  tgt_addr.end = tgt_addr.start + 1;\n-\t  TRACE (\"() func %d:\\t0x%llx..0x%llx\", i,\n-\t\t tgt_addr.start, tgt_addr.end);\n-\t  curr_dev_table.push_back (tgt_addr);\n-\t}\n-\n-      for (int i = 0; i < num_vars; i++)\n-\t{\n-\t  addr_pair tgt_addr;\n-\t  tgt_addr.start = (uintptr_t) table[num_funcs+i*2];\n-\t  tgt_addr.end = tgt_addr.start + (uintptr_t) table[num_funcs+i*2+1];\n-\t  TRACE (\"() var %d:\\t0x%llx..0x%llx\", i, tgt_addr.start, tgt_addr.end);\n-\t  curr_dev_table.push_back (tgt_addr);\n-\t}\n-\n-      dev_table.push_back (curr_dev_table);\n-      delete [] table;\n-    }\n-\n-  address_table->insert (std::make_pair (target_image, dev_table));\n-  image_descriptors->insert (std::make_pair (target_image, image));\n-  return ret;\n-}\n-\n-/* Return the libgomp version number we're compatible with.  There is\n-   no requirement for cross-version compatibility.  */\n-\n-extern \"C\" unsigned\n-GOMP_OFFLOAD_version (void)\n-{\n-  return GOMP_VERSION;\n-}\n-\n-extern \"C\" int\n-GOMP_OFFLOAD_load_image (int device, const unsigned version,\n-\t\t\t const void *target_image, addr_pair **result,\n-\t\t\t uint64_t ** /* rev_fn_table */)\n-{\n-  TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n-\n-  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n-    {\n-      GOMP_PLUGIN_error (\"Offload data incompatible with intelmic plugin\"\n-\t\t\t \" (expected %u, received %u)\",\n-\t\t\t GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n-      return -1;\n-    }\n-\n-  /* If target_image is already present in address_table, then there is no need\n-     to offload it.  */\n-  if (address_table->count (target_image) == 0)\n-    {\n-      /* If fail, return -1 as error code.  */\n-      if (!offload_image (target_image))\n-\treturn -1;\n-    }\n-\n-  AddrVect *curr_dev_table = &(*address_table)[target_image][device];\n-  int table_size = curr_dev_table->size ();\n-  addr_pair *table = (addr_pair *) malloc (table_size * sizeof (addr_pair));\n-  if (table == NULL)\n-    {\n-      GOMP_PLUGIN_error (\"%s: Can't allocate memory\\n\", __FILE__);\n-      return -1;\n-    }\n-\n-  std::copy (curr_dev_table->begin (), curr_dev_table->end (), table);\n-  *result = table;\n-  return table_size;\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_unload_image (int device, unsigned version,\n-\t\t\t   const void *target_image)\n-{\n-  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n-    {\n-      GOMP_PLUGIN_error (\"Offload data incompatible with intelmic plugin\"\n-\t\t\t \" (expected %u, received %u)\",\n-\t\t\t GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n-      return false;\n-    }\n-\n-  TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n-\n-  /* liboffloadmic unloads the image from all available devices.  */\n-  if (image_descriptors->count (target_image) > 0)\n-    {\n-      TargetImageDesc *image_desc = (*image_descriptors)[target_image];\n-      __offload_unregister_image (image_desc);\n-      free (image_desc);\n-\n-      address_table->erase (target_image);\n-      image_descriptors->erase (target_image);\n-    }\n-  return true;\n-}\n-\n-extern \"C\" void *\n-GOMP_OFFLOAD_alloc (int device, size_t size)\n-{\n-  TRACE (\"(device = %d, size = %d)\", device, size);\n-\n-  void *tgt_ptr;\n-  VarDesc vd[2] = { vd_host2tgt, vd_tgt2host };\n-  vd[0].ptr = &size;\n-  vd[0].size = sizeof (size);\n-  vd[1].ptr = &tgt_ptr;\n-  vd[1].size = sizeof (void *);\n-\n-  if (!offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2,\n-\t\tvd, NULL))\n-    return NULL;\n-\n-  return tgt_ptr;\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_free (int device, void *tgt_ptr)\n-{\n-  TRACE (\"(device = %d, tgt_ptr = %p)\", device, tgt_ptr);\n-\n-  VarDesc vd = vd_host2tgt;\n-  vd.ptr = &tgt_ptr;\n-  vd.size = sizeof (void *);\n-\n-  return offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1,\n-\t\t  &vd, NULL);\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_host2dev (int device, void *tgt_ptr, const void *host_ptr,\n-\t\t       size_t size)\n-{\n-  TRACE (\"(device = %d, tgt_ptr = %p, host_ptr = %p, size = %d)\",\n-\t device, tgt_ptr, host_ptr, size);\n-  if (!size)\n-    return true;\n-\n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &tgt_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &size;\n-  vd1[1].size = sizeof (size);\n-\n-  if (!offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2,\n-\t\tvd1, NULL))\n-    return false;\n-\n-  VarDesc vd2 = vd_host2tgt;\n-  vd2.ptr = (void *) host_ptr;\n-  vd2.size = size;\n-\n-  return offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1,\n-\t\t  &vd2, NULL);\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_dev2host (int device, void *host_ptr, const void *tgt_ptr,\n-\t\t       size_t size)\n-{\n-  TRACE (\"(device = %d, host_ptr = %p, tgt_ptr = %p, size = %d)\",\n-\t device, host_ptr, tgt_ptr, size);\n-  if (!size)\n-    return true;\n-\n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &tgt_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &size;\n-  vd1[1].size = sizeof (size);\n-\n-  if (!offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2,\n-\t\tvd1, NULL))\n-    return false;\n-\n-  VarDesc vd2 = vd_tgt2host;\n-  vd2.ptr = (void *) host_ptr;\n-  vd2.size = size;\n-\n-  return offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1,\n-\t\t  &vd2, NULL);\n-}\n-\n-extern \"C\" bool\n-GOMP_OFFLOAD_dev2dev (int device, void *dst_ptr, const void *src_ptr,\n-\t\t      size_t size)\n-{\n-  TRACE (\"(device = %d, dst_ptr = %p, src_ptr = %p, size = %d)\",\n-\t device, dst_ptr, src_ptr, size);\n-  if (!size)\n-    return true;\n-\n-  VarDesc vd[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &dst_ptr;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &src_ptr;\n-  vd[1].size = sizeof (void *);\n-  vd[2].ptr = &size;\n-  vd[2].size = sizeof (size);\n-\n-  return offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3,\n-\t\t  vd, NULL);\n-}\n-\n-extern \"C\" void\n-GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n-\t\t\tvoid **, void *async_data)\n-{\n-  TRACE (\"(device = %d, tgt_fn = %p, tgt_vars = %p, async_data = %p)\", device,\n-\t tgt_fn, tgt_vars, async_data);\n-\n-  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &tgt_fn;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &tgt_vars;\n-  vd[1].size = sizeof (void *);\n-\n-  offload (__FILE__, __LINE__, device, \"__offload_target_run\", 2, vd,\n-\t   (const void **) async_data);\n-}\n-\n-extern \"C\" void\n-GOMP_OFFLOAD_run (int device, void *tgt_fn, void *tgt_vars, void **)\n-{\n-  TRACE (\"(device = %d, tgt_fn = %p, tgt_vars = %p)\", device, tgt_fn, tgt_vars);\n-\n-  GOMP_OFFLOAD_async_run (device, tgt_fn, tgt_vars, NULL, NULL);\n-}"}, {"sha": "ccf7240e2864a5a8834f05752f175500fdf3a2db", "filename": "liboffloadmic/plugin/offload_target_main.cpp", "status": "removed", "additions": 0, "deletions": 380, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Foffload_target_main.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,380 +0,0 @@\n-/* Plugin for offload execution on Intel MIC devices.\n-\n-   Copyright (C) 2014-2016 Free Software Foundation, Inc.\n-\n-   Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n-\n-   This file is part of the GNU Offloading and Multi Processing Library\n-   (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Target side part of a libgomp plugin.  */\n-\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"compiler_if_target.h\"\n-\n-\n-#ifdef DEBUG\n-#define TRACE(...)\t\t\t\t\t      \\\n-{\t\t\t\t\t\t\t      \\\n-fprintf (stderr, \"TARGET:\\t%s:%s \", __FILE__, __FUNCTION__);  \\\n-fprintf (stderr, __VA_ARGS__);\t\t\t\t      \\\n-fprintf (stderr, \"\\n\");\t\t\t\t\t      \\\n-}\n-#else\n-#define TRACE { }\n-#endif\n-\n-\n-static VarDesc vd_host2tgt = {\n-  { 1, 1 },\t\t      /* dst, src\t\t\t      */\n-  { 1, 0 },\t\t      /* in, out\t\t\t      */\n-  1,\t\t\t      /* alloc_if\t\t\t      */\n-  1,\t\t\t      /* free_if\t\t\t      */\n-  4,\t\t\t      /* align\t\t\t\t      */\n-  0,\t\t\t      /* mic_offset\t\t\t      */\n-  { 0, 0, 0, 0, 0, 0, 0, 0 }, /* is_static, is_static_dstn, has_length,\n-\t\t\t\t is_stack_buf, sink_addr, alloc_disp,\n-\t\t\t\t is_noncont_src, is_noncont_dst\t      */\n-  0,\t\t\t      /* offset\t\t\t\t      */\n-  0,\t\t\t      /* size\t\t\t\t      */\n-  1,\t\t\t      /* count\t\t\t\t      */\n-  0,\t\t\t      /* alloc\t\t\t\t      */\n-  0,\t\t\t      /* into\t\t\t\t      */\n-  0\t\t\t      /* ptr\t\t\t\t      */\n-};\n-\n-static VarDesc vd_tgt2host = {\n-  { 1, 1 },\t\t      /* dst, src\t\t\t      */\n-  { 0, 1 },\t\t      /* in, out\t\t\t      */\n-  1,\t\t\t      /* alloc_if\t\t\t      */\n-  1,\t\t\t      /* free_if\t\t\t      */\n-  4,\t\t\t      /* align\t\t\t\t      */\n-  0,\t\t\t      /* mic_offset\t\t\t      */\n-  { 0, 0, 0, 0, 0, 0, 0, 0 }, /* is_static, is_static_dstn, has_length,\n-\t\t\t\t is_stack_buf, sink_addr, alloc_disp,\n-\t\t\t\t is_noncont_src, is_noncont_dst\t      */\n-  0,\t\t\t      /* offset\t\t\t\t      */\n-  0,\t\t\t      /* size\t\t\t\t      */\n-  1,\t\t\t      /* count\t\t\t\t      */\n-  0,\t\t\t      /* alloc\t\t\t\t      */\n-  0,\t\t\t      /* into\t\t\t\t      */\n-  0\t\t\t      /* ptr\t\t\t\t      */\n-};\n-\n-/* Pointer to the descriptor of the last loaded shared library.  */\n-static void *last_loaded_library = NULL;\n-\n-/* Pointer and size of the variable, used in __offload_target_host2tgt_p[12]\n-   and __offload_target_tgt2host_p[12].  */\n-static void *last_var_ptr = NULL;\n-static int last_var_size = 0;\n-\n-\n-/* Override the corresponding functions from libgomp.  */\n-extern \"C\" int\n-omp_is_initial_device (void) __GOMP_NOTHROW\n-{\n-  return 0;\n-}\n-\n-extern \"C\" int32_t\n-omp_is_initial_device_ (void)\n-{\n-  return omp_is_initial_device ();\n-}\n-\n-\n-/* Dummy function needed for the initialization of target process during the\n-   first call to __offload_offload1.  */\n-static void\n-__offload_target_init_proc (OFFLOAD ofldt)\n-{\n-  TRACE (\"\");\n-}\n-\n-/* Collect addresses of the offload functions and of the global variables from\n-   the library descriptor and send them to host.\n-   Part 1: Send num_funcs and num_vars to host.  */\n-static void\n-__offload_target_table_p1 (OFFLOAD ofldt)\n-{\n-  void ***lib_descr = (void ***) last_loaded_library;\n-\n-  if (lib_descr == NULL)\n-    {\n-      TRACE (\"\");\n-      fprintf (stderr, \"Error! No shared libraries loaded on target.\\n\");\n-      return;\n-    }\n-\n-  void **func_table_begin = lib_descr[0];\n-  void **func_table_end   = lib_descr[1];\n-  void **var_table_begin  = lib_descr[2];\n-  void **var_table_end    = lib_descr[3];\n-\n-  /* The func table contains only addresses, the var table contains addresses\n-     and corresponding sizes.  */\n-  int num_funcs = func_table_end - func_table_begin;\n-  int num_vars = (var_table_end - var_table_begin) / 2;\n-  TRACE (\"(num_funcs = %d, num_vars = %d)\", num_funcs, num_vars);\n-\n-  VarDesc vd[2] = { vd_tgt2host, vd_tgt2host };\n-  vd[0].ptr = &num_funcs;\n-  vd[0].size = sizeof (num_funcs);\n-  vd[1].ptr = &num_vars;\n-  vd[1].size = sizeof (num_vars);\n-\n-  __offload_target_enter (ofldt, 2, vd, NULL);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Part 2: Send the table with addresses to host.  */\n-static void\n-__offload_target_table_p2 (OFFLOAD ofldt)\n-{\n-  void ***lib_descr = (void ***) last_loaded_library;\n-  void **func_table_begin = lib_descr[0];\n-  void **func_table_end   = lib_descr[1];\n-  void **var_table_begin  = lib_descr[2];\n-  void **var_table_end    = lib_descr[3];\n-\n-  int num_funcs = func_table_end - func_table_begin;\n-  int num_vars = (var_table_end - var_table_begin) / 2;\n-  int table_size = (num_funcs + 2 * num_vars) * sizeof (void *);\n-  void **table = (void **) malloc (table_size);\n-  TRACE (\"(table_size = %d)\", table_size);\n-\n-  VarDesc vd = vd_tgt2host;\n-  vd.ptr = table;\n-  vd.size = table_size;\n-\n-  __offload_target_enter (ofldt, 1, &vd, NULL);\n-\n-  void **p;\n-  int i = 0;\n-  for (p = func_table_begin; p < func_table_end; p++, i++)\n-    table[i] = *p;\n-\n-  for (p = var_table_begin; p < var_table_end; p++, i++)\n-    table[i] = *p;\n-\n-  __offload_target_leave (ofldt);\n-  free (table);\n-}\n-\n-/* Allocate size bytes and send a pointer to the allocated memory to host.  */\n-static void\n-__offload_target_alloc (OFFLOAD ofldt)\n-{\n-  size_t size = 0;\n-  void *ptr = NULL;\n-\n-  VarDesc vd[2] = { vd_host2tgt, vd_tgt2host };\n-  vd[0].ptr = &size;\n-  vd[0].size = sizeof (size);\n-  vd[1].ptr = &ptr;\n-  vd[1].size = sizeof (void *);\n-\n-  __offload_target_enter (ofldt, 2, vd, NULL);\n-  ptr = malloc (size);\n-  TRACE (\"(size = %d): ptr = %p\", size, ptr);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Free the memory space pointed to by ptr.  */\n-static void\n-__offload_target_free (OFFLOAD ofldt)\n-{\n-  void *ptr = 0;\n-\n-  VarDesc vd = vd_host2tgt;\n-  vd.ptr = &ptr;\n-  vd.size = sizeof (void *);\n-\n-  __offload_target_enter (ofldt, 1, &vd, NULL);\n-  TRACE (\"(ptr = %p)\", ptr);\n-  free (ptr);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Receive var_size bytes from host and store to var_ptr.\n-   Part 1: Receive var_ptr and var_size from host.  */\n-static void\n-__offload_target_host2tgt_p1 (OFFLOAD ofldt)\n-{\n-  void *var_ptr = NULL;\n-  size_t var_size = 0;\n-\n-  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &var_ptr;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &var_size;\n-  vd[1].size = sizeof (var_size);\n-\n-  __offload_target_enter (ofldt, 2, vd, NULL);\n-  TRACE (\"(var_ptr = %p, var_size = %d)\", var_ptr, var_size);\n-  last_var_ptr = var_ptr;\n-  last_var_size = var_size;\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Part 2: Receive the data from host.  */\n-static void\n-__offload_target_host2tgt_p2 (OFFLOAD ofldt)\n-{\n-  TRACE (\"(last_var_ptr = %p, last_var_size = %d)\",\n-\t last_var_ptr, last_var_size);\n-\n-  VarDesc vd = vd_host2tgt;\n-  vd.ptr = last_var_ptr;\n-  vd.size = last_var_size;\n-\n-  __offload_target_enter (ofldt, 1, &vd, NULL);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Send var_size bytes from var_ptr to host.\n-   Part 1: Receive var_ptr and var_size from host.  */\n-static void\n-__offload_target_tgt2host_p1 (OFFLOAD ofldt)\n-{\n-  void *var_ptr = NULL;\n-  size_t var_size = 0;\n-\n-  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &var_ptr;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &var_size;\n-  vd[1].size = sizeof (var_size);\n-\n-  __offload_target_enter (ofldt, 2, vd, NULL);\n-  TRACE (\"(var_ptr = %p, var_size = %d)\", var_ptr, var_size);\n-  last_var_ptr = var_ptr;\n-  last_var_size = var_size;\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Part 2: Send the data to host.  */\n-static void\n-__offload_target_tgt2host_p2 (OFFLOAD ofldt)\n-{\n-  TRACE (\"(last_var_ptr = %p, last_var_size = %d)\",\n-\t last_var_ptr, last_var_size);\n-\n-  VarDesc vd = vd_tgt2host;\n-  vd.ptr = last_var_ptr;\n-  vd.size = last_var_size;\n-\n-  __offload_target_enter (ofldt, 1, &vd, NULL);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Copy SIZE bytes from SRC_PTR to DST_PTR.  */\n-static void\n-__offload_target_tgt2tgt (OFFLOAD ofldt)\n-{\n-  void *src_ptr = NULL;\n-  void *dst_ptr = NULL;\n-  size_t size = 0;\n-\n-  VarDesc vd[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &dst_ptr;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &src_ptr;\n-  vd[1].size = sizeof (void *);\n-  vd[2].ptr = &size;\n-  vd[2].size = sizeof (size);\n-\n-  __offload_target_enter (ofldt, 3, vd, NULL);\n-  TRACE (\"(dst_ptr = %p, src_ptr = %p, size = %d)\", dst_ptr, src_ptr, size);\n-  memcpy (dst_ptr, src_ptr, size);\n-  __offload_target_leave (ofldt);\n-}\n-\n-/* Call offload function by the address fn_ptr and pass vars_ptr to it.  */\n-static void\n-__offload_target_run (OFFLOAD ofldt)\n-{\n-  void *fn_ptr;\n-  void *vars_ptr;\n-\n-  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n-  vd[0].ptr = &fn_ptr;\n-  vd[0].size = sizeof (void *);\n-  vd[1].ptr = &vars_ptr;\n-  vd[1].size = sizeof (void *);\n-\n-  __offload_target_enter (ofldt, 2, vd, NULL);\n-  TRACE (\"(fn_ptr = %p, vars_ptr = %p)\", fn_ptr, vars_ptr);\n-  void (*fn)(void *) = (void (*)(void *)) fn_ptr;\n-  fn (vars_ptr);\n-  __offload_target_leave (ofldt);\n-}\n-\n-\n-/* This should be called from every library with offloading.  */\n-extern \"C\" void\n-target_register_lib (const void *target_table)\n-{\n-  TRACE (\"(target_table = %p { %p, %p, %p, %p })\", target_table,\n-\t ((void **) target_table)[0], ((void **) target_table)[1],\n-\t ((void **) target_table)[2], ((void **) target_table)[3]);\n-\n-  last_loaded_library = (void *) target_table;\n-}\n-\n-/* Use __offload_target_main from liboffload.  */\n-int\n-main (int argc, char **argv)\n-{\n-  __offload_target_main ();\n-  return 0;\n-}\n-\n-\n-/* Register offload_target_main's functions in the liboffload.  */\n-\n-struct Entry {\n-  const char *name;\n-  void *func;\n-};\n-\n-#define REGISTER(f)\t\t\t\t      \\\n-extern \"C\" const Entry __offload_target_##f##_$entry  \\\n-__attribute__ ((section(\".OffloadEntryTable.\"))) = {  \\\n-  \"__offload_target_\"#f,\t\t\t      \\\n-  (void *) __offload_target_##f\t\t\t      \\\n-}\n-REGISTER (init_proc);\n-REGISTER (table_p1);\n-REGISTER (table_p2);\n-REGISTER (alloc);\n-REGISTER (free);\n-REGISTER (host2tgt_p1);\n-REGISTER (host2tgt_p2);\n-REGISTER (tgt2host_p1);\n-REGISTER (tgt2host_p2);\n-REGISTER (tgt2tgt);\n-REGISTER (run);\n-#undef REGISTER"}, {"sha": "f2c3e48a99ccdb88cab79f596aeb4596e5ad6a0c", "filename": "liboffloadmic/runtime/cean_util.cpp", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcean_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcean_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,421 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#include \"cean_util.h\"\n-#include \"offload_common.h\"\n-\n-// 1. allocate element of CeanReadRanges type\n-// 2. initialized it for reading consequently contiguous ranges\n-//    described by \"ap\" argument\n-CeanReadRanges * init_read_ranges_arr_desc(const Arr_Desc *ap)\n-{\n-    CeanReadRanges * res;\n-\n-    // find the max contiguous range\n-    int64_t rank = ap->rank - 1;\n-    int64_t length = ap->dim[rank].size;\n-    for (; rank >= 0; rank--) {\n-        if (ap->dim[rank].stride == 1) {\n-            length *= (ap->dim[rank].upper - ap->dim[rank].lower + 1);\n-            if (rank > 0 && length != ap->dim[rank - 1].size) {\n-                break;\n-            }\n-        }\n-        else {\n-            break;\n-        }\n-    }\n-\n-    res =(CeanReadRanges *)malloc(sizeof(CeanReadRanges) +\n-                                  (ap->rank - rank) * sizeof(CeanReadDim));\n-    if (res == NULL)\n-      LIBOFFLOAD_ERROR(c_malloc);\n-\n-    res->arr_desc = const_cast<Arr_Desc*>(ap);\n-    res->current_number = 0;\n-    res->range_size = length;\n-    res->last_noncont_ind = rank;\n-\n-    // calculate number of contiguous ranges inside noncontiguous dimensions\n-    int count = 1;\n-    bool prev_is_cont = true;\n-    int64_t offset = 0;\n-\n-    for (; rank >= 0; rank--) {\n-        res->Dim[rank].count = count;\n-        res->Dim[rank].size = ap->dim[rank].stride * ap->dim[rank].size;\n-        count *= (prev_is_cont && ap->dim[rank].stride == 1? 1 :\n-            (ap->dim[rank].upper - ap->dim[rank].lower +\n-            ap->dim[rank].stride) / ap->dim[rank].stride);\n-        prev_is_cont = false;\n-        offset +=(ap->dim[rank].lower - ap->dim[rank].lindex) *\n-                 ap->dim[rank].size;\n-    }\n-    res->range_max_number = count;\n-    res -> ptr = (void*)ap->base;\n-    res -> init_offset = offset;\n-    return res;\n-}\n-\n-// check if ranges described by 1 argument could be transferred into ranges\n-// described by 2-nd one\n-bool cean_ranges_match(\n-    CeanReadRanges * read_rng1,\n-    CeanReadRanges * read_rng2\n-)\n-{\n-    return ( read_rng1 == NULL || read_rng2 == NULL ||\n-            (read_rng1->range_size % read_rng2->range_size == 0 ||\n-            read_rng2->range_size % read_rng1->range_size == 0));\n-}\n-\n-// Set next offset and length and returns true for next range.\n-// Returns false if the ranges are over.\n-bool get_next_range(\n-    CeanReadRanges * read_rng,\n-    int64_t *offset\n-)\n-{\n-    if (++read_rng->current_number > read_rng->range_max_number) {\n-        read_rng->current_number = 0;\n-        return false;\n-    }\n-    int rank = 0;\n-    int num = read_rng->current_number - 1;\n-    int64_t cur_offset = 0;\n-    int num_loc;\n-    for (; rank <= read_rng->last_noncont_ind; rank++) {\n-        num_loc = num / read_rng->Dim[rank].count;\n-        cur_offset += num_loc * read_rng->Dim[rank].size;\n-        num = num % read_rng->Dim[rank].count;\n-    }\n-    *offset = cur_offset + read_rng->init_offset;\n-    return true;\n-}\n-\n-bool is_arr_desc_contiguous(const Arr_Desc *ap)\n-{\n-    int64_t rank = ap->rank - 1;\n-    int64_t length = ap->dim[rank].size;\n-    for (; rank >= 0; rank--) {\n-        if (ap->dim[rank].stride > 1 &&\n-            ap->dim[rank].upper - ap->dim[rank].lower != 0) {\n-                return false;\n-        }\n-        else if (length != ap->dim[rank].size) {\n-            for (; rank >= 0; rank--) {\n-                if (ap->dim[rank].upper - ap->dim[rank].lower != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        length *= (ap->dim[rank].upper - ap->dim[rank].lower + 1);\n-    }\n-    return true;\n-}\n-\n-int64_t cean_get_transf_size(CeanReadRanges * read_rng)\n-{\n-    return(read_rng->range_max_number * read_rng->range_size);\n-}\n-\n-static uint64_t last_left, last_right;\n-\n-typedef void (*fpp)(\n-    const char *spaces,\n-    uint64_t low,\n-    uint64_t high,\n-    int esize,\n-    bool print_values\n-);\n-\n-static void generate_one_range(\n-    const char *spaces,\n-    uint64_t lrange,\n-    uint64_t rrange,\n-    fpp fp,\n-    int esize,\n-    bool print_values\n-)\n-{\n-    OFFLOAD_TRACE(3,\n-        \"%s    generate_one_range(lrange=%p, rrange=%p, esize=%d)\\n\",\n-        spaces, (void*)lrange, (void*)rrange, esize);\n-    if (last_left == -1) {\n-        // First range\n-        last_left = lrange;\n-    }\n-    else {\n-        if (lrange == last_right+1) {\n-            // Extend previous range, don't print\n-        }\n-        else {\n-            (*fp)(spaces, last_left, last_right, esize, print_values);\n-            last_left = lrange;\n-        }\n-    }\n-    last_right = rrange;\n-}\n-\n-static bool element_is_contiguous(\n-    uint64_t rank,\n-    const struct Dim_Desc *ddp\n-)\n-{    \n-    if (rank == 1) {\n-        return (ddp[0].lower == ddp[0].upper || ddp[0].stride == 1);\n-    }\n-    else {\n-        return ((ddp[0].size == (ddp[1].upper-ddp[1].lower+1)*ddp[1].size) &&\n-                 element_is_contiguous(rank-1, ddp++));\n-    }\n-}\n-\n-static void generate_mem_ranges_one_rank(\n-    const char *spaces,\n-    uint64_t base,\n-    uint64_t rank,\n-    const struct Dim_Desc *ddp,\n-    fpp fp,\n-    int esize,\n-    bool print_values\n-)\n-{\n-    uint64_t lindex = ddp->lindex;\n-    uint64_t lower = ddp->lower;\n-    uint64_t upper = ddp->upper;\n-    uint64_t stride = ddp->stride;\n-    uint64_t size = ddp->size;\n-    OFFLOAD_TRACE(3,\n-        \"%s    \"\n-        \"generate_mem_ranges_one_rank(base=%p, rank=%lld, lindex=%lld, \"\n-        \"lower=%lld, upper=%lld, stride=%lld, size=%lld, esize=%d)\\n\",\n-        spaces, (void*)base, rank, lindex, lower, upper, stride, size, esize);\n-\n-    if (element_is_contiguous(rank, ddp)) {\n-        uint64_t lrange, rrange;\n-        lrange = base + (lower-lindex)*size;\n-        rrange = lrange + (upper-lower+1)*size - 1;\n-        generate_one_range(spaces, lrange, rrange, fp, esize, print_values);\n-    }\n-    else {\n-        if (rank == 1) {\n-            for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n-                uint64_t lrange, rrange;\n-                lrange = base + i*size;\n-                rrange = lrange + size - 1;\n-                generate_one_range(spaces, lrange, rrange,\n-\t\t                   fp, esize, print_values);\n-            }\n-        }\n-        else {\n-            for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n-                generate_mem_ranges_one_rank(\n-                    spaces, base+i*size, rank-1, ddp+1,\n-                    fp, esize, print_values);\n-\n-            }\n-        }\n-    }\n-}\n-\n-static void generate_mem_ranges(\n-    const char *spaces,\n-    const Arr_Desc *adp,\n-    bool deref,\n-    fpp fp,\n-    bool print_values\n-)\n-{\n-    uint64_t esize;\n-\n-    OFFLOAD_TRACE(3,\n-        \"%s    \"\n-        \"generate_mem_ranges(adp=%p, deref=%d, fp)\\n\",\n-        spaces, adp, deref);\n-    last_left = -1;\n-    last_right = -2;\n-\n-    // Element size is derived from last dimension\n-    esize = adp->dim[adp->rank-1].size;\n-\n-    generate_mem_ranges_one_rank(\n-        // For c_cean_var the base addr is the address of the data\n-        // For c_cean_var_ptr the base addr is dereferenced to get to the data\n-        spaces, deref ? *((uint64_t*)(adp->base)) : adp->base,\n-        adp->rank, &adp->dim[0], fp, esize, print_values);\n-    (*fp)(spaces, last_left, last_right, esize, print_values);\n-}\n-\n-// returns offset and length of the data to be transferred\n-void __arr_data_offset_and_length(\n-    const Arr_Desc *adp,\n-    int64_t &offset,\n-    int64_t &length\n-)\n-{\n-    int64_t rank = adp->rank - 1;\n-    int64_t size = adp->dim[rank].size;\n-    int64_t r_off = 0; // offset from right boundary\n-\n-    // find the rightmost dimension which takes just part of its\n-    // range. We define it if the size of left rank is not equal\n-    // the range's length between upper and lower boungaries\n-    while (rank > 0) {\n-        size *= (adp->dim[rank].upper - adp->dim[rank].lower + 1);\n-        if (size != adp->dim[rank - 1].size) {\n-            break;\n-        }\n-        rank--;\n-    }\n-\n-    offset = (adp->dim[rank].lower - adp->dim[rank].lindex) *\n-             adp->dim[rank].size;\n-\n-    // find gaps both from the left - offset and from the right - r_off\n-    for (rank--; rank >= 0; rank--) {\n-        offset += (adp->dim[rank].lower - adp->dim[rank].lindex) *\n-                  adp->dim[rank].size;\n-        r_off += adp->dim[rank].size -\n-                 (adp->dim[rank + 1].upper - adp->dim[rank + 1].lindex + 1) *\n-                 adp->dim[rank + 1].size;\n-    }\n-    length = (adp->dim[0].upper - adp->dim[0].lindex + 1) *\n-             adp->dim[0].size - offset - r_off;\n-}\n-\n-#if OFFLOAD_DEBUG > 0\n-\n-static void print_range(\n-    const char *spaces,\n-    uint64_t low,\n-    uint64_t high,\n-    int esize,\n-    bool print_values\n-)\n-{\n-    char buffer[1024];\n-    char number[32];\n-\n-    OFFLOAD_TRACE(3, \"%s        print_range(low=%p, high=%p, esize=%d)\\n\",\n-        spaces, (void*)low, (void*)high, esize);\n-\n-    if (console_enabled < 4 || !print_values) {\n-        return;\n-    }\n-    OFFLOAD_TRACE(4, \"%s            values:\\n\", spaces);\n-    int count = 0;\n-    buffer[0] = '\\0';\n-    while (low <= high)\n-    {\n-        switch (esize)\n-        {\n-        case 1:\n-            sprintf(number, \"%d \", *((char *)low));\n-            low += 1;\n-            break;\n-        case 2:\n-            sprintf(number, \"%d \", *((short *)low));\n-            low += 2;\n-            break;\n-        case 4:\n-            sprintf(number, \"%d \", *((int *)low));\n-            low += 4;\n-            break;\n-        default:\n-            sprintf(number, \"0x%016x \", *((uint64_t *)low));\n-            low += 8;\n-            break;\n-        }\n-        strcat(buffer, number);\n-        count++;\n-        if (count == 10) {\n-            OFFLOAD_TRACE(4, \"%s            %s\\n\", spaces, buffer);\n-            count = 0;\n-            buffer[0] = '\\0';\n-        }\n-    }\n-    if (count != 0) {\n-        OFFLOAD_TRACE(4, \"%s            %s\\n\", spaces, buffer);\n-    }\n-}\n-\n-void __arr_desc_dump(\n-    const char *spaces,\n-    const char *name,\n-    const Arr_Desc *adp,\n-    bool deref,\n-    bool print_values\n-)\n-{\n-    OFFLOAD_TRACE(2, \"%s%s CEAN expression %p\\n\", spaces, name, adp);\n-\n-    if (adp != 0) {\n-        OFFLOAD_TRACE(2, \"%s    base=%llx, rank=%lld\\n\",\n-            spaces, adp->base, adp->rank);\n-\n-        for (int i = 0; i < adp->rank; i++) {\n-            OFFLOAD_TRACE(2,\n-                          \"%s    dimension %d: size=%lld, lindex=%lld, \"\n-                          \"lower=%lld, upper=%lld, stride=%lld\\n\",\n-                          spaces, i, adp->dim[i].size, adp->dim[i].lindex,\n-                          adp->dim[i].lower, adp->dim[i].upper,\n-                          adp->dim[i].stride);\n-        }\n-        // For c_cean_var the base addr is the address of the data\n-        // For c_cean_var_ptr the base addr is dereferenced to get to the data\n-        generate_mem_ranges(spaces, adp, deref, &print_range, print_values);\n-    }\n-}\n-\n-void noncont_struct_dump(\n-    const char *spaces,\n-    const char *name,\n-    struct NonContigDesc *desc_p)\n-{\n-   OFFLOAD_TRACE(2, \"%s%s NonCont Struct expression %p\\n\",\n-                 spaces, name, desc_p->base);\n-   if (desc_p) {\n-       OFFLOAD_TRACE(2, \"%s%s    base=%p\\n\", spaces, name, desc_p->base);\n-       for (int i = 0; i < desc_p->interval_cnt; i++) {\n-           OFFLOAD_TRACE(2,\"%s    dimension %d: lower=%lld, size=%lld\\n\",\n-               spaces, i, desc_p->interval[i].lower, desc_p->interval[i].size);\n-       }\n-   }\n-}\n-\n-int64_t get_noncont_struct_size(struct NonContigDesc *desc_p)\n-{\n-    int index = desc_p->interval_cnt - 1;\n-    return(desc_p->interval[index].lower + desc_p->interval[index].size);\n-}\n-\n-#endif // OFFLOAD_DEBUG"}, {"sha": "1ba8793b653863b18746fbc0ca31e68a4b2da624", "filename": "liboffloadmic/runtime/cean_util.h", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcean_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcean_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,137 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#ifndef CEAN_UTIL_H_INCLUDED\n-#define CEAN_UTIL_H_INCLUDED\n-\n-#include <stdint.h>\n-#include \"offload_util.h\"\n-\n-// CEAN expression representation\n-struct Dim_Desc {\n-    int64_t size;       // Length of data type\n-    int64_t lindex;     // Lower index\n-    int64_t lower;      // Lower section bound\n-    int64_t upper;      // Upper section bound\n-    int64_t stride;     // Stride\n-};\n-\n-struct Arr_Desc {\n-    int64_t base;       // Base address\n-    int64_t rank;       // Rank of array\n-    Dim_Desc dim[1];\n-};\n-\n-struct CeanReadDim {\n-    int64_t count; // The number of elements in this dimension\n-    int64_t size;  // The number of bytes between successive\n-                   // elements in this dimension.\n-};\n-\n-struct CeanReadRanges {\n-    Arr_Desc* arr_desc;\n-    void *  ptr;\n-    int64_t current_number;   // the number of ranges read\n-    int64_t range_max_number; // number of contiguous ranges\n-    int64_t range_size;       // size of max contiguous range\n-    int     last_noncont_ind; // size of Dim array\n-    int64_t init_offset;      // offset of 1-st element from array left bound\n-    CeanReadDim Dim[1];\n-};\n-\n-struct IntervalDesc {\n-    int64_t lower;   // Lower  index\n-    int64_t size;    // Size of each element at this interval\n-};\n-\n-struct NonContigDesc {\n-    int64_t base;            // Base address\n-    int64_t interval_cnt;    // Number of intervals\n-    struct IntervalDesc interval[1];\n-};\n-\n-// array descriptor length\n-#define __arr_desc_length(rank) \\\n-    (sizeof(int64_t) + sizeof(Dim_Desc) * (rank))\n-\n-// returns offset and length of the data to be transferred\n-DLL_LOCAL void __arr_data_offset_and_length(const Arr_Desc *adp,\n-                                  int64_t &offset,\n-                                  int64_t &length);\n-\n-// define if data array described by argument is contiguous one\n-DLL_LOCAL bool is_arr_desc_contiguous(const Arr_Desc *ap);\n-\n-// allocate element of CeanReadRanges type initialized\n-// to read consequently contiguous ranges described by \"ap\" argument\n-DLL_LOCAL CeanReadRanges * init_read_ranges_arr_desc(const Arr_Desc *ap);\n-\n-// check if ranges described by 1 argument could be transferred into ranges\n-// described by 2-nd one\n-DLL_LOCAL bool cean_ranges_match(\n-    CeanReadRanges * read_rng1,\n-    CeanReadRanges * read_rng2\n-);\n-\n-// first argument - returned value by call to init_read_ranges_arr_desc.\n-// returns true if offset and length of next range is set successfuly.\n-// returns false if the ranges is over.\n-DLL_LOCAL bool get_next_range(\n-    CeanReadRanges * read_rng,\n-    int64_t *offset\n-);\n-\n-// returns number of transferred bytes\n-DLL_LOCAL int64_t cean_get_transf_size(CeanReadRanges * read_rng);\n-\n-#if OFFLOAD_DEBUG > 0\n-// prints array descriptor contents to stderr\n-DLL_LOCAL void    __arr_desc_dump(\n-    const char *spaces,\n-    const char *name,\n-    const Arr_Desc *adp,\n-    bool dereference,\n-    bool print_values);\n-\n-DLL_LOCAL void noncont_struct_dump(\n-    const char *spaces,\n-    const char *name,\n-    struct NonContigDesc *desc_p);\n-\n-DLL_LOCAL int64_t get_noncont_struct_size(struct NonContigDesc *desc_p);\n-\n-#define ARRAY_DESC_DUMP(spaces, name, adp, dereference, print_values) \\\n-    if (console_enabled >= 2) \\\n-        __arr_desc_dump(spaces, name, adp, dereference, print_values);\n-#else\n-#define ARRAY_DESC_DUMP(spaces, name, adp, dereference, print_values)\n-#endif // OFFLOAD_DEBUG\n-\n-#endif // CEAN_UTIL_H_INCLUDED"}, {"sha": "179a3029e9c3bd1f8dbe5fa00cc17fc0e72d924d", "filename": "liboffloadmic/runtime/coi/coi_client.cpp", "status": "removed", "additions": 0, "deletions": 494, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,494 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-// The COI host interface\n-\n-#include \"coi_client.h\"\n-#include \"../offload_common.h\"\n-\n-namespace COI {\n-\n-#define COI_VERSION1    \"COI_1.0\"\n-#define COI_VERSION2    \"COI_2.0\"\n-\n-bool            is_available;\n-static void*    lib_handle;\n-\n-// pointers to functions from COI library\n-COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n-COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n-\n-COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*, const void*,\n-                                     uint64_t, int, const char**, uint8_t,\n-                                     const char**, uint8_t, const char*,\n-                                     uint64_t, const char*, const char*,\n-                                     uint64_t, COIPROCESS*);\n-COIRESULT (*ProcessCreateFromFile)(COIENGINE, const char*,\n-                                     int, const char**, uint8_t,\n-                                     const char**, uint8_t, const char*,\n-                                     uint64_t, const char*,COIPROCESS*);\n-COIRESULT (*ProcessSetCacheSize)(COIPROCESS, uint64_t, uint32_t,\n-                                 uint64_t, uint32_t, uint32_t,\n-                                 const COIEVENT*, COIEVENT*);\n-COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t, int8_t*, uint32_t*);\n-COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t, const char**,\n-                                       COIFUNCTION*);\n-COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS, const void*, uint64_t,\n-                                          const char*, const char*,\n-                                          const char*, uint64_t, uint32_t,\n-                                          COILIBRARY*);\n-COIRESULT (*ProcessUnloadLibrary)(COIPROCESS,\n-                                  COILIBRARY);\n-COIRESULT (*ProcessRegisterLibraries)(uint32_t, const void**, const uint64_t*,\n-                                      const char**, const uint64_t*);\n-\n-COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t, COIPIPELINE*);\n-COIRESULT (*PipelineDestroy)(COIPIPELINE);\n-COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION, uint32_t,\n-                                 const COIBUFFER*, const COI_ACCESS_FLAGS*,\n-                                 uint32_t, const COIEVENT*, const void*,\n-                                 uint16_t, void*, uint16_t, COIEVENT*);\n-\n-COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t, const void*,\n-                          uint32_t, const COIPROCESS*, COIBUFFER*);\n-COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n-                                    void*, uint32_t, const COIPROCESS*,\n-                                    COIBUFFER*);\n-COIRESULT (*BufferDestroy)(COIBUFFER);\n-COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t, COI_MAP_TYPE, uint32_t,\n-                       const COIEVENT*, COIEVENT*, COIMAPINSTANCE*, void**);\n-COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t, const COIEVENT*, COIEVENT*);\n-COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*, uint64_t,\n-                         COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n-COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t, COI_COPY_TYPE,\n-                        uint32_t, const COIEVENT*, COIEVENT*);\n-COIRESULT (*BufferReadMultiD)(COIBUFFER, uint64_t,\n-                        void *, void *, COI_COPY_TYPE,\n-                        uint32_t, const   COIEVENT*, COIEVENT*);\n-COIRESULT (*BufferWriteMultiD)(COIBUFFER, const   COIPROCESS,\n-                       uint64_t, void *, void *,\n-                       COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*);\n-\n-COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n-                        COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n-COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n-COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n-                            COI_BUFFER_MOVE_FLAG, uint32_t,\n-                            const   COIEVENT*, COIEVENT*);\n-\n-COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t, uint8_t, uint32_t*,\n-                       uint32_t*);\n-\n-uint64_t  (*PerfGetCycleFrequency)(void);\n-\n-COIRESULT (*PipelineClearCPUMask) (COI_CPU_MASK);\n-\n-COIRESULT (*PipelineSetCPUMask) (COIPROCESS, uint32_t,\n-                                        uint8_t, COI_CPU_MASK);\n-COIRESULT (*EngineGetInfo)(COIENGINE, uint32_t, COI_ENGINE_INFO*);\n-\n-COIRESULT (*EventRegisterCallback)(\n-    const COIEVENT,\n-    void (*)(COIEVENT, const COIRESULT, const void*),\n-    const void*,\n-    const uint64_t);\n-\n-COIRESULT (*ProcessConfigureDMA)(const uint64_t, const int);\n-\n-bool init(void)\n-{\n-#ifndef TARGET_WINNT\n-    const char *lib_name = \"libcoi_host.so.0\";\n-#else // TARGET_WINNT\n-    const char *lib_name = \"coi_host.dll\";\n-#endif // TARGET_WINNT\n-\n-    OFFLOAD_DEBUG_TRACE(2, \"Loading COI library %s ...\\n\", lib_name);\n-    lib_handle = DL_open(lib_name);\n-    if (lib_handle == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to load the library\\n\");\n-        return false;\n-    }\n-\n-    EngineGetCount =\n-        (COIRESULT (*)(COI_ISA_TYPE, uint32_t*))\n-            DL_sym(lib_handle, \"COIEngineGetCount\", COI_VERSION1);\n-    if (EngineGetCount == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIEngineGetCount\");\n-        fini();\n-        return false;\n-    }\n-\n-    EngineGetHandle =\n-        (COIRESULT (*)(COI_ISA_TYPE, uint32_t, COIENGINE*))\n-            DL_sym(lib_handle, \"COIEngineGetHandle\", COI_VERSION1);\n-    if (EngineGetHandle == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIEngineGetHandle\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessCreateFromMemory =\n-        (COIRESULT (*)(COIENGINE, const char*, const void*, uint64_t, int,\n-                       const char**, uint8_t, const char**, uint8_t,\n-                       const char*, uint64_t, const char*, const char*,\n-                       uint64_t, COIPROCESS*))\n-            DL_sym(lib_handle, \"COIProcessCreateFromMemory\", COI_VERSION1);\n-    if (ProcessCreateFromMemory == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessCreateFromMemory\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessSetCacheSize =\n-           (COIRESULT (*)(COIPROCESS, uint64_t, uint32_t,\n-                                 uint64_t, uint32_t, uint32_t,\n-                                 const COIEVENT*, COIEVENT*))\n-               DL_sym(lib_handle, \"COIProcessSetCacheSize\", COI_VERSION1);\n-    if (ProcessSetCacheSize == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessSetCacheSize\");\n-#if 0  // for now disable as ProcessSetCacheSize is not available on < MPSS 3.4\n-        fini();\n-        return false;\n-#endif\n-    }\n-\n-    ProcessCreateFromFile =\n-           (COIRESULT (*)(COIENGINE, const char*, int, const char**, uint8_t,\n-                          const char**, uint8_t, const char*, uint64_t,\n-                          const char*, COIPROCESS*))\n-            DL_sym(lib_handle, \"COIProcessCreateFromFile\", COI_VERSION1);\n-    if (ProcessCreateFromFile == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessCreateFromFile\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessDestroy =\n-        (COIRESULT (*)(COIPROCESS, int32_t, uint8_t, int8_t*,\n-                       uint32_t*))\n-            DL_sym(lib_handle, \"COIProcessDestroy\", COI_VERSION1);\n-    if (ProcessDestroy == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessDestroy\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessGetFunctionHandles =\n-        (COIRESULT (*)(COIPROCESS, uint32_t, const char**, COIFUNCTION*))\n-            DL_sym(lib_handle, \"COIProcessGetFunctionHandles\", COI_VERSION1);\n-    if (ProcessGetFunctionHandles == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessGetFunctionHandles\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessLoadLibraryFromMemory =\n-        (COIRESULT (*)(COIPROCESS, const void*, uint64_t, const char*,\n-                       const char*, const char*, uint64_t, uint32_t,\n-                       COILIBRARY*))\n-            DL_sym(lib_handle, \"COIProcessLoadLibraryFromMemory\", COI_VERSION2);\n-    if (ProcessLoadLibraryFromMemory == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessLoadLibraryFromMemory\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessUnloadLibrary =\n-        (COIRESULT (*)(COIPROCESS,\n-                       COILIBRARY))\n-            DL_sym(lib_handle, \"COIProcessUnloadLibrary\", COI_VERSION1);\n-    if (ProcessUnloadLibrary == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessUnloadLibrary\");\n-        fini();\n-        return false;\n-    }\n-\n-    ProcessRegisterLibraries =\n-        (COIRESULT (*)(uint32_t, const void**, const uint64_t*, const char**,\n-                       const uint64_t*))\n-            DL_sym(lib_handle, \"COIProcessRegisterLibraries\", COI_VERSION1);\n-    if (ProcessRegisterLibraries == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIProcessRegisterLibraries\");\n-        fini();\n-        return false;\n-    }\n-\n-    PipelineCreate =\n-        (COIRESULT (*)(COIPROCESS, COI_CPU_MASK, uint32_t, COIPIPELINE*))\n-            DL_sym(lib_handle, \"COIPipelineCreate\", COI_VERSION1);\n-    if (PipelineCreate == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPipelineCreate\");\n-        fini();\n-        return false;\n-    }\n-\n-    PipelineDestroy =\n-        (COIRESULT (*)(COIPIPELINE))\n-            DL_sym(lib_handle, \"COIPipelineDestroy\", COI_VERSION1);\n-    if (PipelineDestroy == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPipelineDestroy\");\n-        fini();\n-        return false;\n-    }\n-\n-    PipelineRunFunction =\n-        (COIRESULT (*)(COIPIPELINE, COIFUNCTION, uint32_t, const COIBUFFER*,\n-                       const COI_ACCESS_FLAGS*, uint32_t, const COIEVENT*,\n-                       const void*, uint16_t, void*, uint16_t, COIEVENT*))\n-            DL_sym(lib_handle, \"COIPipelineRunFunction\", COI_VERSION1);\n-    if (PipelineRunFunction == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPipelineRunFunction\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferCreate =\n-        (COIRESULT (*)(uint64_t, COI_BUFFER_TYPE, uint32_t, const void*,\n-                       uint32_t, const COIPROCESS*, COIBUFFER*))\n-            DL_sym(lib_handle, \"COIBufferCreate\", COI_VERSION1);\n-    if (BufferCreate == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferCreate\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferCreateFromMemory =\n-        (COIRESULT (*)(uint64_t, COI_BUFFER_TYPE, uint32_t, void*,\n-                       uint32_t, const COIPROCESS*, COIBUFFER*))\n-            DL_sym(lib_handle, \"COIBufferCreateFromMemory\", COI_VERSION1);\n-    if (BufferCreateFromMemory == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferCreateFromMemory\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferDestroy =\n-        (COIRESULT (*)(COIBUFFER))\n-            DL_sym(lib_handle, \"COIBufferDestroy\", COI_VERSION1);\n-    if (BufferDestroy == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferDestroy\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferMap =\n-        (COIRESULT (*)(COIBUFFER, uint64_t, uint64_t, COI_MAP_TYPE, uint32_t,\n-                       const COIEVENT*, COIEVENT*, COIMAPINSTANCE*,\n-                       void**))\n-            DL_sym(lib_handle, \"COIBufferMap\", COI_VERSION1);\n-    if (BufferMap == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferMap\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferUnmap =\n-        (COIRESULT (*)(COIMAPINSTANCE, uint32_t, const COIEVENT*,\n-                       COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferUnmap\", COI_VERSION1);\n-    if (BufferUnmap == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferUnmap\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferWrite =\n-        (COIRESULT (*)(COIBUFFER, uint64_t, const void*, uint64_t,\n-                       COI_COPY_TYPE, uint32_t, const COIEVENT*,\n-                       COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferWrite\", COI_VERSION1);\n-    if (BufferWrite == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferWrite\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferRead =\n-        (COIRESULT (*)(COIBUFFER, uint64_t, void*, uint64_t,\n-                                     COI_COPY_TYPE, uint32_t,\n-                                     const COIEVENT*, COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferRead\", COI_VERSION1);\n-    if (BufferRead == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferRead\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferReadMultiD =\n-        (COIRESULT (*)(COIBUFFER, uint64_t,\n-                       void *, void *, COI_COPY_TYPE,\n-                       uint32_t, const   COIEVENT*, COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferReadMultiD\", COI_VERSION1);\n-    // We  accept that coi library has no COIBufferReadMultiD routine.\n-    // So there is no check for zero value\n-\n-    BufferWriteMultiD =\n-        (COIRESULT (*)(COIBUFFER, const   COIPROCESS,\n-                       uint64_t, void *, void *,\n-                       COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferWriteMultiD\", COI_VERSION1);\n-    // We  accept that coi library has no COIBufferWriteMultiD routine.\n-    // So there is no check for zero value\n-\n-    BufferCopy =\n-        (COIRESULT (*)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n-                       COI_COPY_TYPE, uint32_t, const COIEVENT*,\n-                       COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferCopy\", COI_VERSION1);\n-    if (BufferCopy == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferCopy\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferGetSinkAddress =\n-        (COIRESULT (*)(COIBUFFER, uint64_t*))\n-            DL_sym(lib_handle, \"COIBufferGetSinkAddress\", COI_VERSION1);\n-    if (BufferGetSinkAddress == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferGetSinkAddress\");\n-        fini();\n-        return false;\n-    }\n-\n-    BufferSetState =\n-        (COIRESULT(*)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n-                      COI_BUFFER_MOVE_FLAG, uint32_t, const COIEVENT*,\n-                      COIEVENT*))\n-            DL_sym(lib_handle, \"COIBufferSetState\", COI_VERSION1);\n-    if (BufferSetState == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIBufferSetState\");\n-        fini();\n-        return false;\n-    }\n-\n-    EventWait =\n-        (COIRESULT (*)(uint16_t, const COIEVENT*, int32_t, uint8_t,\n-                       uint32_t*, uint32_t*))\n-            DL_sym(lib_handle, \"COIEventWait\", COI_VERSION1);\n-    if (EventWait == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIEventWait\");\n-        fini();\n-        return false;\n-    }\n-\n-    PerfGetCycleFrequency =\n-        (uint64_t (*)(void))\n-            DL_sym(lib_handle, \"COIPerfGetCycleFrequency\", COI_VERSION1);\n-    if (PerfGetCycleFrequency == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPerfGetCycleFrequency\");\n-        fini();\n-        return false;\n-    }\n-\n-    PipelineClearCPUMask =\n-        (COIRESULT (*)(COI_CPU_MASK))\n-            DL_sym(lib_handle, \"COIPipelineClearCPUMask\", COI_VERSION1);\n-    if (PipelineClearCPUMask == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPipelineClearCPUMask\");\n-        fini();\n-        return false;\n-    }\n-\n-    PipelineSetCPUMask =\n-        (COIRESULT (*)(COIPROCESS, uint32_t,uint8_t, COI_CPU_MASK))\n-            DL_sym(lib_handle, \"COIPipelineSetCPUMask\", COI_VERSION1);\n-    if (PipelineSetCPUMask == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIPipelineSetCPUMask\");\n-        fini();\n-        return false;\n-    }\n-\n-    EngineGetInfo =\n-        (COIRESULT (*)(COIENGINE, uint32_t, COI_ENGINE_INFO*))\n-            DL_sym(lib_handle, \"COIEngineGetInfo\", COI_VERSION1);\n-    if (EngineGetInfo == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n-                            \"COIEngineGetInfo\");\n-        fini();\n-        return false;\n-    }\n-    \n-    EventRegisterCallback =\n-        (COIRESULT (*)(COIEVENT,\n-         void (*)(COIEVENT, const COIRESULT, const void*),\n-         const void*,\n-         const uint64_t))\n-            DL_sym(lib_handle, \"COIEventRegisterCallback\", COI_VERSION1);\n-\n-    ProcessConfigureDMA =\n-        (COIRESULT (*)(const uint64_t, const int))\n-            DL_sym(lib_handle, \"COIProcessConfigureDMA\", COI_VERSION1);\n-    \n-    is_available = true;\n-\n-    return true;\n-}\n-\n-void fini(void)\n-{\n-    is_available = false;\n-\n-    if (lib_handle != 0) {\n-#ifndef TARGET_WINNT\n-        DL_close(lib_handle);\n-#endif // TARGET_WINNT\n-        lib_handle = 0;\n-    }\n-}\n-\n-} // namespace COI"}, {"sha": "b5b0efc49476d497dc22b128adc196bb553cca15", "filename": "liboffloadmic/runtime/coi/coi_client.h", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,176 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-// The interface between offload library and the COI API on the host\n-\n-#ifndef COI_CLIENT_H_INCLUDED\n-#define COI_CLIENT_H_INCLUDED\n-\n-#include <common/COIPerf_common.h>\n-#include <common/COIMacros_common.h>\n-#include <source/COIEngine_source.h>\n-#include <source/COIProcess_source.h>\n-#include <source/COIPipeline_source.h>\n-#include <source/COIBuffer_source.h>\n-#include <source/COIEvent_source.h>\n-\n-#include <string.h>\n-\n-#include \"../liboffload_error_codes.h\"\n-#include \"../offload_util.h\"\n-\n-#define MIC_ENGINES_MAX     128\n-\n-#if MIC_ENGINES_MAX < COI_MAX_ISA_MIC_DEVICES\n-#error MIC_ENGINES_MAX need to be increased\n-#endif\n-\n-// COI library interface\n-namespace COI {\n-\n-DLL_LOCAL extern bool init(void);\n-DLL_LOCAL extern void fini(void);\n-\n-DLL_LOCAL extern bool is_available;\n-\n-// pointers to functions from COI library\n-DLL_LOCAL extern COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n-DLL_LOCAL extern COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n-\n-DLL_LOCAL extern COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*,\n-                                           const void*, uint64_t, int,\n-                                           const char**, uint8_t,\n-                                           const char**, uint8_t,\n-                                           const char*, uint64_t,\n-                                           const char*,\n-                                           const char*, uint64_t,\n-                                           COIPROCESS*);\n-DLL_LOCAL extern COIRESULT (*ProcessCreateFromFile)(COIENGINE, const char*, int,\n-                                          const char**, uint8_t,\n-                                          const char**,\n-                                          uint8_t,\n-                                          const char*,\n-                                          uint64_t,\n-                                          const char*,\n-                                          COIPROCESS*);\n-DLL_LOCAL extern COIRESULT (*ProcessSetCacheSize)(COIPROCESS, uint64_t, uint32_t,\n-                                                uint64_t, uint32_t, uint32_t,\n-                                                const COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t,\n-                                  int8_t*, uint32_t*);\n-DLL_LOCAL extern COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t,\n-                                             const char**,\n-                                             COIFUNCTION*);\n-DLL_LOCAL extern COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS,\n-                                                const void*,\n-                                                uint64_t,\n-                                                const char*,\n-                                                const char*,\n-                                                const char*,\n-                                                uint64_t,\n-                                                uint32_t,\n-                                                COILIBRARY*);\n-\n-DLL_LOCAL extern COIRESULT (*ProcessUnloadLibrary)(COIPROCESS,\n-                                                COILIBRARY);\n-\n-DLL_LOCAL extern COIRESULT (*ProcessRegisterLibraries)(uint32_t,\n-                                            const void**,\n-                                            const uint64_t*,\n-                                            const char**,\n-                                            const uint64_t*);\n-\n-DLL_LOCAL extern COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t,\n-                                  COIPIPELINE*);\n-DLL_LOCAL extern COIRESULT (*PipelineDestroy)(COIPIPELINE);\n-DLL_LOCAL extern COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION,\n-                                       uint32_t, const COIBUFFER*,\n-                                       const COI_ACCESS_FLAGS*,\n-                                       uint32_t, const COIEVENT*,\n-                                       const void*, uint16_t, void*,\n-                                       uint16_t, COIEVENT*);\n-\n-DLL_LOCAL extern COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n-                                const void*, uint32_t,\n-                                const COIPROCESS*, COIBUFFER*);\n-DLL_LOCAL extern COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE,\n-                                          uint32_t, void*,\n-                                          uint32_t, const COIPROCESS*,\n-                                          COIBUFFER*);\n-DLL_LOCAL extern COIRESULT (*BufferDestroy)(COIBUFFER);\n-DLL_LOCAL extern COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t,\n-                             COI_MAP_TYPE, uint32_t, const COIEVENT*,\n-                             COIEVENT*, COIMAPINSTANCE*, void**);\n-DLL_LOCAL extern COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t,\n-                               const COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*,\n-                               uint64_t, COI_COPY_TYPE, uint32_t,\n-                               const COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t,\n-                              COI_COPY_TYPE, uint32_t,\n-                              const COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*BufferReadMultiD)(COIBUFFER, uint64_t,\n-                            void *, void *, COI_COPY_TYPE,\n-                            uint32_t, const   COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*BufferWriteMultiD)(COIBUFFER, const   COIPROCESS,\n-                            uint64_t, void *, void *,\n-                            COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*);\n-\n-DLL_LOCAL extern COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t,\n-                              uint64_t, COI_COPY_TYPE, uint32_t,\n-                              const COIEVENT*, COIEVENT*);\n-DLL_LOCAL extern COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n-DLL_LOCAL extern COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n-                                   COI_BUFFER_MOVE_FLAG, uint32_t,\n-                                   const   COIEVENT*, COIEVENT*);\n-\n-DLL_LOCAL extern COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t,\n-                           uint8_t, uint32_t*, uint32_t*);\n-\n-DLL_LOCAL extern uint64_t (*PerfGetCycleFrequency)(void);\n-\n-DLL_LOCAL extern COIRESULT (*ProcessConfigureDMA)(const uint64_t, const int);\n-\n-extern COIRESULT (*PipelineClearCPUMask)(COI_CPU_MASK);\n-\n-extern COIRESULT (*PipelineSetCPUMask)(COIPROCESS, uint32_t,\n-                                        uint8_t, COI_CPU_MASK);\n-extern COIRESULT (*EngineGetInfo)(COIENGINE, uint32_t, COI_ENGINE_INFO*);\n-\n-extern COIRESULT (*EventRegisterCallback)(\n-    const COIEVENT,\n-    void (*)(COIEVENT, const COIRESULT, const void*),\n-    const void*,\n-    const uint64_t);\n-    \n-const int DMA_MODE_READ_WRITE = 1; \n-} // namespace COI\n-\n-#endif // COI_CLIENT_H_INCLUDED"}, {"sha": "67aa991eebbcb09fd154d543cc3e43838e420ca7", "filename": "liboffloadmic/runtime/coi/coi_server.cpp", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,180 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-// The COI interface on the target\n-\n-#include \"coi_server.h\"\n-\n-#include \"../offload_target.h\"\n-#include \"../offload_timer.h\"\n-#ifdef MYO_SUPPORT\n-#include \"../offload_myo_target.h\"      // for __offload_myoLibInit/Fini\n-#endif // MYO_SUPPORT\n-\n-#if !defined(CPU_COUNT)\n-// if CPU_COUNT is not defined count number of CPUs manually \n-static\n-int my_cpu_count(cpu_set_t const *cpu_set) \n-{\n-    int res = 0;\n-    for (int i = 0; i < sizeof(cpu_set_t) / sizeof(__cpu_mask); ++i) {\n-        res += __builtin_popcountl(cpu_set->__bits[i]);\n-    }\n-    return res;\n-}\n-// Map CPU_COUNT to our function\n-#define CPU_COUNT(x) my_cpu_count(x)\n-\n-#endif\n-\n-COINATIVELIBEXPORT\n-void server_compute(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    OffloadDescriptor::offload(buffer_count, buffers,\n-                               misc_data, misc_data_len,\n-                               return_data, return_data_len);\n-}\n-\n-COINATIVELIBEXPORT\n-void server_init(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    struct init_data {\n-        int  device_index;\n-        int  devices_total;\n-        int  console_level;\n-        int  offload_report_level;\n-    } *data = (struct init_data*) misc_data;\n-\n-    // set device index and number of total devices\n-    mic_index = data->device_index;\n-    mic_engines_total = data->devices_total;\n-\n-    // initialize trace level\n-    console_enabled = data->console_level;\n-    offload_report_level = data->offload_report_level;\n-\n-    // return back the process id\n-    *((pid_t*) return_data) = getpid();\n-}\n-\n-COINATIVELIBEXPORT\n-void server_var_table_size(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    struct Params {\n-        int64_t nelems;\n-        int64_t length;\n-    } *params;\n-\n-    params = static_cast<Params*>(return_data);\n-    params->length = __offload_vars.table_size(params->nelems);\n-}\n-\n-COINATIVELIBEXPORT\n-void server_var_table_copy(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    __offload_vars.table_copy(buffers[0], *static_cast<int64_t*>(misc_data));\n-}\n-\n-COINATIVELIBEXPORT\n-void server_set_stream_affinity(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-  /* kmp affinity is not supported by GCC.  */\n-}\n-\n-#ifdef MYO_SUPPORT\n-// temporary workaround for blocking behavior of myoiLibInit/Fini calls\n-COINATIVELIBEXPORT\n-void server_myoinit(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    __offload_myoLibInit();\n-}\n-\n-COINATIVELIBEXPORT\n-void server_myofini(\n-    uint32_t  buffer_count,\n-    void**    buffers,\n-    uint64_t* buffers_len,\n-    void*     misc_data,\n-    uint16_t  misc_data_len,\n-    void*     return_data,\n-    uint16_t  return_data_len\n-)\n-{\n-    __offload_myoLibFini();\n-}\n-#endif // MYO_SUPPORT"}, {"sha": "1afaa3bd810756b3733333f266ff631dbe2c0729", "filename": "liboffloadmic/runtime/coi/coi_server.h", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,94 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-// The interface between offload library and the COI API on the target\n-\n-#ifndef COI_SERVER_H_INCLUDED\n-#define COI_SERVER_H_INCLUDED\n-\n-#include <common/COIEngine_common.h>\n-#include <common/COIPerf_common.h>\n-#include <sink/COIProcess_sink.h>\n-#include <sink/COIPipeline_sink.h>\n-#include <sink/COIBuffer_sink.h>\n-#include <list>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include \"../liboffload_error_codes.h\"\n-\n-// wrappers for COI API\n-#define PipelineStartExecutingRunFunctions() \\\n-    { \\\n-        COIRESULT res = COIPipelineStartExecutingRunFunctions(); \\\n-        if (res != COI_SUCCESS) { \\\n-            LIBOFFLOAD_ERROR(c_pipeline_start_run_funcs, mic_index, res); \\\n-            exit(1); \\\n-        } \\\n-    }\n-\n-#define ProcessWaitForShutdown() \\\n-    { \\\n-        COIRESULT res = COIProcessWaitForShutdown(); \\\n-        if (res != COI_SUCCESS) { \\\n-            LIBOFFLOAD_ERROR(c_process_wait_shutdown, mic_index, res); \\\n-            exit(1); \\\n-        } \\\n-    }\n-\n-#define BufferAddRef(buf) \\\n-    { \\\n-        COIRESULT res = COIBufferAddRef(buf); \\\n-        if (res != COI_SUCCESS) { \\\n-            LIBOFFLOAD_ERROR(c_buf_add_ref, mic_index, res); \\\n-            exit(1); \\\n-        } \\\n-    }\n-\n-#define BufferReleaseRef(buf) \\\n-    { \\\n-        COIRESULT res = COIBufferReleaseRef(buf); \\\n-        if (res != COI_SUCCESS) { \\\n-            LIBOFFLOAD_ERROR(c_buf_release_ref, mic_index, res); \\\n-            exit(1); \\\n-        } \\\n-    }\n-\n-#define EngineGetIndex(index) \\\n-    { \\\n-        COI_ISA_TYPE isa_type; \\\n-        COIRESULT res = COIEngineGetIndex(&isa_type, index); \\\n-        if (res != COI_SUCCESS) { \\\n-            LIBOFFLOAD_ERROR(c_get_engine_index, mic_index, res); \\\n-            exit(1); \\\n-        } \\\n-    }\n-\n-#endif // COI_SERVER_H_INCLUDED"}, {"sha": "4d8feb467159b6e8895514e075ca3bfc95c7b726", "filename": "liboffloadmic/runtime/compiler_if_host.cpp", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,501 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#include \"compiler_if_host.h\"\n-\n-#include <malloc.h>\n-#ifndef TARGET_WINNT\n-#include <alloca.h>\n-#endif // TARGET_WINNT\n-\n-// Global counter on host.\n-// This variable is used if P2OPT_offload_do_data_persistence == 2.\n-// The variable used to identify offload constructs contained in one procedure.\n-// Increment of OFFLOAD_CALL_COUNT is inserted at entries of HOST routines with\n-// offload constructs.\n-static int offload_call_count = 0;\n-\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n-    TARGET_TYPE      target_type,\n-    int              target_number,\n-    int              is_optional,\n-    _Offload_status* status,\n-    const char*      file,\n-    uint64_t         line\n-)\n-{\n-    bool retval;\n-    OFFLOAD ofld;\n-\n-    // initialize status\n-    if (status != 0) {\n-        status->result = OFFLOAD_UNAVAILABLE;\n-        status->device_number = -1;\n-        status->data_sent = 0;\n-        status->data_received = 0;\n-    }\n-\n-    // make sure libray is initialized\n-    retval = __offload_init_library();\n-\n-    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n-    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-\n-    // initialize all devices is init_type is on_offload_all\n-    if (retval && __offload_init_type == c_init_on_offload_all) {\n-        for (int i = 0; i < mic_engines_total; i++) {\n-             mic_engines[i].init();\n-        }\n-    }\n-    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n-\n-    if (target_type == TARGET_HOST) {\n-        // Host always available\n-        retval = true;\n-    }\n-    else if (target_type == TARGET_MIC) {\n-        if (target_number >= -1) {\n-            if (retval) {\n-                if (target_number >= 0) {\n-                    // User provided the device number\n-                    target_number = target_number % mic_engines_total;\n-                }\n-                else {\n-                    // use device 0\n-                    target_number = 0;\n-                }\n-\n-                // reserve device in ORSL\n-                if (is_optional) {\n-                    if (!ORSL::try_reserve(target_number)) {\n-                        target_number = -1;\n-                    }\n-                }\n-                else {\n-                    if (!ORSL::reserve(target_number)) {\n-                        target_number = -1;\n-                    }\n-                }\n-\n-                // initialize device\n-                if (target_number >= 0 &&\n-                    __offload_init_type == c_init_on_offload) {\n-                    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-                    mic_engines[target_number].init();\n-                    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-                }\n-            }\n-            else {\n-                // fallback to CPU\n-                target_number = -1;\n-            }\n-\n-            if (target_number < 0 || !retval) {\n-                if (!is_optional && status == 0) {\n-                    LIBOFFLOAD_ERROR(c_device_is_not_available);\n-                    exit(1);\n-                }\n-\n-                retval = false;\n-            }\n-        }\n-        else {\n-            LIBOFFLOAD_ERROR(c_invalid_device_number);\n-            exit(1);\n-        }\n-    }\n-\n-    if (retval) {\n-        ofld = new OffloadDescriptor(target_number, status,\n-                                     !is_optional, false, timer_data);\n-        OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n-        Offload_Report_Prolog(timer_data);\n-        OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n-                              \"Starting offload: target_type = %d, \"\n-                              \"number = %d, is_optional = %d\\n\",\n-                              target_type, target_number, is_optional);\n-\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n-    }\n-    else {\n-        ofld = NULL;\n-\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_total_offload);\n-        offload_report_free_data(timer_data);\n-    }\n-\n-    return ofld;\n-}\n-\n-// This routine is called for OpenMP4.5 offload calls\n-// OpenMP 4.5 offload is always optional.\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n-    const int*  device_num,\n-    const char* file,\n-    uint64_t    line\n-)\n-{\n-    int target_number;\n-\n-    // make sure libray is initialized and at least one device is available\n-    if (!__offload_init_library()) {\n-       OFFLOAD_DEBUG_TRACE(2, \"No device available, fall back to host\\n\");\n-       return NULL;\n-    }\n-\n-    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n-\n-    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-\n-    if (__offload_init_type == c_init_on_offload_all) {\n-        for (int i = 0; i < mic_engines_total; i++) {\n-             mic_engines[i].init();\n-        }\n-    }\n-\n-    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n-\n-    // use default device number if it is not provided\n-    if (device_num != 0) {\n-        target_number = *device_num;\n-    }\n-    else {\n-        target_number = __omp_device_num;\n-    }\n-\n-    // device number should be a non-negative integer value\n-    if (target_number < 0) {\n-        LIBOFFLOAD_ERROR(c_omp_invalid_device_num);\n-        exit(1);\n-    }\n-\n-    // should we do this for OpenMP?\n-    target_number %= mic_engines_total;\n-\n-    // reserve device in ORSL\n-    if (!ORSL::reserve(target_number)) {\n-        LIBOFFLOAD_ERROR(c_device_is_not_available);\n-        exit(1);\n-    }\n-\n-    // initialize device(s)\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-\n-    if (__offload_init_type == c_init_on_offload) {\n-        mic_engines[target_number].init();\n-    }\n-\n-    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-\n-    OFFLOAD ofld =\n-        new OffloadDescriptor(target_number, 0, true, true, timer_data);\n-\n-    OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n-\n-    Offload_Report_Prolog(timer_data);\n-\n-    OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n-                          \"Starting OpenMP offload, device = %d\\n\",\n-                          target_number);\n-\n-    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n-\n-    return ofld;\n-}\n-\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE2(\n-    TARGET_TYPE      target_type,\n-    int              target_number,\n-    int              is_optional,\n-    _Offload_status* status,\n-    const char*      file,\n-    uint64_t         line,\n-    const void**     stream\n-)\n-{\n-    bool retval;\n-    OFFLOAD ofld;\n-\n-    // initialize status\n-    if (status != 0) {\n-        status->result = OFFLOAD_UNAVAILABLE;\n-        status->device_number = -1;\n-        status->data_sent = 0;\n-        status->data_received = 0;\n-    }\n-\n-    // make sure libray is initialized\n-    retval = __offload_init_library();\n-    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n-    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-\n-    // initalize all devices if init_type is on_offload_all\n-    if (retval && __offload_init_type == c_init_on_offload_all) {\n-        for (int i = 0; i < mic_engines_total; i++) {\n-             mic_engines[i].init();\n-        }\n-    }\n-    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-\n-    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n-\n-    if (target_type == TARGET_HOST) {\n-        // Host always available\n-        retval = true;\n-    }\n-    else if (target_type == TARGET_MIC) {\n-        _Offload_stream handle = *(reinterpret_cast<_Offload_stream*>(stream));\n-        Stream * stream = handle ? Stream::find_stream(handle, false) : NULL;\n-        if (target_number >= -1) {\n-            if (retval) {\n-                // device number is defined by stream\n-                if (stream) {\n-                    target_number = stream->get_device();\n-                    target_number = target_number % mic_engines_total;\n-                }\n-\n-                // reserve device in ORSL\n-                if (target_number != -1) {\n-                    if (is_optional) {\n-                        if (!ORSL::try_reserve(target_number)) {\n-                            target_number = -1;\n-                        }\n-                    }\n-                    else {\n-                        if (!ORSL::reserve(target_number)) {\n-                            target_number = -1;\n-                        }\n-                    }\n-                }\n-\n-                // initialize device\n-                if (target_number >= 0 &&\n-                    __offload_init_type == c_init_on_offload) {\n-                    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n-                    mic_engines[target_number].init();\n-                    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n-                }\n-            }\n-            else {\n-                // fallback to CPU\n-                target_number = -1;\n-            }\n-            if (!(target_number == -1 && handle == 0)) {\n-                if (target_number < 0 || !retval) {\n-                    if (!is_optional && status == 0) {\n-                        LIBOFFLOAD_ERROR(c_device_is_not_available);\n-                        exit(1);\n-                    }\n-\n-                    retval = false;\n-                }\n-            }\n-        }\n-        else {\n-            LIBOFFLOAD_ERROR(c_invalid_device_number);\n-            exit(1);\n-        }\n-    }\n-\n-    if (retval) {\n-        ofld = new OffloadDescriptor(target_number, status,\n-                                     !is_optional, false, timer_data);\n-        OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n-        Offload_Report_Prolog(timer_data);\n-        OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n-                              \"Starting offload: target_type = %d, \"\n-                              \"number = %d, is_optional = %d\\n\",\n-                              target_type, target_number, is_optional);\n-\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n-    }\n-    else {\n-        ofld = NULL;\n-\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n-        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_total_offload);\n-        offload_report_free_data(timer_data);\n-    }\n-\n-    return ofld;\n-}\n-\n-static int offload_offload_wrap(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void **waits,\n-    const void **signal,\n-    int entry_id,\n-    const void *stack_addr,\n-    OffloadFlags offload_flags\n-)\n-{\n-    if (signal) {\n-       ofld->set_signal(*signal);\n-    }\n-\n-    bool ret = ofld->offload(name, is_empty, vars, vars2, num_vars,\n-                             waits, num_waits, signal, entry_id,\n-                             stack_addr, offload_flags);\n-    if (!ret || (signal == 0 && ofld->get_stream() == 0 &&\n-                 !offload_flags.bits.omp_async)) {\n-        delete ofld;\n-    }\n-    return ret;\n-}\n-\n-extern \"C\" int OFFLOAD_OFFLOAD1(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void **waits,\n-    const void **signal\n-)\n-{\n-    return offload_offload_wrap(ofld, name, is_empty,\n-                            num_vars, vars, vars2,\n-                            num_waits, waits,\n-                            signal, 0, NULL, {0});\n-}\n-\n-extern \"C\" int OFFLOAD_OFFLOAD2(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void** signal,\n-    int entry_id,\n-    const void *stack_addr\n-)\n-{\n-    return offload_offload_wrap(ofld, name, is_empty,\n-                            num_vars, vars, vars2,\n-                            num_waits, waits,\n-                            signal, entry_id, stack_addr, {0});\n-}\n-\n-extern \"C\" int OFFLOAD_OFFLOAD3(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void** signal,\n-    int entry_id,\n-    const void *stack_addr,\n-    OffloadFlags offload_flags,\n-    const void** stream\n-)\n-{\n-    // 1. if the source is compiled with -traceback then stream is 0\n-    // 2. if offload has a stream clause then stream is address of stream value\n-    if (stream) {\n-        ofld->set_stream(*(reinterpret_cast<_Offload_stream *>(stream)));\n-    }\n-\n-    return offload_offload_wrap(ofld, name, is_empty,\n-                            num_vars, vars, vars2,\n-                            num_waits, waits,\n-                            signal, entry_id, stack_addr, offload_flags);\n-}\n-\n-extern \"C\" int OFFLOAD_OFFLOAD(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void **waits,\n-    const void *signal,\n-    int entry_id,\n-    const void *stack_addr\n-)\n-{\n-    // signal is passed by reference now\n-    const void **signal_new = (signal != 0) ? &signal : 0;\n-    const void **waits_new = 0;\n-    int num_waits_new = 0;\n-\n-    // remove NULL values from the list of signals to wait for\n-    if (num_waits > 0) {\n-        waits_new = (const void**) alloca(sizeof(void*) * num_waits);\n-        for (int i = 0; i < num_waits; i++) {\n-            if (waits[i] != 0) {\n-                waits_new[num_waits_new++] = waits[i];\n-            }\n-        }\n-    }\n-\n-    return OFFLOAD_OFFLOAD1(ofld, name, is_empty,\n-                            num_vars, vars, vars2,\n-                            num_waits_new, waits_new,\n-                            signal_new);\n-}\n-\n-extern \"C\" int OFFLOAD_CALL_COUNT()\n-{\n-    offload_call_count++;\n-    return offload_call_count;\n-}"}, {"sha": "025f6fb2dba70d4be3c2eb9754bfa0dbd93ee2b4", "filename": "liboffloadmic/runtime/compiler_if_host.h", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,209 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-/*! \\file\n-    \\brief The interface between compiler-generated host code and runtime library\n-*/\n-\n-#ifndef COMPILER_IF_HOST_H_INCLUDED\n-#define COMPILER_IF_HOST_H_INCLUDED\n-\n-#include \"offload_host.h\"\n-\n-#define OFFLOAD_TARGET_ACQUIRE          OFFLOAD_PREFIX(target_acquire)\n-#define OFFLOAD_TARGET_ACQUIRE1         OFFLOAD_PREFIX(target_acquire1)\n-#define OFFLOAD_TARGET_ACQUIRE2         OFFLOAD_PREFIX(target_acquire2)\n-#define OFFLOAD_OFFLOAD                 OFFLOAD_PREFIX(offload)\n-#define OFFLOAD_OFFLOAD1                OFFLOAD_PREFIX(offload1)\n-#define OFFLOAD_OFFLOAD2                OFFLOAD_PREFIX(offload2)\n-#define OFFLOAD_OFFLOAD3                OFFLOAD_PREFIX(offload3)\n-#define OFFLOAD_CALL_COUNT              OFFLOAD_PREFIX(offload_call_count)\n-\n-\n-/*! \\fn OFFLOAD_TARGET_ACQUIRE\n-    \\brief Attempt to acquire the target.\n-    \\param target_type   The type of target.\n-    \\param target_number The device number.\n-    \\param is_optional   Whether CPU fall-back is allowed.\n-    \\param status        Address of variable to hold offload status.\n-    \\param file          Filename in which this offload occurred.\n-    \\param line          Line number in the file where this offload occurred.\n-*/\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n-    TARGET_TYPE      target_type,\n-    int              target_number,\n-    int              is_optional,\n-    _Offload_status* status,\n-    const char*      file,\n-    uint64_t         line\n-);\n-\n-/*! \\fn OFFLOAD_TARGET_ACQUIRE1\n-    \\brief Acquire the target for offload (OpenMP).\n-    \\param device_number Device number or null if not specified.\n-    \\param file          Filename in which this offload occurred\n-    \\param line          Line number in the file where this offload occurred.\n-*/\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n-    const int*      device_number,\n-    const char*     file,\n-    uint64_t        line\n-);\n-\n-/*! \\fn OFFLOAD_TARGET_ACQUIRE2\n-    \\brief Attempt to acquire the target.\n-    \\param target_type   The type of target.\n-    \\param target_number The device number.\n-    \\param is_optional   Whether CPU fall-back is allowed.\n-    \\param status        Address of variable to hold offload status.\n-    \\param file          Filename in which this offload occurred.\n-    \\param line          Line number in the file where this offload occurred.\n-    \\param stream        Pointer to stream value.\n-*/\n-extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE2(\n-    TARGET_TYPE      target_type,\n-    int              target_number,\n-    int              is_optional,\n-    _Offload_status* status,\n-    const char*      file,\n-    uint64_t         line,\n-    const void**     stream\n-);\n-\n-/*! \\fn OFFLOAD_OFFLOAD1\n-    \\brief Run function on target using interface for old data persistence.\n-    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n-    \\param name Name of offload entry point.\n-    \\param is_empty If no code to execute (e.g. offload_transfer)\n-    \\param num_vars Number of variable descriptors.\n-    \\param vars Pointer to VarDesc array.\n-    \\param vars2 Pointer to VarDesc2 array.\n-    \\param num_waits Number of \"wait\" values.\n-    \\param waits Pointer to array of wait values.\n-    \\param signal Pointer to signal value or NULL.\n-*/\n-extern \"C\" int OFFLOAD_OFFLOAD1(\n-    OFFLOAD o,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void** signal\n-);\n-\n-/*! \\fn OFFLOAD_OFFLOAD2\n-    \\brief Run function on target using interface for new data persistence.\n-    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n-    \\param name Name of offload entry point.\n-    \\param is_empty If no code to execute (e.g. offload_transfer)\n-    \\param num_vars Number of variable descriptors.\n-    \\param vars Pointer to VarDesc array.\n-    \\param vars2 Pointer to VarDesc2 array.\n-    \\param num_waits Number of \"wait\" values.\n-    \\param waits Pointer to array of wait values.\n-    \\param signal Pointer to signal value or NULL.\n-    \\param entry_id A signature for the function doing the offload.\n-    \\param stack_addr The stack frame address of the function doing offload.\n-*/\n-extern \"C\" int OFFLOAD_OFFLOAD2(\n-    OFFLOAD o,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void** signal,\n-    int entry_id,\n-    const void *stack_addr\n-);\n-\n-\n-/*! \\fn OFFLOAD_OFFLOAD3\n-    \\brief Run function on target, API introduced in 15.0 Update 1\n-    \\brief when targetptr, preallocated feature was introduced.\n-    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n-    \\param name Name of offload entry point.\n-    \\param is_empty If no code to execute (e.g. offload_transfer)\n-    \\param num_vars Number of variable descriptors.\n-    \\param vars Pointer to VarDesc array.\n-    \\param vars2 Pointer to VarDesc2 array.\n-    \\param num_waits Number of \"wait\" values.\n-    \\param waits Pointer to array of wait values.\n-    \\param signal Pointer to signal value or NULL.\n-    \\param entry_id A signature for the function doing the offload.\n-    \\param stack_addr The stack frame address of the function doing offload.\n-    \\param offload_flags Flags to indicate Fortran traceback, OpenMP async.\n-    \\param stream Pointer to stream value or NULL.\n-*/\n-extern \"C\" int OFFLOAD_OFFLOAD3(\n-    OFFLOAD ofld,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void** signal,\n-    int entry_id,\n-    const void *stack_addr,\n-    OffloadFlags offload_flags,\n-    const void** stream\n-);\n-\n-// Run function on target (obsolete).\n-// @param o    OFFLOAD object\n-// @param name function name\n-extern \"C\" int OFFLOAD_OFFLOAD(\n-    OFFLOAD o,\n-    const char *name,\n-    int is_empty,\n-    int num_vars,\n-    VarDesc *vars,\n-    VarDesc2 *vars2,\n-    int num_waits,\n-    const void** waits,\n-    const void* signal,\n-    int entry_id = 0,\n-    const void *stack_addr = NULL\n-);\n-\n-// Global counter on host.\n-// This variable is used if P2OPT_offload_do_data_persistence == 2.\n-// The variable used to identify offload constructs contained in one procedure.\n-// Call to OFFLOAD_CALL_COUNT() is inserted at HOST on entry of the routine.\n-extern \"C\" int  OFFLOAD_CALL_COUNT();\n-\n-#endif // COMPILER_IF_HOST_H_INCLUDED"}, {"sha": "a44bd886147c6381e632563105bf0fb03f1afc61", "filename": "liboffloadmic/runtime/compiler_if_target.cpp", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,64 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#include \"compiler_if_target.h\"\n-\n-extern \"C\" void OFFLOAD_TARGET_ENTER(\n-    OFFLOAD ofld,\n-    int vars_total,\n-    VarDesc *vars,\n-    VarDesc2 *vars2\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p, %d, %p, %p)\\n\", __func__, ofld,\n-                        vars_total, vars, vars2);\n-    ofld->merge_var_descs(vars, vars2, vars_total);\n-    ofld->scatter_copyin_data();\n-}\n-\n-extern \"C\" void OFFLOAD_TARGET_LEAVE(\n-    OFFLOAD ofld\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ofld);\n-    ofld->gather_copyout_data();\n-}\n-\n-extern \"C\" void OFFLOAD_TARGET_MAIN(void)\n-{\n-    // initialize target part\n-    __offload_target_init();\n-\n-    // pass control to COI\n-    PipelineStartExecutingRunFunctions();\n-    ProcessWaitForShutdown();\n-\n-    OFFLOAD_DEBUG_TRACE(2, \"Exiting main...\\n\");\n-}"}, {"sha": "ebb9b73d0aa7249d220d31b572be4c70a9504535", "filename": "liboffloadmic/runtime/compiler_if_target.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,70 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-/*! \\file\n-    \\brief The interface between compiler-generated target code and runtime library\n-*/\n-\n-#ifndef COMPILER_IF_TARGET_H_INCLUDED\n-#define COMPILER_IF_TARGET_H_INCLUDED\n-\n-#include \"offload_target.h\"\n-\n-#define OFFLOAD_TARGET_ENTER            OFFLOAD_PREFIX(target_enter)\n-#define OFFLOAD_TARGET_LEAVE            OFFLOAD_PREFIX(target_leave)\n-#define OFFLOAD_TARGET_MAIN             OFFLOAD_PREFIX(target_main)\n-\n-/*! \\fn OFFLOAD_TARGET_ENTER\n-    \\brief Fill in variable addresses using VarDesc array.\n-    \\brief Then call back the runtime library to fetch data.\n-    \\param ofld         Offload descriptor created by runtime.\n-    \\param var_desc_num Number of variable descriptors.\n-    \\param var_desc     Pointer to VarDesc array.\n-    \\param var_desc2    Pointer to VarDesc2 array.\n-*/\n-extern \"C\" void OFFLOAD_TARGET_ENTER(\n-    OFFLOAD ofld,\n-    int var_desc_num,\n-    VarDesc *var_desc,\n-    VarDesc2 *var_desc2\n-);\n-\n-/*! \\fn OFFLOAD_TARGET_LEAVE\n-    \\brief Call back the runtime library to gather outputs using VarDesc array.\n-    \\param ofld Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n-*/\n-extern \"C\" void OFFLOAD_TARGET_LEAVE(\n-    OFFLOAD ofld\n-);\n-\n-// Entry point for the target application.\n-extern \"C\" void OFFLOAD_TARGET_MAIN(void);\n-\n-#endif // COMPILER_IF_TARGET_H_INCLUDED"}, {"sha": "f79cf1f8699a1db188217fe7bfcdc248781514cd", "filename": "liboffloadmic/runtime/dv_util.cpp", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fdv_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fdv_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,153 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#include \"offload_common.h\"\n-\n-bool __dv_is_contiguous(const ArrDesc *dvp)\n-{\n-    if (dvp->Flags & ArrDescFlagsContiguous) {\n-        return true;\n-    }\n-\n-    if (dvp->Rank != 0) {\n-        if (dvp->Dim[0].Mult != dvp->Len) {\n-            return false;\n-        }\n-        for (int i = 1; i < dvp->Rank; i++) {\n-            if (dvp->Dim[i].Mult !=\n-                dvp->Dim[i-1].Extent * dvp->Dim[i-1].Mult) {\n-                return false;\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n-bool __dv_is_allocated(const ArrDesc *dvp)\n-{\n-    return (dvp->Flags & ArrDescFlagsDefined);\n-}\n-\n-uint64_t __dv_data_length(const ArrDesc *dvp)\n-{\n-    uint64_t size;\n-\n-    if (dvp->Rank == 0) {\n-        size = dvp->Len;\n-        return size;\n-    }\n-\n-    size = dvp->Len;\n-    for (int i = 0; i < dvp->Rank; ++i) {\n-        size += (dvp->Dim[i].Extent-1) * dvp->Dim[i].Mult;\n-    }\n-    return size;\n-}\n-\n-uint64_t __dv_data_length(const ArrDesc *dvp, int64_t count)\n-{\n-    if (dvp->Rank == 0) {\n-        return count;\n-    }\n-\n-    return count * dvp->Dim[0].Mult;\n-}\n-\n-// Create CeanReadRanges data for reading contiguous ranges of\n-// noncontiguous array defined by the argument\n-CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp)\n-{\n-    int64_t         len;\n-    int             count;\n-    int             rank = dvp->Rank;\n-    CeanReadRanges *res = NULL;\n-\n-    if (rank != 0) {\n-        int i = 0;\n-        len = dvp->Len;\n-        if (dvp->Dim[0].Mult == len) {\n-            for (i = 1; i < rank; i++) {\n-                len *= dvp->Dim[i-1].Extent;\n-                if (dvp->Dim[i].Mult != len) {\n-                    break;\n-                }\n-            }\n-        }\n-        res = (CeanReadRanges *)malloc(\n-            sizeof(CeanReadRanges) + (rank - i) * sizeof(CeanReadDim));\n-        if (res == NULL)\n-            LIBOFFLOAD_ERROR(c_malloc);\n-        res -> last_noncont_ind = rank - i - 1;\n-        count = 1;\n-        for (; i < rank; i++) {\n-            res->Dim[rank - i - 1].count = count;\n-            res->Dim[rank - i - 1].size = dvp->Dim[i].Mult;\n-            count *= dvp->Dim[i].Extent;\n-        }\n-        res -> range_max_number = count;\n-        res -> range_size = len;\n-        res -> ptr = (void*)dvp->Base;\n-        res -> current_number = 0;\n-        res -> init_offset = 0;\n-    }\n-    return res;\n-}\n-\n-#if OFFLOAD_DEBUG > 0\n-void __dv_desc_dump(const char *name, const ArrDesc *dvp)\n-{\n-    OFFLOAD_TRACE(3, \"%s DV %p\\n\", name, dvp);\n-\n-    if (dvp != 0) {\n-        OFFLOAD_TRACE(3,\n-                      \"    dv->Base   = 0x%lx\\n\"\n-                      \"    dv->Len    = 0x%lx\\n\"\n-                      \"    dv->Offset = 0x%lx\\n\"\n-                      \"    dv->Flags  = 0x%lx\\n\"\n-                      \"    dv->Rank   = 0x%lx\\n\"\n-                      \"    dv->Resrvd = 0x%lx\\n\",\n-                      dvp->Base,\n-                      dvp->Len,\n-                      dvp->Offset,\n-                      dvp->Flags,\n-                      dvp->Rank,\n-                      dvp->Reserved);\n-\n-        for (int i = 0 ; i < dvp->Rank; i++) {\n-            OFFLOAD_TRACE(3,\n-                          \"    (%d) Extent=%ld, Multiplier=%ld, LowerBound=%ld\\n\",\n-                          i,\n-                          dvp->Dim[i].Extent,\n-                          dvp->Dim[i].Mult,\n-                          dvp->Dim[i].LowerBound);\n-        }\n-    }\n-}\n-#endif // OFFLOAD_DEBUG > 0"}, {"sha": "370ff01637d4b91d2b11fc8f3fe745148ed37340", "filename": "liboffloadmic/runtime/dv_util.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fdv_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fdv_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,84 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#ifndef DV_UTIL_H_INCLUDED\n-#define DV_UTIL_H_INCLUDED\n-\n-#include <stdint.h>\n-#include \"offload_util.h\"\n-\n-// Dope vector declarations\n-#define ArrDescMaxArrayRank         31\n-\n-// Dope vector flags\n-#define ArrDescFlagsDefined         1\n-#define ArrDescFlagsNodealloc       2\n-#define ArrDescFlagsContiguous      4\n-\n-typedef int64_t dv_size;\n-\n-typedef struct DimDesc {\n-    dv_size        Extent;      // Number of elements in this dimension\n-    dv_size        Mult;        // Multiplier for this dimension.\n-                                // The number of bytes between successive\n-                                // elements in this dimension.\n-    dv_size        LowerBound;  // LowerBound of this dimension\n-} DimDesc ;\n-\n-typedef struct ArrDesc {\n-    dv_size        Base;        // Base address\n-    dv_size        Len;         // Length of data type, used only for\n-                                // character strings.\n-    dv_size        Offset;\n-    dv_size        Flags;       // Flags\n-    dv_size        Rank;        // Rank of pointer\n-    dv_size        Reserved;    // reserved for openmp requests\n-    DimDesc Dim[ArrDescMaxArrayRank];\n-} ArrDesc ;\n-\n-typedef ArrDesc* pArrDesc;\n-\n-DLL_LOCAL bool __dv_is_contiguous(const ArrDesc *dvp);\n-\n-DLL_LOCAL bool __dv_is_allocated(const ArrDesc *dvp);\n-\n-DLL_LOCAL uint64_t __dv_data_length(const ArrDesc *dvp);\n-\n-DLL_LOCAL uint64_t __dv_data_length(const ArrDesc *dvp, int64_t nelems);\n-\n-DLL_LOCAL CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp);\n-\n-#if OFFLOAD_DEBUG > 0\n-DLL_LOCAL void    __dv_desc_dump(const char *name, const ArrDesc *dvp);\n-#else // OFFLOAD_DEBUG\n-#define __dv_desc_dump(name, dvp)\n-#endif // OFFLOAD_DEBUG\n-\n-#endif // DV_UTIL_H_INCLUDED"}, {"sha": "085a92d83eae9142f561ee869325f9042285a48e", "filename": "liboffloadmic/runtime/emulator/coi_common.h", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,168 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef COI_COMMON_H_INCLUDED\n-#define COI_COMMON_H_INCLUDED\n-\n-#include <common/COIMacros_common.h>\n-#include <common/COIPerf_common.h>\n-#include <source/COIEngine_source.h>\n-#include <source/COIProcess_source.h>\n-#include <source/COIPipeline_source.h>\n-#include <source/COIBuffer_source.h>\n-#include <source/COIEvent_source.h>\n-\n-#include <assert.h>\n-#include <dirent.h>\n-#include <dlfcn.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <pthread.h>\n-#include <signal.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/mman.h>\n-#include <sys/stat.h>\n-#include <unistd.h>\n-\n-\n-/* Environment variable for path to 'target' files.  */\n-#define MIC_DIR_ENV\t\t  \"OFFLOAD_MIC_DIR\"\n-\n-/* Environment variable for engine index.  */\n-#define MIC_INDEX_ENV\t\t  \"OFFLOAD_MIC_INDEX\"\n-\n-/* Environment variable for target executable run command.  */\n-#define OFFLOAD_EMUL_RUN_ENV      \"OFFLOAD_EMUL_RUN\"\n-\n-/* Environment variable for number of emulated devices.  */\n-#define OFFLOAD_EMUL_NUM_ENV\t  \"OFFLOAD_EMUL_NUM\"\n-\n-\n-/* Path to engine directory.  */\n-#define ENGINE_PATH\t\t  \"/tmp/offload_XXXXXX\"\n-\n-/* Relative path to directory with pipes.  */\n-#define PIPES_PATH\t\t  \"/pipes\"\n-\n-/* Non-numerical part of host-to-target pipe file name.  */\n-#define PIPE_HOST2TGT_NAME\t  PIPES_PATH \"/host2tgt_\"\n-\n-/* Non-numerical part of target-to-host pipe file name.  */\n-#define PIPE_TGT2HOST_NAME\t  PIPES_PATH \"/tgt2host_\"\n-\n-/* Non-numerical part of shared memory file name.  */\n-#define SHM_NAME\t\t  \"/offload_shm_\"\n-\n-\n-/* Use secure getenv if it's supported.  */\n-#ifdef HAVE_SECURE_GETENV\n-  #define getenv(x)\t      secure_getenv(x)\n-#elif HAVE___SECURE_GETENV\n-  #define getenv(x)\t      __secure_getenv(x)\n-#endif\n-\n-\n-/* Wrapper for malloc.  */\n-#define MALLOC(type, ptr, size)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  type p = (type) malloc (size);\t\t\\\n-  if (p == NULL)\t\t\t\t\\\n-    COIERROR (\"Cannot allocate memory.\");\t\\\n-  ptr = p;\t\t\t\t\t\\\n-}\n-\n-/* Like MALLOC, but return NULL instead of COIRESULT.  */\n-#define MALLOCN(type, ptr, size)\t\t\\\n-{\t\t\t\t\t\t\\\n-  type p = (type) malloc (size);\t\t\\\n-  if (p == NULL)\t\t\t\t\\\n-    COIERRORN (\"Cannot allocate memory.\");\t\\\n-  ptr = p;\t\t\t\t\t\\\n-}\n-\n-/* Wrapper for strdup.  */\n-#define STRDUP(ptr, str)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  char *p = strdup (str);\t\t\t\\\n-  if (p == NULL)\t\t\t\t\\\n-    COIERROR (\"Cannot allocate memory.\");\t\\\n-  ptr = p;\t\t\t\t\t\\\n-}\n-\n-/* Wrapper for pipe reading.  */\n-#define READ(pipe, ptr, size)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  int s = (int) size;\t\t\t\t\\\n-  if (read (pipe, ptr, s) != s)\t\t\t\\\n-    COIERROR (\"Cannot read from pipe.\");\t\\\n-}\n-\n-/* Like READ, but return NULL instead of COIRESULT.  */\n-#define READN(pipe, ptr, size)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  int s = (int) size;\t\t\t\t\\\n-  if (read (pipe, ptr, s) != s)\t\t\t\\\n-    COIERRORN (\"Cannot read from pipe.\");\t\\\n-}\n-\n-/* Wrapper for pipe writing.  */\n-#define WRITE(pipe, ptr, size)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  int s = (int) size;\t\t\t\t\\\n-  if (write (pipe, ptr, s) != s)\t\t\\\n-    COIERROR (\"Cannot write in pipe.\");\t\t\\\n-}\n-\n-/* Like WRITE, but return NULL instead of COIRESULT.  */\n-#define WRITEN(pipe, ptr, size)\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  int s = (int) size;\t\t\t\t\\\n-  if (write (pipe, ptr, s) != s)\t\t\\\n-    COIERRORN (\"Cannot write in pipe.\");\t\\\n-}\n-\n-\n-/* Command codes enum.  */\n-typedef enum\n-{\n-  CMD_BUFFER_COPY,\n-  CMD_BUFFER_MAP,\n-  CMD_BUFFER_UNMAP,\n-  CMD_GET_FUNCTION_HANDLE,\n-  CMD_OPEN_LIBRARY,\n-  CMD_CLOSE_LIBRARY,\n-  CMD_PIPELINE_CREATE,\n-  CMD_PIPELINE_DESTROY,\n-  CMD_PIPELINE_RUN_FUNCTION,\n-  CMD_SHUTDOWN\n-} cmd_t;\n-\n-#endif // COI_COMMON_H_INCLUDED"}, {"sha": "c11214723e0fb7a18eb77ab9ca37903b366ce294", "filename": "liboffloadmic/runtime/emulator/coi_device.cpp", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,401 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#include \"coi_device.h\"\n-\n-#include \"coi_version_asm.h\"\n-\n-#define CYCLE_FREQUENCY     1000000000\n-\n-\n-static uint32_t engine_index;\n-static char *engine_dir;\n-\n-\n-extern \"C\"\n-{\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferAddRef, 1) (void *ptr)\n-{\n-  COITRACE (\"COIBufferAddRef\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferReleaseRef, 1) (void *ptr)\n-{\n-  COITRACE (\"COIBufferReleaseRef\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEngineGetIndex, 1) (COI_ISA_TYPE *type,\n-\t\t\t\t       uint32_t *index)\n-{\n-  COITRACE (\"COIEngineGetIndex\");\n-\n-  /* type is not used in liboffloadmic.  */\n-  *index = engine_index;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineStartExecutingRunFunctions, 1) ()\n-{\n-  COITRACE (\"COIPipelineStartExecutingRunFunctions\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-/* The start routine for the COI pipeline thread.  */\n-\n-static void *\n-pipeline_thread_routine (void *in_pipeline_num)\n-{\n-  uint32_t pipeline_num = *(uint32_t *) in_pipeline_num;\n-  free (in_pipeline_num);\n-\n-  /* Open pipes.  */\n-  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n-  MALLOCN (char *, pipe_host2tgt_path,\n-\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"0000000000\"));\n-  MALLOCN (char *, pipe_tgt2host_path,\n-\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"0000000000\"));\n-  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"%010d\", engine_dir,\n-\t   pipeline_num);\n-  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"%010d\", engine_dir,\n-\t   pipeline_num);\n-  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n-  if (pipe_host2tgt < 0)\n-    COIERRORN (\"Cannot open host-to-target pipe.\");\n-  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n-  if (pipe_tgt2host < 0)\n-    COIERRORN (\"Cannot open target-to-host pipe.\");\n-\n-  free (pipe_host2tgt_path);\n-  free (pipe_tgt2host_path);\n-\n-  while (1)\n-    {\n-      /* Read and execute command.  */\n-      cmd_t cmd = CMD_PIPELINE_DESTROY;\n-      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n-\tCOIERRORN (\"Cannot read from pipe.\");\n-\n-      if (cmd == CMD_PIPELINE_DESTROY)\n-\tbreak;\n-      else if (cmd == CMD_PIPELINE_RUN_FUNCTION)\n-\t{\n-\t  /* Receive data from host.  */\n-\t  void (*func) (uint32_t, void **, uint64_t *, void *, uint16_t, void *,\n-\t\t\tuint16_t);\n-\t  uint32_t buffer_count;\n-\t  READN (pipe_host2tgt, &func, sizeof (void *));\n-\t  READN (pipe_host2tgt, &buffer_count, sizeof (uint32_t));\n-\t  void **buffers;\n-\t  uint64_t *buffers_len;\n-\t  MALLOCN (void **, buffers, buffer_count * sizeof (void *));\n-\t  MALLOCN (uint64_t *, buffers_len, buffer_count * sizeof (uint64_t));\n-\t  for (uint32_t i = 0; i < buffer_count; i++)\n-\t    {\n-\t      READN (pipe_host2tgt, &buffers_len[i], sizeof (uint64_t));\n-\t      READN (pipe_host2tgt, &buffers[i], sizeof (void *));\n-\t    }\n-\t  uint16_t misc_data_len;\n-\t  READN (pipe_host2tgt, &misc_data_len, sizeof (uint16_t));\n-\t  void *misc_data = NULL;\n-\t  if (misc_data_len > 0)\n-\t    {\n-\t      MALLOCN (void *, misc_data, misc_data_len);\n-\t      READN (pipe_host2tgt, misc_data, misc_data_len);\n-\t    }\n-\t  uint16_t return_data_len;\n-\t  READN (pipe_host2tgt, &return_data_len, sizeof (uint16_t));\n-\t  void *return_data;\n-\t  if (return_data_len > 0)\n-\t    MALLOCN (void *, return_data, return_data_len);\n-\n-\t  /* Run function.  */\n-\t  func (buffer_count, buffers, buffers_len, misc_data,\n-\t\tmisc_data_len, return_data, return_data_len);\n-\n-\t  /* Send data to host if any or just send notification.  */\n-\t  WRITEN (pipe_tgt2host, return_data_len > 0 ? return_data : &cmd,\n-\t\t  return_data_len > 0 ? return_data_len : sizeof (cmd_t));\n-\n-\t  /* Clean up.  */\n-\t  free (buffers);\n-\t  free (buffers_len);\n-\t  if (misc_data_len > 0)\n-\t    free (misc_data);\n-\t  if (return_data_len > 0)\n-\t    free (return_data);\n-\t}\n-      else\n-\tCOIERRORN (\"Unrecognizable command from host.\");\n-    }\n-\n-  /* Close pipes.  */\n-  if (close (pipe_host2tgt) < 0)\n-    COIERRORN (\"Cannot close host-to-target pipe.\");\n-  if (close (pipe_tgt2host) < 0)\n-    COIERRORN (\"Cannot close target-to-host pipe.\");\n-\n-  return NULL;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n-{\n-  COITRACE (\"COIProcessWaitForShutdown\");\n-\n-  engine_dir = getenv (MIC_DIR_ENV);\n-  char *mic_index = getenv (MIC_INDEX_ENV);\n-  assert (engine_dir != NULL && mic_index != NULL);\n-\n-  /* Get engine index.  */\n-  engine_index = atoi (mic_index);\n-\n-  /* Open main pipes.  */\n-  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n-  MALLOC (char *, pipe_host2tgt_path,\n-\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"mainpipe\"));\n-  MALLOC (char *, pipe_tgt2host_path,\n-\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"mainpipe\"));\n-  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"mainpipe\", engine_dir);\n-  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"mainpipe\", engine_dir);\n-  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n-  if (pipe_host2tgt < 0)\n-    COIERROR (\"Cannot open host-to-target main pipe.\");\n-  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n-  if (pipe_tgt2host < 0)\n-    COIERROR (\"Cannot open target-to-host main pipe.\");\n-\n-  /* Clean up.  */\n-  free (pipe_host2tgt_path);\n-  free (pipe_tgt2host_path);\n-\n-  /* Handler.  */\n-  while (1)\n-    {\n-      /* Read and execute command.  */\n-      cmd_t cmd = CMD_SHUTDOWN;\n-      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n-\tCOIERROR (\"Cannot read from main pipe.\");\n-\n-      switch (cmd)\n-\t{\n-\tcase CMD_BUFFER_COPY:\n-\t  {\n-\t    uint64_t len;\n-\t    void *dest, *source;\n-\n-\t    /* Receive data from host.  */\n-\t    READ (pipe_host2tgt, &dest, sizeof (void *));\n-\t    READ (pipe_host2tgt, &source, sizeof (void *));\n-\t    READ (pipe_host2tgt, &len, sizeof (uint64_t));\n-\n-\t    /* Copy.  */\n-\t    memcpy (dest, source, len);\n-\n-\t    /* Notify host about completion.  */\n-\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n-\n-\t    break;\n-\t  }\n-\tcase CMD_BUFFER_MAP:\n-\t  {\n-\t    char *name;\n-\t    size_t len;\n-\t    uint64_t buffer_len;\n-\t    void *buffer;\n-\n-\t    /* Receive data from host.  */\n-\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n-\t    MALLOC (char *, name, len);\n-\t    READ (pipe_host2tgt, name, len);\n-\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n-\n-\t    /* Open shared memory.  */\n-\t    int fd = shm_open (name, O_CLOEXEC | O_RDWR, S_IRUSR | S_IWUSR);\n-\t    if (fd < 0)\n-\t      COIERROR (\"Cannot open shared memory.\");\n-\n-\t    /* Map shared memory.  */\n-\t    buffer = mmap (NULL, buffer_len, PROT_READ | PROT_WRITE,\n-\t\t\t   MAP_SHARED, fd, 0);\n-\t    if (buffer == NULL)\n-\t      COIERROR (\"Cannot map shared memory.\");\n-\n-\t    /* Send data to host.  */\n-\t    WRITE (pipe_tgt2host, &fd, sizeof (int));\n-\t    WRITE (pipe_tgt2host, &buffer, sizeof (void *));\n-\n-\t    /* Clean up.  */\n-\t    free (name);\n-\n-\t    break;\n-\t  }\n-\tcase CMD_BUFFER_UNMAP:\n-\t  {\n-\t    int fd;\n-\t    uint64_t buffer_len;\n-\t    void *buffer;\n-\n-\t    /* Receive data from host.  */\n-\t    READ (pipe_host2tgt, &fd, sizeof (int));\n-\t    READ (pipe_host2tgt, &buffer, sizeof (void *));\n-\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n-\n-\t    /* Unmap buffer.  */\n-\t    if (munmap (buffer, buffer_len) < 0)\n-\t      COIERROR (\"Cannot unmap shared memory.\");\n-\n-\t    /* Close shared memory.  */\n-\t    if (close (fd) < 0)\n-\t      COIERROR (\"Cannot close shared memory file.\");\n-\n-\t    /* Notify host about completion.  */\n-\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n-\n-\t    break;\n-\t  }\n-\tcase CMD_GET_FUNCTION_HANDLE:\n-\t  {\n-\t    char *name;\n-\t    size_t len;\n-\n-\t    /* Receive data from host.  */\n-\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n-\t    MALLOC (char *, name, len);\n-\t    READ (pipe_host2tgt, name, len);\n-\n-\t    /* Find function.  */\n-\t    void *ptr = dlsym (RTLD_DEFAULT, name);\n-\t    if (ptr == NULL)\n-\t      COIERROR (\"Cannot find symbol %s.\", name);\n-\n-\t    /* Send data to host.  */\n-\t    WRITE (pipe_tgt2host, &ptr, sizeof (void *));\n-\n-\t    /* Clean up.  */\n-\t    free (name);\n-\n-\t    break;\n-\t  }\n-\tcase CMD_OPEN_LIBRARY:\n-\t  {\n-\t    char *lib_path;\n-\t    size_t len;\n-\n-\t    /* Receive data from host.  */\n-\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n-\t    MALLOC (char *, lib_path, len);\n-\t    READ (pipe_host2tgt, lib_path, len);\n-\n-\t    /* Open library.  */\n-\t    void *handle = dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL);\n-\t    if (handle == NULL)\n-\t      COIERROR (\"Cannot load %s: %s\", lib_path, dlerror ());\n-\n-\t    /* Send data to host.  */\n-\t    WRITE (pipe_tgt2host, &handle, sizeof (void *));\n-\n-\t    /* Clean up.  */\n-\t    free (lib_path);\n-\n-\t    break;\n-\t  }\n-\tcase CMD_CLOSE_LIBRARY:\n-\t  {\n-\t    /* Receive data from host.  */\n-\t    void *handle;\n-\t    READ (pipe_host2tgt, &handle, sizeof (void *));\n-\n-\t    dlclose (handle);\n-\n-\t    break;\n-\t  }\n-\tcase CMD_PIPELINE_CREATE:\n-\t  {\n-\t    /* Receive data from host.  */\n-\t    uint32_t *pipeline_num;\n-\t    MALLOC (uint32_t *, pipeline_num, sizeof (uint32_t));\n-\t    READ (pipe_host2tgt, pipeline_num, sizeof (*pipeline_num));\n-\n-\t    /* Create a new thread for the pipeline.  */\n-\t    pthread_t thread;\n-\t    if (pthread_create (&thread, NULL, pipeline_thread_routine,\n-\t\t\t\tpipeline_num))\n-\t      COIERROR (\"Cannot create new thread.\");\n-\t    break;\n-\t  }\n-\tcase CMD_SHUTDOWN:\n-\t  if (close (pipe_host2tgt) < 0)\n-\t    COIERROR (\"Cannot close host-to-target main pipe.\");\n-\t  if (close (pipe_tgt2host) < 0)\n-\t    COIERROR (\"Cannot close target-to-host main pipe.\");\n-\t  return COI_SUCCESS;\n-\tdefault:\n-\t  COIERROR (\"Unrecognizable command from host.\");\n-\t}\n-    }\n-\n-  return COI_ERROR;\n-}\n-\n-\n-\n-uint64_t\n-SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n-{\n-  COITRACE (\"COIPerfGetCycleFrequency\");\n-\n-  return (uint64_t) CYCLE_FREQUENCY;\n-}\n-\n-} // extern \"C\"\n-"}, {"sha": "a3778baa6a2a86000625e502ad2d63937835bab7", "filename": "liboffloadmic/runtime/emulator/coi_device.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,66 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef COI_DEVICE_H_INCLUDED\n-#define COI_DEVICE_H_INCLUDED\n-\n-#include \"coi_common.h\"\n-\n-#define COIERROR(...)\t\t\t    \\\n-{\t\t\t\t\t    \\\n-  fprintf (stderr, \"COI ERROR - TARGET: \"); \\\n-  fprintf (stderr, __VA_ARGS__);\t    \\\n-  fprintf (stderr, \"\\n\");\t\t    \\\n-  perror (NULL);\t\t\t    \\\n-  return COI_ERROR;\t\t\t    \\\n-}\n-\n-/* Like COIERROR, but return NULL instead of COIRESULT.  */\n-#define COIERRORN(...)\t\t\t    \\\n-{\t\t\t\t\t    \\\n-  fprintf (stderr, \"COI ERROR - TARGET: \"); \\\n-  fprintf (stderr, __VA_ARGS__);\t    \\\n-  fprintf (stderr, \"\\n\");\t\t    \\\n-  perror (NULL);\t\t\t    \\\n-  return NULL;\t\t\t\t    \\\n-}\n-\n-#ifdef DEBUG\n-  #define COITRACE(...)\t\t\t      \\\n-  {\t\t\t\t\t      \\\n-    fprintf (stderr, \"COI TRACE - TARGET: \"); \\\n-    fprintf (stderr, __VA_ARGS__);\t      \\\n-    fprintf (stderr, \"\\n\");\t\t      \\\n-  }\n-#else\n-  #define COITRACE(...) {}\n-#endif\n-\n-\n-#endif // COI_DEVICE_H_INCLUDED"}, {"sha": "6170d8d7f3d669bdde009bfaaf32a5cd9ab0878c", "filename": "liboffloadmic/runtime/emulator/coi_host.cpp", "status": "removed", "additions": 0, "deletions": 1634, "changes": 1634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,1634 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#include <set>\n-#include <map>\n-#include <queue>\n-\n-#include \"coi_host.h\"\n-\n-#include \"coi_version_asm.h\"\n-\n-#define CYCLE_FREQUENCY     1000000000\n-\n-enum buffer_t\n-{\n-  BUFFER_NORMAL,\n-  BUFFER_MEMORY\n-};\n-\n-struct Engine\n-{\n-  COI_ISA_TYPE type;\n-  uint32_t index;\n-  char *dir;\n-};\n-\n-struct Function\n-{\n-  void *ptr;\n-  uint32_t num_buffers;\n-  uint64_t *bufs_size;\n-  void * *bufs_data_target;\n-  uint16_t misc_data_len;\n-  void *misc_data;\n-  uint16_t return_value_len;\n-  void *return_value;\n-  COIEVENT completion_event;\n-};\n-\n-struct Callback\n-{\n-  COI_EVENT_CALLBACK ptr;\n-  const void *data;\n-};\n-\n-struct Process\n-{\n-  pid_t pid;\n-  int pipe_host2tgt;\n-  int pipe_tgt2host;\n-  Engine *engine;\n-  void **functions;\n-};\n-\n-struct Pipeline\n-{\n-  pthread_t thread;\n-  bool destroy;\n-  bool is_destroyed;\n-  char *pipe_host2tgt_path;\n-  char *pipe_tgt2host_path;\n-  int pipe_host2tgt;\n-  int pipe_tgt2host;\n-  std::queue<Function> queue;\n-  Process *process;\n-};\n-\n-struct Buffer\n-{\n-  buffer_t type;\n-  char *name;\n-  int fd;\n-  int fd_target;\n-  uint64_t size;\n-  void *data;\n-  void *data_target;\n-  Process *process;\n-};\n-\n-\n-/* Environment variables.  */\n-extern char **environ;\n-\n-/* List of directories for removing on exit.  */\n-static char **tmp_dirs;\n-static unsigned tmp_dirs_num;\n-\n-/* Number of emulated MIC engines.  */\n-static long num_engines;\n-\n-/* Number of the last COI pipeline.  */\n-static uint32_t max_pipeline_num;\n-\n-/* Set of undestroyed pipelines.  */\n-static std::set<Pipeline *> pipelines;\n-\n-/* Number of the last COI event, the event #0 is always signalled.  */\n-static uint64_t max_event_num = 1;\n-\n-/* Set of created COI events, which are not signalled.  */\n-static std::set<uint64_t> non_signalled_events;\n-\n-/* Set of COI events, which encountered errors.  */\n-static std::map<uint64_t, COIRESULT> errored_events;\n-\n-/* Set of registered callbacks, indexed by event number.  */\n-static std::map<uint64_t, Callback> callbacks;\n-\n-/* Mutex to sync parallel execution.  */\n-static pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n-\n-\n-static COIRESULT\n-read_long_env (const char *env_name, long *var, long var_default)\n-{\n-  char *str = getenv (env_name);\n-  char *s;\n-\n-  if (!str || *str == '\\0')\n-    *var = var_default;\n-  else\n-    {\n-      errno = 0;\n-      *var = strtol (str, &s, 0);\n-      if (errno != 0 || s == str || *s != '\\0')\n-\tCOIERROR (\"Variable %s has invalid value.\", env_name);\n-    }\n-\n-  return COI_SUCCESS;\n-}\n-\n-__attribute__((constructor))\n-static void\n-init ()\n-{\n-  if (read_long_env (OFFLOAD_EMUL_NUM_ENV, &num_engines, 1) == COI_ERROR)\n-    exit (0);\n-}\n-\n-\n-/* Helper function for directory removing.  */\n-static COIRESULT remove_directory (char *path)\n-{\n-  char *file;\n-  struct dirent *entry;\n-  struct stat statfile;\n-  DIR *dir = opendir (path);\n-  if (dir == NULL)\n-    COIERROR (\"Cannot open directory %s.\", dir);\n-\n-  while (entry = readdir (dir))\n-    {\n-      if (!strcmp (entry->d_name, \".\") || !strcmp (entry->d_name, \"..\"))\n-\tcontinue;\n-\n-      MALLOC (char *, file, strlen (path) + strlen (entry->d_name) + 2);\n-      sprintf (file, \"%s/%s\", path, entry->d_name);\n-\n-      if (stat (file, &statfile) < 0)\n-\tCOIERROR (\"Cannot retrieve information about file %s.\", file);\n-\n-      if (S_ISDIR (statfile.st_mode))\n-\t{\n-\t  if (remove_directory (file) == COI_ERROR)\n-\t    return COI_ERROR;\n-\t}\n-      else\n-\t{\n-\t  if (unlink (file) < 0)\n-\t    COIERROR (\"Cannot unlink file %s.\", file);\n-\t}\n-\n-      free (file);\n-    }\n-\n-  if (closedir (dir) < 0)\n-    COIERROR (\"Cannot close directory %s.\", path);\n-  if (rmdir (path) < 0)\n-    COIERROR (\"Cannot remove directory %s.\", path);\n-\n-  return COI_SUCCESS;\n-}\n-\n-__attribute__((destructor))\n-static void\n-cleanup ()\n-{\n-  for (unsigned i = 0; i < tmp_dirs_num; i++)\n-    {\n-      remove_directory (tmp_dirs[i]);\n-      free (tmp_dirs[i]);\n-    }\n-  free (tmp_dirs);\n-}\n-\n-static COIRESULT\n-start_critical_section ()\n-{\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n-  return COI_SUCCESS;\n-}\n-\n-static COIRESULT\n-finish_critical_section ()\n-{\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n-  return COI_SUCCESS;\n-}\n-\n-static bool\n-pipeline_is_destroyed (const Pipeline *pipeline)\n-{\n-  start_critical_section ();\n-  bool res = pipeline->is_destroyed;\n-  finish_critical_section ();\n-  return res;\n-}\n-\n-static void\n-maybe_invoke_callback (const COIEVENT event, const COIRESULT result)\n-{\n-  std::map<uint64_t, Callback>::iterator cb = callbacks.find (event.opaque[0]);\n-\n-  if (cb != callbacks.end ())\n-    {\n-      Callback callback = cb->second;\n-      callback.ptr (event, result, callback.data);\n-      callbacks.erase (cb);\n-    }\n-}\n-\n-static void\n-signal_event (const COIEVENT event, const COIRESULT result)\n-{\n-  if (result != COI_SUCCESS)\n-    errored_events.insert (std::pair <uint64_t, COIRESULT> (event.opaque[0],\n-\t\t\t\t\t\t\t    result));\n-  non_signalled_events.erase (event.opaque[0]);\n-\n-  maybe_invoke_callback (event, result);\n-}\n-\n-static COIRESULT\n-get_event_result (const COIEVENT event)\n-{\n-  COIRESULT res = COI_SUCCESS;\n-\n-  std::map<uint64_t, COIRESULT>::iterator ee\n-    = errored_events.find (event.opaque[0]);\n-\n-  if (ee != errored_events.end ())\n-    res = ee->second;\n-\n-  return res;\n-}\n-\n-\n-extern \"C\"\n-{\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER in_DestBuffer,\n-\t\t\t\t   COIBUFFER in_SourceBuffer,\n-\t\t\t\t   uint64_t in_DestOffset,\n-\t\t\t\t   uint64_t in_SourceOffset,\n-\t\t\t\t   uint64_t in_Length,\n-\t\t\t\t   COI_COPY_TYPE in_Type,\n-\t\t\t\t   uint32_t in_NumDependencies,\n-\t\t\t\t   const COIEVENT *in_pDependencies,  // Ignored\n-\t\t\t\t   COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIBufferCopy\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_DestBuffer != NULL);\n-  assert (in_SourceBuffer != NULL);\n-  assert (in_Type == COI_COPY_UNSPECIFIED);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Convert input arguments.  */\n-  Buffer *dest = (Buffer *) in_DestBuffer;\n-  Buffer *source = (Buffer *) in_SourceBuffer;\n-\n-  start_critical_section ();\n-\n-  /* Map buffers if needed.  */\n-  if (dest->data == 0 && dest->type == BUFFER_NORMAL)\n-    if (COIBufferMap (in_DestBuffer, 0, dest->size, (COI_MAP_TYPE) 0,\n-\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-  if (source->data == 0 && source->type == BUFFER_NORMAL)\n-    if (COIBufferMap (in_SourceBuffer, 0, source->size, (COI_MAP_TYPE) 0,\n-\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  /* Copy data.  */\n-  if (source->data != 0 && dest->data != 0)\n-    memcpy ((void *) ((uintptr_t) dest->data + in_DestOffset),\n-\t    (void *) ((uintptr_t) source->data + in_SourceOffset), in_Length);\n-  else\n-    {\n-      assert (dest->process == source->process);\n-\n-      Buffer *buffer;\n-      cmd_t cmd = CMD_BUFFER_COPY;\n-\n-      /* Create intermediary buffer.  */\n-      if (COIBufferCreate (in_Length, COI_BUFFER_NORMAL, 0, 0, 1,\n-\t\t\t   (COIPROCESS*) &dest->process,\n-\t\t\t   (COIBUFFER *) &buffer) == COI_ERROR)\n-\treturn COI_ERROR;\n-\n-      int pipe_host2tgt = dest->process->pipe_host2tgt;\n-      int pipe_tgt2host = dest->process->pipe_tgt2host;\n-\n-      /* Copy from source to intermediary buffer.  */\n-      if (source->data == 0)\n-\t{\n-\t  assert (source->data_target != 0);\n-\n-\t  /* Send data to target.  */\n-\t  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-\t  WRITE (pipe_host2tgt, &buffer->data_target, sizeof (void *));\n-\t  WRITE (pipe_host2tgt, &source->data_target, sizeof (void *));\n-\t  WRITE (pipe_host2tgt, &buffer->size, sizeof (uint64_t));\n-\n-\t  /* Receive data from target.  */\n-\t  READ (pipe_tgt2host, &cmd, sizeof (cmd_t));\n-\t}\n-      else\n-\t{\n-\t  if (COIBufferCopy ((COIBUFFER) buffer, in_SourceBuffer, 0,\n-\t\t\t     in_SourceOffset, in_Length, in_Type, 0, 0, 0)\n-\t      == COI_ERROR)\n-\t    return COI_ERROR;\n-\t}\n-\n-      /* Copy from intermediary buffer to dest.  */\n-      if (dest->data == 0)\n-\t{\n-\t  assert (dest->data_target != 0);\n-\n-\t  /* Send data to target.  */\n-\t  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-\t  WRITE (pipe_host2tgt, &dest->data_target, sizeof (void *));\n-\t  WRITE (pipe_host2tgt, &buffer->data_target, sizeof (void *));\n-\t  WRITE (pipe_host2tgt, &buffer->size, sizeof (uint64_t));\n-\n-\t  /* Receive data from target.  */\n-\t  READ (pipe_tgt2host, &cmd, sizeof (cmd_t));\n-\t}\n-      else\n-\t{\n-\t  if (COIBufferCopy (in_DestBuffer, (COIBUFFER) buffer, in_DestOffset,\n-\t\t\t     0, in_Length, in_Type, 0, 0, 0) == COI_ERROR)\n-\t    return COI_ERROR;\n-\t}\n-\n-      /* Unmap on target and destroy intermediary buffer.  */\n-      if (COIBufferDestroy ((COIBUFFER) buffer) == COI_ERROR)\n-\treturn COI_ERROR;\n-    }\n-\n-  /* Unmap buffers if needed.  */\n-  if (dest->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) dest, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-  if (source->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) source, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  finish_critical_section ();\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t in_Size,\n-\t\t\t\t     COI_BUFFER_TYPE in_Type,\n-\t\t\t\t     uint32_t in_Flags,\n-\t\t\t\t     const void *in_pInitData,\n-\t\t\t\t     uint32_t in_NumProcesses,\n-\t\t\t\t     const COIPROCESS *in_pProcesses,\n-\t\t\t\t     COIBUFFER *out_pBuffer)\n-{\n-  COITRACE (\"COIBufferCreate\");\n-\n-  char *shm_name;\n-  int shm_fd;\n-  const int ullong_max_len = 20;\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Type == COI_BUFFER_NORMAL || in_Type == COI_BUFFER_OPENCL);\n-  assert ((in_Flags & COI_SINK_MEMORY) == 0);\n-  assert ((in_Flags & COI_SAME_ADDRESS_SINKS) == 0);\n-  assert ((in_Flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n-  assert (in_pInitData == NULL);\n-  assert (in_NumProcesses == 1);\n-  assert (in_pProcesses != NULL);\n-  assert (out_pBuffer != NULL);\n-\n-  /* Create shared memory with an unique name.  */\n-  MALLOC (char *, shm_name, strlen (SHM_NAME) + ullong_max_len + 1);\n-  for (unsigned long long i = 0; i >= 0; i++)\n-    {\n-      sprintf (shm_name, SHM_NAME \"%lu\", i);\n-      shm_fd = shm_open (shm_name, O_CLOEXEC | O_CREAT | O_EXCL | O_RDWR,\n-\t\t\t S_IRUSR | S_IWUSR);\n-      if (shm_fd > 0)\n-\tbreak;\n-    }\n-  if (ftruncate (shm_fd, in_Size) < 0)\n-    COIERROR (\"Cannot truncate shared memory file.\");\n-\n-  /* Create buffer.  */\n-  Buffer *buf = new Buffer;\n-  buf->data = 0;\n-  buf->fd = shm_fd;\n-  buf->process = (Process *) in_pProcesses[0];\n-  buf->size = in_Size;\n-  buf->type = BUFFER_NORMAL;\n-  STRDUP (buf->name, shm_name);\n-\n-  /* Map buffer on target.  */\n-  size_t len = strlen (buf->name) + 1;\n-\n-  start_critical_section ();\n-\n-  /* Send data to target.  */\n-  const cmd_t cmd = CMD_BUFFER_MAP;\n-  int pipe_host2tgt = buf->process->pipe_host2tgt;\n-  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-  WRITE (pipe_host2tgt, &len, sizeof (size_t));\n-  WRITE (pipe_host2tgt, buf->name, len);\n-  WRITE (pipe_host2tgt, &buf->size, sizeof (uint64_t));\n-\n-  /* Receive data from target.  */\n-  int pipe_tgt2host = buf->process->pipe_tgt2host;\n-  READ (pipe_tgt2host, &buf->fd_target, sizeof (int));\n-  READ (pipe_tgt2host, &buf->data_target, sizeof (void *));\n-\n-  finish_critical_section ();\n-\n-  /* Prepare output arguments.  */\n-  *out_pBuffer = (COIBUFFER) buf;\n-\n-  /* Clean up.  */\n-  free (shm_name);\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferCreateFromMemory, 1) (uint64_t in_Size,\n-\t\t\t\t\t       COI_BUFFER_TYPE in_Type,\n-\t\t\t\t\t       uint32_t in_Flags,\n-\t\t\t\t\t       void *in_Memory,\n-\t\t\t\t\t       uint32_t in_NumProcesses,\n-\t\t\t\t\t       const COIPROCESS *in_pProcesses,\n-\t\t\t\t\t       COIBUFFER *out_pBuffer)\n-{\n-  COITRACE (\"COIBufferCreateFromMemory\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Type == COI_BUFFER_NORMAL);\n-  assert ((in_Flags & COI_SAME_ADDRESS_SINKS) == 0);\n-  assert ((in_Flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n-  assert (in_NumProcesses == 1);\n-  assert (in_pProcesses != NULL);\n-  assert (out_pBuffer != NULL);\n-\n-  /* Create buffer.  */\n-  Buffer *buf = new Buffer;\n-  buf->data = (in_Flags & COI_SINK_MEMORY) == 0 ? in_Memory : 0;\n-  buf->data_target = (in_Flags & COI_SINK_MEMORY) != 0 ? in_Memory : 0;\n-  buf->process = (Process *) in_pProcesses[0];\n-  buf->size = in_Size;\n-  buf->type = BUFFER_MEMORY;\n-\n-  /* Prepare output argument.  */\n-  *out_pBuffer = (COIBUFFER) buf;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferDestroy, 1) (COIBUFFER in_Buffer)\n-{\n-  COITRACE (\"COIBufferDestroy\");\n-\n-  cmd_t cmd = CMD_BUFFER_UNMAP;\n-\n-  assert (in_Buffer != NULL);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) in_Buffer;\n-\n-  /* Unmap buffer on host.  */\n-  if (buf->data != 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) in_Buffer, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  /* Unmap buffer on target.  */\n-  if (buf->data_target != 0)\n-    {\n-      start_critical_section ();\n-\n-      /* Send data to target.  */\n-      int pipe_host2tgt = buf->process->pipe_host2tgt;\n-      WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n-      WRITE (pipe_host2tgt, &buf->fd_target, sizeof (int));\n-      WRITE (pipe_host2tgt, &buf->data_target, sizeof (void *));\n-      WRITE (pipe_host2tgt, &buf->size, sizeof (uint64_t));\n-\n-      /* Receive data from target.  */\n-      READ (buf->process->pipe_tgt2host, &cmd, sizeof (cmd_t));\n-\n-      finish_critical_section ();\n-    }\n-\n-  /* Unlink shared memory.  */\n-  if (buf->type == BUFFER_NORMAL)\n-    {\n-      if (close (buf->fd) < 0)\n-\tCOIERROR (\"Cannot close shared memory file.\");\n-      if (shm_unlink (buf->name) < 0)\n-\tCOIERROR (\"Cannot unlink shared memory.\");\n-      free (buf->name);\n-    }\n-\n-  /* Clean up.  */\n-  delete buf;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferGetSinkAddress, 1) (COIBUFFER in_Buffer,\n-\t\t\t\t\t     uint64_t *out_pAddress)\n-{\n-  COITRACE (\"COIBufferGetSinkAddress\");\n-\n-  assert (in_Buffer != NULL);\n-  assert (out_pAddress != NULL);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) in_Buffer;\n-\n-  /* Here should come BUFFER_NORMAL buffer.  */\n-  assert (buf->type == BUFFER_NORMAL);\n-\n-  /* Prepare output argument.  */\n-  *out_pAddress = (uint64_t) buf->data_target;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferMap, 1) (COIBUFFER in_Buffer,\n-\t\t\t\t  uint64_t in_Offset,\n-\t\t\t\t  uint64_t in_Length,\t\t    // Ignored\n-\t\t\t\t  COI_MAP_TYPE in_Type,\t\t    // Ignored\n-\t\t\t\t  uint32_t in_NumDependencies,\n-\t\t\t\t  const COIEVENT *in_pDependencies, // Ignored\n-\t\t\t\t  COIEVENT *out_pCompletion,\n-\t\t\t\t  COIMAPINSTANCE *out_pMapInstance,\n-\t\t\t\t  void **out_ppData)\n-{\n-  COITRACE (\"COIBufferMap\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Offset == 0);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) in_Buffer;\n-\n-  /* Only BUFFER_NORMAL buffers should come here.  */\n-  assert (buf->type == BUFFER_NORMAL);\n-\n-  /* Map shared memory.  */\n-  buf->data = mmap (NULL, buf->size, PROT_READ | PROT_WRITE,\n-\t\t    MAP_SHARED, buf->fd, 0);\n-  if (buf->data == NULL)\n-    COIERROR (\"Cannot map shared memory.\");\n-\n-  /* Prepare output arguments.  */\n-  if (out_pMapInstance != 0)\n-    *out_pMapInstance = (COIMAPINSTANCE) buf;\n-  if (out_ppData != 0)\n-    *out_ppData = buf->data;\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferRead, 1) (COIBUFFER in_SourceBuffer,\n-\t\t\t\t   uint64_t in_Offset,\n-\t\t\t\t   void *in_pDestData,\n-\t\t\t\t   uint64_t in_Length,\n-\t\t\t\t   COI_COPY_TYPE in_Type,\n-\t\t\t\t   uint32_t in_NumDependencies,\n-\t\t\t\t   const COIEVENT *in_pDependencies,  // Ignored\n-\t\t\t\t   COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIBufferRead\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_pDestData != NULL);\n-  assert (in_Type == COI_COPY_UNSPECIFIED);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) in_SourceBuffer;\n-\n-  start_critical_section ();\n-\n-  /* Map buffers if needed.  */\n-  if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferMap (in_SourceBuffer, 0, buf->size, (COI_MAP_TYPE) 0, 0, 0, 0,\n-\t\t      0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  /* Copy data.  */\n-  memcpy (in_pDestData, (void *) ((uintptr_t) buf->data + in_Offset),\n-\t  in_Length);\n-\n-  /* Unmap buffers if needed.  */\n-  if (buf->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  finish_critical_section ();\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferSetState, 1) (COIBUFFER in_Buffer,\t\t  // Ignored\n-\t\t\t\t       COIPROCESS in_Process,\t\t  // Ignored\n-\t\t\t\t       COI_BUFFER_STATE in_State,\t  // Ignored\n-\t\t\t\t       COI_BUFFER_MOVE_FLAG in_DataMove,\n-\t\t\t\t       uint32_t in_NumDependencies,\n-\t\t\t\t       const COIEVENT *in_pDependencies,  // Ignored\n-\t\t\t\t       COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIBufferSetState\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_DataMove == COI_BUFFER_NO_MOVE);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferUnmap, 1) (COIMAPINSTANCE in_MapInstance,\n-\t\t\t\t    uint32_t in_NumDependencies,\n-\t\t\t\t    const COIEVENT *in_pDependencies, // Ignored\n-\t\t\t\t    COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIBufferUnmap\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_MapInstance != NULL);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buffer = (Buffer *) in_MapInstance;\n-\n-  /* Only BUFFER_NORMAL buffers should come here.  */\n-  assert (buffer->type == BUFFER_NORMAL);\n-\n-  /* Unmap shared memory.  */\n-  if (munmap (buffer->data, buffer->size) < 0)\n-    COIERROR (\"Cannot unmap shared memory.\");\n-\n-  buffer->data = 0;\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIBufferWrite, 1) (COIBUFFER in_DestBuffer,\n-\t\t\t\t    uint64_t in_Offset,\n-\t\t\t\t    const void *in_pSourceData,\n-\t\t\t\t    uint64_t in_Length,\n-\t\t\t\t    COI_COPY_TYPE in_Type,\n-\t\t\t\t    uint32_t in_NumDependencies,\n-\t\t\t\t    const COIEVENT *in_pDependencies, // Ignored\n-\t\t\t\t    COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIBufferWrite\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_DestBuffer != NULL);\n-  assert (in_pSourceData != NULL);\n-  assert (in_Type == COI_COPY_UNSPECIFIED);\n-  assert (in_NumDependencies == 0);\n-\n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) in_DestBuffer;\n-\n-  start_critical_section ();\n-\n-  /* Map buffers if needed.  */\n-  if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferMap (in_DestBuffer, 0, buf->size, (COI_MAP_TYPE) 0, 0, 0, 0, 0,\n-\t\t      0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  /* Copy data.  */\n-  memcpy ((void *) ((uintptr_t) buf->data + in_Offset), in_pSourceData,\n-\t  in_Length);\n-\n-  /* Unmap buffers if needed.  */\n-  if (buf->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n-      return COI_ERROR;\n-\n-  finish_critical_section ();\n-\n-  if (out_pCompletion)\n-    out_pCompletion->opaque[0] = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEngineGetCount, 1) (COI_ISA_TYPE isa,\n-\t\t\t\t       uint32_t *count)\n-{\n-  COITRACE (\"COIEngineGetCount\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (isa == COI_ISA_MIC);\n-  assert (count != NULL);\n-\n-  /* Prepare output arguments.  */\n-  *count = num_engines;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEngineGetHandle, 1) (COI_ISA_TYPE in_ISA,\n-\t\t\t\t\tuint32_t in_EngineIndex,\n-\t\t\t\t\tCOIENGINE *out_pEngineHandle)\n-{\n-  COITRACE (\"COIEngineGetHandle\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_ISA == COI_ISA_MIC);\n-  assert (out_pEngineHandle != NULL);\n-\n-  /* Check engine index.  */\n-  if (in_EngineIndex >= num_engines)\n-    COIERROR (\"Wrong engine index.\");\n-\n-  /* Create engine handle.  */\n-  Engine *engine = new Engine;\n-  engine->dir = NULL;\n-  engine->index = in_EngineIndex;\n-  engine->type = in_ISA;\n-\n-  /* Prepare output argument.  */\n-  *out_pEngineHandle = (COIENGINE) engine;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEventWait, 1) (uint16_t in_NumEvents,\n-\t\t\t\t  const COIEVENT *in_pEvents,\n-\t\t\t\t  int32_t in_TimeoutMilliseconds,\n-\t\t\t\t  uint8_t in_WaitForAll,\n-\t\t\t\t  uint32_t *out_pNumSignaled,\n-\t\t\t\t  uint32_t *out_pSignaledIndices)\n-{\n-  COITRACE (\"COIEventWait\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_pEvents != NULL);\n-  assert (in_TimeoutMilliseconds == 0 || in_TimeoutMilliseconds == -1);\n-  assert (in_WaitForAll == 1);\n-  assert (out_pNumSignaled == NULL);\n-  assert (out_pSignaledIndices == NULL);\n-\n-  if (in_TimeoutMilliseconds == 0)\n-    {\n-      /* If some event is not signalled, return timeout error.  */\n-      for (uint16_t i = 0; i < in_NumEvents; i++)\n-\tif (non_signalled_events.count (in_pEvents[i].opaque[0]) > 0)\n-\t  return COI_TIME_OUT_REACHED;\n-\telse\n-\t  {\n-\t    /* If the event signalled with an error, return that error.  */\n-\t    start_critical_section ();\n-\t    COIRESULT res = get_event_result (in_pEvents[i]);\n-\t    finish_critical_section ();\n-\t    if (res != COI_SUCCESS)\n-\t      return res;\n-\t  }\n-    }\n-  else\n-    {\n-      /* Wait indefinitely for all events.  */\n-      for (uint16_t i = 0; i < in_NumEvents; i++)\n-\t{\n-\t  while (non_signalled_events.count (in_pEvents[i].opaque[0]) > 0)\n-\t    usleep (1000);\n-\n-\t  /* If the event signalled with an error, return that error.  */\n-\t  start_critical_section ();\n-\t  COIRESULT res = get_event_result (in_pEvents[i]);\n-\t  finish_critical_section ();\n-\t  if (res != COI_SUCCESS)\n-\t    return res;\n-\t}\n-    }\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEventRegisterCallback, 1) (const COIEVENT in_Event,\n-\t\t\t\t\t      COI_EVENT_CALLBACK in_Callback,\n-\t\t\t\t\t      const void *in_UserData,\n-\t\t\t\t\t      const uint64_t in_Flags)\n-{\n-  COITRACE (\"COIEventRegisterCallback\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Callback != NULL);\n-  assert (in_UserData != NULL);\n-  assert (in_Flags == 0);\n-\n-  start_critical_section ();\n-  if (non_signalled_events.count (in_Event.opaque[0]) == 0)\n-    {\n-      /* If the event is already signalled, invoke the callback immediately.  */\n-      COIRESULT res = get_event_result (in_Event);\n-      in_Callback (in_Event, res, in_UserData);\n-    }\n-  else\n-    {\n-      Callback callback;\n-      callback.ptr = in_Callback;\n-      callback.data = in_UserData;\n-      callbacks.insert (std::pair <uint64_t, Callback> (in_Event.opaque[0],\n-\t\t\t\t\t\t\tcallback));\n-    }\n-  finish_critical_section ();\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-/* The start routine for the COI pipeline thread.  */\n-\n-static void *\n-pipeline_thread_routine (void *in_Pipeline)\n-{\n-  /* Convert input arguments.  */\n-  Pipeline *pipeline = (Pipeline *) in_Pipeline;\n-\n-  /* Open pipes.  */\n-  pipeline->pipe_host2tgt\n-    = open (pipeline->pipe_host2tgt_path, O_CLOEXEC | O_WRONLY);\n-  if (pipeline->pipe_host2tgt < 0)\n-    COIERRORN (\"Cannot open host-to-target pipe.\");\n-  pipeline->pipe_tgt2host\n-    = open (pipeline->pipe_tgt2host_path, O_CLOEXEC | O_RDONLY);\n-  if (pipeline->pipe_tgt2host < 0)\n-    COIERRORN (\"Cannot open target-to-host pipe.\");\n-\n-  free (pipeline->pipe_host2tgt_path);\n-  free (pipeline->pipe_tgt2host_path);\n-  pipeline->pipe_host2tgt_path = NULL;\n-  pipeline->pipe_tgt2host_path = NULL;\n-\n-  while (!pipeline->destroy)\n-    if (pipeline->queue.empty ())\n-      usleep (1000);\n-    else\n-      {\n-\tFunction func = pipeline->queue.front ();\n-\tstart_critical_section ();\n-\tpipeline->queue.pop ();\n-\tfinish_critical_section ();\n-\n-\t/* Send data to target.  */\n-\tcmd_t cmd = CMD_PIPELINE_RUN_FUNCTION;\n-\tWRITEN (pipeline->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-\tWRITEN (pipeline->pipe_host2tgt, &func.ptr, sizeof (void *));\n-\tWRITEN (pipeline->pipe_host2tgt, &func.num_buffers, sizeof (uint32_t));\n-\tfor (uint32_t i = 0; i < func.num_buffers; i++)\n-\t  {\n-\t    WRITEN (pipeline->pipe_host2tgt, &func.bufs_size[i],\n-\t\t    sizeof (uint64_t));\n-\t    WRITEN (pipeline->pipe_host2tgt, &func.bufs_data_target[i],\n-\t\t    sizeof (void *));\n-\t  }\n-\tWRITEN (pipeline->pipe_host2tgt, &func.misc_data_len,\n-\t\tsizeof (uint16_t));\n-\tif (func.misc_data_len > 0)\n-\t  WRITEN (pipeline->pipe_host2tgt, func.misc_data, func.misc_data_len);\n-\tWRITEN (pipeline->pipe_host2tgt, &func.return_value_len,\n-\t\tsizeof (uint16_t));\n-\n-\tdelete [] func.bufs_size;\n-\tdelete [] func.bufs_data_target;\n-\n-\t/* Receive data from target.  Wait for target function to complete,\n-\t   whether it has any data to return or not.  */\n-\tbool has_return_value = func.return_value_len > 0;\n-\tint ret_len\n-\t  = read (pipeline->pipe_tgt2host,\n-\t\t  has_return_value ? func.return_value : &cmd,\n-\t\t  has_return_value ? func.return_value_len : sizeof (cmd_t));\n-\tif (ret_len == 0)\n-\t  {\n-\t    start_critical_section ();\n-\t    signal_event (func.completion_event, COI_PROCESS_DIED);\n-\t    pipeline->is_destroyed = true;\n-\t    finish_critical_section ();\n-\t    return NULL;\n-\t  }\n-\telse if (ret_len != (has_return_value ? func.return_value_len\n-\t\t\t\t\t      : sizeof (cmd_t)))\n-\t  COIERRORN (\"Cannot read from pipe.\");\n-\n-\tstart_critical_section ();\n-\tsignal_event (func.completion_event, COI_SUCCESS);\n-\tfinish_critical_section ();\n-      }\n-\n-  /* Send data to target.  */\n-  const cmd_t cmd = CMD_PIPELINE_DESTROY;\n-  WRITEN (pipeline->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-\n-  /* Close pipes.  */\n-  if (close (pipeline->pipe_host2tgt) < 0)\n-    COIERRORN (\"Cannot close host-to-target pipe.\");\n-  if (close (pipeline->pipe_tgt2host) < 0)\n-    COIERRORN (\"Cannot close target-to-host pipe.\");\n-\n-  start_critical_section ();\n-  pipeline->is_destroyed = true;\n-  finish_critical_section ();\n-  return NULL;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineCreate, 1) (COIPROCESS in_Process,\n-\t\t\t\t       COI_CPU_MASK in_Mask,\n-\t\t\t\t       uint32_t in_StackSize,\t    // Ignored\n-\t\t\t\t       COIPIPELINE *out_pPipeline)\n-{\n-  COITRACE (\"COIPipelineCreate\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Process != NULL);\n-  assert (in_Mask == 0);\n-  assert (out_pPipeline != NULL);\n-\n-  /* Convert input arguments.  */\n-  Process *proc = (Process *) in_Process;\n-\n-  start_critical_section ();\n-\n-  /* Create pipeline handle.  */\n-  Pipeline *pipeline = new Pipeline;\n-  pipeline->destroy = false;\n-  pipeline->is_destroyed = false;\n-  pipeline->process = proc;\n-  pipelines.insert (pipeline);\n-\n-  /* Create pipes.  */\n-  uint32_t pipeline_num = max_pipeline_num++;\n-  char *eng_dir = pipeline->process->engine->dir;\n-  MALLOC (char *, pipeline->pipe_host2tgt_path,\n-\t  strlen (eng_dir) + sizeof (PIPE_HOST2TGT_NAME \"0000000000\"));\n-  MALLOC (char *, pipeline->pipe_tgt2host_path,\n-\t  strlen (eng_dir) + sizeof (PIPE_TGT2HOST_NAME \"0000000000\"));\n-  sprintf (pipeline->pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"%010d\",\n-\t   eng_dir, pipeline_num);\n-  sprintf (pipeline->pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"%010d\",\n-\t   eng_dir, pipeline_num);\n-  if (mkfifo (pipeline->pipe_host2tgt_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create pipe %s.\", pipeline->pipe_host2tgt_path);\n-  if (mkfifo (pipeline->pipe_tgt2host_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create pipe %s.\", pipeline->pipe_tgt2host_path);\n-\n-  /* Send data to target.  */\n-  const cmd_t cmd = CMD_PIPELINE_CREATE;\n-  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-  WRITE (proc->pipe_host2tgt, &pipeline_num, sizeof (pipeline_num));\n-\n-  /* Create a new thread for the pipeline.  */\n-  if (pthread_create (&pipeline->thread, NULL, pipeline_thread_routine,\n-\t\t      pipeline))\n-    COIERROR (\"Cannot create new thread.\");\n-\n-  finish_critical_section ();\n-\n-  /* Prepare output arguments.  */\n-  *out_pPipeline = (COIPIPELINE) pipeline;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineDestroy, 1) (COIPIPELINE in_Pipeline)\n-{\n-  COITRACE (\"COIPipelineDestroy\");\n-\n-  assert (in_Pipeline != NULL);\n-\n-  /* Convert input arguments.  */\n-  Pipeline *pipeline = (Pipeline *) in_Pipeline;\n-\n-  start_critical_section ();\n-  /* Remove pipeline from the set of undestroyed pipelines.  */\n-  pipelines.erase (pipeline);\n-\n-  /* Exit pipeline thread.  */\n-  pipeline->destroy = true;\n-  finish_critical_section ();\n-\n-  while (!pipeline_is_destroyed (pipeline))\n-    usleep (1000);\n-\n-  /* Join with a destroyed thread.  */\n-  if (pthread_join (pipeline->thread, NULL))\n-    COIERROR (\"Cannot join with a thread.\");\n-\n-  delete pipeline;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineRunFunction, 1) (COIPIPELINE in_Pipeline,\n-\t\t\t\t\t    COIFUNCTION in_Function,\n-\t\t\t\t\t    uint32_t in_NumBuffers,\n-\t\t\t\t\t    const COIBUFFER *in_Buffers,\n-\t\t\t\t\t    const COI_ACCESS_FLAGS *in_pBufferAccessFlags, // Ignored\n-\t\t\t\t\t    uint32_t in_NumDependencies,\n-\t\t\t\t\t    const COIEVENT *in_pDependencies,\t\t   // Ignored\n-\t\t\t\t\t    const void *in_pMiscData,\n-\t\t\t\t\t    uint16_t in_MiscDataLen,\n-\t\t\t\t\t    void *out_pAsyncReturnValue,\n-\t\t\t\t\t    uint16_t in_AsyncReturnValueLen,\n-\t\t\t\t\t    COIEVENT *out_pCompletion)\n-{\n-  COITRACE (\"COIPipelineRunFunction\");\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Pipeline != NULL);\n-  assert (in_Function != NULL);\n-  assert (in_NumDependencies == 0);\n-\n-  Function func;\n-  func.ptr = (void *) in_Function;\n-  func.num_buffers = in_NumBuffers;\n-  func.bufs_size = new uint64_t [in_NumBuffers];\n-  func.bufs_data_target = new void * [in_NumBuffers];\n-  for (uint32_t i = 0; i < in_NumBuffers; i++)\n-    {\n-      Buffer **bufs = (Buffer **) in_Buffers;\n-      func.bufs_size[i] = bufs[i]->size;\n-      func.bufs_data_target[i] = bufs[i]->data_target;\n-    }\n-  func.misc_data = (void *) in_pMiscData;\n-  func.misc_data_len = in_MiscDataLen;\n-  func.return_value = out_pAsyncReturnValue;\n-  func.return_value_len = in_AsyncReturnValueLen;\n-\n-  start_critical_section ();\n-  func.completion_event.opaque[0] = max_event_num++;\n-  non_signalled_events.insert (func.completion_event.opaque[0]);\n-  ((Pipeline *) in_Pipeline)->queue.push (func);\n-  finish_critical_section ();\n-\n-  /* In case of synchronous execution we have to wait for target.  */\n-  if (out_pCompletion == NULL)\n-    COIEventWait (1, &func.completion_event, -1, 1, NULL, NULL);\n-  else\n-    *out_pCompletion = func.completion_event;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE in_Engine,\n-\t\t\t\t\t\tconst char *in_pBinaryName,\n-\t\t\t\t\t\tconst void *in_pBinaryBuffer,\n-\t\t\t\t\t\tuint64_t in_BinaryBufferLength,\n-\t\t\t\t\t\tint in_Argc,\n-\t\t\t\t\t\tconst char **in_ppArgv,\n-\t\t\t\t\t\tuint8_t in_DupEnv,\n-\t\t\t\t\t\tconst char **in_ppAdditionalEnv,\n-\t\t\t\t\t\tuint8_t in_ProxyActive,\t\t// Ignored\n-\t\t\t\t\t\tconst char *in_Reserved,\t// Ignored\n-\t\t\t\t\t\tuint64_t in_InitialBufferSpace,\t// Ignored\n-\t\t\t\t\t\tconst char *in_LibrarySearchPath,\n-\t\t\t\t\t\tconst char *in_FileOfOrigin,    // Ignored\n-\t\t\t\t\t\tuint64_t in_FileOfOriginOffset,\t// Ignored\n-\t\t\t\t\t\tCOIPROCESS *out_pProcess)\n-{\n-  COITRACE (\"COIProcessCreateFromMemory\");\n-\n-  const int run_max_args_num = 128;\n-  char *run_argv[run_max_args_num];\n-  char *emul_run = getenv (OFFLOAD_EMUL_RUN_ENV);\n-  const int uint_max_len = 11;\n-\n-  /* Features of liboffloadmic.  */\n-  assert (in_Engine != NULL);\n-  assert (in_pBinaryName != NULL);\n-  assert (in_pBinaryBuffer != NULL);\n-  assert (in_Argc == 0);\n-  assert (in_ppArgv == NULL);\n-  assert (in_ppAdditionalEnv == NULL);\n-  assert (in_LibrarySearchPath != NULL);\n-  assert (out_pProcess != NULL);\n-\n-  /* Convert input arguments.  */\n-  Engine *eng = (Engine *) in_Engine;\n-\n-  /* Create temporary directory for engine files.  */\n-  assert (eng->dir == NULL);\n-  STRDUP (eng->dir, ENGINE_PATH);\n-  if (mkdtemp (eng->dir) == NULL)\n-    COIERROR (\"Cannot create temporary directory %s.\", eng->dir);\n-\n-  /* Save path to engine directory for clean up on exit.  */\n-  tmp_dirs_num++;\n-  tmp_dirs = (char **) realloc (tmp_dirs, tmp_dirs_num * sizeof (char *));\n-  if (!tmp_dirs)\n-    COIERROR (\"Cannot allocate memory.\");\n-  STRDUP (tmp_dirs[tmp_dirs_num - 1], eng->dir);\n-\n-  /* Create target executable file.  */\n-  char *target_exe;\n-  MALLOC (char *, target_exe, strlen (eng->dir) + strlen (in_pBinaryName) + 2);\n-  sprintf (target_exe, \"%s/%s\", eng->dir, in_pBinaryName);\n-  int fd = open (target_exe, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n-  if (fd < 0)\n-    COIERROR (\"Cannot create file %s.\", target_exe);\n-  FILE *file = fdopen (fd, \"wb\");\n-  if (file == NULL)\n-    COIERROR (\"Cannot associate stream with file descriptor.\");\n-  if (fwrite (in_pBinaryBuffer, 1, in_BinaryBufferLength, file)\n-      != in_BinaryBufferLength)\n-    COIERROR (\"Cannot write in file %s.\", target_exe);\n-  if (fclose (file) != 0)\n-    COIERROR (\"Cannot close file %s.\", target_exe);\n-\n-  /* Fix file permissions.  */\n-  if (chmod (target_exe, S_IRWXU) < 0)\n-    COIERROR (\"Cannot change permissions for file %s.\", target_exe);\n-\n-  /* Create directory for pipes to prevent names collision.  */\n-  char *pipes_path;\n-  MALLOC (char *, pipes_path, strlen (eng->dir) + sizeof (PIPES_PATH));\n-  sprintf (pipes_path, \"%s\" PIPES_PATH, eng->dir);\n-  if (mkdir (pipes_path, S_IRWXU) < 0)\n-    COIERROR (\"Cannot create folder %s.\", pipes_path);\n-\n-  /* Create 2 main pipes for inter-process communication.  */\n-  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n-  MALLOC (char *, pipe_host2tgt_path,\n-\t  strlen (eng->dir) + sizeof (PIPE_HOST2TGT_NAME \"mainpipe\"));\n-  MALLOC (char *, pipe_tgt2host_path,\n-\t  strlen (eng->dir) + sizeof (PIPE_TGT2HOST_NAME \"mainpipe\"));\n-  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"mainpipe\", eng->dir);\n-  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"mainpipe\", eng->dir);\n-  if (mkfifo (pipe_host2tgt_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create main pipe %s.\", pipe_host2tgt_path);\n-  if (mkfifo (pipe_tgt2host_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create main pipe %s.\", pipe_tgt2host_path);\n-\n-  /* Prepare argv.  */\n-  if (emul_run == NULL || strcmp (emul_run, \"\") == 0)\n-    {\n-      STRDUP (run_argv[0], target_exe);\n-      run_argv[1] = (char *) NULL;\n-    }\n-  else\n-    {\n-      char *ptr, *tmp;\n-      int i = 0;\n-      STRDUP (tmp, emul_run);\n-      char *tok = strtok_r (tmp, \" \", &ptr);\n-      while (tok != NULL)\n-\t{\n-\t  if (i >= run_max_args_num)\n-\t    COIERROR (\"Run command has too many arguments.\");\n-\t  STRDUP (run_argv[i++], tok);\n-\t  tok = strtok_r (NULL, \" \", &ptr);\n-\t}\n-      STRDUP (run_argv[i], target_exe);\n-      run_argv[i + 1] = (char *) NULL;\n-      free (tmp);\n-    }\n-\n-  /* Prepare envp.  */\n-  int env_num = 0;\n-  if (in_DupEnv == true)\n-    while (environ[env_num++]);\n-  env_num += 4; // LD_LIBRARY_PATH, MIC_DIR, MIC_INDEX, NULL\n-\n-  char **envp;\n-  MALLOC (char **, envp, env_num * sizeof (char *));\n-\n-  int env_i = 0;\n-  if (in_DupEnv == true)\n-    for (unsigned i = 0; environ[i] != NULL; i++)\n-      {\n-\tunsigned j;\n-\tchar *env_name;\n-\tSTRDUP (env_name, environ[i]);\n-\tfor (j = 0; env_name[j] != '=' && env_name[j] != '\\0'; j++);\n-\tenv_name[j] = '\\0';\n-\tif (strcmp (env_name, \"LD_LIBRARY_PATH\") != 0\n-\t    && strcmp (env_name, MIC_DIR_ENV) != 0\n-\t    && strcmp (env_name, MIC_INDEX_ENV) != 0)\n-\t  STRDUP (envp[env_i++], environ[i]);\n-\tfree (env_name);\n-      }\n-\n-  MALLOC (char *, envp[env_i], strlen (MIC_DIR_ENV) + strlen (eng->dir) + 2);\n-  sprintf (envp[env_i], \"%s=%s\", MIC_DIR_ENV, eng->dir);\n-\n-  MALLOC (char *, envp[env_i + 1], strlen (MIC_INDEX_ENV) + uint_max_len + 1);\n-  sprintf (envp[env_i + 1], \"%s=%u\", MIC_INDEX_ENV, eng->index);\n-\n-  MALLOC (char *, envp[env_i + 2],\n-\t  strlen (\"LD_LIBRARY_PATH=\") + strlen (in_LibrarySearchPath) + 1);\n-  sprintf (envp[env_i + 2], \"LD_LIBRARY_PATH=%s\", in_LibrarySearchPath);\n-\n-  envp[env_i + 3] = (char *) NULL;\n-\n-  /* Create target process.  */\n-  pid_t pid = vfork ();\n-  if (pid < 0)\n-    COIERROR (\"Cannot create child process.\");\n-\n-  if (pid == 0)\n-    {\n-      /* Run target executable.  */\n-      if (execvpe (run_argv[0], run_argv, envp) == -1)\n-\tCOIERROR (\"Cannot execute file %s.\", target_exe);\n-    }\n-\n-  /* Open main pipes.  */\n-  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_WRONLY);\n-  if (pipe_host2tgt < 0)\n-    COIERROR (\"Cannot open host-to-target main pipe.\");\n-  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_RDONLY);\n-  if (pipe_tgt2host < 0)\n-    COIERROR (\"Cannot open target-to-host main pipe.\");\n-\n-  /* Create process handle.  */\n-  Process *proc = new Process;\n-  proc->pid = pid;\n-  proc->pipe_host2tgt = pipe_host2tgt;\n-  proc->pipe_tgt2host = pipe_tgt2host;\n-  proc->engine = eng;\n-  proc->functions = NULL;\n-\n-  /* Prepare output arguments.  */\n-  *out_pProcess = (COIPROCESS) proc;\n-\n-  /* Clean up.  */\n-  for (unsigned i = 0; run_argv[i] != NULL; i++)\n-    free (run_argv[i]);\n-  for (unsigned i = 0; envp[i] != NULL; i++)\n-    free (envp[i]);\n-  free (envp);\n-  free (pipe_host2tgt_path);\n-  free (pipe_tgt2host_path);\n-  free (pipes_path);\n-  free (target_exe);\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessCreateFromFile, 1) (COIENGINE in_Engine,\n-\t\t\t\t\t      const char *in_pBinaryName,\n-\t\t\t\t\t      int in_Argc,\n-\t\t\t\t\t      const char **in_ppArgv,\n-\t\t\t\t\t      uint8_t in_DupEnv,\n-\t\t\t\t\t      const char **in_ppAdditionalEnv,\n-\t\t\t\t\t      uint8_t in_ProxyActive,\n-\t\t\t\t\t      const char *in_Reserved,\n-\t\t\t\t\t      uint64_t in_BufferSpace,\n-\t\t\t\t\t      const char *in_LibrarySearchPath,\n-\t\t\t\t\t      COIPROCESS *out_pProcess)\n-{\n-  COITRACE (\"COIProcessCreateFromFile\");\n-\n-  /* liboffloadmic with GCC compiled binaries should never go here.  */\n-  assert (false);\n-  return COI_ERROR;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessDestroy, 1) (COIPROCESS in_Process,\n-\t\t\t\t       int32_t in_WaitForMainTimeout, // Ignored\n-\t\t\t\t       uint8_t in_ForceDestroy,\n-\t\t\t\t       int8_t *out_pProcessReturn,\n-\t\t\t\t       uint32_t *out_pTerminationCode)\n-{\n-  COITRACE (\"COIProcessDestroy\");\n-\n-  assert (in_Process != NULL);\n-  assert (out_pProcessReturn != NULL);\n-  assert (out_pTerminationCode != NULL);\n-\n-  /* Convert input arguments.  */\n-  Process *proc = (Process *) in_Process;\n-\n-  /* Destroy all undestroyed pipelines.  */\n-  while (!pipelines.empty ())\n-    {\n-      std::set<Pipeline *>::iterator p = pipelines.begin ();\n-      COIPipelineDestroy ((COIPIPELINE) *p);\n-    }\n-\n-  /* Close main pipes.  */\n-  if (close (proc->pipe_host2tgt) < 0)\n-    COIERROR (\"Cannot close host-to-target main pipe.\");\n-  if (close (proc->pipe_tgt2host) < 0)\n-    COIERROR (\"Cannot close target-to-host main pipe.\");\n-\n-  /* Shutdown target process by force.  */\n-  if (in_ForceDestroy)\n-    kill (proc->pid, SIGTERM);\n-\n-  /* Clean up.  */\n-  free (proc->engine->dir);\n-  free (proc->functions);\n-  delete proc->engine;\n-  delete proc;\n-\n-  /* Prepare output arguments.  */\n-  *out_pProcessReturn = 0;\n-  *out_pTerminationCode = 0;\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessGetFunctionHandles, 1) (COIPROCESS in_Process,\n-\t\t\t\t\t\t  uint32_t in_NumFunctions,\n-\t\t\t\t\t\t  const char **in_ppFunctionNameArray,\n-\t\t\t\t\t\t  COIFUNCTION *out_pFunctionHandleArray)\n-{\n-  COITRACE (\"COIProcessGetFunctionHandles\");\n-\n-  assert (in_Process != NULL);\n-  assert (in_ppFunctionNameArray != NULL);\n-  assert (out_pFunctionHandleArray != NULL);\n-\n-  /* Convert input arguments.  */\n-  Process *proc = (Process *) in_Process;\n-\n-  /* This function should be called once for the process.  */\n-  assert (proc->functions == NULL);\n-\n-  /* Create array of function pointers.  Last element is 0, what shows the end\n-     of the array.  This array is used to free memory when process is\n-     destroyed.  */\n-  proc->functions = (void **) calloc (in_NumFunctions + 1, sizeof (void *));\n-  if (proc->functions == NULL)\n-    COIERROR (\"Cannot allocate memory.\");\n-\n-  /* Get handles for functions.  */\n-  for (uint32_t i = 0; i < in_NumFunctions; i++)\n-    {\n-      size_t len = strlen (in_ppFunctionNameArray[i]) + 1;\n-\n-      start_critical_section ();\n-\n-      /* Send data to target.  */\n-      const cmd_t cmd = CMD_GET_FUNCTION_HANDLE;\n-      WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-      WRITE (proc->pipe_host2tgt, &len, sizeof (size_t));\n-      WRITE (proc->pipe_host2tgt, in_ppFunctionNameArray[i], len);\n-\n-      /* Receive data from target.  */\n-      void *fn_ptr;\n-      READ (proc->pipe_tgt2host, &fn_ptr, sizeof (void *));\n-\n-      finish_critical_section ();\n-\n-      /* Save function pointer.  */\n-      proc->functions[i] = fn_ptr;\n-\n-      /* Prepare output arguments.  */\n-      out_pFunctionHandleArray[i] = (COIFUNCTION) fn_ptr;\n-    }\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS in_Process,\n-\t\t\t\t\t\t     const void *in_pLibraryBuffer,\n-\t\t\t\t\t\t     uint64_t in_LibraryBufferLength,\n-\t\t\t\t\t\t     const char *in_pLibraryName,\n-\t\t\t\t\t\t     const char *in_LibrarySearchPath,\t// Ignored\n-\t\t\t\t\t\t     const char *in_FileOfOrigin,\t// Ignored\n-\t\t\t\t\t\t     uint64_t in_FileOfOriginOffset,\t// Ignored\n-\t\t\t\t\t\t     uint32_t in_Flags,\t\t\t// Ignored\n-\t\t\t\t\t\t     COILIBRARY *out_pLibrary)\n-{\n-  COITRACE (\"COIProcessLoadLibraryFromMemory\");\n-\n-  assert (in_Process != NULL);\n-  assert (in_pLibraryBuffer != NULL);\n-  assert (out_pLibrary != NULL);\n-\n-  /* Convert input arguments.  */\n-  Process *proc = (Process *) in_Process;\n-\n-  /* Create target library file.  */\n-  char *lib_path;\n-  size_t len = strlen (proc->engine->dir) + strlen (in_pLibraryName) + 2;\n-  MALLOC (char *, lib_path, len);\n-  sprintf (lib_path, \"%s/%s\", proc->engine->dir, in_pLibraryName);\n-  int fd = open (lib_path, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n-  if (fd < 0)\n-    COIERROR (\"Cannot create file %s.\", lib_path);\n-  FILE *file = fdopen (fd, \"wb\");\n-  if (file == NULL)\n-    COIERROR (\"Cannot associate stream with file descriptor.\");\n-  if (fwrite (in_pLibraryBuffer, 1, in_LibraryBufferLength, file)\n-      != in_LibraryBufferLength)\n-    COIERROR (\"Cannot write in file %s.\", lib_path);\n-  if (fclose (file) != 0)\n-    COIERROR (\"Cannot close file %s.\", lib_path);\n-\n-  start_critical_section ();\n-\n-  /* Make target open library.  */\n-  const cmd_t cmd = CMD_OPEN_LIBRARY;\n-  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-  WRITE (proc->pipe_host2tgt, &len, sizeof (size_t));\n-  WRITE (proc->pipe_host2tgt, lib_path, len);\n-\n-  /* Receive data from target.  */\n-  void *handle;\n-  READ (proc->pipe_tgt2host, &handle, sizeof (void *));\n-\n-  finish_critical_section ();\n-\n-  /* Clean up.  */\n-  free (lib_path);\n-\n-  *out_pLibrary = (COILIBRARY) handle;\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessRegisterLibraries, 1) (uint32_t in_NumLibraries,\t\t      // Ignored\n-\t\t\t\t\t\t const void **in_ppLibraryArray,\t      // Ignored\n-\t\t\t\t\t\t const uint64_t *in_pLibrarySizeArray,\t      // Ignored\n-\t\t\t\t\t\t const char **in_ppFileOfOriginArray,\t      // Ignored\n-\t\t\t\t\t\t const uint64_t *in_pFileOfOriginOffSetArray) // Ignored\n-{\n-  COITRACE (\"COIProcessRegisterLibraries\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIProcessUnloadLibrary, 1) (COIPROCESS in_Process,\n-\t\t\t\t\t     COILIBRARY in_Library)\n-{\n-  COITRACE (\"COIProcessUnloadLibrary\");\n-\n-  assert (in_Process != NULL);\n-  assert (in_Library != NULL);\n-\n-  const cmd_t cmd = CMD_CLOSE_LIBRARY;\n-\n-  /* Convert input arguments.  */\n-  Process *proc = (Process *) in_Process;\n-\n-  start_critical_section ();\n-\n-  /* Make target close library.  */\n-  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n-  WRITE (proc->pipe_host2tgt, &in_Library, sizeof (void *));\n-\n-  finish_critical_section ();\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-uint64_t\n-SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n-{\n-  COITRACE (\"COIPerfGetCycleFrequency\");\n-\n-  return (uint64_t) CYCLE_FREQUENCY;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineClearCPUMask, 1) (COI_CPU_MASK *in_Mask)\n-{\n-  COITRACE (\"COIPipelineClearCPUMask\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIPipelineSetCPUMask, 1) (COIPROCESS in_Process,\n-\t\t\t\t\t   uint32_t in_CoreID,\n-\t\t\t\t\t   uint8_t in_ThreadID,\n-\t\t\t\t\t   COI_CPU_MASK *out_pMask)\n-{\n-  COITRACE (\"COIPipelineSetCPUMask\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return COI_SUCCESS;\n-}\n-\n-\n-COIRESULT\n-SYMBOL_VERSION (COIEngineGetInfo, 1) (COIENGINE in_EngineHandle,  // Ignored\n-\t\t\t\t      uint32_t in_EngineInfoSize, // Ignored\n-\t\t\t\t      COI_ENGINE_INFO *out_pEngineInfo)\n-{\n-  COITRACE (\"COIEngineGetInfo\");\n-\n-  assert (out_pEngineInfo != NULL);\n-\n-  out_pEngineInfo->ISA = COI_DEVICE_KNL;\n-  out_pEngineInfo->NumCores = 1;\n-  out_pEngineInfo->NumThreads = 8;\n-  out_pEngineInfo->CoreMaxFrequency = SYMBOL_VERSION(COIPerfGetCycleFrequency,1)() / 1000000;\n-  out_pEngineInfo->PhysicalMemory = 1024;\n-  out_pEngineInfo->PhysicalMemoryFree = 1024;\n-  out_pEngineInfo->SwapMemory = 1024;\n-  out_pEngineInfo->SwapMemoryFree = 1024;\n-  out_pEngineInfo->MiscFlags = COI_ENG_ECC_DISABLED;\n-\n-  return COI_SUCCESS;\n-}\n-\n-} // extern \"C\"\n-"}, {"sha": "82dbc92aef849e960a6d123915800f5ac8ae121c", "filename": "liboffloadmic/runtime/emulator/coi_host.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,65 +0,0 @@\n-/*\n-    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef COI_HOST_H_INCLUDED\n-#define COI_HOST_H_INCLUDED\n-\n-#include \"coi_common.h\"\n-\n-#define COIERROR(...)\t\t\t  \\\n-{\t\t\t\t\t  \\\n-  fprintf (stderr, \"COI ERROR - HOST: \"); \\\n-  fprintf (stderr, __VA_ARGS__);\t  \\\n-  fprintf (stderr, \"\\n\");\t\t  \\\n-  perror (NULL);\t\t\t  \\\n-  return COI_ERROR;\t\t\t  \\\n-}\n-\n-/* Like COIERROR, but return NULL instead of COIRESULT.  */\n-#define COIERRORN(...)\t\t\t  \\\n-{\t\t\t\t\t  \\\n-  fprintf (stderr, \"COI ERROR - HOST: \"); \\\n-  fprintf (stderr, __VA_ARGS__);\t  \\\n-  fprintf (stderr, \"\\n\");\t\t  \\\n-  perror (NULL);\t\t\t  \\\n-  return NULL;\t\t\t\t  \\\n-}\n-\n-#ifdef DEBUG\n-  #define COITRACE(...)\t\t\t    \\\n-  {\t\t\t\t\t    \\\n-    fprintf (stderr, \"COI TRACE - HOST: \"); \\\n-    fprintf (stderr, __VA_ARGS__);\t    \\\n-    fprintf (stderr, \"\\n\");\t\t    \\\n-  }\n-#else\n-  #define COITRACE(...) {}\n-#endif\n-\n-#endif // COI_HOST_H_INCLUDED"}, {"sha": "e64ba7dcc06445e69ffdfda5f8d3b17790af067a", "filename": "liboffloadmic/runtime/emulator/coi_version_asm.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,91 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-// Originally generated via:\n-//   cd include;\n-//   ctags -x --c-kinds=fp -R sink/ source/ common/ | grep -v COIX | awk '{print \"__asm__(\\\".symver \"$1\"1,\"$1\"@@COI_1.0\\\");\"}'\n-//\n-// These directives must have an associated linker script with VERSION stuff.\n-// See coi_version_linker_script.map\n-// Passed in as\n-//    -Wl,--version-script coi_version_linker_script.map\n-// when building Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-//\n-// See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info\n-//\n-// This is not strictly a .h file, so no need to #pragma once or anything.\n-// You must include these asm directives in the same translation unit as the\n-// one where the function body is.\n-// Otherwise we'd have add this file to the list of files needed to build\n-// libcoi*, instead of including it in each of the api/*/*cpp files.\n-//\n-__asm__(\".symver COIBufferAddRef1,COIBufferAddRef@@COI_1.0\");\n-__asm__(\".symver COIBufferCopy1,COIBufferCopy@@COI_1.0\");\n-__asm__(\".symver COIBufferCreate1,COIBufferCreate@@COI_1.0\");\n-__asm__(\".symver COIBufferCreateFromMemory1,COIBufferCreateFromMemory@@COI_1.0\");\n-__asm__(\".symver COIBufferDestroy1,COIBufferDestroy@@COI_1.0\");\n-__asm__(\".symver COIBufferGetSinkAddress1,COIBufferGetSinkAddress@@COI_1.0\");\n-__asm__(\".symver COIBufferMap1,COIBufferMap@@COI_1.0\");\n-__asm__(\".symver COIBufferRead1,COIBufferRead@@COI_1.0\");\n-__asm__(\".symver COIBufferReleaseRef1,COIBufferReleaseRef@@COI_1.0\");\n-__asm__(\".symver COIBufferSetState1,COIBufferSetState@@COI_1.0\");\n-__asm__(\".symver COIBufferUnmap1,COIBufferUnmap@@COI_1.0\");\n-__asm__(\".symver COIBufferWrite1,COIBufferWrite@@COI_1.0\");\n-__asm__(\".symver COIEngineGetCount1,COIEngineGetCount@@COI_1.0\");\n-__asm__(\".symver COIEngineGetHandle1,COIEngineGetHandle@@COI_1.0\");\n-__asm__(\".symver COIEngineGetIndex1,COIEngineGetIndex@@COI_1.0\");\n-__asm__(\".symver COIEngineGetInfo1,COIEngineGetInfo@@COI_1.0\");\n-__asm__(\".symver COIEventRegisterCallback1,COIEventRegisterCallback@@COI_1.0\");\n-__asm__(\".symver COIEventWait1,COIEventWait@@COI_1.0\");\n-__asm__(\".symver COIPerfGetCycleFrequency1,COIPerfGetCycleFrequency@@COI_1.0\");\n-__asm__(\".symver COIPipelineClearCPUMask1,COIPipelineClearCPUMask@@COI_1.0\");\n-__asm__(\".symver COIPipelineCreate1,COIPipelineCreate@@COI_1.0\");\n-__asm__(\".symver COIPipelineDestroy1,COIPipelineDestroy@@COI_1.0\");\n-__asm__(\".symver COIPipelineRunFunction1,COIPipelineRunFunction@@COI_1.0\");\n-__asm__(\".symver COIPipelineSetCPUMask1,COIPipelineSetCPUMask@@COI_1.0\");\n-__asm__(\".symver COIPipelineStartExecutingRunFunctions1,COIPipelineStartExecutingRunFunctions@@COI_1.0\");\n-__asm__(\".symver COIProcessCreateFromFile1,COIProcessCreateFromFile@@COI_1.0\");\n-__asm__(\".symver COIProcessCreateFromMemory1,COIProcessCreateFromMemory@@COI_1.0\");\n-__asm__(\".symver COIProcessDestroy1,COIProcessDestroy@@COI_1.0\");\n-__asm__(\".symver COIProcessGetFunctionHandles1,COIProcessGetFunctionHandles@@COI_1.0\");\n-__asm__(\".symver COIProcessLoadLibraryFromMemory2,COIProcessLoadLibraryFromMemory@COI_2.0\");\n-__asm__(\".symver COIProcessRegisterLibraries1,COIProcessRegisterLibraries@@COI_1.0\");\n-__asm__(\".symver COIProcessUnloadLibrary1,COIProcessUnloadLibrary@@COI_1.0\");\n-__asm__(\".symver COIProcessWaitForShutdown1,COIProcessWaitForShutdown@@COI_1.0\");"}, {"sha": "ea180669858fb172126c2c2c9d8e7fd8bf393280", "filename": "liboffloadmic/runtime/emulator/coi_version_linker_script.map", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map?ref=e724b0480bfa5ec04f39be8c7290330b495c59de", "patch": "@@ -1,91 +0,0 @@\n-/*\n- * Copyright 2010-2016 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-/***\n-* See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info.\n-* Use this in conjunction with coi_version_asm.h.\n-* // Comments don't work in this file.\n-***/\n-\n-COI_1.0\n-{\n-  global:\n-    COIBufferAddRef;\n-    COIBufferCopy;\n-    COIBufferCreate;\n-    COIBufferCreateFromMemory;\n-    COIBufferDestroy;\n-    COIBufferGetSinkAddress;\n-    COIBufferMap;\n-    COIBufferRead;\n-    COIBufferReleaseRef;\n-    COIBufferSetState;\n-    COIBufferUnmap;\n-    COIBufferWrite;\n-    COIEngineGetCount;\n-    COIEngineGetHandle;\n-    COIEngineGetIndex;\n-    COIEngineGetInfo;\n-    COIEventWait;\n-    COIEventRegisterCallback;\n-    COIPerfGetCycleFrequency;\n-    COIPipelineClearCPUMask;\n-    COIPipelineCreate;\n-    COIPipelineDestroy;\n-    COIPipelineRunFunction;\n-    COIPipelineSetCPUMask;\n-    COIPipelineStartExecutingRunFunctions;\n-    COIProcessCreateFromFile;\n-    COIProcessCreateFromMemory;\n-    COIProcessDestroy;\n-    COIProcessGetFunctionHandles;\n-    COIProcessLoadLibraryFromMemory;\n-    COIProcessRegisterLibraries;\n-    COIProcessUnloadLibrary;\n-    COIProcessWaitForShutdown;\n-  local:\n-    *;\n-};\n-\n-COI_2.0\n-{\n-\n-} COI_1.0;\n-"}, {"sha": "5dffdb115129873ac43af6e85eabab14dbe6a36e", "filename": "liboffloadmic/runtime/liboffload_error.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error.c?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "d7a71c3e6d452424d766dbbb62562851fbd278a5", "filename": "liboffloadmic/runtime/liboffload_error_codes.h", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "ffee72f5ae8ac424e988c0bcc17dd81b3ffbb253", "filename": "liboffloadmic/runtime/liboffload_msg.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.c?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "93eccd496fd79c0b19150e7cd72c000ec098e4f5", "filename": "liboffloadmic/runtime/liboffload_msg.h", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "1874dd97796fe2fb228b28114f91b708e392315a", "filename": "liboffloadmic/runtime/mic_lib.f90", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fmic_lib.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fmic_lib.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fmic_lib.f90?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "4a329ba0e560ef186f4cc563a27117cefecd6b40", "filename": "liboffloadmic/runtime/offload.h", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "af569ae3376e44a53f5c57d2dbe7f719fbff408b", "filename": "liboffloadmic/runtime/offload_common.cpp", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "445d47cfad03ba41a118067e112567ff910d7afd", "filename": "liboffloadmic/runtime/offload_common.h", "status": "removed", "additions": 0, "deletions": 553, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "b2de56c68eb6effa15cfc073f7b6c48a949945c0", "filename": "liboffloadmic/runtime/offload_engine.cpp", "status": "removed", "additions": 0, "deletions": 1128, "changes": 1128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "b4cdad503be3f6b532c512c2506e590076bd7696", "filename": "liboffloadmic/runtime/offload_engine.h", "status": "removed", "additions": 0, "deletions": 724, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_engine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_engine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "d1f52f143422f2eb88c3798aba1b51d525205f56", "filename": "liboffloadmic/runtime/offload_env.cpp", "status": "removed", "additions": 0, "deletions": 384, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_env.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_env.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "166b5d9242df3adbfe32420d4841dbbd2d61fb71", "filename": "liboffloadmic/runtime/offload_env.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_env.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_env.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "cab08c43550d7e7872f466c510f5b9aac91c7f20", "filename": "liboffloadmic/runtime/offload_host.cpp", "status": "removed", "additions": 0, "deletions": 7255, "changes": 7255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "4f1ef1392ba5688d66ee2ed49fe7f40948f6c57e", "filename": "liboffloadmic/runtime/offload_host.h", "status": "removed", "additions": 0, "deletions": 541, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "baf25afbb2fbf6f95006eb2c15221f38394441e4", "filename": "liboffloadmic/runtime/offload_iterator.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_iterator.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "0439fec313b6c09138a4677919dbb68bf58f484f", "filename": "liboffloadmic/runtime/offload_omp_host.cpp", "status": "removed", "additions": 0, "deletions": 1267, "changes": 1267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "2bcfef5acea629792471d71c236175024a6880f8", "filename": "liboffloadmic/runtime/offload_omp_target.cpp", "status": "removed", "additions": 0, "deletions": 736, "changes": 736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "a2ab6743ab5a4baf1793e3e9a03228c50a4d0219", "filename": "liboffloadmic/runtime/offload_orsl.cpp", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "4513fcc47494a7392b8121d344f70a9475ac8da3", "filename": "liboffloadmic/runtime/offload_orsl.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_orsl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_orsl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "09c4d206e58df51670a493582a798d93c8800495", "filename": "liboffloadmic/runtime/offload_table.cpp", "status": "removed", "additions": 0, "deletions": 671, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_table.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_table.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "9f9f93261cba791edc0baf957e62a0d5e100d50e", "filename": "liboffloadmic/runtime/offload_table.h", "status": "removed", "additions": 0, "deletions": 468, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "16ba4a329911f438ce06e879fd5f1e2f88732b3a", "filename": "liboffloadmic/runtime/offload_target.cpp", "status": "removed", "additions": 0, "deletions": 878, "changes": 878, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "8d2971b2418409753c0bf3da2b4c55c76235eff6", "filename": "liboffloadmic/runtime/offload_target.h", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "68f7c3054d56d87dae15ec653fb9cb9b10effc2a", "filename": "liboffloadmic/runtime/offload_target_main.cpp", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target_main.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "30a1149b6fb94bd880e200edfa815eb3eb5953e2", "filename": "liboffloadmic/runtime/offload_timer.h", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "3d93508f5d872a87dbebf84049048ff439e2bfec", "filename": "liboffloadmic/runtime/offload_timer_host.cpp", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "860f29765803bf0c908e65339accd2d75d261a68", "filename": "liboffloadmic/runtime/offload_timer_target.cpp", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "8d69c286f57f1dd6ff424b345d5ac5785e28cf75", "filename": "liboffloadmic/runtime/offload_trace.cpp", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "e48aa01f340d5b60f0ef46dd2e6928698c95290c", "filename": "liboffloadmic/runtime/offload_trace.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "bb434871f6025b737c5d98a2e6e8daecf1429663", "filename": "liboffloadmic/runtime/offload_util.cpp", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "789846239bfcc387d68e1f1ce009fc7c96a5b7fe", "filename": "liboffloadmic/runtime/offload_util.h", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Foffload_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "49d40509c97b52bacb39a78f1807acc551cb1ac9", "filename": "liboffloadmic/runtime/ofldbegin.cpp", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldbegin.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "3cabc1a00035507508fe59e9cef19b7a0f1e2b3a", "filename": "liboffloadmic/runtime/ofldend.cpp", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fofldend.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Fofldend.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldend.cpp?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "867bae5f33c38e6ba2f539c7399532b8698619be", "filename": "liboffloadmic/runtime/orsl-lite/include/orsl-lite.h", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "669c40a13584dcbf4cb662a5ffcf09dc3d04317c", "filename": "liboffloadmic/runtime/orsl-lite/lib/orsl-lite.c", "status": "removed", "additions": 0, "deletions": 357, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}, {"sha": "ab5f59930fc3b9bf59c8e0306d0a2c7855e111c5", "filename": "liboffloadmic/runtime/orsl-lite/version.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e724b0480bfa5ec04f39be8c7290330b495c59de/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt?ref=e724b0480bfa5ec04f39be8c7290330b495c59de"}]}