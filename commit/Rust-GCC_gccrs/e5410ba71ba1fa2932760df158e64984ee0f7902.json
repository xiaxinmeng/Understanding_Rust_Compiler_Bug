{"sha": "e5410ba71ba1fa2932760df158e64984ee0f7902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0MTBiYTcxYmExZmEyOTMyNzYwZGYxNThlNjQ5ODRlZTBmNzkwMg==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-12-02T19:25:55Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-12-02T19:25:55Z"}, "message": "tree.c (is_attribute_p): Split out to ..\n\n2004-12-02  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * tree.c (is_attribute_p): Split out to ..\n        (is_attribute_with_length_p): Here.  Use IDENTIFIER_LENGTH instead\n        of strlen and compare the string lengths before calling strcmp.\n        (lookup_attribute): Call is_attribute_with_length_p instead of\n        is_attribute_p.\n\nFrom-SVN: r91654", "tree": {"sha": "376105576b66aacc3abc95111e0be1b732ec133c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/376105576b66aacc3abc95111e0be1b732ec133c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5410ba71ba1fa2932760df158e64984ee0f7902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5410ba71ba1fa2932760df158e64984ee0f7902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5410ba71ba1fa2932760df158e64984ee0f7902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5410ba71ba1fa2932760df158e64984ee0f7902/comments", "author": null, "committer": null, "parents": [{"sha": "910fbc166c123f616d3ec527c2646c80dac0377a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910fbc166c123f616d3ec527c2646c80dac0377a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910fbc166c123f616d3ec527c2646c80dac0377a"}], "stats": {"total": 41, "additions": 31, "deletions": 10}, "files": [{"sha": "8c274935736a2c33b17d9dc0b46ff0d39774d8bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5410ba71ba1fa2932760df158e64984ee0f7902/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5410ba71ba1fa2932760df158e64984ee0f7902/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5410ba71ba1fa2932760df158e64984ee0f7902", "patch": "@@ -1,3 +1,11 @@\n+2004-12-02  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* tree.c (is_attribute_p): Split out to ..\n+\t(is_attribute_with_length_p): Here.  Use IDENTIFIER_LENGTH instead\n+\tof strlen and compare the string lengths before calling strcmp.\n+\t(lookup_attribute): Call is_attribute_with_length_p instead of\n+\tis_attribute_p.\n+\n 2004-12-02  Devang Patel  <dpatel@apple.com>\n \n \t* config/darwin.h (TARGET_OPTION_TRANSLATE_TABLE): Add -gfull and -gused."}, {"sha": "843410bf07bddb0fe210b7bab3ab160ecb8bba30", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5410ba71ba1fa2932760df158e64984ee0f7902/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5410ba71ba1fa2932760df158e64984ee0f7902/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e5410ba71ba1fa2932760df158e64984ee0f7902", "patch": "@@ -3026,6 +3026,7 @@ build_type_attribute_variant (tree ttype, tree attribute)\n   return ttype;\n }\n \n+\n /* Return nonzero if IDENT is a valid name for attribute ATTR,\n    or zero if not.\n \n@@ -3034,21 +3035,21 @@ build_type_attribute_variant (tree ttype, tree attribute)\n    `text'.  One might then also require attribute lists to be stored in\n    their canonicalized form.  */\n \n-int\n-is_attribute_p (const char *attr, tree ident)\n+static int\n+is_attribute_with_length_p (const char *attr, int attr_len, tree ident)\n {\n-  int ident_len, attr_len;\n+  int ident_len;\n   const char *p;\n \n   if (TREE_CODE (ident) != IDENTIFIER_NODE)\n     return 0;\n-\n-  if (strcmp (attr, IDENTIFIER_POINTER (ident)) == 0)\n-    return 1;\n-\n+  \n   p = IDENTIFIER_POINTER (ident);\n-  ident_len = strlen (p);\n-  attr_len = strlen (attr);\n+  ident_len = IDENTIFIER_LENGTH (ident);\n+  \n+  if (ident_len == attr_len\n+      && strcmp (attr, p) == 0)\n+    return 1;\n \n   /* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */\n   if (attr[0] == '_')\n@@ -3073,6 +3074,17 @@ is_attribute_p (const char *attr, tree ident)\n   return 0;\n }\n \n+/* Return nonzero if IDENT is a valid name for attribute ATTR,\n+   or zero if not.\n+\n+   We try both `text' and `__text__', ATTR may be either one.  */\n+\n+int\n+is_attribute_p (const char *attr, tree ident)\n+{\n+  return is_attribute_with_length_p (attr, strlen (attr), ident);\n+}\n+\n /* Given an attribute name and a list of attributes, return a pointer to the\n    attribute's list element if the attribute is part of the list, or NULL_TREE\n    if not found.  If the attribute appears more than once, this only\n@@ -3083,11 +3095,12 @@ tree\n lookup_attribute (const char *attr_name, tree list)\n {\n   tree l;\n+  size_t attr_len = strlen (attr_name);\n \n   for (l = list; l; l = TREE_CHAIN (l))\n     {\n       gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n-      if (is_attribute_p (attr_name, TREE_PURPOSE (l)))\n+      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l)))\n \treturn l;\n     }\n "}]}