{"sha": "c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ2YmIyZmQzZDAxMTlmZmY2MDkxNWRiZWZjNGUwYWEzMTQ3ZThhMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:29Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:29Z"}, "message": "Initial revision\n\nFrom-SVN: r26245", "tree": {"sha": "522e31e5ebef7f562177a59549a0db4b25188e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/522e31e5ebef7f562177a59549a0db4b25188e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2/comments", "author": null, "committer": null, "parents": [{"sha": "6ad7c37da561071652f37cf4cfa8edb6347dd43f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad7c37da561071652f37cf4cfa8edb6347dd43f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ad7c37da561071652f37cf4cfa8edb6347dd43f"}], "stats": {"total": 1386, "additions": 1386, "deletions": 0}, "files": [{"sha": "98fce1ee549100acf6aed40b6525dd3c5e315028", "filename": "boehm-gc/README", "status": "added", "additions": 1386, "deletions": 0, "changes": 1386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2/boehm-gc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2/boehm-gc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME?ref=c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "patch": "@@ -0,0 +1,1386 @@\n+Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n+\n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+Permission is hereby granted to use or copy this program\n+for any purpose,  provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is granted,\n+provided the above notices are retained, and a notice that the code was\n+modified is included with the above copyright notice.\n+\n+This is version 4.13alpha2 of a conservative garbage collector for C and C++.\n+\n+You might find a more recent version of this at\n+\n+http://reality.sgi.com/boehm/gc.html\n+\n+HISTORY -\n+\n+  Early versions of this collector were developed as a part of research\n+projects supported in part by the National Science Foundation\n+and the Defense Advance Research Projects Agency.\n+Much of the code was rewritten by Hans-J. Boehm at Xerox PARC.\n+The SPARC specific code was contributed by Mark Weiser\n+(weiser@parc.xerox.com).  The Encore Multimax modifications were supplied by\n+Kevin Kenny (kenny@m.cs.uiuc.edu).  The adaptation to the RT is largely due\n+to Vernon Lee (scorpion@rice.edu), on machines made available by IBM.\n+Much of the HP specific code and a number of good suggestions for improving the\n+generic code are due to Walter Underwood (wunder@hp-ses.sde.hp.com).\n+Robert Brazile (brazile@diamond.bbn.com) originally supplied the ULTRIX code.\n+Al Dosser (dosser@src.dec.com) and Regis Cridlig (Regis.Cridlig@cl.cam.ac.uk)\n+subsequently provided updates and information on variation between ULTRIX\n+systems.  Parag Patel (parag@netcom.com) supplied the A/UX code.\n+Jesper Peterson(jep@mtiame.mtia.oz.au) and\n+Michel Schinz supplied the Amiga port.\n+Thomas Funke (thf@zelator.in-berlin.de(?)) and\n+Brian D.Carlstrom (bdc@clark.lcs.mit.edu) supplied the NeXT ports.\n+Douglas Steel (doug@wg.icl.co.uk) provided ICL DRS6000 code.\n+Bill Janssen (janssen@parc.xerox.com) supplied the SunOS dynamic loader\n+specific code. Manuel Serrano (serrano@cornas.inria.fr) supplied linux and\n+Sony News specific code.  Al Dosser provided Alpha/OSF/1 code.  He and\n+Dave Detlefs(detlefs@src.dec.com) also provided several generic bug fixes.\n+Alistair G. Crooks(agc@uts.amdahl.com) supplied the NetBSD and 386BSD ports.\n+Jeffrey Hsu (hsu@soda.berkeley.edu) provided the FreeBSD port.\n+Brent Benson (brent@jade.ssd.csd.harris.com) ported the collector to\n+a Motorola 88K processor running CX/UX (Harris NightHawk).\n+Ari Huttunen (Ari.Huttunen@hut.fi) generalized the OS/2 port to\n+nonIBM development environments (a nontrivial task).\n+Patrick Beard (beard@cs.ucdavis.edu) provided the initial MacOS port.\n+David Chase, then at Olivetti Research, suggested several improvements.\n+Scott Schwartz (schwartz@groucho.cse.psu.edu) supplied some of the\n+code to save and print call stacks for leak detection on a SPARC.\n+Jesse Hull and John Ellis supplied the C++ interface code.\n+Zhong Shao performed much of the experimentation that led to the\n+current typed allocation facility.  (His dynamic type inference code hasn't\n+made it into the released version of the collector, yet.)\n+(Blame for misinstallation of these modifications goes to the first author,\n+however.)\n+\n+Credits for some more recent modifications are given in the modification\n+history at the end of this file.\n+\n+    This is intended to be a general purpose, garbage collecting storage\n+allocator.  The algorithms used are described in:\n+\n+Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n+Software Practice & Experience, September 1988, pp. 807-820.\n+\n+Boehm, H., A. Demers, and S. Shenker, \"Mostly Parallel Garbage Collection\",\n+Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design\n+and Implementation, SIGPLAN Notices 26, 6 (June 1991), pp. 157-164.\n+\n+Boehm, H., \"Space Efficient Conservative Garbage Collection\", Proceedings\n+of the ACM SIGPLAN '91 Conference on Programming Language Design and\n+Implementation, SIGPLAN Notices 28, 6 (June 1993), pp. 197-206.\n+\n+  Possible interactions between the collector and optimizing compilers are\n+discussed in\n+\n+Boehm, H., and D. Chase, \"A Proposal for GC-safe C Compilation\",\n+The Journal of C Language Translation 4, 2 (December 1992).\n+\n+and\n+\n+Boehm H., \"Simple GC-safe Compilation\", Proceedings\n+of the ACM SIGPLAN '96 Conference on Programming Language Design and\n+Implementation.\n+\n+(Both are also available from\n+http://reality.sgi.com/employees/boehm_mti/papers/, among other places.)\n+\n+  Unlike the collector described in the second reference, this collector\n+operates either with the mutator stopped during the entire collection\n+(default) or incrementally during allocations.  (The latter is supported\n+on only a few machines.)  It does not rely on threads, but is intended\n+to be thread-safe.\n+\n+  Some of the ideas underlying the collector have previously been explored\n+by others.  (Doug McIlroy wrote a vaguely similar collector that is part of\n+version 8 UNIX (tm).)  However none of this work appears to have been widely\n+disseminated.\n+\n+  Rudimentary tools for use of the collector as a leak detector are included, as\n+is a fairly sophisticated string package \"cord\" that makes use of the collector.\n+(See cord/README.)\n+\n+\n+GENERAL DESCRIPTION\n+\n+  This is a garbage collecting storage allocator that is intended to be\n+used as a plug-in replacement for C's malloc.\n+\n+  Since the collector does not require pointers to be tagged, it does not\n+attempt to ensure that all inaccessible storage is reclaimed.  However,\n+in our experience, it is typically more successful at reclaiming unused\n+memory than most C programs using explicit deallocation.  Unlike manually\n+introduced leaks, the amount of unreclaimed memory typically stays\n+bounded.\n+\n+  In the following, an \"object\" is defined to be a region of memory allocated\n+by the routines described below.  \n+\n+  Any objects not intended to be collected must be pointed to either\n+from other such accessible objects, or from the registers,\n+stack, data, or statically allocated bss segments.  Pointers from\n+the stack or registers may point to anywhere inside an object.\n+The same is true for heap pointers if the collector is compiled with\n+ ALL_INTERIOR_POINTERS defined, as is now the default.\n+\n+Compiling without ALL_INTERIOR_POINTERS may reduce accidental retention\n+of garbage objects, by requiring pointers from the heap to to the beginning\n+of an object.  But this no longer appears to be a significant\n+issue for most programs.\n+\n+There are a number of routines which modify the pointer recognition\n+algorithm.  GC_register_displacement allows certain interior pointers\n+to be recognized even if ALL_INTERIOR_POINTERS is nor defined.\n+GC_malloc_ignore_off_page allows some pointers into the middle of large objects\n+to be disregarded, greatly reducing the probablility of accidental\n+retention of large objects.  For most purposes it seems best to compile\n+with ALL_INTERIOR_POINTERS and to use GC_malloc_ignore_off_page if\n+you get collector warnings from allocations of very large objects.\n+See README.debugging for details.\n+\n+  Note that pointers inside memory allocated by the standard \"malloc\" are not\n+seen by the garbage collector.  Thus objects pointed to only from such a\n+region may be prematurely deallocated.  It is thus suggested that the\n+standard \"malloc\" be used only for memory regions, such as I/O buffers, that\n+are guaranteed not to contain pointers to garbage collectable memory.\n+Pointers in C language automatic, static, or register variables,\n+are correctly recognized.  (Note that GC_malloc_uncollectable has semantics\n+similar to standard malloc, but allocates objects that are traced by the\n+collector.)\n+\n+  The collector does not always know how to find pointers in data\n+areas that are associated with dynamic libraries.  This is easy to\n+remedy IF you know how to find those data areas on your operating\n+system (see GC_add_roots).  Code for doing this under SunOS, IRIX 5.X and 6.X,\n+HP/UX, Alpha OSF/1, Linux, and win32 is included and used by default.  (See\n+README.win32 for win32 details.)  On other systems pointers from dynamic\n+library data areas may not be considered by the collector.\n+\n+  Note that the garbage collector does not need to be informed of shared\n+read-only data.  However if the shared library mechanism can introduce\n+discontiguous data areas that may contain pointers, then the collector does\n+need to be informed.\n+\n+  Signal processing for most signals may be deferred during collection,\n+and during uninterruptible parts of the allocation process.  Unlike\n+standard ANSI C mallocs, it can be safe to invoke malloc\n+from a signal handler while another malloc is in progress, provided\n+the original malloc is not restarted.  (Empirically, many UNIX\n+applications already assume this.)  To obtain this level  of signal\n+safety, remove the definition of -DNO_SIGNALS in Makefile.  This incurs\n+a minor performance penalty, and hence is no longer the default.\n+\n+  The allocator/collector can also be configured for thread-safe operation.\n+(Full signal safety can also be achieved, but only at the cost of two system\n+calls per malloc, which is usually unacceptable.)\n+\n+INSTALLATION AND PORTABILITY\n+\n+  As distributed, the macro SILENT is defined in Makefile.\n+In the event of problems, this can be removed to obtain a moderate\n+amount of descriptive output for each collection.\n+(The given statistics exhibit a few peculiarities.\n+Things don't appear to add up for a variety of reasons, most notably\n+fragmentation losses.  These are probably much more significant for the\n+contrived program \"test.c\" than for your application.)\n+\n+  Note that typing \"make test\" will automatically build the collector\n+and then run setjmp_test and gctest. Setjmp_test will give you information\n+about configuring the collector, which is useful primarily if you have\n+a machine that's not already supported.  Gctest is a somewhat superficial\n+test of collector functionality.  Failure is indicated by a core dump or\n+a message to the effect that the collector is broken.  Gctest takes about \n+35 seconds to run on a SPARCstation 2. On a slower machine,\n+expect it to take a while.  It may use up to 8 MB of memory.  (The\n+multi-threaded version will use more.)  \"Make test\" will also, as\n+its last step, attempt to build and test the \"cord\" string library.\n+This will fail without an ANSI C compiler.\n+\n+  The Makefile will generate a library gc.a which you should link against.\n+Typing \"make cords\" will add the cord library to gc.a.\n+Note that this requires an ANSI C compiler.\n+\n+  It is suggested that if you need to replace a piece of the collector\n+(e.g. GC_mark_rts.c) you simply list your version ahead of gc.a on the\n+\t\twork.)\n+ld command line, rather than replacing the one in gc.a.  (This will\n+generate numerous warnings under some versions of AIX, but it still\n+works.)\n+\n+  All include files that need to be used by clients will be put in the\n+include subdirectory.  (Normally this is just gc.h.  \"Make cords\" adds\n+\"cord.h\" and \"ec.h\".)\n+\n+  The collector currently is designed to run essentially unmodified on\n+machines that use a flat 32-bit or 64-bit address space.\n+That includes the vast majority of Workstations and X86 (X >= 3) PCs.\n+(The list here was deleted because it was getting too long and constantly\n+out of date.)\n+  It does NOT run under plain 16-bit DOS or Windows 3.X.  There are however\n+various packages (e.g. win32s, djgpp) that allow flat 32-bit address\n+applications to run under those systemsif the have at least an 80386 processor,\n+and several of those are compatible with the collector.\n+\n+  In a few cases (Amiga, OS/2, Win32, MacOS) a separate makefile\n+or equivalent is supplied.  Many of these have separate README.system\n+files.\n+\n+  Dynamic libraries are completely supported only under SunOS\n+(and even that support is not functional on the last Sun 3 release),\n+IRIX 5&6, HP-PA, Win32 (not Win32S) and OSF/1 on DEC AXP machines.\n+On other machines we recommend that you do one of the following:\n+\n+  1) Add dynamic library support (and send us the code).\n+  2) Use static versions of the libraries.\n+  3) Arrange for dynamic libraries to use the standard malloc.\n+     This is still dangerous if the library stores a pointer to a\n+     garbage collected object.  But nearly all standard interfaces\n+     prohibit this, because they deal correctly with pointers\n+     to stack allocated objects.  (Strtok is an exception.  Don't\n+     use it.)\n+\n+  In all cases we assume that pointer alignment is consistent with that\n+enforced by the standard C compilers.  If you use a nonstandard compiler\n+you may have to adjust the alignment parameters defined in gc_priv.h.\n+\n+  A port to a machine that is not byte addressed, or does not use 32 bit\n+or 64 bit addresses will require a major effort.  A port to plain MSDOS\n+or win16 is hard.\n+\n+  For machines not already mentioned, or for nonstandard compilers, the\n+following are likely to require change:\n+\n+1.  The parameters in config.h.\n+      The parameters that will usually require adjustment are\n+   STACKBOTTOM,  ALIGNMENT and DATASTART.  Setjmp_test\n+   prints its guesses of the first two.\n+      DATASTART should be an expression for computing the\n+   address of the beginning of the data segment.  This can often be\n+   &etext.  But some memory management units require that there be\n+   some unmapped space between the text and the data segment.  Thus\n+   it may be more complicated.   On UNIX systems, this is rarely\n+   documented.  But the adb \"$m\" command may be helpful.  (Note\n+   that DATASTART will usually be a function of &etext.  Thus a\n+   single experiment is usually insufficient.)\n+     STACKBOTTOM is used to initialize GC_stackbottom, which\n+   should be a sufficient approximation to the coldest stack address.\n+   On some machines, it is difficult to obtain such a value that is\n+   valid across a variety of MMUs, OS releases, etc.  A number of\n+   alternatives exist for using the collector in spite of this.  See the\n+   discussion in config.h immediately preceding the various\n+   definitions of STACKBOTTOM.\n+   \n+2.  mach_dep.c.\n+      The most important routine here is one to mark from registers.\n+    The distributed file includes a generic hack (based on setjmp) that\n+    happens to work on many machines, and may work on yours.  Try\n+    compiling and running setjmp_t.c to see whether it has a chance of\n+    working.  (This is not correct C, so don't blame your compiler if it\n+    doesn't work.  Based on limited experience, register window machines\n+    are likely to cause trouble.  If your version of setjmp claims that\n+    all accessible variables, including registers, have the value they\n+    had at the time of the longjmp, it also will not work.  Vanilla 4.2 BSD\n+    on Vaxen makes such a claim.  SunOS does not.)\n+      If your compiler does not allow in-line assembly code, or if you prefer\n+    not to use such a facility, mach_dep.c may be replaced by a .s file\n+    (as we did for the MIPS machine and the PC/RT).\n+      At this point enough architectures are supported by mach_dep.c\n+    that you will rarely need to do more than adjust for assembler\n+    syntax.\n+\n+3.  os_dep.c (and gc_priv.h).\n+  \t  Several kinds of operating system dependent routines reside here.\n+  \tMany are optional.  Several are invoked only through corresponding\n+  \tmacros in gc_priv.h, which may also be redefined as appropriate.\n+      The routine GC_register_data_segments is crucial.  It registers static\n+    data areas that must be traversed by the collector. (User calls to\n+    GC_add_roots may sometimes be used for similar effect.)\n+      Routines to obtain memory from the OS also reside here.\n+    Alternatively this can be done entirely by the macro GET_MEM\n+    defined in gc_priv.h.  Routines to disable and reenable signals\n+    also reside here if they are need by the macros DISABLE_SIGNALS\n+    and ENABLE_SIGNALS defined in gc_priv.h.\n+      In a multithreaded environment, the macros LOCK and UNLOCK\n+    in gc_priv.h will need to be suitably redefined.\n+      The incremental collector requires page dirty information, which\n+    is acquired through routines defined in os_dep.c.  Unless directed\n+    otherwise by config.h, these are implemented as stubs that simply\n+    treat all pages as dirty.  (This of course makes the incremental\n+    collector much less useful.)\n+\n+4.  dyn_load.c\n+\tThis provides a routine that allows the collector to scan data\n+\tsegments associated with dynamic libraries.  Often it is not\n+\tnecessary to provide this routine unless user-written dynamic\n+\tlibraries are used.\n+\n+  For a different version of UN*X or different machines using the\n+Motorola 68000, Vax, SPARC, 80386, NS 32000, PC/RT, or MIPS architecture,\n+it should frequently suffice to change definitions in config.h.\n+\n+\n+THE C INTERFACE TO THE ALLOCATOR\n+\n+  The following routines are intended to be directly called by the user.\n+Note that usually only GC_malloc is necessary.  GC_clear_roots and GC_add_roots\n+calls may be required if the collector has to trace from nonstandard places\n+(e.g. from dynamic library data areas on a machine on which the \n+collector doesn't already understand them.)  On some machines, it may\n+be desirable to set GC_stacktop to a good approximation of the stack base. \n+(This enhances code portability on HP PA machines, since there is no\n+good way for the collector to compute this value.)  Client code may include\n+\"gc.h\", which defines all of the following, plus many others.\n+\n+1)  GC_malloc(nbytes)\n+    - allocate an object of size nbytes.  Unlike malloc, the object is\n+      cleared before being returned to the user.  Gc_malloc will\n+      invoke the garbage collector when it determines this to be appropriate.\n+      GC_malloc may return 0 if it is unable to acquire sufficient\n+      space from the operating system.  This is the most probable\n+      consequence of running out of space.  Other possible consequences\n+      are that a function call will fail due to lack of stack space,\n+      or that the collector will fail in other ways because it cannot\n+      maintain its internal data structures, or that a crucial system\n+      process will fail and take down the machine.  Most of these\n+      possibilities are independent of the malloc implementation.\n+\n+2)  GC_malloc_atomic(nbytes)\n+    - allocate an object of size nbytes that is guaranteed not to contain any\n+      pointers.  The returned object is not guaranteed to be cleared.\n+      (Can always be replaced by GC_malloc, but results in faster collection\n+      times.  The collector will probably run faster if large character\n+      arrays, etc. are allocated with GC_malloc_atomic than if they are\n+      statically allocated.)\n+\n+3)  GC_realloc(object, new_size)\n+    - change the size of object to be new_size.  Returns a pointer to the\n+      new object, which may, or may not, be the same as the pointer to\n+      the old object.  The new object is taken to be atomic iff the old one\n+      was.  If the new object is composite and larger than the original object,\n+      then the newly added bytes are cleared (we hope).  This is very likely\n+      to allocate a new object, unless MERGE_SIZES is defined in gc_priv.h.\n+      Even then, it is likely to recycle the old object only if the object\n+      is grown in small additive increments (which, we claim, is generally bad\n+      coding practice.)\n+\n+4)  GC_free(object)\n+    - explicitly deallocate an object returned by GC_malloc or\n+      GC_malloc_atomic.  Not necessary, but can be used to minimize\n+      collections if performance is critical.  Probably a performance\n+      loss for very small objects (<= 8 bytes).\n+\n+5)  GC_expand_hp(bytes)\n+    - Explicitly increase the heap size.  (This is normally done automatically\n+      if a garbage collection failed to GC_reclaim enough memory.  Explicit\n+      calls to GC_expand_hp may prevent unnecessarily frequent collections at\n+      program startup.)\n+\n+6)  GC_malloc_ignore_off_page(bytes)\n+\t- identical to GC_malloc, but the client promises to keep a pointer to\n+\t  the somewhere within the first 256 bytes of the object while it is\n+\t  live.  (This pointer should nortmally be declared volatile to prevent\n+\t  interference from compiler optimizations.)  This is the recommended\n+\t  way to allocate anything that is likely to be larger than 100Kbytes\n+\t  or so.  (GC_malloc may result in failure to reclaim such objects.)\n+\n+7)  GC_set_warn_proc(proc)\n+\t- Can be used to redirect warnings from the collector.  Such warnings\n+\t  should be rare, and should not be ignored during code development.\n+      \n+8) GC_enable_incremental()\n+    - Enables generational and incremental collection.  Useful for large\n+      heaps on machines that provide access to page dirty information.\n+      Some dirty bit implementations may interfere with debugging\n+      (by catching address faults) and place restrictions on heap arguments\n+      to system calls (since write faults inside a system call may not be\n+      handled well).\n+\n+9) Several routines to allow for registration of finalization code.\n+   User supplied finalization code may be invoked when an object becomes\n+   unreachable.  To call (*f)(obj, x) when obj becomes inaccessible, use\n+\tGC_register_finalizer(obj, f, x, 0, 0);\n+   For more sophisticated uses, and for finalization ordering issues,\n+   see gc.h.\n+\n+  The global variable GC_free_space_divisor may be adjusted up from its\n+default value of 4 to use less space and more collection time, or down for\n+the opposite effect.  Setting it to 1 or 0 will effectively disable collections\n+and cause all allocations to simply grow the heap.\n+\n+  The variable GC_non_gc_bytes, which is normally 0, may be changed to reflect\n+the amount of memory allocated by the above routines that should not be\n+considered as a candidate for collection.  Careless use may, of course, result\n+in excessive memory consumption.\n+\n+  Some additional tuning is possible through the parameters defined\n+near the top of gc_priv.h.\n+  \n+  If only GC_malloc is intended to be used, it might be appropriate to define:\n+\n+#define malloc(n) GC_malloc(n)\n+#define calloc(m,n) GC_malloc((m)*(n))\n+\n+  For small pieces of VERY allocation intensive code, gc_inl.h\n+includes some allocation macros that may be used in place of GC_malloc\n+and friends.\n+\n+  All externally visible names in the garbage collector start with \"GC_\".\n+To avoid name conflicts, client code should avoid this prefix, except when\n+accessing garbage collector routines or variables.\n+\n+  There are provisions for allocation with explicit type information.\n+This is rarely necessary.  Details can be found in gc_typed.h.\n+\n+THE C++ INTERFACE TO THE ALLOCATOR:\n+\n+  The Ellis-Hull C++ interface to the collector is included in\n+the collector distribution.  If you intend to use this, type\n+\"make c++\" after the initial build of the collector is complete.\n+See gc_cpp.h for the definition of the interface.  This interface\n+tries to approximate the Ellis-Detlefs C++ garbage collection\n+proposal without compiler changes.\n+\n+Cautions:\n+1. Arrays allocated without new placement syntax are\n+allocated as uncollectable objects.  They are traced by the\n+collector, but will not be reclaimed.\n+\n+2. Failure to use \"make c++\" in combination with (1) will\n+result in arrays allocated using the default new operator.\n+This is likely to result in disaster without linker warnings.\n+\n+3. If your compiler supports an overloaded new[] operator,\n+then gc_cpp.cc and gc_cpp.h should be suitably modified.\n+\n+4. Many current C++ compilers have deficiencies that\n+break some of the functionality.  See the comments in gc_cpp.h\n+for suggested workarounds.\n+\n+USE AS LEAK DETECTOR:\n+\n+  The collector may be used to track down leaks in C programs that are\n+intended to run with malloc/free (e.g. code with extreme real-time or\n+portability constraints).  To do so define FIND_LEAK in Makefile\n+This will cause the collector to invoke the report_leak\n+routine defined near the top of reclaim.c whenever an inaccessible\n+object is found that has not been explicitly freed.  The collector will\n+no longer reclaim inaccessible memory; in this form it is purely a\n+debugging tool.\n+  Productive use of this facility normally involves redefining report_leak\n+to do something more intelligent.  This typically requires annotating\n+objects with additional information (e.g. creation time stack trace) that\n+identifies their origin.  Such code is typically not very portable, and is\n+not included here, except on SPARC machines.\n+  If all objects are allocated with GC_DEBUG_MALLOC (see next section),\n+then the default version of report_leak will report the source file\n+and line number at which the leaked object was allocated.  This may\n+sometimes be sufficient.  (On SPARC/SUNOS4 machines, it will also report\n+a cryptic stack trace.  This can often be turned into a sympolic stack\n+trace by invoking program \"foo\" with \"callprocs foo\".  Callprocs is\n+a short shell script that invokes adb to expand program counter values\n+to symbolic addresses.  It was largely supplied by Scott Schwartz.)\n+  Note that the debugging facilities described in the next section can\n+sometimes be slightly LESS effective in leak finding mode, since in\n+leak finding mode, GC_debug_free actually results in reuse of the object.\n+(Otherwise the object is simply marked invalid.)  Also note that the test\n+program is not designed to run meaningfully in FIND_LEAK mode.\n+Use \"make gc.a\" to build the collector.\n+\n+DEBUGGING FACILITIES:\n+\n+  The routines GC_debug_malloc, GC_debug_malloc_atomic, GC_debug_realloc,\n+and GC_debug_free provide an alternate interface to the collector, which\n+provides some help with memory overwrite errors, and the like.\n+Objects allocated in this way are annotated with additional\n+information.  Some of this information is checked during garbage\n+collections, and detected inconsistencies are reported to stderr.\n+\n+  Simple cases of writing past the end of an allocated object should\n+be caught if the object is explicitly deallocated, or if the\n+collector is invoked while the object is live.  The first deallocation\n+of an object will clear the debugging info associated with an\n+object, so accidentally repeated calls to GC_debug_free will report the\n+deallocation of an object without debugging information.  Out of\n+memory errors will be reported to stderr, in addition to returning\n+NIL.\n+\n+  GC_debug_malloc checking  during garbage collection is enabled\n+with the first call to GC_debug_malloc.  This will result in some\n+slowdown during collections.  If frequent heap checks are desired,\n+this can be achieved by explicitly invoking GC_gcollect, e.g. from\n+the debugger.\n+\n+  GC_debug_malloc allocated objects should not be passed to GC_realloc\n+or GC_free, and conversely.  It is however acceptable to allocate only\n+some objects with GC_debug_malloc, and to use GC_malloc for other objects,\n+provided the two pools are kept distinct.  In this case, there is a very\n+low probablility that GC_malloc allocated objects may be misidentified as\n+having been overwritten.  This should happen with probability at most\n+one in 2**32.  This probability is zero if GC_debug_malloc is never called.\n+\n+  GC_debug_malloc, GC_malloc_atomic, and GC_debug_realloc take two\n+additional trailing arguments, a string and an integer.  These are not\n+interpreted by the allocator.  They are stored in the object (the string is\n+not copied).  If an error involving the object is detected, they are printed.\n+\n+  The macros GC_MALLOC, GC_MALLOC_ATOMIC, GC_REALLOC, GC_FREE, and\n+GC_REGISTER_FINALIZER are also provided.  These require the same arguments\n+as the corresponding (nondebugging) routines.  If gc.h is included\n+with GC_DEBUG defined, they call the debugging versions of these\n+functions, passing the current file name and line number as the two\n+extra arguments, where appropriate.  If gc.h is included without GC_DEBUG\n+defined, then all these macros will instead be defined to their nondebugging\n+equivalents.  (GC_REGISTER_FINALIZER is necessary, since pointers to\n+objects with debugging information are really pointers to a displacement\n+of 16 bytes form the object beginning, and some translation is necessary\n+when finalization routines are invoked.  For details, about what's stored\n+in the header, see the definition of the type oh in debug_malloc.c)\n+\n+INCREMENTAL/GENERATIONAL COLLECTION:\n+\n+The collector normally interrupts client code for the duration of \n+a garbage collection mark phase.  This may be unacceptable if interactive\n+response is needed for programs with large heaps.  The collector\n+can also run in a \"generational\" mode, in which it usually attempts to\n+collect only objects allocated since the last garbage collection.\n+Furthermore, in this mode, garbage collections run mostly incrementally,\n+with a small amount of work performed in response to each of a large number of\n+GC_malloc requests.\n+\n+This mode is enabled by a call to GC_enable_incremental().\n+\n+Incremental and generational collection is effective in reducing\n+pause times only if the collector has some way to tell which objects\n+or pages have been recently modified.  The collector uses two sources\n+of information:\n+\n+1. Information provided by the VM system.  This may be provided in\n+one of several forms.  Under Solaris 2.X (and potentially under other\n+similar systems) information on dirty pages can be read from the\n+/proc file system.  Under other systems (currently SunOS4.X) it is\n+possible to write-protect the heap, and catch the resulting faults.\n+On these systems we require that system calls writing to the heap\n+(other than read) be handled specially by client code.\n+See os_dep.c for details.\n+\n+2. Information supplied by the programmer.  We define \"stubborn\"\n+objects to be objects that are rarely changed.  Such an object\n+can be allocated (and enabled for writing) with GC_malloc_stubborn.\n+Once it has been initialized, the collector should be informed with\n+a call to GC_end_stubborn_change.  Subsequent writes that store\n+pointers into the object must be preceded by a call to\n+GC_change_stubborn.\n+\n+This mechanism performs best for objects that are written only for\n+initialization, and such that only one stubborn object is writable\n+at once.  It is typically not worth using for short-lived\n+objects.  Stubborn objects are treated less efficiently than pointerfree\n+(atomic) objects.\n+\n+A rough rule of thumb is that, in the absence of VM information, garbage\n+collection pauses are proportional to the amount of pointerful storage\n+plus the amount of modified \"stubborn\" storage that is reachable during\n+the collection.  \n+\n+Initial allocation of stubborn objects takes longer than allocation\n+of other objects, since other data structures need to be maintained.\n+\n+We recommend against random use of stubborn objects in client\n+code, since bugs caused by inappropriate writes to stubborn objects\n+are likely to be very infrequently observed and hard to trace.  \n+However, their use may be appropriate in a few carefully written\n+library routines that do not make the objects themselves available\n+for writing by client code.\n+\n+\n+BUGS:\n+\n+  Any memory that does not have a recognizable pointer to it will be\n+reclaimed.  Exclusive-or'ing forward and backward links in a list\n+doesn't cut it.\n+  Some C optimizers may lose the last undisguised pointer to a memory\n+object as a consequence of clever optimizations.  This has almost\n+never been observed in practice.  Send mail to boehm@mti.sgi.com\n+for suggestions on how to fix your compiler.\n+  This is not a real-time collector.  In the standard configuration,\n+percentage of time required for collection should be constant across\n+heap sizes.  But collection pauses will increase for larger heaps.\n+(On SPARCstation 2s collection times will be on the order of 300 msecs\n+per MB of accessible memory that needs to be scanned.  Your mileage\n+may vary.)  The incremental/generational collection facility helps,\n+but is portable only if \"stubborn\" allocation is used.\n+  Please address bug reports to boehm@mti.sgi.com.  If you are\n+contemplating a major addition, you might also send mail to ask whether\n+it's already been done (or whether we tried and discarded it).\n+\n+RECENT VERSIONS:\n+\n+  Version 1.3 and immediately preceding versions contained spurious\n+assembly language assignments to TMP_SP.  Only the assignment in the PC/RT\n+code is necessary.  On other machines, with certain compiler options,\n+the assignments can lead to an unsaved register being overwritten.\n+Known to cause problems under SunOS 3.5 WITHOUT the -O option.  (With\n+-O the compiler recognizes it as dead code.  It probably shouldn't,\n+but that's another story.)\n+\n+  Version 1.4 and earlier versions used compile time determined values\n+for the stack base.  This no longer works on Sun 3s, since Sun 3/80s use\n+a different stack base.  We now use a straightforward heuristic on all\n+machines on which it is known to work (incl. Sun 3s) and compile-time\n+determined values for the rest.  There should really be library calls\n+to determine such values.\n+\n+  Version 1.5 and earlier did not ensure 8 byte alignment for objects\n+allocated on a sparc based machine.\n+\n+  Version 1.8 added ULTRIX support in gc_private.h.\n+  \n+  Version 1.9 fixed a major bug in gc_realloc.\n+  \n+  Version 2.0 introduced a consistent naming convention for collector\n+routines and added support for registering dynamic library data segments\n+in the standard mark_roots.c.  Most of the data structures were revamped.\n+The treatment of interior pointers was completely changed.  Finalization\n+was added.  Support for locking was added.  Object kinds were added.\n+We added a black listing facility to avoid allocating at addresses known\n+to occur as integers somewhere in the address space.  Much of this\n+was accomplished by adapting ideas and code from the PCR collector.\n+The test program was changed and expanded.\n+\n+  Version 2.1 was the first stable version since 1.9, and added support\n+for PPCR.\n+\n+  Version 2.2 added debugging allocation, and fixed various bugs.  Among them:\n+- GC_realloc could fail to extend the size of the object for certain large object sizes.\n+- A blatant subscript range error in GC_printf, which unfortunately\n+  wasn't exercised on machines with sufficient stack alignment constraints.\n+- GC_register_displacement did the wrong thing if it was called after\n+  any allocation had taken place.\n+- The leak finding code would eventually break after 2048 byte\n+  byte objects leaked.\n+- interface.c didn't compile.\n+- The heap size remained much too small for large stacks.\n+- The stack clearing code behaved badly for large stacks, and perhaps\n+  on HP/PA machines.\n+\n+  Version 2.3 added ALL_INTERIOR_POINTERS and fixed the following bugs:\n+- Missing declaration of etext in the A/UX version.\n+- Some PCR root-finding problems.\n+- Blacklisting was not 100% effective, because the plausible future\n+  heap bounds were being miscalculated.\n+- GC_realloc didn't handle out-of-memory correctly.\n+- GC_base could return a nonzero value for addresses inside free blocks.\n+- test.c wasn't really thread safe, and could erroneously report failure\n+  in a multithreaded environment.  (The locking primitives need to be\n+  replaced for other threads packages.)\n+- GC_CONS was thoroughly broken.\n+- On a SPARC with dynamic linking, signals stayed diabled while the\n+  client code was running.\n+  (Thanks to Manuel Serrano at INRIA for reporting the last two.)\n+  \n+  Version 2.4 added GC_free_space_divisor as a tuning knob, added\n+  support for OS/2 and linux, and fixed the following bugs:\n+- On machines with unaligned pointers (e.g. Sun 3), every 128th word could\n+  fail to be considered for marking.\n+- Dynamic_load.c erroneously added 4 bytes to the length of the data and\n+  bss sections of the dynamic library.  This could result in a bad memory\n+  reference if the actual length was a multiple of a page.  (Observed on\n+  Sun 3.  Can probably also happen on a Sun 4.)\n+  (Thanks to Robert Brazile for pointing out that the Sun 3 version\n+  was broken.  Dynamic library handling is still broken on Sun 3s\n+  under 4.1.1U1, but apparently not 4.1.1.  If you have such a machine,\n+  use -Bstatic.)\n+  \n+  Version 2.5 fixed the following bugs:\n+- Removed an explicit call to exit(1)\n+- Fixed calls to GC_printf and GC_err_printf, so the correct number of\n+  arguments are always supplied.  The OS/2 C compiler gets confused if\n+  the number of actuals and the number of formals differ.  (ANSI C\n+  doesn't require this to work.  The ANSI sanctioned way of doing things\n+  causes too many compatibility problems.)\n+  \n+  Version 3.0  added generational/incremental collection and stubborn\n+  objects.\n+\n+  Version 3.1 added the following features:\n+- A workaround for a SunOS 4.X SPARC C compiler\n+  misfeature that caused problems when the collector was turned into\n+  a dynamic library.  \n+- A fix for a bug in GC_base that could result in a memory fault.\n+- A fix for a performance bug (and several other misfeatures) pointed\n+  out by Dave Detlefs and Al Dosser.\n+- Use of dirty bit information for static data under Solaris 2.X.\n+- DEC Alpha/OSF1 support (thanks to Al Dosser).\n+- Incremental collection on more platforms.\n+- A more refined heap expansion policy.  Less space usage by default.\n+- Various minor enhancements to reduce space usage, and to reduce\n+  the amount of memory scanned by the collector.\n+- Uncollectable allocation without per object overhead.\n+- More conscientious handling of out-of-memory conditions.\n+- Fixed a bug in debugging stubborn allocation.\n+- Fixed a bug that resulted in occasional erroneous reporting of smashed\n+  objects with debugging allocation.\n+- Fixed bogus leak reports of size 4096 blocks with FIND_LEAK.\n+\n+  Version 3.2 fixed a serious and not entirely repeatable bug in\n+  the incremental collector.  It appeared only when dirty bit info\n+  on the roots was available, which is normally only under Solaris.\n+  It also added GC_general_register_disappearing_link, and some\n+  testing code.  Interface.c disappeared.\n+\n+  Version 3.3 fixes several bugs and adds new ports:\n+- PCR-specific bugs.\n+- Missing locking in GC_free, redundant FASTUNLOCK\n+  in GC_malloc_stubborn, and 2 bugs in\n+  GC_unregister_disappearing_link.\n+  All of the above were pointed out by Neil Sharman\n+  (neil@cs.mu.oz.au).\n+- Common symbols allocated by the SunOS4.X dynamic loader\n+  were not included in the root set.\n+- Bug in GC_finalize (reported by Brian Beuning and Al Dosser)\n+- Merged Amiga port from Jesper Peterson (untested)\n+- Merged NeXT port from Thomas Funke (significantly\n+  modified and untested)\n+\n+  Version 3.4:\n+- Fixed a performance bug in GC_realloc.\n+- Updated the amiga port.\n+- Added NetBSD and 386BSD ports.\n+- Added cord library.\n+- Added trivial performance enhancement for\n+  ALL_INTERIOR_POINTERS.  (Don't scan last word.)\n+  \n+  Version 3.5\n+- Minor collections now mark from roots only once, if that\n+  doesn't cause an excessive pause.\n+- The stack clearing heuristic was refined to prevent anomalies\n+  with very heavily recursive programs and sparse stacks.\n+- Fixed a bug that prevented mark stack growth in some cases.\n+  GC_objects_are_marked should be set to TRUE after a call\n+  to GC_push_roots and as part of GC_push_marked, since\n+  both can now set mark bits.  I think this is only a performance\n+  bug, but I wouldn't bet on it.  It's certainly very hard to argue\n+  that the old version was correct.\n+- Fixed an incremental collection bug that prevented it from\n+  working at all when HBLKSIZE != getpagesize()\n+- Changed dynamic_loading.c to include gc_priv.h before testing\n+  DYNAMIC_LOADING.  SunOS dynamic library scanning\n+  must have been broken in 3.4.\n+- Object size rounding now adapts to program behavior.\n+- Added a workaround (provided by Manuel Serrano and\n+  colleagues) to a long-standing SunOS 4.X (and 3.X?) ld bug\n+  that I had incorrectly assumed to have been squished.\n+  The collector was broken if the text segment size was within\n+  32 bytes of a multiple of 8K bytes, and if the beginning of\n+  the data segment contained interesting roots.  The workaround\n+  assumes a demand-loadable executable.  The original may have\n+  have \"worked\" in some other cases.\n+- Added dynamic library support under IRIX5.\n+- Added support for EMX under OS/2 (thanks to Ari Huttunen).\n+  \n+Version 3.6:\n+- fixed a bug in the mark stack growth code that was introduced\n+  in 3.4.\n+- fixed Makefile to work around DEC AXP compiler tail recursion\n+  bug.\n+\n+Version 3.7:\n+- Added a workaround for an HP/UX compiler bug.\n+- Fixed another stack clearing performance bug.  Reworked\n+  that code once more.\n+  \n+Version 4.0:\n+- Added support for Solaris threads (which was possible\n+  only by reimplementing some fraction of Solaris threads,\n+  since Sun doesn't currently make the thread debugging\n+  interface available).\n+- Added non-threads win32 and win32S support.\n+- (Grudgingly, with suitable muttering of obscenities) renamed\n+  files so that the collector distribution could live on a FAT\n+  file system.  Files that are guaranteed to be useless on\n+  a PC still have long names.  Gc_inline.h and gc_private.h\n+  still exist, but now just include  gc_inl.h and gc_priv.h.\n+- Fixed a really obscure bug in finalization that could cause\n+  undetected mark stack overflows.  (I would be surprised if\n+  any real code ever tickled this one.)\n+- Changed finalization code to dynamically resize the hash\n+  tables it maintains.  (This probably does not matter for well-\n+  -written code.  It no doubt does for C++ code that overuses\n+  destructors.)\n+- Added typed allocation primitives.  Rewrote the marker to\n+  accommodate them with more reasonable efficiency.  This\n+  change should also speed up marking for GC_malloc allocated\n+  objects a little.  See gc_typed.h for new primitives.\n+- Improved debugging facilities slightly.  Allocation time\n+  stack traces are now kept by default on SPARC/SUNOS4.\n+  (Thanks to Scott Schwartz.)\n+- Added better support for small heap applications.\n+- Significantly extended cord package.  Fixed a bug in the\n+  implementation of lazily read files.  Printf and friends now\n+  have cord variants.  Cord traversals are a bit faster.\n+- Made ALL_INTERIOR_POINTERS recognition the default.\n+- Fixed de so that it can run in constant space, independent\n+  of file size.  Added simple string searching to cords and de.\n+- Added the Hull-Ellis C++ interface.\n+- Added dynamic library support for OSF/1.\n+  (Thanks to Al Dosser and Tim Bingham at DEC.)\n+- Changed argument to GC_expand_hp to be expressed\n+  in units of bytes instead of heap blocks.  (Necessary\n+  since the heap block size now varies depending on\n+  configuration.  The old version was never very clean.)\n+- Added GC_get_heap_size().  The previous \"equivalent\"\n+  was broken.\n+- Restructured the Makefile a bit.  \n+\n+Since version 4.0:\n+- Changed finalization implementation to guarantee that\n+  finalization procedures are called outside of the allocation\n+  lock, making direct use of the interface a little less dangerous.\n+  MAY BREAK EXISTING CLIENTS that assume finalizers\n+  are protected by a lock.  Since there seem to be few multithreaded\n+  clients that use finalization, this is hopefully not much of\n+  a problem.\n+- Fixed a gross bug in CORD_prev.\n+- Fixed a bug in blacklst.c that could result in unbounded\n+  heap growth during startup on machines that do not clear\n+  memory obtained from the OS (e.g. win32S).\n+- Ported de editor to win32/win32S.  (This is now the only\n+  version with a mouse-sensitive UI.)\n+- Added GC_malloc_ignore_off_page to allocate large arrays\n+  in the presence of ALL_INTERIOR_POINTERS.\n+- Changed GC_call_with_alloc_lock to not disable signals in\n+  the single-threaded case.\n+- Reduced retry count in GC_collect_or_expand for garbage\n+  collecting when out of memory.\n+- Made uncollectable allocations bypass black-listing, as they\n+  should.\n+- Fixed a bug in typed_test in test.c that could cause (legitimate)\n+  GC crashes.\n+- Fixed some potential synchronization problems in finalize.c\n+- Fixed a real locking problem in typd_mlc.c.\n+- Worked around an AIX 3.2 compiler feature that results in\n+  out of bounds memory references.\n+- Partially worked around an IRIX5.2 beta problem (which may\n+  or may not persist to the final release).\n+- Fixed a bug in the heap integrity checking code that could\n+  result in explicitly deallocated objects being identified as\n+  smashed.  Fixed a bug in the dbg_mlc stack saving code\n+  that caused old argument pointers to be considered live.\n+- Fixed a bug in CORD_ncmp (and hence CORD_str).\n+- Repaired the OS2 port, which had suffered from bit rot\n+  in 4.0.  Worked around what appears to be CSet/2 V1.0\n+  optimizer bug.\n+- Fixed a Makefile bug for target \"c++\".\n+\n+Since version 4.1:\n+- Multiple bug fixes/workarounds in the Solaris threads version.\n+  (It occasionally failed to locate some register contents for\n+  marking.  It also turns out that thr_suspend and friends are\n+  unreliable in Solaris 2.3.  Dirty bit reads appear\n+  to be unreliable under some weird \n+  circumstances.  My stack marking code\n+  contained a serious performance bug.  The new code is\n+  extremely defensive, and has not failed in several cpu\n+  hours of testing.  But  no guarantees ...)\n+- Added MacOS support (thanks to Patrick Beard.)\n+- Fixed several syntactic bugs in gc_c++.h and friends.  (These\n+  didn't bother g++, but did bother most other compilers.)\n+  Fixed gc_c++.h finalization interface.  (It didn't.)\n+- 64 bit alignment for allocated objects was not guaranteed in a\n+  few cases in which it should have been.\n+- Added GC_malloc_atomic_ignore_off_page.\n+- Added GC_collect_a_little.\n+- Added some prototypes to gc.h.\n+- Some other minor bug fixes (notably in Makefile).\n+- Fixed OS/2 / EMX port (thanks to Ari Huttunen).\n+- Fixed AmigaDOS port. (thanks to Michel Schinz).\n+- Fixed the DATASTART definition under Solaris.  There\n+  was a 1 in 16K chance of the collector missing the first\n+  64K of static data (and thus crashing).\n+- Fixed some blatant anachronisms in the README file.\n+- Fixed PCR-Makefile for upcoming PPCR release.\n+\n+Since version 4.2:\n+- Fixed SPARC alignment problem with GC_DEBUG.\n+- Fixed Solaris threads /proc workaround.  The real\n+  problem was an interaction with mprotect.\n+- Incorporated fix from Patrick Beard for gc_c++.h (now gc_cpp.h).\n+- Slightly improved allocator space utilization by\n+  fixing the GC_size_map mechanism.\n+- Integrated some Sony News and MIPS RISCos 4.51\n+  patches.  (Thanks to Nobuyuki Hikichi of\n+  Software Research Associates, Inc. Japan)\n+- Fixed HP_PA alignment problem.  (Thanks to\n+  xjam@cork.cs.berkeley.edu.)\n+- Added GC_same_obj and friends.  Changed GC_base\n+  to return 0 for pointers past the end of large objects.\n+  Improved GC_base performance with ALL_INTERIOR_POINTERS\n+  on machines with a slow integer mod operation.\n+  Added GC_PTR_ADD, GC_PTR_STORE, etc. to prepare\n+  for preprocessor.\n+- changed the default on most UNIX machines to be that\n+  signals are not disabled during critical GC operations.\n+  This is still ANSI-conforming, though somewhat dangerous\n+  in the presence of signal handlers. But the performance\n+  cost of the alternative is sometimes problematic.\n+  Can be changed back with a minor Makefile edit.\n+- renamed IS_STRING in gc.h, to CORD_IS_STRING, thus\n+  following my own naming convention.  Added the function\n+  CORD_to_const_char_star.\n+- Fixed a gross bug in GC_finalize.  Symptom: occasional\n+  address faults in that function.  (Thanks to Anselm\n+  Baird-Smith (Anselm.BairdSmith@inria.fr)\n+- Added port to ICL DRS6000 running DRS/NX.  Restructured\n+  things a bit to factor out common code, and remove obsolete\n+  code.  Collector should now run under SUNOS5 with either\n+  mprotect or /proc dirty bits.  (Thanks to Douglas Steel\n+  (doug@wg.icl.co.uk)).\n+- More bug fixes and workarounds for Solaris 2.X.  (These were\n+  mostly related to putting the collector in a dynamic library,\n+  which didn't really work before.  Also SOLARIS_THREADS\n+  didn't interact well with dl_open.)  Thanks to btlewis@eng.sun.com.\n+- Fixed a serious performance bug on the DEC Alpha.  The text\n+  segment was getting registered as part of the root set.\n+  (Amazingly, the result was still fast enough that the bug\n+  was not conspicuous.) The fix works on OSF/1, version 1.3.\n+  Hopefully it also works on other versions of OSF/1 ...\n+- Fixed a bug in GC_clear_roots.\n+- Fixed a bug in GC_generic_malloc_words_small that broke\n+  gc_inl.h.  (Reported by Antoine de Maricourt.  I broke it\n+  in trying to tweak the Mac port.) \n+- Fixed some problems with cord/de under Linux.\n+- Fixed some cord problems, notably with CORD_riter4.\n+- Added DG/UX port.\n+  Thanks to Ben A. Mesander (ben@piglet.cr.usgs.gov)\n+- Added finalization registration routines with weaker ordering\n+  constraints.  (This is necessary for C++ finalization with\n+  multiple inheritance, since the compiler often adds self-cycles.)\n+- Filled the holes in the SCO port. (Thanks to Michael Arnoldus\n+  <chime@proinf.dk>.)\n+- John Ellis' additions to the C++ support:  From John:\n+\n+* I completely rewrote the documentation in the interface gc_c++.h\n+(later renamed gc_cpp.h).  I've tried to make it both clearer and more\n+precise.\n+\n+* The definition of accessibility now ignores pointers from an\n+finalizable object (an object with a clean-up function) to itself.\n+This allows objects with virtual base classes to be finalizable by the\n+collector.  Compilers typically implement virtual base classes using\n+pointers from an object to itself, which under the old definition of\n+accessibility prevented objects with virtual base classes from ever\n+being collected or finalized.\n+\n+* gc_cleanup now includes gc as a virtual base.  This was enabled by\n+the change in the definition of accessibility.\n+\n+* I added support for operator new[].  Since most (all?) compilers\n+don't yet support operator new[], it is conditionalized on\n+-DOPERATOR_NEW_ARRAY.  The code is untested, but its trivial and looks\n+correct.\n+\n+* The test program test_gc_c++ (later renamed test_cpp.cc)\n+tries to test for the C++-specific functionality not tested by the\n+other programs.\n+- Added <unistd.h> include to misc.c.  (Needed for ppcr.)\n+- Added PowerMac port. (Thanks to Patrick Beard again.)\n+- Fixed \"srcdir\"-related Makefile problems.  Changed things so\n+  that all externally visible include files always appear in the\n+  include subdirectory of the source.  Made gc.h directly\n+  includable from C++ code.  (These were at Per\n+  Bothner's suggestion.)\n+- Changed Intel code to also mark from ebp (Kevin Warne's\n+  suggestion).\n+- Renamed C++ related files so they could live in a FAT\n+  file system. (Charles Fiterman's suggestion.)\n+- Changed Windows NT Makefile to include C++ support in\n+  gc.lib.  Added C++ test as Makefile target.\n+  \n+Since version 4.3:\n+ - ASM_CLEAR_CODE was erroneously defined for HP\n+   PA machines, resulting in a compile error.\n+ - Fixed OS/2 Makefile to create a library.  (Thanks to\n+   Mark Boulter (mboulter@vnet.ibm.com)).\n+ - Gc_cleanup objects didn't work if they were created on\n+   the stack.  Fixed.\n+ - One copy of Gc_cpp.h in the distribution was out of \n+   synch, and failed to document some known compiler\n+   problems with explicit destructor invocation.  Partially\n+   fixed.  There are probably other compilers on which\n+   gc_cleanup is miscompiled.\n+ - Fixed Makefile to pass C compiler flags to C++ compiler.\n+ - Added Mac fixes.\n+ - Fixed os_dep.c to work around what appears to be\n+   a new and different VirtualQuery bug under newer\n+   versions of win32S.\n+ - GC_non_gc_bytes was not correctly maintained by\n+   GC_free.  Fixed.  Thanks to James Clark (jjc@jclark.com).\n+ - Added GC_set_max_heap_size.\n+ - Changed allocation code to ignore blacklisting if it is preventing\n+   use of a very large block of memory.  This has the advantage\n+   that naive code allocating very large objects is much more\n+   likely to work.  The downside is you might no\n+   longer find out that such code should really use\n+   GC_malloc_ignore_off_page.\n+ - Changed GC_printf under win32 to close and reopen the file\n+   between calls.  FAT file systems otherwise make the log file\n+   useless for debugging.\n+ - Added GC_try_to_collect and GC_get_bytes_since_gc.  These\n+   allow starting an abortable collection during idle times. \n+   This facility does not require special OS support.  (Thanks to\n+   Michael Spertus of Geodesic Systems for suggesting this.  It was\n+   actually an easy addition.  Kumar Srikantan previously added a similar\n+   facility to a now ancient version of the collector.  At the time\n+   this was much harder, and the result was less convincing.)\n+ - Added some support for the Borland development environment.  (Thanks\n+   to John Ellis and Michael Spertus.)\n+ - Removed a misfeature from checksums.c that caused unexpected \n+   heap growth.  (Thanks to Scott Schwartz.)\n+ - Changed finalize.c to call WARN if it encounters a finalization cycle.\n+   WARN is defined in gc_priv.h to write a message, usually to stdout.\n+   In many environments, this may be inappropriate.\n+ - Renamed NO_PARAMS in gc.h to GC_NO_PARAMS, thus adhering to my own\n+   naming convention.\n+ - Added GC_set_warn_proc to intercept warnings.\n+ - Fixed Amiga port. (Thanks to Michel Schinz (schinz@alphanet.ch).)\n+ - Fixed a bug in mark.c that could result in an access to unmapped\n+   memory from GC_mark_from_mark_stack on machines with unaligned\n+   pointers.\n+ - Fixed a win32 specific performance bug that could result in scanning of\n+   objects allocated with the system malloc.\n+ - Added REDIRECT_MALLOC.\n+\n+Since version 4.4:\n+ - Fixed many minor and one major README bugs. (Thanks to Franklin Chen\n+   (chen@adi.com) for pointing out many of them.)\n+ - Fixed ALPHA/OSF/1 dynamic library support. (Thanks to Jonathan Bachrach\n+   (jonathan@harlequin.com)).\n+ - Added incremental GC support (MPROTECT_VDB) for Linux (with some\n+   help from Bruno Haible).\n+ - Altered SPARC recognition tests in gc.h and config.h (mostly as\n+   suggested by Fergus Henderson).\n+ - Added basic incremental GC support for win32, as implemented by\n+   Windows NT and Windows 95.  GC_enable_incremental is a noop\n+   under win32s, which doesn't implement enough of the VM interface.\n+ - Added -DLARGE_CONFIG.\n+ - Fixed GC_..._ignore_off_page to also function without\n+   -DALL_INTERIOR_POINTERS.\n+ - (Hopefully) fixed RS/6000 port.  (Only the test was broken.)\n+ - Fixed a performance bug in the nonincremental collector running\n+   on machines supporting incremental collection with MPROTECT_VDB\n+   (e.g. SunOS 4, DEC AXP).  This turned into a correctness bug under\n+   win32s with win32 incremental collection.  (Not all memory protection\n+   was disabled.)\n+ - Fixed some ppcr related bit rot.\n+ - Caused dynamic libraries to be unregistered before reregistering.\n+   The old way turned out to be a performance bug on some machines.\n+ - GC_root_size was not properly maintained under MSWIN32.\n+ - Added -DNO_DEBUGGING and GC_dump.\n+ - Fixed a couple of bugs arising with SOLARIS_THREADS +\n+   REDIRECT_MALLOC.\n+ - Added NetBSD/M68K port.  (Thanks to Peter Seebach\n+   <seebs@taniemarie.solon.com>.)\n+ - Fixed a serious realloc bug.  For certain object sizes, the collector\n+   wouldn't scan the expanded part of the object.  (Thanks to Clay Spence\n+   (cds@peanut.sarnoff.com) for noticing the problem, and helping me to\n+   track it down.)\n+   \n+Since version 4.5:\n+ - Added Linux ELF support.  (Thanks to Arrigo Triulzi <arrigo@ic.ac.uk>.)\n+ - GC_base crashed if it was called before any other GC_ routines.\n+   This could happen if a gc_cleanup object was allocated outside the heap\n+   before any heap allocation.\n+ - The heap expansion heuristic was not stable if all objects had finalization\n+   enabled.  Fixed finalize.c to count memory in finalization queue and\n+   avoid explicit deallocation.  Changed alloc.c to also consider this count.\n+   (This is still not recommended.  It's expensive if nothing else.)  Thanks\n+   to John Ellis for pointing this out.\n+ - GC_malloc_uncollectable(0) was broken.  Thanks to Phong Vo for pointing\n+   this out.\n+ - The collector didn't compile under Linux 1.3.X.  (Thanks to Fred Gilham for\n+   pointing this out.)  The current workaround is ugly, but expected to be\n+   temporary.\n+ - Fixed a formatting problem for SPARC stack traces.\n+ - Fixed some '=='s in os_dep.c that should have been assignments.\n+   Fortunately these were in code that should never be executed anyway.\n+   (Thanks to Fergus Henderson.)\n+ - Fixed the heap block allocator to only drop blacklisted blocks in small\n+   chunks.  Made BL_LIMIT self adjusting.  (Both of these were in response\n+   to heap growth observed by Paul Graham.)\n+ - Fixed the Metrowerks/68K Mac code to also mark from a6.  (Thanks\n+   to Patrick Beard.)\n+ - Significantly updated README.debugging.\n+ - Fixed some problems with longjmps out of signal handlers, especially under\n+   Solaris.  Added a workaround for the fact that siglongjmp doesn't appear to\n+   do the right thing with -lthread under Solaris.\n+ - Added MSDOS/djgpp port.  (Thanks to Mitch Harris  (maharri@uiuc.edu).)\n+ - Added \"make reserved_namespace\" and \"make user_namespace\".  The\n+   first renames ALL \"GC_xxx\" identifiers as \"_GC_xxx\".  The second is the\n+   inverse transformation.  Note that doing this is guaranteed to break all\n+   clients written for the other names.\n+ - descriptor field for kind NORMAL in GC_obj_kinds with ADD_BYTE_AT_END\n+   defined should be -ALIGNMENT not WORDS_TO_BYTES(-1).  This is\n+   a serious bug on machines with pointer alignment of less than a word.\n+ - GC_ignore_self_finalize_mark_proc didn't handle pointers to very near the\n+   end of the object correctly.  Caused failures of the C++ test on a DEC Alpha\n+   with g++.\n+ - gc_inl.h still had problems.  Partially fixed.  Added warnings at the\n+   beginning to hopefully specify the remaining dangers.\n+ - Added DATAEND definition to config.h.\n+ - Fixed some of the .h file organization.  Fixed \"make floppy\".\n+ \n+Since version 4.6:\n+ - Fixed some compilation problems with -DCHECKSUMS (thanks to Ian Searle)\n+ - Updated some Mac specific files to synchronize with Patrick Beard.\n+ - Fixed a serious bug for machines with non-word-aligned pointers.\n+   (Thanks to Patrick Beard for pointing out the problem.  The collector\n+   should fail almost any conceivable test immediately on such machines.)\n+\n+Since version 4.7:\n+ - Changed a \"comment\" in a MacOS specific part of mach-dep.c that caused\n+   gcc to fail on other platforms.\n+\n+Since version 4.8\n+ - More README.debugging fixes.\n+ - Objects ready for finalization, but not finalized in the same GC\n+   cycle, could be prematurely collected.  This occasionally happened\n+   in test_cpp.\n+ - Too little memory was obtained from the system for very large\n+   objects.  That could cause a heap explosion if these objects were\n+   not contiguous (e.g. under PCR), and too much of them was blacklisted.\n+ - Due to an improper initialization, the collector was too hesitant to\n+   allocate blacklisted objects immediately after system startup.\n+ - Moved GC_arrays from the data into the bss segment by not explicitly\n+   initializing it to zero.  This significantly\n+   reduces the size of executables, and probably avoids some disk accesses\n+   on program startup.  It's conceivable that it might break a port that I\n+   didn't test.\n+ - Fixed EMX_MAKEFILE to reflect the gc_c++.h to gc_cpp.h renaming which\n+   occurred a while ago.\n+\n+Since 4.9:\n+ - Fixed a typo around a call to GC_collect_or_expand in alloc.c.  It broke\n+   handling of out of memory.  (Thanks to Patrick Beard for noticing.)\n+\n+Since 4.10:\n+ - Rationalized (hopefully) GC_try_to_collect in an incremental collection\n+   environment.  It appeared to not handle a call while a collection was in\n+   progress, and was otherwise too conservative.\n+ - Merged GC_reclaim_or_delete_all into GC_reclaim_all to get rid of some\n+   code.\n+ - Added Patrick Beard's Mac fixes, with substantial completely untested\n+   modifications.\n+ - Fixed the MPROTECT_VDB code to deal with large pages and imprecise\n+   fault addresses (as on an UltraSPARC running Solaris 2.5).  Note that this\n+   was not a problem in the default configuration, which uses PROC_VDB.\n+ - The DEC Alpha assembly code needed to restore $gp between calls.\n+   Thanks to Fergus Henderson for tracking this down and supplying a\n+   patch.\n+ - The write command for \"de\" was completely broken for large files.\n+   I used the easiest portable fix, which involved changing the semantics\n+   so that f.new is written instead of overwriting f.  That's safer anyway.\n+ - Added README.solaris2 with a discussion of the possible problems of\n+   mixing the collector's sbrk allocation with malloc/realloc.\n+ - Changed the data segment starting address for SGI machines.  The\n+   old code failed under IRIX6.\n+ - Required double word alignment for MIPS.\n+ - Various minor fixes to remove warnings.\n+ - Attempted to fix some Solaris threads problems reported by Zhiying Chen.\n+   In particular, the collector could try to fork a thread with the\n+   world stopped as part of GC_thr_init.  It also failed to deal with\n+   the case in which the original thread terminated before the whole\n+   process did.\n+ - Added -DNO_EXECUTE_PERMISSION.  This has a major performance impact\n+   on the incremental collector under Irix, and perhaps under other\n+   operating systems.\n+ - Added some code to support allocating the heap with mmap.  This may\n+   be preferable under some circumstances.\n+ - Integrated dynamic library support for HP.\n+   (Thanks to Knut Tvedten <knuttv@ifi.uio.no>.)\n+ - Integrated James Clark's win32 threads support, and made a number\n+   of changes to it, many of which were suggested by Pontus Rydin.\n+   This is still not 100% solid.\n+ - Integrated Alistair Crooks' support for UTS4 running on an Amdahl\n+   370-class machine.\n+ - Fixed a serious bug in explicitly typed allocation.  Objects requiring\n+   large descriptors where handled in a way that usually resulted in\n+   a segmentation fault in the marker.  (Thanks to Jeremy Fitzhardinge\n+   for helping to track this down.)\n+ - Added partial support for GNU win32 development.  (Thanks to Fergus\n+   Henderson.)\n+ - Added optional support for Java-style finalization semantics.  (Thanks\n+   to Patrick Bridges.)  This is recommended only for Java implementations.\n+ - GC_malloc_uncollectable faulted instead of returning 0 when out of\n+   memory.  (Thanks to dan@math.uiuc.edu for noticing.)\n+ - Calls to GC_base before the collector was initialized failed on a\n+   DEC Alpha.  (Thanks to Matthew Flatt.)\n+ - Added base pointer checking to GC_REGISTER_FINALIZER in debugging\n+   mode, at the suggestion of Jeremy Fitzhardinge.\n+ - GC_debug_realloc failed for uncollectable objects.  (Thanks to\n+   Jeremy Fitzhardinge.)\n+ - Explicitly typed allocation could crash if it ran out of memory.\n+   (Thanks to Jeremy Fitzhardinge.)\n+ - Added minimal support for a DEC Alpha running Linux.\n+ - Fixed a problem with allocation of objects whose size overflowed\n+   ptrdiff_t.  (This now fails unconditionally, as it should.)\n+ - Added the beginning of Irix pthread support.\n+ - Integrated Xiaokun Zhu's fixes for djgpp 2.01.\n+ - Added SGI-style STL allocator support (gc_alloc.h).\n+ - Fixed a serious bug in README.solaris2.  Multithreaded programs must include\n+   gc.h with SOLARIS_THREADS defined.\n+ - Changed GC_free so it actually deallocates uncollectable objects.\n+   (Thanks to Peter Chubb for pointing out the problem.)\n+ - Added Linux ELF support for dynamic libararies.  (Thanks again to\n+   Patrick Bridges.)\n+ - Changed the Borland cc configuration so that the assembler is not\n+   required.\n+ - Fixed a bug in the C++ test that caused it to fail in 64-bit\n+   environments.\n+\n+Since 4.11:\n+ - Fixed ElfW definition in dyn_load.c. (Thanks to Fergus Henderson.)\n+   This prevented the dynamic library support from compiling on some\n+   older ELF Linux systems.\n+ - Fixed UTS4 port (which I apparently mangled during the integration)\n+   (Thanks to again to Alistair Crooks.)\n+ - \"Make C++\" failed on Suns with SC4.0, due to a problem with \"bool\".\n+   Fixed in gc_priv.h.\n+ - Added more pieces for GNU win32.  (Thanks to Timothy N. Newsham.)\n+   The current state of things should suffice for at least some\n+   applications.\n+ - Changed the out of memory retry count handling as suggested by\n+   Kenjiro Taura.  (This matters only if GC_max_retries > 0, which\n+   is no longer the default.)\n+ - If a /proc read failed repeatedly, GC_written_pages was not updated\n+   correctly.  (Thanks to Peter Chubb for diagnosing this.)\n+ - Under unlikely circumstances, the allocator could infinite loop in\n+   an out of memory situation.  (Thanks again to Kenjiro Taura for\n+   identifying the problem and supplying a fix.)\n+ - Fixed a syntactic error in the DJGPP code.  (Thanks to Fergus\n+   Henderson for finding this by inspection.)  Also fixed a test program\n+   problem with DJGPP (Thanks to Peter Monks.)\n+ - Atomic uncollectable objects were not treated correctly by the\n+   incremental collector.  This resulted in weird log statistics and\n+   occasional performance problems.  (Thanks to Peter Chubb for pointing\n+   this out.)\n+ - Fixed some problems resulting from compilers that dont define\n+   __STDC__.  In this case void * and char * were used inconsistently\n+   in some cases.  (Void * should not have been used at all.  If\n+   you have an ANSI superset compiler that does not define __STDC__,\n+   please compile with -D__STDC__=0. Thanks to Manuel Serrano and others\n+   for pointing out the problem.)\n+ - Fixed a compilation problem on Irix with -n32 and -DIRIX_THREADS.\n+   Also fixed some other IRIX_THREADS problems which may or may not have\n+   had observable symptoms.\n+ - Fixed an HP PA compilation problem in dyn_load.c.  (Thanks to\n+   Philippe Queinnec.)\n+ - SEGV fault handlers sometimes did not get reset correctly.  (Thanks\n+   to David Pickens.)\n+ - Added a fix for SOLARIS_THREADS on Intel.  (Thanks again to David\n+   Pickens.)  This probably needs more work to become functional.\n+ - Fixed struct sigcontext_struct in os_dep.c for compilation under\n+   Linux 2.1.X.\t(Thanks to Fergus Henderson.)\n+ - Changed the DJGPP STACKBOTTOM and DATASTART values to those suggested\n+   by Kristian Kristensen.  These may still not be right, but it is\n+   it is likely to work more often than what was there before.  They may\n+   even be exactly right.\n+ - Added a #include <string.h> to test_cpp.cc.  This appears to help\n+   with HP/UX and gcc.  (Thanks to assar@sics.se.)\n+ - Version 4.11 failed to run in incremental mode on recent 64-bit Irix\n+   kernels.  This was a problem related to page unaligned heap segments.\n+   Changed the code to page align heap sections on all platforms.\n+   (I had mistakenly identified this as a kernel problem earlier.\n+   It was not.)\n+ - Version 4.11 did not make allocated storage executable, except on\n+   one or two platforms, due to a bug in a #if test.  (Thanks to Dave\n+   Grove for pointing this out.)\n+ - Added sparc_sunos4_mach_dep.s to support Sun's compilers under SunOS4.\n+ - Added GC_exclude_static_roots.\n+ - Fixed the object size mapping algorithm.  This shouldn't matter,\n+   but the old code was ugly.\n+ - Heap checking code could die if one of the allocated objects was\n+   larger than its base address.  (Unsigned underflow problem.  Thanks\n+   to Clay Spence for isolating the problem.)\n+ - Added RS6000 (AIX) dynamic library support and fixed STACK_BOTTOM.\n+   (Thanks to Fred Stearns.)\n+ - Added Fergus Henderson's patches for improved robustness with large\n+   heaps and lots of blacklisting.\n+ - Added Peter Chubb's changes to support Solaris Pthreads, to support\n+   MMAP allocation in Solaris, to allow Solaris to find dynamic libraries\n+   through /proc, to add malloc_typed_ignore_off_page, and a few other\n+   minor features and bug fixes.\n+ - The Solaris 2 port should not use sbrk.  I received confirmation from\n+   Sun that the use of sbrk and malloc in the same program is not\n+   supported.  The collector now defines USE_MMAP by default on Solaris.\n+ - Replaced the djgpp makefile with Gary Leavens' version.\n+ - Fixed MSWIN32 detection test.\n+ - Added Fergus Henderson's patches to allow putting the collector into\n+   a DLL under GNU win32.\n+ - Added Ivan V. Demakov's port to Watcom C on X86.\n+ - Added Ian Piumarta's Linux/PowerPC port.\n+ - On Brian Burton's suggestion added PointerFreeGC to the placement\n+   options in gc_cpp.h.  This is of course unsafe, and may be controversial.\n+   On the other hand, it seems to be needed often enough that it's worth\n+   adding as a standard facility.\n+\n+Since 4.12:\n+ - Fixed a crucial bug in the Watcom port.  There was a redundant decl\n+   of GC_push_one in gc_priv.h.\n+ - Added FINALIZE_ON_DEMAND.\n+ - Fixed some pre-ANSI cc problems in test.c.\n+ - Removed getpagesize() use for Solaris.  It seems to be missing in one\n+   or two versions.\n+ - Fixed bool handling for SPARCCompiler version 4.2.\n+ - Fixed some files in include that had gotten unlinked from the main\n+   copy.\n+ - Some RS/6000 fixes (missing casts).  Thanks to Toralf Foerster.\n+ - Fixed several problems in GC_debug_realloc, affecting mostly the\n+   FIND_LEAK case.\n+ - GC_exclude_static_roots contained a buggy unsigned comparison to\n+   terminate a loop.  (Thanks to Wilson Ho.)\n+ - CORD_str failed if the substring occurred at the last possible position.\n+   (Only affects cord users.)\n+ - Fixed Linux code to deal with RedHat 5.0 and integrated Peter Bigot's\n+   os_dep.c code for dealing with various Linux versions.\n+ - Added workaround for Irix pthreads sigaction bug and possible signal\n+   misdirection problems.\n+Since alpha1:\n+ - Changed RS6000 STACKBOTTOM.\n+ - Integrated Patrick Beard's Mac changes.\n+ - Alpha1 didn't compile on Irix m.n, m < 6.\n+ - Replaced Makefile.dj with a new one from Gary Leavens.\n+ - Added Andrew Stitcher's changes to support SCO OpenServer.\n+ - Added PRINT_BLACK_LIST, to allow debugging of high densities of false\n+   pointers.\n+ - Added code to debug allocator to keep track of return address\n+   in GC_malloc caller, thus giving a bit more context.\n+ - Changed default behavior of large block allocator to more\n+   aggressively avoid fragmentation.  This is likely to slow down the\n+   collector when it succeeds at reducing space cost.\n+ - Integrated Fergus Henderson's CYGWIN32 changes.  They are untested,\n+   but needed for newer versions.\n+ - USE_MMAP had some serious bugs.  This caused the collector to fail\n+   consistently on Solaris with -DSMALL_CONFIG.\n+ - Added Linux threads support, thanks largely to Fergus Henderson.\n+\n+To do:\n+ - I have a backlog of unintegrated contributed platform-specific changes.\n+ - Very large root set sizes (> 16 MB or so) could cause the collector\n+   to abort with an unexpected mark stack overflow.  (Thanks again to\n+   Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial\n+   size.\n+ - The SGI version of the collector marks from mmapped pages, even\n+   if they are not part of dynamic library static data areas.  This\n+   causes performance problems with some SGI libraries that use mmap\n+   as a bitmap allocator.  NOT YET FIXED.  It may be possible to turn\n+   off DYNAMIC_LOADING in the collector as a workaround.  It may also\n+   be possible to conditionally intercept mmap and use GC_exclude_static_roots.\n+   The real fix is to walk rld data structures, which looks possible.\n+ - Integrate MIT and DEC pthreads ports.\n+ "}]}