{"sha": "bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZjNDU1NTFkNWFjZTQyZjRiNjEzM2MwNWYwMTBjZjVlYjVjYjlmMw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-01-11T09:51:17Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-01-11T09:51:17Z"}, "message": "re PR target/18916 (mis-aligned vector code with copy memory (-maltivec))\n\n\tPR target/18916\n\t* builtins.c (std_gimplify_va_arg_expr): Adjust alignment of *ap.\n\t* expr.h (struct locate_and_pad_arg_data): Add \"boundary\".\n\t* function.c (locate_and_pad_parm): Set new field.\n\t(assign_parm_find_stack_rtl): Use it instead of FUNCTION_ARG_BOUNDARY.\n\tTweak where_pad test to include \"none\".  Always set mem align for\n\tstack_parm.\n\t(assign_parm_adjust_stack_rtl): Discard stack_parm if alignment\n\tnot sufficient for type.\n\t(assign_parm_setup_block): If stack_parm is zero on entry, always\n\tmake a new stack local.  Block move old stack parm if necessary\n\tto new aligned stack local.\n\t(assign_parm_setup_stack): Use a block move to handle\n\tpotentially misaligned entry_parm.\n\t(assign_parms_unsplit_complex): Specify required alignment when\n\tcreating stack local.\n\t* calls.c (compute_argument_addresses): Override alignment of stack\n\targ calculated from its type with the alignment given by\n\tFUNCTION_ARG_BOUNDARY.\n\t(store_one_arg): Likewise.\n\nFrom-SVN: r93179", "tree": {"sha": "8327d7ab80bc3b691512853606494ea8aaaa0ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8327d7ab80bc3b691512853606494ea8aaaa0ae4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/comments", "author": null, "committer": null, "parents": [{"sha": "d3f6e07b9a129f1f090e4290c54448cacc0e0eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f6e07b9a129f1f090e4290c54448cacc0e0eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f6e07b9a129f1f090e4290c54448cacc0e0eb1"}], "stats": {"total": 161, "additions": 121, "deletions": 40}, "files": [{"sha": "2106edad785a91e6df87180fe873dde5a1533956", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "patch": "@@ -1,4 +1,28 @@\n+2005-01-11  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/18916\n+\t* builtins.c (std_gimplify_va_arg_expr): Adjust alignment of *ap.\n+\t* expr.h (struct locate_and_pad_arg_data): Add \"boundary\".\n+\t* function.c (locate_and_pad_parm): Set new field.\n+\t(assign_parm_find_stack_rtl): Use it instead of FUNCTION_ARG_BOUNDARY.\n+\tTweak where_pad test to include \"none\".  Always set mem align for\n+\tstack_parm.\n+\t(assign_parm_adjust_stack_rtl): Discard stack_parm if alignment\n+\tnot sufficient for type.\n+\t(assign_parm_setup_block): If stack_parm is zero on entry, always\n+\tmake a new stack local.  Block move old stack parm if necessary\n+\tto new aligned stack local.\n+\t(assign_parm_setup_stack): Use a block move to handle\n+\tpotentially misaligned entry_parm.\n+\t(assign_parms_unsplit_complex): Specify required alignment when\n+\tcreating stack local.\n+\t* calls.c (compute_argument_addresses): Override alignment of stack\n+\targ calculated from its type with the alignment given by\n+\tFUNCTION_ARG_BOUNDARY.\n+\t(store_one_arg): Likewise.\n+\n 2005-01-11  Jan Beulich  <jbeulich@novell.com>\n+\n \t* config/ia64/ia64.md (zero_extendsidi2): Replace zxt4 by addp4.\n \tChange respective itanium_class attribute to ialu.\n \t(shladdp4_internal): New."}, {"sha": "e231d8361cc4561c6752ace9fb2c20c9eaf400fc", "filename": "gcc/builtins.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "patch": "@@ -1,6 +1,6 @@\n /* Expand builtin functions.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -3894,6 +3894,18 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist_tmp, t));\n       gimplify_and_add (t, pre_p);\n     }\n+  else\n+    boundary = align;\n+\n+  /* If the actual alignment is less than the alignment of the type,\n+     adjust the type accordingly so that we don't assume strict alignment\n+     when deferencing the pointer.  */\n+  boundary *= BITS_PER_UNIT;\n+  if (boundary < TYPE_ALIGN (type))\n+    {\n+      type = build_variant_type_copy (type);\n+      TYPE_ALIGN (type) = boundary;\n+    }\n \n   /* Compute the rounded size of the type.  */\n   type_size = size_in_bytes (type);"}, {"sha": "72cba4914036016165950adb81f3384fabac5375", "filename": "gcc/calls.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "patch": "@@ -1,6 +1,7 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1357,6 +1358,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t  rtx offset = ARGS_SIZE_RTX (args[i].locate.offset);\n \t  rtx slot_offset = ARGS_SIZE_RTX (args[i].locate.slot_offset);\n \t  rtx addr;\n+\t  unsigned int align, boundary;\n \n \t  /* Skip this parm if it will not be passed on the stack.  */\n \t  if (! args[i].pass_on_stack && args[i].reg != 0)\n@@ -1369,9 +1371,18 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \n \t  addr = plus_constant (addr, arg_offset);\n \t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n-\t  set_mem_align (args[i].stack, PARM_BOUNDARY);\n \t  set_mem_attributes (args[i].stack,\n \t\t\t      TREE_TYPE (args[i].tree_value), 1);\n+\t  align = BITS_PER_UNIT;\n+\t  boundary = args[i].locate.boundary;\n+\t  if (args[i].locate.where_pad != downward)\n+\t    align = boundary;\n+\t  else if (GET_CODE (offset) == CONST_INT)\n+\t    {\n+\t      align = INTVAL (offset) * BITS_PER_UNIT | boundary;\n+\t      align = align & -align;\n+\t    }\n+\t  set_mem_align (args[i].stack, align);\n \n \t  if (GET_CODE (slot_offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n@@ -1380,9 +1391,9 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \n \t  addr = plus_constant (addr, arg_offset);\n \t  args[i].stack_slot = gen_rtx_MEM (args[i].mode, addr);\n-\t  set_mem_align (args[i].stack_slot, PARM_BOUNDARY);\n \t  set_mem_attributes (args[i].stack_slot,\n \t\t\t      TREE_TYPE (args[i].tree_value), 1);\n+\t  set_mem_align (args[i].stack_slot, args[i].locate.boundary);\n \n \t  /* Function incoming arguments may overlap with sibling call\n \t     outgoing arguments and we cannot allow reordering of reads\n@@ -4119,9 +4130,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t\t\t  NULL_RTX, TYPE_MODE (sizetype), 0);\n \t}\n \n-      /* Some types will require stricter alignment, which will be\n-\t provided for elsewhere in argument layout.  */\n-      parm_align = MAX (PARM_BOUNDARY, TYPE_ALIGN (TREE_TYPE (pval)));\n+      parm_align = arg->locate.boundary;\n \n       /* When an argument is padded down, the block is aligned to\n \t PARM_BOUNDARY, but the actual argument isn't.  */"}, {"sha": "a7eb1e397dc709a6db322cded16511e29e059a31", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "patch": "@@ -1,6 +1,7 @@\n /* Definitions for code generation pass of GNU compiler.\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -116,6 +117,8 @@ struct locate_and_pad_arg_data\n   struct args_size alignment_pad;\n   /* Which way we should pad this arg.  */\n   enum direction where_pad;\n+  /* slot_offset is at least this aligned.  */\n+  unsigned int boundary;\n };\n \n /* Add the value of the tree INC to the `struct args_size' TO.  */"}, {"sha": "250d71bcb121637af5ba19fbd21bc79ac7797f87", "filename": "gcc/function.c", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bfc45551d5ace42f4b6133c05f010cf5eb5cb9f3", "patch": "@@ -1,6 +1,7 @@\n /* Expands front end tree to back end RTL for GCC.\n    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2405,22 +2406,21 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n \n   set_mem_attributes (stack_parm, parm, 1);\n \n-  boundary = FUNCTION_ARG_BOUNDARY (data->promoted_mode, data->passed_type);\n-  align = 0;\n+  boundary = data->locate.boundary;\n+  align = BITS_PER_UNIT;\n \n   /* If we're padding upward, we know that the alignment of the slot\n      is FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're\n      intentionally forcing upward padding.  Otherwise we have to come\n      up with a guess at the alignment based on OFFSET_RTX.  */\n-  if (data->locate.where_pad == upward || data->entry_parm)\n+  if (data->locate.where_pad != downward || data->entry_parm)\n     align = boundary;\n   else if (GET_CODE (offset_rtx) == CONST_INT)\n     {\n       align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n       align = align & -align;\n     }\n-  if (align > 0)\n-    set_mem_align (stack_parm, align);\n+  set_mem_align (stack_parm, align);\n \n   if (data->entry_parm)\n     set_reg_attrs_for_parm (data->entry_parm, stack_parm);\n@@ -2492,7 +2492,6 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n /* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's\n    always valid and properly aligned.  */\n \n-\n static void\n assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n {\n@@ -2501,8 +2500,12 @@ assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n   /* If we can't trust the parm stack slot to be aligned enough for its\n      ultimate type, don't use that slot after entry.  We'll make another\n      stack slot, if we need one.  */\n-  if (STRICT_ALIGNMENT && stack_parm\n-      && GET_MODE_ALIGNMENT (data->nominal_mode) > MEM_ALIGN (stack_parm))\n+  if (stack_parm\n+      && ((STRICT_ALIGNMENT\n+\t   && GET_MODE_ALIGNMENT (data->nominal_mode) > MEM_ALIGN (stack_parm))\n+\t  || (data->nominal_type\n+\t      && TYPE_ALIGN (data->nominal_type) > MEM_ALIGN (stack_parm)\n+\t      && MEM_ALIGN (stack_parm) < PREFERRED_STACK_BOUNDARY)))\n     stack_parm = NULL;\n \n   /* If parm was passed in memory, and we need to convert it on entry,\n@@ -2548,6 +2551,8 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n {\n   rtx entry_parm = data->entry_parm;\n   rtx stack_parm = data->stack_parm;\n+  HOST_WIDE_INT size;\n+  HOST_WIDE_INT size_stored;\n \n   if (GET_CODE (entry_parm) == PARALLEL)\n     entry_parm = emit_group_move_into_temps (entry_parm);\n@@ -2593,30 +2598,34 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       return;\n     }\n \n+  size = int_size_in_bytes (data->passed_type);\n+  size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n+  if (stack_parm == 0)\n+    {\n+      stack_parm = assign_stack_local (BLKmode, size_stored,\n+\t\t\t\t       TYPE_ALIGN (data->passed_type));\n+      if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n+\tPUT_MODE (stack_parm, GET_MODE (entry_parm));\n+      set_mem_attributes (stack_parm, parm, 1);\n+    }\n+\n   /* If a BLKmode arrives in registers, copy it to a stack slot.  Handle\n      calls that pass values in multiple non-contiguous locations.  */\n   if (REG_P (entry_parm) || GET_CODE (entry_parm) == PARALLEL)\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (data->passed_type);\n-      HOST_WIDE_INT size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n       rtx mem;\n \n       /* Note that we will be storing an integral number of words.\n \t So we have to be careful to ensure that we allocate an\n-\t integral number of words.  We do this below in the\n+\t integral number of words.  We do this above when we call\n \t assign_stack_local if space was not allocated in the argument\n \t list.  If it was, this will not work if PARM_BOUNDARY is not\n \t a multiple of BITS_PER_WORD.  It isn't clear how to fix this\n \t if it becomes a problem.  Exception is when BLKmode arrives\n \t with arguments not conforming to word_mode.  */\n \n-      if (stack_parm == 0)\n-\t{\n-\t  stack_parm = assign_stack_local (BLKmode, size_stored, 0);\n-\t  data->stack_parm = stack_parm;\n-\t  PUT_MODE (stack_parm, GET_MODE (entry_parm));\n-\t  set_mem_attributes (stack_parm, parm, 1);\n-\t}\n+      if (data->stack_parm == 0)\n+\t;\n       else if (GET_CODE (entry_parm) == PARALLEL)\n \t;\n       else\n@@ -2686,7 +2695,16 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \tmove_block_from_reg (REGNO (entry_parm), mem,\n \t\t\t     size_stored / UNITS_PER_WORD);\n     }\n+  else if (data->stack_parm == 0)\n+    {\n+      push_to_sequence (all->conversion_insns);\n+      emit_block_move (stack_parm, data->entry_parm, GEN_INT (size),\n+\t\t       BLOCK_OP_NORMAL);\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n+    }\n \n+  data->stack_parm = stack_parm;\n   SET_DECL_RTL (parm, stack_parm);\n }\n \n@@ -2887,6 +2905,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n {\n   /* Value must be stored in the stack slot STACK_PARM during function\n      execution.  */\n+  bool to_conversion = false;\n \n   if (data->promoted_mode != data->nominal_mode)\n     {\n@@ -2896,40 +2915,52 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n       emit_move_insn (tempreg, validize_mem (data->entry_parm));\n \n       push_to_sequence (all->conversion_insns);\n+      to_conversion = true;\n+\n       data->entry_parm = convert_to_mode (data->nominal_mode, tempreg,\n \t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (parm)));\n \n       if (data->stack_parm)\n \t/* ??? This may need a big-endian conversion on sparc64.  */\n \tdata->stack_parm\n \t  = adjust_address (data->stack_parm, data->nominal_mode, 0);\n-\n-      all->conversion_insns = get_insns ();\n-      end_sequence ();\n     }\n \n   if (data->entry_parm != data->stack_parm)\n     {\n+      rtx src, dest;\n+\n       if (data->stack_parm == 0)\n \t{\n \t  data->stack_parm\n \t    = assign_stack_local (GET_MODE (data->entry_parm),\n \t\t\t\t  GET_MODE_SIZE (GET_MODE (data->entry_parm)),\n-\t\t\t\t  0);\n+\t\t\t\t  TYPE_ALIGN (data->passed_type));\n \t  set_mem_attributes (data->stack_parm, parm, 1);\n \t}\n \n-      if (data->promoted_mode != data->nominal_mode)\n+      dest = validize_mem (data->stack_parm);\n+      src = validize_mem (data->entry_parm);\n+\n+      if (MEM_P (src))\n \t{\n-\t  push_to_sequence (all->conversion_insns);\n-\t  emit_move_insn (validize_mem (data->stack_parm),\n-\t\t\t  validize_mem (data->entry_parm));\n-\t  all->conversion_insns = get_insns ();\n-\t  end_sequence ();\n+\t  /* Use a block move to handle potentially misaligned entry_parm.  */\n+\t  if (!to_conversion)\n+\t    push_to_sequence (all->conversion_insns);\n+\t  to_conversion = true;\n+\n+\t  emit_block_move (dest, src,\n+\t\t\t   GEN_INT (int_size_in_bytes (data->passed_type)),\n+\t\t\t   BLOCK_OP_NORMAL);\n \t}\n       else\n-\temit_move_insn (validize_mem (data->stack_parm),\n-\t\t\tvalidize_mem (data->entry_parm));\n+\temit_move_insn (dest, src);\n+    }\n+\n+  if (to_conversion)\n+    {\n+      all->conversion_insns = get_insns ();\n+      end_sequence ();\n     }\n \n   SET_DECL_RTL (parm, data->stack_parm);\n@@ -2967,7 +2998,8 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all, tree fnargs)\n \n \t      /* split_complex_arg put the real and imag parts in\n \t\t pseudos.  Move them to memory.  */\n-\t      tmp = assign_stack_local (DECL_MODE (parm), size, 0);\n+\t      tmp = assign_stack_local (DECL_MODE (parm), size,\n+\t\t\t\t\tTYPE_ALIGN (TREE_TYPE (parm)));\n \t      set_mem_attributes (tmp, parm, 1);\n \t      rmem = adjust_address_nv (tmp, inner, 0);\n \t      imem = adjust_address_nv (tmp, inner, GET_MODE_SIZE (inner));\n@@ -3411,6 +3443,7 @@ locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n   where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n   boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n   locate->where_pad = where_pad;\n+  locate->boundary = boundary;\n \n #ifdef ARGS_GROW_DOWNWARD\n   locate->slot_offset.constant = -initial_offset_ptr->constant;"}]}