{"sha": "2f937369fa50dfd2f5af11b18d30c5489451072c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5MzczNjlmYTUwZGZkMmY1YWYxMWIxOGQzMGM1NDg5NDUxMDcyYw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-06-11T12:22:48Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-06-11T12:22:48Z"}, "message": "Delete SEQUENCE rtl usage outside of reorg and ssa passes.\n\n2002-06-05  David S. Miller  <davem@redhat.com>\n\n\tDelete SEQUENCE rtl usage outside of reorg and ssa passes.\n\t* rtl.h (gen_sequence, emit_insns, emit_insns_before,\n\temit_insns_before_scope, emit_insns_after,\n\temit_insns_after_scope): Delete declaration.\n\t* ada/misc.c (insert_code_for): Use emit_insn* instead of\n\temit_insns_foo.\n\t* config/alpha/alpha.c (alpha_set_memflags_1): Abort on SEQUENCE.\n\t(alpha_set_memflags): Fix comment.\n\t(set_frame_related_p): Use get_insns instead of gen_sequence.\n\t* config/alpha/alpha.md (setjmp receiver splitter): Avoid\n\temitting no insns.\n\t* config/arm/arm.c (arm_finalize_pic): Use get_insns instead of\n\tgen_sequence.\n\t(arm_gen_load_multiple, arm_gen_store_multiple): Likewise.\n\t* config/fr30/fr30.c (fr30_move_double): Likewise.\n\t* config/i386/i386.c (ix86_expand_int_movcc, ix86_expand_movstr):\n\tLikewise.\n\t* config/ia64/ia64.c (spill_restore_mem): Likewise.\n\t* config/ia64/ia64.md (conditional move spliiter): Avoid emitting\n\tno insns.\n\t* config/m32r/m32r.c (gen_split_move_double): Use get_insns\n\tinstead of gen_sequence.\n\t* config/mips/mips.c (embedded_pic_fnaddr_reg): Likewise.\n\t(mips_expand_prologue, mips16_gp_pseudo_reg): Likewise.\n\t* config/sh/sh.c (sh_need_epilogue): Likewise.\n\t* config/sparc/sparc.md (current_function_calls_alloca, flat): New\n\tattributes.\n\t(setjmp pattern and split): Use them to avoid splitter which emits\n\tno RTL.\n\t* genattrtab.c (main): Emit include of function.h\n\t* config/stormy16/stormy16.c (xstormy16_split_cbranch): Use\n\tget_insns instead of gen_sequence.\n\t* config/cris/cris.c (cris_split_movdx): Likewise.\n\t* emit-rtl.c (emit_insns*): Kill.\n\t(try_split): Expect insn list instead of SEQUENCE.\n\t(make_jump_insn_raw, make_call_insn_raw): Fix comments.\n\t(emit_*insn*): Reimplement to work with INSN lists and PATTERNs.\n\tMake them abort if a SEQUENCE is given and RTL checking is\n\tenabled.\n\t(emit_*_scope): Don't forget to set scope on final insn.\n\t(gen_sequence): Move from here...\n\t* ssa.c (gen_sequence): To here as private function.\n\t* builtins.c (expand_builtin_apply_args): Use emit_insn_foo, fix\n\tcomments.\n\t(expand_builtin_return, expand_builtin_mathfn): Likewise.\n\t(expand_builtin_strlen): Use get_insns instead of gen_sequence.\n\t(expand_builtin_saveregs): Use emit_insn_foo, fix comments.\n\t(expand_builtin_expect_jump): Use get_insns and fix comments.\n\t* calls.c (try_to_integrate): Use emit_insn_foo.\n\t(expand_call, emit_library_call_value_1): Likewise.\n\t* expr.c (emit_queue): Handle insn lists instead of SEQUENCE.\n\t(emit_move_insn_1): Use get_insns instead of gen_sequence.\n\t(expand_expr): Use emit_insn_foo.\n\t* cfgrtl.c (commit_one_edge_insertion): Use emit_insn_foo.\n\t* except.c (build_post_landing_pads): Likewise.\n\t* flow.c (attempt_auto_inc): Likewise.\n\t* stmt.c (expand_fixup, fixup_gotos, expand_nl_handler_label,\n\texpand_nl_goto_receivers, expand_decl_cleanup): Likewise.\n\t* function.c (fixup_var_refs_insn): Use get_insns instead of\n\tgen_sequence.\n\t(fixup_var_refs_1): Likewise and expect insn list from gen_foo.\n\t(fixup_memory_subreg): Use get_insns instead of gen_sequence.\n\t(fixup_stack_1, purge_addressof_1, expand_main_function,\n\tget_arg_pointer_save_area): Likewise.\n\t(optimize_bit_field, instantiate_virtual_regs_1, assign_parms,\n\texpand_function_end): Use emit_insn_foo.\n\t(record_insns, keep_stack_depressed): Work with insn list instead\n\tof SEQUENCE, fix comments.\n\t* ifcvt.c (noce_emit_store_flag, noce_try_store_flag,\n\tnoce_try_store_flag_constants, noce_try_store_flag_inc,\n\tnoce_try_store_flag_mask, noce_emit_cmove, noce_try_cmove_arith,\n\tnoce_try_minmax, noce_try_abs): Use emit_insn_foo.\n\t(noce_process_if_block): Use get_insns instead of gen_sequence.\n\t* optabs.c (add_equal_note): Work with insn list, fix comments.\n\t(expand_binop): Expect insn list from GEN_FCN(), use emit_insn_foo.\n\t(expand_unop, expand_complex_abs, expand_unop_insn,\n\texpand_no_conflict_block): Likewise.\n\t(gen_move_insn): Use get_insns instead of gen_sequence.\n\t(gen_cond_trap): Likewise.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\t(emit_initial_value_sets): Use emit_insn_foo.\n\t* reload1.c (emit_output_reload_insns, emit_reload_insns): Likewise.\n\t(fixup_abnormal_edges): Avoid losing REG_NOTES more intelligently\n\tnow that RTL generators give insn lists.\n\t* sibcall.c (replace_call_placeholder): Use emit_insn_foo.\n\t* doloop.c (doloop_modify, doloop_modify_runtime): Use get_insns\n\tinstead of gen_sequence.\n\t(doloop_optimize): Work with insn lists instead of SEQUENCE rtl.\n\t* explow.c (emit_stack_save, emit_stack_restore): Use get_insns\n\tinstead of gen_sequence.\n\t* loop.c (move_movables, emit_prefetch_instructions,\n\tgen_add_mult, check_dbra_loop, gen_load_of_final_value):\n\tLikewise.\n\t(loop_regs_update): Work with insn list instead of SEQUENCE rtl.\n\t(product_cheap_p): Likewise, and add commentary about RTL wastage\n\there.\n\t* lcm.c (optimize_mode_switching): Use get_insns instead of\n\tgen_sequence.\n\t* profile.c (gen_edge_profiler): Likewise.\n\t* regmove.c (copy_src_to_dest): Likewise.\n\t* reg-stack.c (compensate_edge): Likewise and fix comment.\n\t* gcse.c (process_insert_insn): Likewise.\n\t(insert_insn_end_bb): Work with insn list instead of SEQUENCE rtl.\n\t* jump.c (delete_prior_computation): Update comment.\n\t* genemit.c (gen_expand, gen_split, main): Use get_insns instead\n\tof gen_sequence, update comments to match.\n\t* recog.c (peephole2_optimize): Work with insn lists instead of\n\tSEQUENCE rtl.\n\t* sched-vis.c (print_pattern): Abort on SEQUENCE.\n\t* unroll.c (unroll_loop, find_splittable_givs, final_giv_value):\n\tUse get_insns instead of gen_sequence.\n\t(copy_loop_body): Likewise and don't emit dummy NOTE.\n\t* genrecog.c: Don't mention SEQUENCE rtl in comments.\n\t* combine.c (try_combine): Expect insn lists from split generator.\n\t* reorg.c (relax_delay_slots): Emit SEQUENCE into insn list by\n\thand.\n\nFrom-SVN: r54497", "tree": {"sha": "5f5a5da6b9ff25b136d9c1acd1a495af48658efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5a5da6b9ff25b136d9c1acd1a495af48658efb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f937369fa50dfd2f5af11b18d30c5489451072c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f937369fa50dfd2f5af11b18d30c5489451072c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f937369fa50dfd2f5af11b18d30c5489451072c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f937369fa50dfd2f5af11b18d30c5489451072c/comments", "author": null, "committer": null, "parents": [{"sha": "43cf10b56ceb4bb309c6aac698845eebf734d351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43cf10b56ceb4bb309c6aac698845eebf734d351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43cf10b56ceb4bb309c6aac698845eebf734d351"}], "stats": {"total": 1837, "additions": 1096, "deletions": 741}, "files": [{"sha": "c00e99e5b4ab08d7f4d3ac6bee8d0c2cf055f045", "filename": "gcc/ChangeLog", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1,3 +1,122 @@\n+2002-06-05  David S. Miller  <davem@redhat.com>\n+\n+\tDelete SEQUENCE rtl usage outside of reorg and ssa passes.\n+\t* rtl.h (gen_sequence, emit_insns, emit_insns_before,\n+\temit_insns_before_scope, emit_insns_after,\n+\temit_insns_after_scope): Delete declaration.\n+\t* ada/misc.c (insert_code_for): Use emit_insn* instead of\n+\temit_insns_foo.\n+\t* config/alpha/alpha.c (alpha_set_memflags_1): Abort on SEQUENCE.\n+\t(alpha_set_memflags): Fix comment.\n+\t(set_frame_related_p): Use get_insns instead of gen_sequence.\n+\t* config/alpha/alpha.md (setjmp receiver splitter): Avoid\n+\temitting no insns.\n+\t* config/arm/arm.c (arm_finalize_pic): Use get_insns instead of\n+\tgen_sequence.\n+\t(arm_gen_load_multiple, arm_gen_store_multiple): Likewise.\n+\t* config/fr30/fr30.c (fr30_move_double): Likewise.\n+\t* config/i386/i386.c (ix86_expand_int_movcc, ix86_expand_movstr):\n+\tLikewise.\n+\t* config/ia64/ia64.c (spill_restore_mem): Likewise.\n+\t* config/ia64/ia64.md (conditional move spliiter): Avoid emitting\n+\tno insns.\n+\t* config/m32r/m32r.c (gen_split_move_double): Use get_insns\n+\tinstead of gen_sequence.\n+\t* config/mips/mips.c (embedded_pic_fnaddr_reg): Likewise.\n+\t(mips_expand_prologue, mips16_gp_pseudo_reg): Likewise.\n+\t* config/sh/sh.c (sh_need_epilogue): Likewise.\n+\t* config/sparc/sparc.md (current_function_calls_alloca, flat): New\n+\tattributes.\n+\t(setjmp pattern and split): Use them to avoid splitter which emits\n+\tno RTL.\n+\t* genattrtab.c (main): Emit include of function.h\n+\t* config/stormy16/stormy16.c (xstormy16_split_cbranch): Use\n+\tget_insns instead of gen_sequence.\n+\t* config/cris/cris.c (cris_split_movdx): Likewise.\n+\t* emit-rtl.c (emit_insns*): Kill.\n+\t(try_split): Expect insn list instead of SEQUENCE.\n+\t(make_jump_insn_raw, make_call_insn_raw): Fix comments.\n+\t(emit_*insn*): Reimplement to work with INSN lists and PATTERNs.\n+\tMake them abort if a SEQUENCE is given and RTL checking is\n+\tenabled.\n+\t(emit_*_scope): Don't forget to set scope on final insn.\n+\t(gen_sequence): Move from here...\n+\t* ssa.c (gen_sequence): To here as private function.\n+\t* builtins.c (expand_builtin_apply_args): Use emit_insn_foo, fix\n+\tcomments.\n+\t(expand_builtin_return, expand_builtin_mathfn): Likewise.\n+\t(expand_builtin_strlen): Use get_insns instead of gen_sequence.\n+\t(expand_builtin_saveregs): Use emit_insn_foo, fix comments.\n+\t(expand_builtin_expect_jump): Use get_insns and fix comments.\n+\t* calls.c (try_to_integrate): Use emit_insn_foo.\n+\t(expand_call, emit_library_call_value_1): Likewise.\n+\t* expr.c (emit_queue): Handle insn lists instead of SEQUENCE.\n+\t(emit_move_insn_1): Use get_insns instead of gen_sequence.\n+\t(expand_expr): Use emit_insn_foo.\n+\t* cfgrtl.c (commit_one_edge_insertion): Use emit_insn_foo.\n+\t* except.c (build_post_landing_pads): Likewise.\n+\t* flow.c (attempt_auto_inc): Likewise.\n+\t* stmt.c (expand_fixup, fixup_gotos, expand_nl_handler_label,\n+\texpand_nl_goto_receivers, expand_decl_cleanup): Likewise.\n+\t* function.c (fixup_var_refs_insn): Use get_insns instead of\n+\tgen_sequence.\n+\t(fixup_var_refs_1): Likewise and expect insn list from gen_foo.\n+\t(fixup_memory_subreg): Use get_insns instead of gen_sequence.\n+\t(fixup_stack_1, purge_addressof_1, expand_main_function,\n+\tget_arg_pointer_save_area): Likewise.\n+\t(optimize_bit_field, instantiate_virtual_regs_1, assign_parms,\n+\texpand_function_end): Use emit_insn_foo.\n+\t(record_insns, keep_stack_depressed): Work with insn list instead\n+\tof SEQUENCE, fix comments.\n+\t* ifcvt.c (noce_emit_store_flag, noce_try_store_flag,\n+\tnoce_try_store_flag_constants, noce_try_store_flag_inc,\n+\tnoce_try_store_flag_mask, noce_emit_cmove, noce_try_cmove_arith,\n+\tnoce_try_minmax, noce_try_abs): Use emit_insn_foo.\n+\t(noce_process_if_block): Use get_insns instead of gen_sequence.\n+\t* optabs.c (add_equal_note): Work with insn list, fix comments.\n+\t(expand_binop): Expect insn list from GEN_FCN(), use emit_insn_foo.\n+\t(expand_unop, expand_complex_abs, expand_unop_insn,\n+\texpand_no_conflict_block): Likewise.\n+\t(gen_move_insn): Use get_insns instead of gen_sequence.\n+\t(gen_cond_trap): Likewise.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\t(emit_initial_value_sets): Use emit_insn_foo.\n+\t* reload1.c (emit_output_reload_insns, emit_reload_insns): Likewise.\n+\t(fixup_abnormal_edges): Avoid losing REG_NOTES more intelligently\n+\tnow that RTL generators give insn lists.\n+\t* sibcall.c (replace_call_placeholder): Use emit_insn_foo.\n+\t* doloop.c (doloop_modify, doloop_modify_runtime): Use get_insns\n+\tinstead of gen_sequence.\n+\t(doloop_optimize): Work with insn lists instead of SEQUENCE rtl.\n+\t* explow.c (emit_stack_save, emit_stack_restore): Use get_insns\n+\tinstead of gen_sequence.\n+\t* loop.c (move_movables, emit_prefetch_instructions,\n+\tgen_add_mult, check_dbra_loop, gen_load_of_final_value):\n+\tLikewise.\n+\t(loop_regs_update): Work with insn list instead of SEQUENCE rtl.\n+\t(product_cheap_p): Likewise, and add commentary about RTL wastage\n+\there.\n+\t* lcm.c (optimize_mode_switching): Use get_insns instead of\n+\tgen_sequence.\n+\t* profile.c (gen_edge_profiler): Likewise.\n+\t* regmove.c (copy_src_to_dest): Likewise.\n+\t* reg-stack.c (compensate_edge): Likewise and fix comment.\n+\t* gcse.c (process_insert_insn): Likewise.\n+\t(insert_insn_end_bb): Work with insn list instead of SEQUENCE rtl.\n+\t* jump.c (delete_prior_computation): Update comment.\n+\t* genemit.c (gen_expand, gen_split, main): Use get_insns instead\n+\tof gen_sequence, update comments to match.\n+\t* recog.c (peephole2_optimize): Work with insn lists instead of\n+\tSEQUENCE rtl.\n+\t* sched-vis.c (print_pattern): Abort on SEQUENCE.\n+\t* unroll.c (unroll_loop, find_splittable_givs, final_giv_value):\n+\tUse get_insns instead of gen_sequence.\n+\t(copy_loop_body): Likewise and don't emit dummy NOTE.\n+\t* genrecog.c: Don't mention SEQUENCE rtl in comments.\n+\t* combine.c (try_combine): Expect insn lists from split generator.\n+\t* reorg.c (relax_delay_slots): Emit SEQUENCE into insn list by\n+\thand.\n+\t\n 2002-06-11  Roger Sayle  <roger@eyesopen.com>\n \t    Andreas Jaeger <aj@suse.de>\n "}, {"sha": "347636fa083a873c9c310116a0290bec293e6587", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -740,7 +740,7 @@ insert_code_for (gnat_node)\n       do_pending_stack_adjust ();\n       insns = get_insns ();\n       end_sequence ();\n-      emit_insns_after (insns, RTL_EXPR_RTL (get_gnu_tree (gnat_node)));\n+      emit_insn_after (insns, RTL_EXPR_RTL (get_gnu_tree (gnat_node)));\n     }\n }\n "}, {"sha": "bcf1118039084ddaafb88d76d9770875bc320e2c", "filename": "gcc/builtins.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1159,12 +1159,12 @@ expand_builtin_apply_args ()\n \n     apply_args_value = temp;\n \n-    /* Put the sequence after the NOTE that starts the function.\n-       If this is inside a SEQUENCE, make the outer-level insn\n+    /* Put the insns after the NOTE that starts the function.\n+       If this is inside a start_sequence, make the outer-level insn\n        chain current, so the code is placed at the start of the\n        function.  */\n     push_topmost_sequence ();\n-    emit_insns_before (seq, NEXT_INSN (get_insns ()));\n+    emit_insn_before (seq, NEXT_INSN (get_insns ()));\n     pop_topmost_sequence ();\n     return temp;\n   }\n@@ -1393,7 +1393,7 @@ expand_builtin_return (result)\n       }\n \n   /* Put the USE insns before the return.  */\n-  emit_insns (call_fusage);\n+  emit_insn (call_fusage);\n \n   /* Return whatever values was restored by jumping directly to the end\n      of the function.  */\n@@ -1581,7 +1581,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n   /* Output the entire sequence.  */\n   insns = get_insns ();\n   end_sequence ();\n-  emit_insns (insns);\n+  emit_insn (insns);\n \n   return target;\n }\n@@ -1663,7 +1663,7 @@ expand_builtin_strlen (exp, target)\n \t\t\t    expand_expr (src, src_reg, ptr_mode, EXPAND_SUM));\n       if (pat != src_reg)\n \temit_move_insn (src_reg, pat);\n-      pat = gen_sequence ();\n+      pat = get_insns ();\n       end_sequence ();\n \n       if (before_strlen)\n@@ -2828,11 +2828,11 @@ expand_builtin_saveregs ()\n \n   saveregs_value = val;\n \n-  /* Put the sequence after the NOTE that starts the function.  If this\n-     is inside a SEQUENCE, make the outer-level insn chain current, so\n+  /* Put the insns after the NOTE that starts the function.  If this\n+     is inside a start_sequence, make the outer-level insn chain current, so\n      the code is placed at the start of the function.  */\n   push_topmost_sequence ();\n-  emit_insns_after (seq, get_insns ());\n+  emit_insn_after (seq, get_insns ());\n   pop_topmost_sequence ();\n \n   return val;\n@@ -3513,7 +3513,7 @@ expand_builtin_expect (arglist, target)\n \n /* Like expand_builtin_expect, except do this in a jump context.  This is\n    called from do_jump if the conditional is a __builtin_expect.  Return either\n-   a SEQUENCE of insns to emit the jump or NULL if we cannot optimize\n+   a list of insns to emit the jump or NULL if we cannot optimize\n    __builtin_expect.  We need to optimize this at jump time so that machines\n    like the PowerPC don't turn the test into a SCC operation, and then jump\n    based on the test being 0/1.  */\n@@ -3534,8 +3534,8 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n   if (TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n       && (integer_zerop (arg1) || integer_onep (arg1)))\n     {\n-      int j;\n       int num_jumps = 0;\n+      rtx insn;\n \n       /* If we fail to locate an appropriate conditional jump, we'll\n \t fall back to normal evaluation.  Ensure that the expression\n@@ -3556,16 +3556,17 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n       /* Expand the jump insns.  */\n       start_sequence ();\n       do_jump (arg0, if_false_label, if_true_label);\n-      ret = gen_sequence ();\n+      ret = get_insns ();\n       end_sequence ();\n \n       /* Now that the __builtin_expect has been validated, go through and add\n \t the expect's to each of the conditional jumps.  If we run into an\n \t error, just give up and generate the 'safe' code of doing a SCC\n \t operation and then doing a branch on that.  */\n-      for (j = 0; j < XVECLEN (ret, 0); j++)\n+      insn = ret;\n+      while (insn != NULL_RTX)\n \t{\n-\t  rtx insn = XVECEXP (ret, 0, j);\n+\t  rtx next = NEXT_INSN (insn);\n \t  rtx pattern;\n \n \t  if (GET_CODE (insn) == JUMP_INSN && any_condjump_p (insn)\n@@ -3576,7 +3577,7 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n \t      int taken;\n \n \t      if (GET_CODE (ifelse) != IF_THEN_ELSE)\n-\t\tcontinue;\n+\t\tgoto do_next_insn;\n \n \t      if (GET_CODE (XEXP (ifelse, 1)) == LABEL_REF)\n \t\t{\n@@ -3603,7 +3604,7 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n \t\t  label = NULL_RTX;\n \t\t}\n \t      else\n-\t\tcontinue;\n+\t\tgoto do_next_insn;\n \n \t      /* If the test is expected to fail, reverse the\n \t\t probabilities.  */\n@@ -3617,11 +3618,14 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n \t      else if (label == if_false_label)\n \t\ttaken = 1 - taken;\n \t      else if (label != if_true_label)\n-\t\tcontinue;\n+\t\tgoto do_next_insn;\n \n \t      num_jumps++;\n \t      predict_insn_def (insn, PRED_BUILTIN_EXPECT, taken);\n \t    }\n+\n+\tdo_next_insn:\n+\t  insn = next;\n \t}\n \n       /* If no jumps were modified, fail and do __builtin_expect the normal"}, {"sha": "6abeacee02c8664fd745653f8479820ac889ce18", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1880,7 +1880,7 @@ try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n \t\t\t\t\t\tNULL_RTX, BITS_PER_UNIT);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n-\t\t  emit_insns_before (seq, first_insn);\n+\t\t  emit_insn_before (seq, first_insn);\n \t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n \t\t}\n \t    }\n@@ -3078,7 +3078,7 @@ expand_call (exp, target, ignore)\n \t    {\n \t      insns = get_insns ();\n \t      end_sequence ();\n-\t      emit_insns (insns);\n+\t      emit_insn (insns);\n \t    }\n \t  else\n \t    {\n@@ -3132,7 +3132,7 @@ expand_call (exp, target, ignore)\n \t  /* Write out the sequence.  */\n \t  insns = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns (insns);\n+\t  emit_insn (insns);\n \t  valreg = temp;\n \t}\n \n@@ -3419,7 +3419,7 @@ expand_call (exp, target, ignore)\n \t\t\t\t\t\ttail_recursion_label));\n     }\n   else\n-    emit_insns (normal_call_insns);\n+    emit_insn (normal_call_insns);\n \n   currently_expanding_call--;\n \n@@ -4099,7 +4099,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t{\n \t  insns = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns (insns);\n+\t  emit_insn (insns);\n \t}\n       else\n \t{"}, {"sha": "7ca747ad7b73a9530c42230a4bd7773a47f9f389", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1393,11 +1393,11 @@ commit_one_edge_insertion (e, watch_calls)\n \n   if (before)\n     {\n-      emit_insns_before (insns, before);\n+      emit_insn_before (insns, before);\n       last = prev_nonnote_insn (before);\n     }\n   else\n-    last = emit_insns_after (insns, after);\n+    last = emit_insn_after (insns, after);\n \n   if (returnjump_p (last))\n     {"}, {"sha": "3a173de4a087af5a64dfecc186becf9700e84011", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2167,30 +2167,23 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t    }\n \t}\n \n-      /* If we've split a jump pattern, we'll wind up with a sequence even\n-\t with one instruction.  We can handle that below, so extract it.  */\n-      if (m_split && GET_CODE (m_split) == SEQUENCE\n-\t  && XVECLEN (m_split, 0) == 1)\n-\tm_split = PATTERN (XVECEXP (m_split, 0, 0));\n-\n-      if (m_split && GET_CODE (m_split) != SEQUENCE)\n+      if (m_split && NEXT_INSN (m_split) == NULL_RTX)\n \t{\n+\t  m_split = PATTERN (m_split);\n \t  insn_code_number = recog_for_combine (&m_split, i3, &new_i3_notes);\n \t  if (insn_code_number >= 0)\n \t    newpat = m_split;\n \t}\n-      else if (m_split && GET_CODE (m_split) == SEQUENCE\n-\t       && XVECLEN (m_split, 0) == 2\n+      else if (m_split && NEXT_INSN (NEXT_INSN (m_split)) == NULL_RTX\n \t       && (next_real_insn (i2) == i3\n-\t\t   || ! use_crosses_set_p (PATTERN (XVECEXP (m_split, 0, 0)),\n-\t\t\t\t\t   INSN_CUID (i2))))\n+\t\t   || ! use_crosses_set_p (PATTERN (m_split), INSN_CUID (i2))))\n \t{\n \t  rtx i2set, i3set;\n-\t  rtx newi3pat = PATTERN (XVECEXP (m_split, 0, 1));\n-\t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n+\t  rtx newi3pat = PATTERN (NEXT_INSN (m_split));\n+\t  newi2pat = PATTERN (m_split);\n \n-\t  i3set = single_set (XVECEXP (m_split, 0, 1));\n-\t  i2set = single_set (XVECEXP (m_split, 0, 0));\n+\t  i3set = single_set (NEXT_INSN (m_split));\n+\t  i2set = single_set (m_split);\n \n \t  /* In case we changed the mode of I2DEST, replace it in the\n \t     pseudo-register table here.  We can't do it above in case this\n@@ -2960,20 +2953,22 @@ find_split_point (loc, insn)\n \t     we can make put both sources together and make a split point\n \t     in the middle.  */\n \n-\t  if (seq && XVECLEN (seq, 0) == 2\n-\t      && GET_CODE (XVECEXP (seq, 0, 0)) == INSN\n-\t      && GET_CODE (PATTERN (XVECEXP (seq, 0, 0))) == SET\n-\t      && SET_DEST (PATTERN (XVECEXP (seq, 0, 0))) == reg\n+\t  if (seq\n+\t      && NEXT_INSN (seq) != NULL_RTX\n+\t      && NEXT_INSN (NEXT_INSN (seq)) == NULL_RTX\n+\t      && GET_CODE (seq) == INSN\n+\t      && GET_CODE (PATTERN (seq)) == SET\n+\t      && SET_DEST (PATTERN (seq)) == reg\n \t      && ! reg_mentioned_p (reg,\n-\t\t\t\t    SET_SRC (PATTERN (XVECEXP (seq, 0, 0))))\n-\t      && GET_CODE (XVECEXP (seq, 0, 1)) == INSN\n-\t      && GET_CODE (PATTERN (XVECEXP (seq, 0, 1))) == SET\n-\t      && SET_DEST (PATTERN (XVECEXP (seq, 0, 1))) == reg\n+\t\t\t\t    SET_SRC (PATTERN (seq)))\n+\t      && GET_CODE (NEXT_INSN (seq)) == INSN\n+\t      && GET_CODE (PATTERN (NEXT_INSN (seq))) == SET\n+\t      && SET_DEST (PATTERN (NEXT_INSN (seq))) == reg\n \t      && memory_address_p (GET_MODE (x),\n-\t\t\t\t   SET_SRC (PATTERN (XVECEXP (seq, 0, 1)))))\n+\t\t\t\t   SET_SRC (PATTERN (NEXT_INSN (seq)))))\n \t    {\n-\t      rtx src1 = SET_SRC (PATTERN (XVECEXP (seq, 0, 0)));\n-\t      rtx src2 = SET_SRC (PATTERN (XVECEXP (seq, 0, 1)));\n+\t      rtx src1 = SET_SRC (PATTERN (seq));\n+\t      rtx src2 = SET_SRC (PATTERN (NEXT_INSN (seq)));\n \n \t      /* Replace the placeholder in SRC2 with SRC1.  If we can\n \t\t find where in SRC2 it was placed, that can become our"}, {"sha": "543d9d044b5103e2280f6d2a3c7fd010b7b28966", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2519,6 +2519,8 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n   switch (GET_CODE (x))\n     {\n     case SEQUENCE:\n+      abort ();\n+\n     case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \talpha_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p,\n@@ -2553,11 +2555,11 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n     }\n }\n \n-/* Given INSN, which is either an INSN or a SEQUENCE generated to\n-   perform a memory operation, look for any MEMs in either a SET_DEST or\n-   a SET_SRC and copy the in-struct, unchanging, and volatile flags from\n-   REF into each of the MEMs found.  If REF is not a MEM, don't do\n-   anything.  */\n+/* Given INSN, which is an INSN list or the PATTERN of a single insn\n+   generated to perform a memory operation, look for any MEMs in either\n+   a SET_DEST or a SET_SRC and copy the in-struct, unchanging, and\n+   volatile flags from REF into each of the MEMs found.  If REF is not\n+   a MEM, don't do anything.  */\n \n void\n alpha_set_memflags (insn, ref)\n@@ -6873,22 +6875,30 @@ alpha_write_verstamp (file)\n static rtx\n set_frame_related_p ()\n {\n-  rtx seq = gen_sequence ();\n+  rtx seq = get_insns ();\n+  rtx insn;\n+\n   end_sequence ();\n \n-  if (GET_CODE (seq) == SEQUENCE)\n+  if (!seq)\n+    return NULL_RTX;\n+\n+  if (INSN_P (seq))\n     {\n-      int i = XVECLEN (seq, 0);\n-      while (--i >= 0)\n-\tRTX_FRAME_RELATED_P (XVECEXP (seq, 0, i)) = 1;\n-     return emit_insn (seq);\n+      insn = seq;\n+      while (insn != NULL_RTX)\n+\t{\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+      seq = emit_insn (seq);\n     }\n   else\n     {\n       seq = emit_insn (seq);\n       RTX_FRAME_RELATED_P (seq) = 1;\n-      return seq;\n     }\n+  return seq;\n }\n \n #define FRP(exp)  (start_sequence (), exp, set_frame_related_p ())"}, {"sha": "9b6a83028b686fc6c225512e48310ff355620c78", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -6740,7 +6740,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n    && prev_nonnote_insn (insn) == operands[0]\"\n   [(const_int 0)]\n-  \"DONE;\")\n+  \"\n+{\n+  emit_note (NULL, NOTE_INSN_DELETED);\n+  DONE;\n+}\")\n \n (define_insn \"*builtin_setjmp_receiver_1\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]"}, {"sha": "5dce15b31c309dbe577ce89f64c4a3d49298c655", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2440,7 +2440,7 @@ arm_finalize_pic (prologue)\n       emit_insn (gen_pic_add_dot_plus_four (pic_offset_table_rtx, l1));\n     }\n \n-  seq = gen_sequence ();\n+  seq = get_insns ();\n   end_sequence ();\n   if (prologue)\n     emit_insn_after (seq, get_insns ());\n@@ -4319,7 +4319,7 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n       if (write_back)\n \temit_move_insn (from, plus_constant (from, count * 4 * sign));\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n       \n       return seq;\n@@ -4386,7 +4386,7 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n       if (write_back)\n \temit_move_insn (to, plus_constant (to, count * 4 * sign));\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n       \n       return seq;"}, {"sha": "6a42c8704242e7cbefe6839e3bf4fcd12960d19d", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2855,7 +2855,7 @@ cris_split_movdx (operands)\n   else\n     abort ();\n \n-  val = gen_sequence ();\n+  val = get_insns ();\n   end_sequence ();\n   return val;\n }"}, {"sha": "f807756bfea680d681ee96dea9b34db4bd318efa", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1095,7 +1095,7 @@ fr30_move_double (operands)\n     /* This should have been prevented by the constraints on movdi_insn.  */\n     abort ();\n   \n-  val = gen_sequence ();\n+  val = get_insns ();\n   end_sequence ();\n \n   return val;"}, {"sha": "9ece4eb24022537d8aaac8992daa2139174fac76", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -8628,7 +8628,7 @@ ix86_expand_int_movcc (operands)\n \n   start_sequence ();\n   compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n-  compare_seq = gen_sequence ();\n+  compare_seq = get_insns ();\n   end_sequence ();\n \n   compare_code = GET_CODE (compare_op);\n@@ -9995,7 +9995,7 @@ ix86_expand_movstr (dst, src, count_exp, align_exp)\n   end_sequence ();\n \n   ix86_set_move_mem_attrs (insns, dst, src, destreg, srcreg);\n-  emit_insns (insns);\n+  emit_insn (insns);\n   return 1;\n }\n "}, {"sha": "e7ef534873c204d6b6a13a5c7d92fd5718d85f6d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2050,7 +2050,7 @@ spill_restore_mem (reg, cfa_off)\n \t\t\t\t spill_fill_data.init_reg[iter],\n \t\t\t\t disp_rtx));\n \n-\t  seq = gen_sequence ();\n+\t  seq = get_insns ();\n \t  end_sequence ();\n \t}\n "}, {"sha": "0dd4487967b2b276d2136f5d4a71cd2eea0aedd1", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -4429,11 +4429,15 @@\n   [(const_int 0)]\n {\n   rtx tmp;\n+  int emitted_something;\n+\n+  emitted_something = 0;\n   if (! rtx_equal_p (operands[0], operands[2]))\n     {\n       tmp = gen_rtx_SET (VOIDmode, operands[0], operands[2]);\n       tmp = gen_rtx_COND_EXEC (VOIDmode, operands[4], tmp);\n       emit_insn (tmp);\n+      emitted_something = 1;\n     }\n   if (! rtx_equal_p (operands[0], operands[3]))\n     {\n@@ -4443,7 +4447,10 @@\n \t\t\t       gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t\t\t    operands[3]));\n       emit_insn (tmp);\n+      emitted_something = 1;\n     }\n+  if (! emitted_something)\n+    emit_note (NULL, NOTE_INSN_DELETED);\n   DONE;\n })\n "}, {"sha": "5948039b55973fd71d94fa56cacd6330ca9822af", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1390,7 +1390,7 @@ gen_split_move_double (operands)\n   else\n     abort ();\n \n-  val = gen_sequence ();\n+  val = get_insns ();\n   end_sequence ();\n   return val;\n }"}, {"sha": "d9a366f7720e7b5aa190bebbe7a1f9d24fd95e1f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1970,7 +1970,7 @@ embedded_pic_fnaddr_reg ()\n       start_sequence ();\n       emit_insn (gen_get_fnaddr (cfun->machine->embedded_pic_fnaddr_rtx,\n \t\t\t\t XEXP (DECL_RTL (current_function_decl), 0)));\n-      seq = gen_sequence ();\n+      seq = get_insn ();\n       end_sequence ();\n       push_topmost_sequence ();\n       emit_insn_after (seq, get_insns ());\n@@ -7371,7 +7371,7 @@ mips_expand_prologue ()\n \t\t\t\t\t    GEN_INT (gp_offset\n \t\t\t\t\t\t     - base_offset))),\n \t\t\t  reg_rtx);\n-\t  reg_18_save = gen_sequence ();\n+\t  reg_18_save = get_insns ();\n \t  end_sequence ();\n \t}\n \n@@ -8343,7 +8343,7 @@ mips16_gp_pseudo_reg ()\n       start_sequence ();\n       emit_move_insn (cfun->machine->mips16_gp_pseudo_rtx,\n \t\t      const_gp);\n-      insn = gen_sequence ();\n+      insn = get_insns ();\n       end_sequence ();\n \n       push_topmost_sequence ();"}, {"sha": "edd4c4998cb0ded3c1b5dec5c0a3f52ea10097c6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -5034,11 +5034,9 @@ sh_need_epilogue ()\n \n       start_sequence ();\n       sh_expand_epilogue ();\n-      epilogue = gen_sequence ();\n+      epilogue = get_insns ();\n       end_sequence ();\n-      sh_need_epilogue_known\n-\t= (GET_CODE (epilogue) == SEQUENCE && XVECLEN (epilogue, 0) == 0\n-\t   ? -1 : 1);\n+      sh_need_epilogue_known = (epilogue == NULL ? -1 : 1);\n     }\n   return sh_need_epilogue_known > 0;\n }"}, {"sha": "158a5c62bcc67b2bf3ea7b2159a2a43c8a51a5b7", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -113,6 +113,12 @@\n (define_attr \"pic\" \"false,true\"\n   (symbol_ref \"flag_pic != 0\"))\n \n+(define_attr \"current_function_calls_alloca\" \"false,true\"\n+  (symbol_ref \"current_function_calls_alloca != 0\"))\n+\n+(define_attr \"flat\" \"false,true\"\n+  (symbol_ref \"TARGET_FLAT != 0\"))\n+\n ;; Length (in # of insns).\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"uncond_branch,call,sibcall\")\n@@ -8174,8 +8180,10 @@\n   \"\"\n   \"*\n {\n-  if (! current_function_calls_alloca || ! TARGET_V9 || TARGET_FLAT)\n-    return \\\"#\\\";\n+  if (! current_function_calls_alloca)\n+    return \\\"\\\";\n+  if (! TARGET_V9 || TARGET_FLAT)\n+    return \\\"\\tta\\t3\\n\\\";\n   fputs (\\\"\\tflushw\\n\\\", asm_out_file);\n   if (flag_pic)\n     fprintf (asm_out_file, \\\"\\tst%c\\t%%l7, [%%sp+%d]\\n\\\",\n@@ -8190,20 +8198,15 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"multi\")\n-   (set (attr \"length\") (if_then_else (eq_attr \"pic\" \"true\")\n-\t\t\t\t       (const_int 4)\n-\t\t\t\t       (const_int 3)))])\n-\n-(define_split\n-  [(unspec_volatile [(const_int 0)] UNSPECV_SETJMP)]\n-  \"! current_function_calls_alloca || ! TARGET_V9 || TARGET_FLAT\"\n-  [(const_int 0)]\n-  \"\n-{\n-  if (current_function_calls_alloca)\n-    emit_insn (gen_flush_register_windows ());\n-  DONE;\n-}\")\n+   (set (attr \"length\")\n+        (cond [(eq_attr \"current_function_calls_alloca\" \"false\")\n+                 (const_int 0)\n+               (eq_attr \"flat\" \"true\")\n+                 (const_int 1)\n+               (eq_attr \"isa\" \"!v9\")\n+                 (const_int 1)\n+               (eq_attr \"pic\" \"true\")\n+                 (const_int 4)] (const_int 3)))])\n \n ;; Pattern for use after a setjmp to store FP and the return register\n ;; into the stack area."}, {"sha": "69e42bb901cbcbab6a651fbea5d50b5bdae0d53b", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -227,15 +227,22 @@ xstormy16_split_cbranch (mode, label, comparison, dest, carry)\n {\n   rtx op0 = XEXP (comparison, 0);\n   rtx op1 = XEXP (comparison, 1);\n-  rtx seq;\n+  rtx seq, last_insn;\n   rtx compare;\n   \n   start_sequence ();\n   xstormy16_expand_arith (mode, COMPARE, dest, op0, op1, carry);\n-  seq = gen_sequence ();\n+  seq = get_insns ();\n   end_sequence ();\n-  compare = SET_SRC (XVECEXP (PATTERN (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1)),\n-\t\t\t      0, 0));\n+\n+  if (! INSN_P (seq))\n+    abort ();\n+\n+  last_insn = seq;\n+  while (NEXT_INSN (last_insn) != NULL_RTX)\n+    last_insn = NEXT_INSN (last_insn);\n+\n+  compare = SET_SRC (XVECEXP (PATTERN (last_insn), 0, 0));\n   PUT_CODE (XEXP (compare, 0), GET_CODE (comparison));\n   XEXP (compare, 1) = gen_rtx_LABEL_REF (VOIDmode, label);\n   emit_insn (seq);"}, {"sha": "dc9ea37973440291dee4516edfa930e9cbfb72d4", "filename": "gcc/doloop.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -490,7 +490,7 @@ doloop_modify (loop, iterations, iterations_max,\n \n   /* Insert initialization of the count register into the loop header.  */\n   convert_move (counter_reg, count, 1);\n-  sequence = gen_sequence ();\n+  sequence = get_insns ();\n   end_sequence ();\n   emit_insn_before (sequence, loop->start);\n \n@@ -508,7 +508,7 @@ doloop_modify (loop, iterations, iterations_max,\n       {\n \tstart_sequence ();\n \temit_insn (init);\n-\tsequence = gen_sequence ();\n+\tsequence = get_insns ();\n \tend_sequence ();\n \temit_insn_after (sequence, loop->start);\n       }\n@@ -747,7 +747,7 @@ doloop_modify_runtime (loop, iterations_max,\n \t}\n     }\n \n-  sequence = gen_sequence ();\n+  sequence = get_insns ();\n   end_sequence ();\n   emit_insn_before (sequence, loop->start);\n \n@@ -871,18 +871,17 @@ doloop_optimize (loop)\n       return 0;\n     }\n \n-  /* A raw define_insn may yield a plain pattern.  If a sequence\n-     was involved, the last must be the jump instruction.  */\n-  if (GET_CODE (doloop_seq) == SEQUENCE)\n+  /* If multiple instructions were created, the last must be the\n+     jump instruction.  Also, a raw define_insn may yield a plain\n+     pattern.  */\n+  doloop_pat = doloop_seq;\n+  if (INSN_P (doloop_pat) && NEXT_INSN (doloop_pat) != NULL_RTX)\n     {\n-      doloop_pat = XVECEXP (doloop_seq, 0, XVECLEN (doloop_seq, 0) - 1);\n-      if (GET_CODE (doloop_pat) == JUMP_INSN)\n-\tdoloop_pat = PATTERN (doloop_pat);\n-      else\n+      while (NEXT_INSN (doloop_pat) != NULL_RTX)\n+\tdoloop_pat = NEXT_INSN (doloop_pat);\n+      if (GET_CODE (doloop_pat) != JUMP_INSN)\n \tdoloop_pat = NULL_RTX;\n     }\n-  else\n-    doloop_pat = doloop_seq;\n \n   if (! doloop_pat\n       || ! (condition = doloop_condition_get (doloop_pat)))"}, {"sha": "a78a5747d9eca3f09bf1b336b241ef0b67f402ae", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 480, "deletions": 327, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -3101,95 +3101,118 @@ try_split (pat, trial, last)\n \n   if (seq)\n     {\n-      /* SEQ can either be a SEQUENCE or the pattern of a single insn.\n-\t The latter case will normally arise only when being done so that\n-\t it, in turn, will be split (SFmode on the 29k is an example).  */\n-      if (GET_CODE (seq) == SEQUENCE)\n+      /* SEQ can only be a list of insns.  */\n+      if (! INSN_P (seq))\n+\tabort ();\n+\n+      /* Sometimes there will be only one insn in that list, this case will\n+\t normally arise only when we want it in turn to be split (SFmode on\n+\t the 29k is an example).  */\n+      if (NEXT_INSN (seq) != NULL_RTX)\n \t{\n-\t  int i, njumps = 0;\n+\t  rtx insn_last, insn;\n+\t  int njumps = 0;\n \n \t  /* Avoid infinite loop if any insn of the result matches\n \t     the original pattern.  */\n-\t  for (i = 0; i < XVECLEN (seq, 0); i++)\n-\t    if (GET_CODE (XVECEXP (seq, 0, i)) == INSN\n-\t\t&& rtx_equal_p (PATTERN (XVECEXP (seq, 0, i)), pat))\n-\t      return trial;\n+\t  insn_last = seq;\n+\t  while (1)\n+\t    {\n+\t      if (rtx_equal_p (PATTERN (insn_last), pat))\n+\t\treturn trial;\n+\t      if (NEXT_INSN (insn_last) == NULL_RTX)\n+\t\tbreak;\n+\t      insn_last = NEXT_INSN (insn_last);\n+\t    }\n \n \t  /* Mark labels.  */\n-\t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n-\t    if (GET_CODE (XVECEXP (seq, 0, i)) == JUMP_INSN)\n-\t      {\n-\t\trtx insn = XVECEXP (seq, 0, i);\n-\t\tmark_jump_label (PATTERN (insn),\n-\t\t\t\t XVECEXP (seq, 0, i), 0);\n-\t\tnjumps++;\n-\t\tif (probability != -1\n-\t\t    && any_condjump_p (insn)\n-\t\t    && !find_reg_note (insn, REG_BR_PROB, 0))\n-\t\t  {\n-\t\t    /* We can preserve the REG_BR_PROB notes only if exactly\n-\t\t       one jump is created, otherwise the machine description\n-\t\t       is responsible for this step using\n-\t\t       split_branch_probability variable.  */\n-\t\t    if (njumps != 1)\n-\t\t      abort ();\n-\t\t    REG_NOTES (insn)\n-\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\t   GEN_INT (probability),\n-\t\t\t\t\t   REG_NOTES (insn));\n-\t\t  }\n-\t      }\n+\t  insn = insn_last;\n+\t  while (insn != NULL_RTX)\n+\t    {\n+\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t\t{\n+\t\t  mark_jump_label (PATTERN (insn), insn, 0);\n+\t\t  njumps++;\n+\t\t  if (probability != -1\n+\t\t      && any_condjump_p (insn)\n+\t\t      && !find_reg_note (insn, REG_BR_PROB, 0))\n+\t\t    {\n+\t\t      /* We can preserve the REG_BR_PROB notes only if exactly\n+\t\t\t one jump is created, otherwise the machine description\n+\t\t\t is responsible for this step using\n+\t\t\t split_branch_probability variable.  */\n+\t\t      if (njumps != 1)\n+\t\t\tabort ();\n+\t\t      REG_NOTES (insn)\n+\t\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\t     GEN_INT (probability),\n+\t\t\t\t\t     REG_NOTES (insn));\n+\t\t    }\n+\t\t}\n+\n+\t      insn = PREV_INSN (insn);\n+\t    }\n \n \t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n \t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */\n \t  if (GET_CODE (trial) == CALL_INSN)\n-\t    for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n-\t      if (GET_CODE (XVECEXP (seq, 0, i)) == CALL_INSN)\n-\t\tCALL_INSN_FUNCTION_USAGE (XVECEXP (seq, 0, i))\n-\t\t  = CALL_INSN_FUNCTION_USAGE (trial);\n+\t    {\n+\t      insn = insn_last;\n+\t      while (insn != NULL_RTX)\n+\t\t{\n+\t\t  if (GET_CODE (insn) == CALL_INSN)\n+\t\t    CALL_INSN_FUNCTION_USAGE (insn)\n+\t\t      = CALL_INSN_FUNCTION_USAGE (trial);\n+\n+\t\t  insn = PREV_INSN (insn);\n+\t\t}\n+\t    }\n \n \t  /* Copy notes, particularly those related to the CFG.  */\n \t  for (note = REG_NOTES (trial); note; note = XEXP (note, 1))\n \t    {\n \t      switch (REG_NOTE_KIND (note))\n \t\t{\n \t\tcase REG_EH_REGION:\n-\t\t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n+\t\t  insn = insn_last;\n+\t\t  while (insn != NULL_RTX)\n \t\t    {\n-\t\t      rtx insn = XVECEXP (seq, 0, i);\n \t\t      if (GET_CODE (insn) == CALL_INSN\n \t\t\t  || (flag_non_call_exceptions\n \t\t\t      && may_trap_p (PATTERN (insn))))\n \t\t\tREG_NOTES (insn)\n \t\t\t  = gen_rtx_EXPR_LIST (REG_EH_REGION,\n \t\t\t\t\t       XEXP (note, 0),\n \t\t\t\t\t       REG_NOTES (insn));\n+\t\t      insn = PREV_INSN (insn);\n \t\t    }\n \t\t  break;\n \n \t\tcase REG_NORETURN:\n \t\tcase REG_SETJMP:\n \t\tcase REG_ALWAYS_RETURN:\n-\t\t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n+\t\t  insn = insn_last;\n+\t\t  while (insn != NULL_RTX)\n \t\t    {\n-\t\t      rtx insn = XVECEXP (seq, 0, i);\n \t\t      if (GET_CODE (insn) == CALL_INSN)\n \t\t\tREG_NOTES (insn)\n \t\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n \t\t\t\t\t       XEXP (note, 0),\n \t\t\t\t\t       REG_NOTES (insn));\n+\t\t      insn = PREV_INSN (insn);\n \t\t    }\n \t\t  break;\n \n \t\tcase REG_NON_LOCAL_GOTO:\n-\t\t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n+\t\t  insn = insn_last;\n+\t\t  while (insn != NULL_RTX)\n \t\t    {\n-\t\t      rtx insn = XVECEXP (seq, 0, i);\n \t\t      if (GET_CODE (insn) == JUMP_INSN)\n \t\t\tREG_NOTES (insn)\n \t\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n \t\t\t\t\t       XEXP (note, 0),\n \t\t\t\t\t       REG_NOTES (insn));\n+\t\t      insn = PREV_INSN (insn);\n \t\t    }\n \t\t  break;\n \n@@ -3201,9 +3224,16 @@ try_split (pat, trial, last)\n \t  /* If there are LABELS inside the split insns increment the\n \t     usage count so we don't delete the label.  */\n \t  if (GET_CODE (trial) == INSN)\n-\t    for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n-\t      if (GET_CODE (XVECEXP (seq, 0, i)) == INSN)\n-\t\tmark_label_nuses (PATTERN (XVECEXP (seq, 0, i)));\n+\t    {\n+\t      insn = last_insn;\n+\t      while (insn != NULL_RTX)\n+\t\t{\n+\t\t  if (GET_CODE (insn) == INSN)\n+\t\t    mark_label_nuses (PATTERN (insn));\n+\n+\t\t  insn = PREV_INSN (insn);\n+\t\t}\n+\t    }\n \n \t  tem = emit_insn_after_scope (seq, trial, INSN_SCOPE (trial));\n \n@@ -3221,13 +3251,13 @@ try_split (pat, trial, last)\n \t      tem = try_split (PATTERN (tem), tem, 1);\n \t}\n       /* Avoid infinite loop if the result matches the original pattern.  */\n-      else if (rtx_equal_p (seq, pat))\n+      else if (rtx_equal_p (PATTERN (seq), pat))\n \treturn trial;\n       else\n \t{\n-\t  PATTERN (trial) = seq;\n+\t  PATTERN (trial) = PATTERN (seq);\n \t  INSN_CODE (trial) = -1;\n-\t  try_split (seq, trial, last);\n+\t  try_split (PATTERN (trial), trial, last);\n \t}\n \n       /* Return either the first or the last insn, depending on which was\n@@ -3274,7 +3304,7 @@ make_insn_raw (pattern)\n   return insn;\n }\n \n-/* Like `make_insn' but make a JUMP_INSN instead of an insn.  */\n+/* Like `make_insn_raw' but make a JUMP_INSN instead of an insn.  */\n \n static rtx\n make_jump_insn_raw (pattern)\n@@ -3296,7 +3326,7 @@ make_jump_insn_raw (pattern)\n   return insn;\n }\n \n-/* Like `make_insn' but make a CALL_INSN instead of an insn.  */\n+/* Like `make_insn_raw' but make a CALL_INSN instead of an insn.  */\n \n static rtx\n make_call_insn_raw (pattern)\n@@ -3782,97 +3812,173 @@ remove_unnecessary_notes ()\n }\n \n \f\n-/* Emit an insn of given code and pattern\n-   at a specified place within the doubly-linked list.  */\n+/* Emit insn(s) of given code and pattern\n+   at a specified place within the doubly-linked list.\n \n-/* Make an instruction with body PATTERN\n-   and output it before the instruction BEFORE.  */\n+   All of the emit_foo global entry points accept an object\n+   X which is either an insn list or a PATTERN of a single\n+   instruction.\n \n-rtx\n-emit_insn_before (pattern, before)\n-     rtx pattern, before;\n-{\n-  rtx insn = before;\n+   There are thus a few canonical ways to generate code and\n+   emit it at a specific place in the instruction stream.  For\n+   example, consider the instruction named SPOT and the fact that\n+   we would like to emit some instructions before SPOT.  We might\n+   do it like this:\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    {\n-      int i;\n+\tstart_sequence ();\n+\t... emit the new instructions ...\n+\tinsns_head = get_insns ();\n+\tend_sequence ();\n \n-      for (i = 0; i < XVECLEN (pattern, 0); i++)\n-\t{\n-\t  insn = XVECEXP (pattern, 0, i);\n-\t  add_insn_before (insn, before);\n-\t}\n-    }\n-  else\n-    {\n-      insn = make_insn_raw (pattern);\n-      add_insn_before (insn, before);\n-    }\n+\temit_insn_before (insns_head, SPOT);\n \n-  return insn;\n-}\n+   It used to be common to generate SEQUENCE rtl instead, but that\n+   is a relic of the past which no longer occurs.  The reason is that\n+   SEQUENCE rtl results in much fragmented RTL memory since the SEQUENCE\n+   generated would almost certainly die right after it was created.  */\n \n-/* Make an instruction with body PATTERN and code JUMP_INSN\n-   and output it before the instruction BEFORE.  */\n+/* Make X be output before the instruction BEFORE.  */\n \n rtx\n-emit_jump_insn_before (pattern, before)\n-     rtx pattern, before;\n+emit_insn_before (x, before)\n+     rtx x, before;\n {\n+  rtx last = before;\n   rtx insn;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    insn = emit_insn_before (pattern, before);\n-  else\n+#ifdef ENABLE_RTL_CHECKING\n+  if (before == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  if (x == NULL_RTX)\n+    return last;\n+\n+  switch (GET_CODE (x))\n     {\n-      insn = make_jump_insn_raw (pattern);\n-      add_insn_before (insn, before);\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn_before (insn, before);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_insn_raw (x);\n+      add_insn_before (last, before);\n+      break;\n     }\n \n-  return insn;\n+  return last;\n }\n \n-/* Make an instruction with body PATTERN and code CALL_INSN\n+/* Make an instruction with body X and code JUMP_INSN\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_call_insn_before (pattern, before)\n-     rtx pattern, before;\n+emit_jump_insn_before (x, before)\n+     rtx x, before;\n {\n-  rtx insn;\n+  rtx insn, last;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    insn = emit_insn_before (pattern, before);\n-  else\n+#ifdef ENABLE_RTL_CHECKING\n+  if (before == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  switch (GET_CODE (x))\n     {\n-      insn = make_call_insn_raw (pattern);\n-      add_insn_before (insn, before);\n-      PUT_CODE (insn, CALL_INSN);\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn_before (insn, before);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_jump_insn_raw (x);\n+      add_insn_before (last, before);\n+      break;\n     }\n \n-  return insn;\n+  return last;\n }\n \n-/* Make an instruction with body PATTERN and code CALL_INSN\n+/* Make an instruction with body X and code CALL_INSN\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_call_insn_after (pattern, before)\n-     rtx pattern, before;\n+emit_call_insn_before (x, before)\n+     rtx x, before;\n {\n-  rtx insn;\n+  rtx last, insn;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    insn = emit_insn_after (pattern, before);\n-  else\n+#ifdef ENABLE_RTL_CHECKING\n+  if (before == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  switch (GET_CODE (x))\n     {\n-      insn = make_call_insn_raw (pattern);\n-      add_insn_after (insn, before);\n-      PUT_CODE (insn, CALL_INSN);\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn_before (insn, before);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_call_insn_raw (x);\n+      add_insn_before (last, before);\n+      break;\n     }\n \n-  return insn;\n+  return last;\n }\n \n /* Make an insn of code BARRIER\n@@ -3924,45 +4030,100 @@ emit_note_before (subtype, before)\n   return note;\n }\n \f\n-/* Make an insn of code INSN with body PATTERN\n-   and output it after the insn AFTER.  */\n+/* Helper for emit_insn_after, handles lists of instructions\n+   efficiently.  */\n \n-rtx\n-emit_insn_after (pattern, after)\n-     rtx pattern, after;\n+static rtx emit_insn_after_1 PARAMS ((rtx, rtx));\n+\n+static rtx\n+emit_insn_after_1 (first, after)\n+     rtx first, after;\n {\n-  rtx insn = after;\n+  rtx last;\n+  rtx after_after;\n+  basic_block bb;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n+  if (GET_CODE (after) != BARRIER\n+      && (bb = BLOCK_FOR_INSN (after)))\n     {\n-      int i;\n-\n-      for (i = 0; i < XVECLEN (pattern, 0); i++)\n-\t{\n-\t  insn = XVECEXP (pattern, 0, i);\n-\t  add_insn_after (insn, after);\n-\t  after = insn;\n-\t}\n+      bb->flags |= BB_DIRTY;\n+      for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n+\tif (GET_CODE (last) != BARRIER)\n+\t  set_block_for_insn (last, bb);\n+      if (GET_CODE (last) != BARRIER)\n+\tset_block_for_insn (last, bb);\n+      if (bb->end == after)\n+\tbb->end = last;\n     }\n   else\n+    for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n+      continue;\n+\n+  after_after = NEXT_INSN (after);\n+\n+  NEXT_INSN (after) = first;\n+  PREV_INSN (first) = after;\n+  NEXT_INSN (last) = after_after;\n+  if (after_after)\n+    PREV_INSN (after_after) = last;\n+\n+  if (after == last_insn)\n+    last_insn = last;\n+  return last;\n+}\n+\n+/* Make X be output after the insn AFTER.  */\n+\n+rtx\n+emit_insn_after (x, after)\n+     rtx x, after;\n+{\n+  rtx last = after;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+  if (after == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  if (x == NULL_RTX)\n+    return last;\n+\n+  switch (GET_CODE (x))\n     {\n-      insn = make_insn_raw (pattern);\n-      add_insn_after (insn, after);\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      last = emit_insn_after_1 (x, after);\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_insn_raw (x);\n+      add_insn_after (last, after);\n+      break;\n     }\n \n-  return insn;\n+  return last;\n }\n \n /* Similar to emit_insn_after, except that line notes are to be inserted so\n    as to act as if this insn were at FROM.  */\n \n void\n-emit_insn_after_with_line_notes (pattern, after, from)\n-     rtx pattern, after, from;\n+emit_insn_after_with_line_notes (x, after, from)\n+     rtx x, after, from;\n {\n   rtx from_line = find_line_note (from);\n   rtx after_line = find_line_note (after);\n-  rtx insn = emit_insn_after (pattern, after);\n+  rtx insn = emit_insn_after (x, after);\n \n   if (from_line)\n     emit_line_note_after (NOTE_SOURCE_FILE (from_line),\n@@ -3975,24 +4136,84 @@ emit_insn_after_with_line_notes (pattern, after, from)\n \t\t\t  insn);\n }\n \n-/* Make an insn of code JUMP_INSN with body PATTERN\n+/* Make an insn of code JUMP_INSN with body X\n    and output it after the insn AFTER.  */\n \n rtx\n-emit_jump_insn_after (pattern, after)\n-     rtx pattern, after;\n+emit_jump_insn_after (x, after)\n+     rtx x, after;\n {\n-  rtx insn;\n+  rtx last;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    insn = emit_insn_after (pattern, after);\n-  else\n+#ifdef ENABLE_RTL_CHECKING\n+  if (after == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  switch (GET_CODE (x))\n     {\n-      insn = make_jump_insn_raw (pattern);\n-      add_insn_after (insn, after);\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      last = emit_insn_after_1 (x, after);\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_jump_insn_raw (x);\n+      add_insn_after (last, after);\n+      break;\n     }\n \n-  return insn;\n+  return last;\n+}\n+\n+/* Make an instruction with body X and code CALL_INSN\n+   and output it after the instruction AFTER.  */\n+\n+rtx\n+emit_call_insn_after (x, after)\n+     rtx x, after;\n+{\n+  rtx last;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+  if (after == NULL_RTX)\n+    abort ();\n+#endif\n+\n+  switch (GET_CODE (x))\n+    {\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      last = emit_insn_after_1 (x, after);\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_call_insn_raw (x);\n+      add_insn_after (last, after);\n+      break;\n+    }\n+\n+  return last;\n }\n \n /* Make an insn of code BARRIER\n@@ -4076,20 +4297,15 @@ emit_insn_after_scope (pattern, after, scope)\n      tree scope;\n {\n   rtx last = emit_insn_after (pattern, after);\n-  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n-    INSN_SCOPE (after) = scope;\n-  return last;\n-}\n \n-/* Like emit_insns_after, but set INSN_SCOPE according to SCOPE.  */\n-rtx\n-emit_insns_after_scope (pattern, after, scope)\n-     rtx pattern, after;\n-     tree scope;\n-{\n-  rtx last = emit_insns_after (pattern, after);\n-  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n-    INSN_SCOPE (after) = scope;\n+  after = NEXT_INSN (after);\n+  while (1)\n+    {\n+      INSN_SCOPE (after) = scope;\n+      if (after == last)\n+\tbreak;\n+      after = NEXT_INSN (after);\n+    }\n   return last;\n }\n \n@@ -4100,8 +4316,15 @@ emit_jump_insn_after_scope (pattern, after, scope)\n      tree scope;\n {\n   rtx last = emit_jump_insn_after (pattern, after);\n-  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n-    INSN_SCOPE (after) = scope;\n+\n+  after = NEXT_INSN (after);\n+  while (1)\n+    {\n+      INSN_SCOPE (after) = scope;\n+      if (after == last)\n+\tbreak;\n+      after = NEXT_INSN (after);\n+    }\n   return last;\n }\n \n@@ -4112,8 +4335,15 @@ emit_call_insn_after_scope (pattern, after, scope)\n      tree scope;\n {\n   rtx last = emit_call_insn_after (pattern, after);\n-  for (after = NEXT_INSN (after); after != last; after = NEXT_INSN (after))\n-    INSN_SCOPE (after) = scope;\n+\n+  after = NEXT_INSN (after);\n+  while (1)\n+    {\n+      INSN_SCOPE (after) = scope;\n+      if (after == last)\n+\tbreak;\n+      after = NEXT_INSN (after);\n+    }\n   return last;\n }\n \n@@ -4126,178 +4356,140 @@ emit_insn_before_scope (pattern, before, scope)\n   rtx first = PREV_INSN (before);\n   rtx last = emit_insn_before (pattern, before);\n \n-  for (first = NEXT_INSN (first); first != last; first = NEXT_INSN (first))\n-    INSN_SCOPE (first) = scope;\n-  return last;\n-}\n-\n-/* Like emit_insns_before, but set INSN_SCOPE according to SCOPE.  */\n-rtx\n-emit_insns_before_scope (pattern, before, scope)\n-     rtx pattern, before;\n-     tree scope;\n-{\n-  rtx first = PREV_INSN (before);\n-  rtx last = emit_insns_before (pattern, before);\n-\n-  for (first = NEXT_INSN (first); first != last; first = NEXT_INSN (first))\n-    INSN_SCOPE (first) = scope;\n+  first = NEXT_INSN (first);\n+  while (1)\n+    {\n+      INSN_SCOPE (first) = scope;\n+      if (first == last)\n+\tbreak;\n+      first = NEXT_INSN (first);\n+    }\n   return last;\n }\n \f\n-/* Make an insn of code INSN with pattern PATTERN\n-   and add it to the end of the doubly-linked list.\n-   If PATTERN is a SEQUENCE, take the elements of it\n-   and emit an insn for each element.\n+/* Take X and emit it at the end of the doubly-linked\n+   INSN list.\n \n    Returns the last insn emitted.  */\n \n rtx\n-emit_insn (pattern)\n-     rtx pattern;\n+emit_insn (x)\n+     rtx x;\n {\n-  rtx insn = last_insn;\n+  rtx last = last_insn;\n+  rtx insn;\n \n-  if (GET_CODE (pattern) == SEQUENCE)\n-    {\n-      int i;\n+  if (x == NULL_RTX)\n+    return last;\n \n-      for (i = 0; i < XVECLEN (pattern, 0); i++)\n+  switch (GET_CODE (x))\n+    {\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n \t{\n-\t  insn = XVECEXP (pattern, 0, i);\n+\t  rtx next = NEXT_INSN (insn);\n \t  add_insn (insn);\n+\t  last = insn;\n+\t  insn = next;\n \t}\n-    }\n-  else\n-    {\n-      insn = make_insn_raw (pattern);\n-      add_insn (insn);\n-    }\n-\n-  return insn;\n-}\n-\n-/* Emit the insns in a chain starting with INSN.\n-   Return the last insn emitted.  */\n+      break;\n \n-rtx\n-emit_insns (insn)\n-     rtx insn;\n-{\n-  rtx last = 0;\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n \n-  while (insn)\n-    {\n-      rtx next = NEXT_INSN (insn);\n-      add_insn (insn);\n-      last = insn;\n-      insn = next;\n+    default:\n+      last = make_insn_raw (x);\n+      add_insn (last);\n+      break;\n     }\n \n   return last;\n }\n \n-/* Emit the insns in a chain starting with INSN and place them in front of\n-   the insn BEFORE.  Return the last insn emitted.  */\n+/* Make an insn of code JUMP_INSN with pattern X\n+   and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_insns_before (insn, before)\n-     rtx insn;\n-     rtx before;\n+emit_jump_insn (x)\n+     rtx x;\n {\n-  rtx last = 0;\n+  rtx last, insn;\n \n-  while (insn)\n+  switch (GET_CODE (x))\n     {\n-      rtx next = NEXT_INSN (insn);\n-      add_insn_before (insn, before);\n-      last = insn;\n-      insn = next;\n-    }\n-\n-  return last;\n-}\n-\n-/* Emit the insns in a chain starting with FIRST and place them in back of\n-   the insn AFTER.  Return the last insn emitted.  */\n-\n-rtx\n-emit_insns_after (first, after)\n-     rtx first;\n-     rtx after;\n-{\n-  rtx last;\n-  rtx after_after;\n-  basic_block bb;\n-\n-  if (!after)\n-    abort ();\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn (insn);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n \n-  if (!first)\n-    return after;\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n \n-  if (GET_CODE (after) != BARRIER\n-      && (bb = BLOCK_FOR_INSN (after)))\n-    {\n-      bb->flags |= BB_DIRTY;\n-      for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-\tif (GET_CODE (last) != BARRIER)\n-\t  set_block_for_insn (last, bb);\n-      if (GET_CODE (last) != BARRIER)\n-\tset_block_for_insn (last, bb);\n-      if (bb->end == after)\n-\tbb->end = last;\n+    default:\n+      last = make_jump_insn_raw (x);\n+      add_insn (last);\n+      break;\n     }\n-  else\n-    for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-      continue;\n-\n-  after_after = NEXT_INSN (after);\n-\n-  NEXT_INSN (after) = first;\n-  PREV_INSN (first) = after;\n-  NEXT_INSN (last) = after_after;\n-  if (after_after)\n-    PREV_INSN (after_after) = last;\n \n-  if (after == last_insn)\n-    last_insn = last;\n   return last;\n }\n \n-/* Make an insn of code JUMP_INSN with pattern PATTERN\n+/* Make an insn of code CALL_INSN with pattern X\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_jump_insn (pattern)\n-     rtx pattern;\n+emit_call_insn (x)\n+     rtx x;\n {\n-  if (GET_CODE (pattern) == SEQUENCE)\n-    return emit_insn (pattern);\n-  else\n+  rtx insn;\n+\n+  switch (GET_CODE (x))\n     {\n-      rtx insn = make_jump_insn_raw (pattern);\n-      add_insn (insn);\n-      return insn;\n-    }\n-}\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = emit_insn (x);\n+      break;\n \n-/* Make an insn of code CALL_INSN with pattern PATTERN\n-   and add it to the end of the doubly-linked list.  */\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      abort ();\n+      break;\n+#endif\n \n-rtx\n-emit_call_insn (pattern)\n-     rtx pattern;\n-{\n-  if (GET_CODE (pattern) == SEQUENCE)\n-    return emit_insn (pattern);\n-  else\n-    {\n-      rtx insn = make_call_insn_raw (pattern);\n+    default:\n+      insn = make_call_insn_raw (x);\n       add_insn (insn);\n-      PUT_CODE (insn, CALL_INSN);\n-      return insn;\n+      break;\n     }\n+\n+  return insn;\n }\n \n /* Add the label LABEL to the end of the doubly-linked list.  */\n@@ -4634,12 +4826,12 @@ pop_topmost_sequence ()\n /* After emitting to a sequence, restore previous saved state.\n \n    To get the contents of the sequence just made, you must call\n-   `gen_sequence' *before* calling here.\n+   `get_insns' *before* calling here.\n \n    If the compiler might have deferred popping arguments while\n    generating this sequence, and this sequence will not be immediately\n    inserted into the instruction stream, use do_pending_stack_adjust\n-   before calling gen_sequence.  That will ensure that the deferred\n+   before calling get_insns.  That will ensure that the deferred\n    pops are inserted into this sequence, and not into some random\n    location in the instruction stream.  See INHIBIT_DEFER_POP for more\n    information about deferred popping of arguments.  */\n@@ -4678,45 +4870,6 @@ in_sequence_p ()\n {\n   return seq_stack != 0;\n }\n-\n-/* Generate a SEQUENCE rtx containing the insns already emitted\n-   to the current sequence.\n-\n-   This is how the gen_... function from a DEFINE_EXPAND\n-   constructs the SEQUENCE that it returns.  */\n-\n-rtx\n-gen_sequence ()\n-{\n-  rtx result;\n-  rtx tem;\n-  int i;\n-  int len;\n-\n-  /* Count the insns in the chain.  */\n-  len = 0;\n-  for (tem = first_insn; tem; tem = NEXT_INSN (tem))\n-    len++;\n-\n-  /* If only one insn, return it rather than a SEQUENCE.\n-     (Now that we cache SEQUENCE expressions, it isn't worth special-casing\n-     the case of an empty list.)\n-     We only return the pattern of an insn if its code is INSN and it\n-     has no notes.  This ensures that no information gets lost.  */\n-  if (len == 1\n-      && GET_CODE (first_insn) == INSN\n-      && ! RTX_FRAME_RELATED_P (first_insn)\n-      /* Don't throw away any reg notes.  */\n-      && REG_NOTES (first_insn) == 0)\n-    return PATTERN (first_insn);\n-\n-  result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n-\n-  for (i = 0, tem = first_insn; tem; tem = NEXT_INSN (tem), i++)\n-    XVECEXP (result, 0, i) = tem;\n-\n-  return result;\n-}\n \f\n /* Put the various virtual registers into REGNO_REG_RTX.  */\n "}, {"sha": "fd3a87f856a291cd7d6b9c511d6d228fd178ba10", "filename": "gcc/except.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1724,7 +1724,7 @@ build_post_landing_pads ()\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_insns_before (seq, region->u.try.catch->label);\n+\t  emit_insn_before (seq, region->u.try.catch->label);\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n@@ -1748,7 +1748,7 @@ build_post_landing_pads ()\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_insns_before (seq, region->label);\n+\t  emit_insn_before (seq, region->label);\n \t  break;\n \n \tcase ERT_CLEANUP:\n@@ -1805,7 +1805,7 @@ connect_post_landing_pads ()\n \n       seq = get_insns ();\n       end_sequence ();\n-      emit_insns_before (seq, region->resume);\n+      emit_insn_before (seq, region->resume);\n       delete_insn (region->resume);\n     }\n }\n@@ -1881,7 +1881,7 @@ dw2_build_landing_pads ()\n       seq = get_insns ();\n       end_sequence ();\n \n-      emit_insns_before (seq, region->post_landing_pad);\n+      emit_insn_before (seq, region->post_landing_pad);\n     }\n }\n \n@@ -2065,7 +2065,7 @@ sjlj_mark_call_sites (lp_info)\n       p = get_insns ();\n       end_sequence ();\n \n-      emit_insns_before (p, before);\n+      emit_insn_before (p, before);\n       last_call_site = this_call_site;\n     }\n }\n@@ -2132,7 +2132,7 @@ sjlj_emit_function_enter (dispatch_label)\n     if (GET_CODE (fn_begin) == NOTE\n \t&& NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n       break;\n-  emit_insns_after (seq, fn_begin);\n+  emit_insn_after (seq, fn_begin);\n }\n \n /* Call back from expand_function_end to know where we should put\n@@ -2162,7 +2162,7 @@ sjlj_emit_function_exit ()\n      post-dominates all can_throw_internal instructions.  This is\n      the last possible moment.  */\n \n-  emit_insns_after (seq, cfun->eh->sjlj_exit_after);\n+  emit_insn_after (seq, cfun->eh->sjlj_exit_after);\n }\n \n static void\n@@ -2226,8 +2226,8 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n   seq = get_insns ();\n   end_sequence ();\n \n-  emit_insns_before (seq, (cfun->eh->region_array[first_reachable]\n-\t\t\t   ->post_landing_pad));\n+  emit_insn_before (seq, (cfun->eh->region_array[first_reachable]\n+\t\t\t  ->post_landing_pad));\n }\n \n static void"}, {"sha": "f6ebebca8efeff22f6b1ff882c30608ab90439b8", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1009,7 +1009,7 @@ emit_stack_save (save_level, psave, after)\n       if (sa != 0)\n \tsa = validize_mem (sa);\n       emit_insn (fcn (sa, stack_pointer_rtx));\n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n       emit_insn_after (seq, after);\n     }\n@@ -1070,7 +1070,7 @@ emit_stack_restore (save_level, sa, after)\n \n       start_sequence ();\n       emit_insn (fcn (stack_pointer_rtx, sa));\n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n       emit_insn_after (seq, after);\n     }"}, {"sha": "dc36708952de04448f6a39b717c0439e11298e2b", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -474,13 +474,29 @@ emit_queue ()\n     {\n       rtx body = QUEUED_BODY (p);\n \n-      if (GET_CODE (body) == SEQUENCE)\n-\t{\n-\t  QUEUED_INSN (p) = XVECEXP (QUEUED_BODY (p), 0, 0);\n-\t  emit_insn (QUEUED_BODY (p));\n+      switch (GET_CODE (body))\n+\t{\n+\tcase INSN:\n+\tcase JUMP_INSN:\n+\tcase CALL_INSN:\n+\tcase CODE_LABEL:\n+\tcase BARRIER:\n+\tcase NOTE:\n+\t  QUEUED_INSN (p) = body;\n+\t  emit_insn (body);\n+\t  break;\n+\n+#ifdef ENABLE_CHECKING\n+\tcase SEQUENCE:\n+\t  abort ();\n+\t  break;\n+#endif\n+\n+\tdefault:\n+\t  QUEUED_INSN (p) = emit_insn (body);\n+\t  break;\n \t}\n-      else\n-\tQUEUED_INSN (p) = emit_insn (QUEUED_BODY (p));\n+\n       pending_chain = QUEUED_NEXT (p);\n     }\n }\n@@ -3114,7 +3130,7 @@ emit_move_insn_1 (x, y)\n \t  last_insn = emit_move_insn (xpart, ypart);\n \t}\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       /* Show the output dies here.  This is necessary for SUBREGs\n@@ -6719,7 +6735,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  if (RTL_EXPR_SEQUENCE (exp) == const0_rtx)\n \t    abort ();\n-\t  emit_insns (RTL_EXPR_SEQUENCE (exp));\n+\t  emit_insn (RTL_EXPR_SEQUENCE (exp));\n \t  RTL_EXPR_SEQUENCE (exp) = const0_rtx;\n \t}\n       preserve_rtl_expr_result (RTL_EXPR_RTL (exp));\n@@ -8859,7 +8875,7 @@ expand_expr (exp, target, tmode, modifier)\n \tif (GET_CODE (target) != CONCAT)\n \t  emit_no_conflict_block (insns, target, op0, op1, NULL_RTX);\n \telse\n-\t  emit_insns (insns);\n+\t  emit_insn (insns);\n \n \treturn target;\n       }\n@@ -8908,7 +8924,7 @@ expand_expr (exp, target, tmode, modifier)\n \tif (GET_CODE (target) != CONCAT)\n \t  emit_no_conflict_block (insns, target, op0, NULL_RTX, NULL_RTX);\n \telse\n-\t  emit_insns (insns);\n+\t  emit_insn (insns);\n \n \treturn target;\n       }"}, {"sha": "48016cef781a911071bf4acfb0db91cd883ad6fd", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -3345,7 +3345,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n \n       /* We now know we'll be doing this change, so emit the\n \t new insn(s) and do the updates.  */\n-      emit_insns_before (insns, insn);\n+      emit_insn_before (insns, insn);\n \n       if (pbi->bb->head == insn)\n \tpbi->bb->head = insns;"}, {"sha": "56c66c6f8db0dabce52ca12f71adf5141af51d87", "filename": "gcc/function.c", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1867,7 +1867,7 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n \t\t  start_sequence ();\n \t\t  convert_move (replacements->new,\n \t\t\t\treplacements->old, unsignedp);\n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t}\n \t      else\n@@ -1949,7 +1949,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \n \t      start_sequence ();\n \t      new_insn = emit_insn (gen_rtx_SET (VOIDmode, y, sub));\n-\t      seq = gen_sequence ();\n+\t      seq = get_insns ();\n \t      end_sequence ();\n \n \t      if (recog_memoized (new_insn) < 0)\n@@ -1960,7 +1960,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t\t  sub = force_operand (sub, y);\n \t\t  if (sub != y)\n \t\t    emit_insn (gen_move_insn (y, sub));\n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t}\n \n@@ -2390,7 +2390,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t       no other function that to do X.  */\n \n \t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n-\t    if (GET_CODE (pat) == SEQUENCE)\n+\t    if (NEXT_INSN (pat) != NULL_RTX)\n \t      {\n \t\tlast = emit_insn_before (pat, insn);\n \n@@ -2408,7 +2408,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t\tdelete_insn (last);\n \t      }\n \t    else\n-\t      PATTERN (insn) = pat;\n+\t      PATTERN (insn) = PATTERN (pat);\n \n \t    return;\n \t  }\n@@ -2434,7 +2434,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t      return;\n \n \t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n-\t    if (GET_CODE (pat) == SEQUENCE)\n+\t    if (NEXT_INSN (pat) != NULL_RTX)\n \t      {\n \t\tlast = emit_insn_before (pat, insn);\n \n@@ -2452,7 +2452,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t\tdelete_insn (last);\n \t      }\n \t    else\n-\t      PATTERN (insn) = pat;\n+\t      PATTERN (insn) = PATTERN (pat);\n \n \t    return;\n \t  }\n@@ -2543,7 +2543,7 @@ fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n   rtx mem = SUBREG_REG (x);\n   rtx addr = XEXP (mem, 0);\n   enum machine_mode mode = GET_MODE (x);\n-  rtx result;\n+  rtx result, seq;\n \n   /* Paradoxical SUBREGs are usually invalid during RTL generation.  */\n   if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (mem)) && ! uncritical)\n@@ -2563,8 +2563,10 @@ fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n \n   start_sequence ();\n   result = adjust_address (mem, mode, offset);\n-  emit_insn_before (gen_sequence (), insn);\n+  seq = get_insns ();\n   end_sequence ();\n+\n+  emit_insn_before (seq, insn);\n   return result;\n }\n \n@@ -2654,7 +2656,7 @@ fixup_stack_1 (x, insn)\n \n \t  start_sequence ();\n \t  temp = copy_to_reg (ad);\n-\t  seq = gen_sequence ();\n+\t  seq = get_insns ();\n \t  end_sequence ();\n \t  emit_insn_before (seq, insn);\n \t  return replace_equiv_address (x, temp);\n@@ -2765,7 +2767,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t  memref = adjust_address (memref, mode, offset);\n \t  insns = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns_before (insns, insn);\n+\t  emit_insn_before (insns, insn);\n \n \t  /* Store this memory reference where\n \t     we found the bit field reference.  */\n@@ -2833,7 +2835,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t     special; just let the optimization be suppressed.  */\n \n \t  if (apply_change_group () && seq)\n-\t    emit_insns_before (seq, insn);\n+\t    emit_insn_before (seq, insn);\n \t}\n     }\n }\n@@ -3066,7 +3068,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t  && ! validate_replace_rtx (x, sub, insn))\n \tabort ();\n \n-      insns = gen_sequence ();\n+      insns = get_insns ();\n       end_sequence ();\n       emit_insn_before (insns, insn);\n       return true;\n@@ -3177,7 +3179,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t      end_sequence ();\n \t\t      goto give_up;\n \t\t    }\n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, insn);\n \t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n@@ -3191,7 +3193,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t     might have created.  */\n \t\t  unshare_all_rtl_again (get_insns ());\n \n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t  p = emit_insn_after (seq, insn);\n \t\t  if (NEXT_INSN (insn))\n@@ -3216,7 +3218,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t      goto give_up;\n \t\t    }\n \n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, insn);\n \t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n@@ -3821,7 +3823,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_insns_before (seq, object);\n+\t  emit_insn_before (seq, object);\n \t  SET_DEST (x) = new;\n \n \t  if (! validate_change (object, &SET_SRC (x), temp, 0)\n@@ -3933,7 +3935,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \n-\t\t  emit_insns_before (seq, object);\n+\t\t  emit_insn_before (seq, object);\n \t\t  if (! validate_change (object, loc, temp, 0)\n \t\t      && ! validate_replace_rtx (x, temp, object))\n \t\t    abort ();\n@@ -4087,7 +4089,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t      seq = get_insns ();\n \t      end_sequence ();\n \n-\t      emit_insns_before (seq, object);\n+\t      emit_insn_before (seq, object);\n \t      if (! validate_change (object, loc, temp, 0)\n \t\t  && ! validate_replace_rtx (x, temp, object))\n \t\tabort ();\n@@ -5084,7 +5086,7 @@ assign_parms (fndecl)\n \n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */\n-  emit_insns (conversion_insns);\n+  emit_insn (conversion_insns);\n \n   last_parm_insn = get_last_insn ();\n \n@@ -6422,7 +6424,7 @@ expand_main_function ()\n       /* Enlist allocate_dynamic_stack_space to pick up the pieces.  */\n       tmp = force_reg (Pmode, const0_rtx);\n       allocate_dynamic_stack_space (tmp, NULL_RTX, BIGGEST_ALIGNMENT);\n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       for (tmp = get_last_insn (); tmp; tmp = PREV_INSN (tmp))\n@@ -6843,7 +6845,7 @@ expand_function_end (filename, line, end_bindings)\n       end_sequence ();\n \n       /* Put those insns at entry to the containing function (this one).  */\n-      emit_insns_before (seq, tail_recursion_reentry);\n+      emit_insn_before (seq, tail_recursion_reentry);\n     }\n \n   /* If we are doing stack checking and this function makes calls,\n@@ -6861,7 +6863,7 @@ expand_function_end (filename, line, end_bindings)\n \t\t\t       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));\n \t    seq = get_insns ();\n \t    end_sequence ();\n-\t    emit_insns_before (seq, tail_recursion_reentry);\n+\t    emit_insn_before (seq, tail_recursion_reentry);\n \t    break;\n \t  }\n     }\n@@ -7067,7 +7069,7 @@ expand_function_end (filename, line, end_bindings)\n \n     start_sequence ();\n     clobber_return_register ();\n-    seq = gen_sequence ();\n+    seq = get_insns ();\n     end_sequence ();\n \n     after = emit_insn_after (seq, clobber_after);\n@@ -7113,7 +7115,7 @@ get_arg_pointer_save_area (f)\n \t have to check it and fix it if necessary.  */\n       start_sequence ();\n       emit_move_insn (validize_mem (ret), virtual_incoming_args_rtx);\n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       push_topmost_sequence ();\n@@ -7124,35 +7126,38 @@ get_arg_pointer_save_area (f)\n   return ret;\n }\n \f\n-/* Extend a vector that records the INSN_UIDs of INSNS (either a\n-   sequence or a single insn).  */\n+/* Extend a vector that records the INSN_UIDs of INSNS\n+   (a list of one or more insns).  */\n \n static void\n record_insns (insns, vecp)\n      rtx insns;\n      varray_type *vecp;\n {\n-  if (GET_CODE (insns) == SEQUENCE)\n-    {\n-      int len = XVECLEN (insns, 0);\n-      int i = VARRAY_SIZE (*vecp);\n+  int i, len;\n+  rtx tmp;\n \n-      VARRAY_GROW (*vecp, i + len);\n-      while (--len >= 0)\n-\t{\n-\t  VARRAY_INT (*vecp, i) = INSN_UID (XVECEXP (insns, 0, len));\n-\t  ++i;\n-\t}\n+  tmp = insns;\n+  len = 0;\n+  while (tmp != NULL_RTX)\n+    {\n+      len++;\n+      tmp = NEXT_INSN (tmp);\n     }\n-  else\n+\n+  i = VARRAY_SIZE (*vecp);\n+  VARRAY_GROW (*vecp, i + len);\n+  tmp = insns;\n+  while (tmp != NULL_RTX)\n     {\n-      int i = VARRAY_SIZE (*vecp);\n-      VARRAY_GROW (*vecp, i + 1);\n-      VARRAY_INT (*vecp, i) = INSN_UID (insns);\n+      VARRAY_INT (*vecp, i) = INSN_UID (tmp);\n+      i++;\n+      tmp = NEXT_INSN (tmp);\n     }\n }\n \n-/* Determine how many INSN_UIDs in VEC are part of INSN.  */\n+/* Determine how many INSN_UIDs in VEC are part of INSN.  Because we can\n+   be running after reorg, SEQUENCE rtl is possible.  */\n \n static int\n contains (insn, vec)\n@@ -7264,20 +7269,21 @@ struct epi_info\n static void handle_epilogue_set PARAMS ((rtx, struct epi_info *));\n static void emit_equiv_load PARAMS ((struct epi_info *));\n \n-/* Modify SEQ, a SEQUENCE that is part of the epilogue, to no modifications\n-   to the stack pointer.  Return the new sequence.  */\n+/* Modify INSN, a list of one or more insns that is part of the epilogue, to\n+   no modifications to the stack pointer.  Return the new list of insns.  */\n \n static rtx\n-keep_stack_depressed (seq)\n-     rtx seq;\n+keep_stack_depressed (insns)\n+     rtx insns;\n {\n-  int i, j;\n+  int j;\n   struct epi_info info;\n+  rtx insn, next;\n \n   /* If the epilogue is just a single instruction, it ust be OK as is.  */\n \n-  if (GET_CODE (seq) != SEQUENCE)\n-    return seq;\n+  if (NEXT_INSN (insns) == NULL_RTX)\n+    return insns;\n \n   /* Otherwise, start a sequence, initialize the information we have, and\n      process all the insns we were given.  */\n@@ -7287,13 +7293,16 @@ keep_stack_depressed (seq)\n   info.sp_offset = 0;\n   info.equiv_reg_src = 0;\n \n-  for (i = 0; i < XVECLEN (seq, 0); i++)\n+  insn = insns;\n+  next = NULL_RTX;\n+  while (insn != NULL_RTX)\n     {\n-      rtx insn = XVECEXP (seq, 0, i);\n+      next = NEXT_INSN (insn);\n \n       if (!INSN_P (insn))\n \t{\n \t  add_insn (insn);\n+\t  insn = next;\n \t  continue;\n \t}\n \n@@ -7329,6 +7338,7 @@ keep_stack_depressed (seq)\n \t    {\n \t      emit_equiv_load (&info);\n \t      add_insn (insn);\n+\t      insn = next;\n \t      continue;\n \t    }\n \t  else if (GET_CODE (retaddr) == MEM\n@@ -7429,11 +7439,13 @@ keep_stack_depressed (seq)\n \n       info.sp_equiv_reg = info.new_sp_equiv_reg;\n       info.sp_offset = info.new_sp_offset;\n+\n+      insn = next;\n     }\n \n-  seq = gen_sequence ();\n+  insns = get_insns ();\n   end_sequence ();\n-  return seq;\n+  return insns;\n }\n \n /* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info\n@@ -7548,12 +7560,10 @@ thread_prologue_and_epilogue_insns (f)\n       emit_insn (seq);\n \n       /* Retain a map of the prologue insns.  */\n-      if (GET_CODE (seq) != SEQUENCE)\n-\tseq = get_insns ();\n       record_insns (seq, &prologue);\n       prologue_end = emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       /* Can't deal with multiple successors of the entry block\n@@ -7712,11 +7722,9 @@ thread_prologue_and_epilogue_insns (f)\n       emit_jump_insn (seq);\n \n       /* Retain a map of the epilogue insns.  */\n-      if (GET_CODE (seq) != SEQUENCE)\n-\tseq = get_insns ();\n       record_insns (seq, &epilogue);\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       insert_insn_on_edge (seq, e);\n@@ -7745,13 +7753,13 @@ thread_prologue_and_epilogue_insns (f)\n       seq = gen_sibcall_epilogue ();\n       end_sequence ();\n \n+      /* Retain a map of the epilogue insns.  Used in life analysis to\n+\t avoid getting rid of sibcall epilogue insns.  Do this before we\n+\t actually emit the sequence.  */\n+      record_insns (seq, &sibcall_epilogue);\n+\n       i = PREV_INSN (insn);\n       newinsn = emit_insn_before (seq, insn);\n-\n-      /* Retain a map of the epilogue insns.  Used in life analysis to\n-\t avoid getting rid of sibcall epilogue insns.  */\n-      record_insns (GET_CODE (seq) == SEQUENCE\n-\t\t    ? seq : newinsn, &sibcall_epilogue);\n     }\n #endif\n "}, {"sha": "28b7264751ae34bce9e994c1552df03d0dad73df", "filename": "gcc/gcse.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -4819,7 +4819,7 @@ process_insert_insn (expr)\n   else if (insn_invalid_p (emit_insn (gen_rtx_SET (VOIDmode, reg, exp))))\n     abort ();\n \n-  pat = gen_sequence ();\n+  pat = get_insns ();\n   end_sequence ();\n \n   return pat;\n@@ -4843,10 +4843,15 @@ insert_insn_end_bb (expr, bb, pre)\n   rtx new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n-  rtx pat;\n-  int i;\n+  rtx pat, pat_end;\n \n   pat = process_insert_insn (expr);\n+  if (pat == NULL_RTX || ! INSN_P (pat))\n+    abort ();\n+\n+  pat_end = pat;\n+  while (NEXT_INSN (pat_end) != NULL_RTX)\n+    pat_end = NEXT_INSN (pat_end);\n \n   /* If the last insn is a jump, insert EXPR in front [taking care to\n      handle cc0, etc. properly].  Similary we need to care trapping\n@@ -4934,26 +4939,16 @@ insert_insn_end_bb (expr, bb, pre)\n   else\n     new_insn = emit_insn_after (pat, insn);\n \n-  /* Keep block number table up to date.\n-     Note, PAT could be a multiple insn sequence, we have to make\n-     sure that each insn in the sequence is handled.  */\n-  if (GET_CODE (pat) == SEQUENCE)\n+  while (1)\n     {\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n+      if (INSN_P (pat))\n \t{\n-\t  rtx insn = XVECEXP (pat, 0, i);\n-\t  if (INSN_P (insn))\n-\t    add_label_notes (PATTERN (insn), new_insn);\n-\n-\t  note_stores (PATTERN (insn), record_set_info, insn);\n+\t  add_label_notes (PATTERN (pat), new_insn);\n+\t  note_stores (PATTERN (pat), record_set_info, pat);\n \t}\n-    }\n-  else\n-    {\n-      add_label_notes (pat, new_insn);\n-\n-      /* Keep register set table up to date.  */\n-      record_one_set (regno, new_insn);\n+      if (pat == pat_end)\n+\tbreak;\n+      pat = NEXT_INSN (pat);\n     }\n \n   gcse_create_count++;"}, {"sha": "71c5957214bb3aa4603b582ed4d3a7f1c37a033d", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -6183,6 +6183,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"insn-attr.h\\\"\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\");\n   printf (\"#include \\\"flags.h\\\"\\n\");\n+  printf (\"#include \\\"function.h\\\"\\n\");\n   printf (\"\\n\");\n   printf (\"#define operands recog_data.operand\\n\\n\");\n "}, {"sha": "93425ad35699ecf9cecc0dea356367df6d834e8d", "filename": "gcc/genemit.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -555,15 +555,15 @@ gen_expand (expand)\n \tprintf (\"  emit_barrier ();\");\n     }\n \n-  /* Call `gen_sequence' to make a SEQUENCE out of all the\n+  /* Call `get_insns' to extract the list of all the\n      insns emitted within this gen_... function.  */\n \n-  printf (\"  _val = gen_sequence ();\\n\");\n+  printf (\"  _val = get_insns ();\\n\");\n   printf (\"  end_sequence ();\\n\");\n   printf (\"  return _val;\\n}\\n\\n\");\n }\n \n-/* Like gen_expand, but generates a SEQUENCE.  */\n+/* Like gen_expand, but generates insns resulting from splitting SPLIT.  */\n \n static void\n gen_split (split)\n@@ -667,10 +667,10 @@ gen_split (split)\n \tprintf (\"  emit_barrier ();\");\n     }\n \n-  /* Call `gen_sequence' to make a SEQUENCE out of all the\n+  /* Call `get_insns' to make a list of all the\n      insns emitted within this gen_... function.  */\n \n-  printf (\"  _val = gen_sequence ();\\n\");\n+  printf (\"  _val = get_insns ();\\n\");\n   printf (\"  end_sequence ();\\n\");\n   printf (\"  return _val;\\n}\\n\\n\");\n \n@@ -841,7 +841,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\");\n   printf (\"#include \\\"ggc.h\\\"\\n\\n\");\n   printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n-  printf (\"#define DONE return (_val = gen_sequence (), end_sequence (), _val)\\n\\n\");\n+  printf (\"#define DONE return (_val = get_insns (), end_sequence (), _val)\\n\\n\");\n \n   /* Read the machine description.  */\n "}, {"sha": "30fee047e4a3cc3d8363e3286c009425d32436c8", "filename": "gcc/genrecog.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -43,11 +43,11 @@\n \n    This program also generates the function `split_insns', which\n    returns 0 if the rtl could not be split, or it returns the split\n-   rtl in a SEQUENCE.\n+   rtl as an INSN list.\n \n    This program also generates the function `peephole2_insns', which\n    returns 0 if the rtl could not be matched.  If there was a match,\n-   the new rtl is returned in a SEQUENCE, and LAST_INSN will point\n+   the new rtl is returned in an INSN list, and LAST_INSN will point\n    to the last recognized insn in the old sequence.  */\n \n #include \"hconfig.h\"\n@@ -2431,10 +2431,10 @@ write_header ()\n \n   puts (\"\\n\\\n    The function split_insns returns 0 if the rtl could not\\n\\\n-   be split or the split rtl in a SEQUENCE if it can be.\\n\\\n+   be split or the split rtl as an INSN list if it can be.\\n\\\n \\n\\\n    The function peephole2_insns returns 0 if the rtl could not\\n\\\n-   be matched. If there was a match, the new rtl is returned in a SEQUENCE,\\n\\\n+   be matched. If there was a match, the new rtl is returned in an INSN list,\\n\\\n    and LAST_INSN will point to the last recognized insn in the old sequence.\\n\\\n */\\n\\n\");\n }"}, {"sha": "bd9d7da7d8efafe49abcb2fcafe38421974d743e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -532,7 +532,7 @@ noce_emit_store_flag (if_info, x, reversep, normalize)\n \t{\n \t  tmp = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns (tmp);\n+\t  emit_insn (tmp);\n \n \t  if_info->cond_earliest = if_info->jump;\n \n@@ -612,7 +612,7 @@ noce_try_store_flag (if_info)\n \n       seq = get_insns ();\n       end_sequence ();\n-      emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+      emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -747,7 +747,7 @@ noce_try_store_flag_constants (if_info)\n       if (seq_contains_jump (seq))\n \treturn FALSE;\n \n-      emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+      emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -807,8 +807,8 @@ noce_try_store_flag_inc (if_info)\n \t  if (seq_contains_jump (seq))\n \t    return FALSE;\n \n-\t  emit_insns_before_scope (seq, if_info->jump,\n-\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n+\t  emit_insn_before_scope (seq, if_info->jump,\n+\t\t\t\t  INSN_SCOPE (if_info->insn_a));\n \n \t  return TRUE;\n \t}\n@@ -860,8 +860,8 @@ noce_try_store_flag_mask (if_info)\n \t  if (seq_contains_jump (seq))\n \t    return FALSE;\n \n-\t  emit_insns_before_scope (seq, if_info->jump,\n-\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n+\t  emit_insn_before_scope (seq, if_info->jump,\n+\t\t\t\t  INSN_SCOPE (if_info->insn_a));\n \n \t  return TRUE;\n \t}\n@@ -900,7 +900,7 @@ noce_emit_cmove (if_info, x, code, cmp_a, cmp_b, vfalse, vtrue)\n \t{\n \t  tmp = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns (tmp);\n+\t  emit_insn (tmp);\n \n \t  return x;\n \t}\n@@ -956,8 +956,8 @@ noce_try_cmove (if_info)\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_insns_before_scope (seq, if_info->jump,\n-\t\t\t  \t   INSN_SCOPE (if_info->insn_a));\n+\t  emit_insn_before_scope (seq, if_info->jump,\n+\t\t\t\t  INSN_SCOPE (if_info->insn_a));\n \t  return TRUE;\n \t}\n       else\n@@ -1119,7 +1119,7 @@ noce_try_cmove_arith (if_info)\n \n   tmp = get_insns ();\n   end_sequence ();\n-  emit_insns_before_scope (tmp, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_scope (tmp, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   return TRUE;\n \n  end_seq_and_fail:\n@@ -1371,7 +1371,7 @@ noce_try_minmax (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1489,7 +1489,7 @@ noce_try_abs (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insns_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1758,7 +1758,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n     {\n       start_sequence ();\n       noce_emit_move_insn (copy_rtx (orig_x), x);\n-      insn_b = gen_sequence ();\n+      insn_b = get_insns ();\n       end_sequence ();\n \n       emit_insn_after_scope (insn_b, test_bb->end, INSN_SCOPE (insn_a));"}, {"sha": "4bbfcea42fcf53fed4bbbb8a10366514c7d579f4", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1942,7 +1942,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \n \t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n \n-\t      seq = gen_sequence ();\n+\t      seq = get_insns ();\n \t      end_sequence ();\n \t      emit_insn_after (seq, map->insns_at_start);\n \t      return temp;\n@@ -1975,7 +1975,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \n \t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n \n-\t      seq = gen_sequence ();\n+\t      seq = get_insns ();\n \t      end_sequence ();\n \t      emit_insn_after (seq, map->insns_at_start);\n \t      return temp;\n@@ -3128,7 +3128,7 @@ emit_initial_value_sets ()\n   seq = get_insns ();\n   end_sequence ();\n \n-  emit_insns_after (seq, get_insns ());\n+  emit_insn_after (seq, get_insns ());\n }\n \n /* If the backend knows where to allocate pseudos for hard"}, {"sha": "3b9dc616065979390b56a4a90143a7965d351f04", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1540,7 +1540,9 @@ delete_prior_computation (note, insn)\n \tbreak;\n \n       /* If we reach a SEQUENCE, it is too complex to try to\n-\t do anything with it, so give up.  */\n+\t do anything with it, so give up.  We can be run during\n+\t and after reorg, so SEQUENCE rtl can legitimately show\n+\t up here.  */\n       if (GET_CODE (pat) == SEQUENCE)\n \tbreak;\n "}, {"sha": "bdbae429d4d088105f66c255b8a528a882536da8", "filename": "gcc/lcm.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1228,12 +1228,11 @@ optimize_mode_switching (file)\n \n \t      start_sequence ();\n \t      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);\n-\t      mode_set = gen_sequence ();\n+\t      mode_set = get_insns ();\n \t      end_sequence ();\n \n \t      /* Do not bother to insert empty sequence.  */\n-\t      if (GET_CODE (mode_set) == SEQUENCE\n-\t\t  && !XVECLEN (mode_set, 0))\n+\t      if (mode_set == NULL_RTX)\n \t\tcontinue;\n \n \t      /* If this is an abnormal edge, we'll insert at the end\n@@ -1298,12 +1297,11 @@ optimize_mode_switching (file)\n \n \t\t  start_sequence ();\n \t\t  EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);\n-\t\t  mode_set = gen_sequence ();\n+\t\t  mode_set = get_insns ();\n \t\t  end_sequence ();\n \n \t\t  /* Do not bother to insert empty sequence.  */\n-\t\t  if (GET_CODE (mode_set) == SEQUENCE\n-\t\t      && !XVECLEN (mode_set, 0))\n+\t\t  if (mode_set == NULL_RTX)\n \t\t    continue;\n \n \t\t  emited = true;"}, {"sha": "ba93c33dcd67ec0298e5ffaa161b3c2451694b30", "filename": "gcc/loop.c", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1949,11 +1949,10 @@ move_movables (loop, movables, threshold, insn_count)\n \n \t\t  start_sequence ();\n \t\t  emit_move_insn (m->set_dest, m->set_src);\n-\t\t  temp = get_insns ();\n-\t\t  seq = gen_sequence ();\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \n-\t\t  add_label_notes (m->set_src, temp);\n+\t\t  add_label_notes (m->set_src, seq);\n \n \t\t  i1 = loop_insn_hoist (loop, seq);\n \t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n@@ -2088,7 +2087,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t    abort ();\n \t\t\t  if (tem != reg)\n \t\t\t    emit_move_insn (reg, tem);\n-\t\t\t  sequence = gen_sequence ();\n+\t\t\t  sequence = get_insns ();\n \t\t\t  end_sequence ();\n \t\t\t  i1 = loop_insn_hoist (loop, sequence);\n \t\t\t}\n@@ -2109,11 +2108,10 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t     use the REG_EQUAL note.  */\n \t\t\t  start_sequence ();\n \t\t\t  emit_move_insn (m->set_dest, m->set_src);\n-\t\t\t  temp = get_insns ();\n-\t\t\t  seq = gen_sequence ();\n+\t\t\t  seq = get_insns ();\n \t\t\t  end_sequence ();\n \n-\t\t\t  add_label_notes (m->set_src, temp);\n+\t\t\t  add_label_notes (m->set_src, seq);\n \n \t\t\t  i1 = loop_insn_hoist (loop, seq);\n \t\t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n@@ -4154,7 +4152,7 @@ emit_prefetch_instructions (loop)\n \t    loc = force_reg (Pmode, loc);\n \t  emit_insn (gen_prefetch (loc, GEN_INT (info[i].write),\n \t\t\t\t   GEN_INT (3)));\n-\t  seq = gen_sequence ();\n+\t  seq = get_insns ();\n \t  end_sequence ();\n \t  emit_insn_before (seq, before_insn);\n \n@@ -7735,7 +7733,7 @@ gen_add_mult (b, m, a, reg)\n   result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 1);\n   if (reg != result)\n     emit_move_insn (reg, result);\n-  seq = gen_sequence ();\n+  seq = get_insns ();\n   end_sequence ();\n \n   return seq;\n@@ -7749,24 +7747,29 @@ loop_regs_update (loop, seq)\n      const struct loop *loop ATTRIBUTE_UNUSED;\n      rtx seq;\n {\n+  rtx insn;\n+\n   /* Update register info for alias analysis.  */\n \n-  if (GET_CODE (seq) == SEQUENCE)\n+  if (seq == NULL_RTX)\n+    return;\n+\n+  if (INSN_P (seq))\n     {\n-      int i;\n-      for (i = 0; i < XVECLEN (seq, 0); ++i)\n+      insn = seq;\n+      while (insn != NULL_RTX)\n \t{\n-\t  rtx set = single_set (XVECEXP (seq, 0, i));\n+\t  rtx set = single_set (insn);\n+\n \t  if (set && GET_CODE (SET_DEST (set)) == REG)\n \t    record_base_value (REGNO (SET_DEST (set)), SET_SRC (set), 0);\n+\n+\t  insn = NEXT_INSN (insn);\n \t}\n     }\n-  else\n-    {\n-      if (GET_CODE (seq) == SET\n-\t  && GET_CODE (SET_DEST (seq)) == REG)\n-\trecord_base_value (REGNO (SET_DEST (seq)), SET_SRC (seq), 0);\n-    }\n+  else if (GET_CODE (seq) == SET\n+\t   && GET_CODE (SET_DEST (seq)) == REG)\n+    record_base_value (REGNO (SET_DEST (seq)), SET_SRC (seq), 0);\n }\n \n \n@@ -7889,16 +7892,20 @@ iv_add_mult_cost (b, m, a, reg)\n }\n \f\n /* Test whether A * B can be computed without\n-   an actual multiply insn.  Value is 1 if so.  */\n+   an actual multiply insn.  Value is 1 if so.\n+\n+  ??? This function stinks because it generates a ton of wasted RTL\n+  ??? and as a result fragments GC memory to no end.  There are other\n+  ??? places in the compiler which are invoked a lot and do the same\n+  ??? thing, generate wasted RTL just to see if something is possible.  */\n \n static int\n product_cheap_p (a, b)\n      rtx a;\n      rtx b;\n {\n-  int i;\n   rtx tmp;\n-  int win = 1;\n+  int win, n_insns;\n \n   /* If only one is constant, make it B.  */\n   if (GET_CODE (a) == CONST_INT)\n@@ -7918,31 +7925,31 @@ product_cheap_p (a, b)\n \n   start_sequence ();\n   expand_mult (GET_MODE (a), a, b, NULL_RTX, 1);\n-  tmp = gen_sequence ();\n+  tmp = get_insns ();\n   end_sequence ();\n \n-  if (GET_CODE (tmp) == SEQUENCE)\n+  win = 1;\n+  if (INSN_P (tmp))\n     {\n-      if (XVEC (tmp, 0) == 0)\n-\twin = 1;\n-      else if (XVECLEN (tmp, 0) > 3)\n-\twin = 0;\n-      else\n-\tfor (i = 0; i < XVECLEN (tmp, 0); i++)\n-\t  {\n-\t    rtx insn = XVECEXP (tmp, 0, i);\n-\n-\t    if (GET_CODE (insn) != INSN\n-\t\t|| (GET_CODE (PATTERN (insn)) == SET\n-\t\t    && GET_CODE (SET_SRC (PATTERN (insn))) == MULT)\n-\t\t|| (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET\n-\t\t    && GET_CODE (SET_SRC (XVECEXP (PATTERN (insn), 0, 0))) == MULT))\n-\t      {\n-\t\twin = 0;\n-\t\tbreak;\n-\t      }\n-\t  }\n+      n_insns = 0;\n+      while (tmp != NULL_RTX)\n+\t{\n+\t  rtx next = NEXT_INSN (tmp);\n+\n+\t  if (++n_insns > 3\n+\t      || GET_CODE (tmp) != INSN\n+\t      || (GET_CODE (PATTERN (tmp)) == SET\n+\t\t  && GET_CODE (SET_SRC (PATTERN (tmp))) == MULT)\n+\t      || (GET_CODE (PATTERN (tmp)) == PARALLEL\n+\t\t  && GET_CODE (XVECEXP (PATTERN (tmp), 0, 0)) == SET\n+\t\t  && GET_CODE (SET_SRC (XVECEXP (PATTERN (tmp), 0, 0))) == MULT))\n+\t    {\n+\t      win = 0;\n+\t      break;\n+\t    }\n+\n+\t  tmp = next;\n+\t}\n     }\n   else if (GET_CODE (tmp) == SET\n \t   && GET_CODE (SET_SRC (tmp)) == MULT)\n@@ -8433,7 +8440,7 @@ check_dbra_loop (loop, insn_count)\n \t\t create a sequence to hold all the insns from expand_inc.  */\n \t      start_sequence ();\n \t      expand_inc (reg, new_add_val);\n-\t      tem = gen_sequence ();\n+\t      tem = get_insns ();\n \t      end_sequence ();\n \n \t      p = loop_insn_emit_before (loop, 0, bl->biv->insn, tem);\n@@ -8474,7 +8481,7 @@ check_dbra_loop (loop, insn_count)\n \t      emit_cmp_and_jump_insns (reg, const0_rtx, cmp_code, NULL_RTX,\n \t\t\t\t       GET_MODE (reg), 0,\n \t\t\t\t       XEXP (jump_label, 0));\n-\t      tem = gen_sequence ();\n+\t      tem = get_insns ();\n \t      end_sequence ();\n \t      emit_jump_insn_before (tem, loop_end);\n \n@@ -10492,7 +10499,7 @@ gen_load_of_final_value (reg, final_value)\n   final_value = force_operand (final_value, reg);\n   if (final_value != reg)\n     emit_move_insn (reg, final_value);\n-  seq = gen_sequence ();\n+  seq = get_insns ();\n   end_sequence ();\n   return seq;\n }"}, {"sha": "88cdf2f8b9cb2d1d26ddd4a87d7539fe751e2bd5", "filename": "gcc/optabs.c", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -121,7 +121,7 @@ static void emit_cmp_and_jump_insn_1 PARAMS ((rtx, rtx, enum machine_mode,\n static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n \t\t\t\t\t enum machine_mode *, int *));\n \f\n-/* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to\n+/* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n    operation).\n \n@@ -132,43 +132,65 @@ static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n    again, ensuring that TARGET is not one of the operands.  */\n \n static int\n-add_equal_note (seq, target, code, op0, op1)\n-     rtx seq;\n+add_equal_note (insns, target, code, op0, op1)\n+     rtx insns;\n      rtx target;\n      enum rtx_code code;\n      rtx op0, op1;\n {\n-  rtx set;\n-  int i;\n+  rtx last_insn, insn, set;\n   rtx note;\n \n-  if ((GET_RTX_CLASS (code) != '1' && GET_RTX_CLASS (code) != '2'\n-       && GET_RTX_CLASS (code) != 'c' && GET_RTX_CLASS (code) != '<')\n-      || GET_CODE (seq) != SEQUENCE\n-      || (set = single_set (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1))) == 0\n-      || GET_CODE (target) == ZERO_EXTRACT\n-      || (! rtx_equal_p (SET_DEST (set), target)\n-\t  /* For a STRICT_LOW_PART, the REG_NOTE applies to what is inside the\n-\t     SUBREG.  */\n-\t  && (GET_CODE (SET_DEST (set)) != STRICT_LOW_PART\n-\t      || ! rtx_equal_p (SUBREG_REG (XEXP (SET_DEST (set), 0)),\n-\t\t\t\ttarget))))\n+  if (! insns\n+      || ! INSN_P (insns)\n+      || NEXT_INSN (insns) == NULL_RTX)\n+    abort ();\n+\n+  if (GET_RTX_CLASS (code) != '1' && GET_RTX_CLASS (code) != '2'\n+      && GET_RTX_CLASS (code) != 'c' && GET_RTX_CLASS (code) != '<')\n+    return 1;\n+\n+  if (GET_CODE (target) == ZERO_EXTRACT)\n+    return 1;\n+\n+  for (last_insn = insns;\n+       NEXT_INSN (last_insn) != NULL_RTX;\n+       last_insn = NEXT_INSN (last_insn))\n+    ;\n+\n+  set = single_set (last_insn);\n+  if (set == NULL_RTX)\n+    return 1;\n+\n+  if (! rtx_equal_p (SET_DEST (set), target)\n+      /* For a STRICT_LOW_PART, the REG_NOTE applies to what is inside the\n+\t SUBREG.  */\n+      && (GET_CODE (SET_DEST (set)) != STRICT_LOW_PART\n+\t  || ! rtx_equal_p (SUBREG_REG (XEXP (SET_DEST (set), 0)),\n+\t\t\t    target)))\n     return 1;\n \n   /* If TARGET is in OP0 or OP1, check if anything in SEQ sets TARGET\n      besides the last insn.  */\n   if (reg_overlap_mentioned_p (target, op0)\n       || (op1 && reg_overlap_mentioned_p (target, op1)))\n-    for (i = XVECLEN (seq, 0) - 2; i >= 0; i--)\n-      if (reg_set_p (target, XVECEXP (seq, 0, i)))\n-\treturn 0;\n+    {\n+      insn = PREV_INSN (last_insn);\n+      while (insn != NULL_RTX)\n+\t{\n+\t  if (reg_set_p (target, insn))\n+\t    return 0;\n+\n+\t  insn = PREV_INSN (insn);\n+\t}\n+    }\n \n   if (GET_RTX_CLASS (code) == '1')\n     note = gen_rtx_fmt_e (code, GET_MODE (target), copy_rtx (op0));\n   else\n     note = gen_rtx_fmt_ee (code, GET_MODE (target), copy_rtx (op0), copy_rtx (op1));\n \n-  set_unique_reg_note (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1), REG_EQUAL, note);\n+  set_unique_reg_note (last_insn, REG_EQUAL, note);\n \n   return 1;\n }\n@@ -817,10 +839,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       pat = GEN_FCN (icode) (temp, xop0, xop1);\n       if (pat)\n \t{\n-\t  /* If PAT is a multi-insn sequence, try to add an appropriate\n+\t  /* If PAT is composed of more than one insn, try to add an appropriate\n \t     REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n \t     operand, call ourselves again, this time without a target.  */\n-\t  if (GET_CODE (pat) == SEQUENCE\n+\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n \t      && ! add_equal_note (pat, temp, binoptab->code, xop0, xop1))\n \t    {\n \t      delete_insns_since (last);\n@@ -1195,7 +1217,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (shift_count != BITS_PER_WORD)\n \t    emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n \t  else\n-\t    emit_insns (insns);\n+\t    emit_insn (insns);\n \n \n \t  return target;\n@@ -2146,7 +2168,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       pat = GEN_FCN (icode) (temp, xop0);\n       if (pat)\n \t{\n-\t  if (GET_CODE (pat) == SEQUENCE\n+\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n \t      && ! add_equal_note (pat, temp, unoptab->code, xop0, NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n@@ -2538,7 +2560,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n       pat = GEN_FCN (icode) (temp, xop0);\n       if (pat)\n \t{\n-\t  if (GET_CODE (pat) == SEQUENCE\n+\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n \t      && ! add_equal_note (pat, temp, this_abs_optab->code, xop0, \n \t\t\t\t   NULL_RTX))\n \t    {\n@@ -2707,7 +2729,7 @@ emit_unop_insn (icode, target, op0, code)\n \n   pat = GEN_FCN (icode) (temp, op0);\n \n-  if (GET_CODE (pat) == SEQUENCE && code != UNKNOWN)\n+  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX && code != UNKNOWN)\n     add_equal_note (pat, temp, code, op0, NULL_RTX);\n   \n   emit_insn (pat);\n@@ -2754,12 +2776,12 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n   rtx prev, next, first, last, insn;\n \n   if (GET_CODE (target) != REG || reload_in_progress)\n-    return emit_insns (insns);\n+    return emit_insn (insns);\n   else\n     for (insn = insns; insn; insn = NEXT_INSN (insn))\n       if (GET_CODE (insn) != INSN\n \t  || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\treturn emit_insns (insns);\n+\treturn emit_insn (insns);\n \n   /* First emit all insns that do not store into words of the output and remove\n      these from the list.  */\n@@ -4082,7 +4104,7 @@ have_sub2_insn (x, y)\n }\n \n /* Generate the body of an instruction to copy Y into X.\n-   It may be a SEQUENCE, if one insn isn't enough.  */\n+   It may be a list of insns, if one insn isn't enough.  */\n \n rtx\n gen_move_insn (x, y)\n@@ -4153,7 +4175,7 @@ gen_move_insn (x, y)\n \n   start_sequence ();\n   emit_move_insn_1 (x, y);\n-  seq = gen_sequence ();\n+  seq = get_insns ();\n   end_sequence ();\n   return seq;\n }\n@@ -5260,7 +5282,7 @@ gen_cond_trap (code, op1, op2, tcode)\n       if (insn)\n \t{\n \t  emit_insn (insn);\n-\t  insn = gen_sequence ();\n+\t  insn = get_insns ();\n \t}\n       end_sequence();\n       return insn;"}, {"sha": "c5b903f04614a7ac7d4370cef8f5da3c8c17580d", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1295,7 +1295,7 @@ gen_edge_profiler (edgeno)\n   if (tmp != mem_ref)\n     emit_move_insn (copy_rtx (mem_ref), tmp);\n \n-  sequence = gen_sequence ();\n+  sequence = get_insns ();\n   end_sequence ();\n   return sequence;\n }"}, {"sha": "005885bc12515f7e9a3503e940321eb175dde27b", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -3065,7 +3065,7 @@ peephole2_optimize (dump_file)\n \t\t     cfg-related call notes.  */\n \t\t  for (i = 0; i <= match_len; ++i)\n \t\t    {\n-\t\t      int j, k;\n+\t\t      int j;\n \t\t      rtx old_insn, new_insn, note;\n \n \t\t      j = i + peep2_current;\n@@ -3076,20 +3076,15 @@ peephole2_optimize (dump_file)\n \t\t\tcontinue;\n \t\t      was_call = true;\n \n-\t\t      new_insn = NULL_RTX;\n-\t\t      if (GET_CODE (try) == SEQUENCE)\n-\t\t\tfor (k = XVECLEN (try, 0) - 1; k >= 0; k--)\n-\t\t\t  {\n-\t\t\t    rtx x = XVECEXP (try, 0, k);\n-\t\t\t    if (GET_CODE (x) == CALL_INSN)\n-\t\t\t      {\n-\t\t\t\tnew_insn = x;\n-\t\t\t\tbreak;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t      else if (GET_CODE (try) == CALL_INSN)\n-\t\t\tnew_insn = try;\n-\t\t      if (! new_insn)\n+\t\t      new_insn = try;\n+\t\t      while (new_insn != NULL_RTX)\n+\t\t\t{\n+\t\t\t  if (GET_CODE (new_insn) == CALL_INSN)\n+\t\t\t    break;\n+\t\t\t  new_insn = NEXT_INSN (new_insn);\n+\t\t\t}\n+\n+\t\t      if (new_insn == NULL_RTX)\n \t\t\tabort ();\n \n \t\t      CALL_INSN_FUNCTION_USAGE (new_insn)"}, {"sha": "ff896fd93b1cc75d885351617908f31ac1d5f4b9", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -2587,16 +2587,13 @@ compensate_edge (e, file)\n       current_block = NULL;\n       start_sequence ();\n \n-      /* ??? change_stack needs some point to emit insns after.\n-         Also needed to keep gen_sequence from returning a\n-         pattern as opposed to a sequence, which would lose\n-         REG_DEAD notes.  */\n+      /* ??? change_stack needs some point to emit insns after.  */\n       after = emit_note (NULL, NOTE_INSN_DELETED);\n \n       tmpstack = regstack;\n       change_stack (after, &tmpstack, target_stack, EMIT_BEFORE);\n \n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n \n       insert_insn_on_edge (seq, e);"}, {"sha": "55a31dc612eafaff62f7a01b8262511f8980e6c3", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -775,7 +775,7 @@ copy_src_to_dest (insn, src, dest, old_max_uid)\n       /* Generate the src->dest move.  */\n       start_sequence ();\n       emit_move_insn (dest, src);\n-      seq = gen_sequence ();\n+      seq = get_insns ();\n       end_sequence ();\n       /* If this sequence uses new registers, we may not use it.  */\n       if (old_num_regs != reg_rtx_no"}, {"sha": "81adb8dcbf8ed7fd00b8d4a289997b68501bef95", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -6822,7 +6822,7 @@ emit_output_reload_insns (chain, rl, j)\n \n   if (rl->when_needed == RELOAD_OTHER)\n     {\n-      emit_insns (other_output_reload_insns[rl->opnum]);\n+      emit_insn (other_output_reload_insns[rl->opnum]);\n       other_output_reload_insns[rl->opnum] = get_insns ();\n     }\n   else\n@@ -7038,25 +7038,25 @@ emit_reload_insns (chain)\n      reloads for the operand.  The RELOAD_OTHER output reloads are\n      output in descending order by reload number.  */\n \n-  emit_insns_before (other_input_address_reload_insns, insn);\n-  emit_insns_before (other_input_reload_insns, insn);\n+  emit_insn_before (other_input_address_reload_insns, insn);\n+  emit_insn_before (other_input_reload_insns, insn);\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      emit_insns_before (inpaddr_address_reload_insns[j], insn);\n-      emit_insns_before (input_address_reload_insns[j], insn);\n-      emit_insns_before (input_reload_insns[j], insn);\n+      emit_insn_before (inpaddr_address_reload_insns[j], insn);\n+      emit_insn_before (input_address_reload_insns[j], insn);\n+      emit_insn_before (input_reload_insns[j], insn);\n     }\n \n-  emit_insns_before (other_operand_reload_insns, insn);\n-  emit_insns_before (operand_reload_insns, insn);\n+  emit_insn_before (other_operand_reload_insns, insn);\n+  emit_insn_before (operand_reload_insns, insn);\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      rtx x = emit_insns_after (outaddr_address_reload_insns[j], insn);\n-      x = emit_insns_after (output_address_reload_insns[j], x);\n-      x = emit_insns_after (output_reload_insns[j], x);\n-      emit_insns_after (other_output_reload_insns[j], x);\n+      rtx x = emit_insn_after (outaddr_address_reload_insns[j], insn);\n+      x = emit_insn_after (output_address_reload_insns[j], x);\n+      x = emit_insn_after (output_reload_insns[j], x);\n+      emit_insn_after (other_output_reload_insns[j], x);\n     }\n \n   /* For all the spill regs newly reloaded in this instruction,\n@@ -9465,19 +9465,14 @@ fixup_abnormal_edges ()\n \t      next = NEXT_INSN (insn);\n \t      if (INSN_P (insn))\n \t\t{\n-\t\t  rtx seq;\n-\n \t          delete_insn (insn);\n \n \t\t  /* We're not deleting it, we're moving it.  */\n \t\t  INSN_DELETED_P (insn) = 0;\n+\t\t  PREV_INSN (insn) = NULL_RTX;\n+\t\t  NEXT_INSN (insn) = NULL_RTX;\n \n-\t\t  /* Emit a sequence, rather than scarfing the pattern, so\n-\t\t     that we don't lose REG_NOTES etc.  */\n-\t\t  /* ??? Could copy the test from gen_sequence, but don't\n-\t\t     think it's worth the bother.  */\n-\t\t  seq = gen_rtx_SEQUENCE (VOIDmode, gen_rtvec (1, insn));\n-\t          insert_insn_on_edge (seq, e);\n+\t          insert_insn_on_edge (insn, e);\n \t\t}\n \t      insn = next;\n \t    }"}, {"sha": "3e3052dff9d09674a278af01621dfe2755a203d4", "filename": "gcc/reorg.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -3240,6 +3240,7 @@ relax_delay_slots (first)\n \t  && GET_CODE (next) == JUMP_INSN\n \t  && GET_CODE (PATTERN (next)) == RETURN)\n \t{\n+\t  rtx after;\n \t  int i;\n \n \t  /* Delete the RETURN and just execute the delay list insns.\n@@ -3256,7 +3257,15 @@ relax_delay_slots (first)\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n-\t  emit_insn_after (pat, trial);\n+\t  if (GET_CODE (pat) != SEQUENCE)\n+\t    abort ();\n+\t  after = trial;\n+\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t    {\n+\t      rtx this_insn = XVECEXP (pat, 0, i);\n+\t      add_insn_after (this_insn, after);\n+\t      after = this_insn;\n+\t    }\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n \t}\n@@ -3352,6 +3361,7 @@ relax_delay_slots (first)\n #endif\n \t  )\n \t{\n+\t  rtx after;\n \t  int i;\n \n \t  /* All this insn does is execute its delay list and jump to the\n@@ -3370,7 +3380,15 @@ relax_delay_slots (first)\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n-\t  emit_insn_after (pat, trial);\n+\t  if (GET_CODE (pat) != SEQUENCE)\n+\t    abort ();\n+\t  after = trial;\n+\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t    {\n+\t      rtx this_insn = XVECEXP (pat, 0, i);\n+\t      add_insn_after (this_insn, after);\n+\t      after = this_insn;\n+\t    }\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n \t}"}, {"sha": "8e050661751154c6327b429b0f65f2bff9905e87", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1349,7 +1349,6 @@ extern void push_to_sequence\t\tPARAMS ((rtx));\n extern void end_sequence\t\tPARAMS ((void));\n extern void push_to_full_sequence\tPARAMS ((rtx, rtx));\n extern void end_full_sequence\t\tPARAMS ((rtx*, rtx*));\n-extern rtx gen_sequence\t\t\tPARAMS ((void));\n \n /* In varasm.c  */\n extern rtx immed_double_const\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n@@ -1394,11 +1393,6 @@ extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_after\t\tPARAMS ((int, rtx));\n extern rtx emit_line_note_after\t\tPARAMS ((const char *, int, rtx));\n extern rtx emit_insn\t\t\tPARAMS ((rtx));\n-extern rtx emit_insns\t\t\tPARAMS ((rtx));\n-extern rtx emit_insns_before\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insns_before_scope\tPARAMS ((rtx, rtx, tree));\n-extern rtx emit_insns_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insns_after_scope\tPARAMS ((rtx, rtx, tree));\n extern rtx emit_jump_insn\t\tPARAMS ((rtx));\n extern rtx emit_call_insn\t\tPARAMS ((rtx));\n extern rtx emit_label\t\t\tPARAMS ((rtx));"}, {"sha": "e44c28a08cca7206b90acff770147b555b4825dd", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -702,18 +702,8 @@ print_pattern (buf, x, verbose)\n       }\n       break;\n     case SEQUENCE:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"%%{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_insn (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s%%}\", t1);\n-      }\n+      /* Should never see SEQUENCE codes until after reorg.  */\n+      abort ();\n       break;\n     case ASM_INPUT:\n       sprintf (buf, \"asm {%s}\", XSTR (x, 0));"}, {"sha": "a5d1b867d8bdaa88d9fc511544959d9fe7133cd9", "filename": "gcc/sibcall.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -541,11 +541,11 @@ replace_call_placeholder (insn, use)\n      sibcall_use_t use;\n {\n   if (use == sibcall_use_tail_recursion)\n-    emit_insns_before (XEXP (PATTERN (insn), 2), insn);\n+    emit_insn_before (XEXP (PATTERN (insn), 2), insn);\n   else if (use == sibcall_use_sibcall)\n-    emit_insns_before (XEXP (PATTERN (insn), 1), insn);\n+    emit_insn_before (XEXP (PATTERN (insn), 1), insn);\n   else if (use == sibcall_use_normal)\n-    emit_insns_before (XEXP (PATTERN (insn), 0), insn);\n+    emit_insn_before (XEXP (PATTERN (insn), 0), insn);\n   else\n     abort ();\n "}, {"sha": "c18f3b9e2f687f760813f7783eede64b4a26ab03", "filename": "gcc/ssa.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -124,6 +124,8 @@ struct ssa_rename_from_hash_table_data {\n   partition reg_partition;\n };\n \n+static rtx gen_sequence\n+  PARAMS ((void));\n static void ssa_rename_from_initialize\n   PARAMS ((void));\n static rtx ssa_rename_from_lookup\n@@ -974,6 +976,28 @@ rename_insn_1 (ptr, data)\n     }\n }\n \n+static rtx\n+gen_sequence ()\n+{\n+  rtx first_insn = get_insns ();\n+  rtx result;\n+  rtx tem;\n+  int i;\n+  int len;\n+\n+  /* Count the insns in the chain.  */\n+  len = 0;\n+  for (tem = first_insn; tem; tem = NEXT_INSN (tem))\n+    len++;\n+\n+  result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n+\n+  for (i = 0, tem = first_insn; tem; tem = NEXT_INSN (tem), i++)\n+    XVECEXP (result, 0, i) = tem;\n+\n+  return result;\n+}\n+\n static void\n rename_block (bb, idom)\n      int bb;\n@@ -1449,7 +1473,7 @@ eliminate_phi (e, reg_partition)\n \tephi_create (i, visited, pred, succ, nodes);\n     }\n \n-  insn = gen_sequence ();\n+  insn = get_insns ();\n   end_sequence ();\n   insert_insn_on_edge (insn, e);\n   if (rtl_dump_file)"}, {"sha": "9220b37e9d0f724781d04f21bac696ed347f057d", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -899,7 +899,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t  NOTE_BLOCK (end) = block;\n \tfixup->context = block;\n \tend_sequence ();\n-\temit_insns_after (start, original_before_jump);\n+\temit_insn_after (start, original_before_jump);\n       }\n \n       fixup->block_start_count = current_block_start_count;\n@@ -1044,7 +1044,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t  (*lang_hooks.decls.poplevel) (1, 0, 0);\n \n \t  end_sequence ();\n-\t  emit_insns_after (cleanup_insns, f->before_jump);\n+\t  emit_insn_after (cleanup_insns, f->before_jump);\n \n \t  f->before_jump = 0;\n \t}\n@@ -1084,7 +1084,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t      end_sequence ();\n \t      if (cleanup_insns != 0)\n \t\tf->before_jump\n-\t\t  = emit_insns_after (cleanup_insns, f->before_jump);\n+\t\t  = emit_insn_after (cleanup_insns, f->before_jump);\n \n \t      f->cleanup_list_list = TREE_CHAIN (lists);\n \t    }\n@@ -3421,7 +3421,7 @@ expand_nl_handler_label (slot, before_insn)\n   emit_move_insn (slot, gen_rtx_LABEL_REF (Pmode, handler_label));\n   insns = get_insns ();\n   end_sequence ();\n-  emit_insns_before (insns, before_insn);\n+  emit_insn_before (insns, before_insn);\n \n   emit_label (handler_label);\n \n@@ -3508,7 +3508,7 @@ expand_nl_goto_receivers (thisblock)\n \temit_move_insn (save_receiver, XEXP (slot, 0));\n \tinsns = get_insns ();\n \tend_sequence ();\n-\temit_insns_before (insns, thisblock->data.block.first_insn);\n+\temit_insn_before (insns, thisblock->data.block.first_insn);\n       }\n \n   /* Jump around the handlers; they run only when specially invoked.  */\n@@ -3994,7 +3994,7 @@ expand_decl_cleanup (decl, cleanup)\n \t  end_sequence ();\n \n \t  thisblock->data.block.last_unconditional_cleanup\n-\t    = emit_insns_after (set_flag_0,\n+\t    = emit_insn_after (set_flag_0,\n \t\t\t\tthisblock->data.block.last_unconditional_cleanup);\n \n \t  emit_move_insn (flag, const1_rtx);\n@@ -4036,8 +4036,8 @@ expand_decl_cleanup (decl, cleanup)\n \t  end_sequence ();\n \t  if (seq)\n \t    thisblock->data.block.last_unconditional_cleanup\n-\t      = emit_insns_after (seq,\n-\t\t\t\t  thisblock->data.block.last_unconditional_cleanup);\n+\t      = emit_insn_after (seq,\n+\t\t\t\t thisblock->data.block.last_unconditional_cleanup);\n \t}\n       else\n \t{"}, {"sha": "3b81d223ac76909dc5d252d1bab6131cabbcddde", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f937369fa50dfd2f5af11b18d30c5489451072c/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=2f937369fa50dfd2f5af11b18d30c5489451072c", "patch": "@@ -1026,7 +1026,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t      LABEL_NUSES (labels[0])++;\n \t    }\n \n-\t  sequence = gen_sequence ();\n+\t  sequence = get_insns ();\n \t  end_sequence ();\n \t  loop_insn_hoist (loop, sequence);\n \n@@ -1758,12 +1758,6 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \n   start_sequence ();\n \n-  /* Emit a NOTE_INSN_DELETED to force at least two insns onto the sequence.\n-     Else gen_sequence could return a raw pattern for a jump which we pass\n-     off to emit_insn_before (instead of emit_jump_insn_before) which causes\n-     a variety of losing behaviors later.  */\n-  emit_note (0, NOTE_INSN_DELETED);\n-\n   insn = copy_start;\n   do\n     {\n@@ -2278,7 +2272,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n   if (final_label && LABEL_NUSES (final_label) > 0)\n     emit_label (final_label);\n \n-  tem = gen_sequence ();\n+  tem = get_insns ();\n   end_sequence ();\n   loop_insn_emit_before (loop, 0, insert_before, tem);\n }\n@@ -2956,7 +2950,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t      ret = force_operand (v->new_reg, tem);\n \t\t      if (ret != tem)\n \t\t\temit_move_insn (tem, ret);\n-\t\t      sequence = gen_sequence ();\n+\t\t      sequence = get_insns ();\n \t\t      end_sequence ();\n \t\t      loop_insn_hoist (loop, sequence);\n \n@@ -3312,7 +3306,7 @@ final_giv_value (loop, v)\n \t\t    tem = expand_simple_binop (GET_MODE (tem), MINUS, tem,\n \t\t\t\t\t       biv->add_val, NULL_RTX, 0,\n \t\t\t\t\t       OPTAB_LIB_WIDEN);\n-\t\t    seq = gen_sequence ();\n+\t\t    seq = get_insns ();\n \t\t    end_sequence ();\n \t\t    loop_insn_sink (loop, seq);\n \t\t  }"}]}