{"sha": "0228065963497bd344e64695e6d6c9a5a3897b4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyODA2NTk2MzQ5N2JkMzQ0ZTY0Njk1ZTZkNmM5YTVhMzg5N2I0ZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-08-01T19:10:14Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-08-01T19:10:14Z"}, "message": "gcse.c (expr_hash_table_size, [...]): Removed.\n\n\t* gcse.c (expr_hash_table_size, n_exprs, set_hash_table_size,\n\tn_sets): Removed.\n\t(expr_hash_table, set_hash_table): Type changed to ...\n\t(struct hash_table): New type.\n\t(hash_scan_insn, hash_scan_set, hash_scan_clobber, hash_scan_call,\n\tinsert_expr_in_table, insert_set_in_table, compute_hash_table,\n\tdump_hash_table, lookup_expr, lookup_set, compute_local_properties,\n\tcompute_ae_gen, compute_ae_kill): Modified to pass the table explicitly.\n\t(alloc_set_hash_table, alloc_expr_hash_table): Merged to ...\n\t(alloc_hash_table): New.\n\t(free_set_hash_table, free_expr_hash_table): Merged to ...\n\t(free_hash_table): New.\n\t(compute_set_hash_table, compute_expr_hash_table): Merged to ...\n\t(compute_hash_table_work): New.\n\t(classic_gcse, one_classic_gcse_pass, compute_cprop_data,\n\tfind_avail_set, one_cprop_pass, find_bypass_set, compute_pre_data,\n\tpre_edge_insert, pre_insert_copies, pre_delete, pre_gcse,\n\tone_pre_gcse_pass, compute_transpout, compute_code_hoist_vbeinout,\n\thoist_code, one_code_hoisting_pass,\n\ttrim_ld_motion_mems): Altered due to changed type of hash tables.\n\nFrom-SVN: r55940", "tree": {"sha": "370174d222ba28856252ede6a7b86f93df3ef078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370174d222ba28856252ede6a7b86f93df3ef078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0228065963497bd344e64695e6d6c9a5a3897b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0228065963497bd344e64695e6d6c9a5a3897b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0228065963497bd344e64695e6d6c9a5a3897b4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0228065963497bd344e64695e6d6c9a5a3897b4d/comments", "author": null, "committer": null, "parents": [{"sha": "905173ebdd1eb70594d11406b3aecf17ce5d0914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/905173ebdd1eb70594d11406b3aecf17ce5d0914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/905173ebdd1eb70594d11406b3aecf17ce5d0914"}], "stats": {"total": 448, "additions": 214, "deletions": 234}, "files": [{"sha": "103e5917a916c2073ee4ab874ef6763e1c4b6176", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0228065963497bd344e64695e6d6c9a5a3897b4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0228065963497bd344e64695e6d6c9a5a3897b4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0228065963497bd344e64695e6d6c9a5a3897b4d", "patch": "@@ -1,3 +1,26 @@\n+2002-08-01  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcse.c (expr_hash_table_size, n_exprs, set_hash_table_size,\n+\tn_sets): Removed.\n+\t(expr_hash_table, set_hash_table): Type changed to ...\n+\t(struct hash_table): New type.\n+\t(hash_scan_insn, hash_scan_set, hash_scan_clobber, hash_scan_call,\n+\tinsert_expr_in_table, insert_set_in_table, compute_hash_table,\n+\tdump_hash_table, lookup_expr, lookup_set, compute_local_properties,\n+\tcompute_ae_gen, compute_ae_kill): Modified to pass the table explicitly.\n+\t(alloc_set_hash_table, alloc_expr_hash_table): Merged to ...\n+\t(alloc_hash_table): New.\n+\t(free_set_hash_table, free_expr_hash_table): Merged to ...\n+\t(free_hash_table): New.\n+\t(compute_set_hash_table, compute_expr_hash_table): Merged to ...\n+\t(compute_hash_table_work): New.\n+\t(classic_gcse, one_classic_gcse_pass, compute_cprop_data,\n+\tfind_avail_set, one_cprop_pass, find_bypass_set, compute_pre_data,\n+\tpre_edge_insert, pre_insert_copies, pre_delete, pre_gcse,\n+\tone_pre_gcse_pass, compute_transpout, compute_code_hoist_vbeinout,\n+\thoist_code, one_code_hoisting_pass,\n+\ttrim_ld_motion_mems): Altered due to changed type of hash tables.\n+\n 2002-08-01  Zack Weinberg  <zack@codesourcery.com>\n \n \t* final.c (output_alternate_entry_point):"}, {"sha": "b0798951cc28bb95801fc53b493f6f8217e2b21c", "filename": "gcc/gcse.c", "status": "modified", "additions": 191, "deletions": 234, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0228065963497bd344e64695e6d6c9a5a3897b4d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0228065963497bd344e64695e6d6c9a5a3897b4d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0228065963497bd344e64695e6d6c9a5a3897b4d", "patch": "@@ -362,19 +362,27 @@ struct occr\n    [one could build a mapping table without holes afterwards though].\n    Someday I'll perform the computation and figure it out.  */\n \n-/* Total size of the expression hash table, in elements.  */\n-static unsigned int expr_hash_table_size;\n+struct hash_table\n+{\n+  /* The table itself.\n+     This is an array of `expr_hash_table_size' elements.  */\n+  struct expr **table;\n+\n+  /* Size of the hash table, in elements.  */\n+  unsigned int size;\n \n-/* The table itself.\n-   This is an array of `expr_hash_table_size' elements.  */\n-static struct expr **expr_hash_table;\n+  /* Number of hash table elements.  */\n+  unsigned int n_elems;\n \n-/* Total size of the copy propagation hash table, in elements.  */\n-static unsigned int set_hash_table_size;\n+  /* Whether the table is expression of copy propagation one.  */\n+  int set_p;\n+};\n \n-/* The table itself.\n-   This is an array of `set_hash_table_size' elements.  */\n-static struct expr **set_hash_table;\n+/* Expression hash table.  */\n+static struct hash_table expr_hash_table;\n+\n+/* Copy propagation hash table.  */\n+static struct hash_table set_hash_table;\n \n /* Mapping of uids to cuids.\n    Only real insns get cuids.  */\n@@ -404,12 +412,6 @@ static rtx *cuid_insn;\n    This is named with \"gcse\" to not collide with global of same name.  */\n static unsigned int max_gcse_regno;\n \n-/* Maximum number of cse-able expressions found.  */\n-static int n_exprs;\n-\n-/* Maximum number of assignments for copy propagation found.  */\n-static int n_sets;\n-\n /* Table of registers that are modified.\n \n    For each register, each element is a list of places where the pseudo-reg\n@@ -560,17 +562,17 @@ static int get_bitmap_width     PARAMS ((int, int, int));\n static void record_one_set\tPARAMS ((int, rtx));\n static void record_set_info\tPARAMS ((rtx, rtx, void *));\n static void compute_sets\tPARAMS ((rtx));\n-static void hash_scan_insn\tPARAMS ((rtx, int, int));\n-static void hash_scan_set\tPARAMS ((rtx, rtx, int));\n-static void hash_scan_clobber\tPARAMS ((rtx, rtx));\n-static void hash_scan_call\tPARAMS ((rtx, rtx));\n+static void hash_scan_insn\tPARAMS ((rtx, struct hash_table *, int));\n+static void hash_scan_set\tPARAMS ((rtx, rtx, struct hash_table *));\n+static void hash_scan_clobber\tPARAMS ((rtx, rtx, struct hash_table *));\n+static void hash_scan_call\tPARAMS ((rtx, rtx, struct hash_table *));\n static int want_to_gcse_p\tPARAMS ((rtx));\n static int oprs_unchanged_p\tPARAMS ((rtx, rtx, int));\n static int oprs_anticipatable_p PARAMS ((rtx, rtx));\n static int oprs_available_p\tPARAMS ((rtx, rtx));\n static void insert_expr_in_table PARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t  int, int));\n-static void insert_set_in_table PARAMS ((rtx, rtx));\n+\t\t\t\t\t  int, int, struct hash_table *));\n+static void insert_set_in_table PARAMS ((rtx, rtx, struct hash_table *));\n static unsigned int hash_expr\tPARAMS ((rtx, enum machine_mode, int *, int));\n static unsigned int hash_expr_1 PARAMS ((rtx, enum machine_mode, int *));\n static unsigned int hash_string_1 PARAMS ((const char *));\n@@ -579,17 +581,14 @@ static int expr_equiv_p\t        PARAMS ((rtx, rtx));\n static void record_last_reg_set_info PARAMS ((rtx, int));\n static void record_last_mem_set_info PARAMS ((rtx));\n static void record_last_set_info PARAMS ((rtx, rtx, void *));\n-static void compute_hash_table\tPARAMS ((int));\n-static void alloc_set_hash_table PARAMS ((int));\n-static void free_set_hash_table PARAMS ((void));\n-static void compute_set_hash_table PARAMS ((void));\n-static void alloc_expr_hash_table PARAMS ((unsigned int));\n-static void free_expr_hash_table PARAMS ((void));\n-static void compute_expr_hash_table PARAMS ((void));\n-static void dump_hash_table\tPARAMS ((FILE *, const char *, struct expr **,\n-\t\t\t\t\t int, int));\n-static struct expr *lookup_expr\tPARAMS ((rtx));\n-static struct expr *lookup_set\tPARAMS ((unsigned int, rtx));\n+static void compute_hash_table\tPARAMS ((struct hash_table *));\n+static void alloc_hash_table PARAMS ((int, struct hash_table *, int));\n+static void free_hash_table PARAMS ((struct hash_table *));\n+static void compute_hash_table_work PARAMS ((struct hash_table *));\n+static void dump_hash_table\tPARAMS ((FILE *, const char *,\n+\t\t\t\t\tstruct hash_table *));\n+static struct expr *lookup_expr\tPARAMS ((rtx, struct hash_table *));\n+static struct expr *lookup_set\tPARAMS ((unsigned int, rtx, struct hash_table *));\n static struct expr *next_set\tPARAMS ((unsigned int, struct expr *));\n static void reset_opr_set_tables PARAMS ((void));\n static int oprs_not_set_p\tPARAMS ((rtx, rtx));\n@@ -602,7 +601,7 @@ static void free_cprop_mem\tPARAMS ((void));\n static void compute_transp\tPARAMS ((rtx, int, sbitmap *, int));\n static void compute_transpout\tPARAMS ((void));\n static void compute_local_properties PARAMS ((sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\t      int));\n+\t\t\t\t\t      struct hash_table *));\n static void compute_cprop_data\tPARAMS ((void));\n static void find_used_regs\tPARAMS ((rtx *, void *));\n static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n@@ -645,9 +644,9 @@ static void compute_kill_rd\tPARAMS ((void));\n static void compute_rd\t\tPARAMS ((void));\n static void alloc_avail_expr_mem PARAMS ((int, int));\n static void free_avail_expr_mem PARAMS ((void));\n-static void compute_ae_gen\tPARAMS ((void));\n+static void compute_ae_gen\tPARAMS ((struct hash_table *));\n static int expr_killed_p\tPARAMS ((rtx, basic_block));\n-static void compute_ae_kill\tPARAMS ((sbitmap *, sbitmap *));\n+static void compute_ae_kill\tPARAMS ((sbitmap *, sbitmap *, struct hash_table *));\n static int expr_reaches_here_p\tPARAMS ((struct occr *, struct expr *,\n \t\t\t\t\t basic_block, int));\n static rtx computing_insn\tPARAMS ((struct expr *, rtx));\n@@ -1114,25 +1113,23 @@ get_bitmap_width (n, x, y)\n    properties.  If NULL, then it is not necessary to compute or record that\n    particular property.\n \n-   SETP controls which hash table to look at.  If zero, this routine looks at\n-   the expr hash table; if nonzero this routine looks at the set hash table.\n-   Additionally, TRANSP is computed as ~TRANSP, since this is really cprop's\n+   TABLE controls which hash table to look at.  If it is  set hash table,\n+   additionally, TRANSP is computed as ~TRANSP, since this is really cprop's\n    ABSALTERED.  */\n \n static void\n-compute_local_properties (transp, comp, antloc, setp)\n+compute_local_properties (transp, comp, antloc, table)\n      sbitmap *transp;\n      sbitmap *comp;\n      sbitmap *antloc;\n-     int setp;\n+     struct hash_table *table;\n {\n-  unsigned int i, hash_table_size;\n-  struct expr **hash_table;\n+  unsigned int i;\n \n   /* Initialize any bitmaps that were passed in.  */\n   if (transp)\n     {\n-      if (setp)\n+      if (table->set_p)\n \tsbitmap_vector_zero (transp, last_basic_block);\n       else\n \tsbitmap_vector_ones (transp, last_basic_block);\n@@ -1143,17 +1140,11 @@ compute_local_properties (transp, comp, antloc, setp)\n   if (antloc)\n     sbitmap_vector_zero (antloc, last_basic_block);\n \n-  /* We use the same code for cprop, pre and hoisting.  For cprop\n-     we care about the set hash table, for pre and hoisting we\n-     care about the expr hash table.  */\n-  hash_table_size = setp ? set_hash_table_size : expr_hash_table_size;\n-  hash_table = setp ? set_hash_table : expr_hash_table;\n-\n-  for (i = 0; i < hash_table_size; i++)\n+  for (i = 0; i < table->size; i++)\n     {\n       struct expr *expr;\n \n-      for (expr = hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+      for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n \t{\n \t  int indx = expr->bitmap_index;\n \t  struct occr *occr;\n@@ -1162,7 +1153,7 @@ compute_local_properties (transp, comp, antloc, setp)\n \t     We start by assuming all are transparent [none are killed], and\n \t     then reset the bits for those that are.  */\n \t  if (transp)\n-\t    compute_transp (expr->expr, indx, transp, setp);\n+\t    compute_transp (expr->expr, indx, transp, table->set_p);\n \n \t  /* The occurrences recorded in antic_occr are exactly those that\n \t     we want to set to non-zero in ANTLOC.  */\n@@ -1938,7 +1929,7 @@ expr_equiv_p (x, y)\n   return 1;\n }\n \n-/* Insert expression X in INSN in the hash table.\n+/* Insert expression X in INSN in the hash TABLE.\n    If it is already present, record it as the last occurrence in INSN's\n    basic block.\n \n@@ -1949,27 +1940,28 @@ expr_equiv_p (x, y)\n    AVAIL_P is non-zero if X is an available expression.  */\n \n static void\n-insert_expr_in_table (x, mode, insn, antic_p, avail_p)\n+insert_expr_in_table (x, mode, insn, antic_p, avail_p, table)\n      rtx x;\n      enum machine_mode mode;\n      rtx insn;\n      int antic_p, avail_p;\n+     struct hash_table *table;\n {\n   int found, do_not_record_p;\n   unsigned int hash;\n   struct expr *cur_expr, *last_expr = NULL;\n   struct occr *antic_occr, *avail_occr;\n   struct occr *last_occr = NULL;\n \n-  hash = hash_expr (x, mode, &do_not_record_p, expr_hash_table_size);\n+  hash = hash_expr (x, mode, &do_not_record_p, table->size);\n \n   /* Do not insert expression in table if it contains volatile operands,\n      or if hash_expr determines the expression is something we don't want\n      to or can't handle.  */\n   if (do_not_record_p)\n     return;\n \n-  cur_expr = expr_hash_table[hash];\n+  cur_expr = table->table[hash];\n   found = 0;\n \n   while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n@@ -1984,16 +1976,16 @@ insert_expr_in_table (x, mode, insn, antic_p, avail_p)\n     {\n       cur_expr = (struct expr *) gcse_alloc (sizeof (struct expr));\n       bytes_used += sizeof (struct expr);\n-      if (expr_hash_table[hash] == NULL)\n+      if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n-\texpr_hash_table[hash] = cur_expr;\n+\ttable->table[hash] = cur_expr;\n       else\n \t/* Add EXPR to end of this hash chain.  */\n \tlast_expr->next_same_hash = cur_expr;\n \n       /* Set the fields of the expr element.  */\n       cur_expr->expr = x;\n-      cur_expr->bitmap_index = n_exprs++;\n+      cur_expr->bitmap_index = table->n_elems++;\n       cur_expr->next_same_hash = NULL;\n       cur_expr->antic_occr = NULL;\n       cur_expr->avail_occr = NULL;\n@@ -2077,9 +2069,10 @@ insert_expr_in_table (x, mode, insn, antic_p, avail_p)\n    basic block.  */\n \n static void\n-insert_set_in_table (x, insn)\n+insert_set_in_table (x, insn, table)\n      rtx x;\n      rtx insn;\n+     struct hash_table *table;\n {\n   int found;\n   unsigned int hash;\n@@ -2090,9 +2083,9 @@ insert_set_in_table (x, insn)\n       || GET_CODE (SET_DEST (x)) != REG)\n     abort ();\n \n-  hash = hash_set (REGNO (SET_DEST (x)), set_hash_table_size);\n+  hash = hash_set (REGNO (SET_DEST (x)), table->size);\n \n-  cur_expr = set_hash_table[hash];\n+  cur_expr = table->table[hash];\n   found = 0;\n \n   while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n@@ -2107,9 +2100,9 @@ insert_set_in_table (x, insn)\n     {\n       cur_expr = (struct expr *) gcse_alloc (sizeof (struct expr));\n       bytes_used += sizeof (struct expr);\n-      if (set_hash_table[hash] == NULL)\n+      if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n-\tset_hash_table[hash] = cur_expr;\n+\ttable->table[hash] = cur_expr;\n       else\n \t/* Add EXPR to end of this hash chain.  */\n \tlast_expr->next_same_hash = cur_expr;\n@@ -2118,7 +2111,7 @@ insert_set_in_table (x, insn)\n \t We must copy X because it can be modified when copy propagation is\n \t performed on its operands.  */\n       cur_expr->expr = copy_rtx (x);\n-      cur_expr->bitmap_index = n_sets++;\n+      cur_expr->bitmap_index = table->n_elems++;\n       cur_expr->next_same_hash = NULL;\n       cur_expr->antic_occr = NULL;\n       cur_expr->avail_occr = NULL;\n@@ -2158,21 +2151,20 @@ insert_set_in_table (x, insn)\n     }\n }\n \n-/* Scan pattern PAT of INSN and add an entry to the hash table.  If SET_P is\n-   non-zero, this is for the assignment hash table, otherwise it is for the\n-   expression hash table.  */\n+/* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or\n+   expression one).  */\n \n static void\n-hash_scan_set (pat, insn, set_p)\n+hash_scan_set (pat, insn, table)\n      rtx pat, insn;\n-     int set_p;\n+     struct hash_table *table;\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n   rtx note;\n \n   if (GET_CODE (src) == CALL)\n-    hash_scan_call (src, insn);\n+    hash_scan_call (src, insn, table);\n \n   else if (GET_CODE (dest) == REG)\n     {\n@@ -2181,12 +2173,12 @@ hash_scan_set (pat, insn, set_p)\n \n       /* If this is a single set and we are doing constant propagation,\n \t see if a REG_NOTE shows this equivalent to a constant.  */\n-      if (set_p && (note = find_reg_equal_equiv_note (insn)) != 0\n+      if (table->set_p && (note = find_reg_equal_equiv_note (insn)) != 0\n \t  && CONSTANT_P (XEXP (note, 0)))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n-      if (! set_p\n+      if (! table->set_p\n \t  && regno >= FIRST_PSEUDO_REGISTER\n \t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t  && can_copy_p [GET_MODE (dest)]\n@@ -2217,11 +2209,11 @@ hash_scan_set (pat, insn, set_p)\n \t  int avail_p = (oprs_available_p (src, insn)\n \t\t\t && ! JUMP_P (insn));\n \n-\t  insert_expr_in_table (src, GET_MODE (dest), insn, antic_p, avail_p);\n+\t  insert_expr_in_table (src, GET_MODE (dest), insn, antic_p, avail_p, table);\n \t}\n \n       /* Record sets for constant/copy propagation.  */\n-      else if (set_p\n+      else if (table->set_p\n \t       && regno >= FIRST_PSEUDO_REGISTER\n \t       && ((GET_CODE (src) == REG\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n@@ -2234,20 +2226,22 @@ hash_scan_set (pat, insn, set_p)\n \t       && (insn == BLOCK_END (BLOCK_NUM (insn))\n \t\t   || ((tmp = next_nonnote_insn (insn)) != NULL_RTX\n \t\t       && oprs_available_p (pat, tmp))))\n-\tinsert_set_in_table (pat, insn);\n+\tinsert_set_in_table (pat, insn, table);\n     }\n }\n \n static void\n-hash_scan_clobber (x, insn)\n+hash_scan_clobber (x, insn, table)\n      rtx x ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n+     struct hash_table *table ATTRIBUTE_UNUSED;\n {\n   /* Currently nothing to do.  */\n }\n \n static void\n-hash_scan_call (x, insn)\n+hash_scan_call (x, insn, table)\n      rtx x ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n+     struct hash_table *table ATTRIBUTE_UNUSED;\n {\n   /* Currently nothing to do.  */\n }\n@@ -2266,9 +2260,9 @@ hash_scan_call (x, insn)\n    not record any expressions.  */\n \n static void\n-hash_scan_insn (insn, set_p, in_libcall_block)\n+hash_scan_insn (insn, table, in_libcall_block)\n      rtx insn;\n-     int set_p;\n+     struct hash_table *table;\n      int in_libcall_block;\n {\n   rtx pat = PATTERN (insn);\n@@ -2281,32 +2275,31 @@ hash_scan_insn (insn, set_p, in_libcall_block)\n      what's been modified.  */\n \n   if (GET_CODE (pat) == SET)\n-    hash_scan_set (pat, insn, set_p);\n+    hash_scan_set (pat, insn, table);\n   else if (GET_CODE (pat) == PARALLEL)\n     for (i = 0; i < XVECLEN (pat, 0); i++)\n       {\n \trtx x = XVECEXP (pat, 0, i);\n \n \tif (GET_CODE (x) == SET)\n-\t  hash_scan_set (x, insn, set_p);\n+\t  hash_scan_set (x, insn, table);\n \telse if (GET_CODE (x) == CLOBBER)\n-\t  hash_scan_clobber (x, insn);\n+\t  hash_scan_clobber (x, insn, table);\n \telse if (GET_CODE (x) == CALL)\n-\t  hash_scan_call (x, insn);\n+\t  hash_scan_call (x, insn, table);\n       }\n \n   else if (GET_CODE (pat) == CLOBBER)\n-    hash_scan_clobber (pat, insn);\n+    hash_scan_clobber (pat, insn, table);\n   else if (GET_CODE (pat) == CALL)\n-    hash_scan_call (pat, insn);\n+    hash_scan_call (pat, insn, table);\n }\n \n static void\n-dump_hash_table (file, name, table, table_size, total_size)\n+dump_hash_table (file, name, table)\n      FILE *file;\n      const char *name;\n-     struct expr **table;\n-     int table_size, total_size;\n+     struct hash_table *table;\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n@@ -2315,20 +2308,20 @@ dump_hash_table (file, name, table, table_size, total_size)\n   struct expr *expr;\n \n   flat_table\n-    = (struct expr **) xcalloc (total_size, sizeof (struct expr *));\n-  hash_val = (unsigned int *) xmalloc (total_size * sizeof (unsigned int));\n+    = (struct expr **) xcalloc (table->n_elems, sizeof (struct expr *));\n+  hash_val = (unsigned int *) xmalloc (table->n_elems * sizeof (unsigned int));\n \n-  for (i = 0; i < table_size; i++)\n-    for (expr = table[i]; expr != NULL; expr = expr->next_same_hash)\n+  for (i = 0; i < (int) table->size; i++)\n+    for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n       {\n \tflat_table[expr->bitmap_index] = expr;\n \thash_val[expr->bitmap_index] = i;\n       }\n \n   fprintf (file, \"%s hash table (%d buckets, %d entries)\\n\",\n-\t   name, table_size, total_size);\n+\t   name, table->size, table->n_elems);\n \n-  for (i = 0; i < total_size; i++)\n+  for (i = 0; i < (int) table->n_elems; i++)\n     if (flat_table[i] != 0)\n       {\n \texpr = flat_table[i];\n@@ -2479,11 +2472,11 @@ record_last_set_info (dest, setter, data)\n    Currently src must be a pseudo-reg or a const_int.\n \n    F is the first insn.\n-   SET_P is non-zero for computing the assignment hash table.  */\n+   TABLE is the table computed.  */\n \n static void\n-compute_hash_table (set_p)\n-     int set_p;\n+compute_hash_table_work (table)\n+     struct hash_table *table;\n {\n   unsigned int i;\n \n@@ -2549,10 +2542,10 @@ compute_hash_table (set_p)\n \t  {\n \t    if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \t      in_libcall_block = 1;\n-\t    else if (set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t    else if (table->set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t      in_libcall_block = 0;\n-\t    hash_scan_insn (insn, set_p, in_libcall_block);\n-\t    if (!set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t    hash_scan_insn (insn, table, in_libcall_block);\n+\t    if (!table->set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t      in_libcall_block = 0;\n \t  }\n     }\n@@ -2561,131 +2554,97 @@ compute_hash_table (set_p)\n   reg_avail_info = NULL;\n }\n \n-/* Allocate space for the set hash table.\n+/* Allocate space for the set/expr hash TABLE.\n    N_INSNS is the number of instructions in the function.\n-   It is used to determine the number of buckets to use.  */\n+   It is used to determine the number of buckets to use.\n+   SET_P determines whether set or expression table will\n+   be created.  */\n \n static void\n-alloc_set_hash_table (n_insns)\n+alloc_hash_table (n_insns, table, set_p)\n      int n_insns;\n+     struct hash_table *table;\n+     int set_p;\n {\n   int n;\n \n-  set_hash_table_size = n_insns / 4;\n-  if (set_hash_table_size < 11)\n-    set_hash_table_size = 11;\n-\n-  /* Attempt to maintain efficient use of hash table.\n-     Making it an odd number is simplest for now.\n-     ??? Later take some measurements.  */\n-  set_hash_table_size |= 1;\n-  n = set_hash_table_size * sizeof (struct expr *);\n-  set_hash_table = (struct expr **) gmalloc (n);\n-}\n-\n-/* Free things allocated by alloc_set_hash_table.  */\n-\n-static void\n-free_set_hash_table ()\n-{\n-  free (set_hash_table);\n-}\n-\n-/* Compute the hash table for doing copy/const propagation.  */\n-\n-static void\n-compute_set_hash_table ()\n-{\n-  /* Initialize count of number of entries in hash table.  */\n-  n_sets = 0;\n-  memset ((char *) set_hash_table, 0,\n-\t  set_hash_table_size * sizeof (struct expr *));\n-\n-  compute_hash_table (1);\n-}\n-\n-/* Allocate space for the expression hash table.\n-   N_INSNS is the number of instructions in the function.\n-   It is used to determine the number of buckets to use.  */\n-\n-static void\n-alloc_expr_hash_table (n_insns)\n-     unsigned int n_insns;\n-{\n-  int n;\n-\n-  expr_hash_table_size = n_insns / 2;\n-  /* Make sure the amount is usable.  */\n-  if (expr_hash_table_size < 11)\n-    expr_hash_table_size = 11;\n+  table->size = n_insns / 4;\n+  if (table->size < 11)\n+    table->size = 11;\n \n   /* Attempt to maintain efficient use of hash table.\n      Making it an odd number is simplest for now.\n      ??? Later take some measurements.  */\n-  expr_hash_table_size |= 1;\n-  n = expr_hash_table_size * sizeof (struct expr *);\n-  expr_hash_table = (struct expr **) gmalloc (n);\n+  table->size |= 1;\n+  n = table->size * sizeof (struct expr *);\n+  table->table = (struct expr **) gmalloc (n);\n+  table->set_p = set_p;\n }\n \n-/* Free things allocated by alloc_expr_hash_table.  */\n+/* Free things allocated by alloc_hash_table.  */\n \n static void\n-free_expr_hash_table ()\n+free_hash_table (table)\n+     struct hash_table *table;\n {\n-  free (expr_hash_table);\n+  free (table->table);\n }\n \n-/* Compute the hash table for doing GCSE.  */\n+/* Compute the hash TABLE for doing copy/const propagation or\n+   expression hash table.  */\n \n static void\n-compute_expr_hash_table ()\n+compute_hash_table (table)\n+    struct hash_table *table;\n {\n   /* Initialize count of number of entries in hash table.  */\n-  n_exprs = 0;\n-  memset ((char *) expr_hash_table, 0,\n-\t  expr_hash_table_size * sizeof (struct expr *));\n+  table->n_elems = 0;\n+  memset ((char *) table->table, 0,\n+\t  table->size * sizeof (struct expr *));\n \n-  compute_hash_table (0);\n+  compute_hash_table_work (table);\n }\n \f\n /* Expression tracking support.  */\n \n-/* Lookup pattern PAT in the expression table.\n+/* Lookup pattern PAT in the expression TABLE.\n    The result is a pointer to the table entry, or NULL if not found.  */\n \n static struct expr *\n-lookup_expr (pat)\n+lookup_expr (pat, table)\n      rtx pat;\n+     struct hash_table *table;\n {\n   int do_not_record_p;\n   unsigned int hash = hash_expr (pat, GET_MODE (pat), &do_not_record_p,\n-\t\t\t\t expr_hash_table_size);\n+\t\t\t\t table->size);\n   struct expr *expr;\n \n   if (do_not_record_p)\n     return NULL;\n \n-  expr = expr_hash_table[hash];\n+  expr = table->table[hash];\n \n   while (expr && ! expr_equiv_p (expr->expr, pat))\n     expr = expr->next_same_hash;\n \n   return expr;\n }\n \n-/* Lookup REGNO in the set table.  If PAT is non-NULL look for the entry that\n+/* Lookup REGNO in the set TABLE.  If PAT is non-NULL look for the entry that\n    matches it, otherwise return the first entry for REGNO.  The result is a\n    pointer to the table entry, or NULL if not found.  */\n \n static struct expr *\n-lookup_set (regno, pat)\n+lookup_set (regno, pat, table)\n      unsigned int regno;\n      rtx pat;\n+     struct hash_table *table;\n {\n-  unsigned int hash = hash_set (regno, set_hash_table_size);\n+  unsigned int hash = hash_set (regno, table->size);\n   struct expr *expr;\n \n-  expr = set_hash_table[hash];\n+  expr = table->table[hash];\n \n   if (pat)\n     {\n@@ -3091,7 +3050,8 @@ free_avail_expr_mem ()\n /* Compute the set of available expressions generated in each basic block.  */\n \n static void\n-compute_ae_gen ()\n+compute_ae_gen (expr_hash_table)\n+     struct hash_table *expr_hash_table;\n {\n   unsigned int i;\n   struct expr *expr;\n@@ -3101,8 +3061,8 @@ compute_ae_gen ()\n      This is all we have to do because an expression is not recorded if it\n      is not available, and the only expressions we want to work with are the\n      ones that are recorded.  */\n-  for (i = 0; i < expr_hash_table_size; i++)\n-    for (expr = expr_hash_table[i]; expr != 0; expr = expr->next_same_hash)\n+  for (i = 0; i < expr_hash_table->size; i++)\n+    for (expr = expr_hash_table->table[i]; expr != 0; expr = expr->next_same_hash)\n       for (occr = expr->avail_occr; occr != 0; occr = occr->next)\n \tSET_BIT (ae_gen[BLOCK_NUM (occr->insn)], expr->bitmap_index);\n }\n@@ -3173,16 +3133,17 @@ expr_killed_p (x, bb)\n /* Compute the set of available expressions killed in each basic block.  */\n \n static void\n-compute_ae_kill (ae_gen, ae_kill)\n+compute_ae_kill (ae_gen, ae_kill, expr_hash_table)\n      sbitmap *ae_gen, *ae_kill;\n+     struct hash_table *expr_hash_table;\n {\n   basic_block bb;\n   unsigned int i;\n   struct expr *expr;\n \n   FOR_EACH_BB (bb)\n-    for (i = 0; i < expr_hash_table_size; i++)\n-      for (expr = expr_hash_table[i]; expr; expr = expr->next_same_hash)\n+    for (i = 0; i < expr_hash_table->size; i++)\n+      for (expr = expr_hash_table->table[i]; expr; expr = expr->next_same_hash)\n \t{\n \t  /* Skip EXPR if generated in this block.  */\n \t  if (TEST_BIT (ae_gen[bb->index], expr->bitmap_index))\n@@ -3637,7 +3598,7 @@ classic_gcse ()\n \n \t      if (want_to_gcse_p (src)\n \t\t  /* Is the expression recorded?  */\n-\t\t  && ((expr = lookup_expr (src)) != NULL)\n+\t\t  && ((expr = lookup_expr (src, &expr_hash_table)) != NULL)\n \t\t  /* Is the expression available [at the start of the\n \t\t     block]?  */\n \t\t  && TEST_BIT (ae_in[bb->index], expr->bitmap_index)\n@@ -3670,27 +3631,26 @@ one_classic_gcse_pass (pass)\n   gcse_subst_count = 0;\n   gcse_create_count = 0;\n \n-  alloc_expr_hash_table (max_cuid);\n+  alloc_hash_table (max_cuid, &expr_hash_table, 0);\n   alloc_rd_mem (last_basic_block, max_cuid);\n-  compute_expr_hash_table ();\n+  compute_hash_table (&expr_hash_table);\n   if (gcse_file)\n-    dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n-\t\t     expr_hash_table_size, n_exprs);\n+    dump_hash_table (gcse_file, \"Expression\", &expr_hash_table);\n \n-  if (n_exprs > 0)\n+  if (expr_hash_table.n_elems > 0)\n     {\n       compute_kill_rd ();\n       compute_rd ();\n-      alloc_avail_expr_mem (last_basic_block, n_exprs);\n-      compute_ae_gen ();\n-      compute_ae_kill (ae_gen, ae_kill);\n+      alloc_avail_expr_mem (last_basic_block, expr_hash_table.n_elems);\n+      compute_ae_gen (&expr_hash_table);\n+      compute_ae_kill (ae_gen, ae_kill, &expr_hash_table);\n       compute_available (ae_gen, ae_kill, ae_out, ae_in);\n       changed = classic_gcse ();\n       free_avail_expr_mem ();\n     }\n \n   free_rd_mem ();\n-  free_expr_hash_table ();\n+  free_hash_table (&expr_hash_table);\n \n   if (gcse_file)\n     {\n@@ -3882,7 +3842,7 @@ compute_transp (x, indx, bmap, set_p)\n static void\n compute_cprop_data ()\n {\n-  compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, 1);\n+  compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, &set_hash_table);\n   compute_available (cprop_pavloc, cprop_absaltered,\n \t\t     cprop_avout, cprop_avin);\n }\n@@ -4027,7 +3987,7 @@ find_avail_set (regno, insn)\n   while (1)\n     {\n       rtx src;\n-      struct expr *set = lookup_set (regno, NULL_RTX);\n+      struct expr *set = lookup_set (regno, NULL_RTX, &set_hash_table);\n \n       /* Find a set that is available at the start of the block\n \t which contains INSN.  */\n@@ -4443,22 +4403,21 @@ one_cprop_pass (pass, alter_jumps)\n \n   local_cprop_pass (alter_jumps);\n \n-  alloc_set_hash_table (max_cuid);\n-  compute_set_hash_table ();\n+  alloc_hash_table (max_cuid, &set_hash_table, 1);\n+  compute_hash_table (&set_hash_table);\n   if (gcse_file)\n-    dump_hash_table (gcse_file, \"SET\", set_hash_table, set_hash_table_size,\n-\t\t     n_sets);\n-  if (n_sets > 0)\n+    dump_hash_table (gcse_file, \"SET\", &set_hash_table);\n+  if (set_hash_table.n_elems > 0)\n     {\n-      alloc_cprop_mem (last_basic_block, n_sets);\n+      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n       compute_cprop_data ();\n       changed = cprop (alter_jumps);\n       if (alter_jumps)\n \tchanged |= bypass_conditional_jumps ();\n       free_cprop_mem ();\n     }\n \n-  free_set_hash_table ();\n+  free_hash_table (&set_hash_table);\n \n   if (gcse_file)\n     {\n@@ -4487,7 +4446,7 @@ find_bypass_set (regno, bb)\n   for (;;)\n     {\n       rtx src;\n-      struct expr *set = lookup_set (regno, NULL_RTX);\n+      struct expr *set = lookup_set (regno, NULL_RTX, &set_hash_table);\n \n       while (set)\n \t{\n@@ -4762,16 +4721,16 @@ compute_pre_data ()\n   basic_block bb;\n   unsigned int ui;\n \n-  compute_local_properties (transp, comp, antloc, 0);\n+  compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   sbitmap_vector_zero (ae_kill, last_basic_block);\n \n   /* Collect expressions which might trap.  */\n-  trapping_expr = sbitmap_alloc (n_exprs);\n+  trapping_expr = sbitmap_alloc (expr_hash_table.n_elems);\n   sbitmap_zero (trapping_expr);\n-  for (ui = 0; ui < expr_hash_table_size; ui++)\n+  for (ui = 0; ui < expr_hash_table.size; ui++)\n     {\n       struct expr *e;\n-      for (e = expr_hash_table[ui]; e != NULL; e = e->next_same_hash)\n+      for (e = expr_hash_table.table[ui]; e != NULL; e = e->next_same_hash)\n \tif (may_trap_p (e->expr))\n \t  SET_BIT (trapping_expr, e->bitmap_index);\n     }\n@@ -4802,7 +4761,7 @@ compute_pre_data ()\n       sbitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n     }\n \n-  edge_list = pre_edge_lcm (gcse_file, n_exprs, transp, comp, antloc,\n+  edge_list = pre_edge_lcm (gcse_file, expr_hash_table.n_elems, transp, comp, antloc,\n \t\t\t    ae_kill, &pre_insert_map, &pre_delete_map);\n   sbitmap_vector_free (antloc);\n   antloc = NULL;\n@@ -5075,7 +5034,7 @@ pre_edge_insert (edge_list, index_map)\n \n   set_size = pre_insert_map[0]->size;\n   num_edges = NUM_EDGES (edge_list);\n-  inserted = sbitmap_vector_alloc (num_edges, n_exprs);\n+  inserted = sbitmap_vector_alloc (num_edges, expr_hash_table.n_elems);\n   sbitmap_vector_zero (inserted, num_edges);\n \n   for (e = 0; e < num_edges; e++)\n@@ -5087,7 +5046,7 @@ pre_edge_insert (edge_list, index_map)\n \t{\n \t  SBITMAP_ELT_TYPE insert = pre_insert_map[e]->elms[i];\n \n-\t  for (j = indx; insert && j < n_exprs; j++, insert >>= 1)\n+\t  for (j = indx; insert && j < (int) expr_hash_table.n_elems; j++, insert >>= 1)\n \t    if ((insert & 1) != 0 && index_map[j]->reaching_reg != NULL_RTX)\n \t      {\n \t\tstruct expr *expr = index_map[j];\n@@ -5192,8 +5151,8 @@ pre_insert_copies ()\n      ??? The current algorithm is rather brute force.\n      Need to do some profiling.  */\n \n-  for (i = 0; i < expr_hash_table_size; i++)\n-    for (expr = expr_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+  for (i = 0; i < expr_hash_table.size; i++)\n+    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       {\n \t/* If the basic block isn't reachable, PPOUT will be TRUE.  However,\n \t   we don't want to insert a copy here because the expression may not\n@@ -5280,8 +5239,8 @@ pre_delete ()\n   struct occr *occr;\n \n   changed = 0;\n-  for (i = 0; i < expr_hash_table_size; i++)\n-    for (expr = expr_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+  for (i = 0; i < expr_hash_table.size; i++)\n+    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       {\n \tint indx = expr->bitmap_index;\n \n@@ -5360,9 +5319,9 @@ pre_gcse ()\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) xcalloc (n_exprs, sizeof (struct expr *));\n-  for (i = 0; i < expr_hash_table_size; i++)\n-    for (expr = expr_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+  index_map = (struct expr **) xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  for (i = 0; i < expr_hash_table.size; i++)\n+    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n   /* Reset bitmap used to track which insns are redundant.  */\n@@ -5405,20 +5364,19 @@ one_pre_gcse_pass (pass)\n   gcse_subst_count = 0;\n   gcse_create_count = 0;\n \n-  alloc_expr_hash_table (max_cuid);\n+  alloc_hash_table (max_cuid, &expr_hash_table, 0);\n   add_noreturn_fake_exit_edges ();\n   if (flag_gcse_lm)\n     compute_ld_motion_mems ();\n \n-  compute_expr_hash_table ();\n+  compute_hash_table (&expr_hash_table);\n   trim_ld_motion_mems ();\n   if (gcse_file)\n-    dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n-\t\t     expr_hash_table_size, n_exprs);\n+    dump_hash_table (gcse_file, \"Expression\", &expr_hash_table);\n \n-  if (n_exprs > 0)\n+  if (expr_hash_table.n_elems > 0)\n     {\n-      alloc_pre_mem (last_basic_block, n_exprs);\n+      alloc_pre_mem (last_basic_block, expr_hash_table.n_elems);\n       compute_pre_data ();\n       changed |= pre_gcse ();\n       free_edge_list (edge_list);\n@@ -5427,7 +5385,7 @@ one_pre_gcse_pass (pass)\n \n   free_ldst_mems ();\n   remove_fake_edges ();\n-  free_expr_hash_table ();\n+  free_hash_table (&expr_hash_table);\n \n   if (gcse_file)\n     {\n@@ -5516,8 +5474,8 @@ compute_transpout ()\n       if (GET_CODE (bb->end) != CALL_INSN)\n \tcontinue;\n \n-      for (i = 0; i < expr_hash_table_size; i++)\n-\tfor (expr = expr_hash_table[i]; expr ; expr = expr->next_same_hash)\n+      for (i = 0; i < expr_hash_table.size; i++)\n+\tfor (expr = expr_hash_table.table[i]; expr ; expr = expr->next_same_hash)\n \t  if (GET_CODE (expr->expr) == MEM)\n \t    {\n \t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n@@ -5932,7 +5890,7 @@ compute_code_hoist_vbeinout ()\n static void\n compute_code_hoist_data ()\n {\n-  compute_local_properties (transp, comp, antloc, 0);\n+  compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n   dominators = calculate_dominance_info (CDI_DOMINATORS);\n@@ -6019,9 +5977,9 @@ hoist_code ()\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) xcalloc (n_exprs, sizeof (struct expr *));\n-  for (i = 0; i < expr_hash_table_size; i++)\n-    for (expr = expr_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+  index_map = (struct expr **) xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  for (i = 0; i < expr_hash_table.size; i++)\n+    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n   /* Walk over each basic block looking for potentially hoistable\n@@ -6175,21 +6133,20 @@ one_code_hoisting_pass ()\n {\n   int changed = 0;\n \n-  alloc_expr_hash_table (max_cuid);\n-  compute_expr_hash_table ();\n+  alloc_hash_table (max_cuid, &expr_hash_table, 0);\n+  compute_hash_table (&expr_hash_table);\n   if (gcse_file)\n-    dump_hash_table (gcse_file, \"Code Hosting Expressions\", expr_hash_table,\n-\t\t     expr_hash_table_size, n_exprs);\n+    dump_hash_table (gcse_file, \"Code Hosting Expressions\", &expr_hash_table);\n \n-  if (n_exprs > 0)\n+  if (expr_hash_table.n_elems > 0)\n     {\n-      alloc_code_hoist_mem (last_basic_block, n_exprs);\n+      alloc_code_hoist_mem (last_basic_block, expr_hash_table.n_elems);\n       compute_code_hoist_data ();\n       hoist_code ();\n       free_code_hoist_mem ();\n     }\n \n-  free_expr_hash_table ();\n+  free_hash_table (&expr_hash_table);\n \n   return changed;\n }\n@@ -6509,9 +6466,9 @@ trim_ld_motion_mems ()\n \n \t  del = 1;\n \t  /* Delete if we cannot find this mem in the expression list.  */\n-\t  for (i = 0; i < expr_hash_table_size && del; i++)\n+\t  for (i = 0; i < expr_hash_table.size && del; i++)\n \t    {\n-\t      for (expr = expr_hash_table[i];\n+\t      for (expr = expr_hash_table.table[i];\n \t\t   expr != NULL;\n \t\t   expr = expr->next_same_hash)\n \t\tif (expr_equiv_p (expr->expr, ptr->pattern))"}]}