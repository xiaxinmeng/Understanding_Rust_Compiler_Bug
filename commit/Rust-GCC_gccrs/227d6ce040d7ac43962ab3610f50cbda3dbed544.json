{"sha": "227d6ce040d7ac43962ab3610f50cbda3dbed544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI3ZDZjZTA0MGQ3YWM0Mzk2MmFiMzYxMGY1MGNiZGEzZGJlZDU0NA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-06-17T01:56:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-06-17T01:56:31Z"}, "message": "emit-rtl.c (operand_subword): Tighten checks for when it is safe to safe to extract a subword out of a REG.\n\n        * emit-rtl.c (operand_subword): Tighten checks for when it is safe\n        to safe to extract a subword out of a REG.\n\nFrom-SVN: r27564", "tree": {"sha": "a570b046814dba585fb23c24779f923df7ddb1ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a570b046814dba585fb23c24779f923df7ddb1ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/227d6ce040d7ac43962ab3610f50cbda3dbed544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227d6ce040d7ac43962ab3610f50cbda3dbed544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227d6ce040d7ac43962ab3610f50cbda3dbed544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227d6ce040d7ac43962ab3610f50cbda3dbed544/comments", "author": null, "committer": null, "parents": [{"sha": "ff77e80cf8aed5b75c76ac943c58e5cb9958b120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff77e80cf8aed5b75c76ac943c58e5cb9958b120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff77e80cf8aed5b75c76ac943c58e5cb9958b120"}], "stats": {"total": 34, "additions": 31, "deletions": 3}, "files": [{"sha": "f0608fcd84983cdb26b84f695aa5cdfb52a822b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227d6ce040d7ac43962ab3610f50cbda3dbed544/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227d6ce040d7ac43962ab3610f50cbda3dbed544/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=227d6ce040d7ac43962ab3610f50cbda3dbed544", "patch": "@@ -1,3 +1,8 @@\n+Thu Jun 17 02:54:30 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* emit-rtl.c (operand_subword): Tighten checks for when it is safe\n+\tto safe to extract a subword out of a REG.\n+\n Thu Jun 17 01:45:24 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.md (mulsi3): Don't add a no-op move at the end."}, {"sha": "f1caea7d60d0bce2d1aae1c64c174d5fb5c493da", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227d6ce040d7ac43962ab3610f50cbda3dbed544/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227d6ce040d7ac43962ab3610f50cbda3dbed544/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=227d6ce040d7ac43962ab3610f50cbda3dbed544", "patch": "@@ -1196,10 +1196,33 @@ operand_subword (op, i, validate_address, mode)\n   /* If OP is a REG or SUBREG, we can handle it very simply.  */\n   if (GET_CODE (op) == REG)\n     {\n-      /* If the register is not valid for MODE, return 0.  If we don't\n-\t do this, there is no way to fix up the resulting REG later.  */\n+      /* ??? There is a potential problem with this code.  It does not\n+\t properly handle extractions of a subword from a hard register\n+\t that is larger than word_mode.  Presumably the check for\n+\t HARD_REGNO_MODE_OK catches these most of these cases.  */\n+\n+      /* If OP is a hard register, but OP + I is not a hard register,\n+\t then extracting a subword is impossible.\n+\n+\t For example, consider if OP is the last hard register and it is\n+\t larger than word_mode.  If we wanted word N (for N > 0) because a\n+\t part of that hard register was known to contain a useful value,\n+\t then OP + I would refer to a pseudo, not the hard register we\n+\t actually wanted.  */\n+      if (REGNO (op) < FIRST_PSEUDO_REGISTER\n+\t  && REGNO (op) + i >= FIRST_PSEUDO_REGISTER)\n+\treturn 0;\n+\n+      /* If the register is not valid for MODE, return 0.  Note we\n+\t have to check both OP and OP + I since they may refer to\n+\t different parts of the register file.\n+\n+\t Consider if OP refers to the last 96bit FP register and we want\n+\t subword 3 because that subword is known to contain a value we\n+\t needed.  */\n       if (REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t  && ! HARD_REGNO_MODE_OK (REGNO (op) + i, word_mode))\n+\t  && (! HARD_REGNO_MODE_OK (REGNO (op), word_mode)\n+\t      || ! HARD_REGNO_MODE_OK (REGNO (op) + i, word_mode)))\n \treturn 0;\n       else if (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t       || (REG_FUNCTION_VALUE_P (op)"}]}