{"sha": "fe53b3ddeca7f359e9121b7f503f7aae4c55abd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU1M2IzZGRlY2E3ZjM1OWU5MTIxYjdmNTAzZjdhYWU0YzU1YWJkNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-21T20:24:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-21T20:24:17Z"}, "message": "Better error message for shift context types.\n\nFix shift of floating point constant to generate constant.\n\nFrom-SVN: r179057", "tree": {"sha": "a917549ee1fdb211a2c24e67594548ec46e5ede1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a917549ee1fdb211a2c24e67594548ec46e5ede1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4/comments", "author": null, "committer": null, "parents": [{"sha": "b17e0d797cbaceb03529e3f71ec5aa81a26ba253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17e0d797cbaceb03529e3f71ec5aa81a26ba253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b17e0d797cbaceb03529e3f71ec5aa81a26ba253"}], "stats": {"total": 69, "additions": 59, "deletions": 10}, "files": [{"sha": "bf829b520ee9616f00fc9aae70a2a24066d75f86", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe53b3ddeca7f359e9121b7f503f7aae4c55abd4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fe53b3ddeca7f359e9121b7f503f7aae4c55abd4", "patch": "@@ -5671,6 +5671,50 @@ Binary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \treturn Expression::make_string(left_string + right_string, location);\n     }\n \n+  // Special case for shift of a floating point constant.\n+  if (op == OPERATOR_LSHIFT || op == OPERATOR_RSHIFT)\n+    {\n+      mpfr_t left_val;\n+      mpfr_init(left_val);\n+      Type* left_type;\n+      mpz_t right_val;\n+      mpz_init(right_val);\n+      Type* right_type;\n+      if (left->float_constant_value(left_val, &left_type)\n+\t  && right->integer_constant_value(false, right_val, &right_type)\n+\t  && mpfr_integer_p(left_val)\n+\t  && (left_type == NULL\n+\t      || left_type->is_abstract()\n+\t      || left_type->integer_type() != NULL))\n+\t{\n+\t  mpz_t left_int;\n+\t  mpz_init(left_int);\n+\t  mpfr_get_z(left_int, left_val, GMP_RNDN);\n+\n+\t  mpz_t val;\n+\t  mpz_init(val);\n+\n+\t  Expression* ret = NULL;\n+\t  if (Binary_expression::eval_integer(op, left_type, left_int,\n+\t\t\t\t\t      right_type, right_val,\n+\t\t\t\t\t      location, val))\n+\t    ret = Expression::make_integer(&val, left_type, location);\n+\n+\t  mpz_clear(left_int);\n+\t  mpz_clear(val);\n+\n+\t  if (ret != NULL)\n+\t    {\n+\t      mpfr_clear(left_val);\n+\t      mpz_clear(right_val);\n+\t      return ret;\n+\t    }\n+\t}\n+\n+      mpfr_clear(left_val);\n+      mpz_clear(right_val);\n+    }\n+\n   return this;\n }\n \n@@ -5939,14 +5983,8 @@ Binary_expression::do_determine_type(const Type_context* context)\n   // Set the context for the left hand operand.\n   if (is_shift_op)\n     {\n-      // The right hand operand plays no role in determining the type\n-      // of the left hand operand.  A shift of an abstract integer in\n-      // a string context gets special treatment, which may be a\n-      // language bug.\n-      if (subcontext.type != NULL\n-\t  && subcontext.type->is_string_type()\n-\t  && tleft->is_abstract())\n-\terror_at(this->location(), \"shift of non-integer operand\");\n+      // The right hand operand of a shift plays no role in\n+      // determining the type of the left hand operand.\n     }\n   else if (!tleft->is_abstract())\n     subcontext.type = tleft;\n@@ -5979,10 +6017,21 @@ Binary_expression::do_determine_type(const Type_context* context)\n \n   this->left_->determine_type(&subcontext);\n \n-  // The context for the right hand operand is the same as for the\n-  // left hand operand, except for a shift operator.\n   if (is_shift_op)\n     {\n+      // We may have inherited an unusable type for the shift operand.\n+      // Give a useful error if that happened.\n+      if (tleft->is_abstract()\n+\t  && subcontext.type != NULL\n+\t  && (this->left_->type()->integer_type() == NULL\n+\t      || (subcontext.type->integer_type() == NULL\n+\t\t  && subcontext.type->float_type() == NULL\n+\t\t  && subcontext.type->complex_type() == NULL)))\n+\tthis->report_error((\"invalid context-determined non-integer type \"\n+\t\t\t    \"for shift operand\"));\n+\n+      // The context for the right hand operand is the same as for the\n+      // left hand operand, except for a shift operator.\n       subcontext.type = Type::lookup_integer_type(\"uint\");\n       subcontext.may_be_abstract = false;\n     }"}]}