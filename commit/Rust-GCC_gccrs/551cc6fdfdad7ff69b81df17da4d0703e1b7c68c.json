{"sha": "551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUxY2M2ZmRmZGFkN2ZmNjliODFkZjE3ZGE0ZDA3MDNlMWI3YzY4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-04T08:15:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-04T08:15:22Z"}, "message": "alpha.c (some_operand): Accept HIGH.\n\n\t* config/alpha/alpha.c (some_operand): Accept HIGH.\n\t(input_operand): Likewise; accept simple references to globals.\n\t(alpha_const_ok_for_letter_p): New, outlined from alpha.h.\n\t(alpha_const_double_ok_for_letter_p): Likewise.\n\t(alpha_extra_constraint): Likewise.\n\t(alpha_preferred_reload_class): Likewise.  Do not force\n\tsymbolic constants to memory.\n\t(alpha_legitimate_address_p): Accept simple references\n\tto small_symbolic_operand.\n\t(alpha_legitimize_address): New arg scratch.  Be prepared to be\n\tcalled when no_new_pseudos.  Emit simple symbolic references.\n\tSplit integers into low, high, and rest.\n\t(alpha_expand_mov): Use alpha_legitimize_address.\n\t(some_small_symbolic_mem_operand): New.\n\t(split_small_symbolic_mem_operand): New.\n\t* config/alpha/alpha-protos.h: Update.\n\t* config/alpha/alpha.h (CONST_OK_FOR_LETTER_P): Out-line.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n\t(EXTRA_CONSTRAINT): Likewise.\n\t(PREFERRED_RELOAD_CLASS): Likewise.\n\t(LEGITIMIZE_ADDRESS): Update for alpha_legitimize_address change.\n\t(PREDICATE_CODES): Update.\n\t* config/alpha/alpha.md: New post-reload splitters to convert\n\tsimplfied symbolic operands to the form that references $29.\n\t(divide expanders): Use emit_move_insn, not gen_movdi_er_high_g.\n\t(movdi_er_nofix, movdi_er_fix): Accept any symbolic operand.\n\nFrom-SVN: r48531", "tree": {"sha": "e88c13ed604cc0ea9b1a2b47638f129faa9c99dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e88c13ed604cc0ea9b1a2b47638f129faa9c99dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/comments", "author": null, "committer": null, "parents": [{"sha": "1eaea05433cd21e35d5b544e2215cdb7bcb389be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eaea05433cd21e35d5b544e2215cdb7bcb389be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eaea05433cd21e35d5b544e2215cdb7bcb389be"}], "stats": {"total": 504, "additions": 364, "deletions": 140}, "files": [{"sha": "044dce3043b91cc487c7c5a1bee32f7d3e40cf06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "patch": "@@ -1,3 +1,32 @@\n+2002-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (some_operand): Accept HIGH.\n+\t(input_operand): Likewise; accept simple references to globals.\n+\t(alpha_const_ok_for_letter_p): New, outlined from alpha.h.\n+\t(alpha_const_double_ok_for_letter_p): Likewise.\n+\t(alpha_extra_constraint): Likewise.\n+\t(alpha_preferred_reload_class): Likewise.  Do not force\n+\tsymbolic constants to memory.\n+\t(alpha_legitimate_address_p): Accept simple references\n+\tto small_symbolic_operand.\n+\t(alpha_legitimize_address): New arg scratch.  Be prepared to be\n+\tcalled when no_new_pseudos.  Emit simple symbolic references.\n+\tSplit integers into low, high, and rest.\n+\t(alpha_expand_mov): Use alpha_legitimize_address.\n+\t(some_small_symbolic_mem_operand): New.\n+\t(split_small_symbolic_mem_operand): New.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (CONST_OK_FOR_LETTER_P): Out-line.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n+\t(EXTRA_CONSTRAINT): Likewise.\n+\t(PREFERRED_RELOAD_CLASS): Likewise.\n+\t(LEGITIMIZE_ADDRESS): Update for alpha_legitimize_address change.\n+\t(PREDICATE_CODES): Update.\n+\t* config/alpha/alpha.md: New post-reload splitters to convert\n+\tsimplfied symbolic operands to the form that references $29.\n+\t(divide expanders): Use emit_move_insn, not gen_movdi_er_high_g.\n+\t(movdi_er_nofix, movdi_er_fix): Accept any symbolic operand.\n+\n 2002-01-03  Richard Henderson  <rth@redhat.com>\n \n \t* local-alloc.c (function_invariant_p): Update commentary."}, {"sha": "2ff035092f2829d5f77f81349ff2e18ea728780c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "patch": "@@ -59,6 +59,7 @@ extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n extern int direct_call_operand PARAMS ((rtx, enum machine_mode));\n extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int some_small_symbolic_mem_operand PARAMS ((rtx, enum machine_mode));\n extern int global_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n@@ -77,6 +78,10 @@ extern int normal_memory_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_no_subreg_operand PARAMS ((rtx, enum machine_mode));\n extern int addition_operation PARAMS ((rtx, enum machine_mode));\n \n+extern bool alpha_const_ok_for_letter_p PARAMS ((HOST_WIDE_INT, int));\n+extern bool alpha_const_double_ok_for_letter_p PARAMS ((rtx, int));\n+extern bool alpha_extra_constraint PARAMS ((rtx, int));\n+\n extern rtx alpha_tablejump_addr_vec PARAMS ((rtx));\n extern rtx alpha_tablejump_best_label PARAMS ((rtx));\n \n@@ -85,11 +90,16 @@ extern rtx alpha_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx alpha_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n \t\t\t\t\t\t    int, int, int));\n \n+extern rtx split_small_symbolic_mem_operand PARAMS ((rtx));\n+\n extern void get_aligned_mem PARAMS ((rtx, rtx *, rtx *));\n extern rtx get_unaligned_address PARAMS ((rtx, int));\n+extern enum reg_class alpha_preferred_reload_class PARAMS ((rtx, \n+\t\t\t\t\t\t\t    enum reg_class));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t     enum machine_mode, \n \t\t\t\t\t\t     rtx, int));\n+\n extern void alpha_set_memflags PARAMS ((rtx, rtx));\n extern rtx alpha_emit_set_const PARAMS ((rtx, enum machine_mode,\n \t\t\t\t\tHOST_WIDE_INT, int));"}, {"sha": "b928609030c92ecda4e3b22ad41e2387676baaf7", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 240, "deletions": 78, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "patch": "@@ -768,7 +768,7 @@ some_operand (op, mode)\n   switch (GET_CODE (op))\n     {\n     case REG:  case MEM:  case CONST_DOUBLE:  case CONST_INT:  case LABEL_REF:\n-    case SYMBOL_REF:  case CONST:\n+    case SYMBOL_REF:  case CONST:  case HIGH:\n       return 1;\n \n     case SUBREG:\n@@ -816,11 +816,22 @@ input_operand (op, mode)\n     case SYMBOL_REF:\n     case CONST:\n       if (TARGET_EXPLICIT_RELOCS)\n-\treturn 0;\n+\t{\n+\t  /* We don't split symbolic operands into something unintelligable\n+\t     until after reload, but we do not wish non-small, non-global\n+\t     symbolic operands to be reconstructed from their high/lo_sum\n+\t     form.  */\n+\t  return (small_symbolic_operand (op, mode)\n+\t\t  || global_symbolic_operand (op, mode));\n+\t}\n \n       /* This handles both the Windows/NT and OSF cases.  */\n       return mode == ptr_mode || mode == DImode;\n \n+    case HIGH:\n+      return (TARGET_EXPLICIT_RELOCS\n+\t      && local_symbolic_operand (XEXP (op, 0), mode));\n+\n     case REG:\n     case ADDRESSOF:\n       return 1;\n@@ -1354,6 +1365,100 @@ addition_operation (op, mode)\n   return 0;\n }\n \n+/* Implements CONST_OK_FOR_LETTER_P.  Return true if the value matches\n+   the range defined for C in [I-P].  */\n+\n+bool\n+alpha_const_ok_for_letter_p (value, c)\n+     HOST_WIDE_INT value;\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case 'I':\n+      /* An unsigned 8 bit constant.  */\n+      return (unsigned HOST_WIDE_INT) value < 0x100;\n+    case 'J':\n+      /* The constant zero.  */\n+      return value == 0;\n+    case 'K':\n+      /* A signed 16 bit constant.  */\n+      return (unsigned HOST_WIDE_INT) (value + 0x8000) < 0x10000;\n+    case 'L':\n+      /* A shifted signed 16 bit constant appropriate for LDAH.  */\n+      return ((value & 0xffff) == 0\n+              && ((value) >> 31 == -1 || value >> 31 == 0));\n+    case 'M':\n+      /* A constant that can be AND'ed with using a ZAP insn.  */\n+      return zap_mask (value);\n+    case 'N':\n+      /* A complemented unsigned 8 bit constant.  */\n+      return (unsigned HOST_WIDE_INT) (~ value) < 0x100;\n+    case 'O':\n+      /* A negated unsigned 8 bit constant.  */\n+      return (unsigned HOST_WIDE_INT) (- value) < 0x100;\n+    case 'P':\n+      /* The constant 1, 2 or 3.  */\n+      return value == 1 || value == 2 || value == 3;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE\n+   matches for C in [GH].  */\n+\n+bool\n+alpha_const_double_ok_for_letter_p (value, c)\n+     rtx value;\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case 'G':\n+      /* The floating point zero constant.  */\n+      return (GET_MODE_CLASS (GET_MODE (value)) == MODE_FLOAT\n+\t      && value == CONST0_RTX (GET_MODE (value)));\n+\n+    case 'H':\n+      /* A valid operand of a ZAP insn.  */\n+      return (GET_MODE (value) == VOIDmode\n+\t      && zap_mask (CONST_DOUBLE_LOW (value))\n+\t      && zap_mask (CONST_DOUBLE_HIGH (value)));\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE\n+   matches for C.  */\n+\n+bool\n+alpha_extra_constraint (value, c)\n+     rtx value;\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case 'Q':\n+      return normal_memory_operand (value, VOIDmode);\n+    case 'R':\n+      return direct_call_operand (value, Pmode);\n+    case 'S':\n+      return (GET_CODE (value) == CONST_INT\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (value) < 64);\n+    case 'T':\n+      return GET_CODE (value) == HIGH;\n+    case 'U':\n+      return TARGET_ABI_UNICOSMK && symbolic_operand (value, VOIDmode);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Return 1 if this function can directly return via $26.  */\n \n int\n@@ -1628,28 +1733,35 @@ alpha_legitimate_address_p (mode, x, strict)\n \treturn true;\n     }\n \n-  /* If we're managing explicit relocations, LO_SUM is valid.  */\n-  else if (TARGET_EXPLICIT_RELOCS && GET_CODE (x) == LO_SUM)\n+  /* If we're managing explicit relocations, LO_SUM is valid, as\n+     are small data symbols.  */\n+  else if (TARGET_EXPLICIT_RELOCS)\n     {\n-      rtx ofs = XEXP (x, 1);\n-      x = XEXP (x, 0);\n-\n-      /* Discard non-paradoxical subregs.  */\n-      if (GET_CODE (x) == SUBREG\n-          && (GET_MODE_SIZE (GET_MODE (x))\n-\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n-\tx = SUBREG_REG (x);\n-\n-      /* Must have a valid base register.  */\n-      if (! (REG_P (x)\n-\t     && (strict\n-\t\t ? STRICT_REG_OK_FOR_BASE_P (x)\n-\t\t : NONSTRICT_REG_OK_FOR_BASE_P (x))))\n-\treturn false;\n-\n-      /* The symbol must be local.  */\n-      if (local_symbolic_operand (ofs, Pmode))\n+      if (small_symbolic_operand (x, Pmode))\n \treturn true;\n+\n+      if (GET_CODE (x) == LO_SUM)\n+\t{\n+\t  rtx ofs = XEXP (x, 1);\n+\t  x = XEXP (x, 0);\n+\n+\t  /* Discard non-paradoxical subregs.  */\n+\t  if (GET_CODE (x) == SUBREG\n+\t      && (GET_MODE_SIZE (GET_MODE (x))\n+\t\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+\t    x = SUBREG_REG (x);\n+\n+\t  /* Must have a valid base register.  */\n+\t  if (! (REG_P (x)\n+\t\t && (strict\n+\t\t     ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t\t     : NONSTRICT_REG_OK_FOR_BASE_P (x))))\n+\t    return false;\n+\n+\t  /* The symbol must be local.  */\n+\t  if (local_symbolic_operand (ofs, Pmode))\n+\t    return true;\n+\t}\n     }\n \n   return false;\n@@ -1659,9 +1771,9 @@ alpha_legitimate_address_p (mode, x, strict)\n    to be legitimate.  If we find one, return the new, valid address.  */\n \n rtx\n-alpha_legitimize_address (x, oldx, mode)\n+alpha_legitimize_address (x, scratch, mode)\n      rtx x;\n-     rtx oldx ATTRIBUTE_UNUSED;\n+     rtx scratch;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   HOST_WIDE_INT addend;\n@@ -1683,7 +1795,8 @@ alpha_legitimize_address (x, oldx, mode)\n      part of the CONST_INT.  Then load FOO plus any high-order part of the\n      CONST_INT into a register.  Our address is (plus reg low-part-const).\n      This is done to reduce the number of GOT entries.  */\n-  if (GET_CODE (x) == CONST\n+  if (!no_new_pseudos\n+      && GET_CODE (x) == CONST\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n     {\n@@ -1695,7 +1808,8 @@ alpha_legitimize_address (x, oldx, mode)\n   /* If we have a (plus reg const), emit the load as in (2), then add\n      the two registers, and finally generate (plus reg low-part-const) as\n      our address.  */\n-  if (GET_CODE (x) == PLUS\n+  if (!no_new_pseudos\n+      && GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST\n       && GET_CODE (XEXP (XEXP (x, 1), 0)) == PLUS\n@@ -1711,48 +1825,84 @@ alpha_legitimize_address (x, oldx, mode)\n   /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */\n   if (TARGET_EXPLICIT_RELOCS && symbolic_operand (x, Pmode))\n     {\n-      rtx scratch;\n       if (local_symbolic_operand (x, Pmode))\n \t{\n \t  if (small_symbolic_operand (x, Pmode))\n-\t    scratch = pic_offset_table_rtx;\n+\t    return x;\n \t  else\n \t    {\n-\t      rtx insn, tmp;\n-\n-\t      scratch = gen_reg_rtx (Pmode);\n-\n-\t      tmp = gen_rtx_HIGH (Pmode, x);\n-\t      tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n-              insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n-\t\t\t\t\t\t    REG_NOTES (insn));\n+\t      if (!no_new_pseudos)\n+\t        scratch = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, scratch,\n+\t\t\t\t      gen_rtx_HIGH (Pmode, x)));\n+\t      return gen_rtx_LO_SUM (Pmode, scratch, x);\n \t    }\n-\n-\t  return gen_rtx_LO_SUM (Pmode, scratch, x);\n-\t}\n-      else\n-\t{\n-\t  scratch = gen_reg_rtx (Pmode);\n-\t  emit_insn (gen_movdi_er_high_g (scratch, pic_offset_table_rtx,\n-\t\t\t\t\t  x, const0_rtx));\n-\t  /* ??? FIXME: Tag the use of scratch with a lituse.  */\n-\t  return scratch;\n \t}\n     }\n \n   return NULL;\n \n  split_addend:\n   {\n-    HOST_WIDE_INT lowpart = (addend & 0xffff) - 2 * (addend & 0x8000);\n-    HOST_WIDE_INT highpart = addend - lowpart;\n-    x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (highpart),\n-\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-    return plus_constant (x, lowpart);\n+    HOST_WIDE_INT low, high;\n+\n+    low = ((addend & 0xffff) ^ 0x8000) - 0x8000;\n+    addend -= low;\n+    high = ((addend & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+    addend -= high;\n+\n+    if (addend)\n+      x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (addend),\n+\t\t\t       (no_new_pseudos ? scratch : NULL_RTX),\n+\t\t\t       1, OPTAB_LIB_WIDEN);\n+    if (high)\n+      x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (high),\n+\t\t\t       (no_new_pseudos ? scratch : NULL_RTX),\n+\t\t\t       1, OPTAB_LIB_WIDEN);\n+\n+    return plus_constant (x, low);\n   }\n }\n \n+/* For TARGET_EXPLICIT_RELOCS, we don't obfuscate a SYMBOL_REF to a\n+   small symbolic operand until after reload.  At which point we need\n+   to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))\n+   so that sched2 has the proper dependency information.  */\n+\n+int\n+some_small_symbolic_mem_operand (x, mode)\n+     rtx x;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  /* Get rid of SIGN_EXTEND, etc.  */\n+  while (GET_RTX_CLASS (GET_CODE (x)) == '1')\n+    x = XEXP (x, 0);\n+\n+  return (GET_CODE (x) == MEM\n+\t  && small_symbolic_operand (XEXP (x, 0), Pmode));\n+}\n+\n+rtx\n+split_small_symbolic_mem_operand (x)\n+     rtx x;\n+{\n+  rtx *p;\n+\n+  if (GET_CODE (x) == MEM)\n+    {\n+      rtx tmp = gen_rtx_LO_SUM (DImode, pic_offset_table_rtx, XEXP (x, 0));\n+      return replace_equiv_address (x, tmp);\n+    }\n+\n+  x = copy_rtx (x);\n+  p = &x;\n+  while (GET_RTX_CLASS (GET_CODE (*p)) == '1')\n+    p = &XEXP (*p, 0);\n+\n+  *p = split_small_symbolic_mem_operand (*p);\n+  return x;\n+}\n+\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and return the new rtx.  */\n    \n@@ -1886,6 +2036,39 @@ get_unaligned_address (ref, extra_offset)\n   return plus_constant (base, offset + extra_offset);\n }\n \n+/* On the Alpha, all (non-symbolic) constants except zero go into\n+   a floating-point register via memory.  Note that we cannot \n+   return anything that is not a subset of CLASS, and that some\n+   symbolic constants cannot be dropped to memory.  */\n+\n+enum reg_class\n+alpha_preferred_reload_class(x, class)\n+     rtx x;\n+     enum reg_class class;\n+{\n+  /* Zero is present in any register class.  */\n+  if (x == CONST0_RTX (GET_MODE (x)))\n+    return class;\n+\n+  /* These sorts of constants we can easily drop to memory.  */\n+  if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+    {\n+      if (class == FLOAT_REGS)\n+\treturn NO_REGS;\n+      if (class == ALL_REGS)\n+\treturn GENERAL_REGS;\n+      return class;\n+    }\n+\n+  /* All other kinds of constants should not (and in the case of HIGH\n+     cannot) be dropped to memory -- instead we use a GENERAL_REGS\n+     secondary reload.  */\n+  if (CONSTANT_P (x))\n+    return (class == ALL_REGS ? GENERAL_REGS : class);\n+\n+  return class;\n+}\n+\n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n    QImode and HImode from an aligned address to a general register\n@@ -2294,36 +2477,15 @@ alpha_expand_mov (mode, operands)\n       && ! reg_or_0_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n-  if (TARGET_EXPLICIT_RELOCS && symbolic_operand (operands[1], mode))\n+  /* Allow legitimize_address to perform some simplifications.  */\n+  if (symbolic_operand (operands[1], mode))\n     {\n-      if (local_symbolic_operand (operands[1], mode))\n+      rtx tmp = alpha_legitimize_address (operands[1], operands[0], mode);\n+      if (tmp)\n \t{\n-\t  rtx scratch;\n-\n-\t  if (small_symbolic_operand (operands[1], Pmode))\n-\t    scratch = pic_offset_table_rtx;\n-\t  else\n-\t    {\n-\t      rtx insn, tmp;\n-\n-\t      scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n-\n-\t      tmp = gen_rtx_HIGH (Pmode, operands[1]);\n-\t      tmp = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp);\n-              insn = emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp));\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, tmp,\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t    }\n-\n-          operands[1] = gen_rtx_LO_SUM (Pmode, scratch, operands[1]);\n+\t  operands[1] = tmp;\n \t  return false;\n \t}\n-      else\n-\t{\n-\t  emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n-\t\t\t\t\t  operands[1], const0_rtx));\n-\t  return true;\n-\t}\n     }\n \n   /* Early out for non-constants and valid constants.  */"}, {"sha": "e2d8b3820d146acf53e8f56d553c8d7eb7e9115a", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "patch": "@@ -812,31 +812,15 @@ enum reg_class {\n    `O' is used for negated 8-bit constants.\n    `P' is used for the constants 1, 2 and 3.  */\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'I' ? (unsigned HOST_WIDE_INT) (VALUE) < 0x100\t\\\n-   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\t\\\n-   : (C) == 'K' ? (unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000\t\\\n-   : (C) == 'L' ? (((VALUE) & 0xffff) == 0\t\t\t\\\n-                  && (((VALUE)) >> 31 == -1 || (VALUE) >> 31 == 0)) \\\n-   : (C) == 'M' ? zap_mask (VALUE)\t\t\t\t\\\n-   : (C) == 'N' ? (unsigned HOST_WIDE_INT) (~ (VALUE)) < 0x100\t\\\n-   : (C) == 'O' ? (unsigned HOST_WIDE_INT) (- (VALUE)) < 0x100\t\\\n-   : (C) == 'P' ? (VALUE) == 1 || (VALUE) == 2 || (VALUE) == 3\t\\\n-   : 0)\n+#define CONST_OK_FOR_LETTER_P   alpha_const_ok_for_letter_p\n \n /* Similar, but for floating or large integer constants, and defining letters\n    G and H.   Here VALUE is the CONST_DOUBLE rtx itself.\n \n    For Alpha, `G' is the floating-point constant zero.  `H' is a CONST_DOUBLE\n    that is the operand of a ZAP insn.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\\\n-  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n-\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n-   : (C) == 'H' ? (GET_MODE (VALUE) == VOIDmode\t\t\t\t\\\n-\t\t   && zap_mask (CONST_DOUBLE_LOW (VALUE))\t\t\\\n-\t\t   && zap_mask (CONST_DOUBLE_HIGH (VALUE)))\t\t\\\n-   : 0)\n+#define CONST_DOUBLE_OK_FOR_LETTER_P  alpha_const_double_ok_for_letter_p\n \n /* Optional extra constraints for this machine.\n \n@@ -848,31 +832,18 @@ enum reg_class {\n \n    'S' is a 6-bit constant (valid for a shift insn).  \n \n+   'T' is a HIGH.\n+\n    'U' is a symbolic operand.  */\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ? normal_memory_operand (OP, VOIDmode)\t\t\t\\\n-   : (C) == 'R' ? direct_call_operand (OP, Pmode)\t\t\\\n-   : (C) == 'S' ? (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n-\t\t   && (unsigned HOST_WIDE_INT) INTVAL (OP) < 64)\t\\\n-   : (C) == 'T' ? GET_CODE (OP) == HIGH\t\t\t\t\t\\\n-   : (TARGET_ABI_UNICOSMK && (C) == 'U')\t\t\t\t\\\n-\t\t? symbolic_operand (OP, VOIDmode)\t\t\t\\\n-   : 0)\n+#define EXTRA_CONSTRAINT  alpha_extra_constraint\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-\n-   On the Alpha, all constants except zero go into a floating-point\n-   register via memory.  */\n+   in some cases it is preferable to use a more restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n-  (CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n-   ? ((CLASS) == FLOAT_REGS || (CLASS) == NO_REGS ? NO_REGS\t\t\\\n-      : (CLASS) == ALL_REGS ? GENERAL_REGS : (CLASS))\t\t\t\\\n-   : (CLASS))\n+#define PREFERRED_RELOAD_CLASS  alpha_preferred_reload_class\n \n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n@@ -1479,14 +1450,14 @@ do {\t\t\t\t\t\t\\\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.  */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  rtx new_x = alpha_legitimize_address (X, OLDX, MODE);\t\\\n-  if (new_x)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      X = new_x;\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  rtx new_x = alpha_legitimize_address (X, NULL_RTX, MODE);\t\\\n+  if (new_x)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      X = new_x;\t\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n } while (0)\n \n /* Try a machine-dependent way of reloading an illegitimate address\n@@ -2117,9 +2088,9 @@ do {\t\t\t\t\t\t\\\n   {\"global_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n+\t\t     SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\t\\\n   {\"some_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t    SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n+\t\t    SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\t\\\n   {\"some_ni_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n   {\"aligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"unaligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n@@ -2130,7 +2101,9 @@ do {\t\t\t\t\t\t\\\n   {\"reg_not_elim_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"reg_no_subreg_operand\", {REG}},\t\t\t\t\t\\\n   {\"addition_operation\", {PLUS}},\t\t\t\t\t\\\n-  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n+  {\"some_small_symbolic_mem_operand\", {MEM, SIGN_EXTEND, ZERO_EXTEND,\t\\\n+\t\t\t\t      FLOAT_EXTEND}},\n \f\n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\"}, {"sha": "31d03c43ad1647d80b5cae78d4f187af9a77b98f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551cc6fdfdad7ff69b81df17da4d0703e1b7c68c/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=551cc6fdfdad7ff69b81df17da4d0703e1b7c68c", "patch": "@@ -649,6 +649,14 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"TARGET_EXPLICIT_RELOCS\"\n   \"ldah %0,%2(%1)\\t\\t!gprelhigh\")\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (high:DI (match_operand:DI 1 \"local_symbolic_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:DI (match_dup 2) (high:DI (match_dup 1))))]\n+  \"operands[2] = pic_offset_table_rtx;\")\n+\n ;; We used to expend quite a lot of effort choosing addq/subq/lda.\n ;; With complications like\n ;;\n@@ -1225,9 +1233,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     default:\n       abort ();\n     }\n-  emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n-\t\t\t\t  gen_rtx_SYMBOL_REF (DImode, str),\n-\t\t\t\t  const0_rtx));\n+  emit_move_insn (operands[0], gen_rtx_SYMBOL_REF (DImode, str));\n }\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1290,9 +1296,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     default:\n       abort ();\n     }\n-  emit_insn (gen_movdi_er_high_g (operands[0], pic_offset_table_rtx,\n-\t\t\t\t  gen_rtx_SYMBOL_REF (DImode, str),\n-\t\t\t\t  const0_rtx));\n+  emit_move_insn (operands[0], gen_rtx_SYMBOL_REF (DImode, str));\n }\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -5459,7 +5463,39 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     return \"lda %0,%2(%1)\\t\\t!gprellow\";\n })\n \n-(define_insn \"movdi_er_high_g\"\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"small_symbolic_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(lo_sum:DI (match_dup 2) (match_dup 1)))]\n+  \"operands[2] = pic_offset_table_rtx;\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"local_symbolic_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:DI (match_dup 2) (high:DI (match_dup 1))))\n+   (set (match_dup 0)\n+\t(lo_sum:DI (match_dup 0) (match_dup 1)))]\n+  \"operands[2] = pic_offset_table_rtx;\")\n+\n+(define_split\n+  [(set (match_operand 0 \"some_small_symbolic_mem_operand\" \"\")\n+\t(match_operand 1 \"\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[0] = split_small_symbolic_mem_operand (operands[0]);\")\n+\n+(define_split\n+  [(set (match_operand 0 \"\" \"\")\n+\t(match_operand 1 \"some_small_symbolic_mem_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = split_small_symbolic_mem_operand (operands[1]);\")\n+\n+(define_insn \"*movdi_er_high_g\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n \t\t    (match_operand:DI 2 \"global_symbolic_operand\" \"\")\n@@ -5469,23 +5505,34 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"ldq %0,%2(%1)\\t\\t!literal\"\n   [(set_attr \"type\" \"ldsym\")])\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"global_symbolic_operand\" \"\"))]\n+  \"TARGET_EXPLICIT_RELOCS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:DI [(match_dup 2)\n+\t\t    (match_dup 1)\n+\t\t    (const_int 0)] UNSPEC_LITERAL))]\n+  \"operands[2] = pic_offset_table_rtx;\")\n+\n (define_insn \"*movdi_er_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,m,rJ,*fJ,Q,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f\"))]\n   \"TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n-   ldah %0,%H1\n+   #\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ild,ist,fcpys,fld,fst\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n \n ;; The 'U' constraint matches symbolic operands on Unicos/Mk. Those should\n ;; have been split up by the rules above but we shouldn't reject the\n@@ -5512,24 +5559,27 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_er_fix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,m,rJ,*fJ,Q,*f,*f,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+\t\t\t\t\"=r,r,r,r,r,r, m, *f,*f, Q, r,*f\")\n+\t(match_operand:DI 1 \"input_operand\"\n+\t\t\t\t\"rJ,K,L,T,s,m,rJ,*fJ, Q,*f,*f, r\"))]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n-   ldah %0,%H1\n+   #\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n \n (define_insn \"*movdi_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")"}]}