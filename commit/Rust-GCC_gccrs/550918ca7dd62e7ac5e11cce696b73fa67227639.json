{"sha": "550918ca7dd62e7ac5e11cce696b73fa67227639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwOTE4Y2E3ZGQ2MmU3YWM1ZTExY2NlNjk2YjczZmE2NzIyNzYzOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-04-16T12:44:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-04-16T12:44:46Z"}, "message": "re PR tree-optimization/39698 (wrong types for vectorized reduction)\n\n2009-04-16  Richard Guenther  <rguenther@suse.de>\n\tIra Rosen  <irar@il.ibm.com>\n\n\tPR tree-optimization/39698\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Use the\n\ttype of the reduction variable.  Only generate the def if\n\tit is needed.\n\n\t* omp-low.c (expand_omp_for_generic): When converting to a pointer\n\tmake sure to first convert to an integer of the same precision.\n\t* tree-vect-loop-manip.c (vect_update_ivs_after_vectorizer): Retain\n\tthe type of the evolution correctly in computing the new\n\tinduction variable base.\n\nCo-Authored-By: Ira Rosen <irar@il.ibm.com>\n\nFrom-SVN: r146180", "tree": {"sha": "6d0cf456ca1d23a6929bcb816d7d099e283934cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d0cf456ca1d23a6929bcb816d7d099e283934cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550918ca7dd62e7ac5e11cce696b73fa67227639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550918ca7dd62e7ac5e11cce696b73fa67227639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550918ca7dd62e7ac5e11cce696b73fa67227639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550918ca7dd62e7ac5e11cce696b73fa67227639/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7"}], "stats": {"total": 81, "additions": 51, "deletions": 30}, "files": [{"sha": "2068c9ce855e59f33ac7d39d3bda798f1fb979c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550918ca7dd62e7ac5e11cce696b73fa67227639", "patch": "@@ -1,3 +1,17 @@\n+2009-04-16  Richard Guenther  <rguenther@suse.de>\n+\tIra Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/39698\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Use the\n+\ttype of the reduction variable.  Only generate the def if\n+\tit is needed.\n+\n+\t* omp-low.c (expand_omp_for_generic): When converting to a pointer\n+\tmake sure to first convert to an integer of the same precision.\n+\t* tree-vect-loop-manip.c (vect_update_ivs_after_vectorizer): Retain\n+\tthe type of the evolution correctly in computing the new\n+\tinduction variable base.\n+\n 2009-04-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/39625"}, {"sha": "0fa938acb2a0bcec07b7289cb93f561257437829", "filename": "gcc/omp-low.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=550918ca7dd62e7ac5e11cce696b73fa67227639", "patch": "@@ -3812,21 +3812,25 @@ expand_omp_for_generic (struct omp_region *region,\n \n   /* Iteration setup for sequential loop goes in L0_BB.  */\n   gsi = gsi_start_bb (l0_bb);\n+  t = istart0;\n   if (bias)\n-    t = fold_convert (type, fold_build2 (MINUS_EXPR, fd->iter_type,\n-\t\t\t\t\t istart0, bias));\n-  else\n-    t = fold_convert (type, istart0);\n+    t = fold_build2 (MINUS_EXPR, fd->iter_type, t, bias);\n+  if (POINTER_TYPE_P (type))\n+    t = fold_convert (lang_hooks.types.type_for_size (TYPE_PRECISION (type),\n+\t\t\t\t\t\t      0), t);\n+  t = fold_convert (type, t);\n   t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE,\n \t\t\t\tfalse, GSI_CONTINUE_LINKING);\n   stmt = gimple_build_assign (fd->loop.v, t);\n   gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n+  t = iend0;\n   if (bias)\n-    t = fold_convert (type, fold_build2 (MINUS_EXPR, fd->iter_type,\n-\t\t\t\t\t iend0, bias));\n-  else\n-    t = fold_convert (type, iend0);\n+    t = fold_build2 (MINUS_EXPR, fd->iter_type, t, bias);\n+  if (POINTER_TYPE_P (type))\n+    t = fold_convert (lang_hooks.types.type_for_size (TYPE_PRECISION (type),\n+\t\t\t\t\t\t      0), t);\n+  t = fold_convert (type, t);\n   iend = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t   false, GSI_CONTINUE_LINKING);\n   if (fd->collapse > 1)"}, {"sha": "56f9bba513d9797096ea02cdf017e04de5b19430", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=550918ca7dd62e7ac5e11cce696b73fa67227639", "patch": "@@ -1593,7 +1593,8 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       tree access_fn = NULL;\n       tree evolution_part;\n       tree init_expr;\n-      tree step_expr;\n+      tree step_expr, off;\n+      tree type;\n       tree var, ni, ni_name;\n       gimple_stmt_iterator last_gsi;\n \n@@ -1623,6 +1624,11 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \n       access_fn = analyze_scalar_evolution (loop, PHI_RESULT (phi)); \n       gcc_assert (access_fn);\n+      /* We can end up with an access_fn like\n+           (short int) {(short unsigned int) i_49, +, 1}_1\n+\t for further analysis we need to strip the outer cast but we\n+\t need to preserve the original type.  */\n+      type = TREE_TYPE (access_fn);\n       STRIP_NOPS (access_fn);\n       evolution_part =\n \t unshare_expr (evolution_part_in_loop_num (access_fn, loop->num));\n@@ -1635,22 +1641,19 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       step_expr = evolution_part;\n       init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, \n \t\t\t\t\t\t\t       loop->num));\n+      init_expr = fold_convert (type, init_expr);\n \n+      off = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t fold_convert (TREE_TYPE (step_expr), niters),\n+\t\t\t step_expr);\n       if (POINTER_TYPE_P (TREE_TYPE (init_expr)))\n \tni = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (init_expr), \n-\t\t\t  init_expr, \n-\t\t\t  fold_build2 (MULT_EXPR, sizetype,\n-\t\t\t\t       fold_convert (sizetype, niters),\n-\t\t\t\t       step_expr));\n+\t\t\t  init_expr,\n+\t\t\t  fold_convert (sizetype, off));\n       else\n \tni = fold_build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n-\t\t\t  fold_build2 (MULT_EXPR, TREE_TYPE (init_expr),\n-\t\t\t\t       fold_convert (TREE_TYPE (init_expr),\n-\t\t\t\t\t\t     niters),\n-\t\t\t\t       step_expr),\n-\t\t\t  init_expr);\n-\n-\n+\t\t\t  init_expr,\n+\t\t\t  fold_convert (TREE_TYPE (init_expr), off));\n \n       var = create_tmp_var (TREE_TYPE (init_expr), \"tmp\");\n       add_referenced_var (var);"}, {"sha": "d78fa99ff8b1755ba0f31a12da74bd35496b5eb8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550918ca7dd62e7ac5e11cce696b73fa67227639/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=550918ca7dd62e7ac5e11cce696b73fa67227639", "patch": "@@ -2267,33 +2267,33 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n-  int nunits =  TYPE_VECTOR_SUBPARTS (vectype);\n-  tree scalar_type = TREE_TYPE (vectype);\n+  tree scalar_type = TREE_TYPE (init_val);\n+  tree vectype = get_vectype_for_scalar_type (scalar_type);\n+  int nunits;\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree type = TREE_TYPE (init_val);\n-  tree vecdef;\n   tree def_for_init;\n   tree init_def;\n   tree t = NULL_TREE;\n   int i;\n   bool nested_in_vect_loop = false; \n \n-  gcc_assert (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type));\n+  gcc_assert (vectype);\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  gcc_assert (POINTER_TYPE_P (scalar_type) || INTEGRAL_TYPE_P (scalar_type)\n+\t      || SCALAR_FLOAT_TYPE_P (scalar_type));\n   if (nested_in_vect_loop_p (loop, stmt))\n     nested_in_vect_loop = true;\n   else\n     gcc_assert (loop == (gimple_bb (stmt))->loop_father);\n \n-  vecdef = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n-\n   switch (code)\n   {\n   case WIDEN_SUM_EXPR:\n   case DOT_PROD_EXPR:\n   case PLUS_EXPR:\n     if (nested_in_vect_loop)\n-      *adjustment_def = vecdef;\n+      *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n     else\n       *adjustment_def = init_val;\n     /* Create a vector of zeros for init_def.  */\n@@ -2310,7 +2310,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n   case MIN_EXPR:\n   case MAX_EXPR:\n     *adjustment_def = NULL_TREE;\n-    init_def = vecdef;\n+    init_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n     break;\n \n   default:"}]}