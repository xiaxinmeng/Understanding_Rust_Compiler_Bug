{"sha": "3f93d7291be9704669ed48e4a277ff40a74abd19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5M2Q3MjkxYmU5NzA0NjY5ZWQ0OGU0YTI3N2ZmNDBhNzRhYmQxOQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-09-11T16:41:58Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-09-11T16:41:58Z"}, "message": "Verify gcov output...\n\nVerify gcov output; most of this file was previously in gcc.misc-tests/\ngcov.exp but was moved so it can be used for other languages.\n\nFrom-SVN: r45545", "tree": {"sha": "c7bd61cb68e2181ac7bc4b8e4ab61f39beadcd04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7bd61cb68e2181ac7bc4b8e4ab61f39beadcd04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f93d7291be9704669ed48e4a277ff40a74abd19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f93d7291be9704669ed48e4a277ff40a74abd19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f93d7291be9704669ed48e4a277ff40a74abd19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f93d7291be9704669ed48e4a277ff40a74abd19/comments", "author": null, "committer": null, "parents": [{"sha": "cd1f97c6d68b9b5b443531ebd16abedcd74b62a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1f97c6d68b9b5b443531ebd16abedcd74b62a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1f97c6d68b9b5b443531ebd16abedcd74b62a2"}], "stats": {"total": 360, "additions": 360, "deletions": 0}, "files": [{"sha": "3767f44e2be5ac0fce293ecb37d79e189529198a", "filename": "gcc/testsuite/lib/gcov.exp", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f93d7291be9704669ed48e4a277ff40a74abd19/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f93d7291be9704669ed48e4a277ff40a74abd19/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcov.exp?ref=3f93d7291be9704669ed48e4a277ff40a74abd19", "patch": "@@ -0,0 +1,360 @@\n+#   Copyright (C) 1997, 2001 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# Verify various kinds of gcov output: line counts, branch percentages,\n+# and call return percentages.  None of this is language-specific.\n+\n+global GCOV\n+\n+#\n+# clean-gcov -- delete the working files the compiler creates for gcov\n+#\n+# TESTCASE is the name of the test.\n+#\n+proc clean-gcov { testcase } {\n+    set basename [file tail $testcase]\n+    set base [file rootname $basename]\n+    remote_file host delete $base.bb $base.bbg $base.da $basename.gcov\n+}\n+\n+#\n+# verify-lines -- check that line counts are as expected\n+#\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+proc verify-lines { testcase file } {\n+    #send_user \"verify-lines\\n\"\n+    global subdir\n+    set failed 0\n+    set lmessage \"\"\n+    set output [grep $file \".*count\\\\(\\[0-9\\]+\\\\)\" line]\n+    #send_user \"output:$output\\n\"\n+    foreach line $output {\n+\tverbose \"Processing count line: $line\" 3\n+\t#send_user \"line:$line\\n\"\n+\tif [regexp \"(\\[0-9\\]+) *(\\[0-9\\]+).*count\\\\((\\[0-9\\]+)\\\\)\" \\\n+\t\t\"$line\" all n is shouldbe] {\n+\t    #send_user \"n $n:is $is:shouldbe $shouldbe\\n\"\n+\t    if { $is == \"\" } {\n+\t\tif { $failed == 0 } {\n+\t\t    set lmessage \"$n:no data available for this line\"\n+\t\t}\n+\t\tincr failed\n+\t    } elseif { $is != $shouldbe } {\n+\t\tif { $failed == 0 } {\n+\t\t    set lmessage \"$n:is $is:should be $shouldbe\"\n+\t\t}\n+\t\tincr failed\n+\t    }\n+\t} else {\n+\t    if { $failed == 0 } {\n+\t        set lmessage \"can't parse $line (in wrong place?)\"\n+\t    }\n+\t    incr failed\n+\t}\n+    }\n+    return [list $failed $lmessage]\n+}\n+\n+#\n+# verify-branches -- check that branch percentages are as expected\n+#\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+# Checks are based on comments in the source file.  This means to look for\n+# branch percentages 10 or 90, 20 or 80, and # 70 or 30:\n+#     /* branch(10, 20, 70) */\n+# This means that all specified percentages should have been seen by now:\n+#     /* branch(end) */\n+# All specified percentages must also be seen by the next branch(n) or\n+# by the end of the file.\n+#\n+# Each check depends on the compiler having generated the expected\n+# branch instructions.  Don't check for branches that might be\n+# optimized away or replaced with predicated instructions.\n+#\n+proc verify-branches { testcase file } {\n+    #send_user \"verify-branches\\n\"\n+    global bmessage\n+    global subdir\n+    set failed 0\n+    set bmessage \"\"\n+    set shouldbe \"\"\n+    set fd [open $file r]\n+    set n 0\n+    while { [gets $fd line] >= 0 } {\n+\tincr n\n+\tif [regexp \"branch\" $line] {\n+\t    verbose \"Processing branch line $n: $line\" 3\n+\t    if [regexp \"branch\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n+\t\t# All percentages in the current list should have been seen.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t        set bmessage \\\n+\t\t\t  \"$n: expected branch percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    #send_user \"$n: expected branch percentages not found: $shouldbe\\n\"\n+\t\t    incr failed\n+\t\t    set shouldbe \"\"\n+\t\t}\n+\t\tset shouldbe $new_shouldbe\n+\t\t#send_user \"$n: looking for: $shouldbe\\n\"\n+\t        # Record the percentages to check for. Replace percentage\n+\t\t# n > 50 with 100-n, since block ordering affects the\n+\t\t# direction of a branch.\n+\t\tfor {set i 0} {$i < [llength $shouldbe]} {incr i} {\n+\t\t    set num [lindex $shouldbe $i]\n+\t\t    if {$num > 50} {\n+\t\t\tset shouldbe [lreplace $shouldbe $i $i [expr 100 - $num]]\n+\t\t    }\n+\t\t}\n+\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (-\\[0-9\\]+)%\" \"$line\" \\\n+\t\t\tall taken] {\n+\t\t# Percentages should never be negative.\n+\t\tif { $failed == 0 } {\n+\t\t    set bmessage \"$n: negative percentage: $taken\"\n+\t\t}\n+\t\tincr failed\n+\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (\\[0-9\\]+)%\" \"$line\" \\\n+\t\t\tall taken] {\n+\t\t#send_user \"$n: taken = $taken\\n\"\n+\t\t# Percentages should never be greater than 100.\n+\t\tif {$taken > 100} {\n+\t\t    if { $failed == 0 } {\n+\t\t\tset bmessage \"$n: percentage greater than 100: $taken\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t}\n+\t\tif {$taken > 50} {\n+\t\t    set taken [expr 100 - $taken]\n+\t\t}\n+\t\t# If this percentage is one to check for then remove it\n+\t\t# from the list.  It's normal to ignore some reports.\n+\t\tset i [lsearch $shouldbe $taken]\n+\t\tif {$i != -1} {\n+\t\t    set shouldbe [lreplace $shouldbe $i $i]\n+\t\t}\n+\t    } elseif [regexp \"branch\\\\(end\\\\)\" \"$line\"] {\n+\t\t# All percentages in the list should have been seen by now.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t\tset bmessage \\\n+\t\t\t  \"$n: expected branch percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    #send_user \"$n: expected branch percentages not found: $shouldbe\\n\"\n+\t\t    incr failed\n+\t\t}\n+\t\tset shouldbe \"\"\n+\t    }\n+\t}\n+    }\n+    # All percentages in the list should have been seen.\n+    if {[llength $shouldbe] != 0} {\n+\tif { $failed == 0 } {\n+\t    set bmessage \"$n: expected branch percentages not found: $shouldbe\"\n+\t}\n+\t#send_user \"$n: expected branch percentages not found: $shouldbe\\n\"\n+\tincr failed\n+    }\n+    close $fd\n+    return [list $failed $bmessage]\n+}\n+\n+#\n+# verify-calls -- check that call return percentages are as expected\n+#\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+# Checks are based on comments in the source file.  This means to look for\n+# call return percentages 50, 20, 33:\n+#     /* returns(50, 20, 33) */\n+# This means that all specified percentages should have been seen by now:\n+#     /* returns(end) */\n+# All specified percentages must also be seen by the next returns(n) or\n+# by the end of the file.\n+#\n+# Each check depends on the compiler having generated the expected\n+# call instructions.  Don't check for calls that are inserted by the\n+# compiler or that might be inlined.\n+#\n+proc verify-calls { testcase file } {\n+    #send_user \"verify-calls\\n\"\n+    global cmessage\n+    global subdir\n+    set failed 0\n+    set cmessage \"\"\n+    set shouldbe \"\"\n+    set fd [open $file r]\n+    set n 0\n+    while { [gets $fd line] >= 0 } {\n+\tincr n\n+\tif [regexp \"returns\" $line] {\n+\t    verbose \"Processing returns line $n: $line\" 3\n+\t    if [regexp \"returns\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n+\t\t# All percentages in the current list should have been seen.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t        set cmessage \\\n+\t\t\t  \"$n: expected return percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t    set shouldbe \"\"\n+\t\t}\n+\t        # Record the percentages to check for.\n+\t\tset shouldbe $new_shouldbe\n+\t    } elseif [regexp \"call \\[0-9\\]+ returns = (-\\[0-9\\]+)%\" \"$line\" \\\n+\t\t\tall returns] {\n+\t\t# Percentages should never be negative.\n+\t\tif { $failed == 0 } {\n+\t\t    set cmessage \"$n: negative percentage: $returns\"\n+\t\t}\n+\t\tincr failed\n+\t    } elseif [regexp \"call \\[0-9\\]+ returns = (\\[0-9\\]+)%\" \"$line\" \\\n+\t\t\tall returns] {\n+\t\t# For branches we check that percentages are not greater than\n+\t\t# 100 but call return percentages can be, as for setjmp(), so\n+\t\t# don't count that as an error.\n+\t\t#\n+\t\t# If this percentage is one to check for then remove it\n+\t\t# from the list.  It's normal to ignore some reports.\n+\t\tset i [lsearch $shouldbe $returns]\n+\t\tif {$i != -1} {\n+\t\t    set shouldbe [lreplace $shouldbe $i $i]\n+\t\t}\n+\t    } elseif [regexp \"returns\\\\(end\\\\)\" \"$line\"] {\n+\t\t# All percentages in the list should have been seen by now.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t\tset cmessage \\\n+\t\t\t  \"$n: expected return percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t}\n+\t\tset shouldbe \"\"\n+\t    }\n+\t}\n+    }\n+    # All percentages in the list should have been seen.\n+    if {[llength $shouldbe] != 0} {\n+\tif { $failed == 0 } {\n+\t    set cmessage \"$n: expected return percentages not found: $shouldbe\"\n+\t}\n+\tincr failed\n+    }\n+    close $fd\n+    return [list $failed $cmessage]\n+}\n+\n+# Called by dg-final to run gcov and analyze the results.\n+#\n+# ARGS is the options to pass to gcov followed by the name of the\n+# test source file.\n+\n+proc run-gcov { args } {\n+    global GCOV\n+    global srcdir subdir\n+\n+    # Extract the test name from the arguments.\n+    set testcase [lindex $args end]\n+\n+    # Get special options for this test from the .x script, if present.\n+    # This can include:\n+    #   gcov_execute_xfail     string to pass to setup_xfail\n+    #   gcov_verify_xfail      string to pass to setup_xfail\n+    #   gcov_verify_branches   if defined, check branch percentages\n+    #   gcov_verify_calls      if defined, check call return percentages\n+    if [file exists [file rootname $srcdir/$subdir/$testcase].x] {\n+\tset done_p 0\n+\tcatch \"set done_p \\[source [file rootname $srcdir/$subdir/$testcase].x\\]\"\n+\tif { $done_p } {\n+\t    return\n+\t}\n+    }\n+\n+    if [info exists gcov_execute_xfail] {\n+\teval setup_xfail [split $gcov_execute_xfail]\n+    }\n+\n+    verbose \"Running $GCOV $testcase\" 2\n+    set testcase [remote_download host $testcase];\n+    set result [remote_exec host $GCOV $args];\n+    if { [lindex $result 0] != 0 } {\n+\tfail \"$subdir/$testcase gcov failed: [lindex $result 1]\"\n+\tclean-gcov $testcase\n+\treturn\n+    }\n+\n+    # Get the gcov output file after making sure it exists.\n+    set files [glob -nocomplain $testcase.gcov]\n+    if { $files == \"\" } {\n+        fail \"$subdir/$testcase gcov failed: $testcase.gcov does not exist\"\n+        clean-gcov $testcase\n+        return;\n+    }\n+    remote_upload host $testcase.gcov $testcase.gcov;\n+\n+    if [info exists gcov_verify_xfail] {\n+\teval setup_xfail [split $gcov_verify_xfail]\n+    }\n+\n+    # Check that line execution counts are as expected.\n+    set loutput [verify-lines $testcase $testcase.gcov]\n+    set lfailed [lindex $loutput 0]\n+    set lmessage [lindex $loutput 1]\n+\n+    # If requested via the .x file, check that branch and call information\n+    # is correct.\n+    if [info exists gcov_verify_branches] {\n+\tset boutput [verify-branches $testcase $testcase.gcov]\n+\tset bfailed [lindex $boutput 0]\n+\tset bmessage [lindex $boutput 1]\n+    } else {\n+\tset bfailed 0\n+\tset bmessage \"\"\n+    }\n+    if [info exists gcov_verify_calls] {\n+\tset coutput [verify-calls $testcase $testcase.gcov]\n+\tset cfailed [lindex $coutput 0]\n+\tset cmessage [lindex $coutput 1]\n+    } else {\n+\tset cfailed 0\n+\tset cmessage \"\"\n+    }\n+\n+    # Report whether the gcov test passed or failed.  If there were\n+    # multiple failures then the message is a summary.\n+    set tfailed [expr $lfailed + $bfailed + $cfailed]\n+    if { $tfailed > 0 } {\n+\tif { $tfailed == 1 } {\n+\t    set vmessage \"$lmessage$bmessage$cmessage\"\n+\t} elseif { $bfailed == 0 && $cfailed == 0 } {\n+\t    set vmessage \"$lfailed failures in line counts\"\n+\t} elseif { $lfailed == 0 && $cfailed == 0 } {\n+\t    set vmessage \"$bfailed failures in branch percentages\"\n+\t} elseif { $lfailed == 0 && $bfailed == 0 } {\n+\t    set vmessage \"$cfailed failures in return percentages\"\n+\t} else {\n+\t    set vmessage \"$lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages\"\n+\t}\n+\tfail \"$subdir/$testcase gcov: $vmessage\"\n+    } else {\n+\tpass \"$subdir/$testcase gcov\"\n+\tclean-gcov $testcase\n+    }\n+}"}]}