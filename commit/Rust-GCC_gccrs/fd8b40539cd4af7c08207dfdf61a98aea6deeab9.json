{"sha": "fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ4YjQwNTM5Y2Q0YWY3YzA4MjA3ZGZkZjYxYTk4YWVhNmRlZWFiOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-04-12T12:52:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T12:52:32Z"}, "message": "sem_ch13.adb (Analyze_Aspect_Specifications): Aspect Depends is now a delayed aspect.\n\n2013-04-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect\n\tDepends is now a delayed aspect. The delay is required\n\tdue to the interplay between aspects Depends and Global.\n\t(Check_Aspect_At_Freeze_Point): Add an entry for aspect Depends.\n\t* sem_prag.adb: Reformat various error messages.\n\t(Add_Item): New subsidiary routine.\n\t(Analyze_Pragma): Add new variables\n\tGlobal_Seen, Result_Seen, Subp_Inputs and Subp_Outputs. The\n\tanalysis of pragma Depends now has the capability to check\n\tthe proper mode and usage of subprogram inputs and outputs.\n\t(Appears_In): New routine.\n\t(Check_Function_Return): New routine.\n\t(Check_Mode): New routine.\n\t(Check_Usage): New routine.\n\t(Collect_Subprogram_Inputs_Outputs): New routine.\n\nFrom-SVN: r197900", "tree": {"sha": "09735f28653f7fa5124ce0e81628fad32c72ccba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09735f28653f7fa5124ce0e81628fad32c72ccba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2658843ea5068503078a7ac9b280179739bb17f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2658843ea5068503078a7ac9b280179739bb17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2658843ea5068503078a7ac9b280179739bb17f"}], "stats": {"total": 530, "additions": 462, "deletions": 68}, "files": [{"sha": "9dc6062d466934861fdda4d4e2da6aa1e449f1be", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "patch": "@@ -1,3 +1,21 @@\n+2013-04-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect\n+\tDepends is now a delayed aspect. The delay is required\n+\tdue to the interplay between aspects Depends and Global.\n+\t(Check_Aspect_At_Freeze_Point): Add an entry for aspect Depends.\n+\t* sem_prag.adb: Reformat various error messages.\n+\t(Add_Item): New subsidiary routine.\n+\t(Analyze_Pragma): Add new variables\n+\tGlobal_Seen, Result_Seen, Subp_Inputs and Subp_Outputs. The\n+\tanalysis of pragma Depends now has the capability to check\n+\tthe proper mode and usage of subprogram inputs and outputs.\n+\t(Appears_In): New routine.\n+\t(Check_Function_Return): New routine.\n+\t(Check_Mode): New routine.\n+\t(Check_Usage): New routine.\n+\t(Collect_Subprogram_Inputs_Outputs): New routine.\n+\n 2013-04-12  Bob Duff  <duff@adacore.com>\n \n \t* par-ch7.adb (P_Package): Initialize Sloc in the newly-pushed scope"}, {"sha": "4c8bbc1677b291eb454e6a1b5fd1e130f3ac5d4b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "patch": "@@ -1475,6 +1475,9 @@ package body Sem_Ch13 is\n \n                   Delay_Required := False;\n \n+               --  Aspect Depends must be delayed because it mentions names\n+               --  of inputs and output that are classified by aspect Global.\n+\n                when Aspect_Depends =>\n                   Aitem :=\n                     Make_Pragma (Loc,\n@@ -1484,8 +1487,6 @@ package body Sem_Ch13 is\n                         Make_Pragma_Argument_Association (Loc,\n                           Expression => Relocate_Node (Expr))));\n \n-                  Delay_Required := False;\n-\n                --  Aspect Global must be delayed because it can mention names\n                --  and benefit from the forward visibility rules applicable to\n                --  aspects of subprograms.\n@@ -7194,6 +7195,14 @@ package body Sem_Ch13 is\n          when Aspect_Default_Value =>\n             T := Entity (ASN);\n \n+         --  Depends is a delayed aspect because it mentiones names first\n+         --  introduced by aspect Global which is already delayed. There is\n+         --  no action to be taken with respect to the aspect itself as the\n+         --  analysis is done by the corresponding pragma.\n+\n+         when Aspect_Depends =>\n+            return;\n+\n          when Aspect_Dispatching_Domain =>\n             T := RTE (RE_Dispatching_Domain);\n \n@@ -7205,8 +7214,8 @@ package body Sem_Ch13 is\n \n          --  Global is a delayed aspect because it may reference names that\n          --  have not been declared yet. There is no action to be taken with\n-         --  respect to the aspect itself as the reference checking is done on\n-         --  the corresponding pragma.\n+         --  respect to the aspect itself as the reference checking is done\n+         --  on the corresponding pragma.\n \n          when Aspect_Global =>\n             return;\n@@ -7283,7 +7292,6 @@ package body Sem_Ch13 is\n          when Aspect_Abstract_State       |\n               Aspect_Contract_Case        |\n               Aspect_Contract_Cases       |\n-              Aspect_Depends              |\n               Aspect_Dimension            |\n               Aspect_Dimension_System     |\n               Aspect_Implicit_Dereference |"}, {"sha": "6efd878c8fb96cecb0584d80258164b1bee8215d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 431, "deletions": 63, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd8b40539cd4af7c08207dfdf61a98aea6deeab9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=fd8b40539cd4af7c08207dfdf61a98aea6deeab9", "patch": "@@ -458,6 +458,11 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n+      procedure Add_Item (Item : Entity_Id; To_List : in out Elist_Id);\n+      --  Subsidiary routine to the analysis of pragmas Depends and Global.\n+      --  Append an input or output item to a list. If the list is empty, a\n+      --  new one is created.\n+\n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n       --  83 mode (used for language pragmas that are not a standard part of\n@@ -983,6 +988,19 @@ package body Sem_Prag is\n          end if;\n       end Ada_2012_Pragma;\n \n+      --------------\n+      -- Add_Item --\n+      --------------\n+\n+      procedure Add_Item (Item : Entity_Id; To_List : in out Elist_Id) is\n+      begin\n+         if No (To_List) then\n+            To_List := New_Elmt_List;\n+         end if;\n+\n+         Append_Unique_Elmt (Item, To_List);\n+      end Add_Item;\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -3485,8 +3503,8 @@ package body Sem_Prag is\n               and then C /= Convention (Overridden_Operation (E))\n             then\n                Error_Pragma_Arg\n-                 (\"cannot change convention for overridden \"\n-                  & \"dispatching operation\", Arg1);\n+                 (\"cannot change convention for overridden dispatching \"\n+                  & \"operation\", Arg1);\n             end if;\n \n             --  Set the convention\n@@ -8652,8 +8670,8 @@ package body Sem_Prag is\n \n             if Warn_On_Obsolescent_Feature then\n                Error_Msg_N\n-                 (\"'G'N'A'T pragma cpp'_virtual is now obsolete and has \"\n-                  & \"no effect?j?\", N);\n+                 (\"'G'N'A'T pragma cpp'_virtual is now obsolete and has no \"\n+                  & \"effect?j?\", N);\n             end if;\n          end CPP_Virtual;\n \n@@ -8667,8 +8685,8 @@ package body Sem_Prag is\n \n             if Warn_On_Obsolescent_Feature then\n                Error_Msg_N\n-                 (\"'G'N'A'T pragma cpp'_vtable is now obsolete and has \"\n-                  & \"no effect?j?\", N);\n+                 (\"'G'N'A'T pragma cpp'_vtable is now obsolete and has no \"\n+                  & \"effect?j?\", N);\n             end if;\n          end CPP_Vtable;\n \n@@ -8900,14 +8918,14 @@ package body Sem_Prag is\n          --  where FUNCTION_RESULT is a function Result attribute_reference\n \n          when Pragma_Depends => Depends : declare\n-            Subp_Decl : Node_Id;\n-            Subp_Id   : Entity_Id;\n-\n             All_Inputs_Seen : Elist_Id := No_Elist;\n             --  A list containing the entities of all the inputs processed so\n             --  far. This Elist is populated with unique entities because the\n             --  same input may appear in multiple input lists.\n \n+            Global_Seen : Boolean := False;\n+            --  A flag set when pragma Global has been processed\n+\n             Outputs_Seen : Elist_Id := No_Elist;\n             --  A list containing the entities of all the outputs processed so\n             --  far. The elements of this list may come from different output\n@@ -8916,12 +8934,52 @@ package body Sem_Prag is\n             Null_Output_Seen : Boolean := False;\n             --  A flag used to track the legality of a null output\n \n+            Result_Seen : Boolean := False;\n+            --  A flag set when Subp_Id'Result is processed\n+\n+            Subp_Id : Entity_Id;\n+            --  The entity of the subprogram subject to pragma Depends\n+\n+            Subp_Inputs  : Elist_Id := No_Elist;\n+            Subp_Outputs : Elist_Id := No_Elist;\n+            --  Two lists containing the full set of inputs and output of the\n+            --  related subprograms. Note that these lists contain both nodes\n+            --  and entities.\n+\n             procedure Analyze_Dependency_Clause\n               (Clause  : Node_Id;\n                Is_Last : Boolean);\n             --  Verify the legality of a single dependency clause. Flag Is_Last\n             --  denotes whether Clause is the last clause in the relation.\n \n+            function Appears_In\n+              (List    : Elist_Id;\n+               Item_Id : Entity_Id) return Boolean;\n+            --  Determine whether a particular item appears in a mixed list of\n+            --  nodes and entities.\n+\n+            procedure Check_Function_Return;\n+            --  Verify that Funtion'Result appears as one of the outputs\n+\n+            procedure Check_Mode\n+              (Item     : Node_Id;\n+               Item_Id  : Entity_Id;\n+               Is_Input : Boolean);\n+            --  Ensure that an item has a proper \"in\", \"in out\" or \"out\" mode\n+            --  depending on its function. If this is not the case, emit an\n+            --  error.\n+\n+            procedure Check_Usage\n+              (Subp_List : Elist_Id;\n+               Item_List : Elist_Id;\n+               Is_Input  : Boolean);\n+            --  Verify that all items from list Subp_List appear in Item_List.\n+            --  Emit an error if this is not the case.\n+\n+            procedure Collect_Subprogram_Inputs_Outputs;\n+            --  Gather all inputs and outputs of the subprogram. These are the\n+            --  formal parameters and entities classified in pragma Global.\n+\n             procedure Normalize_Clause (Clause : Node_Id);\n             --  Remove a self-dependency \"+\" from the input list of a clause.\n             --  Depending on the contents of the relation, either split the\n@@ -9080,6 +9138,9 @@ package body Sem_Prag is\n                      elsif Is_Input then\n                         Error_Msg_N\n                           (\"function result cannot act as input\", Item);\n+\n+                     else\n+                        Result_Seen := True;\n                      end if;\n \n                   --  Detect multiple uses of null in a single dependency list\n@@ -9120,18 +9181,19 @@ package body Sem_Prag is\n                                               E_Out_Parameter,\n                                               E_Variable)\n                         then\n+                           --  Ensure that the item is of the correct mode\n+                           --  depending on its function.\n+\n+                           Check_Mode (Item, Item_Id, Is_Input);\n+\n                            --  Detect multiple uses of the same state, variable\n                            --  or formal parameter. If this is not the case,\n                            --  add the item to the list of processed relations.\n \n                            if Contains (Seen, Item_Id) then\n                               Error_Msg_N (\"duplicate use of item\", Item);\n                            else\n-                              if No (Seen) then\n-                                 Seen := New_Elmt_List;\n-                              end if;\n-\n-                              Append_Elmt (Item_Id, Seen);\n+                              Add_Item (Item_Id, Seen);\n                            end if;\n \n                            --  Detect an illegal use of an input related to a\n@@ -9145,11 +9207,7 @@ package body Sem_Prag is\n                                 (\"input of a null output list appears in \"\n                                  & \"multiple input lists\", Item);\n                            else\n-                              if No (All_Inputs_Seen) then\n-                                 All_Inputs_Seen := New_Elmt_List;\n-                              end if;\n-\n-                              Append_Unique_Elmt (Item_Id, All_Inputs_Seen);\n+                              Add_Item (Item_Id, All_Inputs_Seen);\n                            end if;\n \n                            --  When the item renames an entire object, replace\n@@ -9215,6 +9273,295 @@ package body Sem_Prag is\n                Analyze_Input_List (Inputs);\n             end Analyze_Dependency_Clause;\n \n+            ----------------\n+            -- Appears_In --\n+            ----------------\n+\n+            function Appears_In\n+              (List    : Elist_Id;\n+               Item_Id : Entity_Id) return Boolean\n+            is\n+               Elmt : Elmt_Id;\n+               Id   : Entity_Id;\n+\n+            begin\n+               if Present (List) then\n+                  Elmt := First_Elmt (List);\n+                  while Present (Elmt) loop\n+                     if Nkind (Node (Elmt)) = N_Defining_Identifier then\n+                        Id := Node (Elmt);\n+                     else\n+                        Id := Entity (Node (Elmt));\n+                     end if;\n+\n+                     if Id = Item_Id then\n+                        return True;\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end if;\n+\n+               return False;\n+            end Appears_In;\n+\n+            ----------------------------\n+            --  Check_Function_Return --\n+            ----------------------------\n+\n+            procedure Check_Function_Return is\n+            begin\n+               if Ekind (Subp_Id) = E_Function and then not Result_Seen then\n+                  Error_Msg_NE\n+                    (\"result of & must appear in exactly one output list\",\n+                     N, Subp_Id);\n+               end if;\n+            end Check_Function_Return;\n+\n+            ----------------\n+            -- Check_Mode --\n+            ----------------\n+\n+            procedure Check_Mode\n+              (Item     : Node_Id;\n+               Item_Id  : Entity_Id;\n+               Is_Input : Boolean)\n+            is\n+            begin\n+               if Is_Input then\n+                  if Ekind (Item_Id) = E_Out_Parameter\n+                    or else\n+                      (Global_Seen\n+                         and then not Appears_In (Subp_Inputs, Item_Id))\n+                  then\n+                     Error_Msg_NE\n+                       (\"item & must have mode in or in out\", Item, Item_Id);\n+                  end if;\n+\n+               --  Output\n+\n+               else\n+                  if Ekind (Item_Id) = E_In_Parameter\n+                    or else\n+                      (Global_Seen\n+                         and then not Appears_In (Subp_Outputs, Item_Id))\n+                  then\n+                     Error_Msg_NE\n+                       (\"item & must have mode out or in out\", Item, Item_Id);\n+                  end if;\n+               end if;\n+            end Check_Mode;\n+\n+            -----------------\n+            -- Check_Usage --\n+            -----------------\n+\n+            procedure Check_Usage\n+              (Subp_List : Elist_Id;\n+               Item_List : Elist_Id;\n+               Is_Input  : Boolean)\n+            is\n+               procedure Usage_Error (Item : Node_Id; Item_Id : Entity_Id);\n+               --  Emit an error concerning the erroneous usage of an item\n+\n+               -----------------\n+               -- Usage_Error --\n+               -----------------\n+\n+               procedure Usage_Error (Item : Node_Id; Item_Id : Entity_Id) is\n+               begin\n+                  if Is_Input then\n+                     Error_Msg_NE\n+                       (\"item & must appear in at least one input list of \"\n+                        & \"aspect Depends\", Item, Item_Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"item & must appear in exactly one output list of \"\n+                        & \"aspect Depends\", Item, Item_Id);\n+                  end if;\n+               end Usage_Error;\n+\n+               --  Local variables\n+\n+               Elmt    : Elmt_Id;\n+               Item    : Node_Id;\n+               Item_Id : Entity_Id;\n+\n+            --  Start of processing for Check_Usage\n+\n+            begin\n+               if No (Subp_List) then\n+                  return;\n+               end if;\n+\n+               --  Each input or output of the subprogram must appear in a\n+               --  dependency relation.\n+\n+               Elmt := First_Elmt (Subp_List);\n+               while Present (Elmt) loop\n+                  Item := Node (Elmt);\n+\n+                  if Nkind (Item) = N_Defining_Identifier then\n+                     Item_Id := Item;\n+                  else\n+                     Item_Id := Entity (Item);\n+                  end if;\n+\n+                  --  The item does not appear in a dependency\n+\n+                  if not Contains (Item_List, Item_Id) then\n+                     if Is_Formal (Item_Id) then\n+                        Usage_Error (Item, Item_Id);\n+\n+                     --  States and global variables are not used properly only\n+                     --  when the subprogram is subject to pragma Global.\n+\n+                     elsif Global_Seen then\n+                        Usage_Error (Item, Item_Id);\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end Check_Usage;\n+\n+            ---------------------------------------\n+            -- Collect_Subprogram_Inputs_Outputs --\n+            ---------------------------------------\n+\n+            procedure Collect_Subprogram_Inputs_Outputs is\n+               procedure Collect_Global_List\n+                 (List : Node_Id;\n+                  Mode : Name_Id := Name_Input);\n+               --  Collect all relevant items from a global list\n+\n+               -------------------------\n+               -- Collect_Global_List --\n+               -------------------------\n+\n+               procedure Collect_Global_List\n+                 (List : Node_Id;\n+                  Mode : Name_Id := Name_Input)\n+               is\n+                  procedure Collect_Global_Item\n+                    (Item : Node_Id;\n+                     Mode : Name_Id);\n+                  --  Add an item to the proper subprogram input or output\n+                  --  collection.\n+\n+                  -------------------------\n+                  -- Collect_Global_Item --\n+                  -------------------------\n+\n+                  procedure Collect_Global_Item\n+                    (Item : Node_Id;\n+                     Mode : Name_Id)\n+                  is\n+                  begin\n+                     if Mode = Name_In_Out or else Mode = Name_Input then\n+                        Add_Item (Item, Subp_Inputs);\n+                     end if;\n+\n+                     if Mode = Name_In_Out or else Mode = Name_Output then\n+                        Add_Item (Item, Subp_Outputs);\n+                     end if;\n+                  end Collect_Global_Item;\n+\n+                  --  Local variables\n+\n+                  Assoc : Node_Id;\n+                  Item  : Node_Id;\n+\n+               --  Start of processing for Collect_Global_List\n+\n+               begin\n+                  --  Single global item declaration\n+\n+                  if Nkind_In (List, N_Identifier, N_Selected_Component) then\n+                     Collect_Global_Item (List, Mode);\n+\n+                  --  Simple global list or moded global list declaration\n+\n+                  else\n+                     if Present (Expressions (List)) then\n+                        Item := First (Expressions (List));\n+                        while Present (Item) loop\n+                           Collect_Global_Item (Item, Mode);\n+\n+                           Next (Item);\n+                        end loop;\n+\n+                     else\n+                        Assoc := First (Component_Associations (List));\n+                        while Present (Assoc) loop\n+                           Collect_Global_List\n+                             (List => Expression (Assoc),\n+                              Mode => Chars (First (Choices (Assoc))));\n+\n+                           Next (Assoc);\n+                        end loop;\n+                     end if;\n+                  end if;\n+               end Collect_Global_List;\n+\n+               --  Local variables\n+\n+               Formal : Entity_Id;\n+               Global : Node_Id;\n+               List   : Node_Id;\n+\n+            --  Start of processing for Collect_Subprogram_Inputs_Outputs\n+\n+            begin\n+               --  Process all formal parameters\n+\n+               Formal := First_Formal (Subp_Id);\n+               while Present (Formal) loop\n+                  if Ekind_In (Formal, E_In_Out_Parameter,\n+                                       E_In_Parameter)\n+                  then\n+                     Add_Item (Formal, Subp_Inputs);\n+                  end if;\n+\n+                  if Ekind_In (Formal, E_In_Out_Parameter,\n+                                       E_Out_Parameter)\n+                  then\n+                     Add_Item (Formal, Subp_Outputs);\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+\n+               --  If the subprogram is subject to pragma Global, traverse all\n+               --  global lists and gather the relevant items.\n+\n+               Global := Find_Aspect (Subp_Id, Aspect_Global);\n+               if Present (Global) then\n+                  Global_Seen := True;\n+\n+                  --  Retrieve the pragma as it contains the analyzed lists\n+\n+                  Global := Aspect_Rep_Item (Parent (Global));\n+\n+                  --  The pragma may not have been analyzed because of the\n+                  --  arbitrary declaration order of aspects. Make sure that\n+                  --  it is analyzed for the purposes of item extraction.\n+\n+                  if not Analyzed (Global) then\n+                     Analyze (Global);\n+                  end if;\n+\n+                  List :=\n+                    Expression (First (Pragma_Argument_Associations (Global)));\n+\n+                  --  Nothing to be done for a null global list\n+\n+                  if Nkind (List) /= N_Null then\n+                     Collect_Global_List (List);\n+                  end if;\n+               end if;\n+            end Collect_Subprogram_Inputs_Outputs;\n+\n             ----------------------\n             -- Normalize_Clause --\n             ----------------------\n@@ -9490,6 +9837,7 @@ package body Sem_Prag is\n             Clause      : Node_Id;\n             Errors      : Nat;\n             Last_Clause : Node_Id;\n+            Subp_Decl   : Node_Id;\n \n          --  Start of processing for Depends\n \n@@ -9511,10 +9859,22 @@ package body Sem_Prag is\n             Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n             Clause  := Expression (Arg1);\n \n-            --  There is nothing to be done for a null dependency relation\n+            --  Empty dependency list\n \n             if Nkind (Clause) = N_Null then\n-               null;\n+\n+               --  Gather all states, variables and formal parameters that the\n+               --  subprogram may depend on. These items are obtained from the\n+               --  parameter profile or pragma Global (if available).\n+\n+               Collect_Subprogram_Inputs_Outputs;\n+\n+               --  Verify that every input or output of the subprogram appear\n+               --  in a dependency.\n+\n+               Check_Usage (Subp_Inputs, All_Inputs_Seen, True);\n+               Check_Usage (Subp_Outputs, Outputs_Seen, False);\n+               Check_Function_Return;\n \n             --  Dependency clauses appear as component associations of an\n             --  aggregate.\n@@ -9524,6 +9884,12 @@ package body Sem_Prag is\n             then\n                Last_Clause := Last (Component_Associations (Clause));\n \n+               --  Gather all states, variables and formal parameters that the\n+               --  subprogram may depend on. These items are obtained from the\n+               --  parameter profile or pragma Global (if available).\n+\n+               Collect_Subprogram_Inputs_Outputs;\n+\n                --  Ensure that the formal parameters are visible when analyzing\n                --  all clauses. This falls out of the general rule of aspects\n                --  pertaining to subprogram declarations.\n@@ -9559,6 +9925,13 @@ package body Sem_Prag is\n \n                End_Scope;\n \n+               --  Verify that every input or output of the subprogram appear\n+               --  in a dependency.\n+\n+               Check_Usage (Subp_Inputs, All_Inputs_Seen, True);\n+               Check_Usage (Subp_Outputs, Outputs_Seen, False);\n+               Check_Function_Return;\n+\n             --  The top level dependency relation is malformed\n \n             else\n@@ -10047,8 +10420,8 @@ package body Sem_Prag is\n                 Present (Source_Location)\n             then\n                Error_Pragma\n-                 (\"parameter profile and source location cannot \"\n-                  & \"be used together in pragma%\");\n+                 (\"parameter profile and source location cannot be used \"\n+                  & \"together in pragma%\");\n             end if;\n \n             Process_Eliminate_Pragma\n@@ -10894,18 +11267,14 @@ package body Sem_Prag is\n                   --  processed items.\n \n                   else\n-                     if No (Seen) then\n-                        Seen := New_Elmt_List;\n-                     end if;\n-\n-                     Append_Elmt (Item_Id, Seen);\n+                     Add_Item (Item_Id, Seen);\n                   end if;\n \n                   if Ekind (Item_Id) = E_Abstract_State\n                     and then Is_Volatile_State (Item_Id)\n                   then\n-                     --  A global item of mode In_Out or Output cannot denote\n-                     --  a volatile Input state.\n+                     --  A global item of mode In_Out or Output cannot denote a\n+                     --  volatile Input state.\n \n                      if Is_Input_State (Item_Id)\n                        and then (Global_Mode = Name_In_Out\n@@ -10954,9 +11323,9 @@ package body Sem_Prag is\n                procedure Check_Mode_Restriction_In_Function (Mode : Node_Id) is\n                begin\n                   if Ekind (Subp_Id) = E_Function then\n-                     Error_Msg_Name_1 := Chars (Mode);\n-                     Error_Msg_N\n-                       (\"global mode % not applicable to functions\", Mode);\n+                     Error_Msg_NE\n+                       (\"global mode & not applicable to functions\",\n+                        Mode, Mode);\n                   end if;\n                end Check_Mode_Restriction_In_Function;\n \n@@ -11008,22 +11377,22 @@ package body Sem_Prag is\n \n                      Assoc := First (Component_Associations (List));\n                      while Present (Assoc) loop\n-                           Mode := First (Choices (Assoc));\n+                        Mode := First (Choices (Assoc));\n \n                         if Nkind (Mode) = N_Identifier then\n                            if Chars (Mode) = Name_Contract_In then\n-                                 Check_Duplicate_Mode (Mode, Contract_Seen);\n+                              Check_Duplicate_Mode (Mode, Contract_Seen);\n \n                            elsif Chars (Mode) = Name_In_Out then\n                               Check_Duplicate_Mode (Mode, In_Out_Seen);\n-                                 Check_Mode_Restriction_In_Function (Mode);\n+                              Check_Mode_Restriction_In_Function (Mode);\n \n                            elsif Chars (Mode) = Name_Input then\n-                                 Check_Duplicate_Mode (Mode, Input_Seen);\n+                              Check_Duplicate_Mode (Mode, Input_Seen);\n \n                            elsif Chars (Mode) = Name_Output then\n                               Check_Duplicate_Mode (Mode, Output_Seen);\n-                                 Check_Mode_Restriction_In_Function (Mode);\n+                              Check_Mode_Restriction_In_Function (Mode);\n \n                            else\n                               Error_Msg_N (\"invalid mode selector\", Mode);\n@@ -11316,8 +11685,8 @@ package body Sem_Prag is\n                   null;\n                else\n                   Error_Pragma_Arg\n-                    (\"controlling formal must be of synchronized \"\n-                     & \"tagged type\", Arg1);\n+                    (\"controlling formal must be of synchronized tagged type\",\n+                     Arg1);\n                   return;\n                end if;\n \n@@ -12275,8 +12644,8 @@ package body Sem_Prag is\n \n             elsif In_Private_Part (Current_Scope) then\n                Error_Pragma_Arg\n-                 (\"pragma% only allowed for private type \"\n-                  & \"declared in visible part\", Arg1);\n+                 (\"pragma% only allowed for private type declared in \"\n+                  & \"visible part\", Arg1);\n \n             else\n                Error_Pragma_Arg\n@@ -12369,12 +12738,12 @@ package body Sem_Prag is\n                if Ekind (Def_Id) /= E_Function then\n                   if VM_Target = JVM_Target then\n                      Error_Pragma_Arg\n-                       (\"pragma% requires function returning a \"\n-                        & \"'Java access type\", Def_Id);\n+                       (\"pragma% requires function returning a 'Java access \"\n+                        & \"type\", Def_Id);\n                   else\n                      Error_Pragma_Arg\n-                       (\"pragma% requires function returning a \"\n-                        & \"'C'I'L access type\", Def_Id);\n+                       (\"pragma% requires function returning a 'C'I'L access \"\n+                        & \"type\", Def_Id);\n                   end if;\n                end if;\n \n@@ -12488,7 +12857,7 @@ package body Sem_Prag is\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"first formal of % function must be a named access \"\n-                        & \" type\", Parameter_Type (Parent (This_Formal)));\n+                        & \"type\", Parameter_Type (Parent (This_Formal)));\n \n                   elsif Atree.Convention\n                          (Designated_Type (Etype (This_Formal))) /= Convention\n@@ -12531,13 +12900,13 @@ package body Sem_Prag is\n                   if Atree.Convention (Etype (Def_Id)) /= Convention then\n                      if Convention = Convention_Java then\n                         Error_Pragma_Arg\n-                          (\"pragma% requires function returning a \"\n-                           & \"'Java access type\", Arg1);\n+                          (\"pragma% requires function returning a 'Java \"\n+                           & \"access type\", Arg1);\n                      else\n                         pragma Assert (Convention = Convention_CIL);\n                         Error_Pragma_Arg\n-                          (\"pragma% requires function returning a \"\n-                           & \"'C'I'L access type\", Arg1);\n+                          (\"pragma% requires function returning a 'C'I'L \"\n+                           & \"access type\", Arg1);\n                      end if;\n                   end if;\n \n@@ -14611,8 +14980,8 @@ package body Sem_Prag is\n \n             elsif Lower_Val > Upper_Val then\n                Error_Pragma\n-                 (\"last_priority_expression must be greater than \"\n-                  & \"or equal to first_priority_expression\");\n+                 (\"last_priority_expression must be greater than or equal to \"\n+                  & \"first_priority_expression\");\n \n             --  Store the new policy, but always preserve System_Location since\n             --  we like the error message with the run-time name.\n@@ -15454,8 +15823,8 @@ package body Sem_Prag is\n               or else In_Package_Body (Current_Scope)\n             then\n                Error_Pragma\n-                 (\"pragma% can only apply to type declared immediately\"\n-                  & \" within a package declaration\");\n+                 (\"pragma% can only apply to type declared immediately \"\n+                  & \"within a package declaration\");\n             end if;\n \n             --  A simple storage pool type must be an immutably limited record\n@@ -15693,7 +16062,7 @@ package body Sem_Prag is\n                  or else Present (Next_Formal (First_Formal (Ent)))\n                then\n                   Error_Pragma_Arg\n-                   (\"argument for pragma% must be function of one argument\",\n+                    (\"argument for pragma% must be function of one argument\",\n                      Arg);\n                end if;\n             end Check_OK_Stream_Convert_Function;\n@@ -16828,8 +17197,8 @@ package body Sem_Prag is\n \n                   elsif not Is_Static_String_Expression (Arg1) then\n                      Error_Pragma_Arg\n-                       (\"argument of pragma% must be On/Off or \"\n-                        & \"static string expression\", Arg1);\n+                       (\"argument of pragma% must be On/Off or static string \"\n+                        & \"expression\", Arg1);\n \n                   --  One argument string expression case\n \n@@ -16967,8 +17336,8 @@ package body Sem_Prag is\n \n                      elsif not Is_Static_String_Expression (Arg2) then\n                         Error_Pragma_Arg\n-                          (\"second argument of pragma% must be entity \"\n-                           & \"name or static string expression\", Arg2);\n+                          (\"second argument of pragma% must be entity name \"\n+                           & \"or static string expression\", Arg2);\n \n                      --  String literal case\n \n@@ -17007,9 +17376,8 @@ package body Sem_Prag is\n \n                            if Err then\n                               Error_Msg\n-                                (\"??pragma Warnings On with no \"\n-                                 & \"matching Warnings Off\",\n-                                 Loc);\n+                                (\"??pragma Warnings On with no matching \"\n+                                 & \"Warnings Off\", Loc);\n                            end if;\n                         end if;\n                      end if;"}]}