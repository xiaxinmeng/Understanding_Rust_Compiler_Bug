{"sha": "a70f5d823abaf5ff25c7ef7f167a40c08889f698", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcwZjVkODIzYWJhZjVmZjI1YzdlZjdmMTY3YTQwYzA4ODg5ZjY5OA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-09-26T10:45:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:45:15Z"}, "message": "makeutl.ads (Main_Config_Project): Moved to gpr_util.ads\n\n2007-09-26  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.ads (Main_Config_Project): Moved to gpr_util.ads\n\n\t* prj.ads, prj.adb (Default_Language): Remove function, no longer used\n\tReplace components Compiler_Min_Options and Binder_Min_Options with\n\tCompiler_Required_Switches and Binder_Required_Switches in record\n\tLanguage_Config.\n\tRemove components Default_Language and Config in Project_Tree_Data,\n\tno longer used.\n\n\t* prj-attr.adb: New attributes Required_Switches (<language>) in\n\tpackages Compiler and Binder.\n\n\t* prj-nmsc.adb: Major rewrite of the processing of configuration\n\tattributes for gprbuild. No impact on GNAT tools.\n\n\t* prj-proc.ads, prj-proc.adb (Process_Project_Tree_Phase_2): No longer\n\tprocess configuration attributes: this is done in Prj.Nmsc.Check.\n\t(Recursive_Process): Make a full copy of packages inherited from project\n\tbeing extended, instead of a shallow copy.\n\t(Process_Project_Tree_Phase_1): New procedure\n\t(Process_Project_Tree_Phase_1): New procedure\n\t(Process): Implementation now uses the two new procedures\n\n\t* prj-util.adb (Executable_Of): Get the suffix and the default suffix\n\tfrom the project config, not the tree config that no longer exists.\n\nFrom-SVN: r128797", "tree": {"sha": "eb05109c29fc6fe2f2bda12cbb7e7afa665618cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb05109c29fc6fe2f2bda12cbb7e7afa665618cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a70f5d823abaf5ff25c7ef7f167a40c08889f698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70f5d823abaf5ff25c7ef7f167a40c08889f698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70f5d823abaf5ff25c7ef7f167a40c08889f698", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70f5d823abaf5ff25c7ef7f167a40c08889f698/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15cf0748477830cc0b490111a345dc36bb06de14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15cf0748477830cc0b490111a345dc36bb06de14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15cf0748477830cc0b490111a345dc36bb06de14"}], "stats": {"total": 2366, "additions": 1405, "deletions": 961}, "files": [{"sha": "b03783c73c7aa071902b321a35a905b191be8849", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -43,9 +43,6 @@ package Makeutl is\n    Project_Tree : constant Project_Tree_Ref := new Project_Tree_Data;\n    --  The project tree\n \n-   Main_Config_Project : Project_Id;\n-   --  The project id of the main configuration project\n-\n    procedure Add\n      (Option : String_Access;\n       To     : in out String_List_Access;"}, {"sha": "a833de6ae9b284dc6852fd2da7aeca80e922c5f3", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -156,6 +156,7 @@ package body Prj.Attr is\n    --  Configuration - Compiling\n \n    \"Sadriver#\" &\n+   \"Larequired_switches#\" &\n    \"Lapic_option#\" &\n \n    --  Configuration - Mapping files\n@@ -208,6 +209,7 @@ package body Prj.Attr is\n    --  Configuration - Binding\n \n    \"Sadriver#\" &\n+   \"Larequired_switches#\" &\n    \"Saprefix#\" &\n    \"Saobjects_path#\" &\n    \"Saobjects_path_file#\" &"}, {"sha": "67d397570c7a6949c8af17fd49f211d544fff1dc", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 1080, "deletions": 381, "changes": 1461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -939,368 +939,1118 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref;\n       Data    : in out Project_Data)\n    is\n-      Compiler_Pkg : constant Package_Id :=\n-                       Value_Of (Name_Compiler, Data.Decl.Packages, In_Tree);\n-      Binder_Pkg   : constant Package_Id :=\n-                       Value_Of (Name_Binder, Data.Decl.Packages, In_Tree);\n-      Element      : Package_Element;\n+      Dot_Replacement : File_Name_Type := No_File;\n+      Casing          : Casing_Type    := All_Lower_Case;\n+      Separate_Suffix : File_Name_Type := No_File;\n \n-      Arrays        : Array_Id;\n-      Current_Array : Array_Data;\n-      Arr_Elmt_Id   : Array_Element_Id;\n-      Arr_Element   : Array_Element;\n-      List          : String_List_Id;\n+      Lang_Index : Language_Index := No_Language_Index;\n+      --  The index of the language data being checked\n \n-      Current_Language_Index : Language_Index;\n+      Current_Language : Name_Id := No_Name;\n+      --  The name of the language\n \n-      procedure Get_Language (Name : Name_Id);\n-      --  Check if this is the name of a language of the project and\n-      --  set Current_Language_Index accordingly.\n+      Lang_Data : Language_Data;\n+      --  The data of the language being checked\n \n-      ------------------\n-      -- Get_Language --\n-      ------------------\n+      procedure Get_Language_Index_Of (Language : Name_Id);\n+      --  Get the language index of Language, if Language is one of the\n+      --  languages of the project.\n \n-      procedure Get_Language (Name : Name_Id) is\n+      procedure Process_Project_Level_Simple_Attributes;\n+      --  Process the simple attributes at the project level\n+\n+      procedure Process_Project_Level_Array_Attributes;\n+      --  Process the associate array attributes at the project level\n+\n+      procedure Process_Packages;\n+      --  Read the packages of the project\n+\n+      ---------------------------\n+      -- Get_Language_Index_Of --\n+      ---------------------------\n+\n+      procedure Get_Language_Index_Of (Language : Name_Id) is\n          Real_Language : Name_Id;\n \n       begin\n-         Get_Name_String (Name);\n+         Get_Name_String (Language);\n          To_Lower (Name_Buffer (1 .. Name_Len));\n          Real_Language := Name_Find;\n \n-         Current_Language_Index := Data.First_Language_Processing;\n-         loop\n-            exit when Current_Language_Index = No_Language_Index or else\n-            In_Tree.Languages_Data.Table (Current_Language_Index).Name =\n-              Real_Language;\n-            Current_Language_Index :=\n-              In_Tree.Languages_Data.Table (Current_Language_Index).Next;\n-         end loop;\n-      end Get_Language;\n+         --  Nothing to do if the language is the same as the current language\n \n-   --  Start of processing for Check_Configuration\n+         if Current_Language /= Real_Language then\n+            Lang_Index := Data.First_Language_Processing;\n+            while Lang_Index /= No_Language_Index loop\n+               exit when In_Tree.Languages_Data.Table (Lang_Index).Name =\n+                 Real_Language;\n+               Lang_Index :=\n+                 In_Tree.Languages_Data.Table (Lang_Index).Next;\n+            end loop;\n \n-   begin\n-      if Compiler_Pkg /= No_Package then\n-         Element := In_Tree.Packages.Table (Compiler_Pkg);\n+            if Lang_Index = No_Language_Index then\n+               Current_Language := No_Name;\n+            else\n+               Current_Language := Real_Language;\n+            end if;\n+         end if;\n+      end Get_Language_Index_Of;\n \n-         Arrays := Element.Decl.Arrays;\n-         while Arrays /= No_Array loop\n-            Current_Array := In_Tree.Arrays.Table (Arrays);\n+      ----------------------\n+      -- Process_Packages --\n+      ----------------------\n \n-            Arr_Elmt_Id := Current_Array.Value;\n-            while Arr_Elmt_Id /= No_Array_Element loop\n-               Arr_Element := In_Tree.Array_Elements.Table (Arr_Elmt_Id);\n-               Get_Language (Arr_Element.Index);\n+      procedure Process_Packages is\n+         Packages : Package_Id;\n+         Element  : Package_Element;\n \n-               if Current_Language_Index /= No_Language_Index then\n-                  case Current_Array.Name is\n-                     when Name_Dependency_Switches =>\n-                        List := Arr_Element.Value.Values;\n+         procedure Process_Binder (Arrays : Array_Id);\n+         --  Process the associate array attributes of package Binder\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"dependency option cannot be null\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+         procedure Process_Builder (Attributes : Variable_Id);\n+         --  Process the simple attributes of package Builder\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index)\n-                                 .Config.Dependency_Option,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+         procedure Process_Compiler (Arrays : Array_Id);\n+         --  Process the associate array attributes of package Compiler\n \n-                     when Name_Dependency_Driver =>\n+         procedure Process_Naming (Attributes : Variable_Id);\n+         --  Process the simple attributes of package Naming\n \n-                        --  Attribute Dependency_Driver (<language>)\n+         procedure Process_Naming (Arrays : Array_Id);\n+         --  Process the associate array attributes of package Naming\n \n-                        List := Arr_Element.Value.Values;\n+         procedure Process_Linker (Attributes : Variable_Id);\n+         --  Process the simple attributes of package Linker of a\n+         --  configuration project.\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"compute dependency cannot be null\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+         --------------------\n+         -- Process_Binder --\n+         --------------------\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index)\n-                             .Config.Compute_Dependency,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+         procedure Process_Binder (Arrays : Array_Id) is\n+            Current_Array_Id : Array_Id;\n+            Current_Array    : Array_Data;\n+            Element_Id       : Array_Element_Id;\n+            Element          : Array_Element;\n \n-                     when Name_Include_Option =>\n+         begin\n+            --  Process the associative array attribute of package Binder\n \n-                        --  Attribute Include_Option (<language>)\n+            Current_Array_Id := Arrays;\n+            while Current_Array_Id /= No_Array loop\n+               Current_Array := In_Tree.Arrays.Table (Current_Array_Id);\n \n-                        List := Arr_Element.Value.Values;\n+               Element_Id := Current_Array.Value;\n+               while Element_Id /= No_Array_Element loop\n+                  Element := In_Tree.Array_Elements.Table (Element_Id);\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"include option cannot be null\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+                  --  Get the name of the language\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index).Config.Include_Option,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+                  Get_Language_Index_Of (Element.Index);\n \n-                     when Name_Include_Path =>\n+                  if Lang_Index /= No_Language_Index then\n+                     case Current_Array.Name is\n+                        when Name_Driver =>\n \n-                        --  Attribute Include_Path (<language>)\n+                           --  Attribute Driver (<language>)\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Include_Path :=\n-                           Arr_Element.Value.Value;\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Binder_Driver :=\n+                             File_Name_Type (Element.Value.Value);\n \n-                     when Name_Include_Path_File =>\n+                        when Name_Required_Switches =>\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Binder_Required_Switches,\n+                                From_List => Element.Value.Values,\n+                                In_Tree   => In_Tree);\n \n-                        --  Attribute Include_Path_File (<language>)\n+                        when Name_Prefix =>\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Include_Path_File :=\n-                           Arr_Element.Value.Value;\n+                           --  Attribute Prefix (<language>)\n \n-                     when Name_Driver =>\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Binder_Prefix :=\n+                             Element.Value.Value;\n \n-                        --  Attribute Driver (<language>)\n+                        when Name_Objects_Path =>\n \n-                        Get_Name_String (Arr_Element.Value.Value);\n+                           --  Attribute Objects_Path (<language>)\n \n-                        if Name_Len = 0 then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"compiler driver name cannot be empty\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Objects_Path :=\n+                             Element.Value.Value;\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Compiler_Driver :=\n-                           File_Name_Type (Arr_Element.Value.Value);\n+                        when Name_Objects_Path_File =>\n \n-                     when Name_Switches =>\n+                           --  Attribute Objects_Path (<language>)\n \n-                        --  Attribute Minimum_Compiler_Options (<language>)\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Objects_Path_File :=\n+                             Element.Value.Value;\n \n-                        List := Arr_Element.Value.Values;\n+                        when others =>\n+                           null;\n+                     end case;\n+                  end if;\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index).Config.\n-                               Compiler_Min_Options,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+                  Element_Id := Element.Next;\n+               end loop;\n \n-                     when Name_Pic_Option =>\n+               Current_Array_Id := Current_Array.Next;\n+            end loop;\n+         end Process_Binder;\n \n-                        --  Attribute Pic_Option (<language>)\n+         ---------------------\n+         -- Process_Builder --\n+         ---------------------\n \n-                        List := Arr_Element.Value.Values;\n+         procedure Process_Builder (Attributes : Variable_Id) is\n+            Attribute_Id : Variable_Id;\n+            Attribute    : Variable;\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"compiler PIC option cannot be null\",\n-                               Arr_Element.Value.Location);\n-                        end if;\n+         begin\n+            --  Process non associated array attribute from package Builder\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index).Config.\n-                               Compilation_PIC_Option,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+            Attribute_Id := Attributes;\n+            while Attribute_Id /= No_Variable loop\n+               Attribute :=\n+                 In_Tree.Variable_Elements.Table (Attribute_Id);\n \n-                     when Name_Mapping_File_Switches =>\n+               if not Attribute.Value.Default then\n+                  if Attribute.Name = Name_Executable_Suffix then\n \n-                        --  Attribute Mapping_File_Switches (<language>)\n+                     --  Attribute Executable_Suffix: the suffix of the\n+                     --  executables.\n \n-                        List := Arr_Element.Value.Values;\n+                     Data.Config.Executable_Suffix :=\n+                       Attribute.Value.Value;\n+                  end if;\n+               end if;\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"mapping file switches cannot be null\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+               Attribute_Id := Attribute.Next;\n+            end loop;\n+         end Process_Builder;\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index).Config.\n-                               Mapping_File_Switches,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+         ----------------------\n+         -- Process_Compiler --\n+         ----------------------\n \n-                     when Name_Mapping_Spec_Suffix =>\n+         procedure Process_Compiler (Arrays : Array_Id) is\n+            Current_Array_Id : Array_Id;\n+            Current_Array    : Array_Data;\n+            Element_Id       : Array_Element_Id;\n+            Element          : Array_Element;\n+            List             : String_List_Id;\n \n-                        --  Attribute Mapping_Spec_Suffix (<language>)\n+         begin\n+            --  Process the associative array attribute of package Compiler\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index)\n-                          .Config.Mapping_Spec_Suffix :=\n-                            File_Name_Type (Arr_Element.Value.Value);\n+            Current_Array_Id := Arrays;\n+            while Current_Array_Id /= No_Array loop\n+               Current_Array := In_Tree.Arrays.Table (Current_Array_Id);\n \n-                     when Name_Mapping_Body_Suffix =>\n+               Element_Id := Current_Array.Value;\n+               while Element_Id /= No_Array_Element loop\n+                  Element := In_Tree.Array_Elements.Table (Element_Id);\n \n-                        --  Attribute Mapping_Body_Suffix (<language>)\n+                  --  Get the name of the language\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index)\n-                          .Config.Mapping_Body_Suffix :=\n-                            File_Name_Type (Arr_Element.Value.Value);\n+                  Get_Language_Index_Of (Element.Index);\n \n-                     when Name_Config_File_Switches =>\n+                  if Lang_Index /= No_Language_Index then\n+                     case Current_Array.Name is\n+                        when Name_Dependency_Switches =>\n \n-                        --  Attribute Config_File_Switches (<language>)\n+                           --  Attribute Dependency_Switches (<language>)\n \n-                        List := Arr_Element.Value.Values;\n+                           List := Element.Value.Values;\n \n-                        if List = Nil_String then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"config file switches cannot be null\",\n-                              Arr_Element.Value.Location);\n-                        end if;\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"dependency option cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n \n-                        Put (Into_List =>\n-                             In_Tree.Languages_Data.Table\n-                               (Current_Language_Index).Config.\n-                               Config_File_Switches,\n-                             From_List => List,\n-                             In_Tree => In_Tree);\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Dependency_Option,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n \n-                     when Name_Config_Body_File_Name =>\n+                        when Name_Dependency_Driver =>\n \n-                        --  Attribute Config_Body_File_Name (<language>)\n+                           --  Attribute Dependency_Driver (<language>)\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Config_Body :=\n-                           Arr_Element.Value.Value;\n+                           List := Element.Value.Values;\n \n-                     when Name_Config_Body_File_Name_Pattern =>\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"compute dependency cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n \n-                        --  Attribute Config_Body_File_Name_Pattern\n-                        --  (<language>)\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Compute_Dependency,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index)\n-                          .Config.Config_Body_Pattern :=\n-                          Arr_Element.Value.Value;\n+                        when Name_Include_Switches =>\n \n-                     when Name_Config_Spec_File_Name =>\n+                           --  Attribute Include_Switches (<language>)\n \n-                        --  Attribute Config_Spec_File_Name (<language>)\n+                           List := Element.Value.Values;\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Config_Spec :=\n-                          Arr_Element.Value.Value;\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"include option cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n \n-                     when Name_Config_Spec_File_Name_Pattern =>\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Include_Option,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n \n-                        --  Attribute Config_Spec_File_Name_Pattern\n-                        --  (<language>)\n+                        when Name_Include_Path =>\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index)\n-                          .Config.Config_Spec_Pattern :=\n-                          Arr_Element.Value.Value;\n+                           --  Attribute Include_Path (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Include_Path :=\n+                             Element.Value.Value;\n \n-                     when Name_Config_File_Unique =>\n+                        when Name_Include_Path_File =>\n \n-                        --  Attribute Config_File_Unique (<language>)\n+                           --  Attribute Include_Path_File (<language>)\n \n-                        begin\n                            In_Tree.Languages_Data.Table\n-                             (Current_Language_Index)\n-                             .Config.Config_File_Unique :=\n-                             Boolean'Value\n-                               (Get_Name_String (Arr_Element.Value.Value));\n-                        exception\n-                           when Constraint_Error =>\n+                             (Lang_Index).Config.Include_Path_File :=\n+                             Element.Value.Value;\n+\n+                        when Name_Driver =>\n+\n+                           --  Attribute Driver (<language>)\n+\n+                           Get_Name_String (Element.Value.Value);\n+\n+                           if Name_Len = 0 then\n                               Error_Msg\n-                                (Project, In_Tree,\n-                                 \"illegal value gor Config_File_Unique\",\n-                                 Arr_Element.Value.Location);\n-                        end;\n+                                (Project,\n+                                 In_Tree,\n+                                 \"compiler driver name cannot be empty\",\n+                                 Element.Value.Location);\n+                           end if;\n \n-                     when others =>\n-                        null;\n-                  end case;\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Compiler_Driver :=\n+                             File_Name_Type (Element.Value.Value);\n+\n+                        when Name_Required_Switches =>\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.\n+                                                 Compiler_Required_Switches,\n+                                From_List => Element.Value.Values,\n+                                In_Tree   => In_Tree);\n+\n+                        when Name_Pic_Option =>\n+\n+                           --  Attribute Compiler_Pic_Option (<language>)\n+\n+                           List := Element.Value.Values;\n+\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"compiler PIC option cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n+\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Compilation_PIC_Option,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n+\n+                        when Name_Mapping_File_Switches =>\n+\n+                           --  Attribute Mapping_File_Switches (<language>)\n+\n+                           List := Element.Value.Values;\n+\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"mapping file switches cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n+\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Mapping_File_Switches,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n+\n+                        when Name_Mapping_Spec_Suffix =>\n+\n+                           --  Attribute Mapping_Spec_Suffix (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Mapping_Spec_Suffix :=\n+                               File_Name_Type (Element.Value.Value);\n+\n+                        when Name_Mapping_Body_Suffix =>\n+\n+                           --  Attribute Mapping_Body_Suffix (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Mapping_Body_Suffix :=\n+                               File_Name_Type (Element.Value.Value);\n+\n+                        when Name_Config_File_Switches =>\n+\n+                           --  Attribute Config_File_Switches (<language>)\n+\n+                           List := Element.Value.Values;\n+\n+                           if List = Nil_String then\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"config file switches cannot be null\",\n+                                 Element.Value.Location);\n+                           end if;\n+\n+                           Put (Into_List =>\n+                                In_Tree.Languages_Data.Table\n+                                  (Lang_Index).Config.Config_File_Switches,\n+                                From_List => List,\n+                                In_Tree   => In_Tree);\n+\n+                        when Name_Objects_Path =>\n+\n+                           --  Attribute Objects_Path (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Objects_Path :=\n+                             Element.Value.Value;\n+\n+                        when Name_Objects_Path_File =>\n+\n+                           --  Attribute Objects_Path_File (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Objects_Path_File :=\n+                             Element.Value.Value;\n+\n+                        when Name_Config_Body_File_Name =>\n+\n+                           --  Attribute Config_Body_File_Name (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Config_Body :=\n+                             Element.Value.Value;\n+\n+                        when Name_Config_Body_File_Name_Pattern =>\n+\n+                           --  Attribute Config_Body_File_Name_Pattern\n+                           --  (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Config_Body_Pattern :=\n+                               Element.Value.Value;\n+\n+                        when Name_Config_Spec_File_Name =>\n+\n+                           --  Attribute Config_Spec_File_Name (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Config_Spec :=\n+                             Element.Value.Value;\n+\n+                        when Name_Config_Spec_File_Name_Pattern =>\n+\n+                           --  Attribute Config_Spec_File_Name_Pattern\n+                           --  (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Config_Spec_Pattern :=\n+                               Element.Value.Value;\n+\n+                        when Name_Config_File_Unique =>\n+\n+                           --  Attribute Config_File_Unique (<language>)\n+\n+                           begin\n+                              In_Tree.Languages_Data.Table\n+                                (Lang_Index).Config.Config_File_Unique :=\n+                                  Boolean'Value\n+                                    (Get_Name_String (Element.Value.Value));\n+                           exception\n+                              when Constraint_Error =>\n+                                 Error_Msg\n+                                   (Project,\n+                                    In_Tree,\n+                                    \"illegal value for Config_File_Unique\",\n+                                    Element.Value.Location);\n+                           end;\n+\n+                        when others =>\n+                           null;\n+                     end case;\n+                  end if;\n+\n+                  Element_Id := Element.Next;\n+               end loop;\n+\n+               Current_Array_Id := Current_Array.Next;\n+            end loop;\n+         end Process_Compiler;\n+\n+         --------------------\n+         -- Process_Naming --\n+         --------------------\n+\n+         procedure Process_Naming (Attributes : Variable_Id) is\n+            Attribute_Id : Variable_Id;\n+            Attribute    : Variable;\n+\n+         begin\n+            --  Process non associated array attribute from package Naming\n+\n+            Attribute_Id := Attributes;\n+            while Attribute_Id /= No_Variable loop\n+               Attribute :=\n+                 In_Tree.Variable_Elements.Table (Attribute_Id);\n+\n+               if not Attribute.Value.Default then\n+                  if Attribute.Name = Name_Separate_Suffix then\n+\n+                     --  Attribute Separate_Suffix\n+\n+                     Separate_Suffix := File_Name_Type (Attribute.Value.Value);\n+\n+                  elsif Attribute.Name = Name_Casing then\n+\n+                     --  Attribute Casing\n+\n+                     begin\n+                        Casing :=\n+                          Value (Get_Name_String (Attribute.Value.Value));\n+\n+                     exception\n+                        when Constraint_Error =>\n+                           Error_Msg\n+                             (Project,\n+                              In_Tree,\n+                              \"invalid value for Casing\",\n+                              Attribute.Value.Location);\n+                     end;\n+\n+                  elsif Attribute.Name = Name_Dot_Replacement then\n+\n+                     --  Attribute Dot_Replacement\n+\n+                     Dot_Replacement := File_Name_Type (Attribute.Value.Value);\n+\n+                  end if;\n                end if;\n \n-               Arr_Elmt_Id := Arr_Element.Next;\n+               Attribute_Id := Attribute.Next;\n             end loop;\n+         end Process_Naming;\n+\n+         procedure Process_Naming (Arrays : Array_Id) is\n+            Current_Array_Id : Array_Id;\n+            Current_Array    : Array_Data;\n+            Element_Id       : Array_Element_Id;\n+            Element          : Array_Element;\n+         begin\n+            --  Process the associative array attribute of package Naming\n+\n+            Current_Array_Id := Arrays;\n+            while Current_Array_Id /= No_Array loop\n+               Current_Array := In_Tree.Arrays.Table (Current_Array_Id);\n+\n+               Element_Id := Current_Array.Value;\n+               while Element_Id /= No_Array_Element loop\n+                  Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+                  --  Get the name of the language\n+\n+                  Get_Language_Index_Of (Element.Index);\n+\n+                  if Lang_Index /= No_Language_Index then\n+                     case Current_Array.Name is\n+                        when Name_Specification_Suffix | Name_Spec_Suffix =>\n+\n+                           --  Attribute Spec_Suffix (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Naming_Data.Spec_Suffix :=\n+                               File_Name_Type (Element.Value.Value);\n+\n+                        when Name_Implementation_Suffix | Name_Body_Suffix =>\n+\n+                           --  Attribute Body_Suffix (<language>)\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Naming_Data.Body_Suffix :=\n+                               File_Name_Type (Element.Value.Value);\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Naming_Data.Separate_Suffix :=\n+                               File_Name_Type (Element.Value.Value);\n+\n+                        when others =>\n+                           null;\n+                     end case;\n+                  end if;\n+\n+                  Element_Id := Element.Next;\n+               end loop;\n+\n+               Current_Array_Id := Current_Array.Next;\n+            end loop;\n+         end Process_Naming;\n+\n+         --------------------\n+         -- Process_Linker --\n+         --------------------\n+\n+         procedure Process_Linker (Attributes : Variable_Id) is\n+            Attribute_Id : Variable_Id;\n+            Attribute    : Variable;\n+\n+         begin\n+            --  Process non associated array attribute from package Linker\n+\n+            Attribute_Id := Attributes;\n+            while Attribute_Id /= No_Variable loop\n+               Attribute :=\n+                 In_Tree.Variable_Elements.Table (Attribute_Id);\n+\n+               if not Attribute.Value.Default then\n+                  if Attribute.Name = Name_Driver then\n+\n+                     --  Attribute Linker'Driver: the default linker to use\n+\n+                     Data.Config.Linker :=\n+                       Path_Name_Type (Attribute.Value.Value);\n+\n+                  elsif\n+                    Attribute.Name = Name_Required_Switches\n+                  then\n+\n+                     --  Attribute Required_Switches: the minimum\n+                     --  options to use when invoking the linker\n+\n+                     Put (Into_List =>\n+                            Data.Config.Minimum_Linker_Options,\n+                          From_List => Attribute.Value.Values,\n+                          In_Tree   => In_Tree);\n+\n+                  end if;\n+               end if;\n+\n+               Attribute_Id := Attribute.Next;\n+            end loop;\n+         end Process_Linker;\n+\n+      --  Start of processing for Process_Packages\n+\n+      begin\n+         Packages := Data.Decl.Packages;\n+         while Packages /= No_Package loop\n+            Element := In_Tree.Packages.Table (Packages);\n+\n+            case Element.Name is\n+               when Name_Binder =>\n+\n+                  --  Process attributes of package Binder\n+\n+                  Process_Binder (Element.Decl.Arrays);\n+\n+               when Name_Builder =>\n+\n+                  --  Process attributes of package Builder\n+\n+                  Process_Builder (Element.Decl.Attributes);\n+\n+               when Name_Compiler =>\n+\n+                  --  Process attributes of package Compiler\n+\n+                  Process_Compiler (Element.Decl.Arrays);\n+\n+               when Name_Linker =>\n+\n+                  --  Process attributes of package Linker\n+\n+                  Process_Linker (Element.Decl.Attributes);\n+\n+               when Name_Naming =>\n+\n+                  --  Process attributes of package Naming\n+\n+                  Process_Naming (Element.Decl.Attributes);\n+                  Process_Naming (Element.Decl.Arrays);\n+\n+               when others =>\n+                  null;\n+            end case;\n \n-            Arrays := Current_Array.Next;\n+            Packages := Element.Next;\n          end loop;\n-      end if;\n+      end Process_Packages;\n \n-      --  Comment needed here ???\n+      ---------------------------------------------\n+      -- Process_Project_Level_Simple_Attributes --\n+      ---------------------------------------------\n \n-      if Binder_Pkg /= No_Package then\n-         Element := In_Tree.Packages.Table (Binder_Pkg);\n-         Arrays := Element.Decl.Arrays;\n-         while Arrays /= No_Array loop\n-            Current_Array := In_Tree.Arrays.Table (Arrays);\n+      procedure Process_Project_Level_Simple_Attributes is\n+         Attribute_Id : Variable_Id;\n+         Attribute    : Variable;\n+         List         : String_List_Id;\n \n-            Arr_Elmt_Id := Current_Array.Value;\n-            while Arr_Elmt_Id /= No_Array_Element loop\n-               Arr_Element := In_Tree.Array_Elements.Table (Arr_Elmt_Id);\n+      begin\n+         --  Process non associated array attribute at project level\n \n-               Get_Language (Arr_Element.Index);\n+         Attribute_Id := Data.Decl.Attributes;\n+         while Attribute_Id /= No_Variable loop\n+            Attribute :=\n+              In_Tree.Variable_Elements.Table (Attribute_Id);\n \n-               if Current_Language_Index /= No_Language_Index then\n-                  case Current_Array.Name is\n-                     when Name_Driver =>\n+            if not Attribute.Value.Default then\n+               if Attribute.Name = Name_Library_Builder then\n \n-                        --  Attribute Driver (<language>)\n+                  --  Attribute Library_Builder: the application to invoke\n+                  --  to build libraries.\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Binder_Driver :=\n-                          File_Name_Type (Arr_Element.Value.Value);\n+                  Data.Config.Library_Builder :=\n+                    Path_Name_Type (Attribute.Value.Value);\n \n-                     when Name_Objects_Path =>\n+               elsif Attribute.Name = Name_Archive_Builder then\n \n-                        --  Attribute Objects_Path (<language>)\n+                  --  Attribute Archive_Builder: the archive builder\n+                  --  (usually \"ar\") and its minimum options (usually \"cr\").\n \n-                        In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Objects_Path :=\n-                           Arr_Element.Value.Value;\n+                  List := Attribute.Value.Values;\n+\n+                  if List = Nil_String then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"archive builder cannot be null\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Put (Into_List => Data.Config.Archive_Builder,\n+                       From_List => List,\n+                       In_Tree   => In_Tree);\n+\n+               elsif Attribute.Name = Name_Archive_Indexer then\n+\n+                  --  Attribute Archive_Indexer: the optional archive\n+                  --  indexer (usually \"ranlib\") with its minimum options\n+                  --  (usually none).\n+\n+                  List := Attribute.Value.Values;\n+\n+                  if List = Nil_String then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"archive indexer cannot be null\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Put (Into_List => Data.Config.Archive_Indexer,\n+                       From_List => List,\n+                       In_Tree   => In_Tree);\n+\n+               elsif Attribute.Name = Name_Library_Partial_Linker then\n+\n+                  --  Attribute Library_Partial_Linker: the optional linker\n+                  --  driver with its minimum options, to partially link\n+                  --  archives.\n+\n+                  List := Attribute.Value.Values;\n+\n+                  if List = Nil_String then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"partial linker cannot be null\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Put (Into_List => Data.Config.Lib_Partial_Linker,\n+                       From_List => List,\n+                       In_Tree   => In_Tree);\n+\n+               elsif Attribute.Name = Name_Archive_Suffix then\n+                  Data.Config.Archive_Suffix :=\n+                    File_Name_Type (Attribute.Value.Value);\n+\n+               elsif Attribute.Name = Name_Linker_Executable_Option then\n+\n+                  --  Attribute Linker_Executable_Option: optional options\n+                  --  to specify an executable name. Defaults to \"-o\".\n+\n+                  List := Attribute.Value.Values;\n+\n+                  if List = Nil_String then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"linker executable option cannot be null\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Put (Into_List => Data.Config.Linker_Executable_Option,\n+                       From_List => List,\n+                       In_Tree   => In_Tree);\n+\n+               elsif Attribute.Name = Name_Linker_Lib_Dir_Option then\n+\n+                  --  Attribute Linker_Lib_Dir_Option: optional options\n+                  --  to specify a library search directory. Defaults to\n+                  --  \"-L\".\n+\n+                  Get_Name_String (Attribute.Value.Value);\n+\n+                  if Name_Len = 0 then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"linker library directory option cannot be empty\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Data.Config.Linker_Lib_Dir_Option := Attribute.Value.Value;\n+\n+               elsif Attribute.Name = Name_Linker_Lib_Name_Option then\n+\n+                  --  Attribute Linker_Lib_Name_Option: optional options\n+                  --  to specify the name of a library to be linked in.\n+                  --  Defaults to \"-l\".\n+\n+                  Get_Name_String (Attribute.Value.Value);\n+\n+                  if Name_Len = 0 then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"linker library name option cannot be empty\",\n+                        Attribute.Value.Location);\n+                  end if;\n+\n+                  Data.Config.Linker_Lib_Name_Option := Attribute.Value.Value;\n+\n+               elsif Attribute.Name = Name_Run_Path_Option then\n+\n+                  --  Attribute Run_Path_Option: optional options to\n+                  --  specify a path for libraries.\n+\n+                  List := Attribute.Value.Values;\n+\n+                  if List /= Nil_String then\n+                     Put (Into_List => Data.Config.Run_Path_Option,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+                  end if;\n+\n+               elsif Attribute.Name = Name_Library_Support then\n+                  declare\n+                     pragma Unsuppress (All_Checks);\n+                  begin\n+                     Data.Config.Lib_Support :=\n+                       Library_Support'Value (Get_Name_String\n+                                              (Attribute.Value.Value));\n+                  exception\n+                     when Constraint_Error =>\n+                        Error_Msg\n+                          (Project,\n+                           In_Tree,\n+                           \"invalid value \"\"\" &\n+                           Get_Name_String (Attribute.Value.Value) &\n+                           \"\"\" for Library_Support\",\n+                           Attribute.Value.Location);\n+                  end;\n \n-                     when Name_Objects_Path_File =>\n+               elsif Attribute.Name = Name_Shared_Library_Prefix then\n+                  Data.Config.Shared_Lib_Prefix :=\n+                    File_Name_Type (Attribute.Value.Value);\n \n-                        --  Attribute Objects_Path_File (<language>)\n+               elsif Attribute.Name = Name_Shared_Library_Suffix then\n+                  Data.Config.Shared_Lib_Suffix :=\n+                    File_Name_Type (Attribute.Value.Value);\n+\n+               elsif Attribute.Name = Name_Symbolic_Link_Supported then\n+                  declare\n+                     pragma Unsuppress (All_Checks);\n+                  begin\n+                     Data.Config.Symbolic_Link_Supported :=\n+                       Boolean'Value (Get_Name_String\n+                                      (Attribute.Value.Value));\n+                  exception\n+                     when Constraint_Error =>\n+                        Error_Msg\n+                          (Project,\n+                           In_Tree,\n+                           \"invalid value \"\"\" &\n+                           Get_Name_String (Attribute.Value.Value) &\n+                           \"\"\" for Symbolic_Link_Supported\",\n+                           Attribute.Value.Location);\n+                  end;\n+\n+               elsif\n+                 Attribute.Name = Name_Library_Major_Minor_Id_Supported\n+               then\n+                  declare\n+                     pragma Unsuppress (All_Checks);\n+                  begin\n+                     Data.Config.Lib_Maj_Min_Id_Supported :=\n+                       Boolean'Value (Get_Name_String\n+                                      (Attribute.Value.Value));\n+                  exception\n+                     when Constraint_Error =>\n+                        Error_Msg\n+                          (Project,\n+                           In_Tree,\n+                           \"invalid value \"\"\" &\n+                           Get_Name_String (Attribute.Value.Value) &\n+                           \"\"\" for Library_Major_Minor_Id_Supported\",\n+                           Attribute.Value.Location);\n+                  end;\n+\n+               elsif\n+                 Attribute.Name = Name_Library_Auto_Init_Supported\n+               then\n+                  declare\n+                     pragma Unsuppress (All_Checks);\n+                  begin\n+                     Data.Config.Auto_Init_Supported :=\n+                       Boolean'Value (Get_Name_String\n+                                      (Attribute.Value.Value));\n+                  exception\n+                     when Constraint_Error =>\n+                        Error_Msg\n+                          (Project,\n+                           In_Tree,\n+                           \"invalid value \"\"\" &\n+                           Get_Name_String (Attribute.Value.Value) &\n+                           \"\"\" for Library_Auto_Init_Supported\",\n+                           Attribute.Value.Location);\n+                  end;\n+\n+               elsif\n+                 Attribute.Name = Name_Shared_Library_Minimum_Switches\n+               then\n+                  List := Attribute.Value.Values;\n+\n+                  if List /= Nil_String then\n+                     Put (Into_List => Data.Config.Shared_Lib_Min_Options,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+                  end if;\n+\n+               elsif\n+                 Attribute.Name = Name_Library_Version_Switches\n+               then\n+                  List := Attribute.Value.Values;\n+\n+                  if List /= Nil_String then\n+                     Put (Into_List => Data.Config.Lib_Version_Options,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Attribute_Id := Attribute.Next;\n+         end loop;\n+      end Process_Project_Level_Simple_Attributes;\n+\n+      --------------------------------------------\n+      -- Process_Project_Level_Array_Attributes --\n+      --------------------------------------------\n+\n+      procedure Process_Project_Level_Array_Attributes is\n+         Current_Array_Id : Array_Id;\n+         Current_Array    : Array_Data;\n+         Element_Id       : Array_Element_Id;\n+         Element          : Array_Element;\n+\n+      begin\n+         --  Process the associative array attributes at project level\n+\n+         Current_Array_Id := Data.Decl.Arrays;\n+         while Current_Array_Id /= No_Array loop\n+            Current_Array := In_Tree.Arrays.Table (Current_Array_Id);\n+\n+            Element_Id := Current_Array.Value;\n+            while Element_Id /= No_Array_Element loop\n+               Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+               --  Get the name of the language\n+\n+               Get_Language_Index_Of (Element.Index);\n+\n+               if Lang_Index /= No_Language_Index then\n+                  case Current_Array.Name is\n+                     when Name_Toolchain_Description =>\n+\n+                        --  Attribute Toolchain_Description (<language>)\n \n                         In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Objects_Path_File :=\n-                           Arr_Element.Value.Value;\n+                          (Lang_Index).Config.Toolchain_Description :=\n+                          Element.Value.Value;\n \n-                     when Name_Prefix =>\n+                     when Name_Toolchain_Version =>\n \n-                        --  Attribute Prefix (<language>)\n+                        --  Attribute Toolchain_Version (<language>)\n \n                         In_Tree.Languages_Data.Table\n-                          (Current_Language_Index).Config.Binder_Prefix :=\n-                          Arr_Element.Value.Value;\n+                          (Lang_Index).Config.Toolchain_Version :=\n+                          Element.Value.Value;\n \n                      when others =>\n                         null;\n                   end case;\n                end if;\n \n-               Arr_Elmt_Id := Arr_Element.Next;\n+               Element_Id := Element.Next;\n             end loop;\n \n-            Arrays := Current_Array.Next;\n+            Current_Array_Id := Current_Array.Next;\n          end loop;\n+      end Process_Project_Level_Array_Attributes;\n+\n+   begin\n+      Process_Project_Level_Simple_Attributes;\n+\n+      Process_Project_Level_Array_Attributes;\n+\n+      Process_Packages;\n+\n+      --  For unit based languages, set Casing, Dot_Replacement and\n+      --  Separate_Suffix in Naming_Data.\n+\n+      Lang_Index := Data.First_Language_Processing;\n+      while Lang_Index /= No_Language_Index loop\n+         if In_Tree.Languages_Data.Table\n+           (Lang_Index).Name = Name_Ada\n+         then\n+            In_Tree.Languages_Data.Table\n+              (Lang_Index).Config.Naming_Data.Casing := Casing;\n+            In_Tree.Languages_Data.Table\n+              (Lang_Index).Config.Naming_Data.Dot_Replacement :=\n+              Dot_Replacement;\n+\n+            if Separate_Suffix /= No_File then\n+               In_Tree.Languages_Data.Table\n+                 (Lang_Index).Config.Naming_Data.Separate_Suffix :=\n+                 Separate_Suffix;\n+            end if;\n+\n+            exit;\n+         end if;\n+\n+         Lang_Index := In_Tree.Languages_Data.Table (Lang_Index).Next;\n+      end loop;\n+\n+      --  Give empty names to various prefixes/suffixes, if they have not\n+      --  been specified in the configuration.\n+\n+      if Data.Config.Archive_Suffix = No_File then\n+         Data.Config.Archive_Suffix := Empty_File;\n       end if;\n+\n+      if Data.Config.Shared_Lib_Prefix = No_File then\n+         Data.Config.Shared_Lib_Prefix := Empty_File;\n+      end if;\n+\n+      if Data.Config.Shared_Lib_Suffix = No_File then\n+         Data.Config.Shared_Lib_Suffix := Empty_File;\n+      end if;\n+\n+      Lang_Index := Data.First_Language_Processing;\n+      while Lang_Index /= No_Language_Index loop\n+         Lang_Data := In_Tree.Languages_Data.Table (Lang_Index);\n+\n+         Current_Language := Lang_Data.Display_Name;\n+\n+         if Lang_Data.Name = Name_Ada then\n+\n+            --  For unit based languages, Dot_Replacement, Spec_Suffix and\n+            --  Body_Suffix need to be specified.\n+\n+            if Lang_Data.Config.Naming_Data.Dot_Replacement = No_File then\n+               Error_Msg\n+                 (Project,\n+                  In_Tree,\n+                  \"Dot_Replacement not specified for Ada\",\n+                  No_Location);\n+            end if;\n+\n+            if Lang_Data.Config.Naming_Data.Spec_Suffix = No_File then\n+               Error_Msg\n+                 (Project,\n+                  In_Tree,\n+                  \"Spec_Suffix not specified for Ada\",\n+                  No_Location);\n+            end if;\n+\n+            if Lang_Data.Config.Naming_Data.Body_Suffix = No_File then\n+               Error_Msg\n+                 (Project,\n+                  In_Tree,\n+                  \"Body_Suffix not specified for Ada\",\n+                  No_Location);\n+            end if;\n+\n+         else\n+            --  For file based languages, either Spec_Suffix or Body_Suffix\n+            --  need to be specified.\n+\n+            if Lang_Data.Config.Naming_Data.Spec_Suffix = No_File and then\n+              Lang_Data.Config.Naming_Data.Body_Suffix = No_File\n+            then\n+               Error_Msg\n+                 (Project,\n+                  In_Tree,\n+                  \"no suffixes specified for \" &\n+                  Get_Name_String (Current_Language),\n+                  No_Location);\n+            end if;\n+         end if;\n+\n+         --  For all languages, Compiler_Driver needs to be specified\n+\n+         if Lang_Data.Config.Compiler_Driver = No_File then\n+            Error_Msg\n+              (Project,\n+               In_Tree,\n+               \"no compiler specified for \" &\n+               Get_Name_String (Current_Language),\n+               No_Location);\n+         end if;\n+\n+         Lang_Index := Lang_Data.Next;\n+      end loop;\n    end Check_Configuration;\n \n    ----------------------\n@@ -2840,7 +3590,7 @@ package body Prj.Nmsc is\n \n       if Data.Library then\n          if Get_Mode = Multi_Language then\n-            Support_For_Libraries := In_Tree.Config.Lib_Support;\n+            Support_For_Libraries := Data.Config.Lib_Support;\n \n          else\n             Support_For_Libraries := MLib.Tgt.Support_For_Libraries;\n@@ -3325,11 +4075,16 @@ package body Prj.Nmsc is\n       Data          : in out Project_Data)\n    is\n       Languages : Variable_Value := Nil_Variable_Value;\n-      Lang      : Language_Index;\n+      Def_Lang  : Variable_Value := Nil_Variable_Value;\n+      Def_Lang_Id : Name_Id;\n \n    begin\n+      Data.First_Language_Processing := No_Language_Index;\n       Languages :=\n         Prj.Util.Value_Of (Name_Languages, Data.Decl.Attributes, In_Tree);\n+      Def_Lang :=\n+        Prj.Util.Value_Of\n+          (Name_Default_Language, Data.Decl.Attributes, In_Tree);\n       Data.Ada_Sources_Present   := Data.Source_Dirs /= Nil_String;\n       Data.Other_Sources_Present := Data.Source_Dirs /= Nil_String;\n \n@@ -3360,65 +4115,58 @@ package body Prj.Nmsc is\n \n                Data.Other_Sources_Present := False;\n \n-            elsif In_Tree.Default_Language = No_Name then\n+            elsif Def_Lang.Default then\n                Error_Msg\n                  (Project,\n                   In_Tree,\n                   \"no languages defined for this project\",\n                   Data.Location);\n \n             else\n+               Get_Name_String (Def_Lang.Value);\n+               To_Lower (Name_Buffer (1 .. Name_Len));\n+               Def_Lang_Id := Name_Find;\n                In_Tree.Name_Lists.Table (Data.Languages) :=\n-                 (Name => In_Tree.Default_Language, Next => No_Name_List);\n+                 (Name => Def_Lang_Id, Next => No_Name_List);\n                Language_Data_Table.Increment_Last (In_Tree.Languages_Data);\n                Data.First_Language_Processing :=\n                  Language_Data_Table.Last (In_Tree.Languages_Data);\n                In_Tree.Languages_Data.Table\n                  (Data.First_Language_Processing) := No_Language_Data;\n                In_Tree.Languages_Data.Table\n-                 (Data.First_Language_Processing).Name :=\n-                 In_Tree.Default_Language;\n-               Get_Name_String (In_Tree.Default_Language);\n+                 (Data.First_Language_Processing).Name := Def_Lang_Id;\n+               Get_Name_String (Def_Lang_Id);\n                Name_Buffer (1) := GNAT.Case_Util.To_Upper (Name_Buffer (1));\n                In_Tree.Languages_Data.Table\n                  (Data.First_Language_Processing).Display_Name := Name_Find;\n \n-               Lang := In_Tree.First_Language;\n-\n-               while Lang /= No_Language_Index loop\n-                  if In_Tree.Languages_Data.Table (Lang).Name =\n-                    In_Tree.Default_Language\n-                  then\n-                     In_Tree.Languages_Data.Table\n-                       (Data.First_Language_Processing).Config :=\n-                       In_Tree.Languages_Data.Table (Lang).Config;\n-\n-                     if In_Tree.Languages_Data.Table (Lang).Config.Kind =\n-                       Unit_Based\n-                     then\n-                        Data.Unit_Based_Language_Name :=\n-                          In_Tree.Default_Language;\n-                        Data.Unit_Based_Language_Index :=\n-                          Data.First_Language_Processing;\n-                     end if;\n-\n-                     exit;\n-                  end if;\n+               if Def_Lang_Id = Name_Ada then\n+                  In_Tree.Languages_Data.Table\n+                    (Data.First_Language_Processing).Config.Kind := Unit_Based;\n+                  In_Tree.Languages_Data.Table\n+                    (Data.First_Language_Processing).Config.Dependency_Kind :=\n+                    ALI_File;\n+                  Data.Unit_Based_Language_Name := Name_Ada;\n+                  Data.Unit_Based_Language_Index :=\n+                    Data.First_Language_Processing;\n+               else\n+                  In_Tree.Languages_Data.Table\n+                    (Data.First_Language_Processing).Config.Kind := File_Based;\n+                  In_Tree.Languages_Data.Table\n+                    (Data.First_Language_Processing).Config.Dependency_Kind :=\n+                    Makefile;\n+               end if;\n \n-                  Lang := In_Tree.Languages_Data.Table (Lang).Next;\n-               end loop;\n             end if;\n \n          else\n             declare\n                Current           : String_List_Id := Languages.Values;\n                Element           : String_Element;\n                Lang_Name         : Name_Id;\n-               Display_Lang_Name : Name_Id;\n                Index             : Language_Index;\n                Lang_Data         : Language_Data;\n                NL_Id             : Name_List_Index := No_Name_List;\n-               Config            : Language_Config;\n \n             begin\n                if Get_Mode = Ada_Only then\n@@ -3440,133 +4188,84 @@ package body Prj.Nmsc is\n                   while Current /= Nil_String loop\n                      Element :=\n                        In_Tree.String_Elements.Table (Current);\n-                     Display_Lang_Name := Element.Value;\n                      Get_Name_String (Element.Value);\n                      To_Lower (Name_Buffer (1 .. Name_Len));\n                      Lang_Name := Name_Find;\n \n-                     Name_List_Table.Increment_Last (In_Tree.Name_Lists);\n+                     NL_Id := Data.Languages;\n+                     while NL_Id /= No_Name_List loop\n+                        exit when\n+                          Lang_Name = In_Tree.Name_Lists.Table (NL_Id).Name;\n+                        NL_Id := In_Tree.Name_Lists.Table (NL_Id).Next;\n+                     end loop;\n \n                      if NL_Id = No_Name_List then\n-                        Data.Languages :=\n-                          Name_List_Table.Last (In_Tree.Name_Lists);\n-\n-                     else\n-                        In_Tree.Name_Lists.Table (NL_Id).Next :=\n-                          Name_List_Table.Last (In_Tree.Name_Lists);\n-                     end if;\n+                        Name_List_Table.Increment_Last (In_Tree.Name_Lists);\n \n-                     NL_Id := Name_List_Table.Last (In_Tree.Name_Lists);\n-                     In_Tree.Name_Lists.Table (NL_Id) :=\n-                       (Lang_Name, No_Name_List);\n+                        if Data.Languages = No_Name_List then\n+                           Data.Languages :=\n+                             Name_List_Table.Last (In_Tree.Name_Lists);\n \n-                     if Get_Mode = Ada_Only then\n-                        Index := Language_Indexes.Get (Lang_Name);\n+                        else\n+                           NL_Id := Data.Languages;\n+                           while In_Tree.Name_Lists.Table (NL_Id).Next /=\n+                                   No_Name_List\n+                           loop\n+                              NL_Id := In_Tree.Name_Lists.Table (NL_Id).Next;\n+                           end loop;\n \n-                        if Index = No_Language_Index then\n-                           Add_Language_Name (Lang_Name);\n-                           Index := Last_Language_Index;\n+                           In_Tree.Name_Lists.Table (NL_Id).Next :=\n+                             Name_List_Table.Last (In_Tree.Name_Lists);\n                         end if;\n \n-                        Set (Index, True, Data, In_Tree);\n-                        Set (Language_Processing =>\n-                               Default_Language_Processing_Data,\n-                             For_Language        => Index,\n-                             In_Project          => Data,\n-                             In_Tree             => In_Tree);\n+                        NL_Id := Name_List_Table.Last (In_Tree.Name_Lists);\n+                        In_Tree.Name_Lists.Table (NL_Id) :=\n+                          (Lang_Name, No_Name_List);\n \n-                        if Index = Ada_Language_Index then\n-                           Data.Ada_Sources_Present := True;\n+                        if Get_Mode = Ada_Only then\n+                           Index := Language_Indexes.Get (Lang_Name);\n \n-                        else\n-                           Data.Other_Sources_Present := True;\n-                        end if;\n+                           if Index = No_Language_Index then\n+                              Add_Language_Name (Lang_Name);\n+                              Index := Last_Language_Index;\n+                           end if;\n \n-                     else\n-                        Index := Data.First_Language_Processing;\n+                           Set (Index, True, Data, In_Tree);\n+                           Set (Language_Processing =>\n+                                  Default_Language_Processing_Data,\n+                                For_Language        => Index,\n+                                In_Project          => Data,\n+                                In_Tree             => In_Tree);\n \n-                        while Index /= No_Language_Index loop\n-                           exit when\n-                             Lang_Name =\n-                               In_Tree.Languages_Data.Table (Index).Name;\n-                           Index := In_Tree.Languages_Data.Table (Index).Next;\n-                        end loop;\n+                           if Index = Ada_Language_Index then\n+                              Data.Ada_Sources_Present := True;\n \n-                        if Index = No_Language_Index then\n+                           else\n+                              Data.Other_Sources_Present := True;\n+                           end if;\n+\n+                        else\n                            Language_Data_Table.Increment_Last\n-                             (In_Tree.Languages_Data);\n+                                                 (In_Tree.Languages_Data);\n                            Index :=\n                              Language_Data_Table.Last (In_Tree.Languages_Data);\n                            Lang_Data.Name := Lang_Name;\n                            Lang_Data.Display_Name := Element.Value;\n                            Lang_Data.Next := Data.First_Language_Processing;\n-                           In_Tree.Languages_Data.Table (Index) := Lang_Data;\n-                           Data.First_Language_Processing := Index;\n \n-                           Index := In_Tree.First_Language;\n-\n-                           while Index /= No_Language_Index loop\n-                              exit when\n-                                Lang_Name =\n-                                  In_Tree.Languages_Data.Table (Index).Name;\n-                              Index :=\n-                                In_Tree.Languages_Data.Table (Index).Next;\n-                           end loop;\n-\n-                           if Index = No_Language_Index then\n-                              Error_Msg\n-                                (Project, In_Tree,\n-                                 \"language \"\"\" &\n-                                 Get_Name_String (Display_Lang_Name) &\n-                                 \"\"\" not found in configuration\",\n-                                 Languages.Location);\n+                           if Lang_Name = Name_Ada then\n+                              Lang_Data.Config.Kind := Unit_Based;\n+                              Lang_Data.Config.Dependency_Kind := ALI_File;\n+                              Data.Unit_Based_Language_Name := Name_Ada;\n+                              Data.Unit_Based_Language_Index := Index;\n \n                            else\n-                              Config :=\n-                                In_Tree.Languages_Data.Table (Index).Config;\n-\n-                              --  Duplicate name lists\n-\n-                              Duplicate\n-                                (Config.Compiler_Min_Options, In_Tree);\n-                              Duplicate\n-                                (Config.Compilation_PIC_Option, In_Tree);\n-                              Duplicate\n-                                (Config.Mapping_File_Switches, In_Tree);\n-                              Duplicate\n-                                (Config.Config_File_Switches, In_Tree);\n-                              Duplicate\n-                                (Config.Dependency_Option, In_Tree);\n-                              Duplicate\n-                                (Config.Compute_Dependency, In_Tree);\n-                              Duplicate\n-                                (Config.Include_Option, In_Tree);\n-                              Duplicate\n-                                (Config.Binder_Min_Options, In_Tree);\n-\n-                              In_Tree.Languages_Data.Table\n-                                (Data.First_Language_Processing).Config :=\n-                                Config;\n-\n-                              if Config.Kind = Unit_Based then\n-                                 if\n-                                   Data.Unit_Based_Language_Name = No_Name\n-                                 then\n-                                    Data.Unit_Based_Language_Name := Lang_Name;\n-                                    Data.Unit_Based_Language_Index :=\n-                                      Language_Data_Table.Last\n-                                        (In_Tree.Languages_Data);\n-\n-                                 else\n-                                    Error_Msg\n-                                      (Project, In_Tree,\n-                                       \"not allowed to have several \" &\n-                                       \"unit-based languages in the same \" &\n-                                       \"project\",\n-                                       Languages.Location);\n-                                 end if;\n-                              end if;\n+                              Lang_Data.Config.Kind := File_Based;\n+                              Lang_Data.Config.Dependency_Kind := Makefile;\n                            end if;\n+\n+                           In_Tree.Languages_Data.Table (Index) := Lang_Data;\n+                           Data.First_Language_Processing := Index;\n                         end if;\n                      end if;\n \n@@ -3665,7 +4364,7 @@ package body Prj.Nmsc is\n \n    begin\n       if Get_Mode = Multi_Language then\n-         Auto_Init_Supported := In_Tree.Config.Auto_Init_Supported;\n+         Auto_Init_Supported := Data.Config.Auto_Init_Supported;\n \n       else\n          Auto_Init_Supported :="}, {"sha": "f6a161039fb1d5c88173f4658c47c79a5ab62092", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 256, "deletions": 510, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -1,4 +1,5 @@\n ------------------------------------------------------------------------------\n+\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -31,7 +32,6 @@ with Prj.Attr; use Prj.Attr;\n with Prj.Err;  use Prj.Err;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Nmsc; use Prj.Nmsc;\n-with Prj.Util; use Prj.Util;\n with Sinput;   use Sinput;\n with Snames;\n \n@@ -1195,464 +1195,27 @@ package body Prj.Proc is\n       When_No_Sources        : Error_Warning := Error;\n       Reset_Tree             : Boolean := True)\n    is\n-      Obj_Dir    : Path_Name_Type;\n-      Extending  : Project_Id;\n-      Extending2 : Project_Id;\n-      Packages   : Package_Id;\n-      Element    : Package_Element;\n-\n-      procedure Process_Attributes (Attrs : Variable_Id);\n-\n-      ------------------------\n-      -- Process_Attributes --\n-      ------------------------\n-\n-      procedure Process_Attributes (Attrs : Variable_Id) is\n-         Attribute_Id : Variable_Id;\n-         Attribute    : Variable;\n-         List         : String_List_Id;\n-\n-      begin\n-         --  Loop through attributes\n-\n-         Attribute_Id := Attrs;\n-         while Attribute_Id /= No_Variable loop\n-            Attribute :=\n-              In_Tree.Variable_Elements.Table (Attribute_Id);\n-\n-            if not Attribute.Value.Default then\n-               case Attribute.Name is\n-                  when Snames.Name_Driver =>\n-\n-                     --  Attribute Linker'Driver: the default linker to use\n-\n-                     In_Tree.Config.Linker :=\n-                       Path_Name_Type (Attribute.Value.Value);\n-\n-                  when Snames.Name_Required_Switches =>\n-\n-                     --  Attribute Linker'Required_Switches: the minimum\n-                     --  options to use when invoking the linker\n-\n-                     Put (Into_List =>\n-                          In_Tree.Config.Minimum_Linker_Options,\n-                          From_List => Attribute.Value.Values,\n-                          In_Tree   => In_Tree);\n-\n-                  when Snames.Name_Executable_Suffix =>\n-\n-                     --  Attribute Executable_Suffix: the suffix of the\n-                     --  executables.\n-\n-                     In_Tree.Config.Executable_Suffix :=\n-                       Attribute.Value.Value;\n-\n-                  when Snames.Name_Library_Builder =>\n-\n-                     --  Attribute Library_Builder: the application to invoke\n-                     --  to build libraries.\n-\n-                     In_Tree.Config.Library_Builder :=\n-                       Path_Name_Type (Attribute.Value.Value);\n-\n-                  when Snames.Name_Archive_Builder =>\n-\n-                     --  Attribute Archive_Builder: the archive builder\n-                     --  (usually \"ar\") and its minimum options (usually \"cr\").\n-\n-                     List := Attribute.Value.Values;\n-\n-                     if List = Nil_String then\n-                        Error_Msg\n-                          (\"archive builder cannot be null\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     Put (Into_List => In_Tree.Config.Archive_Builder,\n-                          From_List => List,\n-                          In_Tree   => In_Tree);\n-\n-                  when Snames.Name_Archive_Indexer =>\n-\n-                     --  Attribute Archive_Indexer: the optional archive\n-                     --  indexer (usually \"ranlib\") with its minimum options\n-                     --  (usually none).\n-\n-                     List := Attribute.Value.Values;\n-\n-                     if List = Nil_String then\n-                        Error_Msg\n-                          (\"archive indexer cannot be null\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     Put (Into_List => In_Tree.Config.Archive_Indexer,\n-                          From_List => List,\n-                          In_Tree   => In_Tree);\n-\n-                  when Snames.Name_Library_Partial_Linker =>\n-\n-                     --  Attribute Library_Partial_Linker: the optional linker\n-                     --  driver with its minimum options, to partially link\n-                     --  archives.\n-\n-                     List := Attribute.Value.Values;\n-\n-                     if List = Nil_String then\n-                        Error_Msg\n-                          (\"partial linker cannot be null\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     Put (Into_List => In_Tree.Config.Lib_Partial_Linker,\n-                          From_List => List,\n-                          In_Tree   => In_Tree);\n-\n-                  when Snames.Name_Archive_Suffix =>\n-                     In_Tree.Config.Archive_Suffix :=\n-                       File_Name_Type (Attribute.Value.Value);\n-\n-                  when Snames.Name_Linker_Executable_Option =>\n-\n-                     --  Attribute Linker_Executable_Option: optional options\n-                     --  to specify an executable name. Defaults to \"-o\".\n-\n-                     List := Attribute.Value.Values;\n-\n-                     if List = Nil_String then\n-                        Error_Msg\n-                          (\"linker executable option cannot be null\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     Put (Into_List =>\n-                          In_Tree.Config.Linker_Executable_Option,\n-                          From_List => List,\n-                          In_Tree   => In_Tree);\n-\n-                  when Snames.Name_Linker_Lib_Dir_Option =>\n-\n-                     --  Attribute Linker_Lib_Dir_Option: optional options\n-                     --  to specify a library search directory. Defaults to\n-                     --  \"-L\".\n-\n-                     Get_Name_String (Attribute.Value.Value);\n-\n-                     if Name_Len = 0 then\n-                        Error_Msg\n-                          (\"linker library directory option cannot be empty\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     In_Tree.Config.Linker_Lib_Dir_Option :=\n-                       Attribute.Value.Value;\n-\n-                  when Snames.Name_Linker_Lib_Name_Option =>\n-\n-                     --  Attribute Linker_Lib_Name_Option: optional options\n-                     --  to specify the name of a library to be linked in.\n-                     --  Defaults to \"-l\".\n-\n-                     Get_Name_String (Attribute.Value.Value);\n-\n-                     if Name_Len = 0 then\n-                        Error_Msg\n-                          (\"linker library name option cannot be empty\",\n-                           Attribute.Value.Location);\n-                     end if;\n-\n-                     In_Tree.Config.Linker_Lib_Name_Option :=\n-                       Attribute.Value.Value;\n-\n-                  when Snames.Name_Run_Path_Option =>\n-\n-                     --  Attribute Run_Path_Option: optional options to\n-                     --  specify a path for libraries.\n-\n-                     List := Attribute.Value.Values;\n-\n-                     if List /= Nil_String then\n-                        Put (Into_List => In_Tree.Config.Run_Path_Option,\n-                             From_List => List,\n-                             In_Tree   => In_Tree);\n-                     end if;\n-\n-                  when Snames.Name_Library_Support =>\n-                     declare\n-                        pragma Unsuppress (All_Checks);\n-                     begin\n-                        In_Tree.Config.Lib_Support :=\n-                          Library_Support'Value (Get_Name_String\n-                                                 (Attribute.Value.Value));\n-                     exception\n-                        when Constraint_Error =>\n-                           Error_Msg\n-                             (\"invalid value \"\"\" &\n-                              Get_Name_String (Attribute.Value.Value) &\n-                              \"\"\" for Library_Support\",\n-                              Attribute.Value.Location);\n-                     end;\n-\n-                  when Snames.Name_Shared_Library_Prefix =>\n-                     In_Tree.Config.Shared_Lib_Prefix :=\n-                       File_Name_Type (Attribute.Value.Value);\n-\n-                  when Snames.Name_Shared_Library_Suffix =>\n-                     In_Tree.Config.Shared_Lib_Suffix :=\n-                       File_Name_Type (Attribute.Value.Value);\n-\n-                  when Snames.Name_Symbolic_Link_Supported =>\n-                     declare\n-                        pragma Unsuppress (All_Checks);\n-                     begin\n-                        In_Tree.Config.Symbolic_Link_Supported :=\n-                          Boolean'Value (Get_Name_String\n-                                         (Attribute.Value.Value));\n-                     exception\n-                        when Constraint_Error =>\n-                           Error_Msg\n-                             (\"invalid value \"\"\" &\n-                              Get_Name_String (Attribute.Value.Value) &\n-                              \"\"\" for Symbolic_Link_Supported\",\n-                              Attribute.Value.Location);\n-                     end;\n-\n-                  when Snames.Name_Library_Major_Minor_Id_Supported =>\n-                     declare\n-                        pragma Unsuppress (All_Checks);\n-                     begin\n-                        In_Tree.Config.Lib_Maj_Min_Id_Supported :=\n-                          Boolean'Value (Get_Name_String\n-                                         (Attribute.Value.Value));\n-                     exception\n-                        when Constraint_Error =>\n-                           Error_Msg\n-                             (\"invalid value \"\"\" &\n-                              Get_Name_String (Attribute.Value.Value) &\n-                              \"\"\" for Library_Major_Minor_Id_Supported\",\n-                              Attribute.Value.Location);\n-                     end;\n-\n-                  when Snames.Name_Library_Auto_Init_Supported =>\n-                     declare\n-                        pragma Unsuppress (All_Checks);\n-                     begin\n-                        In_Tree.Config.Auto_Init_Supported :=\n-                          Boolean'Value (Get_Name_String\n-                                         (Attribute.Value.Value));\n-                     exception\n-                        when Constraint_Error =>\n-                           Error_Msg\n-                             (\"invalid value \"\"\" &\n-                              Get_Name_String (Attribute.Value.Value) &\n-                              \"\"\" for Library_Auto_Init_Supported\",\n-                              Attribute.Value.Location);\n-                     end;\n-\n-                  when Snames.Name_Shared_Library_Minimum_Switches =>\n-                     List := Attribute.Value.Values;\n-\n-                     if List /= Nil_String then\n-                        Put (Into_List =>\n-                               In_Tree.Config.Shared_Lib_Min_Options,\n-                             From_List => List,\n-                             In_Tree   => In_Tree);\n-                     end if;\n-\n-                  when Snames.Name_Library_Version_Switches =>\n-                     List := Attribute.Value.Values;\n-\n-                     if List /= Nil_String then\n-                        Put (Into_List =>\n-                               In_Tree.Config.Lib_Version_Options,\n-                             From_List => List,\n-                             In_Tree   => In_Tree);\n-                     end if;\n-\n-                  when others =>\n-                     null;\n-               end case;\n-            end if;\n-\n-            Attribute_Id := Attribute.Next;\n-         end loop;\n-      end Process_Attributes;\n-\n    begin\n-      Error_Report := Report_Error;\n-      Success := True;\n-\n-      if Reset_Tree then\n-\n-         --  Make sure there are no projects in the data structure\n-\n-         Project_Table.Set_Last (In_Tree.Projects, No_Project);\n-      end if;\n-\n-      Processed_Projects.Reset;\n-\n-      --  And process the main project and all of the projects it depends on,\n-      --  recursively.\n-\n-      Recursive_Process\n-        (Project                => Project,\n-         In_Tree                => In_Tree,\n+      Process_Project_Tree_Phase_1\n+        (In_Tree                => In_Tree,\n+         Project                => Project,\n+         Success                => Success,\n          From_Project_Node      => From_Project_Node,\n          From_Project_Node_Tree => From_Project_Node_Tree,\n-         Extended_By            => No_Project);\n+         Report_Error           => Report_Error,\n+         Reset_Tree             => Reset_Tree);\n \n       if not In_Configuration then\n-\n-         if Project /= No_Project then\n-            Check\n-              (In_Tree, Project, Follow_Links, When_No_Sources);\n-         end if;\n-\n-         --  If main project is an extending all project, set the object\n-         --  directory of all virtual extending projects to the object\n-         --  directory of the main project.\n-\n-         if Project /= No_Project\n-           and then\n-             Is_Extending_All (From_Project_Node, From_Project_Node_Tree)\n-         then\n-            declare\n-               Object_Dir : constant Path_Name_Type :=\n-                              In_Tree.Projects.Table\n-                                (Project).Object_Directory;\n-            begin\n-               for Index in\n-                 Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n-               loop\n-                  if In_Tree.Projects.Table (Index).Virtual then\n-                     In_Tree.Projects.Table (Index).Object_Directory :=\n-                       Object_Dir;\n-                  end if;\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  Check that no extending project shares its object directory with\n-         --  the project(s) it extends.\n-\n-         if Project /= No_Project then\n-            for Proj in\n-              Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n-            loop\n-               Extending := In_Tree.Projects.Table (Proj).Extended_By;\n-\n-               if Extending /= No_Project then\n-                  Obj_Dir := In_Tree.Projects.Table (Proj).Object_Directory;\n-\n-                  --  Check that a project being extended does not share its\n-                  --  object directory with any project that extends it,\n-                  --  directly or indirectly, including a virtual extending\n-                  --  project.\n-\n-                  --  Start with the project directly extending it\n-\n-                  Extending2 := Extending;\n-                  while Extending2 /= No_Project loop\n-                     if In_Tree.Projects.Table (Extending2).Ada_Sources /=\n-                       Nil_String\n-                       and then\n-                         In_Tree.Projects.Table (Extending2).Object_Directory =\n-                         Obj_Dir\n-                     then\n-                        if In_Tree.Projects.Table (Extending2).Virtual then\n-                           Error_Msg_Name_1 :=\n-                             In_Tree.Projects.Table (Proj).Display_Name;\n-\n-                           if Error_Report = null then\n-                              Error_Msg\n-                                (\"project %% cannot be extended by a virtual\" &\n-                                 \" project with the same object directory\",\n-                                 In_Tree.Projects.Table (Proj).Location);\n-                           else\n-                              Error_Report\n-                                (\"project \"\"\" &\n-                                 Get_Name_String (Error_Msg_Name_1) &\n-                                 \"\"\" cannot be extended by a virtual \" &\n-                                 \"project with the same object directory\",\n-                                 Project, In_Tree);\n-                           end if;\n-\n-                        else\n-                           Error_Msg_Name_1 :=\n-                             In_Tree.Projects.Table (Extending2).Display_Name;\n-                           Error_Msg_Name_2 :=\n-                             In_Tree.Projects.Table (Proj).Display_Name;\n-\n-                           if Error_Report = null then\n-                              Error_Msg\n-                                (\"project %% cannot extend project %%\",\n-                                 In_Tree.Projects.Table (Extending2).Location);\n-                              Error_Msg\n-                                (\"\\they share the same object directory\",\n-                                 In_Tree.Projects.Table (Extending2).Location);\n-\n-                           else\n-                              Error_Report\n-                                (\"project \"\"\" &\n-                                 Get_Name_String (Error_Msg_Name_1) &\n-                                 \"\"\" cannot extend project \"\"\" &\n-                                 Get_Name_String (Error_Msg_Name_2) & \"\"\"\",\n-                                 Project, In_Tree);\n-                              Error_Report\n-                                (\"they share the same object directory\",\n-                                 Project, In_Tree);\n-                           end if;\n-                        end if;\n-                     end if;\n-\n-                     --  Continue with the next extending project, if any\n-\n-                     Extending2 :=\n-                       In_Tree.Projects.Table (Extending2).Extended_By;\n-                  end loop;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         --  Get the global configuration\n-\n-         if Project /= No_Project then\n-\n-            Process_Attributes\n-              (In_Tree.Projects.Table (Project).Decl.Attributes);\n-\n-            --  Loop through packages ???\n-\n-            Packages := In_Tree.Projects.Table (Project).Decl.Packages;\n-            while Packages /= No_Package loop\n-               Element := In_Tree.Packages.Table (Packages);\n-\n-               case Element.Name is\n-                  when Snames.Name_Builder =>\n-\n-                     --  Process attributes of package Builder\n-\n-                     Process_Attributes (Element.Decl.Attributes);\n-\n-                  when Snames.Name_Linker =>\n-\n-                     --  Process attributes of package Linker\n-\n-                     Process_Attributes (Element.Decl.Attributes);\n-\n-                  when others =>\n-                     null;\n-               end case;\n-\n-               Packages := Element.Next;\n-            end loop;\n-         end if;\n+         Process_Project_Tree_Phase_2\n+           (In_Tree                => In_Tree,\n+            Project                => Project,\n+            Success                => Success,\n+            From_Project_Node      => From_Project_Node,\n+            From_Project_Node_Tree => From_Project_Node_Tree,\n+            Report_Error           => Report_Error,\n+            Follow_Links           => Follow_Links,\n+            When_No_Sources        => When_No_Sources);\n       end if;\n-\n-      Success :=\n-        Total_Errors_Detected = 0\n-          and then\n-            (Warning_Mode /= Treat_As_Error or else Warnings_Detected = 0);\n    end Process;\n \n    -------------------------------\n@@ -1727,6 +1290,7 @@ package body Prj.Proc is\n                           In_Tree.Packages.Table (Pkg).Decl.Packages;\n                         In_Tree.Packages.Table (Pkg).Decl.Packages :=\n                           New_Pkg;\n+\n                      else\n                         The_New_Package.Next :=\n                           In_Tree.Projects.Table (Project).Decl.Packages;\n@@ -1817,7 +1381,7 @@ package body Prj.Proc is\n                  N_Variable_Declaration       =>\n \n                if Expression_Of (Current_Item, From_Project_Node_Tree) =\n-                    Empty_Node\n+                                                                  Empty_Node\n                then\n \n                   --  It must be a full associative array attribute declaration\n@@ -1858,8 +1422,7 @@ package body Prj.Proc is\n                      --  Last new element id created\n \n                      Orig_Element : Array_Element_Id := No_Array_Element;\n-                     --  Current array element in the original associative\n-                     --  array.\n+                     --  Current array element in original associative array\n \n                      Next_Element : Array_Element_Id := No_Array_Element;\n                      --  Id of the array element that follows the new element.\n@@ -1868,7 +1431,7 @@ package body Prj.Proc is\n                      --  declared, and the array elements declared are reused.\n \n                   begin\n-                     --  First, find if the associative array attribute already\n+                     --  First find if the associative array attribute already\n                      --  has elements declared.\n \n                      if Pkg /= No_Package then\n@@ -1947,8 +1510,8 @@ package body Prj.Proc is\n                             (Orig_Project).Decl.Arrays;\n \n                      else\n-                        --  If in a package, find the package where the\n-                        --  value is declared.\n+                        --  If in a package, find the package where the value\n+                        --  is declared.\n \n                         Orig_Package_Name :=\n                           Name_Of\n@@ -1978,8 +1541,8 @@ package body Prj.Proc is\n \n                      --  Now look for the array\n \n-                     while Orig_Array /= No_Array and then\n-                     In_Tree.Arrays.Table (Orig_Array).Name /=\n+                     while Orig_Array /= No_Array\n+                       and then In_Tree.Arrays.Table (Orig_Array).Name /=\n                                                          Current_Item_Name\n                      loop\n                         Orig_Array := In_Tree.Arrays.Table\n@@ -1992,7 +1555,6 @@ package body Prj.Proc is\n                              (\"associative array value cannot be found\",\n                               Location_Of\n                                 (Current_Item, From_Project_Node_Tree));\n-\n                         else\n                            Error_Report\n                              (\"associative array value cannot be found\",\n@@ -2114,7 +1676,9 @@ package body Prj.Proc is\n                      The_Variable : Variable_Id := No_Variable;\n \n                      Current_Item_Name : constant Name_Id :=\n-                       Name_Of (Current_Item, From_Project_Node_Tree);\n+                                           Name_Of\n+                                             (Current_Item,\n+                                              From_Project_Node_Tree);\n \n                   begin\n                      --  Process a typed variable declaration\n@@ -2133,7 +1697,6 @@ package body Prj.Proc is\n                                 (\"no value defined for %%\",\n                                  Location_Of\n                                    (Current_Item, From_Project_Node_Tree));\n-\n                            else\n                               Error_Report\n                                 (\"no value defined for \" &\n@@ -2143,17 +1706,17 @@ package body Prj.Proc is\n \n                         else\n                            declare\n-                              Current_String : Project_Node_Id :=\n-                                                 First_Literal_String\n-                                                   (String_Type_Of\n-                                                      (Current_Item,\n-                                                       From_Project_Node_Tree),\n-                                                    From_Project_Node_Tree);\n+                              Current_String : Project_Node_Id;\n \n                            begin\n                               --  Loop through all the valid strings for the\n                               --  string type and compare to the string value.\n \n+                              Current_String :=\n+                                First_Literal_String\n+                                  (String_Type_Of (Current_Item,\n+                                                   From_Project_Node_Tree),\n+                                                   From_Project_Node_Tree);\n                               while Current_String /= Empty_Node\n                                 and then\n                                   String_Value_Of\n@@ -2196,6 +1759,8 @@ package body Prj.Proc is\n                         end if;\n                      end if;\n \n+                     --  Comment here ???\n+\n                      if Kind_Of (Current_Item, From_Project_Node_Tree) /=\n                           N_Attribute_Declaration\n                        or else\n@@ -2299,9 +1864,9 @@ package body Prj.Proc is\n \n                         end if;\n \n-                     else\n-                        --  Associative array attribute\n+                     --  Associative array attribute\n \n+                     else\n                         --  Get the string index\n \n                         Get_Name_String\n@@ -2347,10 +1912,10 @@ package body Prj.Proc is\n                                              (The_Array).Next;\n                            end loop;\n \n-                           --  If the array cannot be found, create a new\n-                           --  entry in the list. As The_Array_Element is\n-                           --  initialized to No_Array_Element, a new element\n-                           --  will be created automatically later.\n+                           --  If the array cannot be found, create a new entry\n+                           --  in the list. As The_Array_Element is initialized\n+                           --  to No_Array_Element, a new element will be\n+                           --  created automatically later\n \n                            if The_Array = No_Array then\n                               Array_Table.Increment_Last\n@@ -2385,7 +1950,7 @@ package body Prj.Proc is\n                                      The_Array;\n                               end if;\n \n-                           --  Otherwise, initialize The_Array_Element as the\n+                           --  Otherwise initialize The_Array_Element as the\n                            --  head of the element list.\n \n                            else\n@@ -2407,9 +1972,9 @@ package body Prj.Proc is\n                                   (The_Array_Element).Next;\n                            end loop;\n \n-                           --  If no such element were found, create a new\n-                           --  one and insert it in the element list, with\n-                           --  the propoer value.\n+                           --  If no such element were found, create a new one\n+                           --  and insert it in the element list, with the\n+                           --  propoer value.\n \n                            if The_Array_Element = No_Array_Element then\n                               Array_Element_Table.Increment_Last\n@@ -2446,16 +2011,16 @@ package body Prj.Proc is\n \n             when N_Case_Construction =>\n                declare\n-                  The_Project   : Project_Id      := Project;\n+                  The_Project : Project_Id := Project;\n                   --  The id of the project of the case variable\n \n-                  The_Package   : Package_Id      := Pkg;\n+                  The_Package : Package_Id := Pkg;\n                   --  The id of the package, if any, of the case variable\n \n-                  The_Variable  : Variable_Value  := Nil_Variable_Value;\n+                  The_Variable : Variable_Value := Nil_Variable_Value;\n                   --  The case variable\n \n-                  Case_Value    : Name_Id         := No_Name;\n+                  Case_Value : Name_Id := No_Name;\n                   --  The case variable value\n \n                   Case_Item     : Project_Node_Id := Empty_Node;\n@@ -2643,6 +2208,184 @@ package body Prj.Proc is\n       end loop;\n    end Process_Declarative_Items;\n \n+   ----------------------------------\n+   -- Process_Project_Tree_Phase_1 --\n+   ----------------------------------\n+\n+   procedure Process_Project_Tree_Phase_1\n+     (In_Tree                : Project_Tree_Ref;\n+      Project                : out Project_Id;\n+      Success                : out Boolean;\n+      From_Project_Node      : Project_Node_Id;\n+      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Report_Error           : Put_Line_Access;\n+      Reset_Tree             : Boolean := True)\n+   is\n+   begin\n+      Error_Report := Report_Error;\n+      Success := True;\n+\n+      if Reset_Tree then\n+\n+         --  Make sure there are no projects in the data structure\n+\n+         Project_Table.Set_Last (In_Tree.Projects, No_Project);\n+      end if;\n+\n+      Processed_Projects.Reset;\n+\n+      --  And process the main project and all of the projects it depends on,\n+      --  recursively.\n+\n+      Recursive_Process\n+        (Project                => Project,\n+         In_Tree                => In_Tree,\n+         From_Project_Node      => From_Project_Node,\n+         From_Project_Node_Tree => From_Project_Node_Tree,\n+         Extended_By            => No_Project);\n+\n+   end Process_Project_Tree_Phase_1;\n+\n+   ----------------------------------\n+   -- Process_Project_Tree_Phase_2 --\n+   ----------------------------------\n+\n+   procedure Process_Project_Tree_Phase_2\n+     (In_Tree                : Project_Tree_Ref;\n+      Project                : Project_Id;\n+      Success                : out Boolean;\n+      From_Project_Node      : Project_Node_Id;\n+      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Report_Error           : Put_Line_Access;\n+      Follow_Links           : Boolean := True;\n+      When_No_Sources        : Error_Warning := Error)\n+   is\n+      Obj_Dir    : Path_Name_Type;\n+      Extending  : Project_Id;\n+      Extending2 : Project_Id;\n+\n+   --  Start of processing for Process_Project_Tree_Phase_2\n+\n+   begin\n+      Error_Report := Report_Error;\n+      Success := True;\n+\n+      if Project /= No_Project then\n+         Check\n+           (In_Tree, Project, Follow_Links, When_No_Sources);\n+      end if;\n+\n+      --  If main project is an extending all project, set the object\n+      --  directory of all virtual extending projects to the object\n+      --  directory of the main project.\n+\n+      if Project /= No_Project\n+        and then\n+          Is_Extending_All (From_Project_Node, From_Project_Node_Tree)\n+      then\n+         declare\n+            Object_Dir : constant Path_Name_Type :=\n+                           In_Tree.Projects.Table\n+                             (Project).Object_Directory;\n+         begin\n+            for Index in\n+              Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n+            loop\n+               if In_Tree.Projects.Table (Index).Virtual then\n+                  In_Tree.Projects.Table (Index).Object_Directory :=\n+                    Object_Dir;\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Check that no extending project shares its object directory with\n+      --  the project(s) it extends.\n+\n+      if Project /= No_Project then\n+         for Proj in\n+           Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n+         loop\n+            Extending := In_Tree.Projects.Table (Proj).Extended_By;\n+\n+            if Extending /= No_Project then\n+               Obj_Dir := In_Tree.Projects.Table (Proj).Object_Directory;\n+\n+               --  Check that a project being extended does not share its\n+               --  object directory with any project that extends it, directly\n+               --  or indirectly, including a virtual extending project.\n+\n+               --  Start with the project directly extending it\n+\n+               Extending2 := Extending;\n+               while Extending2 /= No_Project loop\n+                  if In_Tree.Projects.Table (Extending2).Ada_Sources /=\n+                    Nil_String\n+                    and then\n+                      In_Tree.Projects.Table (Extending2).Object_Directory =\n+                      Obj_Dir\n+                  then\n+                     if In_Tree.Projects.Table (Extending2).Virtual then\n+                        Error_Msg_Name_1 :=\n+                          In_Tree.Projects.Table (Proj).Display_Name;\n+\n+                        if Error_Report = null then\n+                           Error_Msg\n+                             (\"project %% cannot be extended by a virtual\" &\n+                              \" project with the same object directory\",\n+                              In_Tree.Projects.Table (Proj).Location);\n+                        else\n+                           Error_Report\n+                             (\"project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_1) &\n+                              \"\"\" cannot be extended by a virtual \" &\n+                              \"project with the same object directory\",\n+                              Project, In_Tree);\n+                        end if;\n+\n+                     else\n+                        Error_Msg_Name_1 :=\n+                          In_Tree.Projects.Table (Extending2).Display_Name;\n+                        Error_Msg_Name_2 :=\n+                          In_Tree.Projects.Table (Proj).Display_Name;\n+\n+                        if Error_Report = null then\n+                           Error_Msg\n+                             (\"project %% cannot extend project %%\",\n+                              In_Tree.Projects.Table (Extending2).Location);\n+                           Error_Msg\n+                             (\"\\they share the same object directory\",\n+                              In_Tree.Projects.Table (Extending2).Location);\n+\n+                        else\n+                           Error_Report\n+                             (\"project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_1) &\n+                              \"\"\" cannot extend project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_2) & \"\"\"\",\n+                              Project, In_Tree);\n+                           Error_Report\n+                             (\"they share the same object directory\",\n+                              Project, In_Tree);\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+                  --  Continue with the next extending project, if any\n+\n+                  Extending2 :=\n+                    In_Tree.Projects.Table (Extending2).Extended_By;\n+               end loop;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      Success :=\n+        Total_Errors_Detected = 0\n+          and then\n+            (Warning_Mode /= Treat_As_Error or else Warnings_Detected = 0);\n+   end Process_Project_Tree_Phase_2;\n+\n    ---------------------\n    -- Recursive_Check --\n    ---------------------\n@@ -2875,9 +2618,9 @@ package body Prj.Proc is\n             Recursive_Process\n               (In_Tree                => In_Tree,\n                Project                => Processed_Data.Extends,\n-               From_Project_Node      =>\n-                 Extended_Project_Of\n-                   (Declaration_Node, From_Project_Node_Tree),\n+               From_Project_Node      => Extended_Project_Of\n+                                          (Declaration_Node,\n+                                           From_Project_Node_Tree),\n                From_Project_Node_Tree => From_Project_Node_Tree,\n                Extended_By            => Project);\n \n@@ -2889,9 +2632,9 @@ package body Prj.Proc is\n                From_Project_Node      => From_Project_Node,\n                From_Project_Node_Tree => From_Project_Node_Tree,\n                Pkg                    => No_Package,\n-               Item                   =>\n-                 First_Declarative_Item_Of\n-                   (Declaration_Node, From_Project_Node_Tree));\n+               Item                   => First_Declarative_Item_Of\n+                                          (Declaration_Node,\n+                                           From_Project_Node_Tree));\n \n             --  If it is an extending project, inherit all packages\n             --  from the extended project that are not explicitely defined\n@@ -2902,44 +2645,48 @@ package body Prj.Proc is\n                Processed_Data := In_Tree.Projects.Table (Project);\n \n                declare\n-                  Extended_Pkg : Package_Id :=\n-                                   In_Tree.Projects.Table\n-                                     (Processed_Data.Extends).Decl.Packages;\n-                  Current_Pkg : Package_Id;\n-                  Element     : Package_Element;\n-                  First       : constant Package_Id :=\n-                                  Processed_Data.Decl.Packages;\n-                  Attribute1  : Variable_Id;\n-                  Attribute2  : Variable_Id;\n-                  Attr_Value1 : Variable;\n+                  Extended_Pkg : Package_Id;\n+                  Current_Pkg  : Package_Id;\n+                  Element      : Package_Element;\n+                  First        : constant Package_Id :=\n+                                   Processed_Data.Decl.Packages;\n+                  Attribute1   : Variable_Id;\n+                  Attribute2   : Variable_Id;\n+                  Attr_Value1  : Variable;\n                   Attr_Value2  : Variable;\n \n                begin\n+                  Extended_Pkg :=\n+                    In_Tree.Projects.Table\n+                      (Processed_Data.Extends).Decl.Packages;\n                   while Extended_Pkg /= No_Package loop\n                      Element :=\n                        In_Tree.Packages.Table (Extended_Pkg);\n \n                      Current_Pkg := First;\n-\n+                     while Current_Pkg /= No_Package\n+                       and then In_Tree.Packages.Table (Current_Pkg).Name /=\n+                                                                 Element.Name\n                      loop\n-                        exit when Current_Pkg = No_Package\n-                          or else In_Tree.Packages.Table\n-                                    (Current_Pkg).Name = Element.Name;\n-                        Current_Pkg := In_Tree.Packages.Table\n-                                         (Current_Pkg).Next;\n+                        Current_Pkg :=\n+                          In_Tree.Packages.Table (Current_Pkg).Next;\n                      end loop;\n \n                      if Current_Pkg = No_Package then\n                         Package_Table.Increment_Last\n                           (In_Tree.Packages);\n-                        Current_Pkg := Package_Table.Last\n-                          (In_Tree.Packages);\n+                        Current_Pkg := Package_Table.Last (In_Tree.Packages);\n                         In_Tree.Packages.Table (Current_Pkg) :=\n                           (Name   => Element.Name,\n-                           Decl   => Element.Decl,\n+                           Decl   => No_Declarations,\n                            Parent => No_Package,\n                            Next   => Processed_Data.Decl.Packages);\n                         Processed_Data.Decl.Packages := Current_Pkg;\n+                        Copy_Package_Declarations\n+                          (From  => Element.Decl,\n+                           To    => In_Tree.Packages.Table (Current_Pkg).Decl,\n+                           New_Loc => No_Location,\n+                           In_Tree => In_Tree);\n                      end if;\n \n                      Extended_Pkg := Element.Next;\n@@ -2966,7 +2713,6 @@ package body Prj.Proc is\n                      Attribute2 :=\n                        In_Tree.Projects.Table\n                          (Processed_Data.Extends).Decl.Attributes;\n-\n                      while Attribute2 /= No_Variable loop\n                         Attr_Value2 := In_Tree.Variable_Elements.\n                                          Table (Attribute2);"}, {"sha": "b9f821520bd98c87b7731ed611971a94188115e8", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -50,12 +50,37 @@ package Prj.Proc is\n    --  still valid if they point to a file which is outside of the project),\n    --  and that no directory has a name which is a valid source name.\n    --\n-   --  When_No_Sources indicates what should be done when no sources\n-   --  are found in a project for a specified or implied language.\n+   --  When_No_Sources indicates what should be done when no sources are found\n+   --  in a project for a specified or implied language.\n    --\n    --  When Reset_Tree is True, all the project data are removed from the\n    --  project table before processing.\n    --\n    --  Process is a bit of a junk name, how about Process_Project_Tree???\n \n+   --  The two procedures that follow are implementing procedure Process in\n+   --  two successive phases. They are used by gprbuild/gprclean to add the\n+   --  configuration attributes between the two phases.\n+\n+   procedure Process_Project_Tree_Phase_1\n+     (In_Tree                : Project_Tree_Ref;\n+      Project                : out Project_Id;\n+      Success                : out Boolean;\n+      From_Project_Node      : Project_Node_Id;\n+      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Report_Error           : Put_Line_Access;\n+      Reset_Tree             : Boolean := True);\n+   --  See documentation of parameters in procedure Process above\n+\n+   procedure Process_Project_Tree_Phase_2\n+     (In_Tree                : Project_Tree_Ref;\n+      Project                : Project_Id;\n+      Success                : out Boolean;\n+      From_Project_Node      : Project_Node_Id;\n+      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Report_Error           : Put_Line_Access;\n+      Follow_Links           : Boolean := True;\n+      When_No_Sources        : Error_Warning := Error);\n+   --  See documentation of parameters in procedure Process above\n+\n end Prj.Proc;"}, {"sha": "1917bd22502ad5d47a03eaa29993690f0cae1e4f", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -145,7 +145,8 @@ package body Prj.Util is\n    begin\n       if Builder_Package /= No_Package then\n          if Get_Mode = Multi_Language then\n-            Executable_Suffix_Name := In_Tree.Config.Executable_Suffix;\n+            Executable_Suffix_Name :=\n+              In_Tree.Projects.Table (Project).Config.Executable_Suffix;\n \n          else\n             Executable_Suffix := Prj.Util.Value_Of\n@@ -283,7 +284,8 @@ package body Prj.Util is\n             Result     : File_Name_Type;\n \n          begin\n-            Executable_Extension_On_Target := In_Tree.Config.Executable_Suffix;\n+            Executable_Extension_On_Target :=\n+              In_Tree.Projects.Table (Project).Config.Executable_Suffix;\n             Result := Executable_Name (Name_Find);\n             Executable_Extension_On_Target := Saved_EEOT;\n             return Result;"}, {"sha": "5b0ebbb8ebda90718dd697fc418df746edab7804", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -358,15 +358,6 @@ package body Prj is\n       return Default_Ada_Spec_Suffix_Id;\n    end Default_Ada_Spec_Suffix;\n \n-   ----------------------\n-   -- Default_Language --\n-   ----------------------\n-\n-   function Default_Language (In_Tree : Project_Tree_Ref) return Name_Id is\n-   begin\n-      return In_Tree.Default_Language;\n-   end Default_Language;\n-\n    ---------------------------\n    -- Delete_All_Temp_Files --\n    ---------------------------\n@@ -454,10 +445,6 @@ package body Prj is\n       Value := Project_Empty;\n       Value.Naming := Tree.Private_Part.Default_Naming;\n \n-      if Current_Mode = Multi_Language then\n-         Value.Config := Tree.Config;\n-      end if;\n-\n       return Value;\n    end Empty_Project;\n "}, {"sha": "c0c936e0477bb6257fe05cd6b7dbe2a8dbd698cf", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70f5d823abaf5ff25c7ef7f167a40c08889f698/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=a70f5d823abaf5ff25c7ef7f167a40c08889f698", "patch": "@@ -298,8 +298,6 @@ package Prj is\n       Next : Name_List_Index := No_Name_List;\n    end record;\n \n-   function Default_Language (In_Tree : Project_Tree_Ref) return Name_Id;\n-\n    package Name_List_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Name_Node,\n       Table_Index_Type     => Name_List_Index,\n@@ -363,12 +361,9 @@ package Prj is\n       Compiler_Driver_Path : String_Access := null;\n       --  The path name of the executable for the compiler of the language\n \n-      Compiler_Min_Options : Name_List_Index := No_Name_List;\n-      --  The minimum options for the compiler of the language. Specified\n-      --  in the configuration as Compiler'Switches (<language>).\n-\n-      Min_Compiler_Options : String_List_Access := null;\n-      --  The minimum options as an argument list\n+      Compiler_Required_Switches : Name_List_Index := No_Name_List;\n+      --  The list of switches that are required as a minimum to invoke the\n+      --  compiler driver.\n \n       Compilation_PIC_Option : Name_List_Index := No_Name_List;\n       --  The option(s) to compile a source in Position Independent Code for\n@@ -407,7 +402,7 @@ package Prj is\n       Runtime_Project       : Path_Name_Type  := No_Path;\n       Binder_Driver         : File_Name_Type  := No_File;\n       Binder_Driver_Path    : Path_Name_Type  := No_Path;\n-      Binder_Min_Options    : Name_List_Index := No_Name_List;\n+      Binder_Required_Switches : Name_List_Index      := No_Name_List;\n       Binder_Prefix         : Name_Id         := No_Name;\n       Toolchain_Version     : Name_Id         := No_Name;\n       Toolchain_Description : Name_Id         := No_Name;\n@@ -416,39 +411,38 @@ package Prj is\n    end record;\n \n    No_Language_Config : constant Language_Config :=\n-                          (Kind                    => File_Based,\n-                           Naming_Data             => No_Lang_Naming_Data,\n-                           Compiler_Driver         => No_File,\n-                           Compiler_Driver_Path    => null,\n-                           Compiler_Min_Options    => No_Name_List,\n-                           Min_Compiler_Options    => null,\n-                           Compilation_PIC_Option  => No_Name_List,\n-                           Mapping_File_Switches   => No_Name_List,\n-                           Mapping_Spec_Suffix     => No_File,\n-                           Mapping_Body_Suffix     => No_File,\n-                           Config_File_Switches    => No_Name_List,\n-                           Dependency_Kind         => Makefile,\n-                           Dependency_Option       => No_Name_List,\n-                           Compute_Dependency      => No_Name_List,\n-                           Include_Option          => No_Name_List,\n-                           Include_Path            => No_Name,\n-                           Include_Path_File       => No_Name,\n-                           Objects_Path            => No_Name,\n-                           Objects_Path_File       => No_Name,\n-                           Config_Body             => No_Name,\n-                           Config_Spec             => No_Name,\n-                           Config_Body_Pattern     => No_Name,\n-                           Config_Spec_Pattern     => No_Name,\n-                           Config_File_Unique      => False,\n-                           Runtime_Project         => No_Path,\n-                           Binder_Driver           => No_File,\n-                           Binder_Driver_Path      => No_Path,\n-                           Binder_Min_Options      => No_Name_List,\n-                           Binder_Prefix           => No_Name,\n-                           Toolchain_Version       => No_Name,\n-                           Toolchain_Description   => No_Name,\n-                           PIC_Option              => No_Name,\n-                           Objects_Generated       => True);\n+                          (Kind                       => File_Based,\n+                           Naming_Data                => No_Lang_Naming_Data,\n+                           Compiler_Driver            => No_File,\n+                           Compiler_Driver_Path       => null,\n+                           Compiler_Required_Switches => No_Name_List,\n+                           Compilation_PIC_Option     => No_Name_List,\n+                           Mapping_File_Switches      => No_Name_List,\n+                           Mapping_Spec_Suffix        => No_File,\n+                           Mapping_Body_Suffix        => No_File,\n+                           Config_File_Switches       => No_Name_List,\n+                           Dependency_Kind            => Makefile,\n+                           Dependency_Option          => No_Name_List,\n+                           Compute_Dependency         => No_Name_List,\n+                           Include_Option             => No_Name_List,\n+                           Include_Path               => No_Name,\n+                           Include_Path_File          => No_Name,\n+                           Objects_Path               => No_Name,\n+                           Objects_Path_File          => No_Name,\n+                           Config_Body                => No_Name,\n+                           Config_Spec                => No_Name,\n+                           Config_Body_Pattern        => No_Name,\n+                           Config_Spec_Pattern        => No_Name,\n+                           Config_File_Unique         => False,\n+                           Runtime_Project            => No_Path,\n+                           Binder_Driver              => No_File,\n+                           Binder_Driver_Path         => No_Path,\n+                           Binder_Required_Switches   => No_Name_List,\n+                           Binder_Prefix              => No_Name,\n+                           Toolchain_Version          => No_Name,\n+                           Toolchain_Description      => No_Name,\n+                           PIC_Option                 => No_Name,\n+                           Objects_Generated          => True);\n \n    type Language_Data is record\n       Name          : Name_Id         := No_Name;\n@@ -1390,14 +1384,6 @@ package Prj is\n \n    type Project_Tree_Data is\n       record\n-         --  General\n-\n-         Default_Language         : Name_Id         := No_Name;\n-         --  The name of the language of the sources of a project, when\n-         --  attribute Languages is not specified.\n-\n-         Config                   : Project_Configuration;\n-\n          --  Languages and sources of the project\n \n          First_Language           : Language_Index  := No_Language_Index;"}]}