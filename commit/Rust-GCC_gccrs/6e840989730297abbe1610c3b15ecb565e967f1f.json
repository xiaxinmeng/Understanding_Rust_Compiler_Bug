{"sha": "6e840989730297abbe1610c3b15ecb565e967f1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU4NDA5ODk3MzAyOTdhYmJlMTYxMGMzYjE1ZWNiNTY1ZTk2N2YxZg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-10-23T10:43:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T10:43:30Z"}, "message": "exp_ch7.adb (Process_Transient_Objects): Reimplement to properly handle restriction No_Exception_Propagation.\n\n2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Process_Transient_Objects): Reimplement to properly\n\thandle restriction No_Exception_Propagation.\n\t* exp_ch11.adb (Expand_At_End_Handler): Update the parameter\n\tprofile and all references to Block.\n\t* exp_ch11.ads (Expand_At_End_Handler): Update the parameter\n\tprofile and comment on usage.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Reimplement to properly\n\thandle restriction No_Exception_Propagation.\n\t* gnat1drv.adb, restrict.adb: Update comment.\n\nFrom-SVN: r229227", "tree": {"sha": "003413f638569a3555ab06e70ab2039cc817b977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/003413f638569a3555ab06e70ab2039cc817b977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e840989730297abbe1610c3b15ecb565e967f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e840989730297abbe1610c3b15ecb565e967f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e840989730297abbe1610c3b15ecb565e967f1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e840989730297abbe1610c3b15ecb565e967f1f/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c79f6efda3d3ebae36ecd7beab058684d2790903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c79f6efda3d3ebae36ecd7beab058684d2790903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c79f6efda3d3ebae36ecd7beab058684d2790903"}], "stats": {"total": 681, "additions": 395, "deletions": 286}, "files": [{"sha": "03a8dd91a156d9acb7b7e8ee9f54995424e3b180", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -1,3 +1,15 @@\n+2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Process_Transient_Objects): Reimplement to properly\n+\thandle restriction No_Exception_Propagation.\n+\t* exp_ch11.adb (Expand_At_End_Handler): Update the parameter\n+\tprofile and all references to Block.\n+\t* exp_ch11.ads (Expand_At_End_Handler): Update the parameter\n+\tprofile and comment on usage.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): Reimplement to properly\n+\thandle restriction No_Exception_Propagation.\n+\t* gnat1drv.adb, restrict.adb: Update comment.\n+\n 2015-10-23  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Do not call"}, {"sha": "9580d2dd15fcc4c918b4e3fda5a094242e537ac5", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -99,7 +99,7 @@ package body Exp_Ch11 is\n    --  and the code generator (e.g. gigi) must still handle proper generation\n    --  of cleanup calls for the non-exceptional case.\n \n-   procedure Expand_At_End_Handler (HSS : Node_Id; Block : Node_Id) is\n+   procedure Expand_At_End_Handler (HSS : Node_Id; Blk_Id : Entity_Id) is\n       Clean   : constant Entity_Id  := Entity (At_End_Proc (HSS));\n       Ohandle : Node_Id;\n       Stmnts  : List_Id;\n@@ -138,8 +138,8 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n-      if Present (Block) then\n-         Push_Scope (Block);\n+      if Present (Blk_Id) then\n+         Push_Scope (Blk_Id);\n       end if;\n \n       Ohandle :=\n@@ -175,7 +175,7 @@ package body Exp_Ch11 is\n       Analyze_List (Stmnts, Suppress => All_Checks);\n       Expand_Exception_Handlers (HSS);\n \n-      if Present (Block) then\n+      if Present (Blk_Id) then\n          Pop_Scope;\n       end if;\n    end Expand_At_End_Handler;"}, {"sha": "cdd53de626eedd5106caa7c157823227b71daf41", "filename": "gcc/ada/exp_ch11.ads", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.ads?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,12 +40,11 @@ package Exp_Ch11 is\n    --  See runtime routine Ada.Exceptions for full details on the format and\n    --  content of these tables.\n \n-   procedure Expand_At_End_Handler (HSS : Node_Id; Block : Node_Id);\n-   --  Given a handled statement sequence, HSS, for which the At_End_Proc\n-   --  field is set, and which currently has no exception handlers, this\n-   --  procedure expands the special exception handler required.\n-   --  This procedure also create a new scope for the given Block, if\n-   --  Block is not Empty.\n+   procedure Expand_At_End_Handler (HSS : Node_Id; Blk_Id : Entity_Id);\n+   --  Given handled statement sequence HSS for which the At_End_Proc field\n+   --  is set, and which currently has no exception handlers, this procedure\n+   --  expands the special exception handler required. This procedure also\n+   --  create a new scope for the given block, if Blk_Id is not Empty.\n \n    procedure Expand_Exception_Handlers (HSS : Node_Id);\n    --  This procedure expands exception handlers, and is called as part"}, {"sha": "58a3322596b0925766604d3082e90d5348d5dbaf", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 202, "deletions": 122, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -4683,28 +4683,97 @@ package body Exp_Ch7 is\n \n          --  Local variables\n \n+         Exceptions_OK : constant Boolean :=\n+                           not Restriction_Active (No_Exception_Propagation);\n+\n          Built     : Boolean := False;\n+         Blk_Decl  : Node_Id := Empty;\n+         Blk_Decls : List_Id := No_List;\n+         Blk_Ins   : Node_Id;\n+         Blk_Stmts : List_Id;\n          Desig_Typ : Entity_Id;\n-         Expr      : Node_Id;\n-         Fin_Block : Node_Id;\n+         Fin_Call  : Node_Id;\n          Fin_Data  : Finalization_Exception_Data;\n-         Fin_Decls : List_Id;\n-         Fin_Insrt : Node_Id;\n-         Last_Fin  : Node_Id := Empty;\n+         Fin_Stmts : List_Id;\n+         Hook_Clr  : Node_Id := Empty;\n+         Hook_Id   : Entity_Id;\n+         Hook_Ins  : Node_Id;\n+         Init_Expr : Node_Id;\n          Loc       : Source_Ptr;\n+         Obj_Decl  : Node_Id;\n          Obj_Id    : Entity_Id;\n          Obj_Ref   : Node_Id;\n          Obj_Typ   : Entity_Id;\n-         Prev_Fin  : Node_Id := Empty;\n-         Ptr_Id    : Entity_Id;\n-         Stmt      : Node_Id;\n-         Stmts     : List_Id;\n-         Temp_Id   : Entity_Id;\n-         Temp_Ins  : Node_Id;\n+         Ptr_Typ   : Entity_Id;\n \n       --  Start of processing for Process_Transient_Objects\n \n       begin\n+         --  The expansion performed by this routine is as follows:\n+\n+         --    type Ptr_Typ_1 is access all Ctrl_Trans_Obj_1_Typ;\n+         --    Hook_1 : Ptr_Typ_1 := null;\n+         --    Ctrl_Trans_Obj_1 : ...;\n+         --    Hook_1 := Ctrl_Trans_Obj_1'Unrestricted_Access;\n+         --    . . .\n+         --    type Ptr_Typ_N is access all Ctrl_Trans_Obj_N_Typ;\n+         --    Hook_N : Ptr_Typ_N := null;\n+         --    Ctrl_Trans_Obj_N : ...;\n+         --    Hook_N := Ctrl_Trans_Obj_N'Unrestricted_Access;\n+\n+         --    declare\n+         --       Abrt   : constant Boolean := ...;\n+         --       Ex     : Exception_Occurrence;\n+         --       Raised : Boolean := False;\n+\n+         --    begin\n+         --       begin\n+         --          Hook_N := null;\n+         --          [Deep_]Finalize (Ctrl_Trans_Obj_N);\n+\n+         --       exception\n+         --          when others =>\n+         --             if not Raised then\n+         --                Raised := True;\n+         --                Save_Occurrence (Ex, Get_Current_Excep.all.all);\n+         --       end;\n+         --       . . .\n+         --       begin\n+         --          Hook_1 := null;\n+         --          [Deep_]Finalize (Ctrl_Trans_Obj_1);\n+\n+         --       exception\n+         --          when others =>\n+         --             if not Raised then\n+         --                Raised := True;\n+         --                Save_Occurrence (Ex, Get_Current_Excep.all.all);\n+         --       end;\n+\n+         --       if Raised and not Abrt then\n+         --          Raise_From_Controlled_Operation (Ex);\n+         --       end if;\n+         --    end;\n+\n+         --  When restriction No_Exception_Propagation is active, the expansion\n+         --  is as follows:\n+\n+         --    type Ptr_Typ_1 is access all Ctrl_Trans_Obj_1_Typ;\n+         --    Hook_1 : Ptr_Typ_1 := null;\n+         --    Ctrl_Trans_Obj_1 : ...;\n+         --    Hook_1 := Ctrl_Trans_Obj_1'Unrestricted_Access;\n+         --    . . .\n+         --    type Ptr_Typ_N is access all Ctrl_Trans_Obj_N_Typ;\n+         --    Hook_N : Ptr_Typ_N := null;\n+         --    Ctrl_Trans_Obj_N : ...;\n+         --    Hook_N := Ctrl_Trans_Obj_N'Unrestricted_Access;\n+\n+         --    begin\n+         --       Hook_N := null;\n+         --       [Deep_]Finalize (Ctrl_Trans_Obj_N);\n+         --       Hook_1 := null;\n+         --       [Deep_]Finalize (Ctrl_Trans_Obj_1);\n+         --    end;\n+\n          --  Recognize a scenario where the transient context is an object\n          --  declaration initialized by a build-in-place function call:\n \n@@ -4723,32 +4792,36 @@ package body Exp_Ch7 is\n            and then Present (BIP_Initialization_Call (Defining_Identifier (N)))\n          then\n             Must_Hook := True;\n-            Fin_Insrt := BIP_Initialization_Call (Defining_Identifier (N));\n+            Blk_Ins   := BIP_Initialization_Call (Defining_Identifier (N));\n \n          --  Search the context for at least one subprogram call. If found, the\n          --  machinery exports all transient objects to the enclosing finalizer\n          --  due to the possibility of abnormal call termination.\n \n          else\n             Detect_Subprogram_Call (N);\n-            Fin_Insrt := Last_Object;\n+            Blk_Ins := Last_Object;\n+         end if;\n+\n+         if Clean then\n+            Insert_List_After_And_Analyze (Blk_Ins, Act_Cleanup);\n          end if;\n \n          --  Examine all objects in the list First_Object .. Last_Object\n \n-         Stmt := First_Object;\n-         while Present (Stmt) loop\n-            if Nkind (Stmt) = N_Object_Declaration\n-              and then Analyzed (Stmt)\n-              and then Is_Finalizable_Transient (Stmt, N)\n+         Obj_Decl := First_Object;\n+         while Present (Obj_Decl) loop\n+            if Nkind (Obj_Decl) = N_Object_Declaration\n+              and then Analyzed (Obj_Decl)\n+              and then Is_Finalizable_Transient (Obj_Decl, N)\n \n               --  Do not process the node to be wrapped since it will be\n               --  handled by the enclosing finalizer.\n \n-              and then Stmt /= Related_Node\n+              and then Obj_Decl /= Related_Node\n             then\n-               Loc       := Sloc (Stmt);\n-               Obj_Id    := Defining_Identifier (Stmt);\n+               Loc       := Sloc (Obj_Decl);\n+               Obj_Id    := Defining_Identifier (Obj_Decl);\n                Obj_Typ   := Base_Type (Etype (Obj_Id));\n                Desig_Typ := Obj_Typ;\n \n@@ -4760,18 +4833,8 @@ package body Exp_Ch7 is\n                   Desig_Typ := Available_View (Designated_Type (Desig_Typ));\n                end if;\n \n-               --  Create the necessary entities and declarations the first\n-               --  time around.\n-\n-               if not Built then\n-                  Built     := True;\n-                  Fin_Decls := New_List;\n-\n-                  Build_Object_Declarations (Fin_Data, Fin_Decls, Loc);\n-               end if;\n-\n-               --  Transient variables associated with subprogram calls need\n-               --  extra processing. These variables are usually created right\n+               --  Transient objects associated with subprogram calls need\n+               --  extra processing. These objects are usually created right\n                --  before the call and finalized immediately after the call.\n                --  If an exception occurs during the call, the clean up code\n                --  is skipped due to the sudden change in control and the\n@@ -4783,59 +4846,55 @@ package body Exp_Ch7 is\n \n                if Must_Hook then\n \n-                  --  Step 1: Create an access type which provides a reference\n-                  --  to the transient object. Generate:\n-\n-                  --    Ann : access [all] <Desig_Typ>;\n+                  --  Create an access type which provides a reference to the\n+                  --  transient object. Generate:\n+                  --    type Ptr_Typ is access [all] Desig_Typ;\n \n-                  Ptr_Id := Make_Temporary (Loc, 'A');\n+                  Ptr_Typ := Make_Temporary (Loc, 'A');\n \n-                  Insert_Action (Stmt,\n+                  Insert_Action (Obj_Decl,\n                     Make_Full_Type_Declaration (Loc,\n-                      Defining_Identifier => Ptr_Id,\n+                      Defining_Identifier => Ptr_Typ,\n                       Type_Definition     =>\n                         Make_Access_To_Object_Definition (Loc,\n                           All_Present        =>\n                             Ekind (Obj_Typ) = E_General_Access_Type,\n                           Subtype_Indication =>\n                             New_Occurrence_Of (Desig_Typ, Loc))));\n \n-                  --  Step 2: Create a temporary which acts as a hook to the\n-                  --  transient object. Generate:\n-\n-                  --    Temp : Ptr_Id := null;\n+                  --  Create a temporary which acts as a hook to the transient\n+                  --  object. Generate:\n+                  --    Hook : Ptr_Typ := null;\n \n-                  Temp_Id := Make_Temporary (Loc, 'T');\n+                  Hook_Id := Make_Temporary (Loc, 'T');\n \n-                  Insert_Action (Stmt,\n+                  Insert_Action (Obj_Decl,\n                     Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Temp_Id,\n+                      Defining_Identifier => Hook_Id,\n                       Object_Definition   =>\n-                        New_Occurrence_Of (Ptr_Id, Loc)));\n+                        New_Occurrence_Of (Ptr_Typ, Loc)));\n \n-                  --  Mark the temporary as a transient hook. This signals the\n-                  --  machinery in Build_Finalizer to recognize this special\n-                  --  case.\n+                  --  Mark the temporary as a hook. This signals the machinery\n+                  --  in Build_Finalizer to recognize this special case.\n \n-                  Set_Status_Flag_Or_Transient_Decl (Temp_Id, Stmt);\n+                  Set_Status_Flag_Or_Transient_Decl (Hook_Id, Obj_Decl);\n \n-                  --  Step 3: Hook the transient object to the temporary\n+                  --  Hook the transient object to the temporary. Generate:\n+                  --    Hook := Ptr_Typ (Obj_Id);\n+                  --      <or>\n+                  --    Hook := Obj_Id'Unrestricted_Access;\n \n                   if Is_Access_Type (Obj_Typ) then\n-                     Expr :=\n-                       Convert_To (Ptr_Id, New_Occurrence_Of (Obj_Id, Loc));\n+                     Init_Expr :=\n+                       Convert_To (Ptr_Typ, New_Occurrence_Of (Obj_Id, Loc));\n+\n                   else\n-                     Expr :=\n+                     Init_Expr :=\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Occurrence_Of (Obj_Id, Loc),\n                          Attribute_Name => Name_Unrestricted_Access);\n                   end if;\n \n-                  --  Generate:\n-                  --    Temp := Ptr_Id (Obj_Id);\n-                  --      <or>\n-                  --    Temp := Obj_Id'Unrestricted_Access;\n-\n                   --  When the transient object is initialized by an aggregate,\n                   --  the hook must capture the object after the last component\n                   --  assignment takes place. Only then is the object fully\n@@ -4844,55 +4903,88 @@ package body Exp_Ch7 is\n                   if Ekind (Obj_Id) = E_Variable\n                     and then Present (Last_Aggregate_Assignment (Obj_Id))\n                   then\n-                     Temp_Ins := Last_Aggregate_Assignment (Obj_Id);\n+                     Hook_Ins := Last_Aggregate_Assignment (Obj_Id);\n \n                   --  Otherwise the hook seizes the related object immediately\n \n                   else\n-                     Temp_Ins := Stmt;\n+                     Hook_Ins := Obj_Decl;\n                   end if;\n \n-                  Insert_After_And_Analyze (Temp_Ins,\n+                  Insert_After_And_Analyze (Hook_Ins,\n                     Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Temp_Id, Loc),\n-                      Expression => Expr));\n+                      Name       => New_Occurrence_Of (Hook_Id, Loc),\n+                      Expression => Init_Expr));\n+\n+                  --  The transient object is about to be finalized by the\n+                  --  clean up code following the subprogram call. In order\n+                  --  to avoid double finalization, clear the hook.\n+\n+                  --  Generate:\n+                  --    Hook := null;\n+\n+                  Hook_Clr :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Hook_Id, Loc),\n+                      Expression => Make_Null (Loc));\n                end if;\n \n-               Stmts := New_List;\n+               --  Before generating the clean up code for the first transient\n+               --  object, create a wrapper block which houses all hook clear\n+               --  statements and finalization calls. This wrapper is needed by\n+               --  the back-end.\n \n-               --  The transient object is about to be finalized by the clean\n-               --  up code following the subprogram call. In order to avoid\n-               --  double finalization, clear the hook.\n+               if not Built then\n+                  Built     := True;\n+                  Blk_Stmts := New_List;\n \n-               --  Generate:\n-               --    Temp := null;\n+                  --  Create the declarations of all entities that participate\n+                  --  in exception detection and propagation.\n \n-               if Must_Hook then\n-                  Append_To (Stmts,\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Temp_Id, Loc),\n-                      Expression => Make_Null (Loc)));\n+                  if Exceptions_OK then\n+                     Blk_Decls := New_List;\n+\n+                     --  Generate:\n+                     --    Abrt   : constant Boolean := ...;\n+                     --    Ex     : Exception_Occurrence;\n+                     --    Raised : Boolean := False;\n+\n+                     Build_Object_Declarations (Fin_Data, Blk_Decls, Loc);\n+\n+                     --  Generate:\n+                     --    if Raised and then not Abrt then\n+                     --       Raise_From_Controlled_Operation (Ex);\n+                     --    end if;\n+\n+                     Append_To (Blk_Stmts, Build_Raise_Statement (Fin_Data));\n+                  end if;\n+\n+                  Blk_Decl :=\n+                    Make_Block_Statement (Loc,\n+                      Declarations               => Blk_Decls,\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                          Statements => Blk_Stmts));\n                end if;\n \n                --  Generate:\n                --    [Deep_]Finalize (Obj_Ref);\n \n-               --  Set type of dereference, so that proper conversion are\n-               --  generated when operation is inherited.\n-\n                Obj_Ref := New_Occurrence_Of (Obj_Id, Loc);\n \n                if Is_Access_Type (Obj_Typ) then\n                   Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n-                  Set_Etype (Obj_Ref, Directly_Designated_Type (Obj_Typ));\n+                  Set_Etype (Obj_Ref, Desig_Typ);\n                end if;\n \n-               Append_To (Stmts,\n-                 Make_Final_Call (Obj_Ref => Obj_Ref, Typ => Desig_Typ));\n+               Fin_Call :=\n+                 Make_Final_Call (Obj_Ref => Obj_Ref, Typ => Desig_Typ);\n \n-               --  Generate:\n-               --    [Temp := null;]\n+               --  When exception propagation is enabled wrap the hook clear\n+               --  statement and the finalization call into a block to catch\n+               --  potential exceptions raised during finalization. Generate:\n                --    begin\n+               --       [Temp := null;]\n                --       [Deep_]Finalize (Obj_Ref);\n \n                --    exception\n@@ -4904,60 +4996,48 @@ package body Exp_Ch7 is\n                --          end if;\n                --    end;\n \n-               Fin_Block :=\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => Stmts,\n-                       Exception_Handlers => New_List (\n-                         Build_Exception_Handler (Fin_Data))));\n+               if Exceptions_OK then\n+                  Fin_Stmts := New_List;\n \n-               --  The single raise statement must be inserted after all the\n-               --  finalization blocks, and we put everything into a wrapper\n-               --  block to clearly expose the construct to the back-end.\n+                  if Present (Hook_Clr) then\n+                     Append_To (Fin_Stmts, Hook_Clr);\n+                  end if;\n \n-               if Present (Prev_Fin) then\n-                  Insert_Before_And_Analyze (Prev_Fin, Fin_Block);\n-               else\n-                  Insert_After_And_Analyze (Fin_Insrt,\n+                  Append_To (Fin_Stmts, Fin_Call);\n+\n+                  Prepend_To (Blk_Stmts,\n                     Make_Block_Statement (Loc,\n-                      Declarations => Fin_Decls,\n                       Handled_Statement_Sequence =>\n                         Make_Handled_Sequence_Of_Statements (Loc,\n-                          Statements => New_List (Fin_Block))));\n+                          Statements         => Fin_Stmts,\n+                          Exception_Handlers => New_List (\n+                            Build_Exception_Handler (Fin_Data)))));\n \n-                  Last_Fin := Fin_Block;\n-               end if;\n+               --  Otherwise generate:\n+               --    [Temp := null;]\n+               --    [Deep_]Finalize (Obj_Ref);\n+\n+               else\n+                  Prepend_To (Blk_Stmts, Fin_Call);\n \n-               Prev_Fin := Fin_Block;\n+                  if Present (Hook_Clr) then\n+                     Prepend_To (Blk_Stmts, Hook_Clr);\n+                  end if;\n+               end if;\n             end if;\n \n             --  Terminate the scan after the last object has been processed to\n             --  avoid touching unrelated code.\n \n-            if Stmt = Last_Object then\n+            if Obj_Decl = Last_Object then\n                exit;\n             end if;\n \n-            Next (Stmt);\n+            Next (Obj_Decl);\n          end loop;\n \n-         if Clean then\n-            if Present (Prev_Fin) then\n-               Insert_List_Before_And_Analyze (Prev_Fin, Act_Cleanup);\n-            else\n-               Insert_List_After_And_Analyze (Fin_Insrt, Act_Cleanup);\n-            end if;\n-         end if;\n-\n-         --  Generate:\n-         --    if Raised and then not Abort then\n-         --       Raise_From_Controlled_Operation (E);\n-         --    end if;\n-\n-         if Built and then Present (Last_Fin) then\n-            Insert_After_And_Analyze (Last_Fin,\n-              Build_Raise_Statement (Fin_Data));\n+         if Present (Blk_Decl) then\n+            Insert_After_And_Analyze (Blk_Ins, Blk_Decl);\n          end if;\n       end Process_Transient_Objects;\n "}, {"sha": "bbdcf774c6ae51a478b774c3f6f680600435be53", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 161, "deletions": 144, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -959,46 +959,36 @@ package body Exp_Intr is\n    -- Expand_Unc_Deallocation --\n    -----------------------------\n \n-   --  Generate the following Code :\n-\n-   --    if Arg /= null then\n-   --     <Finalize_Call> (.., T'Class(Arg.all), ..);  -- for controlled types\n-   --       Free (Arg);\n-   --       Arg := Null;\n-   --    end if;\n-\n-   --  For a task, we also generate a call to Free_Task to ensure that the\n-   --  task itself is freed if it is terminated, ditto for a simple protected\n-   --  object, with a call to Finalize_Protection. For composite types that\n-   --  have tasks or simple protected objects as components, we traverse the\n-   --  structures to find and terminate those components.\n-\n    procedure Expand_Unc_Deallocation (N : Node_Id) is\n       Arg       : constant Node_Id    := First_Actual (N);\n       Loc       : constant Source_Ptr := Sloc (N);\n       Typ       : constant Entity_Id  := Etype (Arg);\n-      Desig_T   : constant Entity_Id  := Designated_Type (Typ);\n-      Rtyp      : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n-      Pool      : constant Entity_Id  := Associated_Storage_Pool (Rtyp);\n+      Desig_Typ : constant Entity_Id  := Designated_Type (Typ);\n+      Needs_Fin : constant Boolean    := Needs_Finalization (Desig_Typ);\n+      Root_Typ  : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n+      Pool      : constant Entity_Id  := Associated_Storage_Pool (Root_Typ);\n       Stmts     : constant List_Id    := New_List;\n-      Needs_Fin : constant Boolean    := Needs_Finalization (Desig_T);\n-\n-      Finalizer_Data  : Finalization_Exception_Data;\n-\n-      Blk        : Node_Id := Empty;\n-      Blk_Id     : Entity_Id;\n-      Deref      : Node_Id;\n-      Final_Code : List_Id;\n-      Free_Arg   : Node_Id;\n-      Free_Node  : Node_Id;\n-      Gen_Code   : Node_Id;\n \n       Arg_Known_Non_Null : constant Boolean := Known_Non_Null (N);\n       --  This captures whether we know the argument to be non-null so that\n       --  we can avoid the test. The reason that we need to capture this is\n       --  that we analyze some generated statements before properly attaching\n       --  them to the tree, and that can disturb current value settings.\n \n+      Exceptions_OK : constant Boolean :=\n+                        not Restriction_Active (No_Exception_Propagation);\n+\n+      Abrt_Blk    : Node_Id := Empty;\n+      Abrt_Blk_Id : Entity_Id;\n+      AUD         : Entity_Id;\n+      Fin_Blk     : Node_Id;\n+      Fin_Call    : Node_Id;\n+      Fin_Data    : Finalization_Exception_Data;\n+      Free_Arg    : Node_Id;\n+      Free_Nod    : Node_Id;\n+      Gen_Code    : Node_Id;\n+      Obj_Ref     : Node_Id;\n+\n       Dummy : Entity_Id;\n       --  This variable captures an unused dummy internal entity, see the\n       --  comment associated with its use.\n@@ -1010,152 +1000,177 @@ package body Exp_Intr is\n          return;\n       end if;\n \n-      --  Processing for pointer to controlled type\n+      --  Processing for pointer to controlled types. Generate:\n+\n+      --    Abrt   : constant Boolean := ...;\n+      --    Ex     : Exception_Occurrence;\n+      --    Raised : Boolean := False;\n+\n+      --    begin                             --  aborts allowed\n+      --       Abort_Defer;\n+\n+      --       begin                          --  exception propagation allowed\n+      --          [Deep_]Finalize (Obj_Ref);\n+\n+      --       exception\n+      --          when others =>\n+      --             if not Raised then\n+      --                Raised := True;\n+      --                Save_Occurrence (Ex, Get_Current_Excep.all.all);\n+      --       end;\n+      --    at end\n+      --       Abort_Undefer_Direct;\n+      --    end;\n+\n+      --  Depending on whether exception propagation is enabled and/or aborts\n+      --  are allowed, the generated code may lack block statements.\n \n       if Needs_Fin then\n-         Deref :=\n+         Obj_Ref :=\n            Make_Explicit_Dereference (Loc,\n              Prefix => Duplicate_Subexpr_No_Checks (Arg));\n \n-         --  If the type is tagged, then we must force dispatching on the\n-         --  finalization call because the designated type may not be the\n-         --  actual type of the object.\n+         --  If the designated type is tagged, the finalization call must\n+         --  dispatch because the designated type may not be the actual type\n+         --  of the object.\n \n-         if Is_Tagged_Type (Desig_T)\n-           and then not Is_Class_Wide_Type (Desig_T)\n-         then\n-            Deref := Unchecked_Convert_To (Class_Wide_Type (Desig_T), Deref);\n-\n-         elsif not Is_Tagged_Type (Desig_T) then\n+         if Is_Tagged_Type (Desig_Typ) then\n+            if not Is_Class_Wide_Type (Desig_Typ) then\n+               Obj_Ref :=\n+                 Unchecked_Convert_To (Class_Wide_Type (Desig_Typ), Obj_Ref);\n+            end if;\n \n-            --  Set type of result, to force a conversion when needed (see\n-            --  exp_ch7, Convert_View), given that Deep_Finalize may be\n-            --  inherited from the parent type, and we need the type of the\n-            --  expression to see whether the conversion is in fact needed.\n+         --  Otherwise the designated type is untagged. Set the type of the\n+         --  dereference explicitly to force a conversion when needed given\n+         --  that [Deep_]Finalize may be inherited from a parent type.\n \n-            Set_Etype (Deref, Desig_T);\n+         else\n+            Set_Etype (Obj_Ref, Desig_Typ);\n          end if;\n \n-         --  The finalization call is expanded wrapped in a block to catch any\n-         --  possible exception. If an exception does occur, then Program_Error\n-         --  must be raised following the freeing of the object and its removal\n-         --  from the finalization collection's list. We set a flag to record\n-         --  that an exception was raised, and save its occurrence for use in\n-         --  the later raise.\n-         --\n          --  Generate:\n-         --    Abort  : constant Boolean :=\n-         --               Exception_Occurrence (Get_Current_Excep.all.all) =\n-         --                 Standard'Abort_Signal'Identity;\n-         --      <or>\n-         --    Abort  : constant Boolean := False;  --  no abort\n+         --    [Deep_]Finalize (Obj_Ref);\n+\n+         Fin_Call := Make_Final_Call (Obj_Ref => Obj_Ref, Typ => Desig_Typ);\n \n-         --    E      : Exception_Occurrence;\n+         --  Generate:\n+         --    Abrt   : constant Boolean := ...;\n+         --    Ex     : Exception_Occurrence;\n          --    Raised : Boolean := False;\n-         --\n+\n          --    begin\n-         --       [Deep_]Finalize (Obj);\n+         --       <Fin_Call>\n+\n          --    exception\n          --       when others =>\n-         --          Raised := True;\n-         --          Save_Occurrence (E, Get_Current_Excep.all.all);\n+         --          if not Raised then\n+         --             Raised := True;\n+         --             Save_Occurrence (Ex, Get_Current_Excep.all.all);\n          --    end;\n \n-         Build_Object_Declarations (Finalizer_Data, Stmts, Loc);\n+         if Exceptions_OK then\n+            Build_Object_Declarations (Fin_Data, Stmts, Loc);\n \n-         Final_Code := New_List (\n-           Make_Block_Statement (Loc,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements         => New_List (\n-                   Make_Final_Call (Obj_Ref => Deref, Typ => Desig_T)),\n-                 Exception_Handlers => New_List (\n-                   Build_Exception_Handler (Finalizer_Data)))));\n+            Fin_Blk :=\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements         => New_List (Fin_Call),\n+                    Exception_Handlers => New_List (\n+                      Build_Exception_Handler (Fin_Data))));\n \n-         --  If aborts are allowed, then the finalization code must be\n-         --  protected by an abort defer/undefer pair.\n+            --  The finalization action must be protected by an abort defer\n+            --  undefer pair when aborts are allowed. Generate:\n \n-         if Abort_Allowed then\n-            Prepend_To (Final_Code, Build_Runtime_Call (Loc, RE_Abort_Defer));\n+            --    begin\n+            --       Abort_Defer;\n+            --       <Fin_Blk>\n+            --    at end\n+            --       Abort_Undefer_Direct;\n+            --    end;\n \n-            declare\n-               AUD : constant Entity_Id := RTE (RE_Abort_Undefer_Direct);\n+            if Abort_Allowed then\n+               AUD := RTE (RE_Abort_Undefer_Direct);\n \n-            begin\n-               Blk :=\n+               Abrt_Blk :=\n                  Make_Block_Statement (Loc,\n                    Handled_Statement_Sequence =>\n                      Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements  => Final_Code,\n+                       Statements  => New_List (\n+                         Build_Runtime_Call (Loc, RE_Abort_Defer),\n+                         Fin_Blk),\n                        At_End_Proc => New_Occurrence_Of (AUD, Loc)));\n \n+               Add_Block_Identifier (Abrt_Blk, Abrt_Blk_Id);\n+\n                --  Present the Abort_Undefer_Direct function to the backend so\n                --  that it can inline the call to the function.\n \n                Add_Inlined_Body (AUD, N);\n-            end;\n+               Append_To (Stmts, Abrt_Blk);\n \n-            Add_Block_Identifier (Blk, Blk_Id);\n+            --  Otherwise aborts are not allowed. Generate a dummy entity to\n+            --  ensure that the internal symbols are in sync when a unit is\n+            --  compiled with and without aborts.\n \n-            Append (Blk, Stmts);\n+            else\n+               Dummy := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n+               Append_To (Stmts, Fin_Blk);\n+            end if;\n \n-         else\n-            --  Generate a dummy entity to ensure that the internal symbols are\n-            --  in sync when a unit is compiled with and without aborts.\n+         --  Otherwise exception propagation is not allowed\n \n-            Dummy := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n-            Append_List_To (Stmts, Final_Code);\n+         else\n+            Append_To (Stmts, Fin_Call);\n          end if;\n       end if;\n \n-      --  For a task type, call Free_Task before freeing the ATCB\n-\n-      if Is_Task_Type (Desig_T) then\n-\n-         --  We used to detect the case of Abort followed by a Free here,\n-         --  because the Free wouldn't actually free if it happens before\n-         --  the aborted task actually terminates. The warning was removed,\n-         --  because Free now works properly (the task will be freed once\n-         --  it terminates).\n+      --  For a task type, call Free_Task before freeing the ATCB. We used to\n+      --  detect the case of Abort followed by a Free here, because the Free\n+      --  wouldn't actually free if it happens before the aborted task actually\n+      --  terminates. The warning was removed, because Free now works properly\n+      --  (the task will be freed once it terminates).\n \n+      if Is_Task_Type (Desig_Typ) then\n          Append_To\n            (Stmts, Cleanup_Task (N, Duplicate_Subexpr_No_Checks (Arg)));\n \n       --  For composite types that contain tasks, recurse over the structure\n       --  to build the selectors for the task subcomponents.\n \n-      elsif Has_Task (Desig_T) then\n-         if Is_Record_Type (Desig_T) then\n-            Append_List_To (Stmts, Cleanup_Record (N, Arg, Desig_T));\n+      elsif Has_Task (Desig_Typ) then\n+         if Is_Array_Type (Desig_Typ) then\n+            Append_List_To (Stmts, Cleanup_Array (N, Arg, Desig_Typ));\n \n-         elsif Is_Array_Type (Desig_T) then\n-            Append_List_To (Stmts, Cleanup_Array (N, Arg, Desig_T));\n+         elsif Is_Record_Type (Desig_Typ) then\n+            Append_List_To (Stmts, Cleanup_Record (N, Arg, Desig_Typ));\n          end if;\n       end if;\n \n       --  Same for simple protected types. Eventually call Finalize_Protection\n       --  before freeing the PO for each protected component.\n \n-      if Is_Simple_Protected_Type (Desig_T) then\n+      if Is_Simple_Protected_Type (Desig_Typ) then\n          Append_To (Stmts,\n            Cleanup_Protected_Object (N, Duplicate_Subexpr_No_Checks (Arg)));\n \n-      elsif Has_Simple_Protected_Object (Desig_T) then\n-         if Is_Record_Type (Desig_T) then\n-            Append_List_To (Stmts, Cleanup_Record (N, Arg, Desig_T));\n-         elsif Is_Array_Type (Desig_T) then\n-            Append_List_To (Stmts, Cleanup_Array (N, Arg, Desig_T));\n+      elsif Has_Simple_Protected_Object (Desig_Typ) then\n+         if Is_Array_Type (Desig_Typ) then\n+            Append_List_To (Stmts, Cleanup_Array (N, Arg, Desig_Typ));\n+\n+         elsif Is_Record_Type (Desig_Typ) then\n+            Append_List_To (Stmts, Cleanup_Record (N, Arg, Desig_Typ));\n          end if;\n       end if;\n \n       --  Normal processing for non-controlled types. The argument to free is\n       --  a renaming rather than a constant to ensure that the original context\n       --  is always set to null after the deallocation takes place.\n \n-      Free_Arg  := Duplicate_Subexpr_No_Checks (Arg, Renaming_Req => True);\n-      Free_Node := Make_Free_Statement (Loc, Empty);\n-      Append_To (Stmts, Free_Node);\n-      Set_Storage_Pool (Free_Node, Pool);\n+      Free_Arg := Duplicate_Subexpr_No_Checks (Arg, Renaming_Req => True);\n+      Free_Nod := Make_Free_Statement (Loc, Empty);\n+      Append_To (Stmts, Free_Nod);\n+      Set_Storage_Pool (Free_Nod, Pool);\n \n       --  Attach to tree before analysis of generated subtypes below\n \n@@ -1176,23 +1191,24 @@ package body Exp_Intr is\n          --  Deallocate (which is allowed), then the actual will simply be set\n          --  to null.\n \n-         elsif Present (Get_Rep_Pragma\n-                          (Etype (Pool), Name_Simple_Storage_Pool_Type))\n+         elsif Present\n+                 (Get_Rep_Pragma (Etype (Pool), Name_Simple_Storage_Pool_Type))\n          then\n             declare\n-               Pool_Type  : constant Entity_Id := Base_Type (Etype (Pool));\n-               Dealloc_Op : Entity_Id;\n+               Pool_Typ : constant Entity_Id := Base_Type (Etype (Pool));\n+               Dealloc  : Entity_Id;\n+\n             begin\n-               Dealloc_Op := Get_Name_Entity_Id (Name_Deallocate);\n-               while Present (Dealloc_Op) loop\n-                  if Scope (Dealloc_Op) = Scope (Pool_Type)\n-                    and then Present (First_Formal (Dealloc_Op))\n-                    and then Etype (First_Formal (Dealloc_Op)) = Pool_Type\n+               Dealloc := Get_Name_Entity_Id (Name_Deallocate);\n+               while Present (Dealloc) loop\n+                  if Scope (Dealloc) = Scope (Pool_Typ)\n+                    and then Present (First_Formal (Dealloc))\n+                    and then Etype (First_Formal (Dealloc)) = Pool_Typ\n                   then\n-                     Set_Procedure_To_Call (Free_Node, Dealloc_Op);\n+                     Set_Procedure_To_Call (Free_Nod, Dealloc);\n                      exit;\n                   else\n-                     Dealloc_Op := Homonym (Dealloc_Op);\n+                     Dealloc := Homonym (Dealloc);\n                   end if;\n                end loop;\n             end;\n@@ -1201,17 +1217,17 @@ package body Exp_Intr is\n          --  Deallocate through the class-wide Deallocate_Any.\n \n          elsif Is_Class_Wide_Type (Etype (Pool)) then\n-            Set_Procedure_To_Call (Free_Node, RTE (RE_Deallocate_Any));\n+            Set_Procedure_To_Call (Free_Nod, RTE (RE_Deallocate_Any));\n \n          --  Case of a specific pool type: make a statically bound call\n \n          else\n-            Set_Procedure_To_Call (Free_Node,\n-              Find_Prim_Op (Etype (Pool), Name_Deallocate));\n+            Set_Procedure_To_Call\n+              (Free_Nod, Find_Prim_Op (Etype (Pool), Name_Deallocate));\n          end if;\n       end if;\n \n-      if Present (Procedure_To_Call (Free_Node)) then\n+      if Present (Procedure_To_Call (Free_Nod)) then\n \n          --  For all cases of a Deallocate call, the back-end needs to be able\n          --  to compute the size of the object being freed. This may require\n@@ -1222,11 +1238,11 @@ package body Exp_Intr is\n          --  size parameter computed by GIGI. Same for an access to\n          --  unconstrained packed array.\n \n-         if Is_Class_Wide_Type (Desig_T)\n+         if Is_Class_Wide_Type (Desig_Typ)\n            or else\n-            (Is_Array_Type (Desig_T)\n-              and then not Is_Constrained (Desig_T)\n-              and then Is_Packed (Desig_T))\n+            (Is_Array_Type (Desig_Typ)\n+              and then not Is_Constrained (Desig_Typ)\n+              and then Is_Packed (Desig_Typ))\n          then\n             declare\n                Deref    : constant Node_Id :=\n@@ -1239,9 +1255,9 @@ package body Exp_Intr is\n                --  Perform minor decoration as it is needed by the side effect\n                --  removal mechanism.\n \n-               Set_Etype  (Deref, Desig_T);\n-               Set_Parent (Deref, Free_Node);\n-               D_Subtyp := Make_Subtype_From_Expr (Deref, Desig_T);\n+               Set_Etype  (Deref, Desig_Typ);\n+               Set_Parent (Deref, Free_Nod);\n+               D_Subtyp := Make_Subtype_From_Expr (Deref, Desig_Typ);\n \n                if Nkind (D_Subtyp) in N_Has_Entity then\n                   D_Type := Entity (D_Subtyp);\n@@ -1260,9 +1276,8 @@ package body Exp_Intr is\n \n                Freeze_Itype (D_Type, Deref);\n \n-               Set_Actual_Designated_Subtype (Free_Node, D_Type);\n+               Set_Actual_Designated_Subtype (Free_Nod, D_Type);\n             end;\n-\n          end if;\n       end if;\n \n@@ -1277,18 +1292,19 @@ package body Exp_Intr is\n       if Is_Interface (Directly_Designated_Type (Typ))\n         and then Tagged_Type_Expansion\n       then\n-         Set_Expression (Free_Node,\n+         Set_Expression (Free_Nod,\n            Unchecked_Convert_To (Typ,\n              Make_Function_Call (Loc,\n-               Name => New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+               Name                   =>\n+                 New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n                Parameter_Associations => New_List (\n                  Unchecked_Convert_To (RTE (RE_Address), Free_Arg)))));\n \n       --  Generate:\n       --    free (Obj_Ptr)\n \n       else\n-         Set_Expression (Free_Node, Free_Arg);\n+         Set_Expression (Free_Nod, Free_Arg);\n       end if;\n \n       --  Only remaining step is to set result to null, or generate a raise of\n@@ -1316,14 +1332,14 @@ package body Exp_Intr is\n       --  exception occurrence.\n \n       --  Generate:\n-      --    if Raised and then not Abort then\n+      --    if Raised and then not Abrt then\n       --       raise Program_Error;                  --  for restricted RTS\n       --         <or>\n       --       Raise_From_Controlled_Operation (E);  --  all other cases\n       --    end if;\n \n-      if Needs_Fin then\n-         Append_To (Stmts, Build_Raise_Statement (Finalizer_Data));\n+      if Needs_Fin and then Exceptions_OK then\n+         Append_To (Stmts, Build_Raise_Statement (Fin_Data));\n       end if;\n \n       --  If we know the argument is non-null, then make a block statement\n@@ -1342,7 +1358,7 @@ package body Exp_Intr is\n       else\n          Gen_Code :=\n            Make_Implicit_If_Statement (N,\n-             Condition =>\n+             Condition       =>\n                Make_Op_Ne (Loc,\n                  Left_Opnd  => Duplicate_Subexpr (Arg),\n                  Right_Opnd => Make_Null (Loc)),\n@@ -1357,9 +1373,10 @@ package body Exp_Intr is\n       --  If we generated a block with an At_End_Proc, expand the exception\n       --  handler. We need to wait until after everything else is analyzed.\n \n-      if Present (Blk) then\n+      if Present (Abrt_Blk) then\n          Expand_At_End_Handler\n-           (Handled_Statement_Sequence (Blk), Entity (Identifier (Blk)));\n+           (HSS    => Handled_Statement_Sequence (Abrt_Blk),\n+            Blk_Id => Entity (Identifier (Abrt_Blk)));\n       end if;\n    end Expand_Unc_Deallocation;\n "}, {"sha": "bd3af2ef2714f642b205d6421cfd014c3048ec12", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -378,10 +378,7 @@ procedure Gnat1drv is\n          Optimization_Level := 0;\n \n          --  Enable some restrictions systematically to simplify the generated\n-         --  code (and ease analysis). Note that restriction checks are also\n-         --  disabled in SPARK mode, see Restrict.Check_Restriction, and user\n-         --  specified Restrictions pragmas are ignored, see\n-         --  Sem_Prag.Process_Restrictions_Or_Restriction_Warnings.\n+         --  code (and ease analysis).\n \n          Restrict.Restrictions.Set (No_Initialize_Scalars) := True;\n "}, {"sha": "37f579b737a0a406ac1cdf1f7a0d4a71fa3ca908", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e840989730297abbe1610c3b15ecb565e967f1f/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=6e840989730297abbe1610c3b15ecb565e967f1f", "patch": "@@ -498,14 +498,18 @@ package body Restrict is\n    begin\n       Msg_Issued := False;\n \n-      --  In CodePeer and SPARK mode, we do not want to check for any\n-      --  restriction, or set additional restrictions other than those already\n-      --  set in gnat1drv.adb so that we have consistency between each\n-      --  compilation.\n+      --  In CodePeer mode, we do not want to check for any restriction, or set\n+      --  additional restrictions other than those already set in gnat1drv.adb\n+      --  so that we have consistency between each compilation.\n+\n+      --  In GNATprove mode restrictions are checked, except for\n+      --  No_Initialize_Scalars, which is implicitely set in gnat1drv.adb.\n \n       --  Just checking, SPARK does not allow restrictions to be set ???\n \n-      if CodePeer_Mode then\n+      if CodePeer_Mode\n+        or else (GNATprove_Mode and then R = No_Initialize_Scalars)\n+      then\n          return;\n       end if;\n "}]}