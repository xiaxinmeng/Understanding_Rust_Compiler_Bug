{"sha": "83c02e38a3bf8e6d547a292754a581096021b594", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNjMDJlMzhhM2JmOGU2ZDU0N2EyOTI3NTRhNTgxMDk2MDIxYjU5NA==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-12-02T22:26:50Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-12-02T22:26:50Z"}, "message": "configure.in: Added new MinGW-specific configure flag --with-win32-nlsapi.\n\n\t* configure.in: Added new MinGW-specific configure flag\n\t--with-win32-nlsapi.\n\tAdded new AC_DEFINE MINGW_LIBGCJ_UNICODE.\n\tAdd -lunicows to MinGW SYSTEMSPEC if --with-win32-nlsapi\n\tis set to unicows.\n\t* configure: Rebuilt.\n\t* include/config.h.in: Rebuilt.\n\t* win32.cc (_Jv_Win32NewString): Implemented.\n\t(nativeToUnicode): New helper function defined only for\n\tnon-UNICODE builds.\n\t(unicodeToNative): Likewise.\n\t(_Jv_Win32TempString): Implemented.\n\t(lots): Refactored using tchar.h macros.\n\t(WSAEventWrapper): Use _Jv_Win32NewString.\n\t(_Jv_platform_initialize): Use GetModuleFileNameA instead\n\tof GetModuleFileName.\n\t(_Jv_platform_initProperties): Use _Jv_Win32NewString.\n\tUse temporary stack buffer instead of a heap buffer.\n\t* include/win32.h\n\tAdded defines for UNICODE and _UNICODE if MINGW_LIBGCJ_UNICODE is\n\tdefined; added tchar.h include.\n\t(_Jv_Win32TempString): Declared new helper class.\n\t(JV_TEMP_STRING_WIN32): New helper macro.\n\t(_Jv_Win32NewString): Declared new helper method.\n\t* java/io/natFileDescriptorWin32.cc (open): Use\n\tJV_TEMP_STRING_WIN32 instead of JV_TEMP_UTF_STRING.\n\t(write): Reformatted slightly.\n\t* java/io/natFileWin32.cc (lots): Use tchar.h macros;\n\tuse JV_TEMP_STRING_WIN32 instead of JV_TEMP_UTF_STRING.\n\t(getCanonicalPath): Use _Jv_Win32NewString instead of\n\tJvNewStringUTF.\n\t(performList): Likewise.\n\t* java/lang/natWin32Process.cc (ChildProcessPipe):\n\tUse tchar.h macros.\n\t(startProcess): Use tchar.h macros, JV_TEMP_STRING_WIN32,\n\tand UNICODE environment flag for CreateProcess.\n\t* java/net/natNetworkInterfaceWin32.cc\n\t(winsock2GetRealNetworkInterfaces): Use tchar.h macros and\n\t_Jv_Win32NewString.\n\nFrom-SVN: r74201", "tree": {"sha": "4db34f47c7611b5c83b79334f47f1a5411fbbc44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db34f47c7611b5c83b79334f47f1a5411fbbc44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83c02e38a3bf8e6d547a292754a581096021b594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83c02e38a3bf8e6d547a292754a581096021b594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83c02e38a3bf8e6d547a292754a581096021b594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83c02e38a3bf8e6d547a292754a581096021b594/comments", "author": null, "committer": null, "parents": [{"sha": "5f8a45f75c9e3785bb7146721910d6ffe4e9d7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f8a45f75c9e3785bb7146721910d6ffe4e9d7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f8a45f75c9e3785bb7146721910d6ffe4e9d7e6"}], "stats": {"total": 1192, "additions": 721, "deletions": 471}, "files": [{"sha": "54488a5d11f1a39c41a61e33b809421a81bd62fb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -1,3 +1,45 @@\n+2003-12-02  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* configure.in: Added new MinGW-specific configure flag\n+\t--with-win32-nlsapi.\n+\tAdded new AC_DEFINE MINGW_LIBGCJ_UNICODE.\n+\tAdd -lunicows to MinGW SYSTEMSPEC if --with-win32-nlsapi\n+\tis set to unicows.\n+\t* configure: Rebuilt.\n+\t* include/config.h.in: Rebuilt.\n+\t* win32.cc (_Jv_Win32NewString): Implemented.\n+\t(nativeToUnicode): New helper function defined only for\n+\tnon-UNICODE builds.\n+\t(unicodeToNative): Likewise.\n+\t(_Jv_Win32TempString): Implemented.\n+\t(lots): Refactored using tchar.h macros.\n+\t(WSAEventWrapper): Use _Jv_Win32NewString.\n+\t(_Jv_platform_initialize): Use GetModuleFileNameA instead\n+\tof GetModuleFileName.\n+\t(_Jv_platform_initProperties): Use _Jv_Win32NewString.\n+\tUse temporary stack buffer instead of a heap buffer.\n+\t* include/win32.h\n+\tAdded defines for UNICODE and _UNICODE if MINGW_LIBGCJ_UNICODE is\n+\tdefined; added tchar.h include.\n+\t(_Jv_Win32TempString): Declared new helper class.\n+\t(JV_TEMP_STRING_WIN32): New helper macro.\n+\t(_Jv_Win32NewString): Declared new helper method.\n+\t* java/io/natFileDescriptorWin32.cc (open): Use\n+\tJV_TEMP_STRING_WIN32 instead of JV_TEMP_UTF_STRING.\n+\t(write): Reformatted slightly.\n+\t* java/io/natFileWin32.cc (lots): Use tchar.h macros;\n+\tuse JV_TEMP_STRING_WIN32 instead of JV_TEMP_UTF_STRING.\n+\t(getCanonicalPath): Use _Jv_Win32NewString instead of\n+\tJvNewStringUTF.\n+\t(performList): Likewise.\n+\t* java/lang/natWin32Process.cc (ChildProcessPipe):\n+\tUse tchar.h macros.\n+\t(startProcess): Use tchar.h macros, JV_TEMP_STRING_WIN32,\n+\tand UNICODE environment flag for CreateProcess.\n+\t* java/net/natNetworkInterfaceWin32.cc\n+\t(winsock2GetRealNetworkInterfaces): Use tchar.h macros and\n+\t_Jv_Win32NewString.\n+\n 2003-12-02  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.c"}, {"sha": "5ca63be3e8aee995ec22cc0e51d151bc33017d1a", "filename": "libjava/configure", "status": "modified", "additions": 385, "deletions": 363, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=83c02e38a3bf8e6d547a292754a581096021b594"}, {"sha": "9dad92c8e10295dfa7a61066c92af595515c2703", "filename": "libjava/configure.in", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -97,6 +97,26 @@ AC_ARG_ENABLE(libgcj-multifile,\n esac],[enable_libgcj_multifile=no])\n AM_CONDITIONAL(ONESTEP, test \"$enable_libgcj_multifile\" = yes)\n \n+# What is the native OS API for MinGW?\n+AC_ARG_WITH(win32-nlsapi,\n+changequote(<<,>>)dnl\n+<<  --with-win32-nlsapi=ansi, unicows or unicode\n+                          native MinGW libgcj Win32 OS API [ansi]>>,\n+changequote([,])\n+[case \"${withval}\" in\n+  ansi) with_win32_nlsapi=ansi ;;\n+  unicows) with_win32_nlsapi=unicows ;;\n+  unicode) with_win32_nlsapi=unicode ;;\n+  *) AC_MSG_ERROR(Bad value ${withval} for --with-win32-nlsapi.) ;;\n+esac],[with_win32_nlsapi=ansi])\n+\n+case \"${with_win32_nlsapi}\" in\n+  unicows | unicode) \n+    AC_DEFINE(MINGW_LIBGCJ_UNICODE, 1,\n+      [Define if MinGW libgcj uses the Windows UNICODE OS API.])\n+    ;;\n+esac\n+\n dnl configure.host sets slow_pthread_self if the synchronization code should \n dnl try to avoid pthread_self calls by caching thread IDs in a hashtable.\n if test \"${slow_pthread_self}\" = \"yes\"; then\n@@ -313,6 +333,9 @@ AC_LINK_FILES(gnu/java/nio/natSelectorImpl${PLATFORM}.cc, gnu/java/nio/natSelect\n case \"${host}\" in\n     *mingw*)\n       SYSTEMSPEC=\"-lgdi32 -lwsock32 -lws2_32\"\n+      if test \"${with_win32_nlsapi}\" = \"unicows\"; then\n+        SYSTEMSPEC=\"-lunicows $SYSTEMSPEC\"\n+      fi\n     ;;\n     *)\n       SYSTEMSPEC="}, {"sha": "8a715f1a770fb89fbdfac4e32dd76190e0655dca", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -272,6 +272,9 @@\n /* Define if we should ignore arguments to main(). */\n #undef DISABLE_MAIN_ARGS\n \n+/* Define if MinGW libgcj uses the Windows UNICODE OS API. */\n+#undef MINGW_LIBGCJ_UNICODE\n+\n /* Define if if the synchronization code should try to avoid pthread_self calls by caching thread IDs in a hashtable. */\n #undef SLOW_PTHREAD_SELF\n "}, {"sha": "3de6f11b9ef5111172e14afee82b2d6eabdff535", "filename": "libjava/include/win32.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Finclude%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Finclude%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32.h?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -11,6 +11,16 @@ details.  */\n #ifndef __JV_WIN32_H__\n #define __JV_WIN32_H__\n \n+// Enable UNICODE Support.?\n+\n+#ifdef MINGW_LIBGCJ_UNICODE\n+#define UNICODE\n+#define _UNICODE\n+#endif // MINGW_LIBGCJ_UNICODE\n+\n+#include <tchar.h>\n+\n+// Includes\n #define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n #undef WIN32_LEAN_AND_MEAN\n@@ -23,6 +33,43 @@ details.  */\n \n #include <io.h>\n \n+/* Begin UNICODE Support Classes and Functions */\n+\n+/* Helper class which creates a temporary, null-terminated,\n+   wide-character C string. */\n+class _Jv_Win32TempString\n+{\n+public:\n+  _Jv_Win32TempString(jstring jstr);\n+  ~_Jv_Win32TempString();\n+\n+// Accessors\n+  operator LPCTSTR() const\n+  {\n+    return buf_;\n+  }\n+  LPCTSTR buf() const\n+  {\n+    return buf_;\n+  }\n+  LPTSTR buf()\n+  {\n+    return buf_;\n+  }\n+\n+private:\n+  TCHAR stackbuf_[500];\n+  LPTSTR buf_;\n+};\n+\n+// Mimics the JV_TEMP_STRING_UTF macro in jvm.h\n+#define JV_TEMP_STRING_WIN32(x,y) _Jv_Win32TempString x(y);\n+\n+// Creates a jstring from a LPCTSTR\n+extern jstring _Jv_Win32NewString (LPCTSTR pcsz);\n+\n+/* End UNICODE Helpers */\n+\n // Prefix and suffix for shared libraries.\n #define _Jv_platform_solib_prefix \"\"\n #define _Jv_platform_solib_suffix \".dll\""}, {"sha": "7811a73f4938c799103d9f93a0b8109e6477702b", "filename": "libjava/java/io/natFileDescriptorWin32.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -87,7 +87,7 @@ java::io::FileDescriptor::open (jstring path, jint jflags) {\n   DWORD access = 0;\n   DWORD create = OPEN_EXISTING;\n   \n-  JV_TEMP_UTF_STRING(cpath, path)\n+  JV_TEMP_STRING_WIN32(cpath, path)\n \n   JvAssert((jflags & READ) || (jflags & WRITE));\n \n@@ -115,7 +115,8 @@ java::io::FileDescriptor::open (jstring path, jint jflags) {\n         create = CREATE_ALWAYS;\n     }\n \n-  handle = CreateFile(cpath, access, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, create, 0, NULL);\n+  handle = CreateFile(cpath, access, FILE_SHARE_READ | FILE_SHARE_WRITE,\n+    NULL, create, 0, NULL);\n \n   if (handle == INVALID_HANDLE_VALUE)\n     {\n@@ -174,13 +175,14 @@ java::io::FileDescriptor::write(jbyteArray b, jint offset, jint len)\n \n   jbyte *buf = elements (b) + offset;\n   DWORD bytesWritten;\n+\n   if (WriteFile ((HANDLE)fd, buf, len, &bytesWritten, NULL))\n     {\n       if (java::lang::Thread::interrupted())\n         {\n           InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n           iioe->bytesTransferred = bytesWritten;\n-    throw iioe;\n+          throw iioe;\n         }\n     }\n   else"}, {"sha": "cff86dda7e92f57b8640f309de6777365f588ccd", "filename": "libjava/java/io/natFileWin32.cc", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileWin32.cc?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -40,7 +40,7 @@ details.  */\n jboolean\n java::io::File::_access (jint query)\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -54,13 +54,14 @@ java::io::File::_access (jint query)\n   if ((query == EXISTS) || (query == READ))\n     return (attributes == 0xffffffff) ? false : true;\n   else\n-    return ((attributes != 0xffffffff) && ((attributes & FILE_ATTRIBUTE_READONLY) == 0)) ? true : false;\n+    return ((attributes != 0xffffffff) &&\n+      ((attributes & FILE_ATTRIBUTE_READONLY) == 0)) ? true : false;\n }\n \n jboolean\n java::io::File::_stat (jint query)\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -79,7 +80,7 @@ java::io::File::_stat (jint query)\n jlong\n java::io::File::attr (jint query)\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -108,21 +109,19 @@ java::io::File::attr (jint query)\n jstring\n java::io::File::getCanonicalPath (void)\n {\n-  JV_TEMP_UTF_STRING (cpath, path);\n+  JV_TEMP_STRING_WIN32 (cpath, path);\n   \n   // If the filename is blank, use the current directory.\n-  const char* thepath = cpath.buf();\n-  if (*thepath == '\\0')\n-    thepath = \".\";\n+  LPCTSTR thepath = cpath.buf();\n+  if (*thepath == 0)\n+    thepath = _T(\".\");\n \n   LPTSTR unused;\n-  char buf2[MAX_PATH];\n+  TCHAR buf2[MAX_PATH];\n   if(!GetFullPathName(thepath, MAX_PATH, buf2, &unused))\n     throw new IOException (JvNewStringLatin1 (\"GetFullPathName failed\"));\n \n-  // FIXME: what encoding to assume for file names?  This affects many\n-  // calls.\n-  return JvNewStringUTF(buf2);\n+  return _Jv_Win32NewString (buf2);\n }\n \n jboolean\n@@ -161,12 +160,17 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n   jstring canon = getCanonicalPath();\n   if (! canon)\n     return NULL;\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 5);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n-  if (buf[total-1] == '\\\\')\n-    strcpy (&buf[total], \"*.*\");\n+\n+  int len = canon->length();\n+  TCHAR buf[len + 5];\n+  \n+  JV_TEMP_STRING_WIN32(canonstr, canon);\n+  \n+  _tcscpy(buf, canonstr);\n+  if (buf[len - 1] == _T('\\\\'))\n+    _tcscpy (&buf[len], _T(\"*.*\"));\n   else\n-    strcpy (&buf[total], \"\\\\*.*\");\n+    _tcscpy (&buf[len], _T(\"\\\\*.*\"));\n \n   WIN32_FIND_DATA data;\n   HANDLE handle = FindFirstFile (buf, &data);\n@@ -177,21 +181,22 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n \n   do\n     {\n-      if (strcmp (data.cFileName, \".\") && strcmp (data.cFileName, \"..\"))\n+      if (_tcscmp (data.cFileName, _T(\".\")) &&\n+        _tcscmp (data.cFileName, _T(\"..\")))\n         {\n-          jstring name = JvNewStringUTF (data.cFileName);\n+          jstring name = _Jv_Win32NewString (data.cFileName);\n \n           if (filter && !filter->accept(this, name))\n-      continue;\n+            continue;\n           if (clazz == &java::io::File::class$)\n-      {\n+            {\n               java::io::File *file = new java::io::File (this, name);\n               if (fileFilter && !fileFilter->accept(file))\n-    continue;\n-        vec->addElement (file);\n-      }\n-    else\n-      vec->addElement (name);\n+                continue;\n+              vec->addElement (file);\n+            }\n+          else\n+            vec->addElement (name);\n         }\n     }\n   while (FindNextFile (handle, &data));\n@@ -209,22 +214,22 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n jboolean\n java::io::File::performMkdir (void)\n {\n-  JV_TEMP_UTF_STRING (cpath, path);\n+  JV_TEMP_STRING_WIN32 (cpath, path);\n   return (CreateDirectory(cpath, NULL)) ? true : false;\n }\n \n jboolean\n java::io::File::performRenameTo (File *dest)\n {\n-  JV_TEMP_UTF_STRING (pathFrom, path);\n-  JV_TEMP_UTF_STRING (pathTo, dest->path);\n+  JV_TEMP_STRING_WIN32 (pathFrom, path);\n+  JV_TEMP_STRING_WIN32 (pathTo, dest->path);\n   return (MoveFile(pathFrom, pathTo)) ? true : false;\n }\n \n jboolean\n java::io::File::performDelete ()\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -240,7 +245,7 @@ java::io::File::performDelete ()\n \n jboolean java::io::File::performCreate (void) \n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -262,7 +267,7 @@ jboolean java::io::File::performCreate (void)\n \n jboolean java::io::File::performSetReadOnly ()\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n \n@@ -280,7 +285,7 @@ jboolean java::io::File::performSetReadOnly ()\n \n jboolean java::io::File::performSetLastModified (jlong time)\n {\n-  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  JV_TEMP_STRING_WIN32 (canon, getCanonicalPath());\n   if (!canon)\n     return false;\n "}, {"sha": "7337ab34969caf63d5c26d80541b8cc64124b0fd", "filename": "libjava/java/lang/natWin32Process.cc", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatWin32Process.cc?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -173,7 +173,7 @@ ChildProcessPipe::ChildProcessPipe(EType eType):\n     {\n       DWORD dwErrorCode = GetLastError ();\n       throw new java::io::IOException (\n-        _Jv_WinStrError (\"Error creating pipe\", dwErrorCode));\n+        _Jv_WinStrError (_T(\"Error creating pipe\"), dwErrorCode));\n     }\n \n   // If this is the read end of the child, we need\n@@ -220,48 +220,53 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n   int cmdLineLen = 0;\n \n   for (int i = 0; i < progarray->length; ++i)\n-    cmdLineLen += (_Jv_GetStringUTFLength (elts[i]) + 1);\n+    cmdLineLen += (elts[i]->length() + 1);\n \n-  char *cmdLine = (char *) _Jv_Malloc (cmdLineLen + 1);\n-  char *cmdLineCurPos = cmdLine;\n+  LPTSTR cmdLine = (LPTSTR) _Jv_Malloc ((cmdLineLen + 1) * sizeof(TCHAR));\n+  LPTSTR cmdLineCurPos = cmdLine;\n \n   for (int i = 0; i < progarray->length; ++i)\n     {\n       if (i > 0)\n-        *cmdLineCurPos++ = ' ';\n-      jsize s = _Jv_GetStringUTFLength (elts[i]);\n-      _Jv_GetStringUTFRegion (elts[i], 0, elts[i]->length(), cmdLineCurPos);\n-      cmdLineCurPos += s;\n+        *cmdLineCurPos++ = _T(' ');\n+        \n+      jint len = elts[i]->length();\n+      JV_TEMP_STRING_WIN32(thiselt, elts[i]);\n+      _tcscpy(cmdLineCurPos, thiselt);\n+      cmdLineCurPos += len;\n     }\n-  *cmdLineCurPos = '\\0';\n+  *cmdLineCurPos = _T('\\0');\n \n   // Get the environment, if any.\n-  char *env = NULL;\n+  LPTSTR env = NULL;\n   if (envp)\n     {\n       elts = elements (envp);\n \n       int envLen = 0;\n       for (int i = 0; i < envp->length; ++i)\n-        envLen += (_Jv_GetStringUTFLength (elts[i]) + 1);\n+        envLen += (elts[i]->length() + 1);\n \n-      env = (char *) _Jv_Malloc (envLen + 1);\n+      env = (LPTSTR) _Jv_Malloc ((envLen + 1) * sizeof(TCHAR));\n \n       int j = 0;\n       for (int i = 0; i < envp->length; ++i)\n         {\n-          jsize s = _Jv_GetStringUTFLength (elts[i]);\n-          _Jv_GetStringUTFRegion (elts[i], 0, elts[i]->length(), (env + j));\n-\n-          j += s;\n-          *(env + j) = '\\0';\n+          jint len = elts[i]->length();\n+          \n+          JV_TEMP_STRING_WIN32(thiselt, elts[i]);\n+          _tcscpy(env + j, thiselt);\n+          \n+          j += len;\n+          \n+          // Skip past the null terminator that _tcscpy just inserted.\n           j++;\n         }\n-      *(env + j) = '\\0';\n+      *(env + j) = _T('\\0');\n     }\n \n   // Get the working directory path, if specified.\n-  JV_TEMP_UTF_STRING (wdir, dir ? dir->getPath () : 0);\n+  JV_TEMP_STRING_WIN32 (wdir, dir ? dir->getPath () : 0);\n \n   errorStream = NULL;\n   inputStream = NULL;\n@@ -304,20 +309,21 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n       // starting a console application; it suppresses the\n       // creation of a console window. This flag is ignored on\n       // Win9X.\n+      \n       if (CreateProcess (NULL,\n                          cmdLine,\n                          NULL,\n                          NULL,\n                          1,\n-                         CREATE_NO_WINDOW,\n+                         CREATE_NO_WINDOW | CREATE_UNICODE_ENVIRONMENT,\n                          env,\n                          wdir,\n                          &si,\n                          &pi) == 0)\n         {\n           DWORD dwErrorCode = GetLastError ();\n           throw new IOException (\n-            _Jv_WinStrError (\"Error creating child process\", dwErrorCode));\n+            _Jv_WinStrError (_T(\"Error creating child process\"), dwErrorCode));\n         }\n \n       procHandle = (jint ) pi.hProcess;"}, {"sha": "d4c2b173f8931177a72ee5f919e4062d3d40d7d8", "filename": "libjava/java/net/natNetworkInterfaceWin32.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -70,18 +70,18 @@ winsock2GetRealNetworkInterfaces (jstring* pjstrName,\n       // have access to the real name under Winsock 2, we use\n       // \"lo\" for the loopback interface and ethX for the\n       // real ones.\n-      char szName[30];\n+      TCHAR szName[30];\n       u_long lFlags = arInterfaceInfo[i].iiFlags;\n \n       if (lFlags & IFF_LOOPBACK)\n-        strcpy (szName, \"lo\");\n+        _tcscpy (szName, _T(\"lo\"));\n       else\n         {\n-          strcpy (szName, \"eth\");\n-          wsprintf(szName+3, \"%d\", nCurETHInterface++);\n+          _tcscpy (szName, _T(\"eth\"));\n+          wsprintf(szName+3, _T(\"%d\"), nCurETHInterface++);\n         }\n \n-      jstring if_name = JvNewStringLatin1 (szName);\n+      jstring if_name = _Jv_Win32NewString (szName);\n       java::net::Inet4Address* address =\n         new java::net::Inet4Address (baddr, JvNewStringLatin1 (\"\"));\n       pjstrName[i] = if_name;"}, {"sha": "ec089a52bd8b64832b0626cb01efb6691ee2edd3", "filename": "libjava/win32.cc", "status": "modified", "additions": 146, "deletions": 46, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fwin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83c02e38a3bf8e6d547a292754a581096021b594/libjava%2Fwin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32.cc?ref=83c02e38a3bf8e6d547a292754a581096021b594", "patch": "@@ -42,6 +42,106 @@ const char *_Jv_ThisExecutable (void)\n \n // Helper classes and methods implementation\n   \n+#ifdef MINGW_LIBGCJ_UNICODE\n+\n+// We're using the OS W (UNICODE) API, which means that we're speaking\n+// the same language....\n+jstring\n+_Jv_Win32NewString (LPCTSTR pcsz)\n+{\n+  return JvNewString ((jchar*) pcsz, _tcslen (pcsz));\n+}\n+\n+#else\n+\n+// We're using the OS A functions, which means we need to translate between\n+// UNICODE and the native character set.\n+\n+// First, let's set up some helper translation functions....\n+\n+// Converts the native string to any specified jstring, returning the\n+// length of the jstring. If the specified jstring is null, we simply\n+// compute and return the length.\n+static int nativeToUnicode(LPCSTR pcsz, jstring jstr = 0)\n+{\n+  jchar* buf = 0;\n+  int len = 0;\n+  if (jstr)\n+    {\n+      len = jstr->length();\n+      buf = JvGetStringChars(jstr);\n+    }\n+  return ::MultiByteToWideChar(GetACP(), 0, pcsz,\n+    strlen(pcsz), (LPWSTR) buf, len);\n+}\n+\n+// Does the inverse of nativeToUnicode, with the same calling semantics.\n+static int unicodeToNative(jstring jstr, LPSTR buf, int buflen)\n+{\n+  return ::WideCharToMultiByte(GetACP(), 0, (LPWSTR) JvGetStringChars(jstr),\n+    jstr->length(), buf, buflen, NULL, NULL);\n+}\n+\n+// Convenience function when the caller only wants to compute the length\n+// of the native string.\n+static int unicodeToNative(jstring jstr)\n+{\n+  return unicodeToNative(jstr, 0, 0);\n+}\n+\n+jstring\n+_Jv_Win32NewString (LPCTSTR pcsz)\n+{\n+  // Compute the length, allocate the jstring, then perform the conversion.\n+  int len = nativeToUnicode(pcsz);\n+  jstring jstr = JvAllocString(len);\n+  nativeToUnicode(pcsz, jstr);\n+  return jstr;\n+}\n+\n+#endif // MINGW_LIBGCJ_UNICODE\n+\n+// class _Jv_Win32TempString\n+_Jv_Win32TempString::_Jv_Win32TempString(jstring jstr):\n+  buf_(0)\n+{\n+  if (jstr == 0)\n+    return;\n+    \n+  // We need space for the string length plus a null terminator.\n+  // Determine whether to use our stack-allocated buffer or a heap-\n+  // allocated one.\n+#ifdef MINGW_LIBGCJ_UNICODE\n+  // A UNICODE character is a UNICODE character is a UNICODE character....\n+  int len = jstr->length();\n+#else\n+  // Compute the length of the native character string.\n+  int len = unicodeToNative(jstr);\n+#endif // MINGW_LIBGCJ_UNICODE\n+\n+  int bytesNeeded = (len + 1) * sizeof(TCHAR);\n+  if (bytesNeeded <= (int) sizeof(stackbuf_))\n+    buf_ = stackbuf_;\n+  else\n+    buf_ = (LPTSTR) _Jv_Malloc(bytesNeeded);\n+    \n+#ifdef MINGW_LIBGCJ_UNICODE\n+  // Copy the UNICODE characters to our buffer.\n+  _tcsncpy(buf_, (LPCTSTR) JvGetStringChars (jstr), len);\n+#else\n+  // Convert the UNICODE string to a native one.\n+  unicodeToNative(jstr, buf_, len);\n+#endif // MINGW_LIBGCJ_UNICODE\n+\n+  buf_[len] = 0;\n+}\n+\n+_Jv_Win32TempString::~_Jv_Win32TempString()\n+{\n+  if (buf_ && buf_ != stackbuf_)\n+    _Jv_Free (buf_);\n+}\n+\n // class WSAEventWrapper\n WSAEventWrapper::WSAEventWrapper (int fd, DWORD dwSelFlags):\n   m_hEvent(0),\n@@ -92,16 +192,17 @@ _Jv_WinStrError (LPCTSTR lpszPrologue, int nErrorCode)\n   if (lpszPrologue)\n     {\n       LPTSTR lpszTemp =\n-        (LPTSTR) _Jv_Malloc (strlen (lpszPrologue) +\n-          strlen (lpMsgBuf) + 3);\n-      strcpy (lpszTemp, lpszPrologue);\n-      strcat (lpszTemp, \": \");\n-      strcat (lpszTemp, lpMsgBuf);\n-      ret = JvNewStringLatin1 (lpszTemp);\n+        (LPTSTR) _Jv_Malloc ((_tcslen (lpszPrologue) +\n+          _tcslen (lpMsgBuf) + 3) * sizeof(TCHAR) );\n+      _tcscpy (lpszTemp, lpszPrologue);\n+      _tcscat (lpszTemp, _T(\": \"));\n+      _tcscat (lpszTemp, lpMsgBuf);\n+      ret = _Jv_Win32NewString (lpszTemp);\n+      _Jv_Free (lpszTemp);\n     } \n   else\n     {\n-      ret = JvNewStringLatin1 (lpMsgBuf);\n+      ret = _Jv_Win32NewString (lpMsgBuf);\n     }\n \n   LocalFree(lpMsgBuf);\n@@ -143,14 +244,17 @@ _Jv_platform_initialize (void)\n   // Initialise winsock for networking\n   WSADATA data;\n   if (WSAStartup (MAKEWORD (1, 1), &data))\n-    MessageBox (NULL, \"Error initialising winsock library.\", \"Error\",\n+    MessageBox (NULL, _T(\"Error initialising winsock library.\"), _T(\"Error\"),\n     MB_OK | MB_ICONEXCLAMATION);\n \n   // Install exception handler\n   SetUnhandledExceptionFilter (win32_exception_handler);\n \n-  // Initialize our executable name\n-  GetModuleFileName(NULL, exec_name, sizeof(exec_name));\n+  // Initialize our executable name.\n+  // FIXME: We unconditionally use the ANSI function because\n+  // _Jv_ThisExecutable returns a const char*. We should really\n+  // change _Jv_ThisExecutable to return a jstring.\n+  GetModuleFileNameA(NULL, exec_name, sizeof(exec_name));\n }\n \n // gettimeofday implementation.\n@@ -177,19 +281,19 @@ __mingwthr_key_dtor (DWORD, void (*) (void *))\n   return 0;\n }\n \n-static bool dirExists (const char* dir)\n+static bool dirExists (LPCTSTR dir)\n {\n   DWORD dwAttrs = ::GetFileAttributes (dir);\n   return dwAttrs != 0xFFFFFFFF &&\n     (dwAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0;\n }\n \n-static void getUserHome(char* userHome, const char* userId)\n+static void getUserHome(LPTSTR userHome, LPCTSTR userId)\n {\n-  char* uh = ::getenv (\"USERPROFILE\");\n+  LPTSTR uh = _tgetenv (_T(\"USERPROFILE\"));\n   if (uh)\n     {\n-      strcpy(userHome, uh);\n+      _tcscpy(userHome, uh);\n     }\n   else\n     {\n@@ -202,15 +306,15 @@ static void getUserHome(char* userHome, const char* userId)\n       // To do this correctly, we'd have to factor in the\n       // Windows version, but if we did that, then this attempt\n       // wouldn't be half-hearted.\n-      char userHomePath[MAX_PATH], winHome[MAX_PATH];\n+      TCHAR userHomePath[MAX_PATH], winHome[MAX_PATH];\n       ::GetWindowsDirectory(winHome, MAX_PATH);\n         // assume this call always succeeds\n \n-      sprintf(userHomePath, \"%s\\\\Profiles\\\\%s\", winHome, userId);\n+      _stprintf(userHomePath, _T(\"%s\\\\Profiles\\\\%s\"), winHome, userId);\n       if (dirExists (userHomePath))\n-        strcpy(userHome, userHomePath);\n+        _tcscpy(userHome, userHomePath);\n       else\n-        strcpy(userHome, winHome);\n+        _tcscpy(userHome, winHome);\n     }\n }\n \n@@ -220,34 +324,32 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n {\n   // A convenience define.\n #define SET(Prop,Val) \\\n-  newprops->put(JvNewStringLatin1 (Prop), JvNewStringLatin1 (Val))\n+  newprops->put(JvNewStringLatin1 (Prop), _Jv_Win32NewString (Val))\n \n-  SET (\"file.separator\", \"\\\\\");\n-  SET (\"path.separator\", \";\");\n-  SET (\"line.separator\", \"\\r\\n\");\n+  SET (\"file.separator\", _T(\"\\\\\"));\n+  SET (\"path.separator\", _T(\";\"));\n+  SET (\"line.separator\", _T(\"\\r\\n\"));\n \n   // Use GetCurrentDirectory to set 'user.dir'.\n   DWORD buflen = MAX_PATH;\n-  char *buffer = (char *) _Jv_MallocUnchecked (buflen);\n+  TCHAR buffer[buflen];\n   if (buffer != NULL)\n     {\n       if (GetCurrentDirectory (buflen, buffer))\n   SET (\"user.dir\", buffer);\n \n       if (GetTempPath (buflen, buffer))\n   SET (\"java.io.tmpdir\", buffer);\n-\n-      _Jv_Free (buffer);\n     }\n \n   // Use GetUserName to set 'user.name'.\n   buflen = 257;  // UNLEN + 1\n-  char userName[buflen];\n+  TCHAR userName[buflen];\n   if (GetUserName (userName, &buflen))\n     SET (\"user.name\", userName);\n \n   // Set user.home\n-  char userHome[MAX_PATH];\n+  TCHAR userHome[MAX_PATH];\n   getUserHome(userHome, userName);\n   SET (\"user.home\", userHome);\n \n@@ -257,41 +359,39 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n   if (GetVersionEx (&osvi))\n     {\n-      char *buffer = (char *) _Jv_MallocUnchecked (30);\n       if (buffer != NULL)\n         {\n-          sprintf (buffer, \"%d.%d\", (int) osvi.dwMajorVersion,\n+          _stprintf (buffer, _T(\"%d.%d\"), (int) osvi.dwMajorVersion,\n            (int) osvi.dwMinorVersion);\n           SET (\"os.version\", buffer);\n-          _Jv_Free (buffer);\n         }\n \n       switch (osvi.dwPlatformId)\n         {\n           case VER_PLATFORM_WIN32_WINDOWS:\n             if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)\n-              SET (\"os.name\", \"Windows 95\");\n+              SET (\"os.name\", _T(\"Windows 95\"));\n             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)\n-              SET (\"os.name\", \"Windows 98\");\n+              SET (\"os.name\", _T(\"Windows 98\"));\n             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)\n-              SET (\"os.name\", \"Windows Me\");\n+              SET (\"os.name\", _T(\"Windows Me\"));\n             else\n-              SET (\"os.name\", \"Windows ??\");\n+              SET (\"os.name\", _T(\"Windows ??\"));\n             break;\n \n           case VER_PLATFORM_WIN32_NT:\n             if (osvi.dwMajorVersion <= 4 )\n-              SET (\"os.name\", \"Windows NT\");\n+              SET (\"os.name\", _T(\"Windows NT\"));\n             else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)\n-              SET (\"os.name\", \"Windows 2000\");\n+              SET (\"os.name\", _T(\"Windows 2000\"));\n             else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)\n-              SET (\"os.name\", \"Windows XP\");\n+              SET (\"os.name\", _T(\"Windows XP\"));\n             else\n-              SET (\"os.name\", \"Windows NT ??\");\n+              SET (\"os.name\", _T(\"Windows NT ??\"));\n             break;\n \n           default:\n-            SET (\"os.name\", \"Windows UNKNOWN\");\n+            SET (\"os.name\", _T(\"Windows UNKNOWN\"));\n             break;\n        }\n   }\n@@ -302,23 +402,23 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n   switch (si.wProcessorArchitecture)\n     {\n       case PROCESSOR_ARCHITECTURE_INTEL:\n-        SET (\"os.arch\", \"x86\");\n+        SET (\"os.arch\", _T(\"x86\"));\n         break;\n       case PROCESSOR_ARCHITECTURE_MIPS:\n-        SET (\"os.arch\", \"mips\");\n+        SET (\"os.arch\", _T(\"mips\"));\n         break;\n       case PROCESSOR_ARCHITECTURE_ALPHA:\n-        SET (\"os.arch\", \"alpha\");\n+        SET (\"os.arch\", _T(\"alpha\"));\n         break;\n-      case PROCESSOR_ARCHITECTURE_PPC:\t\n-        SET (\"os.arch\", \"ppc\");\n+      case PROCESSOR_ARCHITECTURE_PPC:  \n+        SET (\"os.arch\", _T(\"ppc\"));\n         break;\n       case PROCESSOR_ARCHITECTURE_IA64:\n-        SET (\"os.arch\", \"ia64\");\n+        SET (\"os.arch\", _T(\"ia64\"));\n         break;\n       case PROCESSOR_ARCHITECTURE_UNKNOWN:\n       default:\n-        SET (\"os.arch\", \"unknown\");\n+        SET (\"os.arch\", _T(\"unknown\"));\n         break;\n     }\n }"}]}