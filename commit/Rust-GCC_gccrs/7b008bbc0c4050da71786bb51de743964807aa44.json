{"sha": "7b008bbc0c4050da71786bb51de743964807aa44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IwMDhiYmMwYzQwNTBkYTcxNzg2YmI1MWRlNzQzOTY0ODA3YWE0NA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-08-18T07:57:54Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-08-18T07:57:54Z"}, "message": "tree-ssa-loop-niter.c (refine_value_range_using_guard): New.\n\n\n\t* tree-ssa-loop-niter.c (refine_value_range_using_guard): New.\n\t(determine_value_range): Call refine_value_range_using_guard for\n\teach loop initial condition to improve value range.\n\n\tgcc/testsuite/ChangeLog\n\t* gcc.dg/tree-ssa/loop-bound-1.c: New test.\n\t* gcc.dg/tree-ssa/loop-bound-3.c: New test.\n\t* gcc.dg/tree-ssa/loop-bound-5.c: New test.\n\nFrom-SVN: r226966", "tree": {"sha": "d6f1601f6704252de8f77d0872b16cbac314429c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f1601f6704252de8f77d0872b16cbac314429c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b008bbc0c4050da71786bb51de743964807aa44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b008bbc0c4050da71786bb51de743964807aa44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b008bbc0c4050da71786bb51de743964807aa44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b008bbc0c4050da71786bb51de743964807aa44/comments", "author": null, "committer": null, "parents": [{"sha": "991995c4e7ac772b3983a36134b613c23b482275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991995c4e7ac772b3983a36134b613c23b482275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991995c4e7ac772b3983a36134b613c23b482275"}], "stats": {"total": 390, "additions": 368, "deletions": 22}, "files": [{"sha": "3bbbec6e5ba48ebb774079b13780f197d313b6d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -1,3 +1,9 @@\n+2015-08-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-niter.c (refine_value_range_using_guard): New.\n+\t(determine_value_range): Call refine_value_range_using_guard for\n+\teach loop initial condition to improve value range.\n+\n 2015-08-17  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/i386/i386.c: Remove include of fibheap.h."}, {"sha": "c41419120dedaf10a94f3e6b7794d7568087ad84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -1,3 +1,9 @@\n+2015-08-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/loop-bound-1.c: New test.\n+\t* gcc.dg/tree-ssa/loop-bound-3.c: New test.\n+\t* gcc.dg/tree-ssa/loop-bound-5.c: New test.\n+\n 2015-08-17  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* gcc.target/mips/mips.exp (mips-dg-options): Redefine isa"}, {"sha": "aedcac2103adc91eef7687d8b2d8bd3d8f8d7edf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-1.c?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (unsigned char s, unsigned char l)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i < l; i += 1)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 254\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 255\" \"ivopts\" } } */"}, {"sha": "23e2f6a7ecd3fd261891d82673007c5be4572b80", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-3.c?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (unsigned char s, unsigned char l)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i > l; i -= 1)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 254\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 255\" \"ivopts\" } } */"}, {"sha": "d0944374b3176a1f69005e1f573f996445ca3da6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-5.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-5.c?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (unsigned char s)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i > 0; i -= 1)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 254\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 255\" \"ivopts\" } } */"}, {"sha": "d46e6c2a6ff0c0ac7659c2d92ed0eafd0389620d", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 290, "deletions": 22, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b008bbc0c4050da71786bb51de743964807aa44/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=7b008bbc0c4050da71786bb51de743964807aa44", "patch": "@@ -122,13 +122,247 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n     }\n }\n \n+/* From condition C0 CMP C1 derives information regarding the value range\n+   of VAR, which is of TYPE.  Results are stored in to BELOW and UP.  */\n+\n+static void\n+refine_value_range_using_guard (tree type, tree var,\n+\t\t\t\ttree c0, enum tree_code cmp, tree c1,\n+\t\t\t\tmpz_t below, mpz_t up)\n+{\n+  tree varc0, varc1, ctype;\n+  mpz_t offc0, offc1;\n+  mpz_t mint, maxt, minc1, maxc1;\n+  wide_int minv, maxv;\n+  bool no_wrap = nowrap_type_p (type);\n+  bool c0_ok, c1_ok;\n+  signop sgn = TYPE_SIGN (type);\n+\n+  switch (cmp)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      STRIP_SIGN_NOPS (c0);\n+      STRIP_SIGN_NOPS (c1);\n+      ctype = TREE_TYPE (c0);\n+      if (!useless_type_conversion_p (ctype, type))\n+\treturn;\n+\n+      break;\n+\n+    case EQ_EXPR:\n+      /* We could derive quite precise information from EQ_EXPR, however,\n+\t such a guard is unlikely to appear, so we do not bother with\n+\t handling it.  */\n+      return;\n+\n+    case NE_EXPR:\n+      /* NE_EXPR comparisons do not contain much of useful information,\n+\t except for cases of comparing with bounds.  */\n+      if (TREE_CODE (c1) != INTEGER_CST\n+\t  || !INTEGRAL_TYPE_P (type))\n+\treturn;\n+\n+      /* Ensure that the condition speaks about an expression in the same\n+\t type as X and Y.  */\n+      ctype = TREE_TYPE (c0);\n+      if (TYPE_PRECISION (ctype) != TYPE_PRECISION (type))\n+\treturn;\n+      c0 = fold_convert (type, c0);\n+      c1 = fold_convert (type, c1);\n+\n+      if (operand_equal_p (var, c0, 0))\n+\t{\n+\t  mpz_t valc1;\n+\n+\t  /* Case of comparing VAR with its below/up bounds.  */\n+\t  mpz_init (valc1);\n+\t  wi::to_mpz (c1, valc1, TYPE_SIGN (type));\n+\t  if (mpz_cmp (valc1, below) == 0)\n+\t    cmp = GT_EXPR;\n+\t  if (mpz_cmp (valc1, up) == 0)\n+\t    cmp = LT_EXPR;\n+\n+\t  mpz_clear (valc1);\n+\t}\n+      else\n+\t{\n+\t  /* Case of comparing with the bounds of the type.  */\n+\t  wide_int min = wi::min_value (type);\n+\t  wide_int max = wi::max_value (type);\n+\n+\t  if (wi::eq_p (c1, min))\n+\t    cmp = GT_EXPR;\n+\t  if (wi::eq_p (c1, max))\n+\t    cmp = LT_EXPR;\n+\t}\n+\n+      /* Quick return if no useful information.  */\n+      if (cmp == NE_EXPR)\n+\treturn;\n+\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  mpz_init (offc0);\n+  mpz_init (offc1);\n+  split_to_var_and_offset (expand_simple_operations (c0), &varc0, offc0);\n+  split_to_var_and_offset (expand_simple_operations (c1), &varc1, offc1);\n+\n+  /* We are only interested in comparisons of expressions based on VAR.  */\n+  if (operand_equal_p (var, varc1, 0))\n+    {\n+      std::swap (varc0, varc1);\n+      mpz_swap (offc0, offc1);\n+      cmp = swap_tree_comparison (cmp);\n+    }\n+  else if (!operand_equal_p (var, varc0, 0))\n+    {\n+      mpz_clear (offc0);\n+      mpz_clear (offc1);\n+      return;\n+    }\n+\n+  mpz_init (mint);\n+  mpz_init (maxt);\n+  get_type_static_bounds (type, mint, maxt);\n+  mpz_init (minc1);\n+  mpz_init (maxc1);\n+  /* Setup range information for varc1.  */\n+  if (integer_zerop (varc1))\n+    {\n+      wi::to_mpz (integer_zero_node, minc1, TYPE_SIGN (type));\n+      wi::to_mpz (integer_zero_node, maxc1, TYPE_SIGN (type));\n+    }\n+  else if (TREE_CODE (varc1) == SSA_NAME\n+\t   && INTEGRAL_TYPE_P (type)\n+\t   && get_range_info (varc1, &minv, &maxv) == VR_RANGE)\n+    {\n+      gcc_assert (wi::le_p (minv, maxv, sgn));\n+      wi::to_mpz (minv, minc1, sgn);\n+      wi::to_mpz (maxv, maxc1, sgn);\n+    }\n+  else\n+    {\n+      mpz_set (minc1, mint);\n+      mpz_set (maxc1, maxt);\n+    }\n+\n+  /* Compute valid range information for varc1 + offc1.  Note nothing\n+     useful can be derived if it overflows or underflows.  Overflow or\n+     underflow could happen when:\n+\n+       offc1 > 0 && varc1 + offc1 > MAX_VAL (type)\n+       offc1 < 0 && varc1 + offc1 < MIN_VAL (type).  */\n+  mpz_add (minc1, minc1, offc1);\n+  mpz_add (maxc1, maxc1, offc1);\n+  c1_ok = (no_wrap\n+\t   || mpz_sgn (offc1) == 0\n+\t   || (mpz_sgn (offc1) < 0 && mpz_cmp (minc1, mint) >= 0)\n+\t   || (mpz_sgn (offc1) > 0 && mpz_cmp (maxc1, maxt) <= 0));\n+  if (!c1_ok)\n+    goto end;\n+\n+  if (mpz_cmp (minc1, mint) < 0)\n+    mpz_set (minc1, mint);\n+  if (mpz_cmp (maxc1, maxt) > 0)\n+    mpz_set (maxc1, maxt);\n+\n+  if (cmp == LT_EXPR)\n+    {\n+      cmp = LE_EXPR;\n+      mpz_sub_ui (maxc1, maxc1, 1);\n+    }\n+  if (cmp == GT_EXPR)\n+    {\n+      cmp = GE_EXPR;\n+      mpz_add_ui (minc1, minc1, 1);\n+    }\n+\n+  /* Compute range information for varc0.  If there is no overflow,\n+     the condition implied that\n+\n+       (varc0) cmp (varc1 + offc1 - offc0)\n+\n+     We can possibly improve the upper bound of varc0 if cmp is LE_EXPR,\n+     or the below bound if cmp is GE_EXPR.\n+\n+     To prove there is no overflow/underflow, we need to check below\n+     four cases:\n+       1) cmp == LE_EXPR && offc0 > 0\n+\n+\t    (varc0 + offc0) doesn't overflow\n+\t    && (varc1 + offc1 - offc0) doesn't underflow\n+\n+       2) cmp == LE_EXPR && offc0 < 0\n+\n+\t    (varc0 + offc0) doesn't underflow\n+\t    && (varc1 + offc1 - offc0) doesn't overfloe\n+\n+\t  In this case, (varc0 + offc0) will never underflow if we can\n+\t  prove (varc1 + offc1 - offc0) doesn't overflow.\n+\n+       3) cmp == GE_EXPR && offc0 < 0\n+\n+\t    (varc0 + offc0) doesn't underflow\n+\t    && (varc1 + offc1 - offc0) doesn't overflow\n+\n+       4) cmp == GE_EXPR && offc0 > 0\n+\n+\t    (varc0 + offc0) doesn't overflow\n+\t    && (varc1 + offc1 - offc0) doesn't underflow\n+\n+\t  In this case, (varc0 + offc0) will never overflow if we can\n+\t  prove (varc1 + offc1 - offc0) doesn't underflow.\n+\n+     Note we only handle case 2 and 4 in below code.  */\n+\n+  mpz_sub (minc1, minc1, offc0);\n+  mpz_sub (maxc1, maxc1, offc0);\n+  c0_ok = (no_wrap\n+\t   || mpz_sgn (offc0) == 0\n+\t   || (cmp == LE_EXPR\n+\t       && mpz_sgn (offc0) < 0 && mpz_cmp (maxc1, maxt) <= 0)\n+\t   || (cmp == GE_EXPR\n+\t       && mpz_sgn (offc0) > 0 && mpz_cmp (minc1, mint) >= 0));\n+  if (!c0_ok)\n+    goto end;\n+\n+  if (cmp == LE_EXPR)\n+    {\n+      if (mpz_cmp (up, maxc1) > 0)\n+\tmpz_set (up, maxc1);\n+    }\n+  else\n+    {\n+      if (mpz_cmp (below, minc1) < 0)\n+\tmpz_set (below, minc1);\n+    }\n+\n+end:\n+  mpz_clear (mint);\n+  mpz_clear (maxt);\n+  mpz_clear (minc1);\n+  mpz_clear (maxc1);\n+  mpz_clear (offc0);\n+  mpz_clear (offc1);\n+}\n+\n /* Stores estimate on the minimum/maximum value of the expression VAR + OFF\n    in TYPE to MIN and MAX.  */\n \n static void\n determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n \t\t       mpz_t min, mpz_t max)\n {\n+  int cnt = 0;\n+  mpz_t minm, maxm;\n+  basic_block bb;\n   wide_int minv, maxv;\n   enum value_range_type rtype = VR_VARYING;\n \n@@ -183,35 +417,69 @@ determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n \t\t}\n \t    }\n \t}\n-      if (rtype == VR_RANGE)\n+      mpz_init (minm);\n+      mpz_init (maxm);\n+      if (rtype != VR_RANGE)\n+\t{\n+\t  mpz_set (minm, min);\n+\t  mpz_set (maxm, max);\n+\t}\n+      else\n \t{\n-\t  mpz_t minm, maxm;\n \t  gcc_assert (wi::le_p (minv, maxv, sgn));\n-\t  mpz_init (minm);\n-\t  mpz_init (maxm);\n \t  wi::to_mpz (minv, minm, sgn);\n \t  wi::to_mpz (maxv, maxm, sgn);\n-\t  mpz_add (minm, minm, off);\n-\t  mpz_add (maxm, maxm, off);\n-\t  /* If the computation may not wrap or off is zero, then this\n-\t     is always fine.  If off is negative and minv + off isn't\n-\t     smaller than type's minimum, or off is positive and\n-\t     maxv + off isn't bigger than type's maximum, use the more\n-\t     precise range too.  */\n-\t  if (nowrap_type_p (type)\n-\t      || mpz_sgn (off) == 0\n-\t      || (mpz_sgn (off) < 0 && mpz_cmp (minm, min) >= 0)\n-\t      || (mpz_sgn (off) > 0 && mpz_cmp (maxm, max) <= 0))\n-\t    {\n-\t      mpz_set (min, minm);\n-\t      mpz_set (max, maxm);\n-\t      mpz_clear (minm);\n-\t      mpz_clear (maxm);\n-\t      return;\n-\t    }\n+\t}\n+      /* Now walk the dominators of the loop header and use the entry\n+\t guards to refine the estimates.  */\n+      for (bb = loop->header;\n+\t   bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) && cnt < MAX_DOMINATORS_TO_WALK;\n+\t   bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+\t{\n+\t  edge e;\n+\t  tree c0, c1;\n+\t  gimple cond;\n+\t  enum tree_code cmp;\n+\n+\t  if (!single_pred_p (bb))\n+\t    continue;\n+\t  e = single_pred_edge (bb);\n+\n+\t  if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\t    continue;\n+\n+\t  cond = last_stmt (e->src);\n+\t  c0 = gimple_cond_lhs (cond);\n+\t  cmp = gimple_cond_code (cond);\n+\t  c1 = gimple_cond_rhs (cond);\n+\n+\t  if (e->flags & EDGE_FALSE_VALUE)\n+\t    cmp = invert_tree_comparison (cmp, false);\n+\n+\t  refine_value_range_using_guard (type, var, c0, cmp, c1, minm, maxm);\n+\t  ++cnt;\n+\t}\n+\n+      mpz_add (minm, minm, off);\n+      mpz_add (maxm, maxm, off);\n+      /* If the computation may not wrap or off is zero, then this\n+\t is always fine.  If off is negative and minv + off isn't\n+\t smaller than type's minimum, or off is positive and\n+\t maxv + off isn't bigger than type's maximum, use the more\n+\t precise range too.  */\n+      if (nowrap_type_p (type)\n+\t  || mpz_sgn (off) == 0\n+\t  || (mpz_sgn (off) < 0 && mpz_cmp (minm, min) >= 0)\n+\t  || (mpz_sgn (off) > 0 && mpz_cmp (maxm, max) <= 0))\n+\t{\n+\t  mpz_set (min, minm);\n+\t  mpz_set (max, maxm);\n \t  mpz_clear (minm);\n \t  mpz_clear (maxm);\n+\t  return;\n \t}\n+      mpz_clear (minm);\n+      mpz_clear (maxm);\n     }\n \n   /* If the computation may wrap, we know nothing about the value, except for"}]}