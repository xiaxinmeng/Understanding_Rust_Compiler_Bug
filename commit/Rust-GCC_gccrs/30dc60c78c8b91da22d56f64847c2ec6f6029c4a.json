{"sha": "30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkYzYwYzc4YzhiOTFkYTIyZDU2ZjY0ODQ3YzJlYzZmNjAyOWM0YQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-10T14:42:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-10T14:42:17Z"}, "message": "24k.md, [...]: Fix comment typos.\n\n\t* config/mips/24k.md, config/sh/divtab.c, config/sh/sh.c,\n\tconfig/sh/sh.md, config/sh/superh.h: Fix comment typos.\n\t* doc/invoke.texi: Fix typos.\n\nFrom-SVN: r99516", "tree": {"sha": "7020e8e4253afc861fb72ad815818937ee682d47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7020e8e4253afc861fb72ad815818937ee682d47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/comments", "author": null, "committer": null, "parents": [{"sha": "8c9004573aae3886048b090c5c474ed30e0bde36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9004573aae3886048b090c5c474ed30e0bde36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c9004573aae3886048b090c5c474ed30e0bde36"}], "stats": {"total": 36, "additions": 21, "deletions": 15}, "files": [{"sha": "8d97a6c5c94796136b03777a274316ba6018250d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -1,3 +1,9 @@\n+2005-05-10  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/mips/24k.md, config/sh/divtab.c, config/sh/sh.c,\n+\tconfig/sh/sh.md, config/sh/superh.h: Fix comment typos.\n+\t* doc/invoke.texi: Fix typos.\n+\n 2005-05-10  Gabor Loki <loki@gcc.gnu.org>\n \n \tPR c/17913"}, {"sha": "4f6d50f6ad250a9dc39b2c11c195394c9bd3819c", "filename": "gcc/config/mips/24k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fmips%2F24k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fmips%2F24k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F24k.md?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -225,7 +225,7 @@\n ;; These timings are therefore twice the values in the 24K manual,\n ;; which are quoted in fpu clocks.\n ;;\n-;; The 24kx is a 24k configuered with 1:1 cpu and fpu, so use\n+;; The 24kx is a 24k configured with 1:1 cpu and fpu, so use\n ;; the unscaled timings\n \n (define_reservation \"r24k_fpu_iss\"\t\"r24k_iss+(r24k_fpu_arith*2)\")"}, {"sha": "25855c5a612099651ff3f4b7e030147636a54a71", "filename": "gcc/config/sh/divtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fdivtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fdivtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fdivtab.c?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -25,7 +25,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Calculate division table for SH5Media integer division\n-   Contributed by Joern Rernnecke\n+   Contributed by Joern Rennecke\n    joern.rennecke@superh.com  */\n \n #include <stdio.h>"}, {"sha": "18798d12f1ecd1de49079b4ce4343eafa92737d6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -747,7 +747,7 @@ print_operand (FILE *stream, rtx x, int code)\n \t    if (GET_CODE (inner) != REG || GET_MODE_SIZE (inner_mode) > 8)\n \t      abort ();\n \t    /* Floating point register pairs are always big endian;\n-\t       general purpose registes are 64 bit wide.  */\n+\t       general purpose registers are 64 bit wide.  */\n \t    regno = REGNO (inner);\n \t    regno = (HARD_REGNO_NREGS (regno, inner_mode)\n \t\t     - HARD_REGNO_NREGS (regno, mode))\n@@ -10947,10 +10947,10 @@ sh_adjust_unroll_max (struct loop * loop, int insn_count,\n    are to be modified.\n \n    This is like replace_rtx, except that we operate on N_REPLACEMENTS\n-   replacements sumultanously - FROM(n) is replacements[n*2] and to(n) is\n+   replacements simultaneously - FROM(n) is replacements[n*2] and to(n) is\n    replacements[n*2+1] - and that we take mode changes into account.\n \n-   If a replacement is ambigous, return NULL_RTX.\n+   If a replacement is ambiguous, return NULL_RTX.\n \n    If MODIFY is zero, don't modify any rtl in place,\n    just return zero or nonzero for failure / success.  */\n@@ -11177,7 +11177,7 @@ shmedia_prepare_call_address (rtx fnaddr, int is_sibcall)\n   /* If ptabs might trap, make this visible to the rest of the compiler.\n      We generally assume that symbols pertain to valid locations, but\n      it is possible to generate invalid symbols with asm or linker tricks.\n-     In a list of functions where each returns its sucessor, an invalid\n+     In a list of functions where each returns its successor, an invalid\n      symbol might denote an empty list.  */\n   if (!TARGET_PT_FIXED\n       && (!is_sym || TARGET_INVALID_SYMBOLS)"}, {"sha": "f05be16d92d6e59fc1f52a1233a63bb49868022d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -1108,7 +1108,7 @@\n \n   /* We want to replace occurences of operands[0] with operands[1] and\n      operands[2] with operands[0] in operands[4]/operands[5].\n-     Doing just two replace_rtx calls naiively would result in the second\n+     Doing just two replace_rtx calls naively would result in the second\n      replacement undoing all that the first did if operands[1] and operands[2]\n      are identical, so we must do this simultaneously.  */\n   replacements[0] = operands[0];"}, {"sha": "deb71bf7206abcb567ca225c380ff68990643bcc", "filename": "gcc/config/sh/superh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsuperh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fconfig%2Fsh%2Fsuperh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsuperh.h?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -23,7 +23,7 @@ Boston, MA 02111-1307, USA.  */\n    It configures the compiler for SH4 only and switches the default\n    endianess to little (although big endian is still available).\n    It also configures the spec file to the default board configuration\n-   but in such a way that it can be overriden by a boardspecs file\n+   but in such a way that it can be overridden by a boardspecs file\n    (using the -specs= option). This file is expected to disable the\n    defaults and provide options --defsym _start and --defsym _stack\n    which are required by the SuperH configuration of GNU ld.\n@@ -90,7 +90,7 @@ extern const char * boardtype;\n extern const char * osruntime;\n \n \n-/* Override the linker spec strings to use the new emultation\n+/* Override the linker spec strings to use the new emulation\n    The specstrings are concatenated as follows\n    LINK_EMUL_PREFIX.(''|'32'|'64'|LINK_DEFAULT_CPU_EMUL).SUBTARGET_LINK_EMUL_SUFFIX\n */"}, {"sha": "7c2c49e63c3ad3296eb0ffd9f7d9b662291caf08", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc60c78c8b91da22d56f64847c2ec6f6029c4a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=30dc60c78c8b91da22d56f64847c2ec6f6029c4a", "patch": "@@ -11513,11 +11513,11 @@ one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call,\n inv:call2, inv:fp .\n \"fp\" performs the operation in floating point.  This has a very high latency,\n but needs only a few instructions, so it might be a good choice if\n-your code has enough easily esploitable ILP to allow the compiler to\n+your code has enough easily exploitable ILP to allow the compiler to\n schedule the floating point instructions together with other instructions.\n Division by zero causes a floating point exception.\n \"inv\" uses integer operations to calculate the inverse of the divisor,\n-and then multiplies the divident with the inverse.  This strategy allows\n+and then multiplies the dividend with the inverse.  This strategy allows\n cse and hoisting of the inverse calculation.  Division by zero calculates\n an unspecified result, but does not trap.\n \"inv:minlat\" is a variant of \"inv\" where if no cse / hoisting opportunities\n@@ -11534,7 +11534,7 @@ assumes that a pointer to a lookup table has already been set up, which\n exposes the pointer load to cse / code hoisting optimizations.\n \"inv:call\", \"inv:call2\" and \"inv:fp\" all use the \"inv\" algorithm for initial\n code generation, but if the code stays unoptimized, revert to the \"call\",\n-\"call2\", or \"fp\" strategies, resspectively.  Note that the\n+\"call2\", or \"fp\" strategies, respectively.  Note that the\n potentially-trapping side effect of division by zero is carried by a\n separate instruction, so it is possible that all the integer instructions\n are hoisted out, but the marker for the side effect stays where it is.\n@@ -11543,7 +11543,7 @@ A recombination to fp operations or a call is not possible in that case.\n that the inverse calculation was nor separated from the multiply, they speed\n up division where the dividend fits into 20 bits (plus sign where applicable),\n by inserting a test to skip a number of operations in this case; this test\n-slows down the case of larger divdends.  inv20u assumes the case of a such\n+slows down the case of larger dividends.  inv20u assumes the case of a such\n a small dividend to be unlikely, and inv20l assumes it to be likely.\n \n @item -mdivsi3_libfunc=@var{name}\n@@ -11565,7 +11565,7 @@ Enable the use of the indexed addressing mode for SHmedia32/SHcompact.\n This is only safe if the hardware and/or OS implement 32 bit wrap-around\n semantics for the indexed addressing mode.  The architecture allows the\n implementation of processors with 64 bit MMU, which the OS could use to\n-get 32 bit addressing, but since no current harware implementation supports\n+get 32 bit addressing, but since no current hardware implementation supports\n this or any other way to make the indexed addressing mode safe to use in\n the 32 bit ABI, the default is -mno-indexed-addressing.\n \n@@ -11585,7 +11585,7 @@ __do_global_ctors, a part of libgcc that runs constructors at program\n startup, calls functions in a list which is delimited by -1.  With the\n -mpt-fixed option, the ptabs will be done before testing against -1.\n That means that all the constructors will be run a bit quicker, but when\n-the loop comes to the end of the list, the pprogram crashes because ptabs\n+the loop comes to the end of the list, the program crashes because ptabs\n loads -1 into a target register.  Since this option is unsafe for any\n hardware implementing the current architecture specification, the default\n is -mno-pt-fixed.  Unless the user specifies a specific cost with"}]}