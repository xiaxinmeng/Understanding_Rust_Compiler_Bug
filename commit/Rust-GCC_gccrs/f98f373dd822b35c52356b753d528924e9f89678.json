{"sha": "f98f373dd822b35c52356b753d528924e9f89678", "node_id": "C_kwDOANBUbNoAKGY5OGYzNzNkZDgyMmIzNWM1MjM1NmI3NTNkNTI4OTI0ZTlmODk2Nzg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-15T14:19:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-16T10:31:05Z"}, "message": "tree-optimization/102880 - make PHI-OPT recognize more CFGs\n\nThis allows extra edges into the middle BB for the PHI-OPT\ntransforms using replace_phi_edge_with_variable that do not\nend up moving stmts from that middle BB.  This avoids regressing\ngcc.dg/tree-ssa/ssa-hoist-4.c with the actual fix for PR102880\nwhere CFG cleanup has the choice to remove two forwarders and\npicks \"the wrong\" leading to\n\n   if (a > b) /\n       /\\    /\n      /  <BB>\n     /    |\n  # PHI <a, b>\n\nrather than\n\n   if (a > b)  |\n       /\\      |\n    <BB> \\     |\n     /    \\    |\n  # PHI <a, b, b>\n\nbut it's relatively straight-forward to support extra edges\ninto the middle-BB in paths ending in replace_phi_edge_with_variable\nand that do not require moving stmts.  That's because we really\nonly want to remove the edge from the condition to the middle BB.\nOf course actually doing that means updating dominators in non-trival\nways which is why I kept the original code for the single edge\ncase and simply defer to CFG cleanup by adjusting the condition for\nthe complicated case.\n\nThe testcase needs to be a GIMPLE one since it's quite unreliable\nto produce the desired CFG.\n\n2021-11-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102880\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Push\n\tsingle_pred (bb1) condition to places that really need it.\n\t(match_simplify_replacement): Likewise.\n\t(value_replacement): Likewise.\n\t(replace_phi_edge_with_variable): Deal with extra edges\n\tinto the middle BB.\n\n\t* gcc.dg/tree-ssa/phi-opt-26.c: New testcase.", "tree": {"sha": "a84767d9dadd877b6221017c09dd4e461917e46c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84767d9dadd877b6221017c09dd4e461917e46c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f98f373dd822b35c52356b753d528924e9f89678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98f373dd822b35c52356b753d528924e9f89678", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98f373dd822b35c52356b753d528924e9f89678", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98f373dd822b35c52356b753d528924e9f89678/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d699f03720fce57b319276226ac4a463a8538e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d699f03720fce57b319276226ac4a463a8538e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d699f03720fce57b319276226ac4a463a8538e9f"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "21aa66e38b8a4665e04af2c943dcb55450668dc9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-26.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98f373dd822b35c52356b753d528924e9f89678/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98f373dd822b35c52356b753d528924e9f89678/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-26.c?ref=f98f373dd822b35c52356b753d528924e9f89678", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fgimple -fdump-tree-phiopt1\" } */\n+\n+int __GIMPLE (ssa,startwith(\"phiopt\"))\n+foo (int a, int b, int flag)\n+{\n+  int res;\n+\n+  __BB(2):\n+  if (flag_2(D) != 0)\n+    goto __BB6;\n+  else\n+    goto __BB4;\n+\n+  __BB(4):\n+  if (a_3(D) > b_4(D))\n+    goto __BB7;\n+  else\n+    goto __BB6;\n+\n+  __BB(6):\n+  goto __BB7;\n+\n+  __BB(7):\n+  res_1 = __PHI (__BB4: a_3(D), __BB6: b_4(D));\n+  return res_1;\n+}\n+\n+/* We should be able to detect MAX despite the extra edge into\n+   the middle BB.  */\n+/* { dg-final { scan-tree-dump \"MAX\" \"phiopt1\" } } */"}, {"sha": "6b22f6bedd47f2fee92818d16d1b2f2538afd63a", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98f373dd822b35c52356b753d528924e9f89678/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98f373dd822b35c52356b753d528924e9f89678/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f98f373dd822b35c52356b753d528924e9f89678", "patch": "@@ -220,7 +220,6 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \n       /* If either bb1's succ or bb2 or bb2's succ is non NULL.  */\n       if (EDGE_COUNT (bb1->succs) == 0\n-          || bb2 == NULL\n \t  || EDGE_COUNT (bb2->succs) == 0)\n         continue;\n \n@@ -276,14 +275,14 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t  || (e1->flags & EDGE_FALLTHRU) == 0)\n         continue;\n \n-      /* Also make sure that bb1 only have one predecessor and that it\n-\t is bb.  */\n-      if (!single_pred_p (bb1)\n-          || single_pred (bb1) != bb)\n-\tcontinue;\n-\n       if (do_store_elim)\n \t{\n+\t  /* Also make sure that bb1 only have one predecessor and that it\n+\t     is bb.  */\n+\t  if (!single_pred_p (bb1)\n+\t      || single_pred (bb1) != bb)\n+\t    continue;\n+\n \t  /* bb1 is the middle block, bb2 the join block, bb the split block,\n \t     e1 the fallthrough edge from bb1 to bb2.  We can't do the\n \t     optimization if the join block has more than two predecessors.  */\n@@ -328,10 +327,11 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t     node.  */\n \t  gcc_assert (arg0 != NULL_TREE && arg1 != NULL_TREE);\n \n-\t  gphi *newphi = factor_out_conditional_conversion (e1, e2, phi,\n-\t\t\t\t\t\t\t    arg0, arg1,\n-\t\t\t\t\t\t\t    cond_stmt);\n-\t  if (newphi != NULL)\n+\t  gphi *newphi;\n+\t  if (single_pred_p (bb1)\n+\t      && (newphi = factor_out_conditional_conversion (e1, e2, phi,\n+\t\t\t\t\t\t\t      arg0, arg1,\n+\t\t\t\t\t\t\t      cond_stmt)))\n \t    {\n \t      phi = newphi;\n \t      /* factor_out_conditional_conversion may create a new PHI in\n@@ -350,12 +350,14 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t\t\t\t\t       early_p))\n \t    cfgchanged = true;\n \t  else if (!early_p\n+\t\t   && single_pred_p (bb1)\n \t\t   && cond_removal_in_builtin_zero_pattern (bb, bb1, e1, e2,\n \t\t\t\t\t\t\t    phi, arg0, arg1))\n \t    cfgchanged = true;\n \t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (spaceship_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t  else if (single_pred_p (bb1)\n+\t\t   && spaceship_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t}\n     }\n@@ -386,7 +388,6 @@ replace_phi_edge_with_variable (basic_block cond_block,\n \t\t\t\tedge e, gphi *phi, tree new_tree)\n {\n   basic_block bb = gimple_bb (phi);\n-  basic_block block_to_remove;\n   gimple_stmt_iterator gsi;\n   tree phi_result = PHI_RESULT (phi);\n \n@@ -422,28 +423,33 @@ replace_phi_edge_with_variable (basic_block cond_block,\n   SET_USE (PHI_ARG_DEF_PTR (phi, e->dest_idx), new_tree);\n \n   /* Remove the empty basic block.  */\n+  edge edge_to_remove;\n   if (EDGE_SUCC (cond_block, 0)->dest == bb)\n+    edge_to_remove = EDGE_SUCC (cond_block, 1);\n+  else\n+    edge_to_remove = EDGE_SUCC (cond_block, 0);\n+  if (EDGE_COUNT (edge_to_remove->dest->preds) == 1)\n     {\n-      EDGE_SUCC (cond_block, 0)->flags |= EDGE_FALLTHRU;\n-      EDGE_SUCC (cond_block, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      EDGE_SUCC (cond_block, 0)->probability = profile_probability::always ();\n+      e->flags |= EDGE_FALLTHRU;\n+      e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      e->probability = profile_probability::always ();\n+      delete_basic_block (edge_to_remove->dest);\n \n-      block_to_remove = EDGE_SUCC (cond_block, 1)->dest;\n+      /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n+      gsi = gsi_last_bb (cond_block);\n+      gsi_remove (&gsi, true);\n     }\n   else\n     {\n-      EDGE_SUCC (cond_block, 1)->flags |= EDGE_FALLTHRU;\n-      EDGE_SUCC (cond_block, 1)->flags\n-\t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      EDGE_SUCC (cond_block, 1)->probability = profile_probability::always ();\n-\n-      block_to_remove = EDGE_SUCC (cond_block, 0)->dest;\n+      /* If there are other edges into the middle block make\n+\t CFG cleanup deal with the edge removal to avoid\n+\t updating dominators here in a non-trivial way.  */\n+      gcond *cond = as_a <gcond *> (last_stmt (cond_block));\n+      if (edge_to_remove->flags & EDGE_TRUE_VALUE)\n+\tgimple_cond_make_false (cond);\n+      else\n+\tgimple_cond_make_true (cond);\n     }\n-  delete_basic_block (block_to_remove);\n-\n-  /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n-  gsi = gsi_last_bb (cond_block);\n-  gsi_remove (&gsi, true);\n \n   statistics_counter_event (cfun, \"Replace PHI with variable\", 1);\n \n@@ -959,6 +965,9 @@ match_simplify_replacement (basic_block cond_bb, basic_block middle_bb,\n      allow it and move it once the transformation is done. */\n   if (!empty_block_p (middle_bb))\n     {\n+      if (!single_pred_p (middle_bb))\n+\treturn false;\n+\n       stmt_to_move = last_and_only_stmt (middle_bb);\n       if (!stmt_to_move)\n \treturn false;\n@@ -1351,7 +1360,10 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t}\n       else\n \t{\n-\t  statistics_counter_event (cfun, \"Replace PHI with variable/value_replacement\", 1);\n+\t  if (!single_pred_p (middle_bb))\n+\t    return 0;\n+\t  statistics_counter_event (cfun, \"Replace PHI with \"\n+\t\t\t\t    \"variable/value_replacement\", 1);\n \n \t  /* Replace the PHI arguments with arg. */\n \t  SET_PHI_ARG_DEF (phi, e0->dest_idx, arg);\n@@ -1367,7 +1379,6 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n             }\n           return 1;\n \t}\n-\n     }\n \n   /* Now optimize (x != 0) ? x + y : y to just x + y.  */"}]}