{"sha": "11560bcc3526da0ab979df1349f3339068e5345a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE1NjBiY2MzNTI2ZGEwYWI5NzlkZjEzNDlmMzMzOTA2OGU1MzQ1YQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-08-14T08:46:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:46:54Z"}, "message": "sem_ch8.ads, [...] (Find_Type, [...]): Use correct entity as denoted entity for the selector of the rewritten node.\n\n2007-08-14  Thomas Quinot  <quinot@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.ads, sem_ch8.adb (Find_Type, case of a 'Base attribute\n\treference): Use correct entity as denoted entity for the selector of\n\tthe rewritten node.\n\t(Find_Direct_Name): Add comment about Generate_Reference incorrectly\n\tsetting the Referenced_As_LHS flag for entities that are implicitly\n\tdereferenced.\n\t(Find_Type): If the type is an internally generated incomplete type,\n\tmark the full view as referenced, to prevent spurious warnings.\n\t(Find_Selected_Component, Has_Components): Handle properly non-limited\n\tviews that are themselves incomplete types.\n\tHandle interfaces visible through limited-with clauses.\n\t(Analyze_Subprogram_Renaming): Disambiguate and set the entity of a\n\tsubprogram generic actual for which we have generated a renaming.\n\tWarn when the renaming introduces a homonym of\n\tthe renamed entity, and the renamed entity is directly visible.\n\nFrom-SVN: r127446", "tree": {"sha": "77f735f88f5eb732588f171670a357174fca9f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77f735f88f5eb732588f171670a357174fca9f21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11560bcc3526da0ab979df1349f3339068e5345a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11560bcc3526da0ab979df1349f3339068e5345a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11560bcc3526da0ab979df1349f3339068e5345a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11560bcc3526da0ab979df1349f3339068e5345a/comments", "author": null, "committer": null, "parents": [{"sha": "fe685905a168e93878f63b9de28052869f316980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe685905a168e93878f63b9de28052869f316980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe685905a168e93878f63b9de28052869f316980"}], "stats": {"total": 242, "additions": 152, "deletions": 90}, "files": [{"sha": "46349f43c183ec0d03ce4777b16a23839b0b0bc6", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 135, "deletions": 71, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11560bcc3526da0ab979df1349f3339068e5345a/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11560bcc3526da0ab979df1349f3339068e5345a/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=11560bcc3526da0ab979df1349f3339068e5345a", "patch": "@@ -721,7 +721,7 @@ package body Sem_Ch8 is\n             Set_Etype (Nam, T);\n          end if;\n \n-         --  Complete analysis of the subtype mark in any case, for ASIS use.\n+         --  Complete analysis of the subtype mark in any case, for ASIS use\n \n          if Present (Subtype_Mark (N)) then\n             Find_Type (Subtype_Mark (N));\n@@ -759,7 +759,7 @@ package body Sem_Ch8 is\n            and then not Is_Access_Constant (Etype (Nam))\n          then\n             Error_Msg_N (\"(Ada 2005): the renamed object is not \"\n-                         & \"access-to-constant ('R'M 8.5.1(6))\", N);\n+                         & \"access-to-constant (RM 8.5.1(6))\", N);\n          end if;\n       end if;\n \n@@ -872,7 +872,7 @@ package body Sem_Ch8 is\n                      Error_Node);\n                   Error_Msg_Sloc := Sloc (N);\n                   Error_Msg_N\n-                    (\"\\because of renaming at# ('R'M 8.5.4(4))\", Error_Node);\n+                    (\"\\because of renaming # (RM 8.5.4(4))\", Error_Node);\n \n                --  Ada 2005 (AI-423): Otherwise, the subtype of the object name\n                --  shall exclude null.\n@@ -881,7 +881,7 @@ package body Sem_Ch8 is\n                  and then not Has_Null_Exclusion (Subtyp_Decl)\n                then\n                   Error_Msg_N\n-                    (\"`NOT NULL` required for subtype & ('R'M 8.5.1(4.6/2))\",\n+                    (\"`NOT NULL` required for subtype & (RM 8.5.1(4.6/2))\",\n                      Defining_Identifier (Subtyp_Decl));\n                end if;\n             end if;\n@@ -1544,7 +1544,7 @@ package body Sem_Ch8 is\n                         Error_Msg_Sloc := Sloc (Hidden);\n                         Error_Msg_N (\"?default subprogram is resolved \" &\n                                      \"in the generic declaration \" &\n-                                     \"('R'M 12.6(17))\", N);\n+                                     \"(RM 12.6(17))\", N);\n                         Error_Msg_NE (\"\\?and will not use & #\", N, Hidden);\n                      end if;\n                   end;\n@@ -1703,6 +1703,31 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  Find the renamed entity that matches the given specification. Disable\n+      --  Ada_83 because there is no requirement of full conformance between\n+      --  renamed entity and new entity, even though the same circuit is used.\n+\n+      --  This is a bit of a kludge, which introduces a really irregular use of\n+      --  Ada_Version[_Explicit]. Would be nice to find cleaner way to do this\n+      --  ???\n+\n+      Ada_Version := Ada_Version_Type'Max (Ada_Version, Ada_95);\n+      Ada_Version_Explicit := Ada_Version;\n+\n+      if No (Old_S) then\n+         Old_S := Find_Renamed_Entity (N, Name (N), New_S, Is_Actual);\n+\n+         --  When the renamed subprogram is overloaded and used as an actual\n+         --  of a generic, its entity is set to the first available homonym.\n+         --  We must first disambiguate the name, then set the proper entity.\n+\n+         if Is_Actual\n+           and then Is_Overloaded (Nam)\n+         then\n+            Set_Entity (Nam, Old_S);\n+         end if;\n+      end if;\n+\n       --  Most common case: subprogram renames subprogram. No body is generated\n       --  in this case, so we must indicate the declaration is complete as is.\n \n@@ -1712,30 +1737,21 @@ package body Sem_Ch8 is\n          Set_Is_Preelaborated (New_S, Is_Preelaborated (Entity (Nam)));\n \n          --  Ada 2005 (AI-423): Check the consistency of null exclusions\n-         --  between a subprogram and its renaming.\n+         --  between a subprogram and its correct renaming.\n \n-         if Ada_Version >= Ada_05 then\n+         --  Note: the Any_Id check is a guard that prevents compiler crashes\n+         --  when performing a null exclusion check between a renaming and a\n+         --  renamed subprogram that has been found to be illegal.\n+\n+         if Ada_Version >= Ada_05\n+           and then Entity (Nam) /= Any_Id\n+         then\n             Check_Null_Exclusion\n               (Ren => New_S,\n                Sub => Entity (Nam));\n          end if;\n       end if;\n \n-      --  Find the renamed entity that matches the given specification. Disable\n-      --  Ada_83 because there is no requirement of full conformance between\n-      --  renamed entity and new entity, even though the same circuit is used.\n-\n-      --  This is a bit of a kludge, which introduces a really irregular use of\n-      --  Ada_Version[_Explicit]. Would be nice to find cleaner way to do this\n-      --  ???\n-\n-      Ada_Version := Ada_Version_Type'Max (Ada_Version, Ada_95);\n-      Ada_Version_Explicit := Ada_Version;\n-\n-      if No (Old_S) then\n-         Old_S := Find_Renamed_Entity (N, Name (N), New_S, Is_Actual);\n-      end if;\n-\n       if Old_S /= Any_Id then\n          if Is_Actual\n            and then From_Default (N)\n@@ -2035,6 +2051,25 @@ package body Sem_Ch8 is\n              New_S, Old_S);\n       end if;\n \n+      --  Another warning or some utility: if the new subprogram as the same\n+      --  name as the old one, the old one is not hidden by an outer homograph,\n+      --  the new one is not a public symbol, and the old one is otherwise\n+      --  directly visible, the renaming is superfluous.\n+\n+      if Chars (Old_S) = Chars (New_S)\n+        and then Comes_From_Source (N)\n+        and then Scope (Old_S) /= Standard_Standard\n+        and then Warn_On_Redundant_Constructs\n+        and then\n+          (Is_Immediately_Visible (Old_S)\n+            or else Is_Potentially_Use_Visible (Old_S))\n+        and then Is_Overloadable (Current_Scope)\n+        and then Chars (Current_Scope) /= Chars (Old_S)\n+      then\n+         Error_Msg_N\n+          (\"?redundant renaming, entity is directly visible\", Name (N));\n+      end if;\n+\n       Ada_Version := Save_AV;\n       Ada_Version_Explicit := Save_AV_Exp;\n    end Analyze_Subprogram_Renaming;\n@@ -2372,7 +2407,7 @@ package body Sem_Ch8 is\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                    Statements => New_List (\n-                     Make_Return_Statement (Loc,\n+                     Make_Simple_Return_Statement (Loc,\n                        Expression => Attr_Node))));\n \n       --  Case of renaming a procedure\n@@ -3421,11 +3456,11 @@ package body Sem_Ch8 is\n          --  undefined reference.\n \n          if not All_Errors_Mode then\n-            Urefs.Increment_Last;\n-            Urefs.Table (Urefs.Last).Node := N;\n-            Urefs.Table (Urefs.Last).Err  := Emsg;\n-            Urefs.Table (Urefs.Last).Nvis := Nvis;\n-            Urefs.Table (Urefs.Last).Loc  := Sloc (N);\n+            Urefs.Append (\n+              (Node => N,\n+               Err  => Emsg,\n+               Nvis => Nvis,\n+               Loc  => Sloc (N)));\n          end if;\n \n          Msg := True;\n@@ -3804,7 +3839,7 @@ package body Sem_Ch8 is\n          --  to the discriminant in the initialization procedure.\n \n          else\n-            --  Entity is unambiguous, indicate that it is referenced here One\n+            --  Entity is unambiguous, indicate that it is referenced here. One\n             --  slightly odd case is that we do not want to set the Referenced\n             --  flag if the entity is a label, and the identifier is the label\n             --  in the source, since this is not a reference from the point of\n@@ -3819,7 +3854,14 @@ package body Sem_Ch8 is\n                   Set_Referenced (E, R);\n                end;\n \n-            --  Normal case, not a label. Generate reference\n+            --  Normal case, not a label: generate reference\n+\n+            --  ??? It is too early to generate a reference here even if\n+            --    the entity is unambiguous, because the tree is not\n+            --    sufficiently typed at this point for Generate_Reference to\n+            --    determine whether this reference modifies the denoted object\n+            --    (because implicit derefences cannot be identified prior to\n+            --    full type resolution).\n \n             else\n                Generate_Reference (E, N);\n@@ -3938,14 +3980,16 @@ package body Sem_Ch8 is\n             --  the scope, it is important to note that the limited view also\n             --  has shadow entities associated nested packages. For this reason\n             --  the correct scope of the entity is the scope of the real entity\n+            --  The non-limited view may itself be incomplete, in which case\n+            --  get the full view if available.\n \n             elsif From_With_Type (Id)\n               and then Is_Type (Id)\n               and then Ekind (Id) = E_Incomplete_Type\n               and then Present (Non_Limited_View (Id))\n               and then Scope (Non_Limited_View (Id)) = P_Name\n             then\n-               Candidate        := Non_Limited_View (Id);\n+               Candidate        := Get_Full_View (Non_Limited_View (Id));\n                Is_New_Candidate := True;\n \n             else\n@@ -4706,6 +4750,8 @@ package body Sem_Ch8 is\n          then\n             --  Selected component of record. Type checking will validate\n             --  name of selector.\n+            --  ??? could we rewrite an implicit dereference into an explicit\n+            --  one here?\n \n             Analyze_Selected_Component (N);\n \n@@ -4865,7 +4911,7 @@ package body Sem_Ch8 is\n                then\n                   Error_Msg_N\n                     (\"\\dereference must not be of an incomplete type \" &\n-                       \"('R'M 3.10.1)\", P);\n+                       \"(RM 3.10.1)\", P);\n                end if;\n \n             else\n@@ -4899,10 +4945,9 @@ package body Sem_Ch8 is\n \n       elsif Nkind (N) = N_Attribute_Reference then\n \n-         --  Class attribute. This is only valid in Ada 95 mode, but we don't\n-         --  do a check, since the tagged type referenced could only exist if\n-         --  we were in 95 mode when it was declared (or, if we were in Ada\n-         --  83 mode, then an error message would already have been issued).\n+         --  Class attribute. This is not valid in Ada 83 mode, but we do not\n+         --  need to enforce that at this point, since the declaration of the\n+         --  tagged type in the prefix would have been flagged already.\n \n          if Attribute_Name (N) = Name_Class then\n             Check_Restriction (No_Dispatch, N);\n@@ -4918,15 +4963,33 @@ package body Sem_Ch8 is\n \n             T := Base_Type (Entity (Prefix (N)));\n \n-            --  Case type is not known to be tagged. Its appearance in the\n-            --  prefix of the 'Class attribute indicates that the full view\n+            --  Case where type is not known to be tagged. Its appearance in\n+            --  the prefix of the 'Class attribute indicates that the full view\n             --  will be tagged.\n \n             if not Is_Tagged_Type (T) then\n                if Ekind (T) = E_Incomplete_Type then\n \n                   --  It is legal to denote the class type of an incomplete\n                   --  type. The full type will have to be tagged, of course.\n+                  --  In Ada2005 this usage is declared obsolescent, so we\n+                  --  warn accordingly.\n+\n+                  --  ??? This test is temporarily disabled (always False)\n+                  --  because it causes an unwanted warning on GNAT sources\n+                  --  (built with -gnatg, which includes Warn_On_Obsolescent_\n+                  --  Feature). Once this issue is cleared in the sources, it\n+                  --  can be enabled.\n+\n+                  if not Is_Tagged_Type (T)\n+                    and then Ada_Version >= Ada_05\n+                    and then Warn_On_Obsolescent_Feature\n+                    and then False\n+                  then\n+                     Error_Msg_N\n+                       (\"applying 'Class to an untagged imcomplete type\"\n+                         & \" is an obsolescent feature  (RM J.11)\", N);\n+                  end if;\n \n                   Set_Is_Tagged_Type (T);\n                   Set_Primitive_Operations (T, New_Elmt_List);\n@@ -5026,14 +5089,12 @@ package body Sem_Ch8 is\n                if Nkind (Prefix (N)) = N_Expanded_Name then\n                   Rewrite (N,\n                      Make_Expanded_Name (Sloc (N),\n-                       Chars     => Chars (Entity (N)),\n-                       Prefix    => New_Copy (Prefix (Prefix (N))),\n-                       Selector_Name =>\n-                         New_Reference_To (Entity (N), Sloc (N))));\n+                       Chars         => Chars (T),\n+                       Prefix        => New_Copy (Prefix (Prefix (N))),\n+                       Selector_Name => New_Reference_To (T, Sloc (N))));\n \n                else\n-                  Rewrite (N,\n-                    New_Reference_To (Entity (N), Sloc (N)));\n+                  Rewrite (N, New_Reference_To (T, Sloc (N)));\n                end if;\n \n                Set_Entity (N, T);\n@@ -5078,8 +5139,32 @@ package body Sem_Ch8 is\n             Set_Entity (N, Any_Type);\n \n          else\n+            --  If the type is an incomplete type created to handle\n+            --  anonymous access components of a record type, then the\n+            --  incomplete type is the visible entity and subsequent\n+            --  references will point to it. Mark the original full\n+            --  type as referenced, to prevent spurious warnings.\n+\n+            if Is_Incomplete_Type (T_Name)\n+              and then Present (Full_View (T_Name))\n+              and then not Comes_From_Source (T_Name)\n+            then\n+               Set_Referenced (Full_View (T_Name));\n+            end if;\n+\n             T_Name := Get_Full_View (T_Name);\n \n+            --  Ada 2005 (AI-251, AI-50217): Handle interfaces visible through\n+            --  limited-with clauses\n+\n+            if From_With_Type (T_Name)\n+              and then Ekind (T_Name) in Incomplete_Kind\n+              and then Present (Non_Limited_View (T_Name))\n+              and then Is_Interface (Non_Limited_View (T_Name))\n+            then\n+               T_Name := Non_Limited_View (T_Name);\n+            end if;\n+\n             if In_Open_Scopes (T_Name) then\n                if Ekind (Base_Type (T_Name)) = E_Task_Type then\n \n@@ -5141,28 +5226,6 @@ package body Sem_Ch8 is\n       end if;\n    end Find_Type;\n \n-   -------------------\n-   -- Get_Full_View --\n-   -------------------\n-\n-   function Get_Full_View (T_Name : Entity_Id) return Entity_Id is\n-   begin\n-      if Ekind (T_Name) = E_Incomplete_Type\n-        and then Present (Full_View (T_Name))\n-      then\n-         return Full_View (T_Name);\n-\n-      elsif Is_Class_Wide_Type (T_Name)\n-        and then Ekind (Root_Type (T_Name)) = E_Incomplete_Type\n-        and then Present (Full_View (Root_Type (T_Name)))\n-      then\n-         return Class_Wide_Type (Full_View (Root_Type (T_Name)));\n-\n-      else\n-         return T_Name;\n-      end if;\n-   end Get_Full_View;\n-\n    ------------------------------------\n    -- Has_Implicit_Character_Literal --\n    ------------------------------------\n@@ -5608,7 +5671,8 @@ package body Sem_Ch8 is\n            or else (Is_Incomplete_Type (T1)\n                      and then From_With_Type (T1)\n                      and then Present (Non_Limited_View (T1))\n-                     and then Is_Record_Type (Non_Limited_View (T1)));\n+                     and then Is_Record_Type\n+                                (Get_Full_View (Non_Limited_View (T1))));\n       end Has_Components;\n \n    --  Start of processing for Is_Appropriate_For_Record\n@@ -5817,7 +5881,7 @@ package body Sem_Ch8 is\n       end if;\n \n       Scope_Suppress := SST.Save_Scope_Suppress;\n-      Local_Entity_Suppress.Set_Last (SST.Save_Local_Entity_Suppress);\n+      Local_Suppress_Stack_Top := SST.Save_Local_Suppress_Stack_Top;\n \n       if Debug_Flag_W then\n          Write_Str (\"--> exiting scope: \");\n@@ -5886,9 +5950,9 @@ package body Sem_Ch8 is\n          SST : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n \n       begin\n-         SST.Entity                         := S;\n-         SST.Save_Scope_Suppress            := Scope_Suppress;\n-         SST.Save_Local_Entity_Suppress     := Local_Entity_Suppress.Last;\n+         SST.Entity                        := S;\n+         SST.Save_Scope_Suppress           := Scope_Suppress;\n+         SST.Save_Local_Suppress_Stack_Top := Local_Suppress_Stack_Top;\n \n          if Scope_Stack.Last > Scope_Stack.First then\n             SST.Component_Alignment_Default := Scope_Stack.Table"}, {"sha": "0a276561b05d1a25e94eebf15b704df563f64425", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11560bcc3526da0ab979df1349f3339068e5345a/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11560bcc3526da0ab979df1349f3339068e5345a/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=11560bcc3526da0ab979df1349f3339068e5345a", "patch": "@@ -76,15 +76,15 @@ package Sem_Ch8 is\n    --  appearing in context clauses.\n \n    procedure Find_Direct_Name (N : Node_Id);\n-   --  Given a direct name (Identifier or Operator_Symbol), this routine\n-   --  scans the homonym chain for the name searching for corresponding\n-   --  visible entities to find the referenced entity (or in the case of\n-   --  overloading), entities. On return, the Entity, and Etype fields\n-   --  are set. In the non-overloaded case, these are the correct final\n-   --  entries. In the overloaded case, Is_Overloaded is set, Etype and\n-   --  Entity refer to an arbitrary element of the overloads set, and\n-   --  an appropriate list of entries has been made in the overload\n-   --  interpretation table (to be disambiguated in the resolve phase).\n+   --  Given a direct name (Identifier or Operator_Symbol), this routine scans\n+   --  the homonym chain for the name searching for corresponding visible\n+   --  entities to find the referenced entity (or in the case of overloading),\n+   --  entities. On return, the Entity and Etype fields are set. In the\n+   --  non-overloaded case, these are the correct final entries. In the\n+   --  overloaded case, Is_Overloaded is set, Etype and Entity refer to an\n+   --  arbitrary element of the overloads set, and an appropriate list of\n+   --  entries has been made in the overload interpretation table (to be\n+   --  disambiguated in the resolve phase).\n \n    procedure Find_Selected_Component (N : Node_Id);\n    --  Resolve various cases of selected components, recognize expanded names\n@@ -93,16 +93,14 @@ package Sem_Ch8 is\n    --  Perform name resolution, and verify that the name found is that of a\n    --  type. On return the Entity and Etype fields of the node N are set\n    --  appropriately. If it is an incomplete type whose full declaration has\n-   --  been seen, they are set to the entity in the full declaration.\n-   --  Similarly, if the type is private, it has received a full declaration,\n-   --  and we are in the private part or body of the package, then the two\n-   --  fields are set to the entity of the full declaration as well. This\n-   --  procedure also provides special processing for Class types as well.\n-\n-   function Get_Full_View (T_Name : Entity_Id) return Entity_Id;\n-   --  If T_Name is an incomplete type and the full declaration has been\n-   --  seen, or is the name of a class_wide type whose root is incomplete.\n-   --  return the corresponding full declaration.\n+   --  been seen, they are set to the entity in the full declaration. If it\n+   --  is an incomplete type associated with an interface visible through a\n+   --  limited-with clause, whose full declaration has been seen, they are\n+   --  set to the entity in the full declaration. Similarly, if the type is\n+   --  private, it has received a full declaration, and we are in the private\n+   --  part or body of the package, then the two fields are set to the entity\n+   --  of the full declaration as well. This procedure also has special\n+   --  processing for 'Class attribute references.\n \n    procedure Initialize;\n    --  Initializes data structures used for visibility analysis. Must be"}]}