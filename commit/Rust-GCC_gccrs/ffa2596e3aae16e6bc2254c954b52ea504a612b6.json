{"sha": "ffa2596e3aae16e6bc2254c954b52ea504a612b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhMjU5NmUzYWFlMTZlNmJjMjI1NGM5NTRiNTJlYTUwNGE2MTJiNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-03-06T09:01:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-06T09:01:07Z"}, "message": "re PR target/28181 (ICE in reload_cse_simplify_operands, at postreload.c:393 on m68k)\n\ngcc/\n\tPR target/28181\n\t* config/m68k/m68k-protos.h (m68k_secondary_reload_class): Declare.\n\t(m68k_preferred_reload_class): Likewise.\n\t* config/m68k/m68k.h (HARD_REGNO_MODE_OK): Remove duplicated comment.\n\t(SECONDARY_RELOAD_CLASS): Define.\n\t(PREFERRED_RELOAD_CLASS): Use m68k_preferred_reload_class.\n\t(LIMIT_RELOAD_CLASS): Delete.\n\t* config/m68k/m68k.c (m68k_regno_mode_ok): Don't prevent address\n\tregisters from storing bytes.\n\t(m68k_secondary_reload_class): New function.\n\t(m68k_preferred_reload_class): Likewise.\n\ngcc/testsuite/\n\t* gcc.c-torture/compile/m68k-byte-addr.c: New test.\n\nFrom-SVN: r122609", "tree": {"sha": "e7694879133c0b1bb72192801c9bf1826003b890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7694879133c0b1bb72192801c9bf1826003b890"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa2596e3aae16e6bc2254c954b52ea504a612b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa2596e3aae16e6bc2254c954b52ea504a612b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa2596e3aae16e6bc2254c954b52ea504a612b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa2596e3aae16e6bc2254c954b52ea504a612b6/comments", "author": null, "committer": null, "parents": [{"sha": "4f44ecc07f40ad8210c703300224b7e6bed86a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f44ecc07f40ad8210c703300224b7e6bed86a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f44ecc07f40ad8210c703300224b7e6bed86a86"}], "stats": {"total": 149, "additions": 110, "deletions": 39}, "files": [{"sha": "69978a316861c066ece0b457138e273434a99d60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -1,3 +1,17 @@\n+2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR target/28181\n+\t* config/m68k/m68k-protos.h (m68k_secondary_reload_class): Declare.\n+\t(m68k_preferred_reload_class): Likewise.\n+\t* config/m68k/m68k.h (HARD_REGNO_MODE_OK): Remove duplicated comment.\n+\t(SECONDARY_RELOAD_CLASS): Define.\n+\t(PREFERRED_RELOAD_CLASS): Use m68k_preferred_reload_class.\n+\t(LIMIT_RELOAD_CLASS): Delete.\n+\t* config/m68k/m68k.c (m68k_regno_mode_ok): Don't prevent address\n+\tregisters from storing bytes.\n+\t(m68k_secondary_reload_class): New function.\n+\t(m68k_preferred_reload_class): Likewise.\n+\n 2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/m68k/m68k.c (m68k_save_reg): Remove special case for"}, {"sha": "b3b78a15adb99b904a7028c0f9f230aa8f0d0f24", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -69,6 +69,9 @@ extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);\n #endif /* RTX_CODE */\n \n extern bool m68k_regno_mode_ok (int, enum machine_mode);\n+extern enum reg_class m68k_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t   enum machine_mode, rtx);\n+extern enum reg_class m68k_preferred_reload_class (rtx, enum reg_class);\n extern int flags_in_68881 (void);\n extern void m68k_expand_prologue (void);\n extern bool m68k_use_return_insn (void);"}, {"sha": "b702f85e47f49e711014c35a71d881262fe68781", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 64, "deletions": 7, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -4153,9 +4153,10 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n-/* Value is true if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 68000, the cpu registers can hold any mode except bytes in address\n-   registers, but the 68881 registers can hold only SFmode or DFmode.  */\n+/* Value is true if hard register REGNO can hold a value of machine-mode\n+   MODE.  On the 68000, we let the cpu registers can hold any mode, but\n+   restrict the 68881 registers to floating-point modes.  */\n+\n bool\n m68k_regno_mode_ok (int regno, enum machine_mode mode)\n {\n@@ -4167,10 +4168,6 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n     }\n   else if (ADDRESS_REGNO_P (regno))\n     {\n-      /* Address Registers, can't hold bytes, can hold aggregate if\n-\t fits in.  */\n-      if (GET_MODE_SIZE (mode) == 1)\n-\treturn false;\n       if (regno + GET_MODE_SIZE (mode) / 4 <= 16)\n \treturn true;\n     }\n@@ -4186,6 +4183,66 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n   return false;\n }\n \n+/* Implement SECONDARY_RELOAD_CLASS.  */\n+\n+enum reg_class\n+m68k_secondary_reload_class (enum reg_class rclass,\n+\t\t\t     enum machine_mode mode, rtx x)\n+{\n+  int regno;\n+\n+  regno = true_regnum (x);\n+\n+  /* If one operand of a movqi is an address register, the other\n+     operand must be a general register or constant.  Other types\n+     of operand must be reloaded through a data register.  */\n+  if (GET_MODE_SIZE (mode) == 1\n+      && reg_classes_intersect_p (rclass, ADDR_REGS)\n+      && !(INT_REGNO_P (regno) || CONSTANT_P (x)))\n+    return DATA_REGS;\n+\n+  /* PC-relative addresses must be loaded into an address register first.  */\n+  if (TARGET_PCREL\n+      && !reg_class_subset_p (rclass, ADDR_REGS)\n+      && symbolic_operand (x, VOIDmode))\n+    return ADDR_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Implement PREFERRED_RELOAD_CLASS.  */\n+\n+enum reg_class\n+m68k_preferred_reload_class (rtx x, enum reg_class rclass)\n+{\n+  enum reg_class secondary_class;\n+\n+  /* If RCLASS might need a secondary reload, try restricting it to\n+     a class that doesn't.  */\n+  secondary_class = m68k_secondary_reload_class (rclass, GET_MODE (x), x);\n+  if (secondary_class != NO_REGS\n+      && reg_class_subset_p (secondary_class, rclass))\n+    return secondary_class;\n+\n+  /* Prefer to use moveq for in-range constants.  */\n+  if (GET_CODE (x) == CONST_INT\n+      && reg_class_subset_p (DATA_REGS, rclass)\n+      && IN_RANGE (INTVAL (x), -0x80, 0x7f))\n+    return DATA_REGS;\n+\n+  /* ??? Do we really need this now?  */\n+  if (GET_CODE (x) == CONST_DOUBLE\n+      && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    {\n+      if (TARGET_HARD_FLOAT && reg_class_subset_p (FP_REGS, rclass))\n+\treturn FP_REGS;\n+\n+      return NO_REGS;\n+    }\n+\n+  return rclass;\n+}\n+\n /* Return floating point values in a 68881 register.  This makes 68881 code\n    a little bit faster.  It also makes -msoft-float code incompatible with\n    hard-float code, so people have to be careful not to mix the two."}, {"sha": "9d7843d7b94733363dd9a903e5201d83c56bb1f4", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -401,13 +401,12 @@ Boston, MA 02110-1301, USA.  */\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   m68k_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n-/* Value is true if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 68000, the cpu registers can hold any mode except bytes in\n-   address registers, the 68881 registers can hold only SFmode or DFmode.  */\n-\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   m68k_regno_mode_ok ((REGNO), (MODE))\n \n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n+  m68k_secondary_reload_class (CLASS, MODE, X)\n+\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n   (! TARGET_HARD_FLOAT\t\t\t\t\t\\\n    || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n@@ -544,34 +543,8 @@ extern enum reg_class regno_reg_class[];\n    ? const_call_operand (OP, VOIDmode)\t\t\t\\\n    : 0)\n \n-/* On the m68k, use a data reg if possible when the\n-   value is a constant in the range where moveq could be used\n-   and we ensure that QImodes are reloaded into data regs.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n-  ((GET_CODE (X) == CONST_INT\t\t\t\\\n-    && (unsigned) (INTVAL (X) + 0x80) < 0x100\t\\\n-    && (CLASS) != ADDR_REGS)\t\t\t\\\n-   ? DATA_REGS\t\t\t\t\t\\\n-   : (GET_MODE (X) == QImode && (CLASS) != ADDR_REGS) \\\n-   ? DATA_REGS\t\t\t\t\t\\\n-   : (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n-      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\t\\\n-   ? (TARGET_HARD_FLOAT && (CLASS == FP_REGS || CLASS == DATA_OR_FP_REGS) \\\n-      ? FP_REGS : NO_REGS)\t\t\t\t\t\t\\\n-   : (TARGET_PCREL\t\t\t\t\\\n-      && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST \\\n-\t  || GET_CODE (X) == LABEL_REF))\t\\\n-   ? ADDR_REGS\t\t\t\t\t\\\n-   : (CLASS))\n-\n-/* Force QImode output reloads from subregs to be allocated to data regs,\n-   since QImode stores from address regs are not supported.  We make the\n-   assumption that if the class is not ADDR_REGS, then it must be a superset\n-   of DATA_REGS.  */\n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n-  (((MODE) == QImode && (CLASS) != ADDR_REGS)\t\\\n-   ? DATA_REGS\t\t\t\t\t\\\n-   : (CLASS))\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+  m68k_preferred_reload_class (X, CLASS)\n \n /* On the m68k, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */"}, {"sha": "849ec240bfd42f0c7a9dfe1e095f8d349acdb66a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -1,3 +1,7 @@\n+2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.c-torture/compile/m68k-byte-addr.c: New test.\n+\n 2007-03-05  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-convert-4.c: New test."}, {"sha": "88667a461eccc391bc772c868e4409b043c8482e", "filename": "gcc/testsuite/gcc.c-torture/compile/m68k-byte-addr.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fm68k-byte-addr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa2596e3aae16e6bc2254c954b52ea504a612b6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fm68k-byte-addr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fm68k-byte-addr.c?ref=ffa2596e3aae16e6bc2254c954b52ea504a612b6", "patch": "@@ -0,0 +1,20 @@\n+/* This testcase triggered an attempt to reload a byte value into an\n+   address register.  */\n+extern volatile unsigned char x[];\n+\n+#define DECLARE(I) orig##I, inc##I\n+#define READ(I) orig##I = x[I]\n+#define INC(I) inc##I = orig##I + 1\n+#define WRITE1(I) x[I] = orig##I\n+#define WRITE2(I) x[I] = inc##I\n+\n+#define REPEAT(X) X(0), X(1), X(2), X(3), X(4), X(5), X(6), X(7), X(8)\n+\n+void foo (void)\n+{\n+  unsigned char REPEAT (DECLARE);\n+  REPEAT (READ);\n+  REPEAT (INC);\n+  REPEAT (WRITE1);\n+  REPEAT (WRITE2);\n+}"}]}