{"sha": "cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "node_id": "C_kwDOANBUbNoAKGNiNDJjMzY3NGE1YTlhYjc3Y2IwYzEyMTZhMWI3NzZjMzIzMDM3ZTI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-21T17:24:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-21T17:24:27Z"}, "message": "Merge #1144\n\n1144: Add name and type resolution support TuplePatterns in MatchArms r=philberty a=philberty\n\nThis adds support for the name and type resolution of match expressions. The code generation\r\nand checks for all cases possible cases needs more thought so this will be done as part of a\r\nseparate PR.\r\n\r\nAddresses #1081 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "223139b9b80a2c0473cb42c87d7d85fcb33a9f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/223139b9b80a2c0473cb42c87d7d85fcb33a9f84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiYZNLCRBK7hj4Ov3rIwAADBgIACP3r+gupb+qD8GFWLpiLyHO\nKiCvSNRsdKWD93XNkUYKhh1xU0BLsjyVMpEuti/MIjttxhUZKR9c1r5OPV63d5lZ\nZblhumE5uscJhNCRqB5eKR9N8s5UZVHyFImLdpI5eUWamA7vg4cMBQTe8t8TUOO5\nLooMDUDV2yPh9uaS5UTzW9G7t+DUeMQpAQGVOXKO09OvAxj5pBUUh41HA9vfMJC4\naLzG9+VuysPFZp/VRFfeUORvjA14ffq6Q5CQ7ke4Mg/gDzbP2qwB0d0QBza58Amv\nXhSjFxUGHIceyMiJaf1Gd3XwmQxya2674wcVKsT5OSAgYiYJV3PoMfEoRQb/quw=\n=7GSg\n-----END PGP SIGNATURE-----\n", "payload": "tree 223139b9b80a2c0473cb42c87d7d85fcb33a9f84\nparent fc22f12c9c707b258f35a1bab0e8154441b972b8\nparent dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1650561867 +0000\ncommitter GitHub <noreply@github.com> 1650561867 +0000\n\nMerge #1144\n\n1144: Add name and type resolution support TuplePatterns in MatchArms r=philberty a=philberty\n\nThis adds support for the name and type resolution of match expressions. The code generation\r\nand checks for all cases possible cases needs more thought so this will be done as part of a\r\nseparate PR.\r\n\r\nAddresses #1081 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc22f12c9c707b258f35a1bab0e8154441b972b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc22f12c9c707b258f35a1bab0e8154441b972b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc22f12c9c707b258f35a1bab0e8154441b972b8"}, {"sha": "dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5"}], "stats": {"total": 754, "additions": 507, "deletions": 247}, "files": [{"sha": "5c6a7545d7697a3ad00e8b8bd66f3dce7a218472", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -2819,12 +2819,7 @@ StructPattern::as_string () const\n std::string\n LiteralPattern::as_string () const\n {\n-  std::string str;\n-\n-  if (has_minus)\n-    str += \"-\";\n-\n-  return str + lit.as_string ();\n+  return lit.as_string ();\n }\n \n std::string"}, {"sha": "a3193f7958475d83d4760f207e3b5cba3c1f5310", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -27,31 +27,21 @@ namespace AST {\n class LiteralPattern : public Pattern\n {\n   Literal lit;\n-  /* make literal have a type given by enum, etc. rustc uses an extended form of\n-   * its literal token implementation */\n-  // TODO: literal representation - use LiteralExpr? or another thing?\n-\n-  // Minus prefixed to literal (if integer or floating-point)\n-  bool has_minus;\n-  // Actually, this might be a good place to use a template.\n-\n   Location locus;\n   NodeId node_id;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor for a literal pattern\n-  LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n-    : lit (std::move (lit)), has_minus (has_minus), locus (locus),\n+  LiteralPattern (Literal lit, Location locus)\n+    : lit (std::move (lit)), locus (locus),\n       node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n-  LiteralPattern (std::string val, Literal::LitType type, Location locus,\n-\t\t  bool has_minus = false)\n+  LiteralPattern (std::string val, Literal::LitType type, Location locus)\n     : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n-      has_minus (has_minus), locus (locus),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+      locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -62,6 +52,10 @@ class LiteralPattern : public Pattern\n \n   NodeId get_pattern_node_id () const override final { return node_id; }\n \n+  Literal &get_literal () { return lit; }\n+\n+  const Literal &get_literal () const { return lit; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1110,7 +1104,7 @@ class TupleStructPattern : public Pattern\n   TupleStructPattern (TupleStructPattern &&other) = default;\n   TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n \n-  Location get_locus () const { return path.get_locus (); }\n+  Location get_locus () const override { return path.get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1141,6 +1135,12 @@ class TupleStructPattern : public Pattern\n class TuplePatternItems\n {\n public:\n+  enum TuplePatternItemType\n+  {\n+    MULTIPLE,\n+    RANGED,\n+  };\n+\n   virtual ~TuplePatternItems () {}\n \n   // TODO: should this store location data?\n@@ -1156,6 +1156,8 @@ class TuplePatternItems\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual TuplePatternItemType get_pattern_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n@@ -1240,6 +1242,11 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n     return patterns;\n   }\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::MULTIPLE;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1318,6 +1325,11 @@ class TuplePatternItemsRanged : public TuplePatternItems\n     return upper_patterns;\n   }\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::RANGED;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "9d95c3e27e8814fd9c973f523486ccc436c1a4ad", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -183,15 +183,23 @@ class LetStmt : public Stmt\n  * expression) */\n class ExprStmt : public Stmt\n {\n-  // TODO: add any useful virtual functions\n+public:\n+  enum ExprStmtType\n+  {\n+    WITH_BLOCK,\n+    WITHOUT_BLOCK\n+  };\n \n+protected:\n   Location locus;\n \n public:\n   Location get_locus () const override final { return locus; }\n \n   bool is_item () const override final { return false; }\n \n+  virtual ExprStmtType get_type () const = 0;\n+\n protected:\n   ExprStmt (Location locus) : locus (locus) {}\n };\n@@ -261,6 +269,11 @@ class ExprStmtWithoutBlock : public ExprStmt\n     return expr;\n   }\n \n+  ExprStmtType get_type () const override\n+  {\n+    return ExprStmtType::WITHOUT_BLOCK;\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -328,6 +341,8 @@ class ExprStmtWithBlock : public ExprStmt\n \n   bool is_semicolon_followed () const { return semicolon_followed; }\n \n+  ExprStmtType get_type () const override { return ExprStmtType::WITH_BLOCK; };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "28895ba197d0702d4a64be8dc95a6479a0caf4e4", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-pattern.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -885,5 +886,79 @@ ASTLoweringBase::attribute_handled_in_another_pass (\n   return lookup.handler != Analysis::CompilerPass::HIR_LOWERING;\n }\n \n+std::unique_ptr<HIR::TuplePatternItems>\n+ASTLoweringBase::lower_tuple_pattern_multiple (\n+  AST::TuplePatternItemsMultiple &pattern)\n+{\n+  std::vector<std::unique_ptr<HIR::Pattern> > patterns;\n+  for (auto &p : pattern.get_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  return std::unique_ptr<HIR::TuplePatternItems> (\n+    new HIR::TuplePatternItemsMultiple (std::move (patterns)));\n+}\n+\n+std::unique_ptr<TuplePatternItems>\n+ASTLoweringBase::lower_tuple_pattern_ranged (\n+  AST::TuplePatternItemsRanged &pattern)\n+{\n+  std::vector<std::unique_ptr<HIR::Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<HIR::Pattern> > upper_patterns;\n+\n+  for (auto &p : pattern.get_lower_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      lower_patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  for (auto &p : pattern.get_upper_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      upper_patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  return std::unique_ptr<HIR::TuplePatternItems> (\n+    new HIR::TuplePatternItemsRanged (std::move (lower_patterns),\n+\t\t\t\t      std::move (upper_patterns)));\n+}\n+\n+HIR::Literal\n+ASTLoweringBase::lower_literal (const AST::Literal &literal)\n+{\n+  HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n+  switch (literal.get_lit_type ())\n+    {\n+    case AST::Literal::LitType::CHAR:\n+      type = HIR::Literal::LitType::CHAR;\n+      break;\n+    case AST::Literal::LitType::STRING:\n+      type = HIR::Literal::LitType::STRING;\n+      break;\n+    case AST::Literal::LitType::BYTE:\n+      type = HIR::Literal::LitType::BYTE;\n+      break;\n+    case AST::Literal::LitType::BYTE_STRING:\n+      type = HIR::Literal::LitType::BYTE_STRING;\n+      break;\n+    case AST::Literal::LitType::INT:\n+      type = HIR::Literal::LitType::INT;\n+      break;\n+    case AST::Literal::LitType::FLOAT:\n+      type = HIR::Literal::LitType::FLOAT;\n+      break;\n+    case AST::Literal::LitType::BOOL:\n+      type = HIR::Literal::LitType::BOOL;\n+      break;\n+    case AST::Literal::LitType::ERROR:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return HIR::Literal (literal.as_string (), type, literal.get_type_hint ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "33009ae8c2db72c2429185be23ff8d9def163a61", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -272,6 +272,14 @@ class ASTLoweringBase : public AST::ASTVisitor\n \n   bool\n   attribute_handled_in_another_pass (const std::string &attribute_path) const;\n+\n+  std::unique_ptr<TuplePatternItems>\n+  lower_tuple_pattern_multiple (AST::TuplePatternItemsMultiple &pattern);\n+\n+  std::unique_ptr<TuplePatternItems>\n+  lower_tuple_pattern_ranged (AST::TuplePatternItemsRanged &pattern);\n+\n+  HIR::Literal lower_literal (const AST::Literal &literal);\n };\n \n } // namespace HIR"}, {"sha": "5ae538621aa147d4ba3eebd704d063489f39b24a", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -327,43 +327,15 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::LiteralExpr &expr) override\n   {\n-    HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n-    switch (expr.get_lit_type ())\n-      {\n-      case AST::Literal::LitType::CHAR:\n-\ttype = HIR::Literal::LitType::CHAR;\n-\tbreak;\n-      case AST::Literal::LitType::STRING:\n-\ttype = HIR::Literal::LitType::STRING;\n-\tbreak;\n-      case AST::Literal::LitType::BYTE:\n-\ttype = HIR::Literal::LitType::BYTE;\n-\tbreak;\n-      case AST::Literal::LitType::BYTE_STRING:\n-\ttype = HIR::Literal::LitType::BYTE_STRING;\n-\tbreak;\n-      case AST::Literal::LitType::INT:\n-\ttype = HIR::Literal::LitType::INT;\n-\tbreak;\n-      case AST::Literal::LitType::FLOAT:\n-\ttype = HIR::Literal::LitType::FLOAT;\n-\tbreak;\n-      case AST::Literal::LitType::BOOL:\n-\ttype = HIR::Literal::LitType::BOOL;\n-\tbreak;\n-\t// Error literals should have been stripped during expansion\n-      case AST::Literal::LitType::ERROR:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   UNKNOWN_LOCAL_DEFID);\n \n-    translated = new HIR::LiteralExpr (mapping, expr.as_string (), type,\n-\t\t\t\t       expr.get_literal ().get_type_hint (),\n-\t\t\t\t       expr.get_locus ());\n+    HIR::Literal l = lower_literal (expr.get_literal ());\n+    translated\n+      = new HIR::LiteralExpr (mapping, std::move (l), expr.get_locus (),\n+\t\t\t      expr.get_outer_attrs ());\n   }\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr) override"}, {"sha": "957f8cd003b42c76914458df4a4562b3d1eefd68", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -163,5 +163,50 @@ ASTLoweringPattern::visit (AST::WildcardPattern &pattern)\n   translated = new HIR::WildcardPattern (mapping, pattern.get_locus ());\n }\n \n+void\n+ASTLoweringPattern::visit (AST::TuplePattern &pattern)\n+{\n+  std::unique_ptr<HIR::TuplePatternItems> items;\n+  switch (pattern.get_items ()->get_pattern_type ())\n+    {\n+      case AST::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tAST::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<AST::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\titems = lower_tuple_pattern_multiple (ref);\n+      }\n+      break;\n+\n+      case AST::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\tAST::TuplePatternItemsRanged &ref\n+\t  = *static_cast<AST::TuplePatternItemsRanged *> (\n+\t    pattern.get_items ().get ());\n+\titems = lower_tuple_pattern_ranged (ref);\n+      }\n+      break;\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::TuplePattern (mapping, std::move (items), pattern.get_locus ());\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::LiteralPattern &pattern)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Literal l = lower_literal (pattern.get_literal ());\n+  translated\n+    = new HIR::LiteralPattern (mapping, std::move (l), pattern.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "32e9dacbbd427e356699902d8be23c512124d75e", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -58,6 +58,10 @@ class ASTLoweringPattern : public ASTLoweringBase\n \n   void visit (AST::WildcardPattern &pattern) override;\n \n+  void visit (AST::TuplePattern &pattern) override;\n+\n+  void visit (AST::LiteralPattern &pattern) override;\n+\n private:\n   ASTLoweringPattern () : translated (nullptr) {}\n "}, {"sha": "e585dd2a3317e49169ce78802cb0f9beb6fe47b5", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -77,13 +77,13 @@ class LiteralExpr : public ExprWithoutBlock\n \n   LiteralExpr (Analysis::NodeMapping mappings, std::string value_as_string,\n \t       Literal::LitType type, PrimitiveCoreType type_hint,\n-\t       Location locus, AST::AttrVec outer_attrs = AST::AttrVec ())\n+\t       Location locus, AST::AttrVec outer_attrs)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n   LiteralExpr (Analysis::NodeMapping mappings, Literal literal, Location locus,\n-\t       AST::AttrVec outer_attrs = AST::AttrVec ())\n+\t       AST::AttrVec outer_attrs)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       literal (std::move (literal)), locus (locus)\n   {}"}, {"sha": "a53210ba768e82cde34a876c6e389e2c66b48839", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -2589,14 +2589,7 @@ StructPattern::as_string () const\n std::string\n LiteralPattern::as_string () const\n {\n-  std::string str;\n-\n-  if (has_minus)\n-    {\n-      str += \"-\";\n-    }\n-\n-  return str + lit.as_string ();\n+  return lit.as_string ();\n }\n \n std::string"}, {"sha": "880fc3e2e482a290c4faadb25e9807c7e769e5dd", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -29,24 +29,21 @@ namespace HIR {\n class LiteralPattern : public Pattern\n {\n   Literal lit;\n-  bool has_minus;\n   Location locus;\n   Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor for a literal pattern\n-  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus,\n-\t\t  bool has_minus = false)\n-    : lit (std::move (lit)), has_minus (has_minus), locus (locus),\n-      mappings (mappings)\n+  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus)\n+    : lit (std::move (lit)), locus (locus), mappings (mappings)\n   {}\n \n   LiteralPattern (Analysis::NodeMapping mappings, std::string val,\n-\t\t  Literal::LitType type, Location locus, bool has_minus = false)\n+\t\t  Literal::LitType type, Location locus)\n     : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n-      has_minus (has_minus), locus (locus), mappings (mappings)\n+      locus (locus), mappings (mappings)\n   {}\n \n   Location get_locus () const override { return locus; }\n@@ -64,6 +61,9 @@ class LiteralPattern : public Pattern\n     return PatternType::LITERAL;\n   }\n \n+  Literal &get_literal () { return lit; }\n+  const Literal &get_literal () const { return lit; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -962,6 +962,12 @@ class TupleStructPattern : public Pattern\n class TuplePatternItems\n {\n public:\n+  enum TuplePatternItemType\n+  {\n+    MULTIPLE,\n+    RANGED,\n+  };\n+\n   virtual ~TuplePatternItems () {}\n \n   // TODO: should this store location data?\n@@ -977,6 +983,8 @@ class TuplePatternItems\n \n   virtual void accept_vis (HIRFullVisitor &vis) = 0;\n \n+  virtual TuplePatternItemType get_pattern_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n@@ -1019,6 +1027,17 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::MULTIPLE;\n+  }\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1077,6 +1096,11 @@ class TuplePatternItemsRanged : public TuplePatternItems\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::RANGED;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1135,6 +1159,9 @@ class TuplePattern : public Pattern\n     return PatternType::TUPLE;\n   }\n \n+  std::unique_ptr<TuplePatternItems> &get_items () { return items; }\n+  const std::unique_ptr<TuplePatternItems> &get_items () const { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "25979cec56018209b2c47cdb39c87f1270815de7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -8563,7 +8563,11 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n \n-      std::unique_ptr<AST::Expr> expr = parse_expr ();\n+      ParseRestrictions restrictions;\n+      restrictions.expr_can_be_stmt = true;\n+      restrictions.consume_semi = false;\n+\n+      std::unique_ptr<AST::ExprStmt> expr = parse_expr_stmt ({}, restrictions);\n       if (expr == nullptr)\n \t{\n \t  Error error (lexer.peek_token ()->get_locus (),\n@@ -8573,10 +8577,30 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n \t  // skip somewhere?\n \t  return nullptr;\n \t}\n-      bool is_expr_without_block = expr->is_expr_without_block ();\n+      bool is_expr_without_block\n+\t= expr->get_type () == AST::ExprStmt::ExprStmtType::WITHOUT_BLOCK;\n \n       // construct match case expr and add to cases\n-      match_arms.push_back (AST::MatchCase (std::move (arm), std::move (expr)));\n+      switch (expr->get_type ())\n+\t{\n+\t  case AST::ExprStmt::ExprStmtType::WITH_BLOCK: {\n+\t    AST::ExprStmtWithBlock *cast\n+\t      = static_cast<AST::ExprStmtWithBlock *> (expr.get ());\n+\t    std::unique_ptr<AST::Expr> e = cast->get_expr ()->clone_expr ();\n+\t    match_arms.push_back (\n+\t      AST::MatchCase (std::move (arm), std::move (e)));\n+\t  }\n+\t  break;\n+\n+\t  case AST::ExprStmt::ExprStmtType::WITHOUT_BLOCK: {\n+\t    AST::ExprStmtWithoutBlock *cast\n+\t      = static_cast<AST::ExprStmtWithoutBlock *> (expr.get ());\n+\t    std::unique_ptr<AST::Expr> e = cast->get_expr ()->clone_expr ();\n+\t    match_arms.push_back (\n+\t      AST::MatchCase (std::move (arm), std::move (e)));\n+\t  }\n+\t  break;\n+\t}\n \n       // handle comma presence\n       if (lexer.peek_token ()->get_id () != COMMA)\n@@ -10400,7 +10424,7 @@ Parser<ManagedTokenSource>::parse_literal_or_range_pattern ()\n       // literal pattern\n       return std::unique_ptr<AST::LiteralPattern> (\n \tnew AST::LiteralPattern (range_lower->get_str (), type,\n-\t\t\t\t range_lower->get_locus (), has_minus));\n+\t\t\t\t range_lower->get_locus ()));\n     }\n }\n "}, {"sha": "24cd171384db95cedf9b55b350ed84ec61687ce0", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -100,5 +100,35 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n   rust_assert (!struct_pattern_elems.has_etc ());\n }\n \n+void\n+PatternDeclaration::visit (AST::TuplePattern &pattern)\n+{\n+  std::unique_ptr<AST::TuplePatternItems> &items = pattern.get_items ();\n+  switch (items->get_pattern_type ())\n+    {\n+      case AST::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tAST::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<AST::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+\n+      case AST::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\tAST::TuplePatternItemsRanged &ref\n+\t  = *static_cast<AST::TuplePatternItemsRanged *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_lower_patterns ())\n+\t  p->accept_vis (*this);\n+\tfor (auto &p : ref.get_upper_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+    }\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "464e3628768afb3284367fc2b387010341bad6e0", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -101,6 +101,8 @@ class PatternDeclaration : public ResolverBase\n \n   void visit (AST::TupleStructPattern &pattern) override;\n \n+  void visit (AST::TuplePattern &pattern) override;\n+\n private:\n   PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "a924866997994638920f27d6aafefcdefa6c5838", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -80,5 +80,177 @@ TypeCheckBase::check_for_unconstrained (\n   return unconstrained;\n }\n \n+TyTy::BaseType *\n+TypeCheckBase::resolve_literal (const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\tHIR::Literal &literal, Location locus)\n+{\n+  TyTy::BaseType *infered = nullptr;\n+  switch (literal.get_lit_type ())\n+    {\n+      case HIR::Literal::LitType::INT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_I8:\n+\t    ok = context->lookup_builtin (\"i8\", &infered);\n+\t    break;\n+\t  case CORETYPE_I16:\n+\t    ok = context->lookup_builtin (\"i16\", &infered);\n+\t    break;\n+\t  case CORETYPE_I32:\n+\t    ok = context->lookup_builtin (\"i32\", &infered);\n+\t    break;\n+\t  case CORETYPE_I64:\n+\t    ok = context->lookup_builtin (\"i64\", &infered);\n+\t    break;\n+\t  case CORETYPE_I128:\n+\t    ok = context->lookup_builtin (\"i128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_U8:\n+\t    ok = context->lookup_builtin (\"u8\", &infered);\n+\t    break;\n+\t  case CORETYPE_U16:\n+\t    ok = context->lookup_builtin (\"u16\", &infered);\n+\t    break;\n+\t  case CORETYPE_U32:\n+\t    ok = context->lookup_builtin (\"u32\", &infered);\n+\t    break;\n+\t  case CORETYPE_U64:\n+\t    ok = context->lookup_builtin (\"u64\", &infered);\n+\t    break;\n+\t  case CORETYPE_U128:\n+\t    ok = context->lookup_builtin (\"u128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_F32:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::INTEGRAL,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::FLOAT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_F32:\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::FLOAT,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BOOL: {\n+\tauto ok = context->lookup_builtin (\"bool\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::CHAR: {\n+\tauto ok = context->lookup_builtin (\"char\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE: {\n+\tauto ok = context->lookup_builtin (\"u8\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::STRING: {\n+\tTyTy::BaseType *base = nullptr;\n+\tauto ok = context->lookup_builtin (\"str\", &base);\n+\trust_assert (ok);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (base->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE_STRING: {\n+\t/* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n+\t   UTF-8, but really just a byte array. Code to construct the array\n+\t   reference copied from ArrayElemsValues and ArrayType. */\n+\tTyTy::BaseType *u8;\n+\tauto ok = context->lookup_builtin (\"u8\", &u8);\n+\trust_assert (ok);\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t\tmappings->get_next_hir_id (\n+\t\t\t\t\t\t  crate_num),\n+\t\t\t\t\t\tUNKNOWN_LOCAL_DEFID);\n+\n+\t/* Capacity is the size of the string (number of chars).\n+\t   It is a constant, but for fold it to get a tree.  */\n+\tstd::string capacity_str\n+\t  = std::to_string (literal.as_string ().size ());\n+\tHIR::LiteralExpr *literal_capacity\n+\t  = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n+\t\t\t\t  HIR::Literal::LitType::INT,\n+\t\t\t\t  PrimitiveCoreType::CORETYPE_USIZE, locus, {});\n+\n+\t// mark the type for this implicit node\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (capacity_mapping, expected_ty);\n+\n+\tAnalysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t     mappings->get_next_hir_id (\n+\t\t\t\t\t       crate_num),\n+\t\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+\tTyTy::ArrayType *array\n+\t  = new TyTy::ArrayType (array_mapping.get_hirid (), locus,\n+\t\t\t\t *literal_capacity,\n+\t\t\t\t TyTy::TyVar (u8->get_ref ()));\n+\tcontext->insert_type (array_mapping, array);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (array->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return infered;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "159f8261c9e02af545c0b5bad0a19fe9056ff8b3", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -55,6 +55,9 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n     const TyTy::SubstitutionArgumentMappings &constraint_b,\n     const TyTy::BaseType *reference);\n \n+  TyTy::BaseType *resolve_literal (const Analysis::NodeMapping &mappings,\n+\t\t\t\t   HIR::Literal &literal, Location locus);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "d6baff11056dc45322383e4b820e6c000bc8183d", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -57,7 +57,7 @@ class TypeCheckEnumItem : public TypeCheckBase\n       = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n \t\t\t      HIR::Literal::LitType::INT,\n \t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus ());\n+\t\t\t      item.get_locus (), {});\n \n     TyTy::BaseType *isize = nullptr;\n     bool ok = context->lookup_builtin (\"isize\", &isize);\n@@ -135,7 +135,7 @@ class TypeCheckEnumItem : public TypeCheckBase\n       = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n \t\t\t      HIR::Literal::LitType::INT,\n \t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus ());\n+\t\t\t      item.get_locus (), {});\n \n     TyTy::BaseType *isize = nullptr;\n     bool ok = context->lookup_builtin (\"isize\", &isize);\n@@ -182,7 +182,7 @@ class TypeCheckEnumItem : public TypeCheckBase\n       = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n \t\t\t      HIR::Literal::LitType::INT,\n \t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus ());\n+\t\t\t      item.get_locus (), {});\n \n     TyTy::BaseType *isize = nullptr;\n     bool ok = context->lookup_builtin (\"isize\", &isize);"}, {"sha": "5db00a43832c299337528d306fcc643455cbdc97", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 167, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -535,172 +535,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::LiteralExpr &expr) override\n   {\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase HIR::Literal::LitType::INT: {\n-\t  bool ok = false;\n-\n-\t  switch (expr.get_literal ().get_type_hint ())\n-\t    {\n-\t    case CORETYPE_I8:\n-\t      ok = context->lookup_builtin (\"i8\", &infered);\n-\t      break;\n-\t    case CORETYPE_I16:\n-\t      ok = context->lookup_builtin (\"i16\", &infered);\n-\t      break;\n-\t    case CORETYPE_I32:\n-\t      ok = context->lookup_builtin (\"i32\", &infered);\n-\t      break;\n-\t    case CORETYPE_I64:\n-\t      ok = context->lookup_builtin (\"i64\", &infered);\n-\t      break;\n-\t    case CORETYPE_I128:\n-\t      ok = context->lookup_builtin (\"i128\", &infered);\n-\t      break;\n-\n-\t    case CORETYPE_U8:\n-\t      ok = context->lookup_builtin (\"u8\", &infered);\n-\t      break;\n-\t    case CORETYPE_U16:\n-\t      ok = context->lookup_builtin (\"u16\", &infered);\n-\t      break;\n-\t    case CORETYPE_U32:\n-\t      ok = context->lookup_builtin (\"u32\", &infered);\n-\t      break;\n-\t    case CORETYPE_U64:\n-\t      ok = context->lookup_builtin (\"u64\", &infered);\n-\t      break;\n-\t    case CORETYPE_U128:\n-\t      ok = context->lookup_builtin (\"u128\", &infered);\n-\t      break;\n-\n-\t    case CORETYPE_F32:\n-\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n-\t      break;\n-\t    case CORETYPE_F64:\n-\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n-\t      ok = context->lookup_builtin (\"f64\", &infered);\n-\t      break;\n-\n-\t    default:\n-\t      ok = true;\n-\t      infered\n-\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::InferType::InferTypeKind::INTEGRAL,\n-\t\t\t\t       expr.get_locus ());\n-\t      break;\n-\t    }\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::FLOAT: {\n-\t  bool ok = false;\n-\n-\t  switch (expr.get_literal ().get_type_hint ())\n-\t    {\n-\t    case CORETYPE_F32:\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n-\t      break;\n-\t    case CORETYPE_F64:\n-\t      ok = context->lookup_builtin (\"f64\", &infered);\n-\t      break;\n-\n-\t    default:\n-\t      ok = true;\n-\t      infered\n-\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT,\n-\t\t\t\t       expr.get_locus ());\n-\t      break;\n-\t    }\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BOOL: {\n-\t  auto ok = context->lookup_builtin (\"bool\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::CHAR: {\n-\t  auto ok = context->lookup_builtin (\"char\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BYTE: {\n-\t  auto ok = context->lookup_builtin (\"u8\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::STRING: {\n-\t  TyTy::BaseType *base = nullptr;\n-\t  auto ok = context->lookup_builtin (\"str\", &base);\n-\t  rust_assert (ok);\n-\n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (base->get_ref ()),\n-\t\t\t\t\t     Mutability::Imm);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BYTE_STRING: {\n-\t  /* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n-\t     UTF-8, but really just a byte array. Code to construct the array\n-\t     reference copied from ArrayElemsValues and ArrayType. */\n-\t  TyTy::BaseType *u8;\n-\t  auto ok = context->lookup_builtin (\"u8\", &u8);\n-\t  rust_assert (ok);\n-\n-\t  auto crate_num = mappings->get_current_crate ();\n-\t  Analysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t\t  mappings->get_next_hir_id (\n-\t\t\t\t\t\t    crate_num),\n-\t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n-\n-\t  /* Capacity is the size of the string (number of chars).\n-\t     It is a constant, but for fold it to get a tree.  */\n-\t  std::string capacity_str\n-\t    = std::to_string (expr.get_literal ().as_string ().size ());\n-\t  HIR::LiteralExpr *literal_capacity\n-\t    = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n-\t\t\t\t    HIR::Literal::LitType::INT,\n-\t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n-\t\t\t\t    expr.get_locus ());\n-\n-\t  // mark the type for this implicit node\n-\t  TyTy::BaseType *expected_ty = nullptr;\n-\t  ok = context->lookup_builtin (\"usize\", &expected_ty);\n-\t  rust_assert (ok);\n-\t  context->insert_type (capacity_mapping, expected_ty);\n-\n-\t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t       mappings->get_next_hir_id (\n-\t\t\t\t\t\t crate_num),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\t  TyTy::ArrayType *array\n-\t    = new TyTy::ArrayType (array_mapping.get_hirid (),\n-\t\t\t\t   expr.get_locus (), *literal_capacity,\n-\t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n-\t  context->insert_type (array_mapping, array);\n-\n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (array->get_ref ()),\n-\t\t\t\t\t     Mutability::Imm);\n-\t}\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    infered = infered->clone ();\n+    infered = resolve_literal (expr.get_mappings (), expr.get_literal (),\n+\t\t\t       expr.get_locus ());\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n@@ -929,7 +765,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    = new HIR::LiteralExpr (mapping, capacity_str,\n \t\t\t\t    HIR::Literal::LitType::INT,\n \t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n-\t\t\t\t    Location ());\n+\t\t\t\t    Location (), {});\n \n \t  // mark the type for this implicit node\n \t  TyTy::BaseType *expected_ty = nullptr;"}, {"sha": "52d0d479d2915c7408e74079931976f269efcf73", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -232,5 +232,46 @@ TypeCheckPattern::visit (HIR::WildcardPattern &pattern)\n   infered->set_ref (pattern.get_pattern_mappings ().get_hirid ());\n }\n \n+void\n+TypeCheckPattern::visit (HIR::TuplePattern &pattern)\n+{\n+  std::unique_ptr<HIR::TuplePatternItems> items;\n+  switch (pattern.get_items ()->get_pattern_type ())\n+    {\n+      case HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tHIR::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<HIR::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tstd::vector<TyTy::TyVar> pattern_elems;\n+\tfor (auto &p : ref.get_patterns ())\n+\t  {\n+\t    TyTy::BaseType *elem = TypeCheckPattern::Resolve (p.get (), parent);\n+\t    pattern_elems.push_back (TyTy::TyVar (elem->get_ref ()));\n+\t  }\n+\tinfered\n+\t  = new TyTy::TupleType (pattern.get_pattern_mappings ().get_hirid (),\n+\t\t\t\t pattern.get_locus (), pattern_elems);\n+      }\n+      break;\n+\n+      case HIR::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\t// HIR::TuplePatternItemsRanged &ref\n+\t//   = *static_cast<HIR::TuplePatternItemsRanged *> (\n+\t//     pattern.get_items ().get ());\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::LiteralPattern &pattern)\n+{\n+  infered = resolve_literal (pattern.get_pattern_mappings (),\n+\t\t\t     pattern.get_literal (), pattern.get_locus ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "b76c7baa6c3af5f780a9c329f1dfaa8c161b259d", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb42c3674a5a9ab77cb0c1216a1b776c323037e2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=cb42c3674a5a9ab77cb0c1216a1b776c323037e2", "patch": "@@ -39,6 +39,8 @@ class TypeCheckPattern : public TypeCheckBase\n       return new TyTy::ErrorType (\n \tpattern->get_pattern_mappings ().get_hirid ());\n \n+    resolver.context->insert_type (pattern->get_pattern_mappings (),\n+\t\t\t\t   resolver.infered);\n     return resolver.infered;\n   }\n \n@@ -50,13 +52,17 @@ class TypeCheckPattern : public TypeCheckBase\n \n   void visit (HIR::WildcardPattern &pattern) override;\n \n+  void visit (HIR::TuplePattern &pattern) override;\n+\n+  void visit (HIR::LiteralPattern &pattern) override;\n+\n private:\n   TypeCheckPattern (TyTy::BaseType *parent)\n-    : TypeCheckBase (), infered (nullptr), parent (parent)\n+    : TypeCheckBase (), parent (parent), infered (nullptr)\n   {}\n \n-  TyTy::BaseType *infered;\n   TyTy::BaseType *parent;\n+  TyTy::BaseType *infered;\n };\n \n } // namespace Resolver"}]}