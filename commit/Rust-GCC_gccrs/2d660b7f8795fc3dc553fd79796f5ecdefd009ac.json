{"sha": "2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ2NjBiN2Y4Nzk1ZmMzZGM1NTNmZDc5Nzk2ZjVlY2RlZmQwMDlhYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-29T19:29:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-29T19:29:14Z"}, "message": "pt.c (dependent_scope_ref_p): Remove.\n\n\t* pt.c (dependent_scope_ref_p): Remove.\n\t(value_dependent_expression_p): Don't call it.\n\t(type_dependent_expression_p): Here either.\n\t* init.c (build_offset_ref): Set TREE_TYPE on a qualified-id\n\tif the scope isn't dependent.\n\n\t* pt.c (convert_nontype_argument): Use mark_lvalue_use if we want\n\ta reference.\n\nFrom-SVN: r161560", "tree": {"sha": "1cee90d7adcb1a68d03b6523fff76da550dcac0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cee90d7adcb1a68d03b6523fff76da550dcac0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09"}], "stats": {"total": 83, "additions": 41, "deletions": 42}, "files": [{"sha": "0f88f2b6781973aa3ce1b2a9885005dac6c58dd2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "patch": "@@ -1,5 +1,14 @@\n 2010-06-29  Jason Merrill  <jason@redhat.com>\n \n+\t* pt.c (dependent_scope_ref_p): Remove.\n+\t(value_dependent_expression_p): Don't call it.\n+\t(type_dependent_expression_p): Here either.\n+\t* init.c (build_offset_ref): Set TREE_TYPE on a qualified-id\n+\tif the scope isn't dependent.\n+\n+\t* pt.c (convert_nontype_argument): Use mark_lvalue_use if we want\n+\ta reference.\n+\n \tPR c++/44587\n \t* pt.c (has_value_dependent_address): New.\n \t(value_dependent_expression_p): Check it."}, {"sha": "7df57ab9e98a908e5f6944c7cb3a25b509eb6c23", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "patch": "@@ -1508,8 +1508,17 @@ build_offset_ref (tree type, tree member, bool address_p)\n     return member;\n \n   if (dependent_type_p (type) || type_dependent_expression_p (member))\n-    return build_qualified_name (NULL_TREE, type, member,\n-\t\t\t\t /*template_p=*/false);\n+    {\n+      tree ref, mem_type = NULL_TREE;\n+      if (!dependent_scope_p (type))\n+\tmem_type = TREE_TYPE (member);\n+      ref = build_qualified_name (mem_type, type, member,\n+\t\t\t\t  /*template_p=*/false);\n+      /* Undo convert_from_reference.  */\n+      if (TREE_CODE (ref) == INDIRECT_REF)\n+\tref = TREE_OPERAND (ref, 0);\n+      return ref;\n+    }\n \n   gcc_assert (TYPE_P (type));\n   if (! is_class_type (type, 1))"}, {"sha": "e4b57dbfeaffb0e5b4cc476cd4dd547c12c8bfca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d660b7f8795fc3dc553fd79796f5ecdefd009ac/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2d660b7f8795fc3dc553fd79796f5ecdefd009ac", "patch": "@@ -4968,7 +4968,10 @@ convert_nontype_argument (tree type, tree expr)\n   if (error_operand_p (expr))\n     return error_mark_node;\n   expr_type = TREE_TYPE (expr);\n-  expr = mark_rvalue_use (expr);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    expr = mark_lvalue_use (expr);\n+  else\n+    expr = mark_rvalue_use (expr);\n \n   /* HACK: Due to double coercion, we can get a\n      NOP_EXPR<REFERENCE_TYPE>(ADDR_EXPR<POINTER_TYPE> (arg)) here,\n@@ -17517,40 +17520,6 @@ dependent_scope_p (tree scope)\n \t  && !currently_open_class (scope));\n }\n \n-/* Returns TRUE if EXPRESSION is dependent, according to CRITERION.  */\n-\n-static bool\n-dependent_scope_ref_p (tree expression, bool criterion (tree))\n-{\n-  tree scope;\n-  tree name;\n-\n-  gcc_assert (TREE_CODE (expression) == SCOPE_REF);\n-\n-  if (!TYPE_P (TREE_OPERAND (expression, 0)))\n-    return true;\n-\n-  scope = TREE_OPERAND (expression, 0);\n-  name = TREE_OPERAND (expression, 1);\n-\n-  /* [temp.dep.expr]\n-\n-     An id-expression is type-dependent if it contains a\n-     nested-name-specifier that contains a class-name that names a\n-     dependent type.  */\n-  /* The suggested resolution to Core Issue 224 implies that if the\n-     qualifying type is the current class, then we must peek\n-     inside it.  */\n-  if (DECL_P (name)\n-      && currently_open_class (scope)\n-      && !criterion (name))\n-    return false;\n-  if (dependent_type_p (scope))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Returns TRUE if the EXPRESSION is value-dependent, in the sense of\n    [temp.dep.constexpr].  EXPRESSION is already known to be a constant\n    expression.  */\n@@ -17640,7 +17609,10 @@ value_dependent_expression_p (tree expression)\n \t      || value_dependent_expression_p (expression));\n \n     case SCOPE_REF:\n-      return dependent_scope_ref_p (expression, value_dependent_expression_p);\n+      {\n+\ttree name = TREE_OPERAND (expression, 1);\n+\treturn value_dependent_expression_p (name);\n+      }\n \n     case COMPONENT_REF:\n       return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n@@ -17783,10 +17755,19 @@ type_dependent_expression_p (tree expression)\n \treturn dependent_type_p (type);\n     }\n \n-  if (TREE_CODE (expression) == SCOPE_REF\n-      && dependent_scope_ref_p (expression,\n-\t\t\t\ttype_dependent_expression_p))\n-    return true;\n+  if (TREE_CODE (expression) == SCOPE_REF)\n+    {\n+      tree scope = TREE_OPERAND (expression, 0);\n+      tree name = TREE_OPERAND (expression, 1);\n+\n+      /* 14.6.2.2 [temp.dep.expr]: An id-expression is type-dependent if it\n+\t contains an identifier associated by name lookup with one or more\n+\t declarations declared with a dependent type, or...a\n+\t nested-name-specifier or qualified-id that names a member of an\n+\t unknown specialization.  */\n+      return (type_dependent_expression_p (name)\n+\t      || dependent_scope_p (scope));\n+    }\n \n   if (TREE_CODE (expression) == FUNCTION_DECL\n       && DECL_LANG_SPECIFIC (expression)"}]}