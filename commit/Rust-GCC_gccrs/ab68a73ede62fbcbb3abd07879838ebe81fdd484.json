{"sha": "ab68a73ede62fbcbb3abd07879838ebe81fdd484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2OGE3M2VkZTYyZmJjYmIzYWJkMDc4Nzk4MzhlYmU4MWZkZDQ4NA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-03-03T17:34:42Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-03-03T17:34:42Z"}, "message": "re PR fortran/54730 (ICE in gfc_typenode_for_spec, at fortran/trans-types.c:1066)\n\nfortran/\n\tPR fortran/54730\n\t* gfortran.h (struct gfc_undo_change_set): New field 'previous'.\n\t(gfc_new_undo_checkpoint, gfc_drop_last_undo_checkpoint,\n\tgfc_restore_last_undo_checkpoint): New prototypes.\n\t* symbol.c (default_undo_chgset_var): Update initialization.\n\t(single_undo_checkpoint_p, gfc_new_undo_checkpoint,\n\tfree_undo_change_set_data, pop_undo_change_set,\n\tgfc_drop_last_undo_checkpoint, enforce_single_undo_checkpoint):\n\tNew functions.\n\t(save_symbol_data): Handle multiple change sets.  Make sure old_symbol\n\tfield's previous value is not overwritten.  Clear gfc_new field.\n\t(restore_old_symbol): Restore previous old_symbol field.\n\t(gfc_restore_last_undo_checkpoint): New function, using body renamed\n\tfrom gfc_undo_symbols.  Restore the previous change set as current one.\n\t(gfc_undo_symbols): New body.\n\t(gfc_commit_symbols, gfc_commit_symbol, gfc_enforce_clean_symbol_state):\n\tCall enforce_single_undo_checkpoint.\n\t(gfc_symbol_done_2): Ditto.  Free change set data.\n\nFrom-SVN: r196414", "tree": {"sha": "b845cd1c7ec2eb129f2b1ede285390fbfc00a15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b845cd1c7ec2eb129f2b1ede285390fbfc00a15c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab68a73ede62fbcbb3abd07879838ebe81fdd484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab68a73ede62fbcbb3abd07879838ebe81fdd484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab68a73ede62fbcbb3abd07879838ebe81fdd484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab68a73ede62fbcbb3abd07879838ebe81fdd484/comments", "author": null, "committer": null, "parents": [{"sha": "4ef9b950005a24aab3b0ea7da77f16292ef587b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef9b950005a24aab3b0ea7da77f16292ef587b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef9b950005a24aab3b0ea7da77f16292ef587b4"}], "stats": {"total": 193, "additions": 184, "deletions": 9}, "files": [{"sha": "c9b0ca6ce571acb1eb2db131bb4e5b23430ba992", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ab68a73ede62fbcbb3abd07879838ebe81fdd484", "patch": "@@ -1,3 +1,24 @@\n+2013-03-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54730\n+\t* gfortran.h (struct gfc_undo_change_set): New field 'previous'.\n+\t(gfc_new_undo_checkpoint, gfc_drop_last_undo_checkpoint,\n+\tgfc_restore_last_undo_checkpoint): New prototypes.\n+\t* symbol.c (default_undo_chgset_var): Update initialization.\n+\t(single_undo_checkpoint_p, gfc_new_undo_checkpoint,\n+\tfree_undo_change_set_data, pop_undo_change_set,\n+\tgfc_drop_last_undo_checkpoint, enforce_single_undo_checkpoint):\n+\tNew functions.\n+\t(save_symbol_data): Handle multiple change sets.  Make sure old_symbol\n+\tfield's previous value is not overwritten.  Clear gfc_new field.\n+\t(restore_old_symbol): Restore previous old_symbol field.\n+\t(gfc_restore_last_undo_checkpoint): New function, using body renamed\n+\tfrom gfc_undo_symbols.  Restore the previous change set as current one.\n+\t(gfc_undo_symbols): New body.\n+\t(gfc_commit_symbols, gfc_commit_symbol, gfc_enforce_clean_symbol_state):\n+\tCall enforce_single_undo_checkpoint.\n+\t(gfc_symbol_done_2): Ditto.  Free change set data.\n+\n 2013-03-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* symbol.c (restore_old_symbol): Fix thinko."}, {"sha": "18bbf7954c381ef3c39a4dfac42e89d7a82c020d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ab68a73ede62fbcbb3abd07879838ebe81fdd484", "patch": "@@ -1281,6 +1281,7 @@ struct gfc_undo_change_set\n {\n   vec<gfc_symbol *> syms;\n   vec<gfc_typebound_proc *> tbps;\n+  gfc_undo_change_set *previous;\n };\n \n \n@@ -2641,6 +2642,9 @@ int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);\n int gfc_get_ha_symbol (const char *, gfc_symbol **);\n int gfc_get_ha_sym_tree (const char *, gfc_symtree **);\n \n+void gfc_new_undo_checkpoint (gfc_undo_change_set &);\n+void gfc_drop_last_undo_checkpoint (void);\n+void gfc_restore_last_undo_checkpoint (void);\n void gfc_undo_symbols (void);\n void gfc_commit_symbols (void);\n void gfc_commit_symbol (gfc_symbol *);"}, {"sha": "ef4076df3fbcd1818fd45e0fa3fdbde162b31b7c", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 159, "deletions": 9, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab68a73ede62fbcbb3abd07879838ebe81fdd484/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=ab68a73ede62fbcbb3abd07879838ebe81fdd484", "patch": "@@ -99,7 +99,7 @@ gfc_gsymbol *gfc_gsym_root = NULL;\n \n gfc_dt_list *gfc_derived_types;\n \n-static gfc_undo_change_set default_undo_chgset_var = { vNULL, vNULL };\n+static gfc_undo_change_set default_undo_chgset_var = { vNULL, vNULL, NULL };\n static gfc_undo_change_set *latest_undo_chgset = &default_undo_chgset_var;\n \n \n@@ -2698,17 +2698,49 @@ gfc_find_symbol (const char *name, gfc_namespace *ns, int parent_flag,\n }\n \n \n+/* Tells whether there is only one set of changes in the stack.  */\n+\n+static bool\n+single_undo_checkpoint_p (void)\n+{\n+  if (latest_undo_chgset == &default_undo_chgset_var)\n+    {\n+      gcc_assert (latest_undo_chgset->previous == NULL);\n+      return true;\n+    }\n+  else\n+    {\n+      gcc_assert (latest_undo_chgset->previous != NULL);\n+      return false;\n+    }\n+}\n+\n /* Save symbol with the information necessary to back it out.  */\n \n static void\n save_symbol_data (gfc_symbol *sym)\n {\n+  gfc_symbol *s;\n+  unsigned i;\n \n-  if (sym->gfc_new || sym->old_symbol != NULL)\n+  if (!single_undo_checkpoint_p ())\n+    {\n+      /* If there is more than one change set, look for the symbol in the\n+         current one.  If it is found there, we can reuse it.  */\n+      FOR_EACH_VEC_ELT (latest_undo_chgset->syms, i, s)\n+\tif (s == sym)\n+\t  {\n+\t    gcc_assert (sym->gfc_new || sym->old_symbol != NULL);\n+\t    return;\n+\t  }\n+    }\n+  else if (sym->gfc_new || sym->old_symbol != NULL)\n     return;\n \n-  sym->old_symbol = XCNEW (gfc_symbol);\n-  *(sym->old_symbol) = *sym;\n+  s = XCNEW (gfc_symbol);\n+  *s = *sym;\n+  sym->old_symbol = s;\n+  sym->gfc_new = 0;\n \n   latest_undo_chgset->syms.safe_push (sym);\n }\n@@ -2879,6 +2911,22 @@ find_common_symtree (gfc_symtree *st, gfc_common_head *head)\n }\n \n \n+/* Clear the given storage, and make it the current change set for registering\n+   changed symbols.  Its contents are freed after a call to\n+   gfc_restore_last_undo_checkpoint or gfc_drop_last_undo_checkpoint, but\n+   it is up to the caller to free the storage itself.  It is usually a local\n+   variable, so there is nothing to do anyway.  */\n+\n+void\n+gfc_new_undo_checkpoint (gfc_undo_change_set &chg_syms)\n+{\n+  chg_syms.syms = vNULL;\n+  chg_syms.tbps = vNULL;\n+  chg_syms.previous = latest_undo_chgset;\n+  latest_undo_chgset = &chg_syms;\n+}\n+\n+\n /* Restore previous state of symbol.  Just copy simple stuff.  */\n   \n static void\n@@ -2933,17 +2981,88 @@ restore_old_symbol (gfc_symbol *p)\n       p->formal = old->formal;\n     }\n \n-  free (p->old_symbol);\n-  p->old_symbol = NULL;\n+  p->old_symbol = old->old_symbol;\n+  free (old);\n+}\n+\n+\n+/* Frees the internal data of a gfc_undo_change_set structure.  Doesn't free\n+   the structure itself.  */\n+\n+static void\n+free_undo_change_set_data (gfc_undo_change_set &cs)\n+{\n+  cs.syms.release ();\n+  cs.tbps.release ();\n+}\n+\n+\n+/* Given a change set pointer, free its target's contents and update it with\n+   the address of the previous change set.  Note that only the contents are\n+   freed, not the target itself (the contents' container).  It is not a problem\n+   as the latter will be a local variable usually.  */\n+\n+static void\n+pop_undo_change_set (gfc_undo_change_set *&cs)\n+{\n+  free_undo_change_set_data (*cs);\n+  cs = cs->previous;\n+}\n+\n+\n+static void free_old_symbol (gfc_symbol *sym);\n+\n+\n+/* Merges the current change set into the previous one.  The changes themselves\n+   are left untouched; only one checkpoint is forgotten.  */\n+\n+void\n+gfc_drop_last_undo_checkpoint (void)\n+{\n+  gfc_symbol *s, *t;\n+  unsigned i, j;\n+\n+  FOR_EACH_VEC_ELT (latest_undo_chgset->syms, i, s)\n+    {\n+      /* No need to loop in this case.  */\n+      if (s->old_symbol == NULL)\n+        continue;\n+\n+      /* Remove the duplicate symbols.  */\n+      FOR_EACH_VEC_ELT (latest_undo_chgset->previous->syms, j, t)\n+\tif (t == s)\n+\t  {\n+\t    latest_undo_chgset->previous->syms.unordered_remove (j);\n+\n+\t    /* S->OLD_SYMBOL is the backup symbol for S as it was at the\n+\t       last checkpoint.  We drop that checkpoint, so S->OLD_SYMBOL\n+\t       shall contain from now on the backup symbol for S as it was\n+\t       at the checkpoint before.  */\n+\t    if (s->old_symbol->gfc_new)\n+\t      {\n+\t\tgcc_assert (s->old_symbol->old_symbol == NULL);\n+\t\ts->gfc_new = s->old_symbol->gfc_new;\n+\t\tfree_old_symbol (s);\n+\t      }\n+\t    else\n+\t      restore_old_symbol (s->old_symbol);\n+\t    break;\n+\t  }\n+    }\n+\n+  latest_undo_chgset->previous->syms.safe_splice (latest_undo_chgset->syms);\n+  latest_undo_chgset->previous->tbps.safe_splice (latest_undo_chgset->tbps);\n+\n+  pop_undo_change_set (latest_undo_chgset);\n }\n \n \n-/* Undoes all the changes made to symbols in the current statement.\n+/* Undoes all the changes made to symbols since the previous checkpoint.\n    This subroutine is made simpler due to the fact that attributes are\n    never removed once added.  */\n \n void\n-gfc_undo_symbols (void)\n+gfc_restore_last_undo_checkpoint (void)\n {\n   gfc_symbol *p;\n   unsigned i;\n@@ -3011,6 +3130,30 @@ gfc_undo_symbols (void)\n \n   latest_undo_chgset->syms.truncate (0);\n   latest_undo_chgset->tbps.truncate (0);\n+\n+  if (!single_undo_checkpoint_p ())\n+    pop_undo_change_set (latest_undo_chgset);\n+}\n+\n+\n+/* Makes sure that there is only one set of changes; in other words we haven't\n+   forgotten to pair a call to gfc_new_checkpoint with a call to either\n+   gfc_drop_last_undo_checkpoint or gfc_restore_last_undo_checkpoint.  */\n+\n+static void\n+enforce_single_undo_checkpoint (void)\n+{\n+  gcc_checking_assert (single_undo_checkpoint_p ());\n+}\n+\n+\n+/* Undoes all the changes made to symbols in the current statement.  */\n+\n+void\n+gfc_undo_symbols (void)\n+{\n+  enforce_single_undo_checkpoint ();\n+  gfc_restore_last_undo_checkpoint ();\n }\n \n \n@@ -3051,6 +3194,8 @@ gfc_commit_symbols (void)\n   gfc_typebound_proc *tbp;\n   unsigned i;\n \n+  enforce_single_undo_checkpoint ();\n+\n   FOR_EACH_VEC_ELT (latest_undo_chgset->syms, i, p)\n     {\n       p->mark = 0;\n@@ -3074,6 +3219,8 @@ gfc_commit_symbol (gfc_symbol *sym)\n   gfc_symbol *p;\n   unsigned i;\n \n+  enforce_single_undo_checkpoint ();\n+\n   FOR_EACH_VEC_ELT (latest_undo_chgset->syms, i, p)\n     if (p == sym)\n       {\n@@ -3357,10 +3504,12 @@ gfc_symbol_init_2 (void)\n void\n gfc_symbol_done_2 (void)\n {\n-\n   gfc_free_namespace (gfc_current_ns);\n   gfc_current_ns = NULL;\n   gfc_free_dt_list ();\n+\n+  enforce_single_undo_checkpoint ();\n+  free_undo_change_set_data (*latest_undo_chgset);\n }\n \n \n@@ -3525,6 +3674,7 @@ gfc_save_all (gfc_namespace *ns)\n void\n gfc_enforce_clean_symbol_state(void)\n {\n+  enforce_single_undo_checkpoint ();\n   gcc_assert (latest_undo_chgset->syms.is_empty ());\n }\n "}]}