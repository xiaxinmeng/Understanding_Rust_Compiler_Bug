{"sha": "0a2aaacccae56098361e7b602dd823ac2c9a850e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyYWFhY2NjYWU1NjA5ODM2MWU3YjYwMmRkODIzYWMyYzlhODUwZQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-08-06T16:12:51Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-08-06T16:12:51Z"}, "message": "alpha.c (alpha_preferred_reload_class, [...]): Avoid C++ keywords.\n\n\t* config/alpha/alpha.c (alpha_preferred_reload_class,\n\talpha_secondary_reload, alpha_emit_set_const_1, function_value,\n\talpha_output_mi_thunk_osf): Avoid C++ keywords.\n\t* config/arm/arm.c (output_move_vfp, output_move_neon): Likewise.\n\t* config/arm/arm.md: Likewise.\n\t* config/avr/avr-protos.h (preferred_reload_class,\n\ttest_hard_reg_class, avr_simplify_comparison_p,\n\tout_shift_with_cnt, class_max_nregs): Likewise.\n\t* config/avr/avr.c (class_max_nregs, avr_simplify_comparison_p,\n\toutput_movqi, output_movhi, output_movsisf, out_shift_with_cnt,\n\tpreferred_reload_class, test_hard_reg_class): Likewise.\n\t* config/bfin/bfin.c (legitimize_pic_address, hard_regno_mode_ok,\n\tbfin_memory_move_cost, bfin_secondary_reload,\n\tbfin_output_mi_thunk): Likewise.\n\t* config/crx/crx.c (crx_secondary_reload_class,\n\tcrx_memory_move_cost): Likewise.\n\t* config/frv/frv-protos.h (frv_secondary_reload_class,\n\tfrv_class_likely_spilled_p, frv_class_max_nregs): Likewise.\n\t* config/frv/frv.c (frv_override_options, frv_alloc_temp_reg,\n\tfrv_secondary_reload_class, frv_class_likely_spilled_p,\n\tfrv_class_max_nregs): Likewise.\n\t* config/h8300/h8300.c (h8300_classify_operand,\n\th8300_unary_length, h8300_bitfield_length, h8300_asm_insn_count):\n\tLikewise.\n\t* config/i386/winnt.c (i386_pe_declare_function_type): Likewise.\n\t* config/ia64/ia64.c (ia64_preferred_reload_class,\n\tia64_secondary_reload_class, ia64_output_mi_thunk): Likewise.\n\t* config/iq2000/iq2000.c (gen_int_relational): Likewise.\n\t* config/m32c/m32c.c (class_can_hold_mode, m32c_output_compare):\n\tLikewise.\n\t* config/m68hc11/m68hc11.c (preferred_reload_class,\n\tm68hc11_memory_move_cost): Likewise.\n\t* config/mcore/mcore.c (mcore_secondary_reload_class,\n\tmcore_reload_class): Likewise.\n\t* config/mips/mips.c (mips_hard_regno_mode_ok_p,\n\tmips_class_max_nregs, mips_cannot_change_mode_class,\n\tmips_preferred_reload_class, mips_secondary_reload_class,\n\tmips_output_mi_thunk): Likewise.\n\t* config/mmix/mmix.c (mmix_preferred_reload_class,\n\tmmix_preferred_output_reload_class, mmix_secondary_reload_class):\n\tLikewise.\n\t* config/mn10300/mn10300.c (mn10300_secondary_reload_class):\n\tLikewise.\n\t* config/pa/pa.c (pa_secondary_reload, pa_combine_instructions,\n\tpa_can_combine_p, pa_cannot_change_mode_class): Likewise.\n\t* config/pa/pa.h (LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n\t* config/rs6000/rs6000.c (paired_expand_vector_init,\n\trs6000_secondary_reload_class, rs6000_output_mi_thunk,\n\tcompare_section_name, rs6000_memory_move_cost): Likewise.\n\t* config/s390/s390.c (s390_emit_compare_and_swap,\n\ts390_preferred_reload_class, s390_secondary_reload,\n\tlegitimize_pic_address, legitimize_tls_address,\n\tlegitimize_reload_address, s390_expand_cs_hqi, s390_expand_atomic,\n\ts390_class_max_nregs): Likewise.\n\t* config/s390/s390.h (LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n\t* config/s390/s390.md: Likewise.\n\t* config/score/score-protos.h (score_secondary_reload_class,\n\tscore_preferred_reload_class): Likewise.\n\t* config/score/score.c (score_preferred_reload_class,\n\tscore_secondary_reload_class): Likewise.\n\t* config/score/score3.c (score3_output_mi_thunk,\n\tscore3_preferred_reload_class, score3_secondary_reload_class,\n\tscore3_hard_regno_mode_ok): Likewise.\n\t* config/score/score3.h (score3_preferred_reload_class,\n\tscore3_secondary_reload_class): Likewise.\n\t* config/score/score7.c (score7_output_mi_thunk,\n\tscore7_preferred_reload_class, score7_secondary_reload_class,\n\tscore7_hard_regno_mode_ok): Likewise.\n\t* config/score/score7.h (score7_preferred_reload_class,\n\tscore7_secondary_reload_class): Likewise.\n\t* config/sh/sh.c (prepare_move_operands, output_far_jump,\n\toutput_branchy_insn, add_constant, gen_block_redirect,\n\tsh_insn_length_adjustment, sh_cannot_change_mode_class,\n\tsh_output_mi_thunk, replace_n_hard_rtx, sh_secondary_reload):\n\tLikewise.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_output_cbranch_hi,\n\txstormy16_output_cbranch_si, xstormy16_secondary_reload_class,\n\txstormy16_preferred_reload_class): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_expand_compare_and_swap,\n\txtensa_expand_atomic, override_options,\n\txtensa_preferred_reload_class, xtensa_secondary_reload_class):\n\tLikewise.\n\t* reorg.c (try_merge_delay_insns): Likewise.\n\t* tree.c (merge_dllimport_decl_attributes): Likewise.\n\n\t* config/frv/frv.c (frv_print_operand): Change isalpha to ISALPHA.\n\nFrom-SVN: r138813", "tree": {"sha": "cb2367793dcc0fbbf5f9b739495dda670be306d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb2367793dcc0fbbf5f9b739495dda670be306d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a2aaacccae56098361e7b602dd823ac2c9a850e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2aaacccae56098361e7b602dd823ac2c9a850e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2aaacccae56098361e7b602dd823ac2c9a850e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2aaacccae56098361e7b602dd823ac2c9a850e/comments", "author": null, "committer": null, "parents": [{"sha": "1b77ee033fecf9248a662458b3ffc7caf4fe19cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b77ee033fecf9248a662458b3ffc7caf4fe19cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b77ee033fecf9248a662458b3ffc7caf4fe19cf"}], "stats": {"total": 1570, "additions": 830, "deletions": 740}, "files": [{"sha": "a819795d7088dbc3a930c8d9462126ce51e6f458", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1,3 +1,93 @@\n+2008-08-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* config/alpha/alpha.c (alpha_preferred_reload_class,\n+\talpha_secondary_reload, alpha_emit_set_const_1, function_value,\n+\talpha_output_mi_thunk_osf): Avoid C++ keywords.\n+\t* config/arm/arm.c (output_move_vfp, output_move_neon): Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\t* config/avr/avr-protos.h (preferred_reload_class,\n+\ttest_hard_reg_class, avr_simplify_comparison_p,\n+\tout_shift_with_cnt, class_max_nregs): Likewise.\n+\t* config/avr/avr.c (class_max_nregs, avr_simplify_comparison_p,\n+\toutput_movqi, output_movhi, output_movsisf, out_shift_with_cnt,\n+\tpreferred_reload_class, test_hard_reg_class): Likewise.\n+\t* config/bfin/bfin.c (legitimize_pic_address, hard_regno_mode_ok,\n+\tbfin_memory_move_cost, bfin_secondary_reload,\n+\tbfin_output_mi_thunk): Likewise.\n+\t* config/crx/crx.c (crx_secondary_reload_class,\n+\tcrx_memory_move_cost): Likewise.\n+\t* config/frv/frv-protos.h (frv_secondary_reload_class,\n+\tfrv_class_likely_spilled_p, frv_class_max_nregs): Likewise.\n+\t* config/frv/frv.c (frv_override_options, frv_alloc_temp_reg,\n+\tfrv_secondary_reload_class, frv_class_likely_spilled_p,\n+\tfrv_class_max_nregs): Likewise.\n+\t* config/h8300/h8300.c (h8300_classify_operand,\n+\th8300_unary_length, h8300_bitfield_length, h8300_asm_insn_count):\n+\tLikewise.\n+\t* config/i386/winnt.c (i386_pe_declare_function_type): Likewise.\n+\t* config/ia64/ia64.c (ia64_preferred_reload_class,\n+\tia64_secondary_reload_class, ia64_output_mi_thunk): Likewise.\n+\t* config/iq2000/iq2000.c (gen_int_relational): Likewise.\n+\t* config/m32c/m32c.c (class_can_hold_mode, m32c_output_compare):\n+\tLikewise.\n+\t* config/m68hc11/m68hc11.c (preferred_reload_class,\n+\tm68hc11_memory_move_cost): Likewise.\n+\t* config/mcore/mcore.c (mcore_secondary_reload_class,\n+\tmcore_reload_class): Likewise.\n+\t* config/mips/mips.c (mips_hard_regno_mode_ok_p,\n+\tmips_class_max_nregs, mips_cannot_change_mode_class,\n+\tmips_preferred_reload_class, mips_secondary_reload_class,\n+\tmips_output_mi_thunk): Likewise.\n+\t* config/mmix/mmix.c (mmix_preferred_reload_class,\n+\tmmix_preferred_output_reload_class, mmix_secondary_reload_class):\n+\tLikewise.\n+\t* config/mn10300/mn10300.c (mn10300_secondary_reload_class):\n+\tLikewise.\n+\t* config/pa/pa.c (pa_secondary_reload, pa_combine_instructions,\n+\tpa_can_combine_p, pa_cannot_change_mode_class): Likewise.\n+\t* config/pa/pa.h (LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n+\t* config/rs6000/rs6000.c (paired_expand_vector_init,\n+\trs6000_secondary_reload_class, rs6000_output_mi_thunk,\n+\tcompare_section_name, rs6000_memory_move_cost): Likewise.\n+\t* config/s390/s390.c (s390_emit_compare_and_swap,\n+\ts390_preferred_reload_class, s390_secondary_reload,\n+\tlegitimize_pic_address, legitimize_tls_address,\n+\tlegitimize_reload_address, s390_expand_cs_hqi, s390_expand_atomic,\n+\ts390_class_max_nregs): Likewise.\n+\t* config/s390/s390.h (LEGITIMIZE_RELOAD_ADDRESS): Likewise.\n+\t* config/s390/s390.md: Likewise.\n+\t* config/score/score-protos.h (score_secondary_reload_class,\n+\tscore_preferred_reload_class): Likewise.\n+\t* config/score/score.c (score_preferred_reload_class,\n+\tscore_secondary_reload_class): Likewise.\n+\t* config/score/score3.c (score3_output_mi_thunk,\n+\tscore3_preferred_reload_class, score3_secondary_reload_class,\n+\tscore3_hard_regno_mode_ok): Likewise.\n+\t* config/score/score3.h (score3_preferred_reload_class,\n+\tscore3_secondary_reload_class): Likewise.\n+\t* config/score/score7.c (score7_output_mi_thunk,\n+\tscore7_preferred_reload_class, score7_secondary_reload_class,\n+\tscore7_hard_regno_mode_ok): Likewise.\n+\t* config/score/score7.h (score7_preferred_reload_class,\n+\tscore7_secondary_reload_class): Likewise.\n+\t* config/sh/sh.c (prepare_move_operands, output_far_jump,\n+\toutput_branchy_insn, add_constant, gen_block_redirect,\n+\tsh_insn_length_adjustment, sh_cannot_change_mode_class,\n+\tsh_output_mi_thunk, replace_n_hard_rtx, sh_secondary_reload):\n+\tLikewise.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_output_cbranch_hi,\n+\txstormy16_output_cbranch_si, xstormy16_secondary_reload_class,\n+\txstormy16_preferred_reload_class): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_expand_compare_and_swap,\n+\txtensa_expand_atomic, override_options,\n+\txtensa_preferred_reload_class, xtensa_secondary_reload_class):\n+\tLikewise.\n+\t* reorg.c (try_merge_delay_insns): Likewise.\n+\t* tree.c (merge_dllimport_decl_attributes): Likewise.\n+\n+\t* config/frv/frv.c (frv_print_operand): Change isalpha to ISALPHA.\n+\n 2008-08-06  Michael Matz  <matz@suse.de>\n \n \t* Makefile.in (write_entries_to_file): Quote words."}, {"sha": "cba9370f629ed107e2a7455a7d66699ca10112f9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1506,43 +1506,43 @@ get_unaligned_offset (rtx addr, HOST_WIDE_INT ofs)\n \n /* On the Alpha, all (non-symbolic) constants except zero go into\n    a floating-point register via memory.  Note that we cannot\n-   return anything that is not a subset of CLASS, and that some\n+   return anything that is not a subset of RCLASS, and that some\n    symbolic constants cannot be dropped to memory.  */\n \n enum reg_class\n-alpha_preferred_reload_class(rtx x, enum reg_class class)\n+alpha_preferred_reload_class(rtx x, enum reg_class rclass)\n {\n   /* Zero is present in any register class.  */\n   if (x == CONST0_RTX (GET_MODE (x)))\n-    return class;\n+    return rclass;\n \n   /* These sorts of constants we can easily drop to memory.  */\n   if (GET_CODE (x) == CONST_INT\n       || GET_CODE (x) == CONST_DOUBLE\n       || GET_CODE (x) == CONST_VECTOR)\n     {\n-      if (class == FLOAT_REGS)\n+      if (rclass == FLOAT_REGS)\n \treturn NO_REGS;\n-      if (class == ALL_REGS)\n+      if (rclass == ALL_REGS)\n \treturn GENERAL_REGS;\n-      return class;\n+      return rclass;\n     }\n \n   /* All other kinds of constants should not (and in the case of HIGH\n      cannot) be dropped to memory -- instead we use a GENERAL_REGS\n      secondary reload.  */\n   if (CONSTANT_P (x))\n-    return (class == ALL_REGS ? GENERAL_REGS : class);\n+    return (rclass == ALL_REGS ? GENERAL_REGS : rclass);\n \n-  return class;\n+  return rclass;\n }\n \n /* Inform reload about cases where moving X with a mode MODE to a register in\n-   CLASS requires an extra scratch or immediate register.  Return the class\n+   RCLASS requires an extra scratch or immediate register.  Return the class\n    needed for the immediate register.  */\n \n static enum reg_class\n-alpha_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+alpha_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t\tenum machine_mode mode, secondary_reload_info *sri)\n {\n   /* Loading and storing HImode or QImode values to and from memory\n@@ -1564,7 +1564,7 @@ alpha_secondary_reload (bool in_p, rtx x, enum reg_class class,\n \n   /* We also cannot do integral arithmetic into FP regs, as might result\n      from register elimination into a DImode fp register.  */\n-  if (class == FLOAT_REGS)\n+  if (rclass == FLOAT_REGS)\n     {\n       if (MEM_P (x) && GET_CODE (XEXP (x, 0)) == AND)\n \treturn GENERAL_REGS;\n@@ -1644,7 +1644,7 @@ static rtx\n alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t\t\tHOST_WIDE_INT c, int n, bool no_output)\n {\n-  HOST_WIDE_INT new;\n+  HOST_WIDE_INT new_const;\n   int i, bits;\n   /* Use a pseudo if highly optimizing and still generating RTL.  */\n   rtx subtarget\n@@ -1743,15 +1743,15 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n       /* First, see if minus some low bits, we've an easy load of\n \t high bits.  */\n \n-      new = ((c & 0xffff) ^ 0x8000) - 0x8000;\n-      if (new != 0)\n+      new_const = ((c & 0xffff) ^ 0x8000) - 0x8000;\n+      if (new_const != 0)\n \t{\n-          temp = alpha_emit_set_const (subtarget, mode, c - new, i, no_output);\n+          temp = alpha_emit_set_const (subtarget, mode, c - new_const, i, no_output);\n \t  if (temp)\n \t    {\n \t      if (no_output)\n \t\treturn temp;\n-\t      return expand_binop (mode, add_optab, temp, GEN_INT (new),\n+\t      return expand_binop (mode, add_optab, temp, GEN_INT (new_const),\n \t\t\t\t   target, 0, OPTAB_WIDEN);\n \t    }\n \t}\n@@ -1778,12 +1778,12 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n       if (bits > 0)\n \tfor (; bits > 0; bits--)\n \t  {\n-\t    new = c >> bits;\n-\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    new_const = c >> bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new_const, i, no_output);\n \t    if (!temp && c < 0)\n \t      {\n-\t\tnew = (unsigned HOST_WIDE_INT)c >> bits;\n-\t\ttemp = alpha_emit_set_const (subtarget, mode, new,\n+\t\tnew_const = (unsigned HOST_WIDE_INT)c >> bits;\n+\t\ttemp = alpha_emit_set_const (subtarget, mode, new_const,\n \t\t\t\t\t     i, no_output);\n \t      }\n \t    if (temp)\n@@ -1806,12 +1806,12 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n       if (bits > 0)\n \tfor (; bits > 0; bits--)\n \t  {\n-\t    new = c << bits;\n-\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    new_const = c << bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new_const, i, no_output);\n \t    if (!temp)\n \t      {\n-\t\tnew = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n-\t        temp = alpha_emit_set_const (subtarget, mode, new,\n+\t\tnew_const = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t        temp = alpha_emit_set_const (subtarget, mode, new_const,\n \t\t\t\t\t     i, no_output);\n \t      }\n \t    if (temp)\n@@ -1832,12 +1832,12 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n       if (bits > 0)\n \tfor (; bits > 0; bits--)\n \t  {\n-\t    new = c << bits;\n-\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    new_const = c << bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new_const, i, no_output);\n \t    if (!temp)\n \t      {\n-\t\tnew = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n-\t        temp = alpha_emit_set_const (subtarget, mode, new,\n+\t\tnew_const = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t        temp = alpha_emit_set_const (subtarget, mode, new_const,\n \t\t\t\t\t     i, no_output);\n \t      }\n \t    if (temp)\n@@ -1855,25 +1855,25 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n      constant except that all bytes that are 0 are changed to be 0xff.  If we\n      can, then we can do a ZAPNOT to obtain the desired constant.  */\n \n-  new = c;\n+  new_const = c;\n   for (i = 0; i < 64; i += 8)\n-    if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n-      new |= (HOST_WIDE_INT) 0xff << i;\n+    if ((new_const & ((HOST_WIDE_INT) 0xff << i)) == 0)\n+      new_const |= (HOST_WIDE_INT) 0xff << i;\n \n   /* We are only called for SImode and DImode.  If this is SImode, ensure that\n      we are sign extended to a full word.  */\n \n   if (mode == SImode)\n-    new = ((new & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+    new_const = ((new_const & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \n-  if (new != c)\n+  if (new_const != c)\n     {\n-      temp = alpha_emit_set_const (subtarget, mode, new, n - 1, no_output);\n+      temp = alpha_emit_set_const (subtarget, mode, new_const, n - 1, no_output);\n       if (temp)\n \t{\n \t  if (no_output)\n \t    return temp;\n-\t  return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n+\t  return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new_const),\n \t\t\t       target, 0, OPTAB_WIDEN);\n \t}\n     }\n@@ -5708,15 +5708,15 @@ function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n \t\tenum machine_mode mode)\n {\n   unsigned int regnum, dummy;\n-  enum mode_class class;\n+  enum mode_class mclass;\n \n   gcc_assert (!valtype || !alpha_return_in_memory (valtype, func));\n \n   if (valtype)\n     mode = TYPE_MODE (valtype);\n \n-  class = GET_MODE_CLASS (mode);\n-  switch (class)\n+  mclass = GET_MODE_CLASS (mode);\n+  switch (mclass)\n     {\n     case MODE_INT:\n       PROMOTE_MODE (mode, dummy, valtype);\n@@ -8261,7 +8261,7 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t\t   tree function)\n {\n   HOST_WIDE_INT hi, lo;\n-  rtx this, insn, funexp;\n+  rtx this_rtx, insn, funexp;\n \n   /* We always require a valid GP.  */\n   emit_insn (gen_prologue_ldgp ());\n@@ -8270,9 +8270,9 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Find the \"this\" pointer.  If the function returns a structure,\n      the structure return pointer is in $16.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, 17);\n+    this_rtx = gen_rtx_REG (Pmode, 17);\n   else\n-    this = gen_rtx_REG (Pmode, 16);\n+    this_rtx = gen_rtx_REG (Pmode, 16);\n \n   /* Add DELTA.  When possible we use ldah+lda.  Otherwise load the\n      entire constant for the add.  */\n@@ -8281,15 +8281,15 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   if (hi + lo == delta)\n     {\n       if (hi)\n-\temit_insn (gen_adddi3 (this, this, GEN_INT (hi)));\n+\temit_insn (gen_adddi3 (this_rtx, this_rtx, GEN_INT (hi)));\n       if (lo)\n-\temit_insn (gen_adddi3 (this, this, GEN_INT (lo)));\n+\temit_insn (gen_adddi3 (this_rtx, this_rtx, GEN_INT (lo)));\n     }\n   else\n     {\n       rtx tmp = alpha_emit_set_long_const (gen_rtx_REG (Pmode, 0),\n \t\t\t\t\t   delta, -(delta < 0));\n-      emit_insn (gen_adddi3 (this, this, tmp));\n+      emit_insn (gen_adddi3 (this_rtx, this_rtx, tmp));\n     }\n \n   /* Add a delta stored in the vtable at VCALL_OFFSET.  */\n@@ -8298,7 +8298,7 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       rtx tmp, tmp2;\n \n       tmp = gen_rtx_REG (Pmode, 0);\n-      emit_move_insn (tmp, gen_rtx_MEM (Pmode, this));\n+      emit_move_insn (tmp, gen_rtx_MEM (Pmode, this_rtx));\n \n       lo = ((vcall_offset & 0xffff) ^ 0x8000) - 0x8000;\n       hi = (((vcall_offset - lo) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n@@ -8320,7 +8320,7 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \ttmp2 = tmp;\n       emit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp2));\n \n-      emit_insn (gen_adddi3 (this, this, tmp));\n+      emit_insn (gen_adddi3 (this_rtx, this_rtx, tmp));\n     }\n \n   /* Generate a tail call to the target function.  */"}, {"sha": "7d1840a6836dde3a13f3229f0de25c575f2bf053", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -10283,7 +10283,7 @@ output_move_vfp (rtx *operands)\n   int load = REG_P (operands[0]);\n   int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n   int integer_p = GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT;\n-  const char *template;\n+  const char *templ;\n   char buff[50];\n   enum machine_mode mode;\n \n@@ -10306,25 +10306,25 @@ output_move_vfp (rtx *operands)\n   switch (GET_CODE (addr))\n     {\n     case PRE_DEC:\n-      template = \"f%smdb%c%%?\\t%%0!, {%%%s1}%s\";\n+      templ = \"f%smdb%c%%?\\t%%0!, {%%%s1}%s\";\n       ops[0] = XEXP (addr, 0);\n       ops[1] = reg;\n       break;\n \n     case POST_INC:\n-      template = \"f%smia%c%%?\\t%%0!, {%%%s1}%s\";\n+      templ = \"f%smia%c%%?\\t%%0!, {%%%s1}%s\";\n       ops[0] = XEXP (addr, 0);\n       ops[1] = reg;\n       break;\n \n     default:\n-      template = \"f%s%c%%?\\t%%%s0, %%1%s\";\n+      templ = \"f%s%c%%?\\t%%%s0, %%1%s\";\n       ops[0] = reg;\n       ops[1] = mem;\n       break;\n     }\n \n-  sprintf (buff, template,\n+  sprintf (buff, templ,\n \t   load ? \"ld\" : \"st\",\n \t   dp ? 'd' : 's',\n \t   dp ? \"P\" : \"\",\n@@ -10365,7 +10365,7 @@ output_move_neon (rtx *operands)\n {\n   rtx reg, mem, addr, ops[2];\n   int regno, load = REG_P (operands[0]);\n-  const char *template;\n+  const char *templ;\n   char buff[50];\n   enum machine_mode mode;\n \n@@ -10392,7 +10392,7 @@ output_move_neon (rtx *operands)\n   switch (GET_CODE (addr))\n     {\n     case POST_INC:\n-      template = \"v%smia%%?\\t%%0!, %%h1\";\n+      templ = \"v%smia%%?\\t%%0!, %%h1\";\n       ops[0] = XEXP (addr, 0);\n       ops[1] = reg;\n       break;\n@@ -10435,12 +10435,12 @@ output_move_neon (rtx *operands)\n       }\n \n     default:\n-      template = \"v%smia%%?\\t%%m0, %%h1\";\n+      templ = \"v%smia%%?\\t%%m0, %%h1\";\n       ops[0] = mem;\n       ops[1] = reg;\n     }\n \n-  sprintf (buff, template, load ? \"ld\" : \"st\");\n+  sprintf (buff, templ, load ? \"ld\" : \"st\");\n   output_asm_insn (buff, ops);\n \n   return \"\";"}, {"sha": "5b514451c5d105bd44ed3c7c3df4248a3ab1aaa9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -5286,12 +5286,12 @@\n \t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n \t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 32)\n \t\t    {\n-\t\t      rtx new;\n+\t\t      rtx new_rtx;\n \n-\t\t      new = widen_memory_access (operands[1], SImode,\n-\t\t\t\t\t\t ((INTVAL (offset) & ~3)\n-\t\t\t\t\t\t  - INTVAL (offset)));\n-\t\t      emit_insn (gen_movsi (reg, new));\n+\t\t      new_rtx = widen_memory_access (operands[1], SImode,\n+\t\t\t\t\t\t     ((INTVAL (offset) & ~3)\n+\t\t\t\t\t\t      - INTVAL (offset)));\n+\t\t      emit_insn (gen_movsi (reg, new_rtx));\n \t\t      if (((INTVAL (offset) & 2) != 0)\n \t\t\t  ^ (BYTES_BIG_ENDIAN ? 1 : 0))\n \t\t\t{"}, {"sha": "bcf81d9afc50a7daf402f4e86f189190d0d2669d", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -94,7 +94,7 @@ extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n \n-extern enum reg_class preferred_reload_class (rtx x, enum reg_class class);\n+extern enum reg_class preferred_reload_class (rtx x, enum reg_class rclass);\n extern int extra_constraint_Q (rtx x);\n extern rtx legitimize_address (rtx x, rtx oldx, enum machine_mode mode);\n extern int adjust_insn_length (rtx insn, int len);\n@@ -111,21 +111,21 @@ extern int reg_unused_after (rtx insn, rtx reg);\n extern int _reg_unused_after (rtx insn, rtx reg);\n extern int avr_jump_mode (rtx x, rtx insn);\n extern int byte_immediate_operand (rtx op, enum machine_mode mode);\n-extern int test_hard_reg_class (enum reg_class class, rtx x);\n+extern int test_hard_reg_class (enum reg_class rclass, rtx x);\n extern int jump_over_one_insn_p (rtx insn, rtx dest);\n \n extern int avr_hard_regno_mode_ok (int regno, enum machine_mode mode);\n extern void final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n extern int avr_simplify_comparison_p (enum machine_mode mode,\n-\t\t\t\t      RTX_CODE operator, rtx x);\n+\t\t\t\t      RTX_CODE op, rtx x);\n extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n extern int compare_eq_p (rtx insn);\n-extern void out_shift_with_cnt (const char *template, rtx insn,\n+extern void out_shift_with_cnt (const char *templ, rtx insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n #endif /* RTX_CODE */\n \n #ifdef HAVE_MACHINE_MODES\n-extern int class_max_nregs (enum reg_class class, enum machine_mode mode);\n+extern int class_max_nregs (enum reg_class rclass, enum machine_mode mode);\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "1b1650f0f37a462daf9b9f2dbca3fbae7391dfff", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1403,7 +1403,7 @@ notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n    class CLASS needed to hold a value of mode MODE.  */\n \n int\n-class_max_nregs (enum reg_class class ATTRIBUTE_UNUSED,enum machine_mode mode)\n+class_max_nregs (enum reg_class rclass ATTRIBUTE_UNUSED,enum machine_mode mode)\n {\n   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n }\n@@ -1566,14 +1566,14 @@ final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n /* Return 0 if undefined, 1 if always true or always false.  */\n \n int\n-avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE operator, rtx x)\n+avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)\n {\n   unsigned int max = (mode == QImode ? 0xff :\n                       mode == HImode ? 0xffff :\n                       mode == SImode ? 0xffffffff : 0);\n-  if (max && operator && GET_CODE (x) == CONST_INT)\n+  if (max && op && GET_CODE (x) == CONST_INT)\n     {\n-      if (unsigned_condition (operator) != operator)\n+      if (unsigned_condition (op) != op)\n \tmax >>= 1;\n \n       if (max != (INTVAL (x) & max)\n@@ -1743,15 +1743,15 @@ output_movqi (rtx insn, rtx operands[], int *l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      const char *template;\n+      const char *templ;\n \n       if (src == const0_rtx)\n \toperands[1] = zero_reg_rtx;\n \n-      template = out_movqi_mr_r (insn, operands, real_l);\n+      templ = out_movqi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n-\toutput_asm_insn (template, operands);\n+\toutput_asm_insn (templ, operands);\n \n       operands[1] = src;\n     }\n@@ -1893,15 +1893,15 @@ output_movhi (rtx insn, rtx operands[], int *l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      const char *template;\n+      const char *templ;\n \n       if (src == const0_rtx)\n \toperands[1] = zero_reg_rtx;\n \n-      template = out_movhi_mr_r (insn, operands, real_l);\n+      templ = out_movhi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n-\toutput_asm_insn (template, operands);\n+\toutput_asm_insn (templ, operands);\n \n       operands[1] = src;\n       return \"\";\n@@ -2581,15 +2581,15 @@ output_movsisf(rtx insn, rtx operands[], int *l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      const char *template;\n+      const char *templ;\n \n       if (src == const0_rtx)\n \t  operands[1] = zero_reg_rtx;\n \n-      template = out_movsi_mr_r (insn, operands, real_l);\n+      templ = out_movsi_mr_r (insn, operands, real_l);\n \n       if (!real_l)\n-\toutput_asm_insn (template, operands);\n+\toutput_asm_insn (templ, operands);\n \n       operands[1] = src;\n       return \"\";\n@@ -2930,7 +2930,7 @@ out_tstsi (rtx insn, int *l)\n    carefully hand-optimized in ?sh??i3_out.  */\n \n void\n-out_shift_with_cnt (const char *template, rtx insn, rtx operands[],\n+out_shift_with_cnt (const char *templ, rtx insn, rtx operands[],\n \t\t    int *len, int t_len)\n {\n   rtx op[10];\n@@ -2975,7 +2975,7 @@ out_shift_with_cnt (const char *template, rtx insn, rtx operands[],\n \t  else\n \t    {\n \t      while (count-- > 0)\n-\t\toutput_asm_insn (template, op);\n+\t\toutput_asm_insn (templ, op);\n \t    }\n \n \t  return;\n@@ -3056,7 +3056,7 @@ out_shift_with_cnt (const char *template, rtx insn, rtx operands[],\n   else\n     {\n       strcat (str, \"\\n1:\\t\");\n-      strcat (str, template);\n+      strcat (str, templ);\n       strcat (str, second_label ? \"\\n2:\\t\" : \"\\n\\t\");\n       strcat (str, use_zero_reg ? AS1 (lsr,%3) : AS1 (dec,%3));\n       strcat (str, CR_TAB);\n@@ -5735,19 +5735,19 @@ avr_function_value (const_tree type,\n    in class CLASS.  */\n \n enum reg_class\n-preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n-  return class;\n+  return rclass;\n }\n \n int\n-test_hard_reg_class (enum reg_class class, rtx x)\n+test_hard_reg_class (enum reg_class rclass, rtx x)\n {\n   int regno = true_regnum (x);\n   if (regno < 0)\n     return 0;\n \n-  if (TEST_HARD_REG_CLASS (class, regno))\n+  if (TEST_HARD_REG_CLASS (rclass, regno))\n     return 1;\n \n   return 0;"}, {"sha": "8fda5c01d8e10af571ceb17cd3cdc78486dbf1a9", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -279,7 +279,7 @@ static rtx\n legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n {\n   rtx addr = orig;\n-  rtx new = orig;\n+  rtx new_rtx = orig;\n \n   if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n     {\n@@ -301,9 +301,9 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \t}\n \n       tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), unspec);\n-      new = gen_const_mem (Pmode, gen_rtx_PLUS (Pmode, picreg, tmp));\n+      new_rtx = gen_const_mem (Pmode, gen_rtx_PLUS (Pmode, picreg, tmp));\n \n-      emit_move_insn (reg, new);\n+      emit_move_insn (reg, new_rtx);\n       if (picreg == pic_offset_table_rtx)\n \tcrtl->uses_pic_offset_table = 1;\n       return reg;\n@@ -348,7 +348,7 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n       return gen_rtx_PLUS (Pmode, base, addr);\n     }\n \n-  return new;\n+  return new_rtx;\n }\n \f\n /* Stack frame layout. */\n@@ -2156,14 +2156,14 @@ int\n hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   /* Allow only dregs to store value of mode HI or QI */\n-  enum reg_class class = REGNO_REG_CLASS (regno);\n+  enum reg_class rclass = REGNO_REG_CLASS (regno);\n \n   if (mode == CCmode)\n     return 0;\n \n   if (mode == V2HImode)\n     return D_REGNO_P (regno);\n-  if (class == CCREGS)\n+  if (rclass == CCREGS)\n     return mode == BImode;\n   if (mode == PDImode || mode == V2PDImode)\n     return regno == REG_A0 || regno == REG_A1;\n@@ -2232,24 +2232,24 @@ bfin_register_move_cost (enum machine_mode mode,\n \n int\n bfin_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       enum reg_class class,\n+\t\t       enum reg_class rclass,\n \t\t       int in ATTRIBUTE_UNUSED)\n {\n   /* Make memory accesses slightly more expensive than any register-register\n      move.  Also, penalize non-DP registers, since they need secondary\n      reloads to load and store.  */\n-  if (! reg_class_subset_p (class, DPREGS))\n+  if (! reg_class_subset_p (rclass, DPREGS))\n     return 10;\n \n   return 8;\n }\n \n /* Inform reload about cases where moving X with a mode MODE to a register in\n-   CLASS requires an extra scratch register.  Return the class needed for the\n+   RCLASS requires an extra scratch register.  Return the class needed for the\n    scratch register.  */\n \n static enum reg_class\n-bfin_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+bfin_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t       enum machine_mode mode, secondary_reload_info *sri)\n {\n   /* If we have HImode or QImode, we can only use DREGS as secondary registers;\n@@ -2280,11 +2280,11 @@ bfin_secondary_reload (bool in_p, rtx x, enum reg_class class,\n       rtx op2 = XEXP (x, 1);\n       int large_constant_p = ! satisfies_constraint_Ks7 (op2);\n \n-      if (class == PREGS || class == PREGS_CLOBBERED)\n+      if (rclass == PREGS || rclass == PREGS_CLOBBERED)\n \treturn NO_REGS;\n       /* If destination is a DREG, we can do this without a scratch register\n \t if the constant is valid for an add instruction.  */\n-      if ((class == DREGS || class == DPREGS)\n+      if ((rclass == DREGS || rclass == DPREGS)\n \t  && ! large_constant_p)\n \treturn NO_REGS;\n       /* Reloading to anything other than a DREG?  Use a PREG scratch\n@@ -2297,11 +2297,11 @@ bfin_secondary_reload (bool in_p, rtx x, enum reg_class class,\n      AREGS are an exception; they can only move to or from another register\n      in AREGS or one in DREGS.  They can also be assigned the constant 0.  */\n   if (x_class == AREGS || x_class == EVEN_AREGS || x_class == ODD_AREGS)\n-    return (class == DREGS || class == AREGS || class == EVEN_AREGS\n-\t    || class == ODD_AREGS\n+    return (rclass == DREGS || rclass == AREGS || rclass == EVEN_AREGS\n+\t    || rclass == ODD_AREGS\n \t    ? NO_REGS : DREGS);\n \n-  if (class == AREGS || class == EVEN_AREGS || class == ODD_AREGS)\n+  if (rclass == AREGS || rclass == EVEN_AREGS || rclass == ODD_AREGS)\n     {\n       if (code == MEM)\n \t{\n@@ -2318,15 +2318,15 @@ bfin_secondary_reload (bool in_p, rtx x, enum reg_class class,\n     }\n \n   /* CCREGS can only be moved from/to DREGS.  */\n-  if (class == CCREGS && x_class != DREGS)\n+  if (rclass == CCREGS && x_class != DREGS)\n     return DREGS;\n-  if (x_class == CCREGS && class != DREGS)\n+  if (x_class == CCREGS && rclass != DREGS)\n     return DREGS;\n \n   /* All registers other than AREGS can load arbitrary constants.  The only\n      case that remains is MEM.  */\n   if (code == MEM)\n-    if (! reg_class_subset_p (class, default_class))\n+    if (! reg_class_subset_p (rclass, default_class))\n       return default_class;\n \n   return NO_REGS;\n@@ -5127,12 +5127,12 @@ bfin_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n {\n   rtx xops[3];\n   /* The this parameter is passed as the first argument.  */\n-  rtx this = gen_rtx_REG (Pmode, REG_R0);\n+  rtx this_rtx = gen_rtx_REG (Pmode, REG_R0);\n \n   /* Adjust the this parameter by a fixed constant.  */\n   if (delta)\n     {\n-      xops[1] = this;\n+      xops[1] = this_rtx;\n       if (delta >= -64 && delta <= 63)\n \t{\n \t  xops[0] = GEN_INT (delta);\n@@ -5175,7 +5175,7 @@ bfin_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \t  output_asm_insn (\"%h1 = %h0; %d1 = %d0; %2 = %2 + %1\", xops);\n \t  xops[0] = gen_rtx_MEM (Pmode, p2tmp);\n \t}\n-      xops[2] = this;\n+      xops[2] = this_rtx;\n       output_asm_insn (\"%1 = %0; %2 = %2 + %1;\", xops);\n     }\n "}, {"sha": "2f4aa6f176b11ed0debaf57a2bf6980ffb022500", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -371,11 +371,11 @@ crx_regno_reg_class (int regno)\n /* Transfer between HILO_REGS and memory via secondary reloading. */\n \n enum reg_class\n-crx_secondary_reload_class (enum reg_class class,\n+crx_secondary_reload_class (enum reg_class rclass,\n \t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    rtx x ATTRIBUTE_UNUSED)\n {\n-  if (reg_classes_intersect_p (class, HILO_REGS)\n+  if (reg_classes_intersect_p (rclass, HILO_REGS)\n       && true_regnum (x) == -1)\n     return GENERAL_REGS;\n \n@@ -839,22 +839,22 @@ crx_address_cost (rtx addr)\n }\n \n /* Return the cost of moving data of mode MODE between a register of class\n- * CLASS and memory; IN is zero if the value is to be written to memory,\n+ * RCLASS and memory; IN is zero if the value is to be written to memory,\n  * nonzero if it is to be read in. This cost is relative to those in\n  * REGISTER_MOVE_COST.  */\n \n int\n crx_memory_move_cost (enum machine_mode mode,\n-\t\t  enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t  enum reg_class rclass ATTRIBUTE_UNUSED,\n \t\t  int in ATTRIBUTE_UNUSED)\n {\n   /* One LD or ST takes twice the time of a simple reg-reg move */\n-  if (reg_classes_intersect_p (class, GENERAL_REGS))\n+  if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n     {\n       /* printf (\"GENERAL_REGS LD/ST = %d\\n\", 4 * HARD_REGNO_NREGS (0, mode));*/\n       return 4 * HARD_REGNO_NREGS (0, mode);\n     }\t\n-  else if (reg_classes_intersect_p (class, HILO_REGS))\n+  else if (reg_classes_intersect_p (rclass, HILO_REGS))\n     {\n       /* HILO to memory and vice versa */\n       /* printf (\"HILO_REGS %s = %d\\n\", in ? \"LD\" : \"ST\","}, {"sha": "8d6b29bc7cf00c61adde91af0dac288121e8a7e6", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -104,13 +104,13 @@ extern void frv_ifcvt_modify_cancel\t(ce_if_block_t *);\n extern int frv_trampoline_size\t\t(void);\n extern void frv_initialize_trampoline\t(rtx, rtx, rtx);\n extern enum reg_class frv_secondary_reload_class\n-\t\t\t\t\t(enum reg_class class,\n+\t\t\t\t\t(enum reg_class rclass,\n \t\t\t\t\t enum machine_mode mode,\n \t\t\t\t\t rtx x, int);\n-extern int frv_class_likely_spilled_p\t(enum reg_class class);\n+extern int frv_class_likely_spilled_p\t(enum reg_class rclass);\n extern int frv_hard_regno_mode_ok\t(int, enum machine_mode);\n extern int frv_hard_regno_nregs\t\t(int, enum machine_mode);\n-extern int frv_class_max_nregs\t\t(enum reg_class class,\n+extern int frv_class_max_nregs\t\t(enum reg_class rclass,\n \t\t\t\t\t enum machine_mode mode);\n extern int frv_legitimate_constant_p\t(rtx);\n extern enum machine_mode frv_select_cc_mode (enum rtx_code, rtx, rtx);"}, {"sha": "7fa2e22f09417b7253291b8d133388bd028013f4", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -651,83 +651,83 @@ frv_override_options (void)\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n-      enum reg_class class;\n+      enum reg_class rclass;\n \n       if (GPR_P (regno))\n \t{\n \t  int gpr_reg = regno - GPR_FIRST;\n \n \t  if (gpr_reg == GR8_REG)\n-\t    class = GR8_REGS;\n+\t    rclass = GR8_REGS;\n \n \t  else if (gpr_reg == GR9_REG)\n-\t    class = GR9_REGS;\n+\t    rclass = GR9_REGS;\n \n \t  else if (gpr_reg == GR14_REG)\n-\t    class = FDPIC_FPTR_REGS;\n+\t    rclass = FDPIC_FPTR_REGS;\n \n \t  else if (gpr_reg == FDPIC_REGNO)\n-\t    class = FDPIC_REGS;\n+\t    rclass = FDPIC_REGS;\n \n \t  else if ((gpr_reg & 3) == 0)\n-\t    class = QUAD_REGS;\n+\t    rclass = QUAD_REGS;\n \n \t  else if ((gpr_reg & 1) == 0)\n-\t    class = EVEN_REGS;\n+\t    rclass = EVEN_REGS;\n \n \t  else\n-\t    class = GPR_REGS;\n+\t    rclass = GPR_REGS;\n \t}\n \n       else if (FPR_P (regno))\n \t{\n \t  int fpr_reg = regno - GPR_FIRST;\n \t  if ((fpr_reg & 3) == 0)\n-\t    class = QUAD_FPR_REGS;\n+\t    rclass = QUAD_FPR_REGS;\n \n \t  else if ((fpr_reg & 1) == 0)\n-\t    class = FEVEN_REGS;\n+\t    rclass = FEVEN_REGS;\n \n \t  else\n-\t    class = FPR_REGS;\n+\t    rclass = FPR_REGS;\n \t}\n \n       else if (regno == LR_REGNO)\n-\tclass = LR_REG;\n+\trclass = LR_REG;\n \n       else if (regno == LCR_REGNO)\n-\tclass = LCR_REG;\n+\trclass = LCR_REG;\n \n       else if (ICC_P (regno))\n-\tclass = ICC_REGS;\n+\trclass = ICC_REGS;\n \n       else if (FCC_P (regno))\n-\tclass = FCC_REGS;\n+\trclass = FCC_REGS;\n \n       else if (ICR_P (regno))\n-\tclass = ICR_REGS;\n+\trclass = ICR_REGS;\n \n       else if (FCR_P (regno))\n-\tclass = FCR_REGS;\n+\trclass = FCR_REGS;\n \n       else if (ACC_P (regno))\n \t{\n \t  int r = regno - ACC_FIRST;\n \t  if ((r & 3) == 0)\n-\t    class = QUAD_ACC_REGS;\n+\t    rclass = QUAD_ACC_REGS;\n \t  else if ((r & 1) == 0)\n-\t    class = EVEN_ACC_REGS;\n+\t    rclass = EVEN_ACC_REGS;\n \t  else\n-\t    class = ACC_REGS;\n+\t    rclass = ACC_REGS;\n \t}\n \n       else if (ACCG_P (regno))\n-\tclass = ACCG_REGS;\n+\trclass = ACCG_REGS;\n \n       else\n-\tclass = NO_REGS;\n+\trclass = NO_REGS;\n \n-      regno_reg_class[regno] = class;\n+      regno_reg_class[regno] = rclass;\n     }\n \n   /* Check for small data option */\n@@ -1539,14 +1539,14 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n static rtx\n frv_alloc_temp_reg (\n      frv_tmp_reg_t *info,\t/* which registers are available */\n-     enum reg_class class,\t/* register class desired */\n+     enum reg_class rclass,\t/* register class desired */\n      enum machine_mode mode,\t/* mode to allocate register with */\n      int mark_as_used,\t\t/* register not available after allocation */\n      int no_abort)\t\t/* return NULL instead of aborting */\n {\n-  int regno = info->next_reg[ (int)class ];\n+  int regno = info->next_reg[ (int)rclass ];\n   int orig_regno = regno;\n-  HARD_REG_SET *reg_in_class = &reg_class_contents[ (int)class ];\n+  HARD_REG_SET *reg_in_class = &reg_class_contents[ (int)rclass ];\n   int i, nr;\n \n   for (;;)\n@@ -1565,7 +1565,7 @@ frv_alloc_temp_reg (\n     }\n \n   nr = HARD_REGNO_NREGS (regno, mode);\n-  info->next_reg[ (int)class ] = regno + nr;\n+  info->next_reg[ (int)rclass ] = regno + nr;\n \n   if (mark_as_used)\n     for (i = 0; i < nr; i++)\n@@ -2777,7 +2777,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n   HOST_WIDE_INT value;\n   int offset;\n \n-  if (code != 0 && !isalpha (code))\n+  if (code != 0 && !ISALPHA (code))\n     value = 0;\n \n   else if (GET_CODE (x) == CONST_INT)\n@@ -6300,19 +6300,19 @@ frv_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n    You should define these macros to indicate to the reload phase that it may\n    need to allocate at least one register for a reload in addition to the\n    register to contain the data.  Specifically, if copying X to a register\n-   CLASS in MODE requires an intermediate register, you should define\n+   RCLASS in MODE requires an intermediate register, you should define\n    `SECONDARY_INPUT_RELOAD_CLASS' to return the largest register class all of\n    whose registers can be used as intermediate registers or scratch registers.\n \n-   If copying a register CLASS in MODE to X requires an intermediate or scratch\n+   If copying a register RCLASS in MODE to X requires an intermediate or scratch\n    register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be defined to return the\n    largest register class required.  If the requirements for input and output\n    reloads are the same, the macro `SECONDARY_RELOAD_CLASS' should be used\n    instead of defining both macros identically.\n \n    The values returned by these macros are often `GENERAL_REGS'.  Return\n    `NO_REGS' if no spare register is needed; i.e., if X can be directly copied\n-   to or from a register of CLASS in MODE without requiring a scratch register.\n+   to or from a register of RCLASS in MODE without requiring a scratch register.\n    Do not define this macro if it would always return `NO_REGS'.\n \n    If a scratch register is required (either with or without an intermediate\n@@ -6323,7 +6323,7 @@ frv_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n \n    Define constraints for the reload register and scratch register that contain\n    a single register class.  If the original reload register (whose class is\n-   CLASS) can meet the constraint given in the pattern, the value returned by\n+   RCLASS) can meet the constraint given in the pattern, the value returned by\n    these macros is used for the class of the scratch register.  Otherwise, two\n    additional reload registers are required.  Their classes are obtained from\n    the constraints in the insn pattern.\n@@ -6341,14 +6341,14 @@ frv_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n    This case often occurs between floating-point and general registers.  */\n \n enum reg_class\n-frv_secondary_reload_class (enum reg_class class,\n+frv_secondary_reload_class (enum reg_class rclass,\n                             enum machine_mode mode ATTRIBUTE_UNUSED,\n                             rtx x,\n                             int in_p ATTRIBUTE_UNUSED)\n {\n   enum reg_class ret;\n \n-  switch (class)\n+  switch (rclass)\n     {\n     default:\n       ret = NO_REGS;\n@@ -6405,10 +6405,10 @@ frv_secondary_reload_class (enum reg_class class,\n \n \f\n /* A C expression whose value is nonzero if pseudos that have been assigned to\n-   registers of class CLASS would likely be spilled because registers of CLASS\n+   registers of class RCLASS would likely be spilled because registers of RCLASS\n    are needed for spill registers.\n \n-   The default value of this macro returns 1 if CLASS has exactly one register\n+   The default value of this macro returns 1 if RCLASS has exactly one register\n    and zero otherwise.  On most machines, this default should be used.  Only\n    define this macro to some other expression if pseudo allocated by\n    `local-alloc.c' end up in memory because their hard registers were needed\n@@ -6420,9 +6420,9 @@ frv_secondary_reload_class (enum reg_class class,\n    register allocation.  */\n \n int\n-frv_class_likely_spilled_p (enum reg_class class)\n+frv_class_likely_spilled_p (enum reg_class rclass)\n {\n-  switch (class)\n+  switch (rclass)\n     {\n     default:\n       break;\n@@ -6686,21 +6686,21 @@ frv_hard_regno_nregs (int regno, enum machine_mode mode)\n \n \f\n /* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n+   class RCLASS needed to hold a value of mode MODE.\n \n    This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value\n-   of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the maximum value of\n-   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class CLASS.\n+   of the macro `CLASS_MAX_NREGS (RCLASS, MODE)' should be the maximum value of\n+   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class RCLASS.\n \n    This macro helps control the handling of multiple-word values in\n    the reload pass.\n \n    This declaration is required.  */\n \n int\n-frv_class_max_nregs (enum reg_class class, enum machine_mode mode)\n+frv_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n {\n-  if (class == ACCG_REGS)\n+  if (rclass == ACCG_REGS)\n     /* An N-byte value requires N accumulator guards.  */\n     return GET_MODE_SIZE (mode);\n   else"}, {"sha": "3d9c0fb7efb2ed19131973ce92e9da426b193eda", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -2147,21 +2147,21 @@ h8300_displacement_length (rtx addr, int size)\n   return h8300_constant_length (offset);\n }\n \n-/* Store the class of operand OP in *CLASS and return the length of any\n-   extra operand fields.  SIZE is the number of bytes in OP.  CLASS\n+/* Store the class of operand OP in *OPCLASS and return the length of any\n+   extra operand fields.  SIZE is the number of bytes in OP.  OPCLASS\n    can be null if only the length is needed.  */\n \n static unsigned int\n-h8300_classify_operand (rtx op, int size, enum h8300_operand_class *class)\n+h8300_classify_operand (rtx op, int size, enum h8300_operand_class *opclass)\n {\n   enum h8300_operand_class dummy;\n \n-  if (class == 0)\n-    class = &dummy;\n+  if (opclass == 0)\n+    opclass = &dummy;\n \n   if (CONSTANT_P (op))\n     {\n-      *class = H8OP_IMMEDIATE;\n+      *opclass = H8OP_IMMEDIATE;\n \n       /* Byte-sized immediates are stored in the opcode fields.  */\n       if (size == 1)\n@@ -2182,27 +2182,27 @@ h8300_classify_operand (rtx op, int size, enum h8300_operand_class *class)\n       op = XEXP (op, 0);\n       if (CONSTANT_P (op))\n \t{\n-\t  *class = H8OP_MEM_ABSOLUTE;\n+\t  *opclass = H8OP_MEM_ABSOLUTE;\n \t  return h8300_constant_length (op);\n \t}\n       else if (GET_CODE (op) == PLUS && CONSTANT_P (XEXP (op, 1)))\n \t{\n-\t  *class = H8OP_MEM_COMPLEX;\n+\t  *opclass = H8OP_MEM_COMPLEX;\n \t  return h8300_displacement_length (op, size);\n \t}\n       else if (GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n \t{\n-\t  *class = H8OP_MEM_COMPLEX;\n+\t  *opclass = H8OP_MEM_COMPLEX;\n \t  return 0;\n \t}\n       else if (register_operand (op, VOIDmode))\n \t{\n-\t  *class = H8OP_MEM_BASE;\n+\t  *opclass = H8OP_MEM_BASE;\n \t  return 0;\n \t}\n     }\n   gcc_assert (register_operand (op, VOIDmode));\n-  *class = H8OP_REGISTER;\n+  *opclass = H8OP_REGISTER;\n   return 0;\n }\n \n@@ -2228,12 +2228,12 @@ h8300_length_from_table (rtx op1, rtx op2, const h8300_length_table *table)\n unsigned int\n h8300_unary_length (rtx op)\n {\n-  enum h8300_operand_class class;\n+  enum h8300_operand_class opclass;\n   unsigned int size, operand_length;\n \n   size = GET_MODE_SIZE (GET_MODE (op));\n-  operand_length = h8300_classify_operand (op, size, &class);\n-  switch (class)\n+  operand_length = h8300_classify_operand (op, size, &opclass);\n+  switch (opclass)\n     {\n     case H8OP_REGISTER:\n       return 2;\n@@ -2257,13 +2257,13 @@ h8300_unary_length (rtx op)\n static unsigned int\n h8300_short_immediate_length (rtx op)\n {\n-  enum h8300_operand_class class;\n+  enum h8300_operand_class opclass;\n   unsigned int size, operand_length;\n \n   size = GET_MODE_SIZE (GET_MODE (op));\n-  operand_length = h8300_classify_operand (op, size, &class);\n+  operand_length = h8300_classify_operand (op, size, &opclass);\n \n-  switch (class)\n+  switch (opclass)\n     {\n     case H8OP_REGISTER:\n       return 2;\n@@ -2283,17 +2283,17 @@ h8300_short_immediate_length (rtx op)\n static unsigned int\n h8300_bitfield_length (rtx op, rtx op2)\n {\n-  enum h8300_operand_class class;\n+  enum h8300_operand_class opclass;\n   unsigned int size, operand_length;\n \n   if (GET_CODE (op) == REG)\n     op = op2;\n   gcc_assert (GET_CODE (op) != REG);\n   \n   size = GET_MODE_SIZE (GET_MODE (op));\n-  operand_length = h8300_classify_operand (op, size, &class);\n+  operand_length = h8300_classify_operand (op, size, &opclass);\n \n-  switch (class)\n+  switch (opclass)\n     {\n     case H8OP_MEM_BASE:\n     case H8OP_MEM_ABSOLUTE:\n@@ -4526,15 +4526,15 @@ output_a_shift (rtx *operands)\n     }\n }\n \n-/* Count the number of assembly instructions in a string TEMPLATE.  */\n+/* Count the number of assembly instructions in a string TEMPL.  */\n \n static unsigned int\n-h8300_asm_insn_count (const char *template)\n+h8300_asm_insn_count (const char *templ)\n {\n   unsigned int count = 1;\n \n-  for (; *template; template++)\n-    if (*template == '\\n')\n+  for (; *templ; templ++)\n+    if (*templ == '\\n')\n       count++;\n \n   return count;"}, {"sha": "8ef79058a7d8442ae7fe1d0900df58bbbfebf8f1", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -531,16 +531,16 @@ i386_pe_asm_output_aligned_decl_common (FILE *stream, tree decl,\n /* Mark a function appropriately.  This should only be called for\n    functions for which we are not emitting COFF debugging information.\n    FILE is the assembler output file, NAME is the name of the\n-   function, and PUBLIC is nonzero if the function is globally\n+   function, and PUB is nonzero if the function is globally\n    visible.  */\n \n void\n-i386_pe_declare_function_type (FILE *file, const char *name, int public)\n+i386_pe_declare_function_type (FILE *file, const char *name, int pub)\n {\n   fprintf (file, \"\\t.def\\t\");\n   assemble_name (file, name);\n   fprintf (file, \";\\t.scl\\t%d;\\t.type\\t%d;\\t.endef\\n\",\n-\t   public ? (int) C_EXT : (int) C_STAT,\n+\t   pub ? (int) C_EXT : (int) C_STAT,\n \t   (int) DT_FCN << N_BTSHFT);\n }\n "}, {"sha": "e8a853bb2567f5bec3ca591105fab51beb90dcc9", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -4958,13 +4958,13 @@ ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n   return 2;\n }\n \n-/* Implement PREFERRED_RELOAD_CLASS.  Place additional restrictions on CLASS\n+/* Implement PREFERRED_RELOAD_CLASS.  Place additional restrictions on RCLASS\n    to use when copying X into that class.  */\n \n enum reg_class\n-ia64_preferred_reload_class (rtx x, enum reg_class class)\n+ia64_preferred_reload_class (rtx x, enum reg_class rclass)\n {\n-  switch (class)\n+  switch (rclass)\n     {\n     case FR_REGS:\n     case FP_REGS:\n@@ -4989,24 +4989,24 @@ ia64_preferred_reload_class (rtx x, enum reg_class class)\n       break;\n     }\n \n-  return class;\n+  return rclass;\n }\n \n /* This function returns the register class required for a secondary\n-   register when copying between one of the registers in CLASS, and X,\n+   register when copying between one of the registers in RCLASS, and X,\n    using MODE.  A return value of NO_REGS means that no secondary register\n    is required.  */\n \n enum reg_class\n-ia64_secondary_reload_class (enum reg_class class,\n+ia64_secondary_reload_class (enum reg_class rclass,\n \t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   int regno = -1;\n \n   if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n     regno = true_regnum (x);\n \n-  switch (class)\n+  switch (rclass)\n     {\n     case BR_REGS:\n     case AR_M_REGS:\n@@ -9571,7 +9571,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t      tree function)\n {\n-  rtx this, insn, funexp;\n+  rtx this_rtx, insn, funexp;\n   unsigned int this_parmno;\n   unsigned int this_regno;\n   rtx delta_rtx;\n@@ -9600,7 +9600,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   if (!TARGET_REG_NAMES)\n     reg_names[this_regno] = ia64_reg_numbers[this_parmno];\n \n-  this = gen_rtx_REG (Pmode, this_regno);\n+  this_rtx = gen_rtx_REG (Pmode, this_regno);\n \n   /* Apply the constant offset, if required.  */\n   delta_rtx = GEN_INT (delta);\n@@ -9610,11 +9610,11 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       REG_POINTER (tmp) = 1;\n       if (delta && satisfies_constraint_I (delta_rtx))\n \t{\n-\t  emit_insn (gen_ptr_extend_plus_imm (this, tmp, delta_rtx));\n+\t  emit_insn (gen_ptr_extend_plus_imm (this_rtx, tmp, delta_rtx));\n \t  delta = 0;\n \t}\n       else\n-\temit_insn (gen_ptr_extend (this, tmp));\n+\temit_insn (gen_ptr_extend (this_rtx, tmp));\n     }\n   if (delta)\n     {\n@@ -9624,7 +9624,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t  emit_move_insn (tmp, delta_rtx);\n \t  delta_rtx = tmp;\n \t}\n-      emit_insn (gen_adddi3 (this, this, delta_rtx));\n+      emit_insn (gen_adddi3 (this_rtx, this_rtx, delta_rtx));\n     }\n \n   /* Apply the offset from the vtable, if required.  */\n@@ -9637,7 +9637,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t{\n \t  rtx t = gen_rtx_REG (ptr_mode, 2);\n \t  REG_POINTER (t) = 1;\n-\t  emit_move_insn (t, gen_rtx_MEM (ptr_mode, this));\n+\t  emit_move_insn (t, gen_rtx_MEM (ptr_mode, this_rtx));\n \t  if (satisfies_constraint_I (vcall_offset_rtx))\n \t    {\n \t      emit_insn (gen_ptr_extend_plus_imm (tmp, t, vcall_offset_rtx));\n@@ -9647,7 +9647,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t    emit_insn (gen_ptr_extend (tmp, t));\n \t}\n       else\n-\temit_move_insn (tmp, gen_rtx_MEM (Pmode, this));\n+\temit_move_insn (tmp, gen_rtx_MEM (Pmode, this_rtx));\n \n       if (vcall_offset)\n \t{\n@@ -9665,7 +9665,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       else\n \temit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));\n \n-      emit_insn (gen_adddi3 (this, this, tmp));\n+      emit_insn (gen_adddi3 (this_rtx, this_rtx, tmp));\n     }\n \n   /* Generate a tail call to the target function.  */"}, {"sha": "06c187bc451bf10973fd62251fa08bdba41249c9", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -937,15 +937,15 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n     {\n       if (p_info->const_add != 0)\n \t{\n-\t  HOST_WIDE_INT new = INTVAL (cmp1) + p_info->const_add;\n+\t  HOST_WIDE_INT new_const = INTVAL (cmp1) + p_info->const_add;\n \n \t  /* If modification of cmp1 caused overflow,\n \t     we would get the wrong answer if we follow the usual path;\n \t     thus, x > 0xffffffffU would turn into x > 0U.  */\n \t  if ((p_info->unsignedp\n-\t       ? (unsigned HOST_WIDE_INT) new >\n+\t       ? (unsigned HOST_WIDE_INT) new_const >\n \t       (unsigned HOST_WIDE_INT) INTVAL (cmp1)\n-\t       : new > INTVAL (cmp1))\n+\t       : new_const > INTVAL (cmp1))\n \t      != (p_info->const_add > 0))\n \t    {\n \t      /* This test is always true, but if INVERT is true then\n@@ -955,7 +955,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n \t      return result;\n \t    }\n \t  else\n-\t    cmp1 = GEN_INT (new);\n+\t    cmp1 = GEN_INT (new_const);\n \t}\n     }\n "}, {"sha": "dcd5b374f931a4ea43561dd455b94931976c6926", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -340,36 +340,36 @@ classes_intersect (int class1, int class2)\n /* Used by m32c_register_move_cost to determine if a move is\n    impossibly expensive.  */\n static int\n-class_can_hold_mode (int class, enum machine_mode mode)\n+class_can_hold_mode (int rclass, enum machine_mode mode)\n {\n   /* Cache the results:  0=untested  1=no  2=yes */\n   static char results[LIM_REG_CLASSES][MAX_MACHINE_MODE];\n-  if (results[class][mode] == 0)\n+  if (results[rclass][mode] == 0)\n     {\n       int r, n, i;\n-      results[class][mode] = 1;\n+      results[rclass][mode] = 1;\n       for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\tif (class_contents[class][0] & (1 << r)\n+\tif (class_contents[rclass][0] & (1 << r)\n \t    && HARD_REGNO_MODE_OK (r, mode))\n \t  {\n \t    int ok = 1;\n \t    n = HARD_REGNO_NREGS (r, mode);\n \t    for (i = 1; i < n; i++)\n-\t      if (!(class_contents[class][0] & (1 << (r + i))))\n+\t      if (!(class_contents[rclass][0] & (1 << (r + i))))\n \t\tok = 0;\n \t    if (ok)\n \t      {\n-\t\tresults[class][mode] = 2;\n+\t\tresults[rclass][mode] = 2;\n \t\tbreak;\n \t      }\n \t  }\n     }\n #if DEBUG0\n   fprintf (stderr, \"class %s can hold %s? %s\\n\",\n-\t   class_names[class], mode_name[mode],\n-\t   (results[class][mode] == 2) ? \"yes\" : \"no\");\n+\t   class_names[rclass], mode_name[mode],\n+\t   (results[rclass][mode] == 2) ? \"yes\" : \"no\");\n #endif\n-  return results[class][mode] == 2;\n+  return results[rclass][mode] == 2;\n }\n \n /* Run-time Target Specification.  */\n@@ -4298,22 +4298,22 @@ m32c_compare_redundant (rtx cmp, rtx *operands)\n char *\n m32c_output_compare (rtx insn, rtx *operands)\n {\n-  static char template[] = \";cmp.b\\t%1,%0\";\n+  static char templ[] = \";cmp.b\\t%1,%0\";\n   /*                             ^ 5  */\n \n-  template[5] = \" bwll\"[GET_MODE_SIZE(GET_MODE(operands[0]))];\n+  templ[5] = \" bwll\"[GET_MODE_SIZE(GET_MODE(operands[0]))];\n   if (m32c_compare_redundant (insn, operands))\n     {\n #if DEBUG_CMP\n       fprintf(stderr, \"cbranch: cmp not needed\\n\");\n #endif\n-      return template;\n+      return templ;\n     }\n \n #if DEBUG_CMP\n-  fprintf(stderr, \"cbranch: cmp needed: `%s'\\n\", template);\n+  fprintf(stderr, \"cbranch: cmp needed: `%s'\\n\", templ);\n #endif\n-  return template + 1;\n+  return templ + 1;\n }\n \n #undef TARGET_ENCODE_SECTION_INFO"}, {"sha": "a52739be67e9d933182b0dc751e11a6472adb0f6", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -435,118 +435,118 @@ m68hc11_hard_regno_rename_ok (int reg1, int reg2)\n }\n \n enum reg_class\n-preferred_reload_class (rtx operand, enum reg_class class)\n+preferred_reload_class (rtx operand, enum reg_class rclass)\n {\n   enum machine_mode mode;\n \n   mode = GET_MODE (operand);\n \n   if (debug_m6811)\n     {\n-      printf (\"Preferred reload: (class=%s): \", reg_class_names[class]);\n+      printf (\"Preferred reload: (class=%s): \", reg_class_names[rclass]);\n     }\n \n-  if (class == D_OR_A_OR_S_REGS && SP_REG_P (operand))\n+  if (rclass == D_OR_A_OR_S_REGS && SP_REG_P (operand))\n     return m68hc11_base_reg_class;\n \n-  if (class >= S_REGS && (GET_CODE (operand) == MEM\n+  if (rclass >= S_REGS && (GET_CODE (operand) == MEM\n \t\t\t  || GET_CODE (operand) == CONST_INT))\n     {\n       /* S_REGS class must not be used.  The movhi template does not\n          work to move a memory to a soft register.\n          Restrict to a hard reg.  */\n-      switch (class)\n+      switch (rclass)\n \t{\n \tdefault:\n \tcase G_REGS:\n \tcase D_OR_A_OR_S_REGS:\n-\t  class = A_OR_D_REGS;\n+\t  rclass = A_OR_D_REGS;\n \t  break;\n \tcase A_OR_S_REGS:\n-\t  class = A_REGS;\n+\t  rclass = A_REGS;\n \t  break;\n \tcase D_OR_SP_OR_S_REGS:\n-\t  class = D_OR_SP_REGS;\n+\t  rclass = D_OR_SP_REGS;\n \t  break;\n \tcase D_OR_Y_OR_S_REGS:\n-\t  class = D_OR_Y_REGS;\n+\t  rclass = D_OR_Y_REGS;\n \t  break;\n \tcase D_OR_X_OR_S_REGS:\n-\t  class = D_OR_X_REGS;\n+\t  rclass = D_OR_X_REGS;\n \t  break;\n \tcase SP_OR_S_REGS:\n-\t  class = SP_REGS;\n+\t  rclass = SP_REGS;\n \t  break;\n \tcase Y_OR_S_REGS:\n-\t  class = Y_REGS;\n+\t  rclass = Y_REGS;\n \t  break;\n \tcase X_OR_S_REGS:\n-\t  class = X_REGS;\n+\t  rclass = X_REGS;\n \t  break;\n \tcase D_OR_S_REGS:\n-\t  class = D_REGS;\n+\t  rclass = D_REGS;\n \t}\n     }\n-  else if (class == Y_REGS && GET_CODE (operand) == MEM)\n+  else if (rclass == Y_REGS && GET_CODE (operand) == MEM)\n     {\n-      class = Y_REGS;\n+      rclass = Y_REGS;\n     }\n-  else if (class == A_OR_D_REGS && GET_MODE_SIZE (mode) == 4)\n+  else if (rclass == A_OR_D_REGS && GET_MODE_SIZE (mode) == 4)\n     {\n-      class = D_OR_X_REGS;\n+      rclass = D_OR_X_REGS;\n     }\n-  else if (class >= S_REGS && S_REG_P (operand))\n+  else if (rclass >= S_REGS && S_REG_P (operand))\n     {\n-      switch (class)\n+      switch (rclass)\n \t{\n \tdefault:\n \tcase G_REGS:\n \tcase D_OR_A_OR_S_REGS:\n-\t  class = A_OR_D_REGS;\n+\t  rclass = A_OR_D_REGS;\n \t  break;\n \tcase A_OR_S_REGS:\n-\t  class = A_REGS;\n+\t  rclass = A_REGS;\n \t  break;\n \tcase D_OR_SP_OR_S_REGS:\n-\t  class = D_OR_SP_REGS;\n+\t  rclass = D_OR_SP_REGS;\n \t  break;\n \tcase D_OR_Y_OR_S_REGS:\n-\t  class = D_OR_Y_REGS;\n+\t  rclass = D_OR_Y_REGS;\n \t  break;\n \tcase D_OR_X_OR_S_REGS:\n-\t  class = D_OR_X_REGS;\n+\t  rclass = D_OR_X_REGS;\n \t  break;\n \tcase SP_OR_S_REGS:\n-\t  class = SP_REGS;\n+\t  rclass = SP_REGS;\n \t  break;\n \tcase Y_OR_S_REGS:\n-\t  class = Y_REGS;\n+\t  rclass = Y_REGS;\n \t  break;\n \tcase X_OR_S_REGS:\n-\t  class = X_REGS;\n+\t  rclass = X_REGS;\n \t  break;\n \tcase D_OR_S_REGS:\n-\t  class = D_REGS;\n+\t  rclass = D_REGS;\n \t}\n     }\n-  else if (class >= S_REGS)\n+  else if (rclass >= S_REGS)\n     {\n       if (debug_m6811)\n \t{\n-\t  printf (\"Class = %s for: \", reg_class_names[class]);\n+\t  printf (\"Class = %s for: \", reg_class_names[rclass]);\n \t  fflush (stdout);\n \t  debug_rtx (operand);\n \t}\n     }\n \n   if (debug_m6811)\n     {\n-      printf (\" => class=%s\\n\", reg_class_names[class]);\n+      printf (\" => class=%s\\n\", reg_class_names[rclass]);\n       fflush (stdout);\n       debug_rtx (operand);\n     }\n \n-  return class;\n+  return rclass;\n }\n \n /* Return 1 if the operand is a valid indexed addressing mode.\n@@ -5097,10 +5097,10 @@ m68hc11_init_libfuncs (void)\n \n /* Cost of moving memory.  */\n int\n-m68hc11_memory_move_cost (enum machine_mode mode, enum reg_class class,\n+m68hc11_memory_move_cost (enum machine_mode mode, enum reg_class rclass,\n                           int in ATTRIBUTE_UNUSED)\n {\n-  if (class <= H_REGS && class > NO_REGS)\n+  if (rclass <= H_REGS && rclass > NO_REGS)\n     {\n       if (GET_MODE_SIZE (mode) <= 2)\n \treturn COSTS_N_INSNS (1) + (reload_completed | reload_in_progress);"}, {"sha": "b80f59f476c62a402b8411fd4b5f1126af4d973d", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -2602,30 +2602,30 @@ mcore_r15_operand_p (rtx x)\n     }\n }\n \n-/* Implement SECONDARY_RELOAD_CLASS.  If CLASS contains r15, and we can't\n+/* Implement SECONDARY_RELOAD_CLASS.  If RCLASS contains r15, and we can't\n    directly move X into it, use r1-r14 as a temporary.  */\n \n enum reg_class\n-mcore_secondary_reload_class (enum reg_class class,\n+mcore_secondary_reload_class (enum reg_class rclass,\n \t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n-  if (TEST_HARD_REG_BIT (reg_class_contents[class], 15)\n+  if (TEST_HARD_REG_BIT (reg_class_contents[rclass], 15)\n       && !mcore_r15_operand_p (x))\n     return LRW_REGS;\n   return NO_REGS;\n }\n \n /* Return the reg_class to use when reloading the rtx X into the class\n-   CLASS.  If X is too complex to move directly into r15, prefer to\n+   RCLASS.  If X is too complex to move directly into r15, prefer to\n    use LRW_REGS instead.  */\n \n enum reg_class\n-mcore_reload_class (rtx x, enum reg_class class)\n+mcore_reload_class (rtx x, enum reg_class rclass)\n {\n-  if (reg_class_subset_p (LRW_REGS, class) && !mcore_r15_operand_p (x))\n+  if (reg_class_subset_p (LRW_REGS, rclass) && !mcore_r15_operand_p (x))\n     return LRW_REGS;\n \n-  return class;\n+  return rclass;\n }\n \n /* Tell me if a pair of reg/subreg rtx's actually refer to the same"}, {"sha": "925a5b7fffccccb83d3101508fe1bcc5ad0b75f7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -8952,7 +8952,7 @@ static bool\n mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n {\n   unsigned int size;\n-  enum mode_class class;\n+  enum mode_class mclass;\n \n   if (mode == CCV2mode)\n     return (ISA_HAS_8CC\n@@ -8975,7 +8975,7 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n     }\n \n   size = GET_MODE_SIZE (mode);\n-  class = GET_MODE_CLASS (mode);\n+  mclass = GET_MODE_CLASS (mode);\n \n   if (GP_REG_P (regno))\n     return ((regno - GP_REG_FIRST) & 1) == 0 || size <= UNITS_PER_WORD;\n@@ -8996,16 +8996,16 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n \t      || mode == DImode))\n \treturn true;\n \n-      if (class == MODE_FLOAT\n-\t  || class == MODE_COMPLEX_FLOAT\n-\t  || class == MODE_VECTOR_FLOAT)\n+      if (mclass == MODE_FLOAT\n+\t  || mclass == MODE_COMPLEX_FLOAT\n+\t  || mclass == MODE_VECTOR_FLOAT)\n \treturn size <= UNITS_PER_FPVALUE;\n \n       /* Allow integer modes that fit into a single register.  We need\n \t to put integers into FPRs when using instructions like CVT\n \t and TRUNC.  There's no point allowing sizes smaller than a word,\n \t because the FPU has no appropriate load/store instructions.  */\n-      if (class == MODE_INT)\n+      if (mclass == MODE_INT)\n \treturn size >= MIN_UNITS_PER_WORD && size <= UNITS_PER_FPREG;\n     }\n \n@@ -9039,7 +9039,7 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n     }\n \n   if (ALL_COP_REG_P (regno))\n-    return class == MODE_INT && size <= UNITS_PER_WORD;\n+    return mclass == MODE_INT && size <= UNITS_PER_WORD;\n \n   if (regno == GOT_VERSION_REGNUM)\n     return mode == SImode;\n@@ -9068,13 +9068,13 @@ mips_hard_regno_nregs (int regno, enum machine_mode mode)\n    in mips_hard_regno_nregs.  */\n \n int\n-mips_class_max_nregs (enum reg_class class, enum machine_mode mode)\n+mips_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n {\n   int size;\n   HARD_REG_SET left;\n \n   size = 0x8000;\n-  COPY_HARD_REG_SET (left, reg_class_contents[(int) class]);\n+  COPY_HARD_REG_SET (left, reg_class_contents[(int) rclass]);\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) ST_REGS]))\n     {\n       size = MIN (size, 4);\n@@ -9095,7 +9095,7 @@ mips_class_max_nregs (enum reg_class class, enum machine_mode mode)\n bool\n mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n \t\t\t       enum machine_mode to ATTRIBUTE_UNUSED,\n-\t\t\t       enum reg_class class)\n+\t\t\t       enum reg_class rclass)\n {\n   /* There are several problems with changing the modes of values\n      in floating-point registers:\n@@ -9118,7 +9118,7 @@ mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n        not ask it to treat the value as having a different format.\n \n      We therefore disallow all mode changes involving FPRs.  */\n-  return reg_classes_intersect_p (FP_REGS, class);\n+  return reg_classes_intersect_p (FP_REGS, rclass);\n }\n \n /* Return true if moves in mode MODE can use the FPU's mov.fmt instruction.  */\n@@ -9157,22 +9157,22 @@ mips_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n /* Implement PREFERRED_RELOAD_CLASS.  */\n \n enum reg_class\n-mips_preferred_reload_class (rtx x, enum reg_class class)\n+mips_preferred_reload_class (rtx x, enum reg_class rclass)\n {\n-  if (mips_dangerous_for_la25_p (x) && reg_class_subset_p (LEA_REGS, class))\n+  if (mips_dangerous_for_la25_p (x) && reg_class_subset_p (LEA_REGS, rclass))\n     return LEA_REGS;\n \n-  if (reg_class_subset_p (FP_REGS, class)\n+  if (reg_class_subset_p (FP_REGS, rclass)\n       && mips_mode_ok_for_mov_fmt_p (GET_MODE (x)))\n     return FP_REGS;\n \n-  if (reg_class_subset_p (GR_REGS, class))\n-    class = GR_REGS;\n+  if (reg_class_subset_p (GR_REGS, rclass))\n+    rclass = GR_REGS;\n \n-  if (TARGET_MIPS16 && reg_class_subset_p (M16_REGS, class))\n-    class = M16_REGS;\n+  if (TARGET_MIPS16 && reg_class_subset_p (M16_REGS, rclass))\n+    rclass = M16_REGS;\n \n-  return class;\n+  return rclass;\n }\n \n /* Implement REGISTER_MOVE_COST.  */\n@@ -9234,48 +9234,48 @@ mips_register_move_cost (enum machine_mode mode,\n }\n \n /* Return the register class required for a secondary register when\n-   copying between one of the registers in CLASS and value X, which\n+   copying between one of the registers in RCLASS and value X, which\n    has mode MODE.  X is the source of the move if IN_P, otherwise it\n    is the destination.  Return NO_REGS if no secondary register is\n    needed.  */\n \n enum reg_class\n-mips_secondary_reload_class (enum reg_class class,\n+mips_secondary_reload_class (enum reg_class rclass,\n \t\t\t     enum machine_mode mode, rtx x, bool in_p)\n {\n   int regno;\n \n   /* If X is a constant that cannot be loaded into $25, it must be loaded\n      into some other GPR.  No other register class allows a direct move.  */\n   if (mips_dangerous_for_la25_p (x))\n-    return reg_class_subset_p (class, LEA_REGS) ? NO_REGS : LEA_REGS;\n+    return reg_class_subset_p (rclass, LEA_REGS) ? NO_REGS : LEA_REGS;\n \n   regno = true_regnum (x);\n   if (TARGET_MIPS16)\n     {\n       /* In MIPS16 mode, every move must involve a member of M16_REGS.  */\n-      if (!reg_class_subset_p (class, M16_REGS) && !M16_REG_P (regno))\n+      if (!reg_class_subset_p (rclass, M16_REGS) && !M16_REG_P (regno))\n \treturn M16_REGS;\n \n       /* We can't really copy to HI or LO at all in MIPS16 mode.  */\n-      if (in_p ? reg_classes_intersect_p (class, ACC_REGS) : ACC_REG_P (regno))\n+      if (in_p ? reg_classes_intersect_p (rclass, ACC_REGS) : ACC_REG_P (regno))\n \treturn M16_REGS;\n \n       return NO_REGS;\n     }\n \n   /* Copying from accumulator registers to anywhere other than a general\n      register requires a temporary general register.  */\n-  if (reg_class_subset_p (class, ACC_REGS))\n+  if (reg_class_subset_p (rclass, ACC_REGS))\n     return GP_REG_P (regno) ? NO_REGS : GR_REGS;\n   if (ACC_REG_P (regno))\n-    return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n+    return reg_class_subset_p (rclass, GR_REGS) ? NO_REGS : GR_REGS;\n \n   /* We can only copy a value to a condition code register from a\n      floating-point register, and even then we require a scratch\n      floating-point register.  We can only copy a value out of a\n      condition-code register into a general register.  */\n-  if (reg_class_subset_p (class, ST_REGS))\n+  if (reg_class_subset_p (rclass, ST_REGS))\n     {\n       if (in_p)\n \treturn FP_REGS;\n@@ -9285,10 +9285,10 @@ mips_secondary_reload_class (enum reg_class class,\n     {\n       if (!in_p)\n \treturn FP_REGS;\n-      return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n+      return reg_class_subset_p (rclass, GR_REGS) ? NO_REGS : GR_REGS;\n     }\n \n-  if (reg_class_subset_p (class, FP_REGS))\n+  if (reg_class_subset_p (rclass, FP_REGS))\n     {\n       if (MEM_P (x)\n \t  && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8))\n@@ -9314,7 +9314,7 @@ mips_secondary_reload_class (enum reg_class class,\n       return GR_REGS;\n     }\n   if (FP_REG_P (regno))\n-    return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n+    return reg_class_subset_p (rclass, GR_REGS) ? NO_REGS : GR_REGS;\n \n   return NO_REGS;\n }\n@@ -12217,7 +12217,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t      tree function)\n {\n-  rtx this, temp1, temp2, insn, fnaddr;\n+  rtx this_rtx, temp1, temp2, insn, fnaddr;\n   bool use_sibcall_p;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n@@ -12257,11 +12257,11 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find out which register contains the \"this\" pointer.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, GP_ARG_FIRST + 1);\n+    this_rtx = gen_rtx_REG (Pmode, GP_ARG_FIRST + 1);\n   else\n-    this = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n+    this_rtx = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n \n-  /* Add DELTA to THIS.  */\n+  /* Add DELTA to THIS_RTX.  */\n   if (delta != 0)\n     {\n       rtx offset = GEN_INT (delta);\n@@ -12270,23 +12270,23 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  mips_emit_move (temp1, offset);\n \t  offset = temp1;\n \t}\n-      emit_insn (gen_add3_insn (this, this, offset));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n     }\n \n-  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n   if (vcall_offset != 0)\n     {\n       rtx addr;\n \n-      /* Set TEMP1 to *THIS.  */\n-      mips_emit_move (temp1, gen_rtx_MEM (Pmode, this));\n+      /* Set TEMP1 to *THIS_RTX.  */\n+      mips_emit_move (temp1, gen_rtx_MEM (Pmode, this_rtx));\n \n-      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n       addr = mips_add_offset (temp2, temp1, vcall_offset);\n \n-      /* Load the offset and add it to THIS.  */\n+      /* Load the offset and add it to THIS_RTX.  */\n       mips_emit_move (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this, this, temp1));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n     }\n \n   /* Jump to the target function.  Use a sibcall if direct jumps are"}, {"sha": "e57f52dd796eea55ca66a57dd36c6e0a7fd83853", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -353,37 +353,37 @@ mmix_local_regno (int regno)\n    We need to extend the reload class of REMAINDER_REG and HIMULT_REG.  */\n \n enum reg_class\n-mmix_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+mmix_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n   /* FIXME: Revisit.  */\n   return GET_CODE (x) == MOD && GET_MODE (x) == DImode\n-    ? REMAINDER_REG : class;\n+    ? REMAINDER_REG : rclass;\n }\n \n /* PREFERRED_OUTPUT_RELOAD_CLASS.\n    We need to extend the reload class of REMAINDER_REG and HIMULT_REG.  */\n \n enum reg_class\n mmix_preferred_output_reload_class (rtx x ATTRIBUTE_UNUSED,\n-\t\t\t\t    enum reg_class class)\n+\t\t\t\t    enum reg_class rclass)\n {\n   /* FIXME: Revisit.  */\n   return GET_CODE (x) == MOD && GET_MODE (x) == DImode\n-    ? REMAINDER_REG : class;\n+    ? REMAINDER_REG : rclass;\n }\n \n /* SECONDARY_RELOAD_CLASS.\n    We need to reload regs of REMAINDER_REG and HIMULT_REG elsewhere.  */\n \n enum reg_class\n-mmix_secondary_reload_class (enum reg_class class,\n+mmix_secondary_reload_class (enum reg_class rclass,\n \t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     rtx x ATTRIBUTE_UNUSED,\n \t\t\t     int in_p ATTRIBUTE_UNUSED)\n {\n-  if (class == REMAINDER_REG\n-      || class == HIMULT_REG\n-      || class == SYSTEM_REGS)\n+  if (rclass == REMAINDER_REG\n+      || rclass == HIMULT_REG\n+      || rclass == SYSTEM_REGS)\n     return GENERAL_REGS;\n \n   return NO_REGS;"}, {"sha": "6f172fc0b26e0f077ed466d071fdef6c3d044835", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1319,11 +1319,11 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n /* What (if any) secondary registers are needed to move IN with mode\n-   MODE into a register in register class CLASS.\n+   MODE into a register in register class RCLASS.\n \n    We might be able to simplify this.  */\n enum reg_class\n-mn10300_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n+mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t\t\t\trtx in)\n {\n   /* Memory loads less than a full word wide can't have an\n@@ -1336,8 +1336,8 @@ mn10300_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n \t   && GET_CODE (SUBREG_REG (in)) == REG\n \t   && REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER))\n       && (mode == QImode || mode == HImode)\n-      && (class == ADDRESS_REGS || class == SP_REGS\n-\t  || class == SP_OR_ADDRESS_REGS))\n+      && (rclass == ADDRESS_REGS || rclass == SP_REGS\n+\t  || rclass == SP_OR_ADDRESS_REGS))\n     {\n       if (TARGET_AM33)\n \treturn DATA_OR_EXTENDED_REGS;\n@@ -1346,12 +1346,12 @@ mn10300_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n \n   /* We can't directly load sp + const_int into a data register;\n      we must use an address register as an intermediate.  */\n-  if (class != SP_REGS\n-      && class != ADDRESS_REGS\n-      && class != SP_OR_ADDRESS_REGS\n-      && class != SP_OR_EXTENDED_REGS\n-      && class != ADDRESS_OR_EXTENDED_REGS\n-      && class != SP_OR_ADDRESS_OR_EXTENDED_REGS\n+  if (rclass != SP_REGS\n+      && rclass != ADDRESS_REGS\n+      && rclass != SP_OR_ADDRESS_REGS\n+      && rclass != SP_OR_EXTENDED_REGS\n+      && rclass != ADDRESS_OR_EXTENDED_REGS\n+      && rclass != SP_OR_ADDRESS_OR_EXTENDED_REGS\n       && (in == stack_pointer_rtx\n \t  || (GET_CODE (in) == PLUS\n \t      && (XEXP (in, 0) == stack_pointer_rtx\n@@ -1363,7 +1363,7 @@ mn10300_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n \t  || XEXP (in, 1) == stack_pointer_rtx))\n     return GENERAL_REGS;\n \n-  if (TARGET_AM33_2 && class == FP_REGS\n+  if (TARGET_AM33_2 && rclass == FP_REGS\n       && GET_CODE (in) == MEM\n       && ! (GET_CODE (in) == MEM && !CONSTANT_ADDRESS_P (XEXP (in, 0))))\n     {"}, {"sha": "9ff778b5b47d3c4f9884b5022989d4797c1532a8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -5684,19 +5684,19 @@ output_arg_descriptor (rtx call_insn)\n }\n \f\n static enum reg_class\n-pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+pa_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n {\n   int is_symbolic, regno;\n \n   /* Handle the easy stuff first.  */\n-  if (class == R1_REGS)\n+  if (rclass == R1_REGS)\n     return NO_REGS;\n \n   if (REG_P (x))\n     {\n       regno = REGNO (x);\n-      if (class == BASE_REG_CLASS && regno < FIRST_PSEUDO_REGISTER)\n+      if (rclass == BASE_REG_CLASS && regno < FIRST_PSEUDO_REGISTER)\n \treturn NO_REGS;\n     }\n   else\n@@ -5712,7 +5712,7 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n      generation requires %r1 as a scratch register.  */\n   if (flag_pic\n       && (mode == SImode || mode == DImode)\n-      && FP_REG_CLASS_P (class)\n+      && FP_REG_CLASS_P (rclass)\n       && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n       sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n@@ -5735,7 +5735,7 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n      memory loads and stores.  */\n   if ((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n       && GET_MODE_CLASS (mode) == MODE_INT\n-      && FP_REG_CLASS_P (class))\n+      && FP_REG_CLASS_P (rclass))\n     {\n       /* Reload passes (mem:SI (reg/f:DI 30 %r30) when it wants to check\n \t the secondary reload needed for a pseudo.  It never passes a\n@@ -5767,7 +5767,7 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n \n   /* We need a secondary register (GPR) for copies between the SAR\n      and anything other than a general register.  */\n-  if (class == SHIFT_REGS && (regno <= 0 || regno >= 32))\n+  if (rclass == SHIFT_REGS && (regno <= 0 || regno >= 32))\n     {\n       sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n       return NO_REGS;\n@@ -5777,7 +5777,7 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n      well as secondary memory.  */\n   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n       && (REGNO_REG_CLASS (regno) == SHIFT_REGS\n-      && FP_REG_CLASS_P (class)))\n+      && FP_REG_CLASS_P (rclass)))\n     {\n       sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n       return NO_REGS;\n@@ -8831,7 +8831,7 @@ pa_reorg (void)\n static void\n pa_combine_instructions (void)\n {\n-  rtx anchor, new;\n+  rtx anchor, new_rtx;\n \n   /* This can get expensive since the basic algorithm is on the\n      order of O(n^2) (or worse).  Only do it for -O2 or higher\n@@ -8843,8 +8843,8 @@ pa_combine_instructions (void)\n      may be combined with \"floating\" insns.  As the name implies,\n      \"anchor\" instructions don't move, while \"floating\" insns may\n      move around.  */\n-  new = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n-  new = make_insn_raw (new);\n+  new_rtx = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, NULL_RTX, NULL_RTX));\n+  new_rtx = make_insn_raw (new_rtx);\n \n   for (anchor = get_insns (); anchor; anchor = NEXT_INSN (anchor))\n     {\n@@ -8900,7 +8900,7 @@ pa_combine_instructions (void)\n \t\t{\n \t\t  /* If ANCHOR and FLOATER can be combined, then we're\n \t\t     done with this pass.  */\n-\t\t  if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t  if (pa_can_combine_p (new_rtx, anchor, floater, 0,\n \t\t\t\t\tSET_DEST (PATTERN (floater)),\n \t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 0),\n \t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 1)))\n@@ -8912,15 +8912,15 @@ pa_combine_instructions (void)\n \t\t{\n \t\t  if (GET_CODE (SET_SRC (PATTERN (floater))) == PLUS)\n \t\t    {\n-\t\t      if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t      if (pa_can_combine_p (new_rtx, anchor, floater, 0,\n \t\t\t\t\t    SET_DEST (PATTERN (floater)),\n \t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 0),\n \t\t\t\t\tXEXP (SET_SRC (PATTERN (floater)), 1)))\n \t\t\tbreak;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      if (pa_can_combine_p (new, anchor, floater, 0,\n+\t\t      if (pa_can_combine_p (new_rtx, anchor, floater, 0,\n \t\t\t\t\t    SET_DEST (PATTERN (floater)),\n \t\t\t\t\t    SET_SRC (PATTERN (floater)),\n \t\t\t\t\t    SET_SRC (PATTERN (floater))))\n@@ -8962,7 +8962,7 @@ pa_combine_instructions (void)\n \t\t    {\n \t\t      /* If ANCHOR and FLOATER can be combined, then we're\n \t\t\t done with this pass.  */\n-\t\t      if (pa_can_combine_p (new, anchor, floater, 1,\n+\t\t      if (pa_can_combine_p (new_rtx, anchor, floater, 1,\n \t\t\t\t\t    SET_DEST (PATTERN (floater)),\n \t\t\t\t\t    XEXP (SET_SRC (PATTERN (floater)),\n \t\t\t\t\t\t  0),\n@@ -9021,7 +9021,7 @@ pa_combine_instructions (void)\n }\n \n static int\n-pa_can_combine_p (rtx new, rtx anchor, rtx floater, int reversed, rtx dest,\n+pa_can_combine_p (rtx new_rtx, rtx anchor, rtx floater, int reversed, rtx dest,\n \t\t  rtx src1, rtx src2)\n {\n   int insn_code_number;\n@@ -9034,12 +9034,12 @@ pa_can_combine_p (rtx new, rtx anchor, rtx floater, int reversed, rtx dest,\n      If the pattern doesn't match or the constraints\n      aren't met keep searching for a suitable floater\n      insn.  */\n-  XVECEXP (PATTERN (new), 0, 0) = PATTERN (anchor);\n-  XVECEXP (PATTERN (new), 0, 1) = PATTERN (floater);\n-  INSN_CODE (new) = -1;\n-  insn_code_number = recog_memoized (new);\n+  XVECEXP (PATTERN (new_rtx), 0, 0) = PATTERN (anchor);\n+  XVECEXP (PATTERN (new_rtx), 0, 1) = PATTERN (floater);\n+  INSN_CODE (new_rtx) = -1;\n+  insn_code_number = recog_memoized (new_rtx);\n   if (insn_code_number < 0\n-      || (extract_insn (new), ! constrain_operands (1)))\n+      || (extract_insn (new_rtx), ! constrain_operands (1)))\n     return 0;\n \n   if (reversed)\n@@ -9652,11 +9652,11 @@ pa_hpux_file_end (void)\n #endif\n \n /* Return true if a change from mode FROM to mode TO for a register\n-   in register class CLASS is invalid.  */\n+   in register class RCLASS is invalid.  */\n \n bool\n pa_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n-\t\t\t     enum reg_class class)\n+\t\t\t     enum reg_class rclass)\n {\n   if (from == to)\n     return false;\n@@ -9674,7 +9674,7 @@ pa_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n      On the 64-bit target, this conflicts with the definition of\n      LOAD_EXTEND_OP.  Thus, we can't allow changing between modes\n      with different sizes in the floating-point registers.  */\n-  if (MAYBE_FP_REG_CLASS_P (class))\n+  if (MAYBE_FP_REG_CLASS_P (rclass))\n     return true;\n \n   /* HARD_REGNO_MODE_OK places modes with sizes larger than a word"}, {"sha": "610bcf5da3c7b07b607117c1ed092cb8dec6972e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1377,7 +1377,7 @@ extern int may_call_alloca;\n #define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN) \t\\\n do { \t\t\t\t\t\t\t\t\t\\\n   long offset, newoffset, mask;\t\t\t\t\t\t\\\n-  rtx new, temp = NULL_RTX;\t\t\t\t\t\t\\\n+  rtx new_rtx, temp = NULL_RTX;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   mask = (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n \t  ? (INT14_OK_STRICT ? 0x3fff : 0x1f) : 0x3fff);\t\t\\\n@@ -1386,14 +1386,14 @@ do { \t\t\t\t\t\t\t\t\t\\\n     temp = simplify_binary_operation (PLUS, Pmode,\t\t\t\\\n \t\t\t\t      XEXP (AD, 0), XEXP (AD, 1));\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  new = temp ? temp : AD;\t\t\t\t\t\t\\\n+  new_rtx = temp ? temp : AD;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (optimize\t\t\t\t\t\t\t\t\\\n-      && GET_CODE (new) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (new, 0)) == REG\t\t\t\t\\\n-      && GET_CODE (XEXP (new, 1)) == CONST_INT)\t\t\t\t\\\n+      && GET_CODE (new_rtx) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (new_rtx, 0)) == REG\t\t\t\t\\\n+      && GET_CODE (XEXP (new_rtx, 1)) == CONST_INT)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      offset = INTVAL (XEXP ((new), 1));\t\t\t\t\\\n+      offset = INTVAL (XEXP ((new_rtx), 1));\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       /* Choose rounding direction.  Round up if we are >= halfway.  */\t\\\n       if ((offset & mask) >= ((mask + 1) / 2))\t\t\t\t\\\n@@ -1409,7 +1409,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (newoffset != 0 && VAL_14_BITS_P (newoffset))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  temp = gen_rtx_PLUS (Pmode, XEXP (new, 0),\t\t\t\\\n+\t  temp = gen_rtx_PLUS (Pmode, XEXP (new_rtx, 0),\t\t\t\\\n \t\t\t       GEN_INT (newoffset));\t\t\t\\\n \t  AD = gen_rtx_PLUS (Pmode, temp, GEN_INT (offset - newoffset));\\\n \t  push_reload (XEXP (AD, 0), 0, &XEXP (AD, 0), 0,\t\t\\"}, {"sha": "2494056eabe1e47281560f5cb615462dc52897cb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -2849,7 +2849,7 @@ paired_expand_vector_init (rtx target, rtx vals)\n   enum machine_mode mode = GET_MODE (target);\n   int n_elts = GET_MODE_NUNITS (mode);\n   int n_var = 0;\n-  rtx x, new, tmp, constant_op, op1, op2;\n+  rtx x, new_rtx, tmp, constant_op, op1, op2;\n   int i;\n \n   for (i = 0; i < n_elts; ++i)\n@@ -2868,10 +2868,10 @@ paired_expand_vector_init (rtx target, rtx vals)\n   if (n_var == 2)\n     {\n       /* The vector is initialized only with non-constants.  */\n-      new = gen_rtx_VEC_CONCAT (V2SFmode, XVECEXP (vals, 0, 0),\n+      new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, XVECEXP (vals, 0, 0),\n \t\t\t\tXVECEXP (vals, 0, 1));\n \n-      emit_move_insn (target, new);\n+      emit_move_insn (target, new_rtx);\n       return;\n     }\n   \n@@ -2887,11 +2887,11 @@ paired_expand_vector_init (rtx target, rtx vals)\n   emit_move_insn (tmp, constant_op);\n \n   if (CONSTANT_P (op1))\n-    new = gen_rtx_VEC_CONCAT (V2SFmode, tmp, op2);\n+    new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, tmp, op2);\n   else\n-    new = gen_rtx_VEC_CONCAT (V2SFmode, op1, tmp);\n+    new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, op1, tmp);\n \n-  emit_move_insn (target, new);\n+  emit_move_insn (target, new_rtx);\n }\n \n void\n@@ -11370,11 +11370,11 @@ rs6000_instantiate_decls (void)\n }\n \n /* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n+   or out of a register in RCLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n \n enum reg_class\n-rs6000_secondary_reload_class (enum reg_class class,\n+rs6000_secondary_reload_class (enum reg_class rclass,\n \t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       rtx in)\n {\n@@ -11393,7 +11393,7 @@ rs6000_secondary_reload_class (enum reg_class class,\n \n \t On Darwin, pic addresses require a load from memory, which\n \t needs a base register.  */\n-      if (class != BASE_REGS\n+      if (rclass != BASE_REGS\n \t  && (GET_CODE (in) == SYMBOL_REF\n \t      || GET_CODE (in) == HIGH\n \t      || GET_CODE (in) == LABEL_REF\n@@ -11422,22 +11422,22 @@ rs6000_secondary_reload_class (enum reg_class class,\n \n   /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n      into anything.  */\n-  if (class == GENERAL_REGS || class == BASE_REGS\n+  if (rclass == GENERAL_REGS || rclass == BASE_REGS\n       || (regno >= 0 && INT_REGNO_P (regno)))\n     return NO_REGS;\n \n   /* Constants, memory, and FP registers can go into FP registers.  */\n   if ((regno == -1 || FP_REGNO_P (regno))\n-      && (class == FLOAT_REGS || class == NON_SPECIAL_REGS))\n+      && (rclass == FLOAT_REGS || rclass == NON_SPECIAL_REGS))\n     return (mode != SDmode) ? NO_REGS : GENERAL_REGS;\n \n   /* Memory, and AltiVec registers can go into AltiVec registers.  */\n   if ((regno == -1 || ALTIVEC_REGNO_P (regno))\n-      && class == ALTIVEC_REGS)\n+      && rclass == ALTIVEC_REGS)\n     return NO_REGS;\n \n   /* We can copy among the CR registers.  */\n-  if ((class == CR_REGS || class == CR0_REGS)\n+  if ((rclass == CR_REGS || rclass == CR0_REGS)\n       && regno >= 0 && CR_REGNO_P (regno))\n     return NO_REGS;\n \n@@ -17578,7 +17578,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t\tHOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t\ttree function)\n {\n-  rtx this, insn, funexp;\n+  rtx this_rtx, insn, funexp;\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n@@ -17589,17 +17589,17 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Find the \"this\" pointer.  If the function returns a structure,\n      the structure return pointer is in r3.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, 4);\n+    this_rtx = gen_rtx_REG (Pmode, 4);\n   else\n-    this = gen_rtx_REG (Pmode, 3);\n+    this_rtx = gen_rtx_REG (Pmode, 3);\n \n   /* Apply the constant offset, if required.  */\n   if (delta)\n     {\n       rtx delta_rtx = GEN_INT (delta);\n       emit_insn (TARGET_32BIT\n-\t\t ? gen_addsi3 (this, this, delta_rtx)\n-\t\t : gen_adddi3 (this, this, delta_rtx));\n+\t\t ? gen_addsi3 (this_rtx, this_rtx, delta_rtx)\n+\t\t : gen_adddi3 (this_rtx, this_rtx, delta_rtx));\n     }\n \n   /* Apply the offset from the vtable, if required.  */\n@@ -17608,7 +17608,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       rtx vcall_offset_rtx = GEN_INT (vcall_offset);\n       rtx tmp = gen_rtx_REG (Pmode, 12);\n \n-      emit_move_insn (tmp, gen_rtx_MEM (Pmode, this));\n+      emit_move_insn (tmp, gen_rtx_MEM (Pmode, this_rtx));\n       if (((unsigned HOST_WIDE_INT) vcall_offset) + 0x8000 >= 0x10000)\n \t{\n \t  emit_insn (TARGET_32BIT\n@@ -17623,8 +17623,8 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  emit_move_insn (tmp, gen_rtx_MEM (Pmode, loc));\n \t}\n       emit_insn (TARGET_32BIT\n-\t\t ? gen_addsi3 (this, this, tmp)\n-\t\t : gen_adddi3 (this, this, tmp));\n+\t\t ? gen_addsi3 (this_rtx, this_rtx, tmp)\n+\t\t : gen_adddi3 (this_rtx, this_rtx, tmp));\n     }\n \n   /* Generate a tail call to the target function.  */\n@@ -20520,12 +20520,12 @@ rs6000_elf_encode_section_info (tree decl, rtx rtl, int first)\n }\n \n static inline bool\n-compare_section_name (const char *section, const char *template)\n+compare_section_name (const char *section, const char *templ)\n {\n   int len;\n \n-  len = strlen (template);\n-  return (strncmp (section, template, len) == 0\n+  len = strlen (templ);\n+  return (strncmp (section, templ, len) == 0\n \t  && (section[len] == 0 || section[len] == '.'));\n }\n \n@@ -21813,17 +21813,17 @@ rs6000_register_move_cost (enum machine_mode mode,\n    or from memory.  */\n \n int\n-rs6000_memory_move_cost (enum machine_mode mode, enum reg_class class,\n+rs6000_memory_move_cost (enum machine_mode mode, enum reg_class rclass,\n \t\t\t int in ATTRIBUTE_UNUSED)\n {\n-  if (reg_classes_intersect_p (class, GENERAL_REGS))\n+  if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n     return 4 * hard_regno_nregs[0][mode];\n-  else if (reg_classes_intersect_p (class, FLOAT_REGS))\n+  else if (reg_classes_intersect_p (rclass, FLOAT_REGS))\n     return 4 * hard_regno_nregs[32][mode];\n-  else if (reg_classes_intersect_p (class, ALTIVEC_REGS))\n+  else if (reg_classes_intersect_p (rclass, ALTIVEC_REGS))\n     return 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n   else\n-    return 4 + rs6000_register_move_cost (mode, class, GENERAL_REGS);\n+    return 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);\n }\n \n /* Returns a code for a target-specific builtin that implements"}, {"sha": "9d60c44254225a164172f1f1cef5248b4a45530c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 148, "deletions": 148, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -836,17 +836,17 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n   return ret;\n }\n \n-/* Emit a SImode compare and swap instruction setting MEM to NEW if OLD\n+/* Emit a SImode compare and swap instruction setting MEM to NEW_RTX if OLD\n    matches CMP.\n    Return the correct condition RTL to be placed in the IF_THEN_ELSE of the\n    conditional branch testing the result.  */\n \n static rtx\n-s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem, rtx cmp, rtx new)\n+s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem, rtx cmp, rtx new_rtx)\n {\n   rtx ret;\n \n-  emit_insn (gen_sync_compare_and_swap_ccsi (old, mem, cmp, new));\n+  emit_insn (gen_sync_compare_and_swap_ccsi (old, mem, cmp, new_rtx));\n   ret = gen_rtx_fmt_ee (code, VOIDmode, s390_compare_emitted, const0_rtx);\n \n   s390_compare_emitted = NULL_RTX;\n@@ -2758,11 +2758,11 @@ legitimate_reload_constant_p (rtx op)\n   return false;\n }\n \n-/* Given an rtx OP being reloaded into a reg required to be in class CLASS,\n+/* Given an rtx OP being reloaded into a reg required to be in class RCLASS,\n    return the class of reg to actually use.  */\n \n enum reg_class\n-s390_preferred_reload_class (rtx op, enum reg_class class)\n+s390_preferred_reload_class (rtx op, enum reg_class rclass)\n {\n   switch (GET_CODE (op))\n     {\n@@ -2772,7 +2772,7 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n       case CONST_DOUBLE:\n       case CONST_INT:\n \tif (legitimate_reload_constant_p (op))\n-\t  return class;\n+\t  return rclass;\n \telse\n \t  return NO_REGS;\n \n@@ -2784,7 +2784,7 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n       case LABEL_REF:\n       case SYMBOL_REF:\n       case CONST:\n-\tif (reg_class_subset_p (ADDR_REGS, class))\n+\tif (reg_class_subset_p (ADDR_REGS, rclass))\n           return ADDR_REGS;\n \telse\n \t  return NO_REGS;\n@@ -2793,7 +2793,7 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n \tbreak;\n     }\n \n-  return class;\n+  return rclass;\n }\n \n /* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int\n@@ -2923,15 +2923,15 @@ s390_reload_symref_address (rtx reg, rtx mem, rtx scratch, bool tomem)\n }\n \n /* Inform reload about cases where moving X with a mode MODE to a register in\n-   CLASS requires an extra scratch or immediate register.  Return the class\n+   RCLASS requires an extra scratch or immediate register.  Return the class\n    needed for the immediate register.  */\n \n static enum reg_class\n-s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+s390_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t       enum machine_mode mode, secondary_reload_info *sri)\n {\n   /* Intermediate register needed.  */\n-  if (reg_classes_intersect_p (CC_REGS, class))\n+  if (reg_classes_intersect_p (CC_REGS, rclass))\n     return GENERAL_REGS;\n \n   if (TARGET_Z10)\n@@ -3007,12 +3007,12 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n       /* For GENERAL_REGS a displacement overflow is no problem if occurring\n \t in a s_operand address since we may fallback to lm/stm.  So we only\n \t have to care about overflows in the b+i+d case.  */\n-      if ((reg_classes_intersect_p (GENERAL_REGS, class)\n+      if ((reg_classes_intersect_p (GENERAL_REGS, rclass)\n \t   && s390_class_max_nregs (GENERAL_REGS, mode) > 1\n \t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS)\n \t  /* For FP_REGS no lm/stm is available so this check is triggered\n \t     for displacement overflows in b+i+d and b+d like addresses.  */\n-\t  || (reg_classes_intersect_p (FP_REGS, class)\n+\t  || (reg_classes_intersect_p (FP_REGS, rclass)\n \t      && s390_class_max_nregs (FP_REGS, mode) > 1))\n \t{\n \t  if (in_p)\n@@ -3029,7 +3029,7 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n   /* A scratch address register is needed when a symbolic constant is\n      copied to r0 compiling with -fPIC.  In other cases the target\n      register might be used as temporary (see legitimize_pic_address).  */\n-  if (in_p && SYMBOLIC_CONST (x) && flag_pic == 2 && class != ADDR_REGS)\n+  if (in_p && SYMBOLIC_CONST (x) && flag_pic == 2 && rclass != ADDR_REGS)\n     sri->icode = (TARGET_64BIT ?\n \t\t  CODE_FOR_reloaddi_PIC_addr :\n \t\t  CODE_FOR_reloadsi_PIC_addr);\n@@ -3218,7 +3218,7 @@ rtx\n legitimize_pic_address (rtx orig, rtx reg)\n {\n   rtx addr = orig;\n-  rtx new = orig;\n+  rtx new_rtx = orig;\n   rtx base;\n \n   gcc_assert (!TLS_SYMBOLIC_CONST (addr));\n@@ -3247,11 +3247,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n           addr = force_const_mem (Pmode, addr);\n \t  emit_move_insn (temp, addr);\n \n-          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n           if (reg != 0)\n             {\n-              s390_load_address (reg, new);\n-              new = reg;\n+              s390_load_address (reg, new_rtx);\n+              new_rtx = reg;\n             }\n         }\n     }\n@@ -3268,12 +3268,12 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  if (reload_in_progress || reload_completed)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n-          new = gen_rtx_CONST (Pmode, new);\n-          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n-          new = gen_const_mem (Pmode, new);\n-          emit_move_insn (reg, new);\n-          new = reg;\n+          new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n+          new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new_rtx);\n+          new_rtx = gen_const_mem (Pmode, new_rtx);\n+          emit_move_insn (reg, new_rtx);\n+          new_rtx = reg;\n         }\n       else if (TARGET_CPU_ZARCH)\n         {\n@@ -3285,13 +3285,13 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  gcc_assert (REGNO (temp) >= FIRST_PSEUDO_REGISTER\n \t\t      || REGNO_REG_CLASS (REGNO (temp)) == ADDR_REGS);\n \n-          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n-          new = gen_rtx_CONST (Pmode, new);\n-          emit_move_insn (temp, new);\n+          new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n+          new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+          emit_move_insn (temp, new_rtx);\n \n-          new = gen_const_mem (Pmode, temp);\n-          emit_move_insn (reg, new);\n-          new = reg;\n+          new_rtx = gen_const_mem (Pmode, temp);\n+          emit_move_insn (reg, new_rtx);\n+          new_rtx = reg;\n         }\n       else\n         {\n@@ -3311,10 +3311,10 @@ legitimize_pic_address (rtx orig, rtx reg)\n           addr = force_const_mem (Pmode, addr);\n           emit_move_insn (temp, addr);\n \n-          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-          new = gen_const_mem (Pmode, new);\n-          emit_move_insn (reg, new);\n-          new = reg;\n+          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+          new_rtx = gen_const_mem (Pmode, new_rtx);\n+          emit_move_insn (reg, new_rtx);\n+          new_rtx = reg;\n         }\n     }\n   else\n@@ -3331,13 +3331,13 @@ legitimize_pic_address (rtx orig, rtx reg)\n                      out of the literal pool, force them back in.  */\n                   case UNSPEC_GOTOFF:\n                   case UNSPEC_PLTOFF:\n-                    new = force_const_mem (Pmode, orig);\n+                    new_rtx = force_const_mem (Pmode, orig);\n                     break;\n \n                   /* @GOT is OK as is if small.  */\n \t\t  case UNSPEC_GOT:\n \t\t    if (flag_pic == 2)\n-\t\t      new = force_const_mem (Pmode, orig);\n+\t\t      new_rtx = force_const_mem (Pmode, orig);\n \t\t    break;\n \n                   /* @GOTENT is OK as is.  */\n@@ -3361,11 +3361,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n                         addr = force_const_mem (Pmode, addr);\n \t                emit_move_insn (temp, addr);\n \n-                        new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+                        new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n                         if (reg != 0)\n                           {\n-                            s390_load_address (reg, new);\n-                            new = reg;\n+                            s390_load_address (reg, new_rtx);\n+                            new_rtx = reg;\n                           }\n                       }\n                     break;\n@@ -3411,12 +3411,12 @@ legitimize_pic_address (rtx orig, rtx reg)\n                         }\n \n                       emit_move_insn (temp, op0);\n-                      new = gen_rtx_PLUS (Pmode, temp, op1);\n+                      new_rtx = gen_rtx_PLUS (Pmode, temp, op1);\n \n                       if (reg != 0)\n                         {\n-                          s390_load_address (reg, new);\n-                          new = reg;\n+                          s390_load_address (reg, new_rtx);\n+                          new_rtx = reg;\n                         }\n                     }\n                   else\n@@ -3441,11 +3441,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n                   addr = force_const_mem (Pmode, addr);\n \t\t  emit_move_insn (temp, addr);\n \n-                  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+                  new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n                   if (reg != 0)\n                     {\n-                      s390_load_address (reg, new);\n-                      new = reg;\n+                      s390_load_address (reg, new_rtx);\n+                      new_rtx = reg;\n                     }\n                 }\n \t    }\n@@ -3459,34 +3459,34 @@ legitimize_pic_address (rtx orig, rtx reg)\n             {\n \t      gcc_assert (XVECLEN (op0, 0) == 1);\n \n-              new = force_const_mem (Pmode, orig);\n+              new_rtx = force_const_mem (Pmode, orig);\n             }\n \n           /* Otherwise, compute the sum.  */\n \t  else\n \t    {\n \t      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-\t      new  = legitimize_pic_address (XEXP (addr, 1),\n+\t      new_rtx  = legitimize_pic_address (XEXP (addr, 1),\n \t\t\t\t\t     base == reg ? NULL_RTX : reg);\n-\t      if (GET_CODE (new) == CONST_INT)\n-\t\tnew = plus_constant (base, INTVAL (new));\n+\t      if (GET_CODE (new_rtx) == CONST_INT)\n+\t\tnew_rtx = plus_constant (base, INTVAL (new_rtx));\n \t      else\n \t\t{\n-\t\t  if (GET_CODE (new) == PLUS && CONSTANT_P (XEXP (new, 1)))\n+\t\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n \t\t    {\n-\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new, 0));\n-\t\t      new = XEXP (new, 1);\n+\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new_rtx, 0));\n+\t\t      new_rtx = XEXP (new_rtx, 1);\n \t\t    }\n-\t\t  new = gen_rtx_PLUS (Pmode, base, new);\n+\t\t  new_rtx = gen_rtx_PLUS (Pmode, base, new_rtx);\n \t\t}\n \n-\t      if (GET_CODE (new) == CONST)\n-\t\tnew = XEXP (new, 0);\n-              new = force_operand (new, 0);\n+\t      if (GET_CODE (new_rtx) == CONST)\n+\t\tnew_rtx = XEXP (new_rtx, 0);\n+              new_rtx = force_operand (new_rtx, 0);\n \t    }\n \t}\n     }\n-  return new;\n+  return new_rtx;\n }\n \n /* Load the thread pointer into a register.  */\n@@ -3532,7 +3532,7 @@ s390_emit_tls_call_insn (rtx result_reg, rtx tls_call)\n static rtx\n legitimize_tls_address (rtx addr, rtx reg)\n {\n-  rtx new, tls_call, temp, base, r2, insn;\n+  rtx new_rtx, tls_call, temp, base, r2, insn;\n \n   if (GET_CODE (addr) == SYMBOL_REF)\n     switch (tls_symbolic_operand (addr))\n@@ -3541,55 +3541,55 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tstart_sequence ();\n \tr2 = gen_rtx_REG (Pmode, 2);\n \ttls_call = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_TLSGD);\n-\tnew = gen_rtx_CONST (Pmode, tls_call);\n-\tnew = force_const_mem (Pmode, new);\n-\temit_move_insn (r2, new);\n+\tnew_rtx = gen_rtx_CONST (Pmode, tls_call);\n+\tnew_rtx = force_const_mem (Pmode, new_rtx);\n+\temit_move_insn (r2, new_rtx);\n \ts390_emit_tls_call_insn (r2, tls_call);\n \tinsn = get_insns ();\n \tend_sequence ();\n \n-\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n+\tnew_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n \ttemp = gen_reg_rtx (Pmode);\n-\temit_libcall_block (insn, temp, r2, new);\n+\temit_libcall_block (insn, temp, r2, new_rtx);\n \n-\tnew = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n+\tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n \tif (reg != 0)\n \t  {\n-\t    s390_load_address (reg, new);\n-\t    new = reg;\n+\t    s390_load_address (reg, new_rtx);\n+\t    new_rtx = reg;\n \t  }\n \tbreak;\n \n       case TLS_MODEL_LOCAL_DYNAMIC:\n \tstart_sequence ();\n \tr2 = gen_rtx_REG (Pmode, 2);\n \ttls_call = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TLSLDM);\n-\tnew = gen_rtx_CONST (Pmode, tls_call);\n-\tnew = force_const_mem (Pmode, new);\n-\temit_move_insn (r2, new);\n+\tnew_rtx = gen_rtx_CONST (Pmode, tls_call);\n+\tnew_rtx = force_const_mem (Pmode, new_rtx);\n+\temit_move_insn (r2, new_rtx);\n \ts390_emit_tls_call_insn (r2, tls_call);\n \tinsn = get_insns ();\n \tend_sequence ();\n \n-\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TLSLDM_NTPOFF);\n+\tnew_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TLSLDM_NTPOFF);\n \ttemp = gen_reg_rtx (Pmode);\n-\temit_libcall_block (insn, temp, r2, new);\n+\temit_libcall_block (insn, temp, r2, new_rtx);\n \n-\tnew = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n+\tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n \tbase = gen_reg_rtx (Pmode);\n-\ts390_load_address (base, new);\n+\ts390_load_address (base, new_rtx);\n \n-\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_DTPOFF);\n-\tnew = gen_rtx_CONST (Pmode, new);\n-\tnew = force_const_mem (Pmode, new);\n+\tnew_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_DTPOFF);\n+\tnew_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\tnew_rtx = force_const_mem (Pmode, new_rtx);\n \ttemp = gen_reg_rtx (Pmode);\n-\temit_move_insn (temp, new);\n+\temit_move_insn (temp, new_rtx);\n \n-\tnew = gen_rtx_PLUS (Pmode, base, temp);\n+\tnew_rtx = gen_rtx_PLUS (Pmode, base, temp);\n \tif (reg != 0)\n \t  {\n-\t    s390_load_address (reg, new);\n-\t    new = reg;\n+\t    s390_load_address (reg, new_rtx);\n+\t    new_rtx = reg;\n \t  }\n \tbreak;\n \n@@ -3602,26 +3602,26 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    if (reload_in_progress || reload_completed)\n \t      df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n-\t    new = gen_rtx_CONST (Pmode, new);\n-\t    new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n-\t    new = gen_const_mem (Pmode, new);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n+\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t    new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new_rtx);\n+\t    new_rtx = gen_const_mem (Pmode, new_rtx);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new);\n+\t    emit_move_insn (temp, new_rtx);\n \t  }\n \telse if (TARGET_CPU_ZARCH)\n \t  {\n \t    /* If the GOT offset might be >= 4k, we determine the position\n \t       of the GOT entry via a PC-relative LARL.  */\n \n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n-\t    new = gen_rtx_CONST (Pmode, new);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n+\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new);\n+\t    emit_move_insn (temp, new_rtx);\n \n-\t    new = gen_const_mem (Pmode, temp);\n+\t    new_rtx = gen_const_mem (Pmode, temp);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new);\n+\t    emit_move_insn (temp, new_rtx);\n \t  }\n \telse if (flag_pic)\n \t  {\n@@ -3631,57 +3631,57 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    if (reload_in_progress || reload_completed)\n \t      df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n-\t    new = gen_rtx_CONST (Pmode, new);\n-\t    new = force_const_mem (Pmode, new);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n+\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t    new_rtx = force_const_mem (Pmode, new_rtx);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new);\n+\t    emit_move_insn (temp, new_rtx);\n \n-            new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-\t    new = gen_const_mem (Pmode, new);\n+            new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+\t    new_rtx = gen_const_mem (Pmode, new_rtx);\n \n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new_rtx, addr), UNSPEC_TLS_LOAD);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_insn (gen_rtx_SET (Pmode, temp, new));\n+\t    emit_insn (gen_rtx_SET (Pmode, temp, new_rtx));\n \t  }\n \telse\n \t  {\n \t    /* In position-dependent code, load the absolute address of\n \t       the GOT entry from the literal pool.  */\n \n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n-\t    new = gen_rtx_CONST (Pmode, new);\n-\t    new = force_const_mem (Pmode, new);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n+\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t    new_rtx = force_const_mem (Pmode, new_rtx);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new);\n+\t    emit_move_insn (temp, new_rtx);\n \n-\t    new = temp;\n-\t    new = gen_const_mem (Pmode, new);\n-\t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n+\t    new_rtx = temp;\n+\t    new_rtx = gen_const_mem (Pmode, new_rtx);\n+\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new_rtx, addr), UNSPEC_TLS_LOAD);\n \t    temp = gen_reg_rtx (Pmode);\n-\t    emit_insn (gen_rtx_SET (Pmode, temp, new));\n+\t    emit_insn (gen_rtx_SET (Pmode, temp, new_rtx));\n \t  }\n \n-\tnew = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n+\tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n \tif (reg != 0)\n \t  {\n-\t    s390_load_address (reg, new);\n-\t    new = reg;\n+\t    s390_load_address (reg, new_rtx);\n+\t    new_rtx = reg;\n \t  }\n \tbreak;\n \n       case TLS_MODEL_LOCAL_EXEC:\n-\tnew = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n-\tnew = gen_rtx_CONST (Pmode, new);\n-\tnew = force_const_mem (Pmode, new);\n+\tnew_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n+\tnew_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\tnew_rtx = force_const_mem (Pmode, new_rtx);\n         temp = gen_reg_rtx (Pmode);\n-\temit_move_insn (temp, new);\n+\temit_move_insn (temp, new_rtx);\n \n-\tnew = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n+\tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n \tif (reg != 0)\n \t  {\n-\t    s390_load_address (reg, new);\n-\t    new = reg;\n+\t    s390_load_address (reg, new_rtx);\n+\t    new_rtx = reg;\n \t  }\n \tbreak;\n \n@@ -3695,7 +3695,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t{\n \tcase UNSPEC_INDNTPOFF:\n \t  gcc_assert (TARGET_CPU_ZARCH);\n-\t  new = addr;\n+\t  new_rtx = addr;\n \t  break;\n \n \tdefault:\n@@ -3706,19 +3706,19 @@ legitimize_tls_address (rtx addr, rtx reg)\n   else if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n     {\n-      new = XEXP (XEXP (addr, 0), 0);\n-      if (GET_CODE (new) != SYMBOL_REF)\n-\tnew = gen_rtx_CONST (Pmode, new);\n+      new_rtx = XEXP (XEXP (addr, 0), 0);\n+      if (GET_CODE (new_rtx) != SYMBOL_REF)\n+\tnew_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \n-      new = legitimize_tls_address (new, reg);\n-      new = plus_constant (new, INTVAL (XEXP (XEXP (addr, 0), 1)));\n-      new = force_operand (new, 0);\n+      new_rtx = legitimize_tls_address (new_rtx, reg);\n+      new_rtx = plus_constant (new_rtx, INTVAL (XEXP (XEXP (addr, 0), 1)));\n+      new_rtx = force_operand (new_rtx, 0);\n     }\n \n   else\n     gcc_unreachable ();  /* for now ... */\n \n-  return new;\n+  return new_rtx;\n }\n \n /* Emit insns making the address in operands[1] valid for a standard\n@@ -3865,19 +3865,19 @@ legitimize_reload_address (rtx ad, enum machine_mode mode ATTRIBUTE_UNUSED,\n     {\n       HOST_WIDE_INT lower = INTVAL (XEXP (ad, 1)) & 0xfff;\n       HOST_WIDE_INT upper = INTVAL (XEXP (ad, 1)) ^ lower;\n-      rtx cst, tem, new;\n+      rtx cst, tem, new_rtx;\n \n       cst = GEN_INT (upper);\n       if (!legitimate_reload_constant_p (cst))\n \tcst = force_const_mem (Pmode, cst);\n \n       tem = gen_rtx_PLUS (Pmode, XEXP (ad, 0), cst);\n-      new = gen_rtx_PLUS (Pmode, tem, GEN_INT (lower));\n+      new_rtx = gen_rtx_PLUS (Pmode, tem, GEN_INT (lower));\n \n       push_reload (XEXP (tem, 1), 0, &XEXP (tem, 1), 0,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, \n \t\t   opnum, (enum reload_type) type);\n-      return new;\n+      return new_rtx;\n     }\n \n   return NULL_RTX;\n@@ -4547,13 +4547,13 @@ init_alignment_context (struct alignment_context *ac, rtx mem,\n }\n \n /* Expand an atomic compare and swap operation for HImode and QImode.  MEM is\n-   the memory location, CMP the old value to compare MEM with and NEW the value\n+   the memory location, CMP the old value to compare MEM with and NEW_RTX the value\n    to set if CMP == MEM.\n    CMP is never in memory for compare_and_swap_cc because\n    expand_bool_compare_and_swap puts it into a register for later compare.  */\n \n void\n-s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx new)\n+s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx new_rtx)\n {\n   struct alignment_context ac;\n   rtx cmpv, newv, val, resv, cc;\n@@ -4569,8 +4569,8 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n   /* Shift the values to the correct bit positions.  */\n   if (!(ac.aligned && MEM_P (cmp)))\n     cmp = s390_expand_mask_and_shift (cmp, mode, ac.shift);\n-  if (!(ac.aligned && MEM_P (new)))\n-    new = s390_expand_mask_and_shift (new, mode, ac.shift);\n+  if (!(ac.aligned && MEM_P (new_rtx)))\n+    new_rtx = s390_expand_mask_and_shift (new_rtx, mode, ac.shift);\n \n   /* Load full word.  Subsequent loads are performed by CS.  */\n   val = expand_simple_binop (SImode, AND, ac.memsi, ac.modemaski,\n@@ -4592,13 +4592,13 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n   else\n     cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,\n \t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n-  if (ac.aligned && MEM_P (new))\n+  if (ac.aligned && MEM_P (new_rtx))\n     {\n       newv = force_reg (SImode, val);\n-      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0, SImode, new);\n+      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0, SImode, new_rtx);\n     }\n   else\n-    newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new, val,\n+    newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new_rtx, val,\n \t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n \n   /* Jump to end if we're done (likely?).  */\n@@ -4632,7 +4632,7 @@ s390_expand_atomic (enum machine_mode mode, enum rtx_code code,\n {\n   struct alignment_context ac;\n   rtx cmp;\n-  rtx new = gen_reg_rtx (SImode);\n+  rtx new_rtx = gen_reg_rtx (SImode);\n   rtx orig = gen_reg_rtx (SImode);\n   rtx csloop = gen_label_rtx ();\n \n@@ -4658,52 +4658,52 @@ s390_expand_atomic (enum machine_mode mode, enum rtx_code code,\n \n   /* Start CS loop.  */\n   emit_label (csloop);\n-  emit_move_insn (new, cmp);\n+  emit_move_insn (new_rtx, cmp);\n \n   /* Patch new with val at correct position.  */\n   switch (code)\n     {\n     case PLUS:\n     case MINUS:\n-      val = expand_simple_binop (SImode, code, new, orig,\n+      val = expand_simple_binop (SImode, code, new_rtx, orig,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       val = expand_simple_binop (SImode, AND, val, ac.modemask,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       /* FALLTHRU */\n     case SET: \n       if (ac.aligned && MEM_P (val))\n-\tstore_bit_field (new, GET_MODE_BITSIZE (mode), 0, SImode, val);\n+\tstore_bit_field (new_rtx, GET_MODE_BITSIZE (mode), 0, SImode, val);\n       else\n \t{\n-\t  new = expand_simple_binop (SImode, AND, new, ac.modemaski,\n+\t  new_rtx = expand_simple_binop (SImode, AND, new_rtx, ac.modemaski,\n \t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n-\t  new = expand_simple_binop (SImode, IOR, new, val,\n+\t  new_rtx = expand_simple_binop (SImode, IOR, new_rtx, val,\n \t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \t}\n       break;\n     case AND:\n     case IOR:\n     case XOR:\n-      new = expand_simple_binop (SImode, code, new, val,\n+      new_rtx = expand_simple_binop (SImode, code, new_rtx, val,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       break;\n     case MULT: /* NAND */\n-      new = expand_simple_binop (SImode, XOR, new, ac.modemask,\n+      new_rtx = expand_simple_binop (SImode, XOR, new_rtx, ac.modemask,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n-      new = expand_simple_binop (SImode, AND, new, val,\n+      new_rtx = expand_simple_binop (SImode, AND, new_rtx, val,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n   s390_emit_jump (csloop, s390_emit_compare_and_swap (NE, cmp,\n-\t\t\t\t\t\t      ac.memsi, cmp, new));\n+\t\t\t\t\t\t      ac.memsi, cmp, new_rtx));\n \n   /* Return the correct part of the bitfield.  */\n   if (target)\n     convert_move (target, expand_simple_binop (SImode, LSHIFTRT,\n-\t\t\t\t\t       after ? new : cmp, ac.shift,\n+\t\t\t\t\t       after ? new_rtx : cmp, ac.shift,\n \t\t\t\t\t       NULL_RTX, 1, OPTAB_DIRECT), 1);\n }\n \n@@ -7288,12 +7288,12 @@ s390_hard_regno_rename_ok (unsigned int old_reg, unsigned int new_reg)\n }\n \n /* Maximum number of registers to represent a value of mode MODE\n-   in a register of class CLASS.  */\n+   in a register of class RCLASS.  */\n \n bool\n-s390_class_max_nregs (enum reg_class class, enum machine_mode mode)\n+s390_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n {\n-  switch (class)\n+  switch (rclass)\n     {\n     case FP_REGS:\n       if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)"}, {"sha": "a8cb4774969f1469f5bcf23bee37033c580943b0", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -748,10 +748,10 @@ used in insn definitions or inline assemblies.  */\n    macro is used in only one place: `find_reloads_address' in reload.c.  */\n #define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN)\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  rtx new = legitimize_reload_address (AD, MODE, OPNUM, (int)(TYPE));\t\\\n-  if (new)\t\t\t\t\t\t\t\t\\\n+  rtx new_rtx = legitimize_reload_address (AD, MODE, OPNUM, (int)(TYPE));\t\\\n+  if (new_rtx)\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      (AD) = new;\t\t\t\t\t\t\t\\\n+      (AD) = new_rtx;\t\t\t\t\t\t\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)"}, {"sha": "f9e89c9fe0713d90b9bb306096ee49cbbdb9481f", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1181,8 +1181,8 @@\n \t      (match_operand:P 2 \"register_operand\" \"=a\")])]\n   \"\"\n {\n-  rtx new = legitimize_pic_address (operands[1], operands[2]);\n-  emit_move_insn (operands[0], new);\n+  rtx new_rtx = legitimize_pic_address (operands[1], operands[2]);\n+  emit_move_insn (operands[0], new_rtx);\n })\n \n ;"}, {"sha": "5f444abdf739bc0e76a5cefe6d83d48809938e94", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -62,13 +62,13 @@ extern void score_declare_object (FILE *stream, const char *name,\n                                   const char *directive, const char *fmt, ...);\n extern int score_output_external (FILE *file, tree decl, const char *name);\n extern void score_override_options (void);\n-extern enum reg_class score_secondary_reload_class (enum reg_class class,\n+extern enum reg_class score_secondary_reload_class (enum reg_class rclass,\n                                                     enum machine_mode mode,\n                                                     rtx x);\n extern rtx score_function_value (tree valtype, tree func,\n                                  enum machine_mode mode);\n extern enum reg_class score_preferred_reload_class (rtx x,\n-                                                    enum reg_class class);\n+                                                    enum reg_class rclass);\n extern HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n extern void score_print_operand (FILE *file, rtx op, int letter);\n extern void score_print_operand_address (FILE *file, rtx addr);"}, {"sha": "c2e4176e382c0d01a1040499ac01c35a83edea77", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -361,27 +361,27 @@ score_reg_class (int regno)\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n-score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_preferred_reload_class (x, class);\n+    return score7_preferred_reload_class (x, rclass);\n   else if (TARGET_SCORE3)\n-    return score3_preferred_reload_class (x, class);\n+    return score3_preferred_reload_class (x, rclass);\n \n   gcc_unreachable ();\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n    and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n enum reg_class\n-score_secondary_reload_class (enum reg_class class,\n+score_secondary_reload_class (enum reg_class rclass,\n                               enum machine_mode mode ATTRIBUTE_UNUSED,\n                               rtx x)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_secondary_reload_class (class, mode, x);\n+    return score7_secondary_reload_class (rclass, mode, x);\n   else if (TARGET_SCORE3)\n-    return score3_secondary_reload_class (class, mode, x);\n+    return score3_secondary_reload_class (rclass, mode, x);\n \n   gcc_unreachable ();\n }"}, {"sha": "c976f38c0055dbb9423fa00027974cadfcfbc2d8", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -323,7 +323,7 @@ score3_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n                         HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n                         tree function)\n {\n-  rtx this, temp1, insn, fnaddr;\n+  rtx this_rtx, temp1, insn, fnaddr;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n   reload_completed = 1;\n@@ -336,11 +336,11 @@ score3_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find out which register contains the \"this\" pointer.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n   else\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n \n-  /* Add DELTA to THIS.  */\n+  /* Add DELTA to THIS_RTX.  */\n   if (delta != 0)\n     {\n       rtx offset = GEN_INT (delta);\n@@ -349,23 +349,23 @@ score3_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n           emit_move_insn (temp1, offset);\n           offset = temp1;\n         }\n-      emit_insn (gen_add3_insn (this, this, offset));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n     }\n \n-  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n   if (vcall_offset != 0)\n     {\n       rtx addr;\n \n-      /* Set TEMP1 to *THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+      /* Set TEMP1 to *THIS_RTX.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n \n-      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n       addr = score3_add_offset (temp1, vcall_offset);\n \n-      /* Load the offset and add it to THIS.  */\n+      /* Load the offset and add it to THIS_RTX.  */\n       emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this, this, temp1));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n     }\n \n   /* Jump to the target function.  */\n@@ -691,27 +691,27 @@ score3_reg_class (int regno)\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n-score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n-  if (reg_class_subset_p (G16_REGS, class))\n+  if (reg_class_subset_p (G16_REGS, rclass))\n     return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, class))\n+  if (reg_class_subset_p (G32_REGS, rclass))\n     return G32_REGS;\n-  return class;\n+  return rclass;\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n    and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n enum reg_class\n-score3_secondary_reload_class (enum reg_class class,\n+score3_secondary_reload_class (enum reg_class rclass,\n                                enum machine_mode mode ATTRIBUTE_UNUSED,\n                                rtx x)\n {\n   int regno = -1;\n   if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n     regno = true_regnum (x);\n \n-  if (!GR_REG_CLASS_P (class))\n+  if (!GR_REG_CLASS_P (rclass))\n     return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n   return NO_REGS;\n }\n@@ -768,21 +768,21 @@ int\n score3_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n   int size = GET_MODE_SIZE (mode);\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n \n-  if (class == MODE_CC)\n+  if (mclass == MODE_CC)\n     return regno == CC_REGNUM;\n   else if (regno == FRAME_POINTER_REGNUM\n            || regno == ARG_POINTER_REGNUM)\n-    return class == MODE_INT;\n+    return mclass == MODE_INT;\n   else if (GP_REG_P (regno))\n     return !(regno & 1) || (size <= UNITS_PER_WORD);\n   else if (CE_REG_P (regno))\n-    return (class == MODE_INT\n+    return (mclass == MODE_INT\n             && ((size <= UNITS_PER_WORD)\n                 || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n   else\n-    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n }\n \n /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame"}, {"sha": "79677702d47949857e74804d74f51d2fec79d353", "filename": "gcc/config/score/score3.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -93,9 +93,9 @@ extern void score3_asm_file_end (void);\n extern void score3_override_options (void);\n extern int score3_reg_class (int regno);\n extern enum reg_class score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n-                                                     enum reg_class class);\n+                                                     enum reg_class rclass);\n extern enum reg_class\n-score3_secondary_reload_class (enum reg_class class,\n+score3_secondary_reload_class (enum reg_class rclass,\n                                enum machine_mode mode ATTRIBUTE_UNUSED,\n                                rtx x);\n extern int score3_const_ok_for_letter_p (HOST_WIDE_INT value, char c);"}, {"sha": "03c47042ed570fbe147d109ed0d776ea8c72f6f8", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -322,7 +322,7 @@ score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n                         HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n                         tree function)\n {\n-  rtx this, temp1, insn, fnaddr;\n+  rtx this_rtx, temp1, insn, fnaddr;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n   reload_completed = 1;\n@@ -335,11 +335,11 @@ score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find out which register contains the \"this\" pointer.  */\n   if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n   else\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n \n-  /* Add DELTA to THIS.  */\n+  /* Add DELTA to THIS_RTX.  */\n   if (delta != 0)\n     {\n       rtx offset = GEN_INT (delta);\n@@ -348,23 +348,23 @@ score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n           emit_move_insn (temp1, offset);\n           offset = temp1;\n         }\n-      emit_insn (gen_add3_insn (this, this, offset));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n     }\n \n-  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n   if (vcall_offset != 0)\n     {\n       rtx addr;\n \n-      /* Set TEMP1 to *THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+      /* Set TEMP1 to *THIS_RTX.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n \n-      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n       addr = score7_add_offset (temp1, vcall_offset);\n \n-      /* Load the offset and add it to THIS.  */\n+      /* Load the offset and add it to THIS_RTX.  */\n       emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this, this, temp1));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n     }\n \n   /* Jump to the target function.  */\n@@ -690,27 +690,27 @@ score7_reg_class (int regno)\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n-score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n-  if (reg_class_subset_p (G16_REGS, class))\n+  if (reg_class_subset_p (G16_REGS, rclass))\n     return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, class))\n+  if (reg_class_subset_p (G32_REGS, rclass))\n     return G32_REGS;\n-  return class;\n+  return rclass;\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n    and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n enum reg_class\n-score7_secondary_reload_class (enum reg_class class,\n+score7_secondary_reload_class (enum reg_class rclass,\n                                enum machine_mode mode ATTRIBUTE_UNUSED,\n                                rtx x)\n {\n   int regno = -1;\n   if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n     regno = true_regnum (x);\n \n-  if (!GR_REG_CLASS_P (class))\n+  if (!GR_REG_CLASS_P (rclass))\n     return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n   return NO_REGS;\n }\n@@ -758,22 +758,22 @@ int\n score7_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n   int size = GET_MODE_SIZE (mode);\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n \n-  if (class == MODE_CC)\n+  if (mclass == MODE_CC)\n     return regno == CC_REGNUM;\n   else if (regno == FRAME_POINTER_REGNUM\n            || regno == ARG_POINTER_REGNUM)\n-    return class == MODE_INT;\n+    return mclass == MODE_INT;\n   else if (GP_REG_P (regno))\n     /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n     return !(regno & 1) || (size <= UNITS_PER_WORD);\n   else if (CE_REG_P (regno))\n-    return (class == MODE_INT\n+    return (mclass == MODE_INT\n             && ((size <= UNITS_PER_WORD)\n                 || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n   else\n-    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n }\n \n /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame"}, {"sha": "1797e4722799643fbfdf1fe6561a627c4f76cb9b", "filename": "gcc/config/score/score7.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -93,9 +93,9 @@ extern void score7_asm_file_end (void);\n extern void score7_override_options (void);\n extern int score7_reg_class (int regno);\n extern enum reg_class score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n-                                                     enum reg_class class);\n+                                                     enum reg_class rclass);\n extern enum\n-reg_class score7_secondary_reload_class (enum reg_class class,\n+reg_class score7_secondary_reload_class (enum reg_class rclass,\n                                          enum machine_mode mode ATTRIBUTE_UNUSED,\n                                          rtx x);\n extern int score7_const_ok_for_letter_p (HOST_WIDE_INT value, char c);"}, {"sha": "74060738ee974daf102c9a2a23fadf0224b0c3e8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1300,9 +1300,9 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t{\n \t  /* This is like change_address_1 (operands[0], mode, 0, 1) ,\n \t     except that we can't use that function because it is static.  */\n-\t  rtx new = change_address (operands[0], mode, 0);\n-\t  MEM_COPY_ATTRIBUTES (new, operands[0]);\n-\t  operands[0] = new;\n+\t  rtx new_rtx = change_address (operands[0], mode, 0);\n+\t  MEM_COPY_ATTRIBUTES (new_rtx, operands[0]);\n+\t  operands[0] = new_rtx;\n \t}\n \n       /* This case can happen while generating code to move the result\n@@ -1915,14 +1915,14 @@ print_slot (rtx insn)\n const char *\n output_far_jump (rtx insn, rtx op)\n {\n-  struct { rtx lab, reg, op; } this;\n+  struct { rtx lab, reg, op; } this_jmp;\n   rtx braf_base_lab = NULL_RTX;\n   const char *jump;\n   int far;\n   int offset = branch_dest (insn) - INSN_ADDRESSES (INSN_UID (insn));\n   rtx prev;\n \n-  this.lab = gen_label_rtx ();\n+  this_jmp.lab = gen_label_rtx ();\n \n   if (TARGET_SH2\n       && offset >= -32764\n@@ -1948,10 +1948,10 @@ output_far_jump (rtx insn, rtx op)\n   if (GET_CODE ((prev = prev_nonnote_insn (insn))) == INSN\n       && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)\n     {\n-      this.reg = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));\n-      if (REGNO (this.reg) == R0_REG && flag_pic && ! TARGET_SH2)\n+      this_jmp.reg = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));\n+      if (REGNO (this_jmp.reg) == R0_REG && flag_pic && ! TARGET_SH2)\n \tjump = \"mov.l\tr1,@-r15; mova\t%O0,r0; mov.l\t@r0,r1; add\tr1,r0; mov.l\t@r15+,r1; jmp\t@%1\";\n-      output_asm_insn (jump, &this.lab);\n+      output_asm_insn (jump, &this_jmp.lab);\n       if (dbr_sequence_length ())\n \tprint_slot (final_sequence);\n       else\n@@ -1963,7 +1963,7 @@ output_far_jump (rtx insn, rtx op)\n       if (dbr_sequence_length ())\n \tprint_slot (final_sequence);\n \n-      this.reg = gen_rtx_REG (SImode, 13);\n+      this_jmp.reg = gen_rtx_REG (SImode, 13);\n       /* We must keep the stack aligned to 8-byte boundaries on SH5.\n \t Fortunately, MACL is fixed and call-clobbered, and we never\n \t need its value across jumps, so save r13 in it instead of in\n@@ -1972,7 +1972,7 @@ output_far_jump (rtx insn, rtx op)\n \toutput_asm_insn (\"lds\tr13, macl\", 0);\n       else\n \toutput_asm_insn (\"mov.l\tr13,@-r15\", 0);\n-      output_asm_insn (jump, &this.lab);\n+      output_asm_insn (jump, &this_jmp.lab);\n       if (TARGET_SH5)\n \toutput_asm_insn (\"sts\tmacl, r13\", 0);\n       else\n@@ -1986,16 +1986,16 @@ output_far_jump (rtx insn, rtx op)\n     }\n   if (far)\n     output_asm_insn (\".align\t2\", 0);\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\", CODE_LABEL_NUMBER (this.lab));\n-  this.op = op;\n+  (*targetm.asm_out.internal_label) (asm_out_file, \"L\", CODE_LABEL_NUMBER (this_jmp.lab));\n+  this_jmp.op = op;\n   if (far && flag_pic)\n     {\n       if (TARGET_SH2)\n-\tthis.lab = braf_base_lab;\n-      output_asm_insn (\".long\t%O2-%O0\", &this.lab);\n+\tthis_jmp.lab = braf_base_lab;\n+      output_asm_insn (\".long\t%O2-%O0\", &this_jmp.lab);\n     }\n   else\n-    output_asm_insn (far ? \".long\t%O2\" : \".word %O2-%O0\", &this.lab);\n+    output_asm_insn (far ? \".long\t%O2\" : \".word %O2-%O0\", &this_jmp.lab);\n   return \"\";\n }\n \n@@ -2092,14 +2092,14 @@ output_branch (int logic, rtx insn, rtx *operands)\n     }\n }\n \n-/* Output a code sequence for INSN using TEMPLATE with OPERANDS; but before,\n+/* Output a code sequence for INSN using TEMPL with OPERANDS; but before,\n    fill in operands 9 as a label to the successor insn.\n    We try to use jump threading where possible.\n    IF CODE matches the comparison in the IF_THEN_ELSE of a following jump,\n    we assume the jump is taken.  I.e. EQ means follow jmp and bf, NE means\n    follow jmp and bt, if the address is in range.  */\n const char *\n-output_branchy_insn (enum rtx_code code, const char *template,\n+output_branchy_insn (enum rtx_code code, const char *templ,\n \t\t     rtx insn, rtx *operands)\n {\n   rtx next_insn = NEXT_INSN (insn);\n@@ -2115,7 +2115,7 @@ output_branchy_insn (enum rtx_code code, const char *template,\n \t  INSN_ADDRESSES_NEW (operands[9],\n \t\t\t      INSN_ADDRESSES (INSN_UID (next_insn))\n \t\t\t      + get_attr_length (next_insn));\n-\t  return template;\n+\t  return templ;\n \t}\n       else\n \t{\n@@ -2127,7 +2127,7 @@ output_branchy_insn (enum rtx_code code, const char *template,\n \t\t/* branch_true */\n \t\tsrc = XEXP (src, 1);\n \t      operands[9] = src;\n-\t      return template;\n+\t      return templ;\n \t    }\n \t}\n     }\n@@ -2136,7 +2136,7 @@ output_branchy_insn (enum rtx_code code, const char *template,\n   INSN_ADDRESSES_NEW (operands[9],\n \t\t      INSN_ADDRESSES (INSN_UID (insn))\n \t\t      + get_attr_length (insn));\n-  return template;\n+  return templ;\n }\n \n const char *\n@@ -3483,7 +3483,7 @@ static rtx\n add_constant (rtx x, enum machine_mode mode, rtx last_value)\n {\n   int i;\n-  rtx lab, new;\n+  rtx lab, new_rtx;\n   label_ref_list_t ref, newref;\n \n   /* First see if we've already got it.  */\n@@ -3499,14 +3499,14 @@ add_constant (rtx x, enum machine_mode mode, rtx last_value)\n \t    }\n \t  if (rtx_equal_p (x, pool_vector[i].value))\n \t    {\n-\t      lab = new = 0;\n+\t      lab = new_rtx = 0;\n \t      if (! last_value\n \t\t  || ! i\n \t\t  || ! rtx_equal_p (last_value, pool_vector[i-1].value))\n \t\t{\n-\t\t  new = gen_label_rtx ();\n-\t\t  LABEL_REFS (new) = pool_vector[i].label;\n-\t\t  pool_vector[i].label = lab = new;\n+\t\t  new_rtx = gen_label_rtx ();\n+\t\t  LABEL_REFS (new_rtx) = pool_vector[i].label;\n+\t\t  pool_vector[i].label = lab = new_rtx;\n \t\t}\n \t      if (lab && pool_window_label)\n \t\t{\n@@ -3516,8 +3516,8 @@ add_constant (rtx x, enum machine_mode mode, rtx last_value)\n \t\t  newref->next = ref;\n \t\t  pool_vector[pool_window_last].wend = newref;\n \t\t}\n-\t      if (new)\n-\t\tpool_window_label = new;\n+\t      if (new_rtx)\n+\t\tpool_window_label = new_rtx;\n \t      pool_window_last = i;\n \t      return lab;\n \t    }\n@@ -4421,7 +4421,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n       rtx scan;\n       /* Don't look for the stack pointer as a scratch register,\n \t it would cause trouble if an interrupt occurred.  */\n-      unsigned try = 0x7fff, used;\n+      unsigned attempt = 0x7fff, used;\n       int jump_left = flag_expensive_optimizations + 1;\n \n       /* It is likely that the most recent eligible instruction is wanted for\n@@ -4442,7 +4442,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t      && GET_CODE (PATTERN (scan)) != CLOBBER\n \t      && get_attr_in_delay_slot (scan) == IN_DELAY_SLOT_YES)\n \t    {\n-\t      try &= ~regs_used (PATTERN (scan), 0);\n+\t      attempt &= ~regs_used (PATTERN (scan), 0);\n \t      break;\n \t    }\n \t}\n@@ -4460,9 +4460,9 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t      if (code == CALL_INSN)\n \t\tused |= regs_used (CALL_INSN_FUNCTION_USAGE (scan), 0);\n \t      dead |= (used >> 16) & ~used;\n-\t      if (dead & try)\n+\t      if (dead & attempt)\n \t\t{\n-\t\t  dead &= try;\n+\t\t  dead &= attempt;\n \t\t  break;\n \t\t}\n \t      if (code == JUMP_INSN)\n@@ -8775,14 +8775,14 @@ sh_insn_length_adjustment (rtx insn)\n     {\n       int sum = 0;\n       rtx body = PATTERN (insn);\n-      const char *template;\n+      const char *templ;\n       char c;\n       int maybe_label = 1;\n \n       if (GET_CODE (body) == ASM_INPUT)\n-\ttemplate = XSTR (body, 0);\n+\ttempl = XSTR (body, 0);\n       else if (asm_noperands (body) >= 0)\n-\ttemplate\n+\ttempl\n \t  = decode_asm_operands (body, NULL, NULL, NULL, NULL, NULL);\n       else\n \treturn 0;\n@@ -8791,20 +8791,20 @@ sh_insn_length_adjustment (rtx insn)\n \t  int ppi_adjust = 0;\n \n \t  do\n-\t    c = *template++;\n+\t    c = *templ++;\n \t  while (c == ' ' || c == '\\t');\n \t  /* all sh-dsp parallel-processing insns start with p.\n \t     The only non-ppi sh insn starting with p is pref.\n \t     The only ppi starting with pr is prnd.  */\n-\t  if ((c == 'p' || c == 'P') && strncasecmp (\"re\", template, 2))\n+\t  if ((c == 'p' || c == 'P') && strncasecmp (\"re\", templ, 2))\n \t    ppi_adjust = 2;\n \t  /* The repeat pseudo-insn expands two three insns, a total of\n \t     six bytes in size.  */\n \t  else if ((c == 'r' || c == 'R')\n-\t\t   && ! strncasecmp (\"epeat\", template, 5))\n+\t\t   && ! strncasecmp (\"epeat\", templ, 5))\n \t    ppi_adjust = 4;\n \t  while (c && c != '\\n'\n-\t\t && ! IS_ASM_LOGICAL_LINE_SEPARATOR (c, template))\n+\t\t && ! IS_ASM_LOGICAL_LINE_SEPARATOR (c, templ))\n \t    {\n \t      /* If this is a label, it is obviously not a ppi insn.  */\n \t      if (c == ':' && maybe_label)\n@@ -8814,7 +8814,7 @@ sh_insn_length_adjustment (rtx insn)\n \t\t}\n \t      else if (c == '\\'' || c == '\"')\n \t\tmaybe_label = 0;\n-\t      c = *template++;\n+\t      c = *templ++;\n \t    }\n \t  sum += ppi_adjust;\n \t  maybe_label = c != ':';\n@@ -10234,24 +10234,24 @@ sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n    is invalid.  */\n bool\n sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n-\t\t\t     enum reg_class class)\n+\t\t\t     enum reg_class rclass)\n {\n   /* We want to enable the use of SUBREGs as a means to\n      VEC_SELECT a single element of a vector.  */\n   if (to == SFmode && VECTOR_MODE_P (from) && GET_MODE_INNER (from) == SFmode)\n-    return (reg_classes_intersect_p (GENERAL_REGS, class));\n+    return (reg_classes_intersect_p (GENERAL_REGS, rclass));\n \n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n       if (TARGET_LITTLE_ENDIAN)\n \t{\n \t  if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)\n-\t    return reg_classes_intersect_p (DF_REGS, class);\n+\t    return reg_classes_intersect_p (DF_REGS, rclass);\n \t}\n       else\n \t{\n \t  if (GET_MODE_SIZE (from) < 8)\n-\t    return reg_classes_intersect_p (DF_HI_REGS, class);\n+\t    return reg_classes_intersect_p (DF_HI_REGS, rclass);\n \t}\n     }\n   return 0;\n@@ -10371,7 +10371,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n {\n   CUMULATIVE_ARGS cum;\n   int structure_value_byref = 0;\n-  rtx this, this_value, sibcall, insns, funexp;\n+  rtx this_rtx, this_value, sibcall, insns, funexp;\n   tree funtype = TREE_TYPE (function);\n   int simple_add = CONST_OK_FOR_ADD (delta);\n   int did_load = 0;\n@@ -10399,7 +10399,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n       FUNCTION_ARG_ADVANCE (cum, Pmode, ptype, 1);\n     }\n-  this = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);\n+  this_rtx = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);\n \n   /* For SHcompact, we only have r0 for a scratch register: r1 is the\n      static chain pointer (even if you can't have nested virtual functions\n@@ -10440,7 +10440,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \terror (\"Need a call-clobbered target register\");\n     }\n \n-  this_value = plus_constant (this, delta);\n+  this_value = plus_constant (this_rtx, delta);\n   if (vcall_offset\n       && (simple_add || scratch0 != scratch1)\n       && strict_memory_address_p (ptr_mode, this_value))\n@@ -10452,19 +10452,19 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   if (!delta)\n     ; /* Do nothing.  */\n   else if (simple_add)\n-    emit_move_insn (this, this_value);\n+    emit_move_insn (this_rtx, this_value);\n   else\n     {\n       emit_move_insn (scratch1, GEN_INT (delta));\n-      emit_insn (gen_add2_insn (this, scratch1));\n+      emit_insn (gen_add2_insn (this_rtx, scratch1));\n     }\n \n   if (vcall_offset)\n     {\n       rtx offset_addr;\n \n       if (!did_load)\n-\temit_load_ptr (scratch0, this);\n+\temit_load_ptr (scratch0, this_rtx);\n \n       offset_addr = plus_constant (scratch0, vcall_offset);\n       if (strict_memory_address_p (ptr_mode, offset_addr))\n@@ -10474,7 +10474,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  /* scratch0 != scratch1, and we have indexed loads.  Get better\n \t     schedule by loading the offset into r1 and using an indexed\n \t     load - then the load of r1 can issue before the load from\n-             (this + delta) finishes.  */\n+             (this_rtx + delta) finishes.  */\n \t  emit_move_insn (scratch1, GEN_INT (vcall_offset));\n \t  offset_addr = gen_rtx_PLUS (Pmode, scratch0, scratch1);\n \t}\n@@ -10495,7 +10495,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n       if (Pmode != ptr_mode)\n \tscratch0 = gen_rtx_TRUNCATE (ptr_mode, scratch0);\n-      emit_insn (gen_add2_insn (this, scratch0));\n+      emit_insn (gen_add2_insn (this_rtx, scratch0));\n     }\n \n   /* Generate a tail call to the target function.  */\n@@ -10530,7 +10530,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     }\n   sibcall = emit_call_insn (sibcall);\n   SIBLING_CALL_P (sibcall) = 1;\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (sibcall), this);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (sibcall), this_rtx);\n   emit_barrier ();\n \n   /* Run just enough of rest_of_compilation to do scheduling and get\n@@ -10930,19 +10930,19 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n \n   if (GET_CODE (x) == SUBREG)\n     {\n-      rtx new = replace_n_hard_rtx (SUBREG_REG (x), replacements,\n+      rtx new_rtx = replace_n_hard_rtx (SUBREG_REG (x), replacements,\n \t\t\t\t    n_replacements, modify);\n \n-      if (GET_CODE (new) == CONST_INT)\n+      if (GET_CODE (new_rtx) == CONST_INT)\n \t{\n-\t  x = simplify_subreg (GET_MODE (x), new,\n+\t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t       GET_MODE (SUBREG_REG (x)),\n \t\t\t       SUBREG_BYTE (x));\n \t  if (! x)\n \t    abort ();\n \t}\n       else if (modify)\n-\tSUBREG_REG (x) = new;\n+\tSUBREG_REG (x) = new_rtx;\n \n       return x;\n     }\n@@ -10990,45 +10990,45 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n     }\n   else if (GET_CODE (x) == ZERO_EXTEND)\n     {\n-      rtx new = replace_n_hard_rtx (XEXP (x, 0), replacements,\n+      rtx new_rtx = replace_n_hard_rtx (XEXP (x, 0), replacements,\n \t\t\t\t    n_replacements, modify);\n \n-      if (GET_CODE (new) == CONST_INT)\n+      if (GET_CODE (new_rtx) == CONST_INT)\n \t{\n \t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n-\t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n+\t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n \t  if (! x)\n \t    abort ();\n \t}\n       else if (modify)\n-\tXEXP (x, 0) = new;\n+\tXEXP (x, 0) = new_rtx;\n \n       return x;\n     }\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n-      rtx new;\n+      rtx new_rtx;\n \n       if (fmt[i] == 'e')\n \t{\n-\t  new = replace_n_hard_rtx (XEXP (x, i), replacements,\n+\t  new_rtx = replace_n_hard_rtx (XEXP (x, i), replacements,\n \t\t\t\t    n_replacements, modify);\n-\t  if (!new)\n+\t  if (!new_rtx)\n \t    return NULL_RTX;\n \t  if (modify)\n-\t    XEXP (x, i) = new;\n+\t    XEXP (x, i) = new_rtx;\n \t}\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t  {\n-\t    new = replace_n_hard_rtx (XVECEXP (x, i, j), replacements,\n+\t    new_rtx = replace_n_hard_rtx (XVECEXP (x, i, j), replacements,\n \t\t\t\t      n_replacements, modify);\n-\t  if (!new)\n+\t  if (!new_rtx)\n \t    return NULL_RTX;\n \t    if (modify)\n-\t      XVECEXP (x, i, j) = new;\n+\t      XVECEXP (x, i, j) = new_rtx;\n \t  }\n     }\n \n@@ -11162,12 +11162,12 @@ shmedia_prepare_call_address (rtx fnaddr, int is_sibcall)\n }\n \n enum reg_class\n-sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n {\n   if (in_p)\n     {\n-      if (REGCLASS_HAS_FP_REG (class)\n+      if (REGCLASS_HAS_FP_REG (rclass)\n \t  && ! TARGET_SHMEDIA\n \t  && immediate_operand ((x), mode)\n \t  && ! ((fp_zero_operand (x) || fp_one_operand (x))\n@@ -11187,13 +11187,13 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n \t  default:\n \t    abort ();\n \t  }\n-      if (class == FPUL_REGS\n+      if (rclass == FPUL_REGS\n           && ((GET_CODE (x) == REG\n                && (REGNO (x) == MACL_REG || REGNO (x) == MACH_REG\n                    || REGNO (x) == T_REG))\n               || GET_CODE (x) == PLUS))\n         return GENERAL_REGS;\n-      if (class == FPUL_REGS && immediate_operand (x, mode))\n+      if (rclass == FPUL_REGS && immediate_operand (x, mode))\n \t{\n \t  if (satisfies_constraint_I08 (x) || fp_zero_operand (x))\n \t    return GENERAL_REGS;\n@@ -11202,11 +11202,11 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n \t  sri->icode = CODE_FOR_reload_insi__i_fpul;\n \t  return NO_REGS;\n \t}\n-      if (class == FPSCR_REGS\n+      if (rclass == FPSCR_REGS\n           && ((GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n               || (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == PLUS)))\n         return GENERAL_REGS;\n-      if (REGCLASS_HAS_FP_REG (class)\n+      if (REGCLASS_HAS_FP_REG (rclass)\n           && TARGET_SHMEDIA\n           && immediate_operand (x, mode)\n           && x != CONST0_RTX (GET_MODE (x))\n@@ -11219,45 +11219,45 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n \t\t\t? CODE_FOR_reload_inqi : CODE_FOR_reload_inhi);\n \t  return NO_REGS;\n \t}\n-      if (TARGET_SHMEDIA && class == GENERAL_REGS\n+      if (TARGET_SHMEDIA && rclass == GENERAL_REGS\n           && (GET_CODE (x) == LABEL_REF || PIC_DIRECT_ADDR_P (x)))\n         return TARGET_REGS;\n     } /* end of input-only processing.  */\n \n-  if (((REGCLASS_HAS_FP_REG (class)\n+  if (((REGCLASS_HAS_FP_REG (rclass)\n \t&& (GET_CODE (x) == REG\n \t    && (GENERAL_OR_AP_REGISTER_P (REGNO (x))\n \t\t|| (FP_REGISTER_P (REGNO (x)) && mode == SImode\n \t\t    && TARGET_FMOVD))))\n-       || (REGCLASS_HAS_GENERAL_REG (class)\n+       || (REGCLASS_HAS_GENERAL_REG (rclass)\n \t   && GET_CODE (x) == REG\n \t   && FP_REGISTER_P (REGNO (x))))\n       && ! TARGET_SHMEDIA\n       && (mode == SFmode || mode == SImode))\n     return FPUL_REGS;\n-  if ((class == FPUL_REGS\n-       || (REGCLASS_HAS_FP_REG (class)\n+  if ((rclass == FPUL_REGS\n+       || (REGCLASS_HAS_FP_REG (rclass)\n            && ! TARGET_SHMEDIA && mode == SImode))\n       && (GET_CODE (x) == MEM\n           || (GET_CODE (x) == REG\n               && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n                   || REGNO (x) == T_REG\n                   || system_reg_operand (x, VOIDmode)))))\n     {\n-      if (class == FPUL_REGS)\n+      if (rclass == FPUL_REGS)\n \treturn GENERAL_REGS;\n       return FPUL_REGS;\n     }\n-  if ((class == TARGET_REGS\n-       || (TARGET_SHMEDIA && class == SIBCALL_REGS))\n+  if ((rclass == TARGET_REGS\n+       || (TARGET_SHMEDIA && rclass == SIBCALL_REGS))\n       && !satisfies_constraint_Csy (x)\n       && (GET_CODE (x) != REG || ! GENERAL_REGISTER_P (REGNO (x))))\n     return GENERAL_REGS;\n-  if ((class == MAC_REGS || class == PR_REGS)\n+  if ((rclass == MAC_REGS || rclass == PR_REGS)\n       && GET_CODE (x) == REG && ! GENERAL_REGISTER_P (REGNO (x))\n-      && class != REGNO_REG_CLASS (REGNO (x)))\n+      && rclass != REGNO_REG_CLASS (REGNO (x)))\n     return GENERAL_REGS;\n-  if (class != GENERAL_REGS && GET_CODE (x) == REG\n+  if (rclass != GENERAL_REGS && GET_CODE (x) == REG\n       && TARGET_REGISTER_P (REGNO (x)))\n     return GENERAL_REGS;\n   return NO_REGS;"}, {"sha": "045735f208ce1364c21b8008a2a5c7fec6743941", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -8637,7 +8637,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t       HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t       tree function)\n {\n-  rtx this, insn, funexp;\n+  rtx this_rtx, insn, funexp;\n   unsigned int int_arg_first;\n \n   reload_completed = 1;\n@@ -8668,9 +8668,9 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Find the \"this\" pointer.  Normally in %o0, but in ARCH64 if the function\n      returns a structure, the structure return pointer is there instead.  */\n   if (TARGET_ARCH64 && aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, int_arg_first + 1);\n+    this_rtx = gen_rtx_REG (Pmode, int_arg_first + 1);\n   else\n-    this = gen_rtx_REG (Pmode, int_arg_first);\n+    this_rtx = gen_rtx_REG (Pmode, int_arg_first);\n \n   /* Add DELTA.  When possible use a plain add, otherwise load it into\n      a register first.  */\n@@ -8685,20 +8685,20 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  delta_rtx = scratch;\n \t}\n \n-      /* THIS += DELTA.  */\n-      emit_insn (gen_add2_insn (this, delta_rtx));\n+      /* THIS_RTX += DELTA.  */\n+      emit_insn (gen_add2_insn (this_rtx, delta_rtx));\n     }\n \n-  /* Add the word at address (*THIS + VCALL_OFFSET).  */\n+  /* Add the word at address (*THIS_RTX + VCALL_OFFSET).  */\n   if (vcall_offset)\n     {\n       rtx vcall_offset_rtx = GEN_INT (vcall_offset);\n       rtx scratch = gen_rtx_REG (Pmode, 1);\n \n       gcc_assert (vcall_offset < 0);\n \n-      /* SCRATCH = *THIS.  */\n-      emit_move_insn (scratch, gen_rtx_MEM (Pmode, this));\n+      /* SCRATCH = *THIS_RTX.  */\n+      emit_move_insn (scratch, gen_rtx_MEM (Pmode, this_rtx));\n \n       /* Prepare for adding VCALL_OFFSET.  The difficulty is that we\n \t may not have any available scratch register at this point.  */\n@@ -8731,14 +8731,14 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  vcall_offset_rtx = GEN_INT (vcall_offset); /* cannot be 0 */\n \t}\n \n-      /* SCRATCH = *(*THIS + VCALL_OFFSET).  */\n+      /* SCRATCH = *(*THIS_RTX + VCALL_OFFSET).  */\n       emit_move_insn (scratch, gen_rtx_MEM (Pmode,\n \t\t\t\t\t    gen_rtx_PLUS (Pmode,\n \t\t\t\t\t\t\t  scratch,\n \t\t\t\t\t\t\t  vcall_offset_rtx)));\n \n-      /* THIS += *(*THIS + VCALL_OFFSET).  */\n-      emit_insn (gen_add2_insn (this, scratch));\n+      /* THIS_RTX += *(*THIS_RTX + VCALL_OFFSET).  */\n+      emit_insn (gen_add2_insn (this_rtx, scratch));\n     }\n \n   /* Generate a tail call to the target function.  */"}, {"sha": "77aedd6e01e72affe49c5ecc4922ac068188e4eb", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -283,7 +283,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n \t\t\t : get_attr_length (insn) == 4);\n   int really_reversed = reversed ^ need_longbranch;\n   const char *ccode;\n-  const char *template;\n+  const char *templ;\n   const char *operands;\n   enum rtx_code code;\n   \n@@ -329,10 +329,10 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n     }\n \n   if (need_longbranch)\n-    template = \"b%s %s,.+8 | jmpf %s\";\n+    templ = \"b%s %s,.+8 | jmpf %s\";\n   else\n-    template = \"b%s %s,%s\";\n-  sprintf (string, template, ccode, operands, label);\n+    templ = \"b%s %s,%s\";\n+  sprintf (string, templ, ccode, operands, label);\n   \n   return string;\n }\n@@ -354,7 +354,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n   int need_longbranch = get_attr_length (insn) >= 8;\n   int really_reversed = reversed ^ need_longbranch;\n   const char *ccode;\n-  const char *template;\n+  const char *templ;\n   char prevop[16];\n   enum rtx_code code;\n   \n@@ -400,10 +400,10 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n     }\n \n   if (need_longbranch)\n-    template = \"%s | b%s .+6 | jmpf %s\";\n+    templ = \"%s | b%s .+6 | jmpf %s\";\n   else\n-    template = \"%s | b%s %s\";\n-  sprintf (string, template, prevop, ccode, label);\n+    templ = \"%s | b%s %s\";\n+  sprintf (string, templ, prevop, ccode, label);\n   \n   return string;\n }\n@@ -420,19 +420,19 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n    You should define these macros to indicate to the reload phase that it may\n    need to allocate at least one register for a reload in addition to the\n    register to contain the data.  Specifically, if copying X to a register\n-   CLASS in MODE requires an intermediate register, you should define\n+   RCLASS in MODE requires an intermediate register, you should define\n    `SECONDARY_INPUT_RELOAD_CLASS' to return the largest register class all of\n    whose registers can be used as intermediate registers or scratch registers.\n \n-   If copying a register CLASS in MODE to X requires an intermediate or scratch\n+   If copying a register RCLASS in MODE to X requires an intermediate or scratch\n    register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be defined to return the\n    largest register class required.  If the requirements for input and output\n    reloads are the same, the macro `SECONDARY_RELOAD_CLASS' should be used\n    instead of defining both macros identically.\n \n    The values returned by these macros are often `GENERAL_REGS'.  Return\n    `NO_REGS' if no spare register is needed; i.e., if X can be directly copied\n-   to or from a register of CLASS in MODE without requiring a scratch register.\n+   to or from a register of RCLASS in MODE without requiring a scratch register.\n    Do not define this macro if it would always return `NO_REGS'.\n \n    If a scratch register is required (either with or without an intermediate\n@@ -443,7 +443,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n \n    Define constraints for the reload register and scratch register that contain\n    a single register class.  If the original reload register (whose class is\n-   CLASS) can meet the constraint given in the pattern, the value returned by\n+   RCLASS) can meet the constraint given in the pattern, the value returned by\n    these macros is used for the class of the scratch register.  Otherwise, two\n    additional reload registers are required.  Their classes are obtained from\n    the constraints in the insn pattern.\n@@ -461,7 +461,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n    This case often occurs between floating-point and general registers.  */\n \n enum reg_class\n-xstormy16_secondary_reload_class (enum reg_class class,\n+xstormy16_secondary_reload_class (enum reg_class rclass,\n \t\t\t\t  enum machine_mode mode,\n \t\t\t\t  rtx x)\n {\n@@ -471,7 +471,7 @@ xstormy16_secondary_reload_class (enum reg_class class,\n        || ((GET_CODE (x) == SUBREG || GET_CODE (x) == REG)\n \t   && (true_regnum (x) == -1\n \t       || true_regnum (x) >= FIRST_PSEUDO_REGISTER)))\n-      && ! reg_class_subset_p (class, EIGHT_REGS))\n+      && ! reg_class_subset_p (rclass, EIGHT_REGS))\n     return EIGHT_REGS;\n \n   /* When reloading a PLUS, the carry register will be required\n@@ -483,13 +483,13 @@ xstormy16_secondary_reload_class (enum reg_class class,\n }\n \n enum reg_class\n-xstormy16_preferred_reload_class (rtx x, enum reg_class class)\n+xstormy16_preferred_reload_class (rtx x, enum reg_class rclass)\n {\n-  if (class == GENERAL_REGS\n+  if (rclass == GENERAL_REGS\n       && GET_CODE (x) == MEM)\n     return EIGHT_REGS;\n \n-  return class;\n+  return rclass;\n }\n \n /* Predicate for symbols and addresses that reflect special 8-bit"}, {"sha": "ec8496534215781f10f3119244bc23e0626f9c88", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1310,10 +1310,10 @@ init_alignment_context (struct alignment_context *ac, rtx mem)\n \n /* Expand an atomic compare and swap operation for HImode and QImode.\n    MEM is the memory location, CMP the old value to compare MEM with\n-   and NEW the value to set if CMP == MEM.  */\n+   and NEW_RTX the value to set if CMP == MEM.  */\n \n void\n-xtensa_expand_compare_and_swap (rtx target, rtx mem, rtx cmp, rtx new)\n+xtensa_expand_compare_and_swap (rtx target, rtx mem, rtx cmp, rtx new_rtx)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   struct alignment_context ac;\n@@ -1328,7 +1328,7 @@ xtensa_expand_compare_and_swap (rtx target, rtx mem, rtx cmp, rtx new)\n   if (ac.shift != NULL_RTX)\n     {\n       cmp = xtensa_expand_mask_and_shift (cmp, mode, ac.shift);\n-      new = xtensa_expand_mask_and_shift (new, mode, ac.shift);\n+      new_rtx = xtensa_expand_mask_and_shift (new_rtx, mode, ac.shift);\n     }\n \n   /* Load the surrounding word into VAL with the MEM value masked out.  */\n@@ -1337,10 +1337,10 @@ xtensa_expand_compare_and_swap (rtx target, rtx mem, rtx cmp, rtx new)\n \t\t\t\t\t\tOPTAB_DIRECT));\n   emit_label (csloop);\n \n-  /* Patch CMP and NEW into VAL at correct position.  */\n+  /* Patch CMP and NEW_RTX into VAL at correct position.  */\n   cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,\n \t\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT));\n-  newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new, val,\n+  newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new_rtx, val,\n \t\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT));\n \n   /* Jump to end if we're done.  */\n@@ -1384,7 +1384,7 @@ xtensa_expand_atomic (enum rtx_code code, rtx target, rtx mem, rtx val,\n   rtx csloop = gen_label_rtx ();\n   rtx cmp, tmp;\n   rtx old = gen_reg_rtx (SImode);\n-  rtx new = gen_reg_rtx (SImode);\n+  rtx new_rtx = gen_reg_rtx (SImode);\n   rtx orig = NULL_RTX;\n \n   init_alignment_context (&ac, mem);\n@@ -1435,35 +1435,35 @@ xtensa_expand_atomic (enum rtx_code code, rtx target, rtx mem, rtx val,\n       tmp = expand_simple_binop (SImode, AND, old, ac.modemaski,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       tmp = expand_simple_binop (SImode, IOR, tmp, val,\n-\t\t\t\t new, 1, OPTAB_DIRECT);\n+\t\t\t\t new_rtx, 1, OPTAB_DIRECT);\n       break;\n \n     case AND:\n     case IOR:\n     case XOR:\n       tmp = expand_simple_binop (SImode, code, old, val,\n-\t\t\t\t new, 1, OPTAB_DIRECT);\n+\t\t\t\t new_rtx, 1, OPTAB_DIRECT);\n       break;\n \n     case MULT: /* NAND */\n       tmp = expand_simple_binop (SImode, XOR, old, ac.modemask,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       tmp = expand_simple_binop (SImode, AND, tmp, val,\n-\t\t\t\t new, 1, OPTAB_DIRECT);\n+\t\t\t\t new_rtx, 1, OPTAB_DIRECT);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  if (tmp != new)\n-    emit_move_insn (new, tmp);\n-  emit_insn (gen_sync_compare_and_swapsi (cmp, ac.memsi, old, new));\n+  if (tmp != new_rtx)\n+    emit_move_insn (new_rtx, tmp);\n+  emit_insn (gen_sync_compare_and_swapsi (cmp, ac.memsi, old, new_rtx));\n   emit_cmp_and_jump_insns (cmp, old, NE, const0_rtx, SImode, true, csloop);\n \n   if (target)\n     {\n-      tmp = (after ? new : cmp);\n+      tmp = (after ? new_rtx : cmp);\n       convert_move (target,\n \t\t    (ac.shift == NULL_RTX ? tmp\n \t\t     : expand_simple_binop (SImode, LSHIFTRT, tmp, ac.shift,\n@@ -1884,15 +1884,15 @@ override_options (void)\n        mode = (enum machine_mode) ((int) mode + 1))\n     {\n       int size = GET_MODE_SIZE (mode);\n-      enum mode_class class = GET_MODE_CLASS (mode);\n+      enum mode_class mclass = GET_MODE_CLASS (mode);\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n \t  int temp;\n \n \t  if (ACC_REG_P (regno))\n \t    temp = (TARGET_MAC16\n-\t\t    && (class == MODE_INT) && (size <= UNITS_PER_WORD));\n+\t\t    && (mclass == MODE_INT) && (size <= UNITS_PER_WORD));\n \t  else if (GP_REG_P (regno))\n \t    temp = ((regno & 1) == 0 || (size <= UNITS_PER_WORD));\n \t  else if (FP_REG_P (regno))\n@@ -2814,7 +2814,7 @@ xtensa_expand_builtin (tree exp, rtx target,\n \n \n enum reg_class\n-xtensa_preferred_reload_class (rtx x, enum reg_class class, int isoutput)\n+xtensa_preferred_reload_class (rtx x, enum reg_class rclass, int isoutput)\n {\n   if (!isoutput && CONSTANT_P (x) && GET_CODE (x) == CONST_DOUBLE)\n     return NO_REGS;\n@@ -2825,15 +2825,15 @@ xtensa_preferred_reload_class (rtx x, enum reg_class class, int isoutput)\n      won't know that it is live because the hard frame pointer is\n      treated specially.  */\n \n-  if (class == AR_REGS || class == GR_REGS)\n+  if (rclass == AR_REGS || rclass == GR_REGS)\n     return RL_REGS;\n \n-  return class;\n+  return rclass;\n }\n \n \n enum reg_class\n-xtensa_secondary_reload_class (enum reg_class class,\n+xtensa_secondary_reload_class (enum reg_class rclass,\n \t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       rtx x, int isoutput)\n {\n@@ -2845,14 +2845,14 @@ xtensa_secondary_reload_class (enum reg_class class,\n \n   if (!isoutput)\n     {\n-      if ((class == FP_REGS || GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+      if ((rclass == FP_REGS || GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t  && constantpool_mem_p (x))\n \treturn RL_REGS;\n     }\n \n   if (ACC_REG_P (regno))\n-    return ((class == GR_REGS || class == RL_REGS) ? NO_REGS : RL_REGS);\n-  if (class == ACC_REG)\n+    return ((rclass == GR_REGS || rclass == RL_REGS) ? NO_REGS : RL_REGS);\n+  if (rclass == ACC_REG)\n     return (GP_REG_P (regno) ? NO_REGS : RL_REGS);\n \n   return NO_REGS;"}, {"sha": "59c6eecf2c26481695f84c3f234de42640115cb5", "filename": "gcc/reorg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -1529,12 +1529,12 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t    {\n \t      if (! annul_p)\n \t\t{\n-\t\t  rtx new;\n+\t\t  rtx new_rtx;\n \n \t\t  update_block (dtrial, thread);\n-\t\t  new = delete_from_delay_slot (dtrial);\n+\t\t  new_rtx = delete_from_delay_slot (dtrial);\n \t          if (INSN_DELETED_P (thread))\n-\t\t    thread = new;\n+\t\t    thread = new_rtx;\n \t\t  INSN_FROM_TARGET_P (next_to_match) = 0;\n \t\t}\n \t      else\n@@ -1567,12 +1567,12 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t{\n \t  if (GET_MODE (merged_insns) == SImode)\n \t    {\n-\t      rtx new;\n+\t      rtx new_rtx;\n \n \t      update_block (XEXP (merged_insns, 0), thread);\n-\t      new = delete_from_delay_slot (XEXP (merged_insns, 0));\n+\t      new_rtx = delete_from_delay_slot (XEXP (merged_insns, 0));\n \t      if (INSN_DELETED_P (thread))\n-\t\tthread = new;\n+\t\tthread = new_rtx;\n \t    }\n \t  else\n \t    {"}, {"sha": "c92beef74cad3477795403720537510f3db73ba4", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2aaacccae56098361e7b602dd823ac2c9a850e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0a2aaacccae56098361e7b602dd823ac2c9a850e", "patch": "@@ -3915,7 +3915,7 @@ merge_decl_attributes (tree olddecl, tree newdecl)\n    The second instance of `foo' nullifies the dllimport.  */\n \n tree\n-merge_dllimport_decl_attributes (tree old, tree new)\n+merge_dllimport_decl_attributes (tree old, tree new_tree)\n {\n   tree a;\n   int delete_dllimport_p = 1;\n@@ -3926,16 +3926,16 @@ merge_dllimport_decl_attributes (tree old, tree new)\n      is not dllimport'd.  We also remove a `new' dllimport if the old list\n      contains dllexport:  dllexport always overrides dllimport, regardless\n      of the order of declaration.  */     \n-  if (!VAR_OR_FUNCTION_DECL_P (new))\n+  if (!VAR_OR_FUNCTION_DECL_P (new_tree))\n     delete_dllimport_p = 0;\n-  else if (DECL_DLLIMPORT_P (new)\n+  else if (DECL_DLLIMPORT_P (new_tree)\n      \t   && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (old)))\n     { \n-      DECL_DLLIMPORT_P (new) = 0;\n+      DECL_DLLIMPORT_P (new_tree) = 0;\n       warning (OPT_Wattributes, \"%q+D already declared with dllexport attribute: \"\n-\t      \"dllimport ignored\", new);\n+\t      \"dllimport ignored\", new_tree);\n     }\n-  else if (DECL_DLLIMPORT_P (old) && !DECL_DLLIMPORT_P (new))\n+  else if (DECL_DLLIMPORT_P (old) && !DECL_DLLIMPORT_P (new_tree))\n     {\n       /* Warn about overriding a symbol that has already been used, e.g.:\n            extern int __attribute__ ((dllimport)) foo;\n@@ -3945,27 +3945,27 @@ merge_dllimport_decl_attributes (tree old, tree new)\n       if (TREE_USED (old))\n \t{\n \t  warning (0, \"%q+D redeclared without dllimport attribute \"\n-\t\t   \"after being referenced with dll linkage\", new);\n+\t\t   \"after being referenced with dll linkage\", new_tree);\n \t  /* If we have used a variable's address with dllimport linkage,\n \t      keep the old DECL_DLLIMPORT_P flag: the ADDR_EXPR using the\n \t      decl may already have had TREE_CONSTANT computed.\n \t      We still remove the attribute so that assembler code refers\n \t      to '&foo rather than '_imp__foo'.  */\n \t  if (TREE_CODE (old) == VAR_DECL && TREE_ADDRESSABLE (old))\n-\t    DECL_DLLIMPORT_P (new) = 1;\n+\t    DECL_DLLIMPORT_P (new_tree) = 1;\n \t}\n \n       /* Let an inline definition silently override the external reference,\n \t but otherwise warn about attribute inconsistency.  */ \n-      else if (TREE_CODE (new) == VAR_DECL\n-\t       || !DECL_DECLARED_INLINE_P (new))\n+      else if (TREE_CODE (new_tree) == VAR_DECL\n+\t       || !DECL_DECLARED_INLINE_P (new_tree))\n \twarning (OPT_Wattributes, \"%q+D redeclared without dllimport attribute: \"\n-\t\t  \"previous dllimport ignored\", new);\n+\t\t  \"previous dllimport ignored\", new_tree);\n     }\n   else\n     delete_dllimport_p = 0;\n \n-  a = merge_attributes (DECL_ATTRIBUTES (old), DECL_ATTRIBUTES (new));\n+  a = merge_attributes (DECL_ATTRIBUTES (old), DECL_ATTRIBUTES (new_tree));\n \n   if (delete_dllimport_p) \n     {"}]}