{"sha": "3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y2MWI0MmYyYjg3MjdhNGZkMDBkNjk1NmM5MWZiMmJiZTc3ZGQ4OA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2007-11-15T14:30:58Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2007-11-15T14:30:58Z"}, "message": "spu-protos.h (legitimate_const): Remove prototype.\n\n\t* config/spu/spu-protos.h (legitimate_const): Remove prototype.\n\t* config/spu/spu.c (legitimate_const): Remove.\n\t(classify_immediate): Inline call to legitimate_const.\n\t(spu_legitimate_address): Likewise.  Allow SMBOL_REF + CONST_INT\n\tfor any constant, not just -512 .. 511.\n\nFrom-SVN: r130200", "tree": {"sha": "93e5da469c246c089f6519c410dcf37b1b4a5407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93e5da469c246c089f6519c410dcf37b1b4a5407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/comments", "author": null, "committer": null, "parents": [{"sha": "dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9"}], "stats": {"total": 60, "additions": 33, "deletions": 27}, "files": [{"sha": "d5683b916937e4a9005d56d0c8e41a2bb6ec0d99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "patch": "@@ -1,3 +1,11 @@\n+2007-11-15  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu-protos.h (legitimate_const): Remove prototype.\n+\t* config/spu/spu.c (legitimate_const): Remove.\n+\t(classify_immediate): Inline call to legitimate_const.\n+\t(spu_legitimate_address): Likewise.  Allow SMBOL_REF + CONST_INT\n+\tfor any constant, not just -512 .. 511.\n+\n 2007-11-15  Sa Liu  <saliu@de.ibm.com>\n \n \t* config/spu/spu.c (spu_emit_branch_or_set): Remove PROCESSOR_CELL"}, {"sha": "ab85d5debb3d72a72d7c03199e6da1dfecfd2861", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "patch": "@@ -52,7 +52,6 @@ extern int logical_immediate_p (rtx op, enum machine_mode mode);\n extern int iohl_immediate_p (rtx op, enum machine_mode mode);\n extern int arith_immediate_p (rtx op, enum machine_mode mode,\n \t\t\t      HOST_WIDE_INT low, HOST_WIDE_INT high);\n-extern int legitimate_const (rtx x, int aligned);\n extern int spu_constant_address_p (rtx x);\n extern int spu_legitimate_constant_p (rtx x);\n extern int spu_legitimate_address (enum machine_mode mode, rtx x,"}, {"sha": "79693b829d6173bfb81c3568858c8e56ba88362e", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=3f61b42f2b8727a4fd00d6956c91fb2bbe77dd88", "patch": "@@ -2475,29 +2475,6 @@ spu_float_const (const char *string, enum machine_mode mode)\n   return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n }\n \n-/* Given a (CONST (PLUS (SYMBOL_REF) (CONST_INT))) return TRUE when the\n-   CONST_INT fits constraint 'K', i.e., is small. */\n-int\n-legitimate_const (rtx x, int aligned)\n-{\n-  /* We can never know if the resulting address fits in 18 bits and can be\n-     loaded with ila.  Instead we should use the HI and LO relocations to\n-     load a 32-bit address.  */\n-  rtx sym, cst;\n-\n-  gcc_assert (GET_CODE (x) == CONST);\n-\n-  if (GET_CODE (XEXP (x, 0)) != PLUS)\n-    return 0;\n-  sym = XEXP (XEXP (x, 0), 0);\n-  cst = XEXP (XEXP (x, 0), 1);\n-  if (GET_CODE (sym) != SYMBOL_REF || GET_CODE (cst) != CONST_INT)\n-    return 0;\n-  if (aligned && ((INTVAL (cst) & 15) != 0 || !ALIGNED_SYMBOL_REF_P (sym)))\n-    return 0;\n-  return satisfies_constraint_K (cst);\n-}\n-\n int\n spu_constant_address_p (rtx x)\n {\n@@ -2618,8 +2595,20 @@ classify_immediate (rtx op, enum machine_mode mode)\n       return TARGET_LARGE_MEM ? IC_IL2s : IC_IL1s;\n \n     case CONST:\n-      return TARGET_LARGE_MEM\n-\t|| !legitimate_const (op, 0) ? IC_IL2s : IC_IL1s;\n+      /* We can never know if the resulting address fits in 18 bits and can be\n+\t loaded with ila.  For now, assume the address will not overflow if\n+\t the displacement is \"small\" (fits 'K' constraint).  */\n+      if (!TARGET_LARGE_MEM && GET_CODE (XEXP (op, 0)) == PLUS)\n+\t{\n+\t  rtx sym = XEXP (XEXP (op, 0), 0);\n+\t  rtx cst = XEXP (XEXP (op, 0), 1);\n+\n+\t  if (GET_CODE (sym) == SYMBOL_REF\n+\t      && GET_CODE (cst) == CONST_INT\n+\t      && satisfies_constraint_K (cst))\n+\t    return IC_IL1s;\n+\t}\n+      return IC_IL2s;\n \n     case HIGH:\n       return IC_IL1s;\n@@ -2870,7 +2859,17 @@ spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n       return !TARGET_LARGE_MEM;\n \n     case CONST:\n-      return !TARGET_LARGE_MEM && legitimate_const (x, 0);\n+      if (!TARGET_LARGE_MEM && GET_CODE (XEXP (x, 0)) == PLUS)\n+\t{\n+\t  rtx sym = XEXP (XEXP (x, 0), 0);\n+\t  rtx cst = XEXP (XEXP (x, 0), 1);\n+\n+\t  /* Accept any symbol_ref + constant, assuming it does not\n+\t     wrap around the local store addressability limit.  */\n+\t  if (GET_CODE (sym) == SYMBOL_REF && GET_CODE (cst) == CONST_INT)\n+\t    return 1;\n+\t}\n+      return 0;\n \n     case CONST_INT:\n       return INTVAL (x) >= 0 && INTVAL (x) <= 0x3ffff;"}]}