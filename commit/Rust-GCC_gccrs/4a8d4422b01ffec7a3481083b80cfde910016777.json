{"sha": "4a8d4422b01ffec7a3481083b80cfde910016777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4ZDQ0MjJiMDFmZmVjN2EzNDgxMDgzYjgwY2ZkZTkxMDAxNjc3Nw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-09-23T20:36:21Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-09-23T20:36:21Z"}, "message": "re PR fortran/48298 ([F03] User-Defined Derived-Type IO (DTIO))\n\n2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/48298\n\t* io/inquire.c (inquire_via_unit): Adjust error check for the\n\ttwo possible internal unit KINDs.\n\t* io/io.h: Adjust defines for is_internal_unit and\n\tis_char4_unit. (gfc_unit): Add internal unit data to structure.\n\t(get_internal_unit): Change declaration to set_internal_unit.\n\t(free_internal_unit): Change name to stash_internal_unit_number.\n\t(get_unique_unit_number): Adjust parameter argument.\n\tDefine IOPARM_DT_HAS_UDTIO. (gfc_saved_unit): New structure.\n\t* io/list_read.c (next_char_internal): Use is_char4_unit.\n\t* io/open.c (st_open): Adjust call to get_unique_unit_number.\n\t* io/transfer.c (write_block): Use is_char4_unit.\n\t(data_transfer_init): Update check for unit numbers.\n\t(st_read_done): Free the various allocated memories used for the\n\tinternal units and stash the negative unit number and pointer to unit\n\tstructure to allow reuse. (st_write_done): Likewise stash the freed\n\tunit.\n\t* io/unit.c: Create a fixed size buffer of 16 gfc_saved_unit's to use\n\tas a stack to save newunit unit numbers and unit structure for reuse.\n\t(get_external_unit): Change name to get_gfc_unit to better\n\treflect what it does. (find_unit): Change call to get_gfc_unit.\n\t(find_or_create_unit): Likewise. (get_internal_unit): Change\n\tname to set_internal_unit. Move internal unit from the dtp\n\tstructure to the gfc_unit structure so that it can be passed to\n\tchild I/O statements through the UNIT.\n\t(free_internal_unit): Change name to stash_internal_unit_number.\n\tPush the common.unit number onto the newunit stack, saving it\n\tfor possible reuse later. (get_unit): Set the internal unit\n\tKIND. Use get_unique_unit_number to get a negative unit number\n\tfor the internal unit. Use get_gfc_unit to get the unit structure\n\tand use set_internal_unit to initialize it.\n\t(init_units): Initialize the newunit stack.\n\t(get_unique_unit_number): Check the stack for an available unit\n\tnumber and use it. If none there get the next most negative\n\tnumber. (close_units): Free any unit structures pointed to from the save\n\tstack.\n\n2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/48298\n\t* gfortran.h (gfc_dt): Add *udtio.\n\t* ioparm.def: Add bit IOPARM_dt_f2003 to align with library use of bit\n\t25. Add IOPARM_dt_dtio bit to common flags.\n\t* resolve.c (resolve_transfer): Set dt->udtio to expression.\n\t* io.c (gfc_match_inquire): Adjust error message for internal\n\tunit KIND.\n\t* libgfortran.h: Adjust defines for GFC_INTERNAL_UNIT4,\n\tGFC_INTERNAL_UNIT, and GFC_INVALID_UNIT.\n\t* trans-io.c (build_dt): Set common_unit to reflect the KIND of\n\tthe internal unit. Set mask bit for presence of dt->udtio.\n\n2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/48298\n\t* gfortran.dg/negative_unit_check.f90: Update test.\n\t* gfortran.dg/dtio_14.f90: New test.\n\nFrom-SVN: r240456", "tree": {"sha": "233a922b1c65dc6ce62e04057d6568b939d7ccc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/233a922b1c65dc6ce62e04057d6568b939d7ccc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8d4422b01ffec7a3481083b80cfde910016777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8d4422b01ffec7a3481083b80cfde910016777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8d4422b01ffec7a3481083b80cfde910016777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8d4422b01ffec7a3481083b80cfde910016777/comments", "author": null, "committer": null, "parents": [{"sha": "9f38dde2306d9a482c03eeaa59688a30d566c8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f38dde2306d9a482c03eeaa59688a30d566c8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f38dde2306d9a482c03eeaa59688a30d566c8ff"}], "stats": {"total": 458, "additions": 328, "deletions": 130}, "files": [{"sha": "daed721dbadfcbed50ad45ed6d1b1edbbd5313e9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -1,3 +1,17 @@\n+2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/48298\n+\t* gfortran.h (gfc_dt): Add *udtio.\n+\t* ioparm.def: Add bit IOPARM_dt_f2003 to align with library use of bit\n+\t25. Add IOPARM_dt_dtio bit to common flags.\n+\t* resolve.c (resolve_transfer): Set dt->udtio to expression.\n+\t* io.c (gfc_match_inquire): Adjust error message for internal\n+\tunit KIND.\n+\t* libgfortran.h: Adjust defines for GFC_INTERNAL_UNIT4,\n+\tGFC_INTERNAL_UNIT, and GFC_INVALID_UNIT.\n+\t* trans-io.c (build_dt): Set common_unit to reflect the KIND of\n+\tthe internal unit. Set mask bit for presence of dt->udtio.\n+\n 2016-09-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get): Use the old caf-"}, {"sha": "1837a53ddb8180b82dd75dfe3ae7b855e179769c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -2332,7 +2332,7 @@ typedef struct\n {\n   gfc_expr *io_unit, *format_expr, *rec, *advance, *iostat, *size, *iomsg,\n \t   *id, *pos, *asynchronous, *blank, *decimal, *delim, *pad, *round,\n-\t   *sign, *extra_comma, *dt_io_kind;\n+\t   *sign, *extra_comma, *dt_io_kind, *udtio;\n \n   gfc_symbol *namelist;\n   /* A format_label of `format_asterisk' indicates the \"*\" format */"}, {"sha": "48c15ef55f9bfbb63b0b49ce16e55792a10c0773", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -4256,9 +4256,11 @@ gfc_match_inquire (void)\n \n   if (inquire->unit != NULL && inquire->unit->expr_type == EXPR_CONSTANT\n       && inquire->unit->ts.type == BT_INTEGER\n-      && mpz_get_si (inquire->unit->value.integer) == GFC_INTERNAL_UNIT)\n+      && ((mpz_get_si (inquire->unit->value.integer) == GFC_INTERNAL_UNIT4)\n+      || (mpz_get_si (inquire->unit->value.integer) == GFC_INTERNAL_UNIT)))\n     {\n-      gfc_error (\"UNIT number in INQUIRE statement at %L can not be -1\", &loc);\n+      gfc_error (\"UNIT number in INQUIRE statement at %L can not \"\n+\t\t \"be %d\", &loc, (int) mpz_get_si (inquire->unit->value.integer));\n       goto cleanup;\n     }\n "}, {"sha": "17b7ac78818878f3aa7979797882c2c5047873af", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -113,3 +113,5 @@ IOPARM (dt,      delim,\t\t1 << 21, char2)\n IOPARM (dt,      pad,\t\t1 << 22, char1)\n IOPARM (dt,      round,\t\t1 << 23, char2)\n IOPARM (dt,      sign,\t\t1 << 24, char1)\n+#define IOPARM_dt_f2003\t\t      (1 << 25)\n+#define IOPARM_dt_dtio\t\t      (1 << 26)"}, {"sha": "cc355086caea23240c4621d69b4d2e7a7e491af0", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -68,10 +68,11 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t| GFC_RTCHECK_RECURSION | GFC_RTCHECK_DO \\\n \t\t\t\t| GFC_RTCHECK_POINTER | GFC_RTCHECK_MEM)\n \n-/* Special unit numbers used to convey certain conditions.  Numbers -3\n+/* Special unit numbers used to convey certain conditions.  Numbers -4\n    thru -9 available.  NEWUNIT values start at -10.  */\n-#define GFC_INTERNAL_UNIT -1\n-#define GFC_INVALID_UNIT  -2\n+#define GFC_INTERNAL_UNIT4 -1    /* KIND=4 Internal Unit.  */\n+#define GFC_INTERNAL_UNIT  -2    /* KIND=1 Internal Unit.  */\n+#define GFC_INVALID_UNIT   -3\n \n /* Possible values for the CONVERT I/O specifier.  */\n /* Keep in sync with GFC_FLAG_CONVERT_* in gcc/flags.h.  */"}, {"sha": "9998302714a8beacf5b255daf82154cd434eedbc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -8739,6 +8739,7 @@ resolve_transfer (gfc_code *code)\n \n       if (dtio_sub != NULL && exp->expr_type == EXPR_VARIABLE)\n \t{\n+\t  dt->udtio = exp;\n \t  sym = exp->symtree->n.sym->ns->proc_name;\n \t  /* Check to see if this is a nested DTIO call, with the\n \t     dummy as the io-list object.  */"}, {"sha": "c0559f3623720f6f138330c1bdd9bdf2456a94b1", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -1808,7 +1808,8 @@ build_dt (tree function, gfc_code * code)\n \t  mask |= set_internal_unit (&block, &post_iu_block,\n \t\t\t\t     var, dt->io_unit);\n \t  set_parameter_const (&block, var, IOPARM_common_unit,\n-\t\t\t       dt->io_unit->ts.kind == 1 ? 0 : -1);\n+\t\t\t       dt->io_unit->ts.kind == 1 ?\n+\t\t\t        GFC_INTERNAL_UNIT : GFC_INTERNAL_UNIT4);\n \t}\n     }\n   else\n@@ -1892,6 +1893,9 @@ build_dt (tree function, gfc_code * code)\n \tmask |= set_parameter_ref (&block, &post_end_block, var,\n \t\t\t\t   IOPARM_dt_size, dt->size);\n \n+      if (dt->udtio)\n+\tmask |= IOPARM_dt_dtio;\n+\n       if (dt->namelist)\n \t{\n \t  if (dt->format_expr || dt->format_label)"}, {"sha": "09b6599c43a1249e43b1c76c2823c294d272b674", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -1,3 +1,9 @@\n+2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/48298\n+\t* gfortran.dg/negative_unit_check.f90: Update test.\n+\t* gfortran.dg/dtio_14.f90: New test.\n+  \n 2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/hotpatch-compile-1.c: Fixed dg-error test."}, {"sha": "16d5b1e40c97eafb0c6b6e11d29b04b2f77e08f8", "filename": "gcc/testsuite/gfortran.dg/dtio_14.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_14.f90?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+!\n+! Functional test of User Defined Derived Type IO with typebound bindings\n+! This version tests IO to internal character units.\n+!\n+MODULE p\n+  TYPE :: person\n+    CHARACTER (LEN=20) :: name\n+    INTEGER(4) :: age\n+    CONTAINS\n+      procedure :: pwf\n+      procedure :: prf\n+      GENERIC :: WRITE(FORMATTED) => pwf\n+      GENERIC :: READ(FORMATTED) => prf\n+  END TYPE person\n+CONTAINS\n+  SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE(unit, FMT = *, IOSTAT=iostat) dtv%name, dtv%age\n+  END SUBROUTINE pwf\n+\n+  SUBROUTINE prf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    READ (UNIT = UNIT, FMT = *) dtv%name, dtv%age\n+  END SUBROUTINE prf\n+END MODULE p\n+\n+PROGRAM test\n+  USE p\n+  TYPE (person) :: chairman, answer\n+  character(kind=1,len=80) :: str1\n+  character(kind=4,len=80) :: str4\n+  str1 = \"\"\n+  str4 = 4_\"\"\n+  chairman%name=\"Charlie\"\n+  chairman%age=62\n+  answer = chairman\n+! KIND=1 test\n+  write (str1, *) chairman\n+  if (trim(str1).ne.\"  Charlie                       62\") call abort\n+  chairman%name=\"Bogus\"\n+  chairman%age=99\n+  read (str1, *) chairman\n+  if (chairman%name.ne.answer%name) call abort\n+  if (chairman%age.ne.answer%age) call abort\n+! KIND=4 test\n+  write (str4, *) chairman\n+  if (trim(str4).ne.4_\"  Charlie                       62\") call abort\n+  chairman%name=\"Bogus\"\n+  chairman%age=99\n+  read (str4, *) chairman\n+  if (chairman%name.ne.answer%name) call abort\n+  if (chairman%age.ne.answer%age) call abort\n+END PROGRAM test"}, {"sha": "002b5b4ac8279b6114762d3c473525c9be704305", "filename": "gcc/testsuite/gfortran.dg/negative_unit_check.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_unit_check.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_unit_check.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_unit_check.f90?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -2,4 +2,5 @@\n !  Test case from PR61933.\n    LOGICAL :: file_exists\n    INQUIRE(UNIT=-1,EXIST=file_exists)! { dg-error \"can not be -1\" }\n+   INQUIRE(UNIT=-2,EXIST=file_exists)! { dg-error \"can not be -2\" }\n END"}, {"sha": "f312a066c18da96206094b070da727c0fcd60152", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -1,3 +1,42 @@\n+2016-09-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/48298\n+\t* io/inquire.c (inquire_via_unit): Adjust error check for the\n+\ttwo possible internal unit KINDs.\n+\t* io/io.h: Adjust defines for is_internal_unit and\n+\tis_char4_unit. (gfc_unit): Add internal unit data to structure.\n+\t(get_internal_unit): Change declaration to set_internal_unit.\n+\t(free_internal_unit): Change name to stash_internal_unit_number.\n+\t(get_unique_unit_number): Adjust parameter argument.\n+\tDefine IOPARM_DT_HAS_UDTIO. (gfc_saved_unit): New structure.\n+\t* io/list_read.c (next_char_internal): Use is_char4_unit.\n+\t* io/open.c (st_open): Adjust call to get_unique_unit_number.\n+\t* io/transfer.c (write_block): Use is_char4_unit.\n+\t(data_transfer_init): Update check for unit numbers.\n+\t(st_read_done): Free the various allocated memories used for the\n+\tinternal units and stash the negative unit number and pointer to unit\n+\tstructure to allow reuse. (st_write_done): Likewise stash the freed\n+\tunit.\n+\t* io/unit.c: Create a fixed size buffer of 16 gfc_saved_unit's to use\n+\tas a stack to save newunit unit numbers and unit structure for reuse.\n+\t(get_external_unit): Change name to get_gfc_unit to better\n+\treflect what it does. (find_unit): Change call to get_gfc_unit.\n+\t(find_or_create_unit): Likewise. (get_internal_unit): Change\n+\tname to set_internal_unit. Move internal unit from the dtp\n+\tstructure to the gfc_unit structure so that it can be passed to\n+\tchild I/O statements through the UNIT.\n+\t(free_internal_unit): Change name to stash_internal_unit_number.\n+\tPush the common.unit number onto the newunit stack, saving it\n+\tfor possible reuse later. (get_unit): Set the internal unit\n+\tKIND. Use get_unique_unit_number to get a negative unit number\n+\tfor the internal unit. Use get_gfc_unit to get the unit structure\n+\tand use set_internal_unit to initialize it.\n+\t(init_units): Initialize the newunit stack.\n+\t(get_unique_unit_number): Check the stack for an available unit\n+\tnumber and use it. If none there get the next most negative\n+\tnumber. (close_units): Free any unit structures pointed to from the save\n+\tstack.\n+\n 2016-09-21  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* intrinsics/random.c (getosrandom): Use rand_s() on"}, {"sha": "2bb518b69c7fdfeb5f3724f6b544dfb80be2e545", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -41,7 +41,7 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n   const char *p;\n   GFC_INTEGER_4 cf = iqp->common.flags;\n \n-  if (iqp->common.unit == GFC_INTERNAL_UNIT)\n+  if (iqp->common.unit == GFC_INTERNAL_UNIT || iqp->common.unit == GFC_INTERNAL_UNIT4)\n     generate_error (&iqp->common, LIBERROR_INQUIRE_INTERNAL_UNIT, NULL);\n \n   if ((cf & IOPARM_INQUIRE_HAS_EXIST) != 0)"}, {"sha": "87c35583754729dd424962573c52d5b97dacccff", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -69,11 +69,11 @@ internal_proto(old_locale_lock);\n \n #define is_array_io(dtp) ((dtp)->internal_unit_desc)\n \n-#define is_internal_unit(dtp) ((dtp)->u.p.unit_is_internal)\n+#define is_internal_unit(dtp) ((dtp)->u.p.current_unit->internal_unit_kind)\n \n #define is_stream_io(dtp) ((dtp)->u.p.current_unit->flags.access == ACCESS_STREAM)\n \n-#define is_char4_unit(dtp) ((dtp)->u.p.unit_is_internal && (dtp)->common.unit)\n+#define is_char4_unit(dtp) ((dtp)->u.p.current_unit->internal_unit_kind == 4)\n \n /* The array_loop_spec contains the variables for the loops over index ranges\n    that are encountered.  */\n@@ -409,6 +409,7 @@ st_parameter_inquire;\n #define IOPARM_DT_HAS_ROUND\t\t\t(1 << 23)\n #define IOPARM_DT_HAS_SIGN\t\t\t(1 << 24)\n #define IOPARM_DT_HAS_F2003                     (1 << 25)\n+#define IOPARM_DT_HAS_UDTIO                     (1 << 26)\n /* Internal use bit.  */\n #define IOPARM_DT_IONML_SET\t\t\t(1u << 31)\n \n@@ -640,12 +641,24 @@ typedef struct gfc_unit\n   int (*next_char_fn_ptr) (st_parameter_dt *);\n   void (*push_char_fn_ptr) (st_parameter_dt *, int);\n \n+  /* Internal unit char string data.  */\n+  char * internal_unit;\n+  gfc_charlen_type internal_unit_len;\n+  gfc_array_char *string_unit_desc;\n+  int internal_unit_kind;\n+\n   /* DTIO Parent/Child procedure, 0 = parent, >0 = child level.  */\n   int child_dtio;\n   int last_char;\n }\n gfc_unit;\n \n+typedef struct gfc_saved_unit\n+{\n+  GFC_INTEGER_4 unit_number;\n+  gfc_unit *unit;\n+}\n+gfc_saved_unit;\n \n /* unit.c */\n \n@@ -663,11 +676,11 @@ internal_proto(unit_lock);\n extern int close_unit (gfc_unit *);\n internal_proto(close_unit);\n \n-extern gfc_unit *get_internal_unit (st_parameter_dt *);\n-internal_proto(get_internal_unit);\n+extern gfc_unit *set_internal_unit (st_parameter_dt *, gfc_unit *, int);\n+internal_proto(set_internal_unit);\n \n-extern void free_internal_unit (st_parameter_dt *);\n-internal_proto(free_internal_unit);\n+extern void stash_internal_unit (st_parameter_dt *);\n+internal_proto(stash_internal_unit);\n \n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n@@ -687,7 +700,7 @@ internal_proto (finish_last_advance_record);\n extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);\n internal_proto (unit_truncate);\n \n-extern GFC_INTEGER_4 get_unique_unit_number (st_parameter_open *);\n+extern GFC_INTEGER_4 get_unique_unit_number (st_parameter_common *);\n internal_proto(get_unique_unit_number);\n \n /* open.c */"}, {"sha": "f258c9d92499b787adfb2592f8f07daac8e59768", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -267,7 +267,7 @@ next_char_internal (st_parameter_dt *dtp)\n \n   /* Get the next character and handle end-of-record conditions.  */\n \n-  if (dtp->common.unit) /* Check for kind=4 internal unit.  */\n+  if (is_char4_unit(dtp)) /* Check for kind=4 internal unit.  */\n    length = sread (dtp->u.p.current_unit->s, &c, 1);\n   else\n    {\n@@ -390,7 +390,7 @@ eat_spaces (st_parameter_dt *dtp)\n       gfc_offset offset = stell (dtp->u.p.current_unit->s);\n       gfc_offset i;\n \n-      if (dtp->common.unit) /* kind=4 */\n+      if (is_char4_unit(dtp)) /* kind=4 */\n \t{\n \t  for (i = 0; i < dtp->u.p.current_unit->bytes_left; i++)\n \t    {"}, {"sha": "d074b020d8113c8d858ce3e0cbcf3f874162b7eb", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -812,7 +812,7 @@ st_open (st_parameter_open *opp)\n   if ((opp->common.flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_OK)\n     {\n       if ((opp->common.flags & IOPARM_OPEN_HAS_NEWUNIT))\n-\topp->common.unit = get_unique_unit_number(opp);\n+\topp->common.unit = get_unique_unit_number(&opp->common);\n       else if (opp->common.unit < 0)\n \t{\n \t  u = find_unit (opp->common.unit);"}, {"sha": "6009c123d71b8f5c50bfa7b0ae1d678cac0aef18", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -737,7 +737,7 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (is_internal_unit (dtp))\n     {\n-      if (dtp->common.unit) /* char4 internel unit.  */\n+      if (is_char4_unit(dtp)) /* char4 internel unit.  */\n \t{\n \t  gfc_char4_t *dest4;\n \t  dest4 = mem_alloc_w4 (dtp->u.p.current_unit->s, &length);\n@@ -2606,7 +2606,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n        st_parameter_open opp;\n        unit_convert conv;\n \n-      if (dtp->common.unit < 0)\n+      if (dtp->common.unit < 0 && !is_internal_unit (dtp))\n \t{\n \t  close_unit (dtp->u.p.current_unit);\n \t  dtp->u.p.current_unit = NULL;\n@@ -3943,18 +3943,34 @@ st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n-  if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n-    {\n-      free_format_data (dtp->u.p.fmt);\n-      free_format (dtp);\n-    }\n-\n   free_ionml (dtp);\n \n-  if (dtp->u.p.current_unit != NULL)\n-    unlock_unit (dtp->u.p.current_unit);\n-\n-  free_internal_unit (dtp);\n+  /* If this is a parent READ statement we do not need to retain the\n+     internal unit structure for child use.  Free it and stash the unit\n+     number for reuse.  */\n+  if (dtp->u.p.current_unit != NULL\n+      && dtp->u.p.current_unit->child_dtio == 0)\n+    {\n+      if (is_internal_unit (dtp) &&\n+\t  (dtp->common.flags & IOPARM_DT_HAS_UDTIO) == 0)\n+        {\n+\t  free (dtp->u.p.current_unit->filename);\n+\t  dtp->u.p.current_unit->filename = NULL;\n+\t  free_format_hash_table (dtp->u.p.current_unit);\n+\t  free (dtp->u.p.current_unit->s);\n+\t  dtp->u.p.current_unit->s = NULL;\n+\t  if (dtp->u.p.current_unit->ls)\n+\t    free (dtp->u.p.current_unit->ls);\n+\t  dtp->u.p.current_unit->ls = NULL;\n+\t  stash_internal_unit (dtp);\n+\t}\n+      if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n+\t{\n+\t  free_format_data (dtp->u.p.fmt);\n+\t  free_format (dtp);\n+\t}\n+      unlock_unit (dtp->u.p.current_unit);\n+    }\n \n   library_end ();\n }\n@@ -3977,43 +3993,55 @@ st_write_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n-  /* Deal with endfile conditions associated with sequential files.  */\n-\n   if (dtp->u.p.current_unit != NULL\n-      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n       && dtp->u.p.current_unit->child_dtio == 0)\n-    switch (dtp->u.p.current_unit->endfile)\n-      {\n-      case AT_ENDFILE:\t\t/* Remain at the endfile record.  */\n-\tbreak;\n-\n-      case AFTER_ENDFILE:\n-\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\t/* Just at it now.  */\n-\tbreak;\n-\n-      case NO_ENDFILE:\n-\t/* Get rid of whatever is after this record.  */\n-        if (!is_internal_unit (dtp))\n-          unit_truncate (dtp->u.p.current_unit,\n-                         stell (dtp->u.p.current_unit->s),\n-                         &dtp->common);\n-\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\tbreak;\n-      }\n-\n-  if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n     {\n-      free_format_data (dtp->u.p.fmt);\n-      free_format (dtp);\n-    }\n+      /* Deal with endfile conditions associated with sequential files.  */\n+      if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+\tswitch (dtp->u.p.current_unit->endfile)\n+\t  {\n+\t  case AT_ENDFILE:\t\t/* Remain at the endfile record.  */\n+\t    break;\n \n-  free_ionml (dtp);\n+\t  case AFTER_ENDFILE:\n+\t    dtp->u.p.current_unit->endfile = AT_ENDFILE; /* Just at it now.  */\n+\t    break;\n \n-  if (dtp->u.p.current_unit != NULL)\n-    unlock_unit (dtp->u.p.current_unit);\n+\t  case NO_ENDFILE:\n+\t    /* Get rid of whatever is after this record.  */\n+\t    if (!is_internal_unit (dtp))\n+\t      unit_truncate (dtp->u.p.current_unit,\n+\t\t\t     stell (dtp->u.p.current_unit->s),\n+\t\t\t     &dtp->common);\n+\t    dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t    break;\n+\t  }\n \n-  free_internal_unit (dtp);\n+      free_ionml (dtp);\n \n+      /* If this is a parent WRITE statement we do not need to retain the\n+\t internal unit structure for child use.  Free it and stash the\n+\t unit number for reuse.  */\n+      if (is_internal_unit (dtp) &&\n+\t  (dtp->common.flags & IOPARM_DT_HAS_UDTIO) == 0)\n+\t{\n+\t  free (dtp->u.p.current_unit->filename);\n+\t  dtp->u.p.current_unit->filename = NULL;\n+\t  free_format_hash_table (dtp->u.p.current_unit);\n+\t  free (dtp->u.p.current_unit->s);\n+\t  dtp->u.p.current_unit->s = NULL;\n+\t  if (dtp->u.p.current_unit->ls)\n+\t    free (dtp->u.p.current_unit->ls);\n+\t  dtp->u.p.current_unit->ls = NULL;\n+\t  stash_internal_unit (dtp);\n+\t}\n+      if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n+\t{\n+\t  free_format_data (dtp->u.p.fmt);\n+\t  free_format (dtp);\n+\t}\n+      unlock_unit (dtp->u.p.current_unit);\n+    }\n   library_end ();\n }\n "}, {"sha": "274b24b686eab0a18d476412604c7085f8bc2e76", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 93, "deletions": 70, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d4422b01ffec7a3481083b80cfde910016777/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=4a8d4422b01ffec7a3481083b80cfde910016777", "patch": "@@ -72,8 +72,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* Unit number to be assigned when NEWUNIT is used in an OPEN statement.  */\n #define GFC_FIRST_NEWUNIT -10\n+#define NEWUNIT_STACK_SIZE 16\n static GFC_INTEGER_4 next_available_newunit = GFC_FIRST_NEWUNIT;\n \n+/* A stack to save previously used newunit-assigned unit numbers to\n+   allow them to be reused without reallocating the gfc_unit structure\n+   which is still in the treap.  */\n+static gfc_saved_unit newunit_stack[NEWUNIT_STACK_SIZE];\n+static int newunit_tos = 0; /* Index to Top of Stack.  */\n+\n #define CACHE_SIZE 3\n static gfc_unit *unit_cache[CACHE_SIZE];\n gfc_offset max_offset;\n@@ -294,12 +301,12 @@ delete_unit (gfc_unit * old)\n }\n \n \n-/* get_external_unit()-- Given an integer, return a pointer to the unit\n+/* get_gfc_unit()-- Given an integer, return a pointer to the unit\n  * structure.  Returns NULL if the unit does not exist,\n  * otherwise returns a locked unit. */\n \n static gfc_unit *\n-get_external_unit (int n, int do_create)\n+get_gfc_unit (int n, int do_create)\n {\n   gfc_unit *p;\n   int c, created = 0;\n@@ -361,6 +368,7 @@ get_external_unit (int n, int do_create)\n       inc_waiting_locked (p);\n     }\n \n+\n   __gthread_mutex_unlock (&unit_lock);\n \n   if (p != NULL && (p->child_dtio == 0))\n@@ -384,14 +392,14 @@ get_external_unit (int n, int do_create)\n gfc_unit *\n find_unit (int n)\n {\n-  return get_external_unit (n, 0);\n+  return get_gfc_unit (n, 0);\n }\n \n \n gfc_unit *\n find_or_create_unit (int n)\n {\n-  return get_external_unit (n, 1);\n+  return get_gfc_unit (n, 1);\n }\n \n \n@@ -426,46 +434,29 @@ is_trim_ok (st_parameter_dt *dtp)\n \n \n gfc_unit *\n-get_internal_unit (st_parameter_dt *dtp)\n+set_internal_unit (st_parameter_dt *dtp, gfc_unit *iunit, int kind)\n {\n-  gfc_unit * iunit;\n   gfc_offset start_record = 0;\n \n-  /* Allocate memory for a unit structure.  */\n-\n-  iunit = xcalloc (1, sizeof (gfc_unit));\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-  {\n-    __gthread_mutex_t tmp = __GTHREAD_MUTEX_INIT;\n-    iunit->lock = tmp;\n-  }\n-#else\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&iunit->lock);\n-#endif\n-  __gthread_mutex_lock (&iunit->lock);\n-\n   iunit->recl = dtp->internal_unit_len;\n-\n-  /* For internal units we set the unit number to -1.\n-     Otherwise internal units can be mistaken for a pre-connected unit or\n-     some other file I/O unit.  */\n-  iunit->unit_number = -1;\n+  iunit->internal_unit = dtp->internal_unit;\n+  iunit->internal_unit_len = dtp->internal_unit_len;\n+  iunit->internal_unit_kind = kind;\n \n   /* As an optimization, adjust the unit record length to not\n      include trailing blanks. This will not work under certain conditions\n      where trailing blanks have significance.  */\n   if (dtp->u.p.mode == READING && is_trim_ok (dtp))\n     {\n       int len;\n-      if (dtp->common.unit == 0)\n-\t  len = string_len_trim (dtp->internal_unit_len,\n-\t\t\t\t\t\t   dtp->internal_unit);\n+      if (kind == 1)\n+\t  len = string_len_trim (iunit->internal_unit_len,\n+\t\t\t\t\t\t   iunit->internal_unit);\n       else\n-\t  len = string_len_trim_char4 (dtp->internal_unit_len,\n-\t\t\t      (const gfc_char4_t*) dtp->internal_unit);\n-      dtp->internal_unit_len = len;\n-      iunit->recl = dtp->internal_unit_len;\n+\t  len = string_len_trim_char4 (iunit->internal_unit_len,\n+\t\t\t      (const gfc_char4_t*) iunit->internal_unit);\n+      iunit->internal_unit_len = len;\n+      iunit->recl = iunit->internal_unit_len;\n     }\n \n   /* Set up the looping specification from the array descriptor, if any.  */\n@@ -475,22 +466,19 @@ get_internal_unit (st_parameter_dt *dtp)\n       iunit->rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);\n       iunit->ls = (array_loop_spec *)\n \txmallocarray (iunit->rank, sizeof (array_loop_spec));\n-      dtp->internal_unit_len *=\n+      iunit->internal_unit_len *=\n \tinit_loop_spec (dtp->internal_unit_desc, iunit->ls, &start_record);\n \n       start_record *= iunit->recl;\n     }\n \n   /* Set initial values for unit parameters.  */\n-  if (dtp->common.unit)\n-    {\n-      iunit->s = open_internal4 (dtp->internal_unit - start_record,\n-\t\t\t\t dtp->internal_unit_len, -start_record);\n-      fbuf_init (iunit, 256);\n-    }\n+  if (kind == 4)\n+    iunit->s = open_internal4 (iunit->internal_unit - start_record,\n+\t\t\t\t iunit->internal_unit_len, -start_record);\n   else\n-    iunit->s = open_internal (dtp->internal_unit - start_record,\n-\t\t\t      dtp->internal_unit_len, -start_record);\n+    iunit->s = open_internal (iunit->internal_unit - start_record,\n+\t\t\t      iunit->internal_unit_len, -start_record);\n \n   iunit->bytes_left = iunit->recl;\n   iunit->last_record=0;\n@@ -522,33 +510,22 @@ get_internal_unit (st_parameter_dt *dtp)\n   dtp->u.p.pending_spaces = 0;\n   dtp->u.p.max_pos = 0;\n   dtp->u.p.at_eof = 0;\n-\n-  /* This flag tells us the unit is assigned to internal I/O.  */\n-\n-  dtp->u.p.unit_is_internal = 1;\n-\n   return iunit;\n }\n \n \n-/* free_internal_unit()-- Free memory allocated for internal units if any.  */\n+/* stash_internal_unit()-- Push the internal unit number onto the\n+   avaialble stack.  */\n void\n-free_internal_unit (st_parameter_dt *dtp)\n+stash_internal_unit (st_parameter_dt *dtp)\n {\n-  if (!is_internal_unit (dtp))\n-    return;\n-\n-  if (unlikely (is_char4_unit (dtp)))\n-    fbuf_destroy (dtp->u.p.current_unit);\n-\n-  if (dtp->u.p.current_unit != NULL)\n-    {\n-      free (dtp->u.p.current_unit->ls);\n-\n-      free (dtp->u.p.current_unit->s);\n-\n-      destroy_unit_mutex (dtp->u.p.current_unit);\n-    }\n+  __gthread_mutex_lock (&unit_lock);\n+  newunit_tos++;\n+  if (newunit_tos >= NEWUNIT_STACK_SIZE)\n+    internal_error (&dtp->common, \"stash_internal_unit(): Stack Size Exceeded\");\n+  newunit_stack[newunit_tos].unit_number = dtp->common.unit;\n+  newunit_stack[newunit_tos].unit = dtp->u.p.current_unit;\n+  __gthread_mutex_unlock (&unit_lock);\n }\n \n \n@@ -559,16 +536,51 @@ free_internal_unit (st_parameter_dt *dtp)\n gfc_unit *\n get_unit (st_parameter_dt *dtp, int do_create)\n {\n+  gfc_unit * unit;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_INTERNAL_UNIT) != 0)\n-    return get_internal_unit (dtp);\n+    {\n+      int kind;\n+      if (dtp->common.unit == GFC_INTERNAL_UNIT)\n+        kind = 1;\n+      else if (dtp->common.unit == GFC_INTERNAL_UNIT4)\n+        kind = 4;\n+      else\n+\tinternal_error (&dtp->common, \"get_unit(): Bad internal unit KIND\");\n \n+      if ((dtp->common.flags & IOPARM_DT_HAS_UDTIO) != 0)\n+\t{\n+\t  dtp->u.p.unit_is_internal = 1;\n+\t  dtp->common.unit = get_unique_unit_number (&dtp->common);\n+\t  unit = get_gfc_unit (dtp->common.unit, do_create);\n+\t  set_internal_unit (dtp, unit, kind);\n+\t  fbuf_init (unit, 128);\n+\t  return unit;\n+\t}\n+      else\n+\t{\n+\t  if (newunit_tos)\n+\t    {\n+\t      dtp->common.unit = newunit_stack[newunit_tos].unit_number;\n+\t      unit = newunit_stack[newunit_tos--].unit;\n+\t      unit->fbuf->act = unit->fbuf->pos = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      dtp->common.unit = get_unique_unit_number (&dtp->common);\n+\t      unit = xcalloc (1, sizeof (gfc_unit));\n+\t      fbuf_init (unit, 128);\n+\t    }\n+\t  set_internal_unit (dtp, unit, kind);\n+\t  return unit;\n+\t}\n+    }\n   /* Has to be an external unit.  */\n-\n   dtp->u.p.unit_is_internal = 0;\n+  dtp->internal_unit = NULL;\n   dtp->internal_unit_desc = NULL;\n-\n-  return get_external_unit (dtp->common.unit, do_create);\n+  unit = get_gfc_unit (dtp->common.unit, do_create);\n+  return unit;\n }\n \n \n@@ -687,6 +699,10 @@ init_units (void)\n   max_offset = 0;\n   for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)\n     max_offset = max_offset + ((gfc_offset) 1 << i);\n+\n+  /* Initialize the newunit stack.  */\n+  memset (newunit_stack, 0, NEWUNIT_STACK_SIZE * sizeof(gfc_saved_unit));\n+  newunit_tos = 0;\n }\n \n \n@@ -765,6 +781,13 @@ close_units (void)\n     close_unit_1 (unit_root, 1);\n   __gthread_mutex_unlock (&unit_lock);\n \n+  while (newunit_tos != 0)\n+    if (newunit_stack[newunit_tos].unit)\n+      {\n+\tfbuf_destroy (newunit_stack[newunit_tos].unit);\n+\tfree (newunit_stack[newunit_tos].unit->s);\n+\tfree (newunit_stack[newunit_tos--].unit);\n+      }\n #ifdef HAVE_FREELOCALE\n   freelocale (c_locale);\n #endif\n@@ -862,9 +885,10 @@ finish_last_advance_record (gfc_unit *u)\n   fbuf_flush (u, u->mode);\n }\n \n-/* Assign a negative number for NEWUNIT in OPEN statements.  */\n+/* Assign a negative number for NEWUNIT in OPEN statements or for\n+   internal units.  */\n GFC_INTEGER_4\n-get_unique_unit_number (st_parameter_open *opp)\n+get_unique_unit_number (st_parameter_common *common)\n {\n   GFC_INTEGER_4 num;\n \n@@ -875,11 +899,10 @@ get_unique_unit_number (st_parameter_open *opp)\n   num = next_available_newunit--;\n   __gthread_mutex_unlock (&unit_lock);\n #endif\n-\n   /* Do not allow NEWUNIT numbers to wrap.  */\n   if (num > GFC_FIRST_NEWUNIT)\n     {\n-      generate_error (&opp->common, LIBERROR_INTERNAL, \"NEWUNIT exhausted\");\n+      generate_error (common, LIBERROR_INTERNAL, \"NEWUNIT exhausted\");\n       return 0;\n     }\n   return num;"}]}