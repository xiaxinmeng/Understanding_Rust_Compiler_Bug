{"sha": "30dd20c0098948de74f6a18978e78e2950782975", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkZDIwYzAwOTg5NDhkZTc0ZjZhMTg5NzhlNzhlMjk1MDc4Mjk3NQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-21T02:00:20Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-21T02:00:20Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "1e3130f51900fb85b63d4f4f0e22d17ca1837770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e3130f51900fb85b63d4f4f0e22d17ca1837770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30dd20c0098948de74f6a18978e78e2950782975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dd20c0098948de74f6a18978e78e2950782975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30dd20c0098948de74f6a18978e78e2950782975", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dd20c0098948de74f6a18978e78e2950782975/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa283484a3dffedc404653af18f9413775cbc3df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa283484a3dffedc404653af18f9413775cbc3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa283484a3dffedc404653af18f9413775cbc3df"}, {"sha": "671cefe61254bedd4a9f526f8912fe68368cbe72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671cefe61254bedd4a9f526f8912fe68368cbe72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671cefe61254bedd4a9f526f8912fe68368cbe72"}], "stats": {"total": 256, "additions": 232, "deletions": 24}, "files": [{"sha": "1924b52d59802265aa073dac48ff09c2d4ebbe2d", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -205,17 +205,21 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   virtual ~TyTyResolveCompile () {}\n \n-  void visit (TyTy::FnType &type) { gcc_unreachable (); }\n+  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::BoolType &type)\n+  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::BoolType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n-  void visit (TyTy::IntType &type)\n+  void visit (TyTy::IntType &type) override\n   {\n     printf (\"type [%s] has ref: %u\\n\", type.as_string ().c_str (),\n \t    type.get_ref ());\n@@ -226,7 +230,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     translated = compiled_type;\n   }\n \n-  void visit (TyTy::UintType &type)\n+  void visit (TyTy::UintType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);"}, {"sha": "f131a89ab84d9051680fb40d30a93c91f29c5d89", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -48,11 +48,7 @@ class CompileItem : public HIRCompileBase\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n-\t  {\n-\t    printf (\"returning early the function [%s] is completed!\\n\",\n-\t\t    function.as_string ().c_str ());\n-\t    return;\n-\t  }\n+\t  return;\n       }\n \n     TyTy::TyBase *fnType;\n@@ -123,9 +119,12 @@ class CompileItem : public HIRCompileBase\n       return true;\n     });\n \n-    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-    HIR::BlockExpr *function_body = function.function_body.get ();\n+    bool toplevel_item\n+      = function.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n+    Bblock *enclosing_scope\n+      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n \n+    HIR::BlockExpr *function_body = function.function_body.get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n "}, {"sha": "c5c646db1e3ce44f0e7db7d30e28f475e956c89a", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -36,10 +36,6 @@ ResolvePath::visit (HIR::PathInExpression &expr)\n       return;\n     }\n \n-  printf (\"PATHIN have ast node id %u ref %u for expr [%s]\\n\",\n-\t  expr.get_mappings ().get_nodeid (), ref_node_id,\n-\t  expr.as_string ().c_str ());\n-\n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n@@ -52,9 +48,6 @@ ResolvePath::visit (HIR::PathInExpression &expr)\n   Bfunction *fn;\n   if (!ctx->lookup_function_decl (ref, &fn))\n     {\n-      printf (\n-\t\"path failed to lookup function attempting to forward resolve!\\n\");\n-\n       // this might fail because its a forward decl so we can attempt to\n       // resolve it now\n       HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item ("}, {"sha": "9a0e0f243ede3e58ebeebc8a28570bad1bca146a", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -109,6 +109,8 @@ class LetStmt : public Stmt\n   LetStmt (LetStmt &&other) = default;\n   LetStmt &operator= (LetStmt &&other) = default;\n \n+  Location get_locus_slow () const override { return get_locus (); }\n+\n   Location get_locus () const { return locus; }\n \n   void accept_vis (HIRVisitor &vis) override;"}, {"sha": "ba4ee21bb6cb01a6d91bacfae60d427c96139ef0", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -168,6 +168,7 @@ Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n   rust_assert (it == resolved_names.end ());\n \n   resolved_names[refId] = defId;\n+  get_name_scope ().peek ()->append_reference_for_def (defId, refId);\n }\n \n bool\n@@ -188,6 +189,7 @@ Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n   rust_assert (it == resolved_types.end ());\n \n   resolved_types[refId] = defId;\n+  get_type_scope ().peek ()->append_reference_for_def (defId, refId);\n }\n \n bool"}, {"sha": "38206f69b99e1bf850cfec2b27ac4fc7c4e2f2a5", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -41,6 +41,7 @@ class Rib\n   {\n     mappings[ident] = id;\n     decls_within_rib.insert (id);\n+    references[id] = {};\n   }\n \n   bool lookup_name (std::string ident, NodeId *id)\n@@ -65,11 +66,30 @@ class Rib\n       }\n   }\n \n+  void iterate_references_for_def (NodeId def, std::function<bool (NodeId)> cb)\n+  {\n+    auto it = references.find (def);\n+    if (it == references.end ())\n+      return;\n+\n+    for (auto ref : it->second)\n+      {\n+\tif (!cb (ref))\n+\t  return;\n+      }\n+  }\n+\n+  void append_reference_for_def (NodeId def, NodeId ref)\n+  {\n+    references[def].insert (ref);\n+  }\n+\n private:\n   CrateNum crate_num;\n   NodeId node_id;\n   std::map<std::string, NodeId> mappings;\n   std::set<NodeId> decls_within_rib;\n+  std::map<NodeId, std::set<NodeId> > references;\n };\n \n class Scope\n@@ -135,8 +155,8 @@ class Scope\n //\n // if parent is UNKNOWN_NODEID then this is a root declaration\n // say the var_decl hasa node_id=4;\n-// the parent could be a BLOCK_Expr node_id but lets make it UNKNOWN_NODE_ID so\n-// we know when it terminates\n+// the parent could be a BLOCK_Expr node_id but lets make it UNKNOWN_NODE_ID\n+// so we know when it terminates\n struct Definition\n {\n   NodeId node;\n@@ -211,9 +231,6 @@ class Resolver\n   // we need two namespaces one for names and ones for types\n   std::map<NodeId, NodeId> resolved_names;\n   std::map<NodeId, NodeId> resolved_types;\n-\n-  std::map<NodeId, std::set<NodeId> > nameDefNodeIdToRibs;\n-  std::map<NodeId, std::set<NodeId> > typeDefNodeIdToRibs;\n };\n \n } // namespace Resolver"}, {"sha": "c9a0fde4d91b08804c94072ce1714ae9bdd0e1cd", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -94,6 +94,9 @@ class TypeCheckExpr : public TypeCheckBase\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     infered = lhs->combine (rhs);\n+    // need to overrite the lhs type with this combination\n+    context->insert_type (expr.get_lhs ()->get_mappings ().get_hirid (),\n+\t\t\t  infered);\n   }\n \n   void visit (HIR::IdentifierExpr &expr)"}, {"sha": "c90af13abb2068cbae29025f8a14f6fa4e0e0ef8", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n #include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-resolver.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -78,6 +79,19 @@ class TypeCheckItem : public TypeCheckBase\n       return true;\n     });\n \n+    // now that the stmts have been resolved we must resolve the block of locals\n+    // and make sure the variables have been resolved\n+    auto body_mappings = function.function_body->get_mappings ();\n+    Rib *rib = nullptr;\n+    if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to lookup locals per block\");\n+\treturn;\n+      }\n+\n+    TyTyResolver::Resolve (rib, mappings, resolver, context);\n+\n     context->pop_return_type ();\n   }\n "}, {"sha": "6eb46ff758ca233198f463566d9cc98b3c4e3978", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -60,7 +60,6 @@ TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type)\n void\n TypeCheckContext::insert_type (HirId id, TyTy::TyBase *type)\n {\n-  rust_assert (resolved.find (id) == resolved.end ());\n   rust_assert (type != nullptr);\n   resolved[id] = type;\n }"}, {"sha": "1ee533ea97c7f462e33260d86520d0979f37a35c", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -0,0 +1,121 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_RESOLVER\n+#define RUST_TYTY_RESOLVER\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TyTyResolver\n+{\n+public:\n+  static void Resolve (Rib *rib, Analysis::Mappings *mappings,\n+\t\t       Resolver *resolver, TypeCheckContext *context)\n+  {\n+    TyTyResolver r (mappings, resolver, context);\n+    r.go (rib);\n+  }\n+\n+  virtual ~TyTyResolver () {}\n+\n+  void go (Rib *rib)\n+  {\n+    rib->iterate_decls ([&] (NodeId decl_node_id) mutable -> bool {\n+      // type inference in rust means we need to gather and examine all\n+      // references of this decl and combine each to make sure the type is\n+      // correctly inferred. Consider the example:\n+      // let mut x; x = 1;\n+      // we can only say x is an infer variable then at the assignment\n+      // we think x must be an integer\n+\n+      std::vector<TyTy::TyBase *> gathered_types;\n+      rib->iterate_references_for_def (\n+\tdecl_node_id, [&] (NodeId ref_node) mutable -> bool {\n+\t  HirId hir_node_ref;\n+\t  bool ok\n+\t    = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t    ref_node, &hir_node_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::TyBase *resolved = nullptr;\n+\t  if (!context->lookup_type (hir_node_ref, &resolved))\n+\t    {\n+\t      rust_fatal_error (mappings->lookup_location (hir_node_ref),\n+\t\t\t\t\"failed to lookup type for reference\");\n+\t      return false;\n+\t    }\n+\n+\t  gathered_types.push_back (resolved);\n+\t  return true;\n+\t});\n+\n+      Definition d;\n+      bool ok = resolver->lookup_definition (decl_node_id, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = mappings->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      TyTy::TyBase *resolved_type = nullptr;\n+      ok = context->lookup_type (decl->get_mappings ().get_hirid (),\n+\t\t\t\t &resolved_type);\n+      rust_assert (ok);\n+\n+      auto resolved_tyty = resolved_type;\n+      for (auto it : gathered_types)\n+\tresolved_tyty = resolved_tyty->combine (it);\n+\n+      // something is not inferred we need to look at all references now\n+      if (resolved_tyty == nullptr || resolved_tyty->is_unit ())\n+\t{\n+\t  rust_error_at (decl->get_locus_slow (), \"failed to resolve type\");\n+\t  return false;\n+\t}\n+\n+      // insert the new resolved definition\n+      context->insert_type (decl->get_mappings ().get_hirid (), resolved_tyty);\n+      return true;\n+    });\n+  }\n+\n+protected:\n+private:\n+  TyTyResolver (Analysis::Mappings *mappings, Resolver *resolver,\n+\t\tTypeCheckContext *context)\n+    : mappings (mappings), resolver (resolver), context (context)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver *resolver;\n+  TypeCheckContext *context;\n+};\n+\n+} // namespace Resolver\n+\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_RESOLVER"}, {"sha": "205ef448ba5b13a83f2f301d458eccea4be071f9", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -105,6 +105,23 @@ class InferRules : protected BaseRules\n     return resolved;\n   }\n \n+  // we are an inference variable so this means we can take the other as the\n+  // type\n+  virtual void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    resolved = new IntType (type.get_ref (), type.get_kind ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    resolved = new UintType (type.get_ref (), type.get_kind ());\n+  }\n+\n private:\n   InferType *base;\n   TyBase *resolved;"}, {"sha": "a69c07eac43032ee04398d267e8c57ba6575ec59", "filename": "gcc/testsuite/rust.test/compilable/forward_decl_1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_1.rs?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let mut an_integer = 5;\n+    an_integer = test(1) + 3;\n+\n+    let call_test = test(1);\n+}\n+\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}"}, {"sha": "b20b565e3326559aa7c32881a244519c3f67991f", "filename": "gcc/testsuite/rust.test/compilable/type_infer3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer3.rs?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -0,0 +1,13 @@\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let mut an_integer = 5;\n+    an_integer = test(1) + 3;\n+\n+    let mut x;\n+    x = 1;\n+\n+    let call_test = test(1);\n+}"}, {"sha": "f1e17ed02efc125e8c5e1d60b24b329915dc4852", "filename": "gcc/testsuite/rust.test/fail_compilation/bad_type2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dd20c0098948de74f6a18978e78e2950782975/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type2.rs?ref=30dd20c0098948de74f6a18978e78e2950782975", "patch": "@@ -0,0 +1,14 @@\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let mut an_integer = 5;\n+    an_integer = test(1) + 3;\n+\n+    let mut x;\n+    x = 1;\n+    x = true;\n+\n+    let call_test = test(1);\n+}"}]}