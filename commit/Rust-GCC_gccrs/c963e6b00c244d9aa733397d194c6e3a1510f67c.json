{"sha": "c963e6b00c244d9aa733397d194c6e3a1510f67c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk2M2U2YjAwYzI0NGQ5YWE3MzMzOTdkMTk0YzZlM2ExNTEwZjY3Yw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@nerim.net", "date": "2002-07-10T12:06:37Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-07-10T12:06:37Z"}, "message": "valarray_meta.h (_UnFunBase): Take a second template parameter.\n\n\t* include/bits/valarray_meta.h (_UnFunBase): Take a second\n\ttemplate parameter. Remove _M_func data member.\n\t(_UnFunClos): Take a third template parameter.\n\t(__abs, __cos, __acos, __cosh, __sin, __asin, __sinh, __tan,\n\t__atan, __tanh, __exp, __log, __log10, __sqrt): New classes.\n\t(_DEFINE_EXPR_UNARY_OPERATOR): Adjust definition.\n\nFrom-SVN: r55365", "tree": {"sha": "331d6a22b1e7b17a28911a0afdfc80a174764cac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/331d6a22b1e7b17a28911a0afdfc80a174764cac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c963e6b00c244d9aa733397d194c6e3a1510f67c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c963e6b00c244d9aa733397d194c6e3a1510f67c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c963e6b00c244d9aa733397d194c6e3a1510f67c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c963e6b00c244d9aa733397d194c6e3a1510f67c/comments", "author": null, "committer": null, "parents": [{"sha": "e6986399dce0b228feb187326e67f08c8008e37c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6986399dce0b228feb187326e67f08c8008e37c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6986399dce0b228feb187326e67f08c8008e37c"}], "stats": {"total": 168, "additions": 134, "deletions": 34}, "files": [{"sha": "60eb56fb0352ee75f6ce86f5193cdf5ed1c73dcc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c963e6b00c244d9aa733397d194c6e3a1510f67c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c963e6b00c244d9aa733397d194c6e3a1510f67c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c963e6b00c244d9aa733397d194c6e3a1510f67c", "patch": "@@ -1,3 +1,12 @@\n+2002-07-10  Gabriel Dos Reis  <gdr@nerim.net>\n+\n+\t* include/bits/valarray_meta.h (_UnFunBase): Take a second\n+\ttemplate parameter. Remove _M_func data member.\n+\t(_UnFunClos): Take a third template parameter.\n+\t(__abs, __cos, __acos, __cosh, __sin, __asin, __sinh, __tan,\n+\t__atan, __tanh, __exp, __log, __log10, __sqrt): New classes.\n+\t(_DEFINE_EXPR_UNARY_OPERATOR): Adjust definition.\n+\n 2002-07-08  Eric Christopher  <echristo@redhat.com>\n \n \t* configure.target: Fix comment for mips atomicity. Add"}, {"sha": "689f715b5c128801c406148a7075dd38c9f1a9fc", "filename": "libstdc++-v3/include/bits/valarray_meta.h", "status": "modified", "additions": 125, "deletions": 34, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c963e6b00c244d9aa733397d194c6e3a1510f67c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c963e6b00c244d9aa733397d194c6e3a1510f67c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h?ref=c963e6b00c244d9aa733397d194c6e3a1510f67c", "patch": "@@ -58,41 +58,132 @@ namespace std\n     //\n     // Unary function application closure.\n     //\n-    template<class _Dom> class _UnFunBase {\n+    template<class _Dom, typename _Op> class _UnFunBase\n+    {\n     public:\n-        typedef typename _Dom::value_type value_type;\n-        typedef value_type _Vt;\n-        \n-        _UnFunBase (const _Dom& __e, _Vt __f(_Vt))\n-                : _M_expr(__e), _M_func(__f) {}\n-        \n-        _Vt operator[] (size_t __i) const { return _M_func(_M_expr[__i]); }\n-        size_t size () const { return _M_expr.size(); }\n-        \n+      typedef typename _Dom::value_type value_type;\n+      typedef value_type _Vt;\n+      \n+      explicit _UnFunBase (const _Dom& __e) : _M_expr(__e) {}\n+      \n+      _Vt operator[] (size_t __i) const { return _Op()(_M_expr[__i]); }\n+      size_t size () const { return _M_expr.size(); }\n+      \n     private:\n-        const _Dom& _M_expr;\n-        _Vt (*_M_func)(_Vt);\n+      const _Dom& _M_expr;\n     };\n \n-    template<template<class, class> class _Meta, class _Dom>\n-        class _UnFunClos;\n+  // Implementations of unary functions applied to valarray<>s.\n+  // I use hard-coded object functions here instead of a generic\n+  // approach like pointers to function:\n+  //    1) correctness: some functions take references, others values.\n+  //       we can't deduce the correct type afterwards.\n+  //    2) efficiency -- object functions can be easily inlined\n+  //    3) be Koenig-lookup-friendly\n+\n+  struct __abs\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return abs(__t); }\n+  };\n+\n+  struct __cos\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return cos(__t); }\n+  };\n+\n+  struct __acos\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return acos(__t); }\n+  };\n+\n+  struct __cosh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return cosh(__t); }\n+  };\n+\n+  struct __sin\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sin(__t); }\n+  };\n+\n+  struct __asin\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return asin(__t); }\n+  };\n+\n+  struct __sinh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sinh(__t); }\n+  };\n+\n+  struct __tan\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return tan(__t); }\n+  };\n+\n+  struct __atan\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return atan(__t); }\n+  };\n+\n+  struct __tanh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return tanh(__t); }\n+  };\n+\n+  struct __exp\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return exp(__t); }\n+  };\n+\n+  struct __log\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return log(__t); }\n+  };\n+\n+  struct __log10\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return log10(__t); }\n+  };\n+\n+  struct __sqrt\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sqrt(__t); }\n+  };\n+\n+  template<template<class, class> class _Meta, class _Dom, typename _Op>\n+    class _UnFunClos;\n     \n-    template<class _Dom>\n-    struct _UnFunClos<_Expr,_Dom> : _UnFunBase<_Dom> {\n-        typedef _UnFunBase<_Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-        \n-        _UnFunClos (const _Dom& __e, value_type __f(value_type))\n-                : _Base (__e, __f) {}\n+  template<class _Dom, typename _Op>\n+    struct _UnFunClos<_Expr,_Dom, _Op> : _UnFunBase<_Dom, _Op>\n+    {\n+      typedef _UnFunBase<_Dom, _Op> _Base;\n+      typedef typename _Base::value_type value_type;\n+\n+      explicit _UnFunClos (const _Dom& __e) : _Base (__e) {}\n     };\n     \n-    template<typename _Tp>\n-    struct _UnFunClos<_ValArray,_Tp> : _UnFunBase<valarray<_Tp> > {\n-        typedef _UnFunBase<valarray<_Tp> > _Base;\n-        typedef typename _Base::value_type value_type;\n-        \n-        _UnFunClos (const valarray<_Tp>& __v, _Tp __f(_Tp))\n-                : _Base (__v, __f) {}\n+  template<typename _Tp, typename _Op>\n+    struct _UnFunClos<_ValArray,_Tp, _Op> : _UnFunBase<valarray<_Tp>, _Op>\n+    {\n+      typedef _UnFunBase<valarray<_Tp>, _Op> _Base;\n+      typedef typename _Base::value_type value_type;\n+\n+      explicit _UnFunClos (const valarray<_Tp>& __v) : _Base (__v) {}\n     };\n \n     //\n@@ -938,20 +1029,20 @@ operator _Op (const valarray<typename _Dom::value_type>& __v,          \\\n \n #define _DEFINE_EXPR_UNARY_FUNCTION(_Name)                              \\\n template<class _Dom>                                                    \\\n-inline _Expr<_UnFunClos<_Expr,_Dom>,typename _Dom::value_type>          \\\n+inline _Expr<_UnFunClos<_Expr,_Dom,__##_Name>,typename _Dom::value_type>\\\n _Name(const _Expr<_Dom,typename _Dom::value_type>& __e)                 \\\n {                                                                       \\\n     typedef typename _Dom::value_type _Tp;                              \\\n-    typedef _UnFunClos<_Expr,_Dom> _Closure;                            \\\n-    return _Expr<_Closure,_Tp>(_Closure(__e(), (_Tp(*)(_Tp))(&_Name))); \\\n+    typedef _UnFunClos<_Expr,_Dom,__##_Name> _Closure;                  \\\n+    return _Expr<_Closure,_Tp>(_Closure(__e()));                        \\\n }                                                                       \\\n                                                                         \\\n template<typename _Tp>                                                  \\\n-inline _Expr<_UnFunClos<_ValArray,_Tp>,_Tp>                             \\\n+inline _Expr<_UnFunClos<_ValArray,_Tp,__##_Name>,_Tp>                   \\\n _Name(const valarray<_Tp>& __v)                                         \\\n {                                                                       \\\n-    typedef _UnFunClos<_ValArray,_Tp> _Closure;                         \\\n-    return _Expr<_Closure,_Tp> (_Closure (__v, (_Tp(*)(_Tp))(&_Name))); \\\n+    typedef _UnFunClos<_ValArray,_Tp,__##_Name> _Closure;               \\\n+    return _Expr<_Closure,_Tp>(_Closure (__v));                         \\\n }\n \n "}]}