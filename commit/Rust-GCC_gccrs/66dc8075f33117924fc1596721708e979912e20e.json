{"sha": "66dc8075f33117924fc1596721708e979912e20e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkYzgwNzVmMzMxMTc5MjRmYzE1OTY3MjE3MDhlOTc5OTEyZTIwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-05T12:51:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-05T12:51:44Z"}, "message": "[multiple changes]\n\n2011-09-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): If the expression\n\tfunction comes from source, indicate that so does its rewriting,\n\tso it is compatible with any subsequent expansion of the\n\tsubprogram body (e.g. when it is a protected operation).\n\t* sem_ch4.adb: minor reformatting\n\n2011-09-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib.adb (Check_Same_Extended_Unit): Comment rewriting. Use\n\tGet_Source_Unit rather than Get_Code_Unit as instantiation unfolding\n\tmay lead to wrong ancestor package in the case of instantiated subunit\n\tbodies. If a subunit is instantiated, follow the chain of instantiations\n\trather than the stub structure.\n\nFrom-SVN: r178530", "tree": {"sha": "648e1c76bb9dc26e7a49e9eb764b5c083e6a46e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648e1c76bb9dc26e7a49e9eb764b5c083e6a46e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66dc8075f33117924fc1596721708e979912e20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66dc8075f33117924fc1596721708e979912e20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66dc8075f33117924fc1596721708e979912e20e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66dc8075f33117924fc1596721708e979912e20e/comments", "author": null, "committer": null, "parents": [{"sha": "1e3a7e8662804a55bd4d01c7d5fe626b982c013a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3a7e8662804a55bd4d01c7d5fe626b982c013a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3a7e8662804a55bd4d01c7d5fe626b982c013a"}], "stats": {"total": 88, "additions": 54, "deletions": 34}, "files": [{"sha": "2bfd148a259bfd04214adf29168bf98d01d9a902", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=66dc8075f33117924fc1596721708e979912e20e", "patch": "@@ -1,3 +1,19 @@\n+2011-09-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): If the expression\n+\tfunction comes from source, indicate that so does its rewriting,\n+\tso it is compatible with any subsequent expansion of the\n+\tsubprogram body (e.g. when it is a protected operation).\n+\t* sem_ch4.adb: minor reformatting\n+\n+2011-09-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib.adb (Check_Same_Extended_Unit): Comment rewriting. Use\n+\tGet_Source_Unit rather than Get_Code_Unit as instantiation unfolding\n+\tmay lead to wrong ancestor package in the case of instantiated subunit\n+\tbodies. If a subunit is instantiated, follow the chain of instantiations\n+\trather than the stub structure.\n+\n 2011-09-02  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch4.adb, sem_ch6.adb: Minor reformatting."}, {"sha": "2c5aa4c507ffeab9cb7b7768fc28106544676875", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=66dc8075f33117924fc1596721708e979912e20e", "patch": "@@ -293,10 +293,14 @@ package body Lib is\n \n       Sloc1 := S1;\n       Sloc2 := S2;\n-      Unum1 := Get_Code_Unit (Sloc1);\n-      Unum2 := Get_Code_Unit (Sloc2);\n+\n+      Unum1 := Get_Source_Unit (Sloc1);\n+      Unum2 := Get_Source_Unit (Sloc2);\n \n       loop\n+         --  Step 1: Check whether the two locations are in the same source\n+         --  file.\n+\n          Sind1 := Get_Source_File_Index (Sloc1);\n          Sind2 := Get_Source_File_Index (Sloc2);\n \n@@ -310,28 +314,27 @@ package body Lib is\n             end if;\n          end if;\n \n-         --  OK, the two nodes are in separate source elements, but this is not\n-         --  decisive, because of the issue of subunits and instantiations.\n-\n-         --  First we deal with subunits, since if the subunit is in an\n-         --  instantiation, we know that the parent is in the corresponding\n-         --  instantiation, since that is the only way we can have a subunit\n-         --  that is part of an instantiation.\n+         --  Step 2: Check subunits. If a subunit is instantiated, follow the\n+         --  instantiation chain rather than the stub chain.\n \n          Unit1 := Unit (Cunit (Unum1));\n          Unit2 := Unit (Cunit (Unum2));\n+         Inst1 := Instantiation (Sind1);\n+         Inst2 := Instantiation (Sind2);\n \n          if Nkind (Unit1) = N_Subunit\n            and then Present (Corresponding_Stub (Unit1))\n+           and then Inst1 = No_Location\n          then\n-            --  Both in subunits. They could have a common ancestor. If they\n-            --  do, then the deeper one must have a longer unit name. Replace\n-            --  the deeper one with its corresponding stub, in order to find\n-            --  nearest common ancestor, if any.\n-\n             if Nkind (Unit2) = N_Subunit\n               and then Present (Corresponding_Stub (Unit2))\n+              and then Inst2 = No_Location\n             then\n+               --  Both locations refer to subunits which may have a common\n+               --  ancestor. If they do, the deeper subunit must have a longer\n+               --  unit name. Replace the deeper one with its corresponding\n+               --  stub in order to find the nearest ancestor.\n+\n                if Length_Of_Name (Unit_Name (Unum1)) <\n                   Length_Of_Name (Unit_Name (Unum2))\n                then\n@@ -345,36 +348,33 @@ package body Lib is\n                   goto Continue;\n                end if;\n \n-            --  Nod1 in subunit, Nod2 not\n+            --  Sloc1 in subunit, Sloc2 not\n \n             else\n                Sloc1 := Sloc (Corresponding_Stub (Unit1));\n                Unum1 := Get_Source_Unit (Sloc1);\n                goto Continue;\n             end if;\n \n-         --  Nod2 in subunit, Nod1 not\n+         --  Sloc2 in subunit, Sloc1 not\n \n          elsif Nkind (Unit2) = N_Subunit\n            and then Present (Corresponding_Stub (Unit2))\n+           and then Inst2 = No_Location\n          then\n             Sloc2 := Sloc (Corresponding_Stub (Unit2));\n             Unum2 := Get_Source_Unit (Sloc2);\n             goto Continue;\n          end if;\n \n-         --  At this stage we know that neither is a subunit, so we deal\n-         --  with instantiations, since we could have a common ancestor\n-\n-         Inst1 := Instantiation (Sind1);\n-         Inst2 := Instantiation (Sind2);\n+         --  Step 3: Check instances. The two locations may yield a common\n+         --  ancestor.\n \n          if Inst1 /= No_Location then\n-\n-            --  Both are instantiations\n-\n             if Inst2 /= No_Location then\n \n+               --  Both locations denote instantiations\n+\n                Depth1 := Instantiation_Depth (Sloc1);\n                Depth2 := Instantiation_Depth (Sloc2);\n \n@@ -396,26 +396,25 @@ package body Lib is\n                   goto Continue;\n                end if;\n \n-            --  Only first node is in instantiation\n+            --  Sloc1 is an instantiation\n \n             else\n                Sloc1 := Inst1;\n                Unum1 := Get_Source_Unit (Sloc1);\n                goto Continue;\n             end if;\n \n-         --  Only second node is instantiation\n+         --  Sloc2 is an instantiation\n \n          elsif Inst2 /= No_Location then\n             Sloc2 := Inst2;\n             Unum2 := Get_Source_Unit (Sloc2);\n             goto Continue;\n          end if;\n \n-         --  No instantiations involved, so we are not in the same unit\n-         --  However, there is one case still to check, namely the case\n-         --  where one location is in the spec, and the other in the\n-         --  corresponding body (the spec location is earlier).\n+         --  Step 4: One location in the spec, the other in the corresponding\n+         --  body of the same unit. The location in the spec is considered\n+         --  earlier.\n \n          if Nkind (Unit1) = N_Subprogram_Body\n               or else\n@@ -434,8 +433,8 @@ package body Lib is\n             end if;\n          end if;\n \n-         --  If that special case does not occur, then we are certain that\n-         --  the two locations are really in separate units.\n+         --  At this point it is certain that the two locations denote two\n+         --  entirely separate units.\n \n          return No;\n "}, {"sha": "6c886d501ea948f1b79b512adb7ac224dc7225b2", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=66dc8075f33117924fc1596721708e979912e20e", "patch": "@@ -4322,8 +4322,7 @@ package body Sem_Ch4 is\n             Error_Msg_Node_2 := First_Subtype (Prefix_Type);\n             Error_Msg_NE (\"no selector& for}\", N, Sel);\n \n-            --  If prefix is incomplete, dd information\n-            --  What is dd???\n+            --  If prefix is incomplete, add information\n \n             if Is_Incomplete_Type (Type_To_Use) then\n                declare"}, {"sha": "b978874890351a47d2a956d213e0347ef1f96288", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66dc8075f33117924fc1596721708e979912e20e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=66dc8075f33117924fc1596721708e979912e20e", "patch": "@@ -298,6 +298,12 @@ package body Sem_Ch6 is\n                 Make_Simple_Return_Statement (LocX,\n                   Expression => Expression (N)))));\n \n+      --  If the expression function comes from source, indicate that so does\n+      --  its rewriting, so it is compatible with any subsequent expansion of\n+      --  the subprogram body (e.g. when it is a protected operation).\n+\n+      Set_Comes_From_Source (New_Body, Comes_From_Source (N));\n+\n       if Present (Prev)\n         and then Ekind (Prev) = E_Generic_Function\n       then"}]}