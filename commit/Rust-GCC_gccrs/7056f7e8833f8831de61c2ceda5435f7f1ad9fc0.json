{"sha": "7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1NmY3ZTg4MzNmODgzMWRlNjFjMmNlZGE1NDM1ZjdmMWFkOWZjMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-12T13:08:35Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-12T13:08:35Z"}, "message": "(basic_induction_var): New arg MODE.\n\nUse it to call convert_modes.\n(strength_reduce): Supply the new arg to basic_induction_var.\n\nFrom-SVN: r5310", "tree": {"sha": "4554fae5c99ae59bf34990f36287858e1d1d81b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4554fae5c99ae59bf34990f36287858e1d1d81b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0/comments", "author": null, "committer": null, "parents": [{"sha": "c2ec26b8afb76691aeb476e829053e4a5bda64d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ec26b8afb76691aeb476e829053e4a5bda64d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ec26b8afb76691aeb476e829053e4a5bda64d3"}], "stats": {"total": 35, "additions": 22, "deletions": 13}, "files": [{"sha": "989df7b119c7ec6e6d403a1e7567ab0a4aa2a3e3", "filename": "gcc/loop.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "patch": "@@ -3209,8 +3209,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n \t      && reg_iv_type[REGNO (dest_reg)] != NOT_BASIC_INDUCT)\n \t    {\n-\t      if (basic_induction_var (SET_SRC (set), dest_reg, p,\n-\t\t\t\t      &inc_val, &mult_val))\n+\t      if (basic_induction_var (SET_SRC (set), GET_MODE (SET_SRC (set)),\n+\t\t\t\t       dest_reg, p, &inc_val, &mult_val))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n \t\t     Create and initialize an induction structure for it.  */\n@@ -4704,7 +4704,9 @@ update_giv_derive (p)\n }\n \f\n /* Check whether an insn is an increment legitimate for a basic induction var.\n-   X is the source of insn P.\n+   X is the source of insn P, or a part of it.\n+   MODE is the mode in which X should be interpreted.\n+\n    DEST_REG is the putative biv, also the destination of the insn.\n    We accept patterns of these forms:\n      REG = REG + INVARIANT (includes REG = REG - CONSTANT)\n@@ -4738,8 +4740,9 @@ update_giv_derive (p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n+basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n      register rtx x;\n+     enum machine_mode mode;\n      rtx p;\n      rtx dest_reg;\n      rtx *inc_val;\n@@ -4769,16 +4772,16 @@ basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n       if (invariant_p (arg) != 1)\n \treturn 0;\n \n-      *inc_val = convert_to_mode (GET_MODE (dest_reg), arg, 0);;\n+      *inc_val = convert_modes (GET_MODE (dest_reg), GET_MODE (x), arg, 0);\n       *mult_val = const1_rtx;\n       return 1;\n \n     case SUBREG:\n       /* If this is a SUBREG for a promoted variable, check the inner\n \t value.  */\n       if (SUBREG_PROMOTED_VAR_P (x))\n-\t  return basic_induction_var (SUBREG_REG (x), dest_reg, p,\n-\t\t\t\t    inc_val, mult_val);\n+\treturn basic_induction_var (SUBREG_REG (x), GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t    dest_reg, p, inc_val, mult_val);\n \n     case REG:\n       /* If this register is assigned in the previous insn, look at its\n@@ -4794,7 +4797,11 @@ basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n \tset = single_set (insn);\n \n       if (set != 0 && SET_DEST (set) == x)\n-\treturn basic_induction_var (SET_SRC (set), dest_reg, insn,\n+\treturn basic_induction_var (SET_SRC (set),\n+\t\t\t\t    (GET_MODE (SET_SRC (set)) == VOIDmode\n+\t\t\t\t     ? GET_MODE (x)\n+\t\t\t\t     : GET_MODE (SET_SRC (set))),\n+\t\t\t\t    dest_reg, insn,\n \t\t\t\t    inc_val, mult_val);\n       /* ... fall through ... */\n \n@@ -4810,16 +4817,17 @@ basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n     case CONST:\n       if (loops_enclosed == 1)\n  \t{\n-\t  *inc_val = convert_to_mode (GET_MODE (dest_reg), x, 0);;\n+\t  /* Possible bug here?  Perhaps we don't know the mode of X.  */\n+\t  *inc_val = convert_modes (GET_MODE (dest_reg), mode, x, 0);\n  \t  *mult_val = const0_rtx;\n  \t  return 1;\n  \t}\n       else\n  \treturn 0;\n \n     case SIGN_EXTEND:\n-      return basic_induction_var (XEXP (x, 0), dest_reg, p,\n-\t\t\t\t  inc_val, mult_val);\n+      return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n+\t\t\t\t  dest_reg, p, inc_val, mult_val);\n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n       for (insn = PREV_INSN (p);\n@@ -4836,8 +4844,9 @@ basic_induction_var (x, dest_reg, p, inc_val, mult_val)\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && GET_CODE (SET_SRC (set)) == ASHIFT\n \t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1))\n-\treturn basic_induction_var (XEXP (SET_SRC (set), 0), dest_reg, insn,\n-\t\t\t\t    inc_val, mult_val);\n+\treturn basic_induction_var (XEXP (SET_SRC (set), 0),\n+\t\t\t\t    GET_MODE (XEXP (x, 0)),\n+\t\t\t\t    dest_reg, insn, inc_val, mult_val);\n       return 0;\n \n     default:"}]}