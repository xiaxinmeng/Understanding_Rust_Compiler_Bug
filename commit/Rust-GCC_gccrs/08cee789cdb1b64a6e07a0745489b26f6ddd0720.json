{"sha": "08cee789cdb1b64a6e07a0745489b26f6ddd0720", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjZWU3ODljZGIxYjY0YTZlMDdhMDc0NTQ4OWIyNmY2ZGRkMDcyMA==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2005-03-13T18:09:55Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-03-13T18:09:55Z"}, "message": "ggc-zone.c: Rewritten.\n\n\t* ggc-zone.c: Rewritten.\n\n\t* alloc-pool.c (dump_alloc_pool_statistics): Don't print statistics\n\tif there are none.\n\t* configure.ac: Define GGC_ZONE for --with-gc=zone.\n\t* config.in: Regenerated.\n\t* configure: Regenerated.\n\t* gentype.c (write_types_process_field, write_func_for_structure):\n\tPass new argument to gt_pch_note_object.\n\t* ggc-common.c (struct ptr_data): Add TYPE.\n\t(gt_pch_note_object): Take TYPE argument and save it.\n\t(call_count): Update call to ggc_pch_count_object.\n\t(call_alloc): Update call to ggc_pch_alloc_object.\n\t(gt_pch_save): Call ggc_pch_prepare_write after paddng the PCH\n\tfile.\n\t* ggc-none.c (rtl_zone, garbage_zone, ggc_alloc_zone_stat): Delete.\n\t* ggc-page.c (rtl_zone, tree_zone, garbage_zone)\n\t(ggc_alloc_zone_stat): Delete.\n\t(ggc_pch_count_object, ggc_pch_alloc_object): Add TYPE argument.\n\t* ggc.h (gt_pch_note_object, ggc_pch_count_object)\n\t(ggc_pch_alloc_object): Update prototypes.\n\t(garbage_zone): Delete.\n\t(tree_zone, rtl_zone, ggc_alloc_zone_stat, ggc_alloc_zone): Move to\n\tGGC_ZONE conditional.  Update.  Change tree_zone and rtl_zone into\n\tpointers.\n\t(tree_id_zone): New variable.\n\t(ggc_alloc_cleared_zone): Remove unused.\n\t(ggc_alloc_zone): Define.\n\t(ggc_alloc_rtvec, ggc_alloc_tree): Update to use ggc_alloc_zone.\n\t* rtl.c (rtx_alloc_stat, shallow_copy_rtx_stat): Use\n\tggc_alloc_zone_stat.\n\t* stringpool.c (gt_pch_n_S): Update call to gt_pch_note_object.\n\t* tree.c (copy_node_stat, make_tree_binfo_stat, make_tree_vec_stat)\n\t(tree_cons_stat, build1_stat): Update call to ggc_alloc_zone_stat.\n\t(make_node_stat): Likewise.  Use tree_id_zone.\n\nFrom-SVN: r96381", "tree": {"sha": "e850ce1ca545eaad896454198fdeff35370ff00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e850ce1ca545eaad896454198fdeff35370ff00f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08cee789cdb1b64a6e07a0745489b26f6ddd0720", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08cee789cdb1b64a6e07a0745489b26f6ddd0720", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08cee789cdb1b64a6e07a0745489b26f6ddd0720", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08cee789cdb1b64a6e07a0745489b26f6ddd0720/comments", "author": null, "committer": null, "parents": [{"sha": "69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7"}], "stats": {"total": 2303, "additions": 1593, "deletions": 710}, "files": [{"sha": "4480c63a82bb3c5c5e79d28785e7c8b0a9e6cbf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -1,3 +1,41 @@\n+2005-03-13  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* ggc-zone.c: Rewritten.\n+\n+\t* alloc-pool.c (dump_alloc_pool_statistics): Don't print statistics\n+\tif there are none.\n+\t* configure.ac: Define GGC_ZONE for --with-gc=zone.\n+\t* config.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* gentype.c (write_types_process_field, write_func_for_structure):\n+\tPass new argument to gt_pch_note_object.\n+\t* ggc-common.c (struct ptr_data): Add TYPE.\n+\t(gt_pch_note_object): Take TYPE argument and save it.\n+\t(call_count): Update call to ggc_pch_count_object.\n+\t(call_alloc): Update call to ggc_pch_alloc_object.\n+\t(gt_pch_save): Call ggc_pch_prepare_write after paddng the PCH\n+\tfile.\n+\t* ggc-none.c (rtl_zone, garbage_zone, ggc_alloc_zone_stat): Delete.\n+\t* ggc-page.c (rtl_zone, tree_zone, garbage_zone)\n+\t(ggc_alloc_zone_stat): Delete.\n+\t(ggc_pch_count_object, ggc_pch_alloc_object): Add TYPE argument.\n+\t* ggc.h (gt_pch_note_object, ggc_pch_count_object)\n+\t(ggc_pch_alloc_object): Update prototypes.\n+\t(garbage_zone): Delete.\n+\t(tree_zone, rtl_zone, ggc_alloc_zone_stat, ggc_alloc_zone): Move to\n+\tGGC_ZONE conditional.  Update.  Change tree_zone and rtl_zone into\n+\tpointers.\n+\t(tree_id_zone): New variable.\n+\t(ggc_alloc_cleared_zone): Remove unused.\n+\t(ggc_alloc_zone): Define.\n+\t(ggc_alloc_rtvec, ggc_alloc_tree): Update to use ggc_alloc_zone.\n+\t* rtl.c (rtx_alloc_stat, shallow_copy_rtx_stat): Use\n+\tggc_alloc_zone_stat.\n+\t* stringpool.c (gt_pch_n_S): Update call to gt_pch_note_object.\n+\t* tree.c (copy_node_stat, make_tree_binfo_stat, make_tree_vec_stat)\n+\t(tree_cons_stat, build1_stat): Update call to ggc_alloc_zone_stat.\n+\t(make_node_stat): Likewise.  Use tree_id_zone.\n+\n 2005-03-13  Daniel Jacobowitz  <dan@codesourcery.com>\n \t    Joseph S. Myers  <joseph@codesourcery.com>\n "}, {"sha": "7c7d1917815670fc676229becaddec445b8c006f", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -333,6 +333,9 @@ void dump_alloc_pool_statistics (void)\n #ifdef GATHER_STATISTICS\n   struct output_info info;\n \n+  if (!alloc_pool_hash)\n+    return;\n+\n   fprintf (stderr, \"\\nAlloc-pool Kind        Pools  Allocated      Peak        Leak\\n\");\n   fprintf (stderr, \"-------------------------------------------------------------\\n\");\n   info.count = 0;"}, {"sha": "d6338729f62d2f804a2f92ed9d55898998f1dafa", "filename": "gcc/config.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -79,6 +79,9 @@\n    this is either `int' or `gid_t'. */\n #undef GETGROUPS_T\n \n+/* Define if the zone collector is in use */\n+#undef GGC_ZONE\n+\n /* Define to 1 if you have the `alphasort' function. */\n #undef HAVE_ALPHASORT\n "}, {"sha": "0283bb9c490155699f85eed768af8d15abf41aa2", "filename": "gcc/configure", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -14959,8 +14959,16 @@ fi\n if test \"${with_gc+set}\" = set; then\n   withval=\"$with_gc\"\n   case \"$withval\" in\n-  page | zone)\n+  page)\n     GGC=ggc-$withval\n+    ;;\n+  zone)\n+    GGC=ggc-$withval\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define GGC_ZONE 1\n+_ACEOF\n+\n     ;;\n   *)\n     { { echo \"$as_me:$LINENO: error: $withval is an invalid option to --with-gc\" >&5"}, {"sha": "3cad882f947e8c36d56a660d0fab05cb610d5526", "filename": "gcc/configure.ac", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -3027,9 +3027,13 @@ AC_ARG_WITH(gc,\n [  --with-gc={page,zone}   choose the garbage collection mechanism to use\n                           with the compiler],\n [case \"$withval\" in\n-  page | zone)\n+  page)\n     GGC=ggc-$withval\n     ;;\n+  zone)\n+    GGC=ggc-$withval\n+    AC_DEFINE(GGC_ZONE, 1, [Define if the zone collector is in use])\n+    ;;\n   *)\n     AC_MSG_ERROR([$withval is an invalid option to --with-gc])\n     ;;"}, {"sha": "0ff0c116e627aee6b6a3017faea57650286983e7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -1928,6 +1928,21 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \t    }\n \t  else\n \t    oprintf (d->of, \", gt_%sa_%s\", wtd->param_prefix, d->prev_val[0]);\n+\n+\t  if (f->u.p->kind == TYPE_PARAM_STRUCT\n+\t      && f->u.p->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d->of, \", gt_e_\");\n+\t      output_mangled_typename (d->of, f);\n+\t    }\n+\t  else if (UNION_OR_STRUCT_P (f)\n+\t\t   && f->u.p->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d->of, \", gt_ggc_e_\");\n+\t      output_mangled_typename (d->of, f);\n+\t    }\n+\t  else\n+\t    oprintf (d->of, \", gt_types_enum_last\");\n \t}\n       oprintf (d->of, \");\\n\");\n       if (d->reorder_fn && wtd->reorder_note_routine)\n@@ -2035,6 +2050,21 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t{\n \t  oprintf (d.of, \", x, gt_%s_\", wtd->param_prefix);\n \t  output_mangled_typename (d.of, orig_s);\n+\n+\t  if (orig_s->u.p->kind == TYPE_PARAM_STRUCT\n+\t      && orig_s->u.p->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d.of, \", gt_e_\");\n+\t      output_mangled_typename (d.of, orig_s);\n+\t    }\n+\t  else if (UNION_OR_STRUCT_P (orig_s)\n+\t\t   && orig_s->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d.of, \", gt_ggc_e_\");\n+\t      output_mangled_typename (d.of, orig_s);\n+\t    }\n+\t  else\n+\t    oprintf (d.of, \", gt_types_enum_last\");\n \t}\n       oprintf (d.of, \"))\\n\");\n     }\n@@ -2045,6 +2075,21 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t{\n \t  oprintf (d.of, \", xlimit, gt_%s_\", wtd->param_prefix);\n \t  output_mangled_typename (d.of, orig_s);\n+\n+\t  if (orig_s->u.p->kind == TYPE_PARAM_STRUCT\n+\t      && orig_s->u.p->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d.of, \", gt_e_\");\n+\t      output_mangled_typename (d.of, orig_s);\n+\t    }\n+\t  else if (UNION_OR_STRUCT_P (orig_s)\n+\t\t   && orig_s->u.s.line.file != NULL)\n+\t    {\n+\t      oprintf (d.of, \", gt_ggc_e_\");\n+\t      output_mangled_typename (d.of, orig_s);\n+\t    }\n+\t  else\n+\t    oprintf (d.of, \", gt_types_enum_last\");\n \t}\n       oprintf (d.of, \"))\\n\");\n       oprintf (d.of, \"   xlimit = (\");\n@@ -2070,6 +2115,21 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t    {\n \t      oprintf (d.of, \", xprev, gt_%s_\", wtd->param_prefix);\n \t      output_mangled_typename (d.of, orig_s);\n+\n+\t      if (orig_s->u.p->kind == TYPE_PARAM_STRUCT\n+\t\t  && orig_s->u.p->u.s.line.file != NULL)\n+\t\t{\n+\t\t  oprintf (d.of, \", gt_e_\");\n+\t\t  output_mangled_typename (d.of, orig_s);\n+\t\t}\n+\t      else if (UNION_OR_STRUCT_P (orig_s)\n+\t\t       && orig_s->u.s.line.file != NULL)\n+\t\t{\n+\t\t  oprintf (d.of, \", gt_ggc_e_\");\n+\t\t  output_mangled_typename (d.of, orig_s);\n+\t\t}\n+\t      else\n+\t\toprintf (d.of, \", gt_types_enum_last\");\n \t    }\n \t  oprintf (d.of, \");\\n\");\n \t  oprintf (d.of, \"      }\\n\");"}, {"sha": "7112f78071eb21e8f9af45ff235afd98734d708b", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -244,6 +244,7 @@ struct ptr_data\n   gt_handle_reorder reorder_fn;\n   size_t size;\n   void *new_addr;\n+  enum gt_types_enum type;\n };\n \n #define POINTER_HASH(x) (hashval_t)((long)x >> 3)\n@@ -252,7 +253,8 @@ struct ptr_data\n \n int\n gt_pch_note_object (void *obj, void *note_ptr_cookie,\n-\t\t    gt_note_pointers note_ptr_fn)\n+\t\t    gt_note_pointers note_ptr_fn,\n+\t\t    enum gt_types_enum type)\n {\n   struct ptr_data **slot;\n \n@@ -277,6 +279,7 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n     (*slot)->size = strlen (obj) + 1;\n   else\n     (*slot)->size = ggc_get_size (obj);\n+  (*slot)->type = type;\n   return 1;\n }\n \n@@ -330,7 +333,9 @@ call_count (void **slot, void *state_p)\n   struct ptr_data *d = (struct ptr_data *)*slot;\n   struct traversal_state *state = (struct traversal_state *)state_p;\n \n-  ggc_pch_count_object (state->d, d->obj, d->size, d->note_ptr_fn == gt_pch_p_S);\n+  ggc_pch_count_object (state->d, d->obj, d->size,\n+\t\t\td->note_ptr_fn == gt_pch_p_S,\n+\t\t\td->type);\n   state->count++;\n   return 1;\n }\n@@ -341,7 +346,9 @@ call_alloc (void **slot, void *state_p)\n   struct ptr_data *d = (struct ptr_data *)*slot;\n   struct traversal_state *state = (struct traversal_state *)state_p;\n \n-  d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size, d->note_ptr_fn == gt_pch_p_S);\n+  d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size,\n+\t\t\t\t      d->note_ptr_fn == gt_pch_p_S,\n+\t\t\t\t      d->type);\n   state->ptrs[state->ptrs_i++] = d;\n   return 1;\n }\n@@ -476,8 +483,6 @@ gt_pch_save (FILE *f)\n   write_pch_globals (gt_ggc_rtab, &state);\n   write_pch_globals (gt_pch_cache_rtab, &state);\n \n-  ggc_pch_prepare_write (state.d, state.f);\n-\n   /* Pad the PCH file so that the mmapped area starts on an allocation\n      granularity (usually page) boundary.  */\n   {\n@@ -496,6 +501,8 @@ gt_pch_save (FILE *f)\n       && fseek (state.f, mmi.offset, SEEK_SET) != 0)\n     fatal_error (\"can't write padding to PCH file: %m\");\n \n+  ggc_pch_prepare_write (state.d, state.f);\n+\n   /* Actually write out the objects.  */\n   for (i = 0; i < state.count; i++)\n     {"}, {"sha": "da906912c9213689e600e4790db0e283d3b3b548", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -33,9 +33,6 @@\n #include \"coretypes.h\"\n #include \"ggc.h\"\n \n-struct alloc_zone *rtl_zone = NULL;\n-struct alloc_zone *garbage_zone = NULL;\n-\n void *\n ggc_alloc_typed_stat (enum gt_types_enum ARG_UNUSED (gte), size_t size\n \t\t      MEM_STAT_DECL)\n@@ -49,13 +46,6 @@ ggc_alloc_stat (size_t size MEM_STAT_DECL)\n   return xmalloc (size);\n }\n \n-void *\n-ggc_alloc_zone_stat (size_t size, struct alloc_zone * ARG_UNUSED (zone)\n-\t\t     MEM_STAT_DECL)\n-{\n-  return xmalloc (size);\n-}\n-\n void *\n ggc_alloc_cleared_stat (size_t size MEM_STAT_DECL)\n {"}, {"sha": "c97b84eff0315b515bc97ad07d6747007d600706", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -495,9 +495,6 @@ static void move_ptes_to_front (int, int);\n void debug_print_page_list (int);\n static void push_depth (unsigned int);\n static void push_by_depth (page_entry *, unsigned long *);\n-struct alloc_zone *rtl_zone = NULL;\n-struct alloc_zone *tree_zone = NULL;\n-struct alloc_zone *garbage_zone = NULL;\n \n /* Push an entry onto G.depth.  */\n \n@@ -1052,15 +1049,6 @@ ggc_alloc_typed_stat (enum gt_types_enum type ATTRIBUTE_UNUSED, size_t size\n   return ggc_alloc_stat (size PASS_MEM_STAT);\n }\n \n-/* Zone allocation function.  Does nothing special in this collector.  */\n-\n-void *\n-ggc_alloc_zone_stat (size_t size, struct alloc_zone *zone ATTRIBUTE_UNUSED\n-\t\t     MEM_STAT_DECL)\n-{\n-  return ggc_alloc_stat (size PASS_MEM_STAT);\n-}\n-\n /* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */\n \n void *\n@@ -2119,7 +2107,8 @@ init_ggc_pch (void)\n \n void\n ggc_pch_count_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n+\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED,\n+\t\t      enum gt_types_enum type ATTRIBUTE_UNUSED)\n {\n   unsigned order;\n \n@@ -2162,7 +2151,8 @@ ggc_pch_this_base (struct ggc_pch_data *d, void *base)\n \n char *\n ggc_pch_alloc_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n+\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED,\n+\t\t      enum gt_types_enum type ATTRIBUTE_UNUSED)\n {\n   unsigned order;\n   char *result;"}, {"sha": "343b7b1427b83d92168d43ebf8fa2a73c430a283", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1408, "deletions": 647, "changes": 2055, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -1,9 +1,10 @@\n /* \"Bag-of-pages\" zone garbage collector for the GNU compiler.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n-   Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin\n-   (dberlin@dberlin.org) \n \n+   Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin\n+   (dberlin@dberlin.org).  Rewritten by Daniel Jacobowitz\n+   <dan@codesourcery.com>.\n \n This file is part of GCC.\n \n@@ -51,6 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VALGRIND_MALLOCLIKE_BLOCK(w,x,y,z)\n #define VALGRIND_FREELIKE_BLOCK(x,y)\n #endif\n+\n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  Prefer either to valloc.  */\n #ifdef HAVE_MMAP_ANON\n@@ -64,56 +66,58 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #  define MAP_ANONYMOUS MAP_ANON\n # endif\n # define USING_MMAP\n-\n #endif\n \n #ifdef HAVE_MMAP_DEV_ZERO\n-\n # include <sys/mman.h>\n # ifndef MAP_FAILED\n #  define MAP_FAILED -1\n # endif\n # define USING_MMAP\n-\n #endif\n \n #ifndef USING_MMAP\n-#error \"Zone collector requires mmap\"\n+#error Zone collector requires mmap\n #endif\n \n #if (GCC_VERSION < 3001)\n #define prefetch(X) ((void) X)\n+#define prefetchw(X) ((void) X)\n #else\n #define prefetch(X) __builtin_prefetch (X)\n+#define prefetchw(X) __builtin_prefetch (X, 1, 3)\n #endif\n \n-/* NOTES:\n+/* FUTURE NOTES:\n+\n    If we track inter-zone pointers, we can mark single zones at a\n    time.\n+\n    If we have a zone where we guarantee no inter-zone pointers, we\n    could mark that zone separately.\n+\n    The garbage zone should not be marked, and we should return 1 in\n    ggc_set_mark for any object in the garbage zone, which cuts off\n    marking quickly.  */\n+\n /* Stategy:\n \n    This garbage-collecting allocator segregates objects into zones.\n    It also segregates objects into \"large\" and \"small\" bins.  Large\n-   objects are greater or equal to page size.\n-\n-   Pages for small objects are broken up into chunks, each of which\n-   are described by a struct alloc_chunk.  One can walk over all\n-   chunks on the page by adding the chunk size to the chunk's data\n-   address.  The free space for a page exists in the free chunk bins.\n+   objects are greater than page size.\n \n-   Each page-entry also has a context depth, which is used to track\n-   pushing and popping of allocation contexts.  Only objects allocated\n-   in the current (highest-numbered) context may be collected.\n+   Pages for small objects are broken up into chunks.  The page has\n+   a bitmap which marks the start position of each chunk (whether\n+   allocated or free).  Free chunks are on one of the zone's free\n+   lists and contain a pointer to the next free chunk.  Chunks in\n+   most of the free lists have a fixed size determined by the\n+   free list.  Chunks in the \"other\" sized free list have their size\n+   stored right after their chain pointer.\n \n    Empty pages (of all sizes) are kept on a single page cache list,\n    and are considered first when new pages are required; they are\n    deallocated at the start of the next collection if they haven't\n-   been recycled by then.  */\n+   been recycled by then.  The free page list is currently per-zone.  */\n \n /* Define GGC_DEBUG_LEVEL to print debugging information.\n      0: No debugging output.\n@@ -127,178 +131,295 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n #endif\n \n-#ifdef COOKIE_CHECKING\n-#define CHUNK_MAGIC 0x95321123\n-#define DEADCHUNK_MAGIC 0x12817317\n-#endif\n+/* This structure manages small free chunks.  The SIZE field is only\n+   initialized if the chunk is in the \"other\" sized free list.  Large\n+   chunks are allocated one at a time to their own page, and so don't\n+   come in here.  */\n \n-/* This structure manages small chunks.  When the chunk is free, it's\n-   linked with other chunks via free_next.  When the chunk is allocated,\n-   the data starts at u.  Large chunks are allocated one at a time to\n-   their own page, and so don't come in here.\n+struct alloc_chunk {\n+  struct alloc_chunk *next_free;\n+  unsigned int size;\n+};\n \n-   The \"type\" field is a placeholder for a future change to do\n-   generational collection.  At present it is 0 when free and\n-   and 1 when allocated.  */\n+/* The size of the fixed-size portion of a small page descriptor.  */\n+#define PAGE_OVERHEAD   (offsetof (struct small_page_entry, alloc_bits))\n \n-struct alloc_chunk {\n-#ifdef COOKIE_CHECKING\n-  unsigned int magic;\n-#endif\n-  unsigned int type:1;\n-  unsigned int mark:1;\n-  unsigned char large;\n-  unsigned short size;\n-  /* Right now, on 32-bit hosts we don't have enough room to save the\n-     typecode unless we make the one remaining flag into a bitfield.\n-     There's a performance cost to that, so we don't do it until we're\n-     ready to use the type information for something.  */\n-  union {\n-    struct alloc_chunk *next_free;\n-    char data[1];\n+/* The collector's idea of the page size.  This must be a power of two\n+   no larger than the system page size, because pages must be aligned\n+   to this amount and are tracked at this granularity in the page\n+   table.  We choose a size at compile time for efficiency.\n \n-    /* Make sure the data is sufficiently aligned.  */\n-    HOST_WIDEST_INT align_i;\n-#ifdef HAVE_LONG_DOUBLE\n-    long double align_d;\n-#else\n-    double align_d;\n+   We could make a better guess at compile time if PAGE_SIZE is a\n+   constant in system headers, and PAGE_SHIFT is defined...  */\n+#define GGC_PAGE_SIZE\t4096\n+#define GGC_PAGE_MASK\t(GGC_PAGE_SIZE - 1)\n+#define GGC_PAGE_SHIFT\t12\n+\n+#if 0\n+/* Alternative definitions which use the runtime page size.  */\n+#define GGC_PAGE_SIZE\tG.pagesize\n+#define GGC_PAGE_MASK\tG.page_mask\n+#define GGC_PAGE_SHIFT\tG.lg_pagesize\n #endif\n-  } u;\n-};\n \n-#define CHUNK_OVERHEAD\t(offsetof (struct alloc_chunk, u))\n+/* The size of a small page managed by the garbage collector.  This\n+   must currently be GGC_PAGE_SIZE, but with a few changes could\n+   be any multiple of it to reduce certain kinds of overhead.  */\n+#define SMALL_PAGE_SIZE GGC_PAGE_SIZE\n \n-/* We maintain several bins of free lists for chunks for very small\n-   objects.  We never exhaustively search other bins -- if we don't\n-   find one of the proper size, we allocate from the \"larger\" bin.  */\n+/* Free bin information.  These numbers may be in need of re-tuning.\n+   In general, decreasing the number of free bins would seem to\n+   increase the time it takes to allocate... */\n \n-/* Decreasing the number of free bins increases the time it takes to allocate.\n-   Similar with increasing max_free_bin_size without increasing num_free_bins.\n+/* FIXME: We can't use anything but MAX_ALIGNMENT for the bin size\n+   today.  */\n \n-   After much histogramming of allocation sizes and time spent on gc,\n-   on a PowerPC G4 7450 - 667 mhz, and a Pentium 4 - 2.8ghz,\n-   these were determined to be the optimal values.  */\n #define NUM_FREE_BINS\t\t64\n-#define MAX_FREE_BIN_SIZE\t(64 * sizeof (void *))\n-#define FREE_BIN_DELTA\t\t(MAX_FREE_BIN_SIZE / NUM_FREE_BINS)\n-#define SIZE_BIN_UP(SIZE)\t(((SIZE) + FREE_BIN_DELTA - 1) / FREE_BIN_DELTA)\n+#define FREE_BIN_DELTA\t\tMAX_ALIGNMENT\n #define SIZE_BIN_DOWN(SIZE)\t((SIZE) / FREE_BIN_DELTA)\n \n-/* Marker used as chunk->size for a large object.  Should correspond\n-   to the size of the bitfield above.  */\n-#define LARGE_OBJECT_SIZE\t0x7fff\n+/* Allocation and marking parameters.  */\n+\n+/* The smallest allocatable unit to keep track of.  */\n+#define BYTES_PER_ALLOC_BIT\tMAX_ALIGNMENT\n+\n+/* The smallest markable unit.  If we require each allocated object\n+   to contain at least two allocatable units, we can use half as many\n+   bits for the mark bitmap.  But this adds considerable complexity\n+   to sweeping.  */\n+#define BYTES_PER_MARK_BIT\tBYTES_PER_ALLOC_BIT\n+\n+#define BYTES_PER_MARK_WORD\t(8 * BYTES_PER_MARK_BIT * sizeof (mark_type))\n \n /* We use this structure to determine the alignment required for\n-   allocations.  For power-of-two sized allocations, that's not a\n-   problem, but it does matter for odd-sized allocations.  */\n+   allocations.\n+\n+   There are several things wrong with this estimation of alignment.\n+\n+   The maximum alignment for a structure is often less than the\n+   maximum alignment for a basic data type; for instance, on some\n+   targets long long must be aligned to sizeof (int) in a structure\n+   and sizeof (long long) in a variable.  i386-linux is one example;\n+   Darwin is another (sometimes, depending on the compiler in use).\n+\n+   Also, long double is not included.  Nothing in GCC uses long\n+   double, so we assume that this is OK.  On powerpc-darwin, adding\n+   long double would bring the maximum alignment up to 16 bytes,\n+   and until we need long double (or to vectorize compiler operations)\n+   that's painfully wasteful.  This will need to change, some day.  */\n \n struct max_alignment {\n   char c;\n   union {\n     HOST_WIDEST_INT i;\n-#ifdef HAVE_LONG_DOUBLE\n-    long double d;\n-#else\n     double d;\n-#endif\n   } u;\n };\n \n /* The biggest alignment required.  */\n \n #define MAX_ALIGNMENT (offsetof (struct max_alignment, u))\n \n-/* Compute the smallest nonnegative number which when added to X gives\n-   a multiple of F.  */\n-\n-#define ROUND_UP_VALUE(x, f) ((f) - 1 - ((f) - 1 + (x)) % (f))\n-\n /* Compute the smallest multiple of F that is >= X.  */\n \n #define ROUND_UP(x, f) (CEIL (x, f) * (f))\n \n+/* Types to use for the allocation and mark bitmaps.  It might be\n+   a good idea to add ffsl to libiberty and use unsigned long\n+   instead; that could speed us up where long is wider than int.  */\n \n-/* A page_entry records the status of an allocation page.  */\n+typedef unsigned int alloc_type;\n+typedef unsigned int mark_type;\n+#define alloc_ffs(x) ffs(x)\n+\n+/* A page_entry records the status of an allocation page.  This is the\n+   common data between all three kinds of pages - small, large, and\n+   PCH.  */\n typedef struct page_entry\n {\n-  /* The next page-entry with objects of the same size, or NULL if\n-     this is the last page-entry.  */\n-  struct page_entry *next;\n+  /* The address at which the memory is allocated.  */\n+  char *page;\n \n-  /* The number of bytes allocated.  (This will always be a multiple\n-     of the host system page size.)  */\n-  size_t bytes;\n+  /* The zone that this page entry belongs to.  */\n+  struct alloc_zone *zone;\n \n+#ifdef GATHER_STATISTICS\n   /* How many collections we've survived.  */\n   size_t survived;\n-\n-  /* The address at which the memory is allocated.  */\n-  char *page;\n-\n-  /* Context depth of this page.  */\n-  unsigned short context_depth;\n+#endif\n \n   /* Does this page contain small objects, or one large object?  */\n   bool large_p;\n \n-  /* The zone that this page entry belongs to.  */\n-  struct alloc_zone *zone;\n+  /* Is this page part of the loaded PCH?  */\n+  bool pch_p;\n } page_entry;\n \n+/* Additional data needed for small pages.  */\n+struct small_page_entry\n+{\n+  struct page_entry common;\n+\n+  /* The next small page entry, or NULL if this is the last.  */\n+  struct small_page_entry *next;\n+\n+  /* If currently marking this zone, a pointer to the mark bits\n+     for this page.  If we aren't currently marking this zone,\n+     this pointer may be stale (pointing to freed memory).  */\n+  mark_type *mark_bits;\n+\n+  /* The allocation bitmap.  This array extends far enough to have\n+     one bit for every BYTES_PER_ALLOC_BIT bytes in the page.  */\n+  alloc_type alloc_bits[1];\n+};\n+\n+/* Additional data needed for large pages.  */\n+struct large_page_entry\n+{\n+  struct page_entry common;\n+\n+  /* The next large page entry, or NULL if this is the last.  */\n+  struct large_page_entry *next;\n+\n+  /* The number of bytes allocated, not including the page entry.  */\n+  size_t bytes;\n+\n+  /* The previous page in the list, so that we can unlink this one.  */\n+  struct large_page_entry *prev;\n+\n+  /* During marking, is this object marked?  */\n+  bool mark_p;\n+};\n+\n+/* A two-level tree is used to look up the page-entry for a given\n+   pointer.  Two chunks of the pointer's bits are extracted to index\n+   the first and second levels of the tree, as follows:\n+\n+\t\t\t\t   HOST_PAGE_SIZE_BITS\n+\t\t\t   32\t\t|      |\n+       msb +----------------+----+------+------+ lsb\n+\t\t\t    |    |      |\n+\t\t\t PAGE_L1_BITS   |\n+\t\t\t\t |      |\n+\t\t\t       PAGE_L2_BITS\n+\n+   The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry\n+   pages are aligned on system page boundaries.  The next most\n+   significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first\n+   index values in the lookup table, respectively.\n+\n+   For 32-bit architectures and the settings below, there are no\n+   leftover bits.  For architectures with wider pointers, the lookup\n+   tree points to a list of pages, which must be scanned to find the\n+   correct one.  */\n+\n+#define PAGE_L1_BITS\t(8)\n+#define PAGE_L2_BITS\t(32 - PAGE_L1_BITS - GGC_PAGE_SHIFT)\n+#define PAGE_L1_SIZE\t((size_t) 1 << PAGE_L1_BITS)\n+#define PAGE_L2_SIZE\t((size_t) 1 << PAGE_L2_BITS)\n+\n+#define LOOKUP_L1(p) \\\n+  (((size_t) (p) >> (32 - PAGE_L1_BITS)) & ((1 << PAGE_L1_BITS) - 1))\n+\n+#define LOOKUP_L2(p) \\\n+  (((size_t) (p) >> GGC_PAGE_SHIFT) & ((1 << PAGE_L2_BITS) - 1))\n+\n+#if HOST_BITS_PER_PTR <= 32\n+\n+/* On 32-bit hosts, we use a two level page table, as pictured above.  */\n+typedef page_entry **page_table[PAGE_L1_SIZE];\n+\n+#else\n+\n+/* On 64-bit hosts, we use the same two level page tables plus a linked\n+   list that disambiguates the top 32-bits.  There will almost always be\n+   exactly one entry in the list.  */\n+typedef struct page_table_chain\n+{\n+  struct page_table_chain *next;\n+  size_t high_bits;\n+  page_entry **table[PAGE_L1_SIZE];\n+} *page_table;\n+\n+#endif\n \n /* The global variables.  */\n static struct globals\n {\n   /* The linked list of zones.  */\n   struct alloc_zone *zones;\n \n-  /* The system's page size.  */\n+  /* Lookup table for associating allocation pages with object addresses.  */\n+  page_table lookup;\n+\n+  /* The system's page size, and related constants.  */\n   size_t pagesize;\n   size_t lg_pagesize;\n+  size_t page_mask;\n+\n+  /* The size to allocate for a small page entry.  This includes\n+     the size of the structure and the size of the allocation\n+     bitmap.  */\n+  size_t small_page_overhead;\n \n-  /* A file descriptor open to /dev/zero for reading.  */\n #if defined (HAVE_MMAP_DEV_ZERO)\n+  /* A file descriptor open to /dev/zero for reading.  */\n   int dev_zero_fd;\n #endif\n \n+  /* Allocate pages in chunks of this size, to throttle calls to memory\n+     allocation routines.  The first page is used, the rest go onto the\n+     free list.  */\n+  size_t quire_size;\n+\n   /* The file descriptor for debugging output.  */\n   FILE *debug_file;\n } G;\n \n-/*  The zone allocation structure.  */\n+/* A zone allocation structure.  There is one of these for every\n+   distinct allocation zone.  */\n struct alloc_zone\n {\n-  /* Name of the zone.  */\n-  const char *name;\n-\n-  /* Linked list of pages in a zone.  */\n-  page_entry *pages;\n+  /* The most recent free chunk is saved here, instead of in the linked\n+     free list, to decrease list manipulation.  It is most likely that we\n+     will want this one.  */\n+  char *cached_free;\n+  size_t cached_free_size;\n \n   /* Linked lists of free storage.  Slots 1 ... NUM_FREE_BINS have chunks of size\n      FREE_BIN_DELTA.  All other chunks are in slot 0.  */\n   struct alloc_chunk *free_chunks[NUM_FREE_BINS + 1];\n \n-  /* Bytes currently allocated.  */\n+  /* The highest bin index which might be non-empty.  It may turn out\n+     to be empty, in which case we have to search downwards.  */\n+  size_t high_free_bin;\n+\n+  /* Bytes currently allocated in this zone.  */\n   size_t allocated;\n \n-  /* Bytes currently allocated at the end of the last collection.  */\n-  size_t allocated_last_gc;\n+  /* Linked list of the small pages in this zone.  */\n+  struct small_page_entry *pages;\n \n-  /* Total amount of memory mapped.  */\n-  size_t bytes_mapped;\n+  /* Doubly linked list of large pages in this zone.  */\n+  struct large_page_entry *large_pages;\n+\n+  /* If we are currently marking this zone, a pointer to the mark bits.  */\n+  mark_type *mark_bits;\n+\n+  /* Name of the zone.  */\n+  const char *name;\n \n-  /* Bit N set if any allocations have been done at context depth N.  */\n-  unsigned long context_depth_allocations;\n+  /* The number of small pages currently allocated in this zone.  */\n+  size_t n_small_pages;\n \n-  /* Bit N set if any collections have been done at context depth N.  */\n-  unsigned long context_depth_collections;\n+  /* Bytes allocated at the end of the last collection.  */\n+  size_t allocated_last_gc;\n \n-  /* The current depth in the context stack.  */\n-  unsigned short context_depth;\n+  /* Total amount of memory mapped.  */\n+  size_t bytes_mapped;\n \n   /* A cache of free system pages.  */\n-  page_entry *free_pages;\n+  struct small_page_entry *free_pages;\n \n   /* Next zone in the linked list of zones.  */\n   struct alloc_zone *next_zone;\n@@ -333,48 +454,310 @@ struct alloc_zone\n #endif\n } main_zone;\n \n-struct alloc_zone *rtl_zone;\n-struct alloc_zone *garbage_zone;\n-struct alloc_zone *tree_zone;\n+/* Some default zones.  */\n+struct alloc_zone rtl_zone;\n+struct alloc_zone tree_zone;\n+struct alloc_zone tree_id_zone;\n+\n+/* The PCH zone does not need a normal zone structure, and it does\n+   not live on the linked list of zones.  */\n+struct pch_zone\n+{\n+  /* The start of the PCH zone.  NULL if there is none.  */\n+  char *page;\n+\n+  /* The end of the PCH zone.  NULL if there is none.  */\n+  char *end;\n+\n+  /* The size of the PCH zone.  0 if there is none.  */\n+  size_t bytes;\n \n-static int always_collect;\n+  /* The allocation bitmap for the PCH zone.  */\n+  alloc_type *alloc_bits;\n \n-/* Allocate pages in chunks of this size, to throttle calls to memory\n-   allocation routines.  The first page is used, the rest go onto the\n-   free list.  This cannot be larger than HOST_BITS_PER_INT for the\n-   in_use bitmask for page_group.  */\n-#define GGC_QUIRE_SIZE 16\n+  /* If we are currently marking, the mark bitmap for the PCH zone.\n+     When it is first read in, we could avoid marking the PCH,\n+     because it will not contain any pointers to GC memory outside\n+     of the PCH; however, the PCH is currently mapped as writable,\n+     so we must mark it in case new pointers are added.  */\n+  mark_type *mark_bits;\n+} pch_zone;\n \n-static int ggc_allocated_p (const void *);\n #ifdef USING_MMAP\n static char *alloc_anon (char *, size_t, struct alloc_zone *);\n #endif\n-static struct page_entry * alloc_small_page ( struct alloc_zone *);\n-static struct page_entry * alloc_large_page (size_t, struct alloc_zone *);\n-static void free_chunk (struct alloc_chunk *, size_t, struct alloc_zone *);\n-static void free_page (struct page_entry *);\n+static struct small_page_entry * alloc_small_page (struct alloc_zone *);\n+static struct large_page_entry * alloc_large_page (size_t, struct alloc_zone *);\n+static void free_chunk (char *, size_t, struct alloc_zone *);\n+static void free_small_page (struct small_page_entry *);\n+static void free_large_page (struct large_page_entry *);\n static void release_pages (struct alloc_zone *);\n static void sweep_pages (struct alloc_zone *);\n-static void * ggc_alloc_zone_1 (size_t, struct alloc_zone *, short MEM_STAT_DECL);\n static bool ggc_collect_1 (struct alloc_zone *, bool);\n-static void check_cookies (void);\n+static void new_ggc_zone_1 (struct alloc_zone *, const char *);\n+\n+/* Traverse the page table and find the entry for a page.\n+   Die (probably) if the object wasn't allocated via GC.  */\n+\n+static inline page_entry *\n+lookup_page_table_entry (const void *p)\n+{\n+  page_entry ***base;\n+  size_t L1, L2;\n+\n+#if HOST_BITS_PER_PTR <= 32\n+  base = &G.lookup[0];\n+#else\n+  page_table table = G.lookup;\n+  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n+  while (table->high_bits != high_bits)\n+    table = table->next;\n+  base = &table->table[0];\n+#endif\n+\n+  /* Extract the level 1 and 2 indices.  */\n+  L1 = LOOKUP_L1 (p);\n+  L2 = LOOKUP_L2 (p);\n+\n+  return base[L1][L2];\n+}\n+\n+/* Set the page table entry for the page that starts at P.  If ENTRY\n+   is NULL, clear the entry.  */\n+\n+static void\n+set_page_table_entry (void *p, page_entry *entry)\n+{\n+  page_entry ***base;\n+  size_t L1, L2;\n+\n+#if HOST_BITS_PER_PTR <= 32\n+  base = &G.lookup[0];\n+#else\n+  page_table table;\n+  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n+  for (table = G.lookup; table; table = table->next)\n+    if (table->high_bits == high_bits)\n+      goto found;\n+\n+  /* Not found -- allocate a new table.  */\n+  table = xcalloc (1, sizeof(*table));\n+  table->next = G.lookup;\n+  table->high_bits = high_bits;\n+  G.lookup = table;\n+found:\n+  base = &table->table[0];\n+#endif\n+\n+  /* Extract the level 1 and 2 indices.  */\n+  L1 = LOOKUP_L1 (p);\n+  L2 = LOOKUP_L2 (p);\n+\n+  if (base[L1] == NULL)\n+    base[L1] = xcalloc (PAGE_L2_SIZE, sizeof (page_entry *));\n+\n+  base[L1][L2] = entry;\n+}\n+\n+/* Find the page table entry associated with OBJECT.  */\n+\n+static inline struct page_entry *\n+zone_get_object_page (const void *object)\n+{\n+  return lookup_page_table_entry (object);\n+}\n+\n+/* Find which element of the alloc_bits array OBJECT should be\n+   recorded in.  */\n+static inline unsigned int\n+zone_get_object_alloc_word (const void *object)\n+{\n+  return (((size_t) object & (GGC_PAGE_SIZE - 1))\n+\t  / (8 * sizeof (alloc_type) * BYTES_PER_ALLOC_BIT));\n+}\n+\n+/* Find which bit of the appropriate word in the alloc_bits array\n+   OBJECT should be recorded in.  */\n+static inline unsigned int\n+zone_get_object_alloc_bit (const void *object)\n+{\n+  return (((size_t) object / BYTES_PER_ALLOC_BIT)\n+\t  % (8 * sizeof (alloc_type)));\n+}\n+\n+/* Find which element of the mark_bits array OBJECT should be recorded\n+   in.  */\n+static inline unsigned int\n+zone_get_object_mark_word (const void *object)\n+{\n+  return (((size_t) object & (GGC_PAGE_SIZE - 1))\n+\t  / (8 * sizeof (mark_type) * BYTES_PER_MARK_BIT));\n+}\n+\n+/* Find which bit of the appropriate word in the mark_bits array\n+   OBJECT should be recorded in.  */\n+static inline unsigned int\n+zone_get_object_mark_bit (const void *object)\n+{\n+  return (((size_t) object / BYTES_PER_MARK_BIT)\n+\t  % (8 * sizeof (mark_type)));\n+}\n+\n+/* Set the allocation bit corresponding to OBJECT in its page's\n+   bitmap.  Used to split this object from the preceeding one.  */\n+static inline void\n+zone_set_object_alloc_bit (const void *object)\n+{\n+  struct small_page_entry *page\n+    = (struct small_page_entry *) zone_get_object_page (object);\n+  unsigned int start_word = zone_get_object_alloc_word (object);\n+  unsigned int start_bit = zone_get_object_alloc_bit (object);\n+\n+  page->alloc_bits[start_word] |= 1L << start_bit;\n+}\n \n+/* Clear the allocation bit corresponding to OBJECT in PAGE's\n+   bitmap.  Used to coalesce this object with the preceeding\n+   one.  */\n+static inline void\n+zone_clear_object_alloc_bit (struct small_page_entry *page,\n+\t\t\t     const void *object)\n+{\n+  unsigned int start_word = zone_get_object_alloc_word (object);\n+  unsigned int start_bit = zone_get_object_alloc_bit (object);\n+\n+  /* Would xor be quicker?  */\n+  page->alloc_bits[start_word] &= ~(1L << start_bit);\n+}\n+\n+/* Find the size of the object which starts at START_WORD and\n+   START_BIT in ALLOC_BITS, which is at most MAX_SIZE bytes.\n+   Helper function for ggc_get_size and zone_find_object_size.  */\n+\n+static inline size_t\n+zone_object_size_1 (alloc_type *alloc_bits,\n+\t\t    size_t start_word, size_t start_bit,\n+\t\t    size_t max_size)\n+{\n+  size_t size;\n+  alloc_type alloc_word;\n+  int indx;\n+\n+  /* Load the first word.  */\n+  alloc_word = alloc_bits[start_word++];\n+\n+  /* If that was the last bit in this word, we'll want to continue\n+     with the next word.  Otherwise, handle the rest of this word.  */\n+  if (start_bit)\n+    {\n+      indx = alloc_ffs (alloc_word >> start_bit);\n+      if (indx)\n+\t/* indx is 1-based.  We started at the bit after the object's\n+\t   start, but we also ended at the bit after the object's end.\n+\t   It cancels out.  */\n+\treturn indx * BYTES_PER_ALLOC_BIT;\n+\n+      /* The extra 1 accounts for the starting unit, before start_bit.  */\n+      size = (sizeof (alloc_type) * 8 - start_bit + 1) * BYTES_PER_ALLOC_BIT;\n+\n+      if (size >= max_size)\n+\treturn max_size;\n+\n+      alloc_word = alloc_bits[start_word++];\n+    }\n+  else\n+    size = BYTES_PER_ALLOC_BIT;\n+\n+  while (alloc_word == 0)\n+    {\n+      size += sizeof (alloc_type) * 8 * BYTES_PER_ALLOC_BIT;\n+      if (size >= max_size)\n+\treturn max_size;\n+      alloc_word = alloc_bits[start_word++];\n+    }\n \n-/* Returns nonzero if P was allocated in GC'able memory.  */\n+  indx = alloc_ffs (alloc_word);\n+  return size + (indx - 1) * BYTES_PER_ALLOC_BIT;\n+}\n+\n+/* Find the size of OBJECT on small page PAGE.  */\n \n-static inline int\n-ggc_allocated_p (const void *p)\n+static inline size_t\n+zone_find_object_size (struct small_page_entry *page,\n+\t\t       const void *object)\n {\n-  struct alloc_chunk *chunk;\n-  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n-#ifdef COOKIE_CHECKING\n-  gcc_assert (chunk->magic == CHUNK_MAGIC);\n+  const char *object_midptr = (const char *) object + BYTES_PER_ALLOC_BIT;\n+  unsigned int start_word = zone_get_object_alloc_word (object_midptr);\n+  unsigned int start_bit = zone_get_object_alloc_bit (object_midptr);\n+  size_t max_size = (page->common.page + SMALL_PAGE_SIZE\n+\t\t     - (char *) object);\n+\n+  return zone_object_size_1 (page->alloc_bits, start_word, start_bit,\n+\t\t\t     max_size);\n+}\n+\n+/* Allocate the mark bits for every zone, and set the pointers on each\n+   page.  */\n+static void\n+zone_allocate_marks (void)\n+{\n+  struct alloc_zone *zone;\n+\n+  for (zone = G.zones; zone; zone = zone->next_zone)\n+    {\n+      struct small_page_entry *page;\n+      mark_type *cur_marks;\n+      size_t mark_words, mark_words_per_page;\n+#ifdef ENABLE_CHECKING\n+      size_t n = 0;\n #endif\n-  if (chunk->type == 1)\n-    return true;  \n-  return false;\n+\n+      mark_words_per_page\n+\t= (GGC_PAGE_SIZE + BYTES_PER_MARK_WORD - 1) / BYTES_PER_MARK_WORD;\n+      mark_words = zone->n_small_pages * mark_words_per_page;\n+      zone->mark_bits = (mark_type *) xcalloc (sizeof (mark_type),\n+\t\t\t\t\t\t   mark_words);\n+      cur_marks = zone->mark_bits;\n+      for (page = zone->pages; page; page = page->next)\n+\t{\n+\t  page->mark_bits = cur_marks;\n+\t  cur_marks += mark_words_per_page;\n+#ifdef ENABLE_CHECKING\n+\t  n++;\n+#endif\n+\t}\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (n == zone->n_small_pages);\n+#endif\n+    }\n+\n+  /* We don't collect the PCH zone, but we do have to mark it\n+     (for now).  */\n+  if (pch_zone.bytes)\n+    pch_zone.mark_bits\n+      = (mark_type *) xcalloc (sizeof (mark_type),\n+\t\t\t       CEIL (pch_zone.bytes, BYTES_PER_MARK_WORD));\n }\n \n+/* After marking and sweeping, release the memory used for mark bits.  */\n+static void\n+zone_free_marks (void)\n+{\n+  struct alloc_zone *zone;\n+\n+  for (zone = G.zones; zone; zone = zone->next_zone)\n+    if (zone->mark_bits)\n+      {\n+\tfree (zone->mark_bits);\n+\tzone->mark_bits = NULL;\n+      }\n+\n+  if (pch_zone.bytes)\n+    {\n+      free (pch_zone.mark_bits);\n+      pch_zone.mark_bits = NULL;\n+    }\n+}\n \n #ifdef USING_MMAP\n /* Allocate SIZE bytes of anonymous memory, preferably near PREF,\n@@ -392,7 +775,6 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size, struct alloc_zone *zone)\n   char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n \t\t\t      MAP_PRIVATE, G.dev_zero_fd, 0);\n #endif\n-  VALGRIND_MALLOCLIKE_BLOCK(page, size, 0, 0);\n \n   if (page == (char *) MAP_FAILED)\n     {\n@@ -402,105 +784,106 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size, struct alloc_zone *zone)\n \n   /* Remember that we allocated this memory.  */\n   zone->bytes_mapped += size;\n+\n   /* Pretend we don't have access to the allocated pages.  We'll enable\n      access to smaller pieces of the area in ggc_alloc.  Discard the\n      handle to avoid handle leak.  */\n   VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (page, size));\n+\n   return page;\n }\n #endif\n \n-/* Allocate a new page for allocating objects of size 2^ORDER,\n-   and return an entry for it.  */\n+/* Allocate a new page for allocating small objects in ZONE, and\n+   return an entry for it.  */\n \n-static inline struct page_entry *\n+static struct small_page_entry *\n alloc_small_page (struct alloc_zone *zone)\n {\n-  struct page_entry *entry;\n-  char *page;\n-\n-  page = NULL;\n+  struct small_page_entry *entry;\n \n   /* Check the list of free pages for one we can use.  */\n   entry = zone->free_pages;\n   if (entry != NULL)\n     {\n       /* Recycle the allocated memory from this page ...  */\n       zone->free_pages = entry->next;\n-      page = entry->page;\n-\n-\n     }\n-#ifdef USING_MMAP\n   else\n     {\n       /* We want just one page.  Allocate a bunch of them and put the\n \t extras on the freelist.  (Can only do this optimization with\n \t mmap for backing store.)  */\n-      struct page_entry *e, *f = zone->free_pages;\n+      struct small_page_entry *e, *f = zone->free_pages;\n       int i;\n+      char *page;\n \n-      page = alloc_anon (NULL, G.pagesize * GGC_QUIRE_SIZE, zone);\n+      page = alloc_anon (NULL, GGC_PAGE_SIZE * G.quire_size, zone);\n \n       /* This loop counts down so that the chain will be in ascending\n \t memory order.  */\n-      for (i = GGC_QUIRE_SIZE - 1; i >= 1; i--)\n+      for (i = G.quire_size - 1; i >= 1; i--)\n \t{\n-\t  e = (struct page_entry *) xmalloc (sizeof (struct page_entry));\n-\t  e->bytes = G.pagesize;\n-\t  e->page = page + (i << G.lg_pagesize);\n+\t  e = xcalloc (1, G.small_page_overhead);\n+\t  e->common.page = page + (i << GGC_PAGE_SHIFT);\n+\t  e->common.zone = zone;\n \t  e->next = f;\n \t  f = e;\n+\t  set_page_table_entry (e->common.page, &e->common);\n \t}\n \n       zone->free_pages = f;\n+\n+      entry = xcalloc (1, G.small_page_overhead);\n+      entry->common.page = page;\n+      entry->common.zone = zone;\n+      set_page_table_entry (page, &entry->common);\n     }\n-#endif\n-  if (entry == NULL)\n-    entry = (struct page_entry *) xmalloc (sizeof (struct page_entry));\n \n-  entry->next = 0;\n-  entry->bytes = G.pagesize;\n-  entry->page = page;\n-  entry->context_depth = zone->context_depth;\n-  entry->large_p = false;\n-  entry->zone = zone;\n-  zone->context_depth_allocations |= (unsigned long)1 << zone->context_depth;\n+  zone->n_small_pages++;\n \n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file,\n-\t     \"Allocating %s page at %p, data %p-%p\\n\", entry->zone->name,\n-\t     (PTR) entry, page, page + G.pagesize - 1);\n+\t     \"Allocating %s page at %p, data %p-%p\\n\",\n+\t     entry->common.zone->name, (PTR) entry, entry->common.page,\n+\t     entry->common.page + SMALL_PAGE_SIZE - 1);\n \n   return entry;\n }\n-/* Compute the smallest multiple of F that is >= X.  */\n-\n-#define ROUND_UP(x, f) (CEIL (x, f) * (f))\n \n /* Allocate a large page of size SIZE in ZONE.  */\n \n-static inline struct page_entry *\n+static struct large_page_entry *\n alloc_large_page (size_t size, struct alloc_zone *zone)\n {\n-  struct page_entry *entry;\n+  struct large_page_entry *entry;\n   char *page;\n-  size =  ROUND_UP (size, 1024);\n-  page = (char *) xmalloc (size + CHUNK_OVERHEAD + sizeof (struct page_entry));\n-  entry = (struct page_entry *) (page + size + CHUNK_OVERHEAD);\n+  size_t needed_size;\n+\n+  needed_size = size + sizeof (struct large_page_entry);\n+  page = xmalloc (needed_size);\n \n-  entry->next = 0;\n+  entry = (struct large_page_entry *) page;\n+\n+  entry->next = NULL;\n+  entry->common.page = page + sizeof (struct large_page_entry);\n+  entry->common.large_p = true;\n+  entry->common.pch_p = false;\n+  entry->common.zone = zone;\n+#ifdef GATHER_STATISTICS\n+  entry->common.survived = 0;\n+#endif\n+  entry->mark_p = false;\n   entry->bytes = size;\n-  entry->page = page;\n-  entry->context_depth = zone->context_depth;\n-  entry->large_p = true;\n-  entry->zone = zone;\n-  zone->context_depth_allocations |= (unsigned long)1 << zone->context_depth;\n+  entry->prev = NULL;\n+\n+  set_page_table_entry (entry->common.page, &entry->common);\n \n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file,\n-\t     \"Allocating %s large page at %p, data %p-%p\\n\", entry->zone->name,\n-\t     (PTR) entry, page, page + size - 1);\n+\t     \"Allocating %s large page at %p, data %p-%p\\n\",\n+\t     entry->common.zone->name, (PTR) entry, entry->common.page,\n+\t     entry->common.page + SMALL_PAGE_SIZE - 1);\n \n   return entry;\n }\n@@ -509,27 +892,41 @@ alloc_large_page (size_t size, struct alloc_zone *zone)\n /* For a page that is no longer needed, put it on the free page list.  */\n \n static inline void\n-free_page (page_entry *entry)\n+free_small_page (struct small_page_entry *entry)\n {\n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file,\n-\t     \"Deallocating %s page at %p, data %p-%p\\n\", entry->zone->name, (PTR) entry,\n-\t     entry->page, entry->page + entry->bytes - 1);\n+\t     \"Deallocating %s page at %p, data %p-%p\\n\",\n+\t     entry->common.zone->name, (PTR) entry,\n+\t     entry->common.page, entry->common.page + SMALL_PAGE_SIZE - 1);\n \n-  if (entry->large_p)\n-    {\n-      free (entry->page);\n-      VALGRIND_FREELIKE_BLOCK (entry->page, entry->bytes);\n-    }\n-  else\n-    {\n-      /* Mark the page as inaccessible.  Discard the handle to\n-\t avoid handle leak.  */\n-      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (entry->page, entry->bytes));\n+  gcc_assert (!entry->common.large_p);\n \n-      entry->next = entry->zone->free_pages;\n-      entry->zone->free_pages = entry;\n-    }\n+  /* Mark the page as inaccessible.  Discard the handle to\n+     avoid handle leak.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (entry->common.page,\n+\t\t\t\t\t    SMALL_PAGE_SIZE));\n+\n+  entry->next = entry->common.zone->free_pages;\n+  entry->common.zone->free_pages = entry;\n+  entry->common.zone->n_small_pages--;\n+}\n+\n+/* Release a large page that is no longer needed.  */\n+\n+static inline void\n+free_large_page (struct large_page_entry *entry)\n+{\n+  if (GGC_DEBUG_LEVEL >= 2)\n+    fprintf (G.debug_file,\n+\t     \"Deallocating %s page at %p, data %p-%p\\n\",\n+\t     entry->common.zone->name, (PTR) entry,\n+\t     entry->common.page, entry->common.page + SMALL_PAGE_SIZE - 1);\n+\n+  gcc_assert (entry->common.large_p);\n+\n+  set_page_table_entry (entry->common.page, NULL);\n+  free (entry);\n }\n \n /* Release the free page cache to the system.  */\n@@ -538,7 +935,7 @@ static void\n release_pages (struct alloc_zone *zone)\n {\n #ifdef USING_MMAP\n-  page_entry *p, *next;\n+  struct small_page_entry *p, *next;\n   char *start;\n   size_t len;\n \n@@ -547,17 +944,17 @@ release_pages (struct alloc_zone *zone)\n \n   while (p)\n     {\n-      start = p->page;\n+      start = p->common.page;\n       next = p->next;\n-      len = p->bytes;\n-      free (p);\n+      len = SMALL_PAGE_SIZE;\n+      set_page_table_entry (p->common.page, NULL);\n       p = next;\n \n-      while (p && p->page == start + len)\n+      while (p && p->common.page == start + len)\n \t{\n \t  next = p->next;\n-\t  len += p->bytes;\n-\t  free (p);\n+\t  len += SMALL_PAGE_SIZE;\n+\t  set_page_table_entry (p->common.page, NULL);\n \t  p = next;\n \t}\n \n@@ -569,74 +966,157 @@ release_pages (struct alloc_zone *zone)\n #endif\n }\n \n-/* Place CHUNK of size SIZE on the free list for ZONE.  */\n+/* Place the block at PTR of size SIZE on the free list for ZONE.  */\n \n static inline void\n-free_chunk (struct alloc_chunk *chunk, size_t size, struct alloc_zone *zone)\n+free_chunk (char *ptr, size_t size, struct alloc_zone *zone)\n {\n+  struct alloc_chunk *chunk = (struct alloc_chunk *) ptr;\n   size_t bin = 0;\n \n   bin = SIZE_BIN_DOWN (size);\n-  gcc_assert (bin);\n+  gcc_assert (bin != 0);\n   if (bin > NUM_FREE_BINS)\n-    bin = 0;\n-#ifdef COOKIE_CHECKING\n-  gcc_assert (chunk->magic == CHUNK_MAGIC || chunk->magic == DEADCHUNK_MAGIC);\n-  chunk->magic = DEADCHUNK_MAGIC;\n-#endif\n-  chunk->u.next_free = zone->free_chunks[bin];\n+    {\n+      bin = 0;\n+      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n+      chunk->size = size;\n+      chunk->next_free = zone->free_chunks[bin];\n+      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (ptr + sizeof (struct alloc_chunk),\n+\t\t\t\t\t\tsize - sizeof (struct alloc_chunk)));\n+    }\n+  else\n+    {\n+      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk *)));\n+      chunk->next_free = zone->free_chunks[bin];\n+      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (ptr + sizeof (struct alloc_chunk *),\n+\t\t\t\t\t\tsize - sizeof (struct alloc_chunk *)));\n+    }\n+\n   zone->free_chunks[bin] = chunk;\n+  if (bin > zone->high_free_bin)\n+    zone->high_free_bin = bin;\n   if (GGC_DEBUG_LEVEL >= 3)\n     fprintf (G.debug_file, \"Deallocating object, chunk=%p\\n\", (void *)chunk);\n-  VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (chunk, sizeof (struct alloc_chunk)));\n }\n \n-/* Allocate a chunk of memory of SIZE bytes.  */\n+/* Allocate a chunk of memory of at least ORIG_SIZE bytes, in ZONE.  */\n \n-static void *\n-ggc_alloc_zone_1 (size_t orig_size, struct alloc_zone *zone,\n-\t\t  short type ATTRIBUTE_UNUSED\n-\t\t  MEM_STAT_DECL)\n+void *\n+ggc_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n+\t\t     MEM_STAT_DECL)\n {\n-  size_t bin = 0;\n-  size_t lsize = 0;\n-  struct page_entry *entry;\n-  struct alloc_chunk *chunk, *lchunk, **pp;\n+  size_t bin;\n+  size_t csize;\n+  struct small_page_entry *entry;\n+  struct alloc_chunk *chunk, **pp;\n   void *result;\n   size_t size = orig_size;\n \n-  /* Align size, so that we're assured of aligned allocations.  */\n-  if (size < FREE_BIN_DELTA)\n-    size = FREE_BIN_DELTA;\n-  size = (size + MAX_ALIGNMENT - 1) & -MAX_ALIGNMENT;\n+  /* Make sure that zero-sized allocations get a unique and freeable\n+     pointer.  */\n+  if (size == 0)\n+    size = MAX_ALIGNMENT;\n+  else\n+    size = (size + MAX_ALIGNMENT - 1) & -MAX_ALIGNMENT;\n+\n+  /* Try to allocate the object from several different sources.  Each\n+     of these cases is responsible for setting RESULT and SIZE to\n+     describe the allocated block, before jumping to FOUND.  If a\n+     chunk is split, the allocate bit for the new chunk should also be\n+     set.\n+\n+     Large objects are handled specially.  However, they'll just fail\n+     the next couple of conditions, so we can wait to check for them\n+     below.  The large object case is relatively rare (< 1%), so this\n+     is a win.  */\n+\n+  /* First try to split the last chunk we allocated.  For best\n+     fragmentation behavior it would be better to look for a\n+     free bin of the appropriate size for a small object.  However,\n+     we're unlikely (1% - 7%) to find one, and this gives better\n+     locality behavior anyway.  This case handles the lion's share\n+     of all calls to this function.  */\n+  if (size <= zone->cached_free_size)\n+    {\n+      result = zone->cached_free;\n+\n+      zone->cached_free_size -= size;\n+      if (zone->cached_free_size)\n+\t{\n+\t  zone->cached_free += size;\n+\t  zone_set_object_alloc_bit (zone->cached_free);\n+\t}\n+\n+      goto found;\n+    }\n+\n+  /* Next, try to find a free bin of the exactly correct size.  */\n+\n+  /* We want to round SIZE up, rather than down, but we know it's\n+     already aligned to at least FREE_BIN_DELTA, so we can just\n+     shift.  */\n+  bin = SIZE_BIN_DOWN (size);\n \n-  /* Large objects are handled specially.  */\n-  if (size >= G.pagesize - 2*CHUNK_OVERHEAD - FREE_BIN_DELTA)\n+  if (bin <= NUM_FREE_BINS\n+      && (chunk = zone->free_chunks[bin]) != NULL)\n     {\n-      size = ROUND_UP (size, 1024);\n-      entry = alloc_large_page (size, zone);\n-      entry->survived = 0;\n-      entry->next = entry->zone->pages;\n-      entry->zone->pages = entry;\n+      /* We have a chunk of the right size.  Pull it off the free list\n+\t and use it.  */\n \n-      chunk = (struct alloc_chunk *) entry->page;\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n-      chunk->large = 1;\n-      chunk->size = CEIL (size, 1024);\n+      zone->free_chunks[bin] = chunk->next_free;\n+\n+      /* NOTE: SIZE is only guaranteed to be right if MAX_ALIGNMENT\n+\t == FREE_BIN_DELTA.  */\n+      result = chunk;\n+\n+      /* The allocation bits are already set correctly.  HIGH_FREE_BIN\n+\t may now be wrong, if this was the last chunk in the high bin.\n+\t Rather than fixing it up now, wait until we need to search\n+\t the free bins.  */\n \n       goto found;\n     }\n \n-  /* First look for a tiny object already segregated into its own\n-     size bucket.  */\n-  bin = SIZE_BIN_UP (size);\n-  if (bin <= NUM_FREE_BINS)\n+  /* Next, if there wasn't a chunk of the ideal size, look for a chunk\n+     to split.  We can find one in the too-big bin, or in the largest\n+     sized bin with a chunk in it.  Try the largest normal-sized bin\n+     first.  */\n+\n+  if (zone->high_free_bin > bin)\n     {\n-      chunk = zone->free_chunks[bin];\n-      if (chunk)\n+      /* Find the highest numbered free bin.  It will be at or below\n+\t the watermark.  */\n+      while (zone->high_free_bin > bin\n+\t     && zone->free_chunks[zone->high_free_bin] == NULL)\n+\tzone->high_free_bin--;\n+\n+      if (zone->high_free_bin > bin)\n \t{\n-\t  zone->free_chunks[bin] = chunk->u.next_free;\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n+\t  size_t tbin = zone->high_free_bin;\n+\t  chunk = zone->free_chunks[tbin];\n+\n+\t  /* Remove the chunk from its previous bin.  */\n+\t  zone->free_chunks[tbin] = chunk->next_free;\n+\n+\t  result = (char *) chunk;\n+\n+\t  /* Save the rest of the chunk for future allocation.  */\n+\t  if (zone->cached_free_size)\n+\t    free_chunk (zone->cached_free, zone->cached_free_size, zone);\n+\n+\t  chunk = (struct alloc_chunk *) ((char *) result + size);\n+\t  zone->cached_free = (char *) chunk;\n+\t  zone->cached_free_size = (tbin - bin) * FREE_BIN_DELTA;\n+\n+\t  /* Mark the new free chunk as an object, so that we can\n+\t     find the size of the newly allocated object.  */\n+\t  zone_set_object_alloc_bit (chunk);\n+\n+\t  /* HIGH_FREE_BIN may now be wrong, if this was the last\n+\t     chunk in the high bin.  Rather than fixing it up now,\n+\t     wait until we need to search the free bins.  */\n+\n \t  goto found;\n \t}\n     }\n@@ -647,85 +1127,113 @@ ggc_alloc_zone_1 (size_t orig_size, struct alloc_zone *zone,\n   chunk = *pp;\n   while (chunk && chunk->size < size)\n     {\n-      pp = &chunk->u.next_free;\n+      pp = &chunk->next_free;\n       chunk = *pp;\n     }\n \n-  /* Failing that, allocate new storage.  */\n-  if (!chunk)\n+  if (chunk)\n     {\n-      entry = alloc_small_page (zone);\n-      entry->next = entry->zone->pages;\n-      entry->zone->pages = entry;\n+      /* Remove the chunk from its previous bin.  */\n+      *pp = chunk->next_free;\n \n-      chunk = (struct alloc_chunk *) entry->page;\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n-      chunk->size = G.pagesize - CHUNK_OVERHEAD;\n-      chunk->large = 0;\n+      result = (char *) chunk;\n+\n+      /* Save the rest of the chunk for future allocation, if there's any\n+\t left over.  */\n+      csize = chunk->size;\n+      if (csize > size)\n+\t{\n+\t  if (zone->cached_free_size)\n+\t    free_chunk (zone->cached_free, zone->cached_free_size, zone);\n+\n+\t  chunk = (struct alloc_chunk *) ((char *) result + size);\n+\t  zone->cached_free = (char *) chunk;\n+\t  zone->cached_free_size = csize - size;\n+\n+\t  /* Mark the new free chunk as an object.  */\n+\t  zone_set_object_alloc_bit (chunk);\n+\t}\n+\n+      goto found;\n     }\n-  else\n+\n+  /* Handle large allocations.  We could choose any threshold between\n+     GGC_PAGE_SIZE - sizeof (struct large_page_entry) and\n+     GGC_PAGE_SIZE.  It can't be smaller, because then it wouldn't\n+     be guaranteed to have a unique entry in the lookup table.  Large\n+     allocations will always fall through to here.  */\n+  if (size > GGC_PAGE_SIZE)\n     {\n-      *pp = chunk->u.next_free;\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n-      chunk->large = 0;\n+      struct large_page_entry *entry = alloc_large_page (size, zone);\n+\n+#ifdef GATHER_STATISTICS\n+      entry->common.survived = 0;\n+#endif\n+\n+      entry->next = zone->large_pages;\n+      if (zone->large_pages)\n+\tzone->large_pages->prev = entry;\n+      zone->large_pages = entry;\n+\n+      result = entry->common.page;\n+\n+      goto found;\n     }\n-  /* Release extra memory from a chunk that's too big.  */\n-  lsize = chunk->size - size;\n-  if (lsize >= CHUNK_OVERHEAD + FREE_BIN_DELTA)\n+\n+  /* Failing everything above, allocate a new small page.  */\n+\n+  entry = alloc_small_page (zone);\n+  entry->next = zone->pages;\n+  zone->pages = entry;\n+\n+  /* Mark the first chunk in the new page.  */\n+  entry->alloc_bits[0] = 1;\n+\n+  result = entry->common.page;\n+  if (size < SMALL_PAGE_SIZE)\n     {\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n-      chunk->size = size;\n+      if (zone->cached_free_size)\n+\tfree_chunk (zone->cached_free, zone->cached_free_size, zone);\n \n-      lsize -= CHUNK_OVERHEAD;\n-      lchunk = (struct alloc_chunk *)(chunk->u.data + size);\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (lchunk, sizeof (struct alloc_chunk)));\n-#ifdef COOKIE_CHECKING\n-      lchunk->magic = CHUNK_MAGIC;\n-#endif\n-      lchunk->type = 0;\n-      lchunk->mark = 0;\n-      lchunk->size = lsize;\n-      lchunk->large = 0;\n-      free_chunk (lchunk, lsize, zone);\n-      lsize = 0;\n+      zone->cached_free = (char *) result + size;\n+      zone->cached_free_size = SMALL_PAGE_SIZE - size;\n+\n+      /* Mark the new free chunk as an object.  */\n+      zone_set_object_alloc_bit (zone->cached_free);\n     }\n \n-  /* Calculate the object's address.  */\n  found:\n-#ifdef COOKIE_CHECKING\n-  chunk->magic = CHUNK_MAGIC;\n-#endif\n-  chunk->type = 1;\n-  chunk->mark = 0;\n+\n   /* We could save TYPE in the chunk, but we don't use that for\n-     anything yet.  */\n-  result = chunk->u.data;\n+     anything yet.  If we wanted to, we could do it by adding it\n+     either before the beginning of the chunk or after its end,\n+     and adjusting the size and pointer appropriately.  */\n+\n+  /* We'll probably write to this after we return.  */\n+  prefetchw (result);\n \n #ifdef ENABLE_GC_CHECKING\n-  /* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the\n-     exact same semantics in presence of memory bugs, regardless of\n-     ENABLE_VALGRIND_CHECKING.  We override this request below.  Drop the\n-     handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n-\n   /* `Poison' the entire allocated object.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n   memset (result, 0xaf, size);\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (result + orig_size,\n+\t\t\t\t\t    size - orig_size));\n #endif\n \n   /* Tell Valgrind that the memory is there, but its content isn't\n      defined.  The bytes at the end of the object are still marked\n      unaccessible.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, orig_size));\n \n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n   zone->allocated += size;\n \n #ifdef GATHER_STATISTICS\n-  ggc_record_overhead (orig_size, size + CHUNK_OVERHEAD - orig_size PASS_MEM_STAT);\n+  ggc_record_overhead (orig_size, size - orig_size, result PASS_MEM_STAT);\n \n   {\n-    size_t object_size = size + CHUNK_OVERHEAD;\n+    size_t object_size = size;\n     size_t overhead = object_size - orig_size;\n \n     zone->stats.total_overhead += overhead;\n@@ -750,8 +1258,8 @@ ggc_alloc_zone_1 (size_t orig_size, struct alloc_zone *zone,\n #endif\n \n   if (GGC_DEBUG_LEVEL >= 3)\n-    fprintf (G.debug_file, \"Allocating object, chunk=%p size=%lu at %p\\n\",\n-\t     (void *)chunk, (unsigned long) size, result);\n+    fprintf (G.debug_file, \"Allocating object, size=%lu at %p\\n\",\n+\t     (unsigned long) size, result);\n \n   return result;\n }\n@@ -766,16 +1274,16 @@ ggc_alloc_typed_stat (enum gt_types_enum gte, size_t size\n   switch (gte)\n     {\n     case gt_ggc_e_14lang_tree_node:\n-      return ggc_alloc_zone_1 (size, tree_zone, gte PASS_MEM_STAT);\n+      return ggc_alloc_zone_stat (size, &tree_zone PASS_MEM_STAT);\n \n     case gt_ggc_e_7rtx_def:\n-      return ggc_alloc_zone_1 (size, rtl_zone, gte PASS_MEM_STAT);\n+      return ggc_alloc_zone_stat (size, &rtl_zone PASS_MEM_STAT);\n \n     case gt_ggc_e_9rtvec_def:\n-      return ggc_alloc_zone_1 (size, rtl_zone, gte PASS_MEM_STAT);\n+      return ggc_alloc_zone_stat (size, &rtl_zone PASS_MEM_STAT);\n \n     default:\n-      return ggc_alloc_zone_1 (size, &main_zone, gte PASS_MEM_STAT);\n+      return ggc_alloc_zone_stat (size, &main_zone PASS_MEM_STAT);\n     }\n }\n \n@@ -784,36 +1292,67 @@ ggc_alloc_typed_stat (enum gt_types_enum gte, size_t size\n void *\n ggc_alloc_stat (size_t size MEM_STAT_DECL)\n {\n-  return ggc_alloc_zone_1 (size, &main_zone, -1 PASS_MEM_STAT);\n-}\n-\n-/* Zone allocation allocates into the specified zone.  */\n-\n-void *\n-ggc_alloc_zone_stat (size_t size, struct alloc_zone *zone MEM_STAT_DECL)\n-{\n-  return ggc_alloc_zone_1 (size, zone, -1 PASS_MEM_STAT);\n+  return ggc_alloc_zone_stat (size, &main_zone PASS_MEM_STAT);\n }\n \n /* Poison the chunk.  */\n #ifdef ENABLE_GC_CHECKING\n-#define poison_chunk(CHUNK, SIZE) \\\n-  memset ((CHUNK)->u.data, 0xa5, (SIZE))\n+#define poison_region(PTR, SIZE) \\\n+  memset ((PTR), 0xa5, (SIZE))\n #else\n-#define poison_chunk(CHUNK, SIZE)\n+#define poison_region(PTR, SIZE)\n #endif\n \n /* Free the object at P.  */\n \n void\n ggc_free (void *p)\n {\n-  struct alloc_chunk *chunk;\n-  \n-  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n-  \n-  /* Poison the chunk.  */\n-  poison_chunk (chunk, ggc_get_size (p));\n+  struct page_entry *page;\n+\n+#ifdef GATHER_STATISTICS\n+  ggc_free_overhead (p);\n+#endif\n+\n+  poison_region (p, ggc_get_size (p));\n+\n+  page = zone_get_object_page (p);\n+\n+  if (page->large_p)\n+    {\n+      struct large_page_entry *large_page\n+\t= (struct large_page_entry *) page;\n+\n+      /* Remove the page from the linked list.  */\n+      if (large_page->prev)\n+\tlarge_page->prev->next = large_page->next;\n+      else\n+\t{\n+\t  gcc_assert (large_page->common.zone->large_pages == large_page);\n+\t  large_page->common.zone->large_pages = large_page->next;\n+\t}\n+      if (large_page->next)\n+\tlarge_page->next->prev = large_page->prev;\n+\n+      large_page->common.zone->allocated -= large_page->bytes;\n+\n+      /* Release the memory associated with this object.  */\n+      free_large_page (large_page);\n+    }\n+  else if (page->pch_p)\n+    /* Don't do anything.  We won't allocate a new object from the\n+       PCH zone so there's no point in releasing anything.  */\n+    ;\n+  else\n+    {\n+      size_t size = ggc_get_size (p);\n+\n+      page->zone->allocated -= size;\n+\n+      /* Add the chunk to the free list.  We don't bother with coalescing,\n+\t since we are likely to want a chunk of this size again.  */\n+      free_chunk (p, size, page->zone);\n+    }\n }\n \n /* If P is not marked, mark it and return false.  Otherwise return true.\n@@ -823,15 +1362,42 @@ ggc_free (void *p)\n int\n ggc_set_mark (const void *p)\n {\n-  struct alloc_chunk *chunk;\n+  struct page_entry *page;\n+  const char *ptr = (const char *) p;\n \n-  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n-#ifdef COOKIE_CHECKING\n-  gcc_assert (chunk->magic == CHUNK_MAGIC);\n-#endif\n-  if (chunk->mark)\n-    return 1;\n-  chunk->mark = 1;\n+  page = zone_get_object_page (p);\n+\n+  if (page->pch_p)\n+    {\n+      size_t mark_word, mark_bit, offset;\n+      offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n+      mark_word = offset / (8 * sizeof (mark_type));\n+      mark_bit = offset % (8 * sizeof (mark_type));\n+      \n+      if (pch_zone.mark_bits[mark_word] & (1 << mark_bit))\n+\treturn 1;\n+      pch_zone.mark_bits[mark_word] |= (1 << mark_bit);\n+    }\n+  else if (page->large_p)\n+    {\n+      struct large_page_entry *large_page\n+\t= (struct large_page_entry *) page;\n+\n+      if (large_page->mark_p)\n+\treturn 1;\n+      large_page->mark_p = true;\n+    }\n+  else\n+    {\n+      struct small_page_entry *small_page\n+\t= (struct small_page_entry *) page;\n+\n+      if (small_page->mark_bits[zone_get_object_mark_word (p)]\n+\t  & (1 << zone_get_object_mark_bit (p)))\n+\treturn 1;\n+      small_page->mark_bits[zone_get_object_mark_word (p)]\n+\t|= (1 << zone_get_object_mark_bit (p));\n+    }\n \n   if (GGC_DEBUG_LEVEL >= 4)\n     fprintf (G.debug_file, \"Marking %p\\n\", p);\n@@ -846,47 +1412,101 @@ ggc_set_mark (const void *p)\n int\n ggc_marked_p (const void *p)\n {\n-  struct alloc_chunk *chunk;\n+  struct page_entry *page;\n+  const char *ptr = p;\n \n-  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n-#ifdef COOKIE_CHECKING\n-  gcc_assert (chunk->magic == CHUNK_MAGIC);\n-#endif\n-  return chunk->mark;\n+  page = zone_get_object_page (p);\n+\n+  if (page->pch_p)\n+    {\n+      size_t mark_word, mark_bit, offset;\n+      offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n+      mark_word = offset / (8 * sizeof (mark_type));\n+      mark_bit = offset % (8 * sizeof (mark_type));\n+      \n+      return (pch_zone.mark_bits[mark_word] & (1 << mark_bit)) != 0;\n+    }\n+\n+  if (page->large_p)\n+    {\n+      struct large_page_entry *large_page\n+\t= (struct large_page_entry *) page;\n+\n+      return large_page->mark_p;\n+    }\n+  else\n+    {\n+      struct small_page_entry *small_page\n+\t= (struct small_page_entry *) page;\n+\n+      return 0 != (small_page->mark_bits[zone_get_object_mark_word (p)]\n+\t\t   & (1 << zone_get_object_mark_bit (p)));\n+    }\n }\n \n /* Return the size of the gc-able object P.  */\n \n size_t\n ggc_get_size (const void *p)\n {\n-  struct alloc_chunk *chunk;\n+  struct page_entry *page;\n+  const char *ptr = (const char *) p;\n \n-  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n-#ifdef COOKIE_CHECKING\n-  gcc_assert (chunk->magic == CHUNK_MAGIC);\n-#endif\n-  if (chunk->large)\n-    return chunk->size * 1024;\n+  page = zone_get_object_page (p);\n+\n+  if (page->pch_p)\n+    {\n+      size_t alloc_word, alloc_bit, offset, max_size;\n+      offset = (ptr - pch_zone.page) / BYTES_PER_ALLOC_BIT + 1;\n+      alloc_word = offset / (8 * sizeof (alloc_type));\n+      alloc_bit = offset % (8 * sizeof (alloc_type));\n+      max_size = pch_zone.bytes - (ptr - pch_zone.page);\n+      return zone_object_size_1 (pch_zone.alloc_bits, alloc_word, alloc_bit,\n+\t\t\t\t max_size);\n+    }\n \n-  return chunk->size;\n+  if (page->large_p)\n+    return ((struct large_page_entry *)page)->bytes;\n+  else\n+    return zone_find_object_size ((struct small_page_entry *) page, p);\n }\n \n /* Initialize the ggc-zone-mmap allocator.  */\n void\n init_ggc (void)\n {\n+  /* The allocation size must be greater than BYTES_PER_MARK_BIT, and\n+     a multiple of both BYTES_PER_ALLOC_BIT and FREE_BIN_DELTA, for\n+     the current assumptions to hold.  */\n+\n+  gcc_assert (FREE_BIN_DELTA == MAX_ALIGNMENT);\n+\n   /* Set up the main zone by hand.  */\n   main_zone.name = \"Main zone\";\n   G.zones = &main_zone;\n \n   /* Allocate the default zones.  */\n-  rtl_zone = new_ggc_zone (\"RTL zone\");\n-  tree_zone = new_ggc_zone (\"Tree zone\");\n-  garbage_zone = new_ggc_zone (\"Garbage zone\");\n+  new_ggc_zone_1 (&rtl_zone, \"RTL zone\");\n+  new_ggc_zone_1 (&tree_zone, \"Tree zone\");\n+  new_ggc_zone_1 (&tree_id_zone, \"Tree identifier zone\");\n \n   G.pagesize = getpagesize();\n   G.lg_pagesize = exact_log2 (G.pagesize);\n+  G.page_mask = ~(G.pagesize - 1);\n+\n+  /* Require the system page size to be a multiple of GGC_PAGE_SIZE.  */\n+  gcc_assert ((G.pagesize & (GGC_PAGE_SIZE - 1)) == 0);\n+\n+  /* Allocate 16 system pages at a time.  */\n+  G.quire_size = 16 * G.pagesize / GGC_PAGE_SIZE;\n+\n+  /* Calculate the size of the allocation bitmap and other overhead.  */\n+  /* Right now we allocate bits for the page header and bitmap.  These\n+     are wasted, but a little tricky to eliminate.  */\n+  G.small_page_overhead\n+    = PAGE_OVERHEAD + (GGC_PAGE_SIZE / BYTES_PER_ALLOC_BIT / 8);\n+  /* G.small_page_overhead = ROUND_UP (G.small_page_overhead, MAX_ALIGNMENT); */\n+\n #ifdef HAVE_MMAP_DEV_ZERO\n   G.dev_zero_fd = open (\"/dev/zero\", O_RDONLY);\n   gcc_assert (G.dev_zero_fd != -1);\n@@ -906,7 +1526,7 @@ init_ggc (void)\n      hork badly if we tried to use it.  */\n   {\n     char *p = alloc_anon (NULL, G.pagesize, &main_zone);\n-    struct page_entry *e;\n+    struct small_page_entry *e;\n     if ((size_t)p & (G.pagesize - 1))\n       {\n \t/* How losing.  Discard this one and try another.  If we still\n@@ -916,25 +1536,39 @@ init_ggc (void)\n \tgcc_assert (!((size_t)p & (G.pagesize - 1)));\n       }\n \n-    /* We have a good page, might as well hold onto it...  */\n-    e = (struct page_entry *) xmalloc (sizeof (struct page_entry));\n-    e->bytes = G.pagesize;\n-    e->page = p;\n-    e->next = main_zone.free_pages;\n-    main_zone.free_pages = e;\n+    if (GGC_PAGE_SIZE == G.pagesize)\n+      {\n+\t/* We have a good page, might as well hold onto it...  */\n+\te = xcalloc (1, G.small_page_overhead);\n+\te->common.page = p;\n+\te->common.zone = &main_zone;\n+\te->next = main_zone.free_pages;\n+\tset_page_table_entry (e->common.page, &e->common);\n+\tmain_zone.free_pages = e;\n+      }\n+    else\n+      {\n+\tmunmap (p, G.pagesize);\n+      }\n   }\n #endif\n }\n \n /* Start a new GGC zone.  */\n \n-struct alloc_zone *\n-new_ggc_zone (const char * name)\n+static void\n+new_ggc_zone_1 (struct alloc_zone *new_zone, const char * name)\n {\n-  struct alloc_zone *new_zone = xcalloc (1, sizeof (struct alloc_zone));\n   new_zone->name = name;\n   new_zone->next_zone = G.zones->next_zone;\n   G.zones->next_zone = new_zone;\n+}\n+\n+struct alloc_zone *\n+new_ggc_zone (const char * name)\n+{\n+  struct alloc_zone *new_zone = xcalloc (1, sizeof (struct alloc_zone));\n+  new_ggc_zone_1 (new_zone, name);\n   return new_zone;\n }\n \n@@ -952,170 +1586,176 @@ destroy_ggc_zone (struct alloc_zone * dead_zone)\n   gcc_assert (z);\n \n   /* z is dead, baby. z is dead.  */\n-  z->dead= true;\n-}\n-\n-/* Increment the `GC context'.  Objects allocated in an outer context\n-   are never freed, eliminating the need to register their roots.  */\n-\n-void\n-ggc_push_context (void)\n-{\n-  struct alloc_zone *zone;\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    ++(zone->context_depth);\n-  /* Die on wrap.  */\n-  gcc_assert (main_zone.context_depth < HOST_BITS_PER_LONG);\n-}\n-\n-/* Decrement the `GC context'.  All objects allocated since the\n-   previous ggc_push_context are migrated to the outer context.  */\n-\n-static void\n-ggc_pop_context_1 (struct alloc_zone *zone)\n-{\n-  unsigned long omask;\n-  unsigned depth;\n-  page_entry *p;\n-\n-  depth = --(zone->context_depth);\n-  omask = (unsigned long)1 << (depth + 1);\n-\n-  if (!((zone->context_depth_allocations | zone->context_depth_collections) & omask))\n-    return;\n-\n-  zone->context_depth_allocations |= (zone->context_depth_allocations & omask) >> 1;\n-  zone->context_depth_allocations &= omask - 1;\n-  zone->context_depth_collections &= omask - 1;\n-\n-  /* Any remaining pages in the popped context are lowered to the new\n-     current context; i.e. objects allocated in the popped context and\n-     left over are imported into the previous context.  */\n-  for (p = zone->pages; p != NULL; p = p->next)\n-    if (p->context_depth > depth)\n-      p->context_depth = depth;\n-}\n-\n-/* Pop all the zone contexts.  */\n-\n-void\n-ggc_pop_context (void)\n-{\n-  struct alloc_zone *zone;\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    ggc_pop_context_1 (zone);\n+  z->dead = true;\n }\n \n /* Free all empty pages and objects within a page for a given zone  */\n \n static void\n sweep_pages (struct alloc_zone *zone)\n {\n-  page_entry **pp, *p, *next;\n-  struct alloc_chunk *chunk, *last_free, *end;\n-  size_t last_free_size, allocated = 0;\n+  struct large_page_entry **lpp, *lp, *lnext;\n+  struct small_page_entry **spp, *sp, *snext;\n+  char *last_free;\n+  size_t allocated = 0;\n   bool nomarksinpage;\n+\n   /* First, reset the free_chunks lists, since we are going to\n      re-free free chunks in hopes of coalescing them into large chunks.  */\n   memset (zone->free_chunks, 0, sizeof (zone->free_chunks));\n-  pp = &zone->pages;\n-  for (p = zone->pages; p ; p = next)\n+  zone->high_free_bin = 0;\n+  zone->cached_free = NULL;\n+  zone->cached_free_size = 0;\n+\n+  /* Large pages are all or none affairs. Either they are completely\n+     empty, or they are completely full.  */\n+  lpp = &zone->large_pages;\n+  for (lp = zone->large_pages; lp != NULL; lp = lnext)\n     {\n-      next = p->next;\n-      /* Large pages are all or none affairs. Either they are\n-\t completely empty, or they are completely full.\n-\t \n-\t XXX: Should we bother to increment allocated.  */\n-      if (p->large_p)\n+      gcc_assert (lp->common.large_p);\n+\n+      lnext = lp->next;\n+\n+#ifdef GATHER_STATISTICS\n+      /* This page has now survived another collection.  */\n+      lp->common.survived++;\n+#endif\n+\n+      if (lp->mark_p)\n \t{\n-\t  if (((struct alloc_chunk *)p->page)->mark == 1)\n-\t    {\n-\t      ((struct alloc_chunk *)p->page)->mark = 0;\n-\t      allocated += p->bytes - CHUNK_OVERHEAD;\n-\t      pp = &p->next;\n-\t    }\n-\t  else\n-\t    {\n-\t      *pp = next;\n+\t  lp->mark_p = false;\n+\t  allocated += lp->bytes;\n+\t  lpp = &lp->next;\n+\t}\n+      else\n+\t{\n+\t  *lpp = lnext;\n #ifdef ENABLE_GC_CHECKING\n-\t      /* Poison the page.  */\n-\t      memset (p->page, 0xb5, p->bytes);\n+\t  /* Poison the page.  */\n+\t  memset (lp->common.page, 0xb5, SMALL_PAGE_SIZE);\n #endif\n-\t      free_page (p);\n-\t    }\n-\t  continue;\n+\t  if (lp->prev)\n+\t    lp->prev->next = lp->next;\n+\t  if (lp->next)\n+\t    lp->next->prev = lp->prev;\n+\t  free_large_page (lp);\n \t}\n+    }\n+\n+  spp = &zone->pages;\n+  for (sp = zone->pages; sp != NULL; sp = snext)\n+    {\n+      char *object, *last_object;\n+      char *end;\n+      alloc_type *alloc_word_p;\n+      mark_type *mark_word_p;\n+\n+      gcc_assert (!sp->common.large_p);\n \n+      snext = sp->next;\n+\n+#ifdef GATHER_STATISTICS\n       /* This page has now survived another collection.  */\n-      p->survived++;\n+      sp->common.survived++;\n+#endif\n \n-      /* Which leaves full and partial pages.  Step through all chunks,\n-\t consolidate those that are free and insert them into the free\n-\t lists.  Note that consolidation slows down collection\n-\t slightly.  */\n+      /* Step through all chunks, consolidate those that are free and\n+\t insert them into the free lists.  Note that consolidation\n+\t slows down collection slightly.  */\n \n-      chunk = (struct alloc_chunk *)p->page;\n-      end = (struct alloc_chunk *)(p->page + G.pagesize);\n+      last_object = object = sp->common.page;\n+      end = sp->common.page + SMALL_PAGE_SIZE;\n       last_free = NULL;\n-      last_free_size = 0;\n       nomarksinpage = true;\n+      mark_word_p = sp->mark_bits;\n+      alloc_word_p = sp->alloc_bits;\n+\n+      gcc_assert (BYTES_PER_ALLOC_BIT == BYTES_PER_MARK_BIT);\n+\n+      object = sp->common.page;\n       do\n \t{\n-\t  prefetch ((struct alloc_chunk *)(chunk->u.data + chunk->size));\n-\t  if (chunk->mark || p->context_depth < zone->context_depth)\n+\t  unsigned int i, n;\n+\t  alloc_type alloc_word;\n+\t  mark_type mark_word;\n+\n+\t  alloc_word = *alloc_word_p++;\n+\t  mark_word = *mark_word_p++;\n+\n+\t  if (mark_word)\n+\t    nomarksinpage = false;\n+\n+\t  /* There ought to be some way to do this without looping...  */\n+\t  i = 0;\n+\t  while ((n = alloc_ffs (alloc_word)) != 0)\n \t    {\n-\t      nomarksinpage = false;\n-\t      if (last_free)\n+\t      /* Extend the current state for n - 1 bits.  We can't\n+\t\t shift alloc_word by n, even though it isn't used in the\n+\t\t loop, in case only the highest bit was set.  */\n+\t      alloc_word >>= n - 1;\n+\t      mark_word >>= n - 1;\n+\t      object += BYTES_PER_MARK_BIT * (n - 1);\n+\n+\t      if (mark_word & 1)\n \t\t{\n-\t\t  last_free->type = 0;\n-\t\t  last_free->size = last_free_size;\n-\t\t  last_free->mark = 0;\n-\t\t  poison_chunk (last_free, last_free_size);\n-\t\t  free_chunk (last_free, last_free_size, zone);\n-\t\t  last_free = NULL;\n-\t\t}\n-\t      if (chunk->mark)\n-\t        {\n-\t          allocated += chunk->size;\n-\t\t}\n-\t      chunk->mark = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (last_free)\n-\t        {\n-\t\t  last_free_size += CHUNK_OVERHEAD + chunk->size;\n+\t\t  if (last_free)\n+\t\t    {\n+\t\t      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (last_free,\n+\t\t\t\t\t\t\t\tobject\n+\t\t\t\t\t\t\t\t- last_free));\n+\t\t      poison_region (last_free, object - last_free);\n+\t\t      free_chunk (last_free, object - last_free, zone);\n+\t\t      last_free = NULL;\n+\t\t    }\n+\t\t  else\n+\t\t    allocated += object - last_object;\n+\t\t  last_object = object;\n \t\t}\n \t      else\n \t\t{\n-\t\t  last_free = chunk;\n-\t\t  last_free_size = chunk->size;\n+\t\t  if (last_free == NULL)\n+\t\t    {\n+\t\t      last_free = object;\n+\t\t      allocated += object - last_object;\n+\t\t    }\n+\t\t  else\n+\t\t    zone_clear_object_alloc_bit (sp, object);\n \t\t}\n+\n+\t      /* Shift to just after the alloc bit we handled.  */\n+\t      alloc_word >>= 1;\n+\t      mark_word >>= 1;\n+\t      object += BYTES_PER_MARK_BIT;\n+\n+\t      i += n;\n \t    }\n \n-\t  chunk = (struct alloc_chunk *)(chunk->u.data + chunk->size);\n+\t  object += BYTES_PER_MARK_BIT * (8 * sizeof (alloc_type) - i);\n \t}\n-      while (chunk < end);\n+      while (object < end);\n \n       if (nomarksinpage)\n \t{\n-\t  *pp = next;\n+\t  *spp = snext;\n #ifdef ENABLE_GC_CHECKING\n+\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (sp->common.page, SMALL_PAGE_SIZE));\n \t  /* Poison the page.  */\n-\t  memset (p->page, 0xb5, p->bytes);\n+\t  memset (sp->common.page, 0xb5, SMALL_PAGE_SIZE);\n #endif\n-\t  free_page (p);\n+\t  free_small_page (sp);\n \t  continue;\n \t}\n       else if (last_free)\n \t{\n-\t  last_free->type = 0;\n-\t  last_free->size = last_free_size;\n-\t  last_free->mark = 0;\n-\t  poison_chunk (last_free, last_free_size);\n-\t  free_chunk (last_free, last_free_size, zone);\n+\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (last_free,\n+\t\t\t\t\t\t    object - last_free));\n+\t  poison_region (last_free, object - last_free);\n+\t  free_chunk (last_free, object - last_free, zone);\n \t}\n-      pp = &p->next;\n+      else\n+\tallocated += object - last_object;\n+\n+      spp = &sp->next;\n     }\n \n   zone->allocated = allocated;\n@@ -1129,6 +1769,31 @@ sweep_pages (struct alloc_zone *zone)\n static bool\n ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n {\n+#if 0\n+  /* */\n+  {\n+    int i;\n+    for (i = 0; i < NUM_FREE_BINS + 1; i++)\n+      {\n+\tstruct alloc_chunk *chunk;\n+\tint n, tot;\n+\n+\tn = 0;\n+\ttot = 0;\n+\tchunk = zone->free_chunks[i];\n+\twhile (chunk)\n+\t  {\n+\t    n++;\n+\t    tot += chunk->size;\n+\t    chunk = chunk->next_free;\n+\t  }\n+\tfprintf (stderr, \"Bin %d: %d free chunks (%d bytes)\\n\",\n+\t\t i, n, tot);\n+      }\n+  }\n+  /* */\n+#endif\n+\n   if (!quiet_flag)\n     fprintf (stderr, \" {%s GC %luk -> \",\n \t     zone->name, (unsigned long) zone->allocated / 1024);\n@@ -1141,11 +1806,15 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n      reuse in the interim.  */\n   release_pages (zone);\n \n-  /* Indicate that we've seen collections at this context depth.  */\n-  zone->context_depth_collections\n-    = ((unsigned long)1 << (zone->context_depth + 1)) - 1;\n   if (need_marking)\n-    ggc_mark_roots ();\n+    {\n+      zone_allocate_marks ();\n+      ggc_mark_roots ();\n+#ifdef GATHER_STATISTICS\n+      ggc_prune_overhead_list ();\n+#endif\n+    }\n+  \n   sweep_pages (zone);\n   zone->was_collected = true;\n   zone->allocated_last_gc = zone->allocated;\n@@ -1155,6 +1824,7 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n   return true;\n }\n \n+#ifdef GATHER_STATISTICS\n /* Calculate the average page survival rate in terms of number of\n    collections.  */\n \n@@ -1163,59 +1833,33 @@ calculate_average_page_survival (struct alloc_zone *zone)\n {\n   float count = 0.0;\n   float survival = 0.0;\n-  page_entry *p;\n+  struct small_page_entry *p;\n+  struct large_page_entry *lp;\n   for (p = zone->pages; p; p = p->next)\n     {\n       count += 1.0;\n-      survival += p->survived;\n+      survival += p->common.survived;\n     }\n-  return survival/count;\n-}\n-\n-/* Check the magic cookies all of the chunks contain, to make sure we\n-   aren't doing anything stupid, like stomping on alloc_chunk\n-   structures.  */\n-\n-static inline void\n-check_cookies (void)\n-{\n-#ifdef COOKIE_CHECKING\n-  page_entry *p;\n-  struct alloc_zone *zone;\n-\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n+  for (lp = zone->large_pages; lp; lp = lp->next)\n     {\n-      for (p = zone->pages; p; p = p->next)\n-\t{\n-\t  if (!p->large_p)\n-\t    {\n-\t      struct alloc_chunk *chunk = (struct alloc_chunk *)p->page;\n-\t      struct alloc_chunk *end = (struct alloc_chunk *)(p->page + G.pagesize);\n-\t      do\n-\t\t{\n-\t\t  gcc_assert (chunk->magic == CHUNK_MAGIC\n-\t\t\t      || chunk->magic == DEADCHUNK_MAGIC);\n-\t\t  chunk = (struct alloc_chunk *)(chunk->u.data + chunk->size);\n-\t\t}\n-\t      while (chunk < end);\n-\t    }\n-\t}\n+      count += 1.0;\n+      survival += lp->common.survived;\n     }\n-#endif\n+  return survival/count;\n }\n+#endif\n+\n /* Top level collection routine.  */\n \n void\n ggc_collect (void)\n {\n   struct alloc_zone *zone;\n   bool marked = false;\n-  float f;\n \n   timevar_push (TV_GC);\n-  check_cookies ();\n \n-  if (!always_collect)\n+  if (!ggc_force_collect)\n     {\n       float allocated_last_gc = 0, allocated = 0, min_expand;\n \n@@ -1258,60 +1902,29 @@ ggc_collect (void)\n \n       for (zone = main_zone.next_zone; zone; zone = zone->next_zone)\n \t{\n-\t  check_cookies ();\n \t  zone->was_collected = false;\n \t  marked |= ggc_collect_1 (zone, !marked);\n \t}\n     }\n \n+#ifdef GATHER_STATISTICS\n   /* Print page survival stats, if someone wants them.  */\n   if (GGC_DEBUG_LEVEL >= 2)\n     {\n       for (zone = G.zones; zone; zone = zone->next_zone)\n \t{\n \t  if (zone->was_collected)\n \t    {\n-\t      f = calculate_average_page_survival (zone);\n+\t      float f = calculate_average_page_survival (zone);\n \t      printf (\"Average page survival in zone `%s' is %f\\n\",\n \t\t      zone->name, f);\n \t    }\n \t}\n     }\n+#endif\n \n-  /* Since we don't mark zone at a time right now, marking in any\n-     zone means marking in every zone. So we have to clear all the\n-     marks in all the zones that weren't collected already.  */\n   if (marked)\n-    {\n-      page_entry *p;\n-      for (zone = G.zones; zone; zone = zone->next_zone)\n-      {\n-\tif (zone->was_collected)\n-\t  continue;\n-\tfor (p = zone->pages; p; p = p->next)\n-\t  {\n-\t    if (!p->large_p)\n-\t      {\n-\t\tstruct alloc_chunk *chunk = (struct alloc_chunk *)p->page;\n-\t\tstruct alloc_chunk *end = (struct alloc_chunk *)(p->page + G.pagesize);\n-\t\tdo\n-\t\t  {\n-\t\t    prefetch ((struct alloc_chunk *)(chunk->u.data + chunk->size));\n-\t\t    if (chunk->mark || p->context_depth < zone->context_depth)\n-\t\t      {\n-\t\t\tchunk->mark = 0;\n-\t\t      }\n-\t\t    chunk = (struct alloc_chunk *)(chunk->u.data + chunk->size);\n-\t\t  }\n-\t\twhile (chunk < end);\n-\t      }\n-\t    else\n-\t      {\n-\t\t((struct alloc_chunk *)p->page)->mark = 0;\n-\t      }\n-\t  }\n-      }\n-    }\n+    zone_free_marks ();\n \n   /* Free dead zones.  */\n   for (zone = G.zones; zone && zone->next_zone; zone = zone->next_zone)\n@@ -1349,17 +1962,18 @@ ggc_print_statistics (void)\n   struct alloc_zone *zone;\n   struct ggc_statistics stats;\n   size_t total_overhead = 0, total_allocated = 0, total_bytes_mapped = 0;\n+  size_t pte_overhead, i;\n \n   /* Clear the statistics.  */\n   memset (&stats, 0, sizeof (stats));\n \n-  /* Make sure collection will really occur, in all zones.  */\n-  always_collect = 1;\n+  /* Make sure collection will really occur.  */\n+  ggc_force_collect = true;\n \n   /* Collect and print the statistics common across collectors.  */\n   ggc_print_common_statistics (stderr, &stats);\n \n-  always_collect = 0;\n+  ggc_force_collect = false;\n \n   /* Release free pages so that we will not count the bytes allocated\n      there as part of the total allocated memory.  */\n@@ -1375,48 +1989,43 @@ ggc_print_statistics (void)\n \t   \"Zone\", \"Allocated\", \"Used\", \"Overhead\");\n   for (zone = G.zones; zone; zone = zone->next_zone)\n     {\n-      page_entry *p;\n-      size_t allocated;\n-      size_t in_use;\n-      size_t overhead;\n+      struct large_page_entry *large_page;\n+      size_t overhead, allocated, in_use;\n \n-      /* Skip empty entries.  */\n-      if (!zone->pages)\n+      /* Skip empty zones.  */\n+      if (!zone->pages && !zone->large_pages)\n \tcontinue;\n \n-      overhead = allocated = in_use = 0;\n+      allocated = in_use = 0;\n \n-      /* Figure out the total number of bytes allocated for objects of\n-\t this size, and how many of them are actually in use.  Also figure\n-\t out how much memory the page table is using.  */\n-      for (p = zone->pages; p; p = p->next)\n+      overhead = sizeof (struct alloc_zone);\n+\n+      for (large_page = zone->large_pages; large_page != NULL;\n+\t   large_page = large_page->next)\n \t{\n-\t  struct alloc_chunk *chunk;\n+\t  allocated += large_page->bytes;\n+\t  in_use += large_page->bytes;\n+\t  overhead += sizeof (struct large_page_entry);\n+\t}\n \n-\t  /* We've also allocated sizeof (page_entry), but it's not in the\n-\t     \"managed\" area... */\n-\t  allocated += p->bytes;\n-\t  overhead += sizeof (page_entry);\n+      /* There's no easy way to walk through the small pages finding\n+\t used and unused objects.  Instead, add all the pages, and\n+\t subtract out the free list.  */\n \n-\t  if (p->large_p)\n-\t    {\n-\t      in_use += p->bytes - CHUNK_OVERHEAD;\n-\t      chunk = (struct alloc_chunk *) p->page;\n-\t      overhead += CHUNK_OVERHEAD;\n-\t      gcc_assert (chunk->type && !chunk->mark);\n-\t      continue;\n-\t    }\n+      allocated += GGC_PAGE_SIZE * zone->n_small_pages;\n+      in_use += GGC_PAGE_SIZE * zone->n_small_pages;\n+      overhead += G.small_page_overhead * zone->n_small_pages;\n \n-\t  for (chunk = (struct alloc_chunk *) p->page;\n-\t       (char *) chunk < (char *) p->page + p->bytes;\n-\t       chunk = (struct alloc_chunk *)(chunk->u.data + chunk->size))\n+      for (i = 0; i <= NUM_FREE_BINS; i++)\n+\t{\n+\t  struct alloc_chunk *chunk = zone->free_chunks[i];\n+\t  while (chunk)\n \t    {\n-\t      overhead += CHUNK_OVERHEAD;\n-\t      if (chunk->type)\n-\t\tin_use += chunk->size;\n-\t      gcc_assert (!chunk->mark);\n+\t      in_use -= ggc_get_size (chunk);\n+\t      chunk = chunk->next_free;\n \t    }\n \t}\n+      \n       fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\",\n \t       zone->name,\n \t       SCALE (allocated), LABEL (allocated),\n@@ -1430,6 +2039,30 @@ ggc_print_statistics (void)\n       total_bytes_mapped += zone->bytes_mapped;\n     }\n \n+  /* Count the size of the page table as best we can.  */\n+#if HOST_BITS_PER_PTR <= 32\n+  pte_overhead = sizeof (G.lookup);\n+  for (i = 0; i < PAGE_L1_SIZE; i++)\n+    if (G.lookup[i])\n+      pte_overhead += PAGE_L2_SIZE * sizeof (struct page_entry *);\n+#else\n+  {\n+    struct page_table_chain *table;\n+    pte_overhead = 0;\n+    while (table)\n+      {\n+\tpte_overhead += sizeof (*table);\n+\tfor (i = 0; i < PAGE_L1_SIZE; i++)\n+\t  if (table->table[i])\n+\t    pte_overhead += PAGE_L2_SIZE * sizeof (struct page_entry *);\n+\ttable = table->next;\n+      }\n+  }\n+#endif\n+  fprintf (stderr, \"%20s %11s %11s %10lu%c\\n\", \"Page Table\",\n+\t   \"\", \"\", SCALE (pte_overhead), LABEL (pte_overhead));\n+  total_overhead += pte_overhead;\n+\n   fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\", \"Total\",\n \t   SCALE (total_bytes_mapped), LABEL (total_bytes_mapped),\n \t   SCALE (total_allocated), LABEL(total_allocated),\n@@ -1485,14 +2118,34 @@ ggc_print_statistics (void)\n #endif\n }\n \n+/* Precompiled header support.  */\n+\n+/* For precompiled headers, we sort objects based on their type.  We\n+   also sort various objects into their own buckets; currently this\n+   covers strings and IDENTIFIER_NODE trees.  The choices of how\n+   to sort buckets have not yet been tuned.  */\n+\n+#define NUM_PCH_BUCKETS\t\t(gt_types_enum_last + 3)\n+\n+#define OTHER_BUCKET\t\t(gt_types_enum_last + 0)\n+#define IDENTIFIER_BUCKET\t(gt_types_enum_last + 1)\n+#define STRING_BUCKET\t\t(gt_types_enum_last + 2)\n+\n+struct ggc_pch_ondisk\n+{\n+  size_t total;\n+  size_t type_totals[NUM_PCH_BUCKETS];\n+};\n+\n struct ggc_pch_data\n {\n-  struct ggc_pch_ondisk\n-  {\n-    unsigned total;\n-  } d;\n+  struct ggc_pch_ondisk d;\n   size_t base;\n-  size_t written;\n+  size_t orig_base;\n+  size_t alloc_size;\n+  alloc_type *alloc_bits;\n+  size_t type_bases[NUM_PCH_BUCKETS];\n+  size_t start_offset;\n };\n \n /* Initialize the PCH data structure.  */\n@@ -1503,114 +2156,222 @@ init_ggc_pch (void)\n   return xcalloc (sizeof (struct ggc_pch_data), 1);\n }\n \n+/* Return which of the page-aligned buckets the object at X, with type\n+   TYPE, should be sorted into in the PCH.  Strings will have\n+   IS_STRING set and TYPE will be gt_types_enum_last.  Other objects\n+   of unknown type will also have TYPE equal to gt_types_enum_last.  */\n+\n+static int\n+pch_bucket (void *x, enum gt_types_enum type,\n+\t    bool is_string)\n+{\n+  /* Sort identifiers into their own bucket, to improve locality\n+     when searching the identifier hash table.  */\n+  if (type == gt_ggc_e_14lang_tree_node\n+      && TREE_CODE ((tree) x) == IDENTIFIER_NODE)\n+    return IDENTIFIER_BUCKET;\n+  else if (type == gt_types_enum_last)\n+    {\n+      if (is_string)\n+\treturn STRING_BUCKET;\n+      return OTHER_BUCKET;\n+    }\n+  return type;\n+}\n+\n /* Add the size of object X to the size of the PCH data.  */\n \n void\n ggc_pch_count_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string)\n+\t\t      size_t size, bool is_string, enum gt_types_enum type)\n {\n-  if (!is_string)\n-    {\n-      d->d.total += size + CHUNK_OVERHEAD;\n-    }\n-  else\n-    d->d.total += size;\n+  /* NOTE: Right now we don't need to align up the size of any objects.\n+     Strings can be unaligned, and everything else is allocated to a\n+     MAX_ALIGNMENT boundary already.  */\n+\n+  d->d.type_totals[pch_bucket (x, type, is_string)] += size;\n }\n \n /* Return the total size of the PCH data.  */\n \n size_t\n ggc_pch_total_size (struct ggc_pch_data *d)\n {\n-  return d->d.total;\n+  enum gt_types_enum i;\n+  size_t alloc_size, total_size;\n+\n+  total_size = 0;\n+  for (i = 0; i < NUM_PCH_BUCKETS; i++)\n+    {\n+      d->d.type_totals[i] = ROUND_UP (d->d.type_totals[i], GGC_PAGE_SIZE);\n+      total_size += d->d.type_totals[i];\n+    }\n+  d->d.total = total_size;\n+\n+  /* Include the size of the allocation bitmap.  */\n+  alloc_size = CEIL (d->d.total, BYTES_PER_ALLOC_BIT * 8);\n+  alloc_size = ROUND_UP (alloc_size, MAX_ALIGNMENT);\n+  d->alloc_size = alloc_size;\n+\n+  return d->d.total + alloc_size;\n }\n \n /* Set the base address for the objects in the PCH file.  */\n \n void\n-ggc_pch_this_base (struct ggc_pch_data *d, void *base)\n+ggc_pch_this_base (struct ggc_pch_data *d, void *base_)\n {\n-  d->base = (size_t) base;\n+  int i;\n+  size_t base = (size_t) base_;\n+\n+  d->base = d->orig_base = base;\n+  for (i = 0; i < NUM_PCH_BUCKETS; i++)\n+    {\n+      d->type_bases[i] = base;\n+      base += d->d.type_totals[i];\n+    }\n+\n+  if (d->alloc_bits == NULL)\n+    d->alloc_bits = xcalloc (1, d->alloc_size);\n }\n \n /* Allocate a place for object X of size SIZE in the PCH file.  */\n \n char *\n ggc_pch_alloc_object (struct ggc_pch_data *d, void *x,\n-\t\t      size_t size, bool is_string)\n+\t\t      size_t size, bool is_string,\n+\t\t      enum gt_types_enum type)\n {\n+  size_t alloc_word, alloc_bit;\n   char *result;\n-  result = (char *)d->base;\n-  if (!is_string)\n-    {\n-      struct alloc_chunk *chunk = (struct alloc_chunk *) ((char *)x - CHUNK_OVERHEAD);\n-      if (chunk->large)\n-\td->base += ggc_get_size (x) + CHUNK_OVERHEAD;\n-      else\n-\td->base += chunk->size + CHUNK_OVERHEAD;\n-      return result + CHUNK_OVERHEAD;\n-    }\n-  else\n-    {\n-      d->base += size;\n-      return result;\n-    }\n-\n+  int bucket = pch_bucket (x, type, is_string);\n+\n+  /* Record the start of the object in the allocation bitmap.  We\n+     can't assert that the allocation bit is previously clear, because\n+     strings may violate the invariant that they are at least\n+     BYTES_PER_ALLOC_BIT long.  This is harmless - ggc_get_size\n+     should not be called for strings.  */\n+  alloc_word = ((d->type_bases[bucket] - d->orig_base)\n+\t\t/ (8 * sizeof (alloc_type) * BYTES_PER_ALLOC_BIT));\n+  alloc_bit = ((d->type_bases[bucket] - d->orig_base)\n+\t       / BYTES_PER_ALLOC_BIT) % (8 * sizeof (alloc_type));\n+  d->alloc_bits[alloc_word] |= 1L << alloc_bit;\n+\n+  /* Place the object at the current pointer for this bucket.  */\n+  result = (char *) d->type_bases[bucket];\n+  d->type_bases[bucket] += size;\n+  return result;\n }\n \n /* Prepare to write out the PCH data to file F.  */\n \n void\n-ggc_pch_prepare_write (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t       FILE *f ATTRIBUTE_UNUSED)\n+ggc_pch_prepare_write (struct ggc_pch_data *d,\n+\t\t       FILE *f)\n {\n-  /* Nothing to do.  */\n+  /* We seek around a lot while writing.  Record where the end\n+     of the padding in the PCH file is, so that we can\n+     locate each object's offset.  */\n+  d->start_offset = ftell (f);\n }\n \n /* Write out object X of SIZE to file F.  */\n \n void\n-ggc_pch_write_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t      FILE *f, void *x, void *newx ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string)\n+ggc_pch_write_object (struct ggc_pch_data *d,\n+\t\t      FILE *f, void *x, void *newx,\n+\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n {\n-  if (!is_string)\n-    {\n-      struct alloc_chunk *chunk = (struct alloc_chunk *) ((char *)x - CHUNK_OVERHEAD);\n-      size = ggc_get_size (x);\n-      if (fwrite (chunk, size + CHUNK_OVERHEAD, 1, f) != 1)\n-\tfatal_error (\"can't write PCH file: %m\");\n-      d->written += size + CHUNK_OVERHEAD;\n-    }\n-   else\n-     {\n-       if (fwrite (x, size, 1, f) != 1)\n-\t fatal_error (\"can't write PCH file: %m\");\n-       d->written += size;\n-     }\n+  if (fseek (f, (size_t) newx - d->orig_base + d->start_offset, SEEK_SET) != 0)\n+    fatal_error (\"can't seek PCH file: %m\");\n+\n+  if (fwrite (x, size, 1, f) != 1)\n+    fatal_error (\"can't write PCH file: %m\");\n }\n \n void\n ggc_pch_finish (struct ggc_pch_data *d, FILE *f)\n {\n+  /* Write out the allocation bitmap.  */\n+  if (fseek (f, d->start_offset + d->d.total, SEEK_SET) != 0)\n+    fatal_error (\"can't seek PCH file: %m\");\n+\n+  if (fwrite (d->alloc_bits, d->alloc_size, 1, f) != 1)\n+    fatal_error (\"can't write PCH fle: %m\");\n+\n+  /* Done with the PCH, so write out our footer.  */\n   if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)\n     fatal_error (\"can't write PCH file: %m\");\n+\n+  free (d->alloc_bits);\n   free (d);\n }\n+\n+/* The PCH file from F has been mapped at ADDR.  Read in any\n+   additional data from the file and set up the GC state.  */\n+\n void\n ggc_pch_read (FILE *f, void *addr)\n {\n   struct ggc_pch_ondisk d;\n-  struct page_entry *entry;\n-  struct alloc_zone *pch_zone;\n+  size_t alloc_size;\n+  struct alloc_zone *zone;\n+  struct page_entry *pch_page;\n+  char *p;\n+\n   if (fread (&d, sizeof (d), 1, f) != 1)\n     fatal_error (\"can't read PCH file: %m\");\n-  entry = xcalloc (1, sizeof (struct page_entry));\n-  entry->bytes = d.total;\n-  entry->page = addr;\n-  entry->context_depth = 0;\n-  pch_zone = new_ggc_zone (\"PCH zone\");\n-  entry->zone = pch_zone;\n-  entry->next = entry->zone->pages;\n-  entry->zone->pages = entry;\n+\n+  alloc_size = CEIL (d.total, BYTES_PER_ALLOC_BIT * 8);\n+  alloc_size = ROUND_UP (alloc_size, MAX_ALIGNMENT);\n+\n+  pch_zone.bytes = d.total;\n+  pch_zone.alloc_bits = (alloc_type *) ((char *) addr + pch_zone.bytes);\n+  pch_zone.page = (char *) addr;\n+  pch_zone.end = (char *) pch_zone.alloc_bits;\n+\n+  /* We've just read in a PCH file.  So, every object that used to be\n+     allocated is now free.  */\n+  for (zone = G.zones; zone; zone = zone->next_zone)\n+    {\n+      struct small_page_entry *page, *next_page;\n+      struct large_page_entry *large_page, *next_large_page;\n+\n+      zone->allocated = 0;\n+\n+      /* Clear the zone's free chunk list.  */\n+      memset (zone->free_chunks, 0, sizeof (zone->free_chunks));\n+      zone->high_free_bin = 0;\n+      zone->cached_free = NULL;\n+      zone->cached_free_size = 0;\n+\n+      /* Move all the small pages onto the free list.  */\n+      for (page = zone->pages; page != NULL; page = next_page)\n+\t{\n+\t  next_page = page->next;\n+\t  memset (page->alloc_bits, 0,\n+\t\t  G.small_page_overhead - PAGE_OVERHEAD);\n+\t  free_small_page (page);\n+\t}\n+\n+      /* Discard all the large pages.  */\n+      for (large_page = zone->large_pages; large_page != NULL;\n+\t   large_page = next_large_page)\n+\t{\n+\t  next_large_page = large_page->next;\n+\t  free_large_page (large_page);\n+\t}\n+\n+      zone->pages = NULL;\n+      zone->large_pages = NULL;\n+    }\n+\n+  /* Allocate the dummy page entry for the PCH, and set all pages\n+     mapped into the PCH to reference it.  */\n+  pch_page = xcalloc (1, sizeof (struct page_entry));\n+  pch_page->page = pch_zone.page;\n+  pch_page->pch_p = true;\n+\n+  for (p = pch_zone.page; p < pch_zone.end; p += GGC_PAGE_SIZE)\n+    set_page_table_entry (p, pch_page);\n }"}, {"sha": "af9687aeecf62ccb90f178cd348d568dc504eb7f", "filename": "gcc/ggc.h", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -54,7 +54,8 @@ typedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,\n \t\t\t\t   void *);\n \n /* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\n-extern int gt_pch_note_object (void *, void *, gt_note_pointers);\n+extern int gt_pch_note_object (void *, void *, gt_note_pointers,\n+\t\t\t       enum gt_types_enum);\n \n /* Used by the gt_pch_n_* routines.  Register that an object has a reorder\n    function.  */\n@@ -169,9 +170,10 @@ extern struct ggc_pch_data *init_ggc_pch (void);\n \n /* The second parameter and third parameters give the address and size\n    of an object.  Update the ggc_pch_data structure with as much of\n-   that information as is necessary. The last argument should be true\n+   that information as is necessary. The bool argument should be true\n    if the object is a string.  */\n-extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool);\n+extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool,\n+\t\t\t\t  enum gt_types_enum);\n \n /* Return the total size of the data to be written to hold all\n    the objects previously passed to ggc_pch_count_object.  */\n@@ -183,8 +185,9 @@ extern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n \n /* Assuming that the objects really do end up at the address\n    passed to ggc_pch_this_base, return the address of this object.\n-   The last argument should be true if the object is a string.  */\n-extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool);\n+   The bool argument should be true if the object is a string.  */\n+extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool,\n+\t\t\t\t   enum gt_types_enum);\n \n /* Write out any initial information required.  */\n extern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);\n@@ -203,30 +206,18 @@ extern void ggc_pch_read (FILE *, void *);\n \f\n /* Allocation.  */\n \n-/* For single pass garbage.  */\n-extern struct alloc_zone *garbage_zone;\n-/* For regular rtl allocations.  */\n-extern struct alloc_zone *rtl_zone;\n-/* For regular tree allocations.  */\n-extern struct alloc_zone *tree_zone;\n /* When set, ggc_collect will do collection.  */\n extern bool ggc_force_collect;\n \n /* The internal primitive.  */\n extern void *ggc_alloc_stat (size_t MEM_STAT_DECL);\n #define ggc_alloc(s) ggc_alloc_stat (s MEM_STAT_INFO)\n-/* Allocate an object into the specified allocation zone.  */\n-extern void *ggc_alloc_zone_stat (size_t, struct alloc_zone * MEM_STAT_DECL);\n-#define ggc_alloc_zone(s,z) ggc_alloc_zone_stat (s,z MEM_STAT_INFO)\n /* Allocate an object of the specified type and size.  */\n extern void *ggc_alloc_typed_stat (enum gt_types_enum, size_t MEM_STAT_DECL);\n #define ggc_alloc_typed(s,z) ggc_alloc_typed_stat (s,z MEM_STAT_INFO)\n /* Like ggc_alloc, but allocates cleared memory.  */\n extern void *ggc_alloc_cleared_stat (size_t MEM_STAT_DECL);\n #define ggc_alloc_cleared(s) ggc_alloc_cleared_stat (s MEM_STAT_INFO)\n-/* Like ggc_alloc_zone, but allocates cleared memory.  */\n-extern void *ggc_alloc_cleared_zone (size_t, struct alloc_zone * MEM_STAT_DECL);\n-#define ggc_alloc_cleared_zone(s,z) ggc_alloc_cleared_stat (s,z MEM_STAT_INFO)\n /* Resize a block.  */\n extern void *ggc_realloc_stat (void *, size_t MEM_STAT_DECL);\n #define ggc_realloc(s,z) ggc_realloc_stat (s,z MEM_STAT_INFO)\n@@ -249,11 +240,11 @@ extern void dump_ggc_loc_statistics (void);\n #define GGC_NEWVAR(T, S)\t((T *) ggc_alloc ((S)))\n #define GGC_CNEWVAR(T, S)\t((T *) ggc_alloc_cleared ((S)))\n \n-#define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t  \\\n-  ((rtvec) ggc_alloc_typed (gt_ggc_e_9rtvec_def, sizeof (struct rtvec_def) \\\n-\t\t      + ((NELT) - 1) * sizeof (rtx)))\n+#define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t \\\n+  ((rtvec) ggc_alloc_zone (sizeof (struct rtvec_def) + ((NELT) - 1)\t \\\n+\t\t\t   * sizeof (rtx), &rtl_zone))\n \n-#define ggc_alloc_tree(LENGTH) ((tree) ggc_alloc_zone (LENGTH, tree_zone))\n+#define ggc_alloc_tree(LENGTH) ((tree) ggc_alloc_zone (LENGTH, &tree_zone))\n \n #define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n   htab_create_alloc (SIZE, HASH, EQ, DEL, ggc_calloc, NULL)\n@@ -309,4 +300,29 @@ extern int ggc_min_expand_heuristic (void);\n extern int ggc_min_heapsize_heuristic (void);\n extern void init_ggc_heuristics (void);\n \n+/* Zone collection.  */\n+#if defined (GGC_ZONE) && !defined (GENERATOR_FILE)\n+\n+/* For regular rtl allocations.  */\n+extern struct alloc_zone rtl_zone;\n+/* For regular tree allocations.  */\n+extern struct alloc_zone tree_zone;\n+/* For IDENTIFIER_NODE allocations.  */\n+extern struct alloc_zone tree_id_zone;\n+\n+/* Allocate an object into the specified allocation zone.  */\n+extern void *ggc_alloc_zone_stat (size_t, struct alloc_zone * MEM_STAT_DECL);\n+# define ggc_alloc_zone(s,z) ggc_alloc_zone_stat (s,z MEM_STAT_INFO)\n+\n+#else\n+\n+# define ggc_alloc_zone(s, z) ggc_alloc (s)\n+# ifdef GATHER_STATISTICS\n+#  define ggc_alloc_zone_stat(s, z, n, l, f) ggc_alloc_stat (s, n, l, f)\n+# else\n+#  define ggc_alloc_zone_stat(s, z) ggc_alloc_stat (s)\n+# endif\n+\n+#endif\n+\n #endif"}, {"sha": "3cd5bca0f558c48b4e671c33a4be0c761201a9a6", "filename": "gcc/rtl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -174,8 +174,7 @@ rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n {\n   rtx rt;\n \n-  rt = (rtx) ggc_alloc_typed_stat (gt_ggc_e_7rtx_def,\n-\t\t\t\t   RTX_SIZE (code) PASS_MEM_STAT);\n+  rt = (rtx) ggc_alloc_zone_stat (RTX_SIZE (code), &rtl_zone PASS_MEM_STAT);\n \n   /* We want to clear everything up to the FLD array.  Normally, this\n      is one int, but we don't want to assume that and it isn't very\n@@ -309,8 +308,8 @@ shallow_copy_rtx_stat (rtx orig MEM_STAT_DECL)\n {\n   rtx copy;\n \n-  copy = (rtx) ggc_alloc_typed_stat (gt_ggc_e_7rtx_def,\n-\t\t\t\t     RTX_SIZE (GET_CODE (orig)) PASS_MEM_STAT);\n+  copy = (rtx) ggc_alloc_zone_stat (RTX_SIZE (GET_CODE (orig)),\n+\t\t\t\t    &rtl_zone PASS_MEM_STAT);\n   memcpy (copy, orig, RTX_SIZE (GET_CODE (orig)));\n   return copy;\n }"}, {"sha": "6a24d53412324c7d3cd7d434b072f2c1676452e0", "filename": "gcc/stringpool.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -197,7 +197,8 @@ gt_pch_p_S (void *obj ATTRIBUTE_UNUSED, void *x ATTRIBUTE_UNUSED,\n void\n gt_pch_n_S (const void *x)\n {\n-  gt_pch_note_object ((void *)x, (void *)x, &gt_pch_p_S);\n+  gt_pch_note_object ((void *)x, (void *)x, &gt_pch_p_S,\n+\t\t      gt_types_enum_last);\n }\n \f\n /* Handle saving and restoring the string pool for PCH.  */"}, {"sha": "815ef7505fcb2fbca0eda55d7d7c12a8b612835e", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08cee789cdb1b64a6e07a0745489b26f6ddd0720/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=08cee789cdb1b64a6e07a0745489b26f6ddd0720", "patch": "@@ -341,7 +341,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n   tree_node_sizes[(int) kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n+  if (code == IDENTIFIER_NODE)\n+    t = ggc_alloc_zone_stat (length, &tree_id_zone PASS_MEM_STAT);\n+  else\n+    t = ggc_alloc_zone_stat (length, &tree_zone PASS_MEM_STAT);\n \n   memset (t, 0, length);\n \n@@ -425,7 +428,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   gcc_assert (code != STATEMENT_LIST);\n \n   length = tree_size (node);\n-  t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n+  t = ggc_alloc_zone_stat (length, &tree_zone PASS_MEM_STAT);\n   memcpy (t, node, length);\n \n   TREE_CHAIN (t) = 0;\n@@ -910,7 +913,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   tree_node_sizes[(int) binfo_kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n+  t = ggc_alloc_zone_stat (length, &tree_zone PASS_MEM_STAT);\n \n   memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n@@ -935,7 +938,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n   tree_node_sizes[(int) vec_kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n+  t = ggc_alloc_zone_stat (length, &tree_zone PASS_MEM_STAT);\n \n   memset (t, 0, length);\n \n@@ -1408,7 +1411,7 @@ tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n   tree node;\n \n   node = ggc_alloc_zone_stat (sizeof (struct tree_list),\n-\t\t\t      tree_zone PASS_MEM_STAT);\n+\t\t\t      &tree_zone PASS_MEM_STAT);\n \n   memset (node, 0, sizeof (struct tree_common));\n \n@@ -2502,7 +2505,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n-  t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n+  t = ggc_alloc_zone_stat (length, &tree_zone PASS_MEM_STAT);\n \n   memset (t, 0, sizeof (struct tree_common));\n "}]}