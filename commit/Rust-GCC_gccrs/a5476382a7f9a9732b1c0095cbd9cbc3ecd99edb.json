{"sha": "a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU0NzYzODJhN2Y5YTk3MzJiMWMwMDk1Y2JkOWNiYzNlY2Q5OWVkYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-08-07T13:41:06Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-21T07:22:49Z"}, "message": "[Ada] Basic support for 128-bit types\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_128BIT_PAIRS): New variable.\n\t(GNATRTL_128BIT_OBJS): Likewise.\n\t(Windows): In 64-bit mode, add the former to LIBGNAT_TARGET_PAIRS and\n\tthe latter to EXTRA_GNATRTL_NONTASKING_OBJS.\n\t(x86_64/linux): Likewise, but unconditionally.\n\t(GNATRTL_NONTASKING_OBJS): Add s-aridou, s-exponn, s-expont,\n\ts-exponu.\n\t* ada_get_targ.adb (Get_Long_Long_Long_Size): New function.\n\t* checks.adb (Apply_Arithmetic_Overflow_Strict): Use Integer_Type_For\n\tto find an appropriate integer type; if it does not exist and the max\n\tinteger size is larger than 64, use the 128-bit arithmetic routines.\n\t* cstand.adb (Create_Standard): Build Standard_Long_Long_Long_Integer\n\tand its base type.  Use it for Etype of Any_Integer, Any_Modular and\n\tAny_Numeric.  Use its size for Build Standard_Long_Long_Long_Unsigned\n\tand Universal_Integer.\n\t(Print_Standard): Print Long_Long_Long_Integer.\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_Mod>: Adjust\n\tcomment.\n\t* exp_ch3.adb (Simple_Init_Initialize_Scalars_Type): Deal with 128-bit\n\ttypes.\n\t* exp_ch4.adb (Expand_Array_Comparison): Likewise.\n\t(Expand_N_Op_Expon): Likewise.\n\t(Narrow_Large_Operation): Likewise.\n\t* exp_dbug.adb (Bounds_Match_Size): Handle 128-bit size.\n\t* exp_fixd.adb (Build_Double_Divide_Code): Use RE_Double_Divide64.\n\t* exp_intr.adb (Expand_Binary_Operator_Call): Handle 128-bit size.\n\t* exp_pakd.ads (E_Array): Extend range to 127.\n\t(Bits_Id): Fill in up to 127.\n\t(Get_Id): Likewise.\n\t(GetU_Id): Likewise.\n\t(Set_Id): Likewise.\n\t(SetU_Id): Likewise.\n\t* exp_pakd.adb (Revert_Storage_Order): Handle 128-bit size.\n\t* exp_util.adb (Integer_Type_For): Likewise.\n\t(Small_Integer_Type_For): Likewise.\n\t* fname.adb (Is_Predefined_File_Name): Do not return False for names\n\tlarger than 12 characters if they start with \"s-\".\n\t* freeze.adb (Adjust_Esize_For_Alignment): Change the maximum value\n\tto System_Max_Integer_Size.\n\t(Check_Suspicious_Modulus): Adjust comment.\n\t(Freeze_Entity): Likewise.\n\t* get_targ.ads (Get_Long_Long_Long_Size): New function.\n\t* get_targ.adb (Get_Long_Long_Long_Size): Likewise.\n\t(Width_From_Size): Deal with 128-bit size.\n\t* gnat1drv.adb (Adjust_Global_Switches): Deal with 128-bit types.\n\t* impunit.adb (Get_Kind_Of_File): Bump buffer size.  Accept files with\n\t13 characters if they start with 's'.  Compare slice of Buffer.\n\t(Not_Impl_Defined_Unit): Accept files with 13 characters if they start\n\twith 's'.\n\t* krunch.ads: Document length for 128-bit support units.\n\t* krunch.adb (Krunch): Set length to 9 for 128-bit support units.\n\t* layout.adb (Layout_Type): Use System_Max_Integer_Size as alignment\n\tlimit.\n\t* rtsfind.ads (RTU_Id): Add System_Arith_128,\n\tSystem_Compare_Array_Signed_128, System_Compare_Array_Unsigned_128,\n\tSystem_Exn_LLLI, System_Exp_LLLU, System_Pack_[65..127].\n\t(RE_Id): Add RE_Integer_128, RE_Unsigned_128, RE_Add_With_Ovflo_Check128\n\tRE_Multiply_With_Ovflo_Check128, RE_Subtract_With_Ovflo_Check128,\n\tRE_Bswap_128, RE_Compare_Array_S128, RE_Compare_Array_U128,\n\tRE_Exn_Long_Long_Long_Integer, RE_Exp_Long_Long_Long_Integer,\n\tRE_Exp_Long_Long_Long_Unsigned, RE_Bits_[65-127], RE_Get_[65-127],\n\tRE_Set_[65-127], RE_IS_Is16, RE_IS_Iu16, RE_Integer_128 and\n\tRE_Unsigned_128.  Rename RE_Add_With_Ovflo_Check, RE_Double_Divide,\n\tRE_Multiply_With_Ovflo_Check, RE_Scaled_Divide and\n\tRE_Subtract_With_Ovflo_Check.  Remove RE_IS_Iz1, RE_IS_Iz2, RE_IS_Iz4,\n\tRE_IS_Iz8, RE_Long_Unsigned, RE_Short_Unsigned, RE_Short_Short_Unsigned\n\t(RE_Unit_Table): Likewise.\n\t* sem_aux.adb (Corresponding_Unsigned_Type): Deal with a size equal to\n\tthat of Standard_Long_Long_Long_Integer.\n\t(First_Subtype): Deal with Standard_Long_Long_Long_Integer'Base.\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause) <Attribute_Size>:\n\tCheck the size against powers of 2 and System_Max_Integer_Size for\n\tobjects as well.\n\t(Set_Enum_Esize): Deal with 128-bit bounds.\n\t* sem_ch3.adb (Set_Modular_Size): Handle 128-bit size.\n\t(Modular_Type_Declaration): Deal with 128-bit types.\n\t(Signed_Integer_Type_Declaration): Support derivation from\n\tStandard_Long_Long_Long_Integer.\n\t* sem_ch4.adb (Analyze_Mod): Handle 128-bit modulus.\n\t* sem_intr.adb: Add with and use clauses for Ttypes.\n\t(Check_Shift): Handle 128-bit size and modulus.\n\t* sem_prag.adb (Analyze_Pragma) <Pragma_Initialize_Scalars>: Deal\n\twith Signed_128 and Unsigned_128.\n\t(Analyze_Integer_Value): Handle 128-bit size.\n\t* sem_util.ads (Addressable): Adjust description.\n\t* sem_util.adb (Addressable): Return true for 128 if the system\n\tsupports 128 bits.\n\t(Set_Invalid_Binder_Values): Deal with Signed_128 and Unsigned_128.\n\t* set_targ.ads (Long_Long_Long_Size): New variable.\n\t* set_targ.adb (S_Long_Long_Long_Size): New constant.\n\t(DTN): Add entry for S_Long_Long_Long_Size.\n\t(DTV): Add entry for Long_Long_Long_Size.\n\t(Set_Targ): Set Long_Long_Long_Size.\n\t* snames.ads-tmpl (Name_Max_Integer_Size): New attribute name.\n\t(Name_Signed_128): New scalar name.\n\t(Name_Unsigned_128): Likewise.\n\t(Scalar_Id): Adjust.\n\t(Integer_Scalar_Id): Likewise.\n\t(Attribute_Id): Add Attribute_Max_Integer_Size.\n\t* stand.ads (Standard_Entity_Type): Add S_Long_Long_Long_Integer.\n\t(Standard_Long_Long_Long_Integer): New renaming.\n\t(Universal_Integer): Adjust description.\n\t(Standard_Long_Long_Long_Unsigned): New variable.\n\t* switch-c.adb (Scan_Front_End_Switches): Deal with -gnate128.\n\t* ttypes.ads (Standard_Long_Long_Long_Integer_Size): New variable.\n\t(Standard_Long_Long_Long_Integer_Width): Likewise.\n\t(System_Max_Integer_Size): Turn into variable.\n\t(System_Max_Binary_Modulus_Power): Likewise.\n\t* uintp.ads (Uint_127): New constant.\n\t* uintp.adb (UI_Power_2): Extednd to 128.\n\t(UI_Power_10): Likewise.\n\t(UI_Expon): Deal with exponent up to 128 specially.\n\t* usage.adb (Write_Switch_Char): Print -gnate128 switch.\n\t* libgnat/a-tifiio.adb (Put_Scaled): Call Scaled_Divide64.\n\t* libgnat/interfac__2020.ads (Integer_128): New integer type.\n\t(Unsigned_128): New modular type.\n\t(Shift_Left, Shift_Right, Shift_Right_Arithmetic, Rotate_Left,\n\tRotate_Right): New intrinsic functions operating on it.\n\t* libgnat/s-aridou.ads, libgnat/s-aridou.adb: New generic\n\tpackage.\n\t* libgnat/s-arit64.ads, libgnat/s-arit64.adb: Instantiate\n\tSystem.Arithmetic_Double.\n\t* libgnat/s-arit128.ads, libgnat/s-arit128.adb: Likewise.\n\t* libgnat/s-bytswa.ads: Add with clause for Interfaces, use subtypes\n\tof unsigned types defined in Interfaces and add Bswap_128.\n\t* libgnat/s-casi128.ads, libgnat/s-casi128.adb: New package.\n\t* libgnat/s-caun128.ads, libgnat/s-caun128.adb: Likewise.\n\t* libgnat/s-exnint.ads: Instantiate System.Exponn.\n\t* libgnat/s-exnint.adb: Add pragma No_Body.\n\t* libgnat/s-exnlli.ads: Instantiate System.Exponn.\n\t* libgnat/s-exnlli.adb: Add pragma No_Body.\n\t* libgnat/s-exnllli.ads: Instantiate System.Exponn.\n\t* libgnat/s-expint.ads: Likewise.\n\t* libgnat/s-expint.adb: Add pragma No_Body.\n\t* libgnat/s-explli.ads: Instantiate System.Exponn.\n\t* libgnat/s-explli.adb: Add pragma No_Body.\n\t* libgnat/s-expllli.ads: Instantiate System.Exponn.\n\t* libgnat/s-explllu.ads: Instantiate System.Exponu.\n\t* libgnat/s-expllu.ads: Likewise.\n\t* libgnat/s-expllu.adb: Add pragma No_Body.\n\t* libgnat/s-exponn.ads, libgnat/s-exponn.adb: New generic\n\tfunction.\n\t* libgnat/s-expont.ads, libgnat/s-expont.adb: Likewise.\n\t* libgnat/s-exponu.ads, libgnat/s-exponu.adb: Likewise.\n\t* libgnat/s-expuns.ads, libgnat/s-expuns.adb: Likewise.\n\t* libgnat/s-pack65.ads, libgnat/s-pack65.adb: New package.\n\t* libgnat/s-pack66.ads, libgnat/s-pack66.adb: New package.\n\t* libgnat/s-pack67.ads, libgnat/s-pack67.adb: New package.\n\t* libgnat/s-pack68.ads, libgnat/s-pack68.adb: New package.\n\t* libgnat/s-pack69.ads, libgnat/s-pack69.adb: New package.\n\t* libgnat/s-pack70.ads, libgnat/s-pack70.adb: New package.\n\t* libgnat/s-pack71.ads, libgnat/s-pack71.adb: New package.\n\t* libgnat/s-pack72.ads, libgnat/s-pack72.adb: New package.\n\t* libgnat/s-pack73.ads, libgnat/s-pack73.adb: New package.\n\t* libgnat/s-pack74.ads, libgnat/s-pack74.adb: New package.\n\t* libgnat/s-pack75.ads, libgnat/s-pack75.adb: New package.\n\t* libgnat/s-pack76.ads, libgnat/s-pack76.adb: New package.\n\t* libgnat/s-pack77.ads, libgnat/s-pack77.adb: New package.\n\t* libgnat/s-pack78.ads, libgnat/s-pack78.adb: New package.\n\t* libgnat/s-pack79.ads, libgnat/s-pack79.adb: New package.\n\t* libgnat/s-pack80.ads, libgnat/s-pack80.adb: New package.\n\t* libgnat/s-pack81.ads, libgnat/s-pack81.adb: New package.\n\t* libgnat/s-pack82.ads, libgnat/s-pack82.adb: New package.\n\t* libgnat/s-pack83.ads, libgnat/s-pack83.adb: New package.\n\t* libgnat/s-pack84.ads, libgnat/s-pack84.adb: New package.\n\t* libgnat/s-pack85.ads, libgnat/s-pack85.adb: New package.\n\t* libgnat/s-pack86.ads, libgnat/s-pack86.adb: New package.\n\t* libgnat/s-pack87.ads, libgnat/s-pack87.adb: New package.\n\t* libgnat/s-pack88.ads, libgnat/s-pack88.adb: New package.\n\t* libgnat/s-pack89.ads, libgnat/s-pack89.adb: New package.\n\t* libgnat/s-pack90.ads, libgnat/s-pack90.adb: New package.\n\t* libgnat/s-pack91.ads, libgnat/s-pack91.adb: New package.\n\t* libgnat/s-pack92.ads, libgnat/s-pack92.adb: New package.\n\t* libgnat/s-pack93.ads, libgnat/s-pack93.adb: New package.\n\t* libgnat/s-pack94.ads, libgnat/s-pack94.adb: New package.\n\t* libgnat/s-pack95.ads, libgnat/s-pack95.adb: New package.\n\t* libgnat/s-pack96.ads, libgnat/s-pack96.adb: New package.\n\t* libgnat/s-pack97.ads, libgnat/s-pack97.adb: New package.\n\t* libgnat/s-pack98.ads, libgnat/s-pack98.adb: New package.\n\t* libgnat/s-pack99.ads, libgnat/s-pack99.adb: New package.\n\t* libgnat/s-pack100.ads, libgnat/s-pack100.adb: New package.\n\t* libgnat/s-pack101.ads, libgnat/s-pack101.adb: New package.\n\t* libgnat/s-pack102.ads, libgnat/s-pack102.adb: New package.\n\t* libgnat/s-pack103.ads, libgnat/s-pack103.adb: New package.\n\t* libgnat/s-pack104.ads, libgnat/s-pack104.adb: New package.\n\t* libgnat/s-pack105.ads, libgnat/s-pack105.adb: New package.\n\t* libgnat/s-pack106.ads, libgnat/s-pack106.adb: New package.\n\t* libgnat/s-pack107.ads, libgnat/s-pack107.adb: New package.\n\t* libgnat/s-pack108.ads, libgnat/s-pack108.adb: New package.\n\t* libgnat/s-pack109.ads, libgnat/s-pack109.adb: New package.\n\t* libgnat/s-pack110.ads, libgnat/s-pack110.adb: New package.\n\t* libgnat/s-pack111.ads, libgnat/s-pack111.adb: New package.\n\t* libgnat/s-pack112.ads, libgnat/s-pack112.adb: New package.\n\t* libgnat/s-pack113.ads, libgnat/s-pack113.adb: New package.\n\t* libgnat/s-pack114.ads, libgnat/s-pack114.adb: New package.\n\t* libgnat/s-pack115.ads, libgnat/s-pack115.adb: New package.\n\t* libgnat/s-pack116.ads, libgnat/s-pack116.adb: New package.\n\t* libgnat/s-pack117.ads, libgnat/s-pack117.adb: New package.\n\t* libgnat/s-pack118.ads, libgnat/s-pack118.adb: New package.\n\t* libgnat/s-pack119.ads, libgnat/s-pack119.adb: New package.\n\t* libgnat/s-pack120.ads, libgnat/s-pack120.adb: New package.\n\t* libgnat/s-pack121.ads, libgnat/s-pack121.adb: New package.\n\t* libgnat/s-pack122.ads, libgnat/s-pack122.adb: New package.\n\t* libgnat/s-pack123.ads, libgnat/s-pack123.adb: New package.\n\t* libgnat/s-pack124.ads, libgnat/s-pack124.adb: New package.\n\t* libgnat/s-pack125.ads, libgnat/s-pack125.adb: New package.\n\t* libgnat/s-pack126.ads, libgnat/s-pack126.adb: New package.\n\t* libgnat/s-pack127.ads, libgnat/s-pack127.adb: New package.\n\t* libgnat/s-rannum.ads (Random): New function returning 128-bit.\n\t* libgnat/s-rannum.adb (Random): Implement it.\n\t* libgnat/s-scaval.ads: Add with clause for Interfaces, use subtypes\n\tof unsigned types defined in Interfaces.\n\t* libgnat/s-scaval.adb: Add use clause for Interfaces.\n\t* libgnat/s-scaval__128.ads, libgnat/s-scaval__128.adb: New\n\tpackage.\n\t* libgnat/s-unstyp.ads (Long_Long_Long_Unsigned): New modular type.\n\t(Shift_Left, Shift_Right, Shift_Right_Arithmetic, Rotate_Left,\n\tRotate_Right): New intrinsic functions operating on it.\n\ngcc/testsuite/\n\n\t* gnat.dg/multfixed.adb: Update expected exception message.", "tree": {"sha": "6d805d80a6ff2d321ce601626721119f0c96568d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d805d80a6ff2d321ce601626721119f0c96568d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6551e4cb27c82db40a6f7dc24f609423a0f6b49d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6551e4cb27c82db40a6f7dc24f609423a0f6b49d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6551e4cb27c82db40a6f7dc24f609423a0f6b49d"}], "stats": {"total": 22195, "additions": 21014, "deletions": 1181}, "files": [{"sha": "6437a4dd3aacbf9c83a1c2f3839dc96d224da5f7", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -518,6 +518,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-aoinar$(objext) \\\n   s-aomoar$(objext) \\\n   s-aotase$(objext) \\\n+  s-aridou$(objext) \\\n   s-arit64$(objext) \\\n   s-assert$(objext) \\\n   s-atacco$(objext) \\\n@@ -582,6 +583,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-explli$(objext) \\\n   s-expllu$(objext) \\\n   s-expmod$(objext) \\\n+  s-exponn$(objext) \\\n+  s-expont$(objext) \\\n+  s-exponu$(objext) \\\n   s-expuns$(objext) \\\n   s-fatflt$(objext) \\\n   s-fatgen$(objext) \\\n@@ -867,6 +871,82 @@ TRASYM_DWARF_UNIX_OBJS = $(TRASYM_DWARF_COMMON_OBJS) s-mmauni$(objext)\n \n TRASYM_DWARF_MINGW_OBJS = $(TRASYM_DWARF_COMMON_OBJS)\n \n+GNATRTL_128BIT_PAIRS = \\\n+  s-scaval.ads<libgnat/s-scaval__128.ads \\\n+  s-scaval.adb<libgnat/s-scaval__128.adb\n+\n+# Objects needed for 128-bit types\n+GNATRTL_128BIT_OBJS = \\\n+  s-arit128$(objext) \\\n+  s-casi128$(objext) \\\n+  s-caun128$(objext) \\\n+  s-exnllli$(objext) \\\n+  s-expllli$(objext) \\\n+  s-explllu$(objext) \\\n+  s-pack65$(objext)  \\\n+  s-pack66$(objext)  \\\n+  s-pack67$(objext)  \\\n+  s-pack68$(objext)  \\\n+  s-pack69$(objext)  \\\n+  s-pack70$(objext)  \\\n+  s-pack71$(objext)  \\\n+  s-pack72$(objext)  \\\n+  s-pack73$(objext)  \\\n+  s-pack74$(objext)  \\\n+  s-pack75$(objext)  \\\n+  s-pack76$(objext)  \\\n+  s-pack77$(objext)  \\\n+  s-pack78$(objext)  \\\n+  s-pack79$(objext)  \\\n+  s-pack80$(objext)  \\\n+  s-pack81$(objext)  \\\n+  s-pack82$(objext)  \\\n+  s-pack83$(objext)  \\\n+  s-pack84$(objext)  \\\n+  s-pack85$(objext)  \\\n+  s-pack86$(objext)  \\\n+  s-pack87$(objext)  \\\n+  s-pack88$(objext)  \\\n+  s-pack89$(objext)  \\\n+  s-pack90$(objext)  \\\n+  s-pack91$(objext)  \\\n+  s-pack92$(objext)  \\\n+  s-pack93$(objext)  \\\n+  s-pack94$(objext)  \\\n+  s-pack95$(objext)  \\\n+  s-pack96$(objext)  \\\n+  s-pack97$(objext)  \\\n+  s-pack98$(objext)  \\\n+  s-pack99$(objext)  \\\n+  s-pack100$(objext) \\\n+  s-pack101$(objext) \\\n+  s-pack102$(objext) \\\n+  s-pack103$(objext) \\\n+  s-pack104$(objext) \\\n+  s-pack105$(objext) \\\n+  s-pack106$(objext) \\\n+  s-pack107$(objext) \\\n+  s-pack108$(objext) \\\n+  s-pack109$(objext) \\\n+  s-pack110$(objext) \\\n+  s-pack111$(objext) \\\n+  s-pack112$(objext) \\\n+  s-pack113$(objext) \\\n+  s-pack114$(objext) \\\n+  s-pack115$(objext) \\\n+  s-pack116$(objext) \\\n+  s-pack117$(objext) \\\n+  s-pack118$(objext) \\\n+  s-pack119$(objext) \\\n+  s-pack120$(objext) \\\n+  s-pack121$(objext) \\\n+  s-pack122$(objext) \\\n+  s-pack123$(objext) \\\n+  s-pack124$(objext) \\\n+  s-pack125$(objext) \\\n+  s-pack126$(objext) \\\n+  s-pack127$(objext)\n+\n # Shared library version\n LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(GNAT_SRC)/gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n \n@@ -2023,12 +2103,14 @@ ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(target_os))),)\n       LIBGNAT_TARGET_PAIRS += $(X86_TARGET_PAIRS)\n       SO_OPTS= -m32 -Wl,-soname,\n     else\n-      LIBGNAT_TARGET_PAIRS += $(X86_64_TARGET_PAIRS)\n+      LIBGNAT_TARGET_PAIRS += $(X86_64_TARGET_PAIRS) $(GNATRTL_128BIT_PAIRS)\n+      EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n       SO_OPTS = -m64 -Wl,-soname,\n     endif\n   else\n     ifeq ($(strip $(MULTISUBDIR)),/64)\n-      LIBGNAT_TARGET_PAIRS += $(X86_64_TARGET_PAIRS)\n+      LIBGNAT_TARGET_PAIRS += $(X86_64_TARGET_PAIRS) $(GNATRTL_128BIT_PAIRS)\n+      EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n       SO_OPTS = -m64 -Wl,-soname,\n     else\n       LIBGNAT_TARGET_PAIRS += $(X86_TARGET_PAIRS)\n@@ -2420,12 +2502,14 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(target_cpu) $(target_os))),)\n   s-tsmona.adb<libgnat/s-tsmona__linux.adb \\\n   $(ATOMICS_TARGET_PAIRS) \\\n   $(X86_64_TARGET_PAIRS) \\\n+  $(GNATRTL_128BIT_PAIRS) \\\n   system.ads<libgnat/system-linux-x86.ads\n \n   TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb\n \n   EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o\n   EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)\n+  EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o a-exetim.o\n \n   EH_MECHANISM=-gcc"}, {"sha": "ddaca1a70b029c5c75423b616f4916d068f7c9e8", "filename": "gcc/ada/ada_get_targ.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fada_get_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fada_get_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada_get_targ.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -100,6 +100,15 @@ package body Get_Targ is\n       return 64;\n    end Get_Long_Long_Size;\n \n+   -----------------------------\n+   -- Get_Long_Long_Long_Size --\n+   -----------------------------\n+\n+   function Get_Long_Long_Long_Size return Pos is\n+   begin\n+      return 64;\n+   end Get_Long_Long_Long_Size;\n+\n    ----------------------\n    -- Get_Pointer_Size --\n    ----------------------"}, {"sha": "b7c6110be420174ee719eb1936012af772e7688f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -1013,8 +1013,7 @@ package body Checks is\n       --  Now see if an overflow check is required\n \n       declare\n-         Siz   : constant Int := UI_To_Int (Esize (Rtyp));\n-         Dsiz  : constant Int := Siz * 2;\n+         Dsiz  : constant Uint := 2 * Esize (Rtyp);\n          Opnod : Node_Id;\n          Ctyp  : Entity_Id;\n          Opnd  : Node_Id;\n@@ -1050,42 +1049,56 @@ package body Checks is\n          --  an integer type of sufficient length to hold the largest possible\n          --  result.\n \n-         --  If the size of check type exceeds the size of Long_Long_Integer,\n+         --  If the size of the check type exceeds the maximum integer size,\n          --  we use a different approach, expanding to:\n \n-         --    typ (xxx_With_Ovflo_Check (Integer_64 (x), Integer (y)))\n+         --    typ (xxx_With_Ovflo_Check (Integer_NN (x), Integer_NN (y)))\n \n          --  where xxx is Add, Multiply or Subtract as appropriate\n \n          --  Find check type if one exists\n \n-         if Dsiz <= Standard_Integer_Size then\n-            Ctyp := Standard_Integer;\n-\n-         elsif Dsiz <= Standard_Long_Long_Integer_Size then\n-            Ctyp := Standard_Long_Long_Integer;\n+         if Dsiz <= System_Max_Integer_Size then\n+            Ctyp := Integer_Type_For (Dsiz, Uns => False);\n \n          --  No check type exists, use runtime call\n \n          else\n+            if System_Max_Integer_Size = 64 then\n+               Ctyp := RTE (RE_Integer_64);\n+            else\n+               Ctyp := RTE (RE_Integer_128);\n+            end if;\n+\n             if Nkind (N) = N_Op_Add then\n-               Cent := RE_Add_With_Ovflo_Check;\n+               if System_Max_Integer_Size = 64 then\n+                  Cent := RE_Add_With_Ovflo_Check64;\n+               else\n+                  Cent := RE_Add_With_Ovflo_Check128;\n+               end if;\n \n-            elsif Nkind (N) = N_Op_Multiply then\n-               Cent := RE_Multiply_With_Ovflo_Check;\n+            elsif Nkind (N) = N_Op_Subtract then\n+               if System_Max_Integer_Size = 64 then\n+                  Cent := RE_Subtract_With_Ovflo_Check64;\n+               else\n+                  Cent := RE_Subtract_With_Ovflo_Check128;\n+               end if;\n \n-            else\n-               pragma Assert (Nkind (N) = N_Op_Subtract);\n-               Cent := RE_Subtract_With_Ovflo_Check;\n+            else pragma Assert (Nkind (N) = N_Op_Multiply);\n+               if System_Max_Integer_Size = 64 then\n+                  Cent := RE_Multiply_With_Ovflo_Check64;\n+               else\n+                  Cent := RE_Multiply_With_Ovflo_Check128;\n+               end if;\n             end if;\n \n             Rewrite (N,\n               OK_Convert_To (Typ,\n                 Make_Function_Call (Loc,\n                   Name => New_Occurrence_Of (RTE (Cent), Loc),\n                   Parameter_Associations => New_List (\n-                    OK_Convert_To (RTE (RE_Integer_64), Left_Opnd  (N)),\n-                    OK_Convert_To (RTE (RE_Integer_64), Right_Opnd (N))))));\n+                    OK_Convert_To (Ctyp, Left_Opnd  (N)),\n+                    OK_Convert_To (Ctyp, Right_Opnd (N))))));\n \n             Analyze_And_Resolve (N, Typ);\n             return;"}, {"sha": "fa335c101b71862db1578cbfc607d29a31c7177e", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -719,6 +719,11 @@ package body CStand is\n         (Standard_Long_Long_Integer, Standard_Long_Long_Integer_Size);\n       Set_Is_Implementation_Defined (Standard_Long_Long_Integer);\n \n+      Build_Signed_Integer_Type\n+        (Standard_Long_Long_Long_Integer,\n+         Standard_Long_Long_Long_Integer_Size);\n+      Set_Is_Implementation_Defined (Standard_Long_Long_Long_Integer);\n+\n       Create_Unconstrained_Base_Type\n         (Standard_Short_Short_Integer, E_Signed_Integer_Subtype);\n \n@@ -734,6 +739,9 @@ package body CStand is\n       Create_Unconstrained_Base_Type\n         (Standard_Long_Long_Integer, E_Signed_Integer_Subtype);\n \n+      Create_Unconstrained_Base_Type\n+        (Standard_Long_Long_Long_Integer, E_Signed_Integer_Subtype);\n+\n       Create_Float_Types;\n \n       --  Create type definition node for type Character. Note that we do not\n@@ -1238,11 +1246,11 @@ package body CStand is\n       Set_Elem_Alignment    (Any_Fixed);\n \n       Any_Integer := New_Standard_Entity (\"an integer type\");\n-      Set_Ekind             (Any_Integer, E_Signed_Integer_Type);\n-      Set_Scope             (Any_Integer, Standard_Standard);\n-      Set_Etype             (Any_Integer, Standard_Long_Long_Integer);\n-      Init_Size             (Any_Integer, Standard_Long_Long_Integer_Size);\n-      Set_Elem_Alignment    (Any_Integer);\n+      Set_Ekind            (Any_Integer, E_Signed_Integer_Type);\n+      Set_Scope            (Any_Integer, Standard_Standard);\n+      Set_Etype            (Any_Integer, Standard_Long_Long_Long_Integer);\n+      Init_Size            (Any_Integer, Standard_Long_Long_Long_Integer_Size);\n+      Set_Elem_Alignment   (Any_Integer);\n \n       Set_Integer_Bounds\n         (Any_Integer,\n@@ -1251,19 +1259,19 @@ package body CStand is\n          Hb  => Intval (High_Bound (Scalar_Range (Standard_Integer))));\n \n       Any_Modular := New_Standard_Entity (\"a modular type\");\n-      Set_Ekind             (Any_Modular, E_Modular_Integer_Type);\n-      Set_Scope             (Any_Modular, Standard_Standard);\n-      Set_Etype             (Any_Modular, Standard_Long_Long_Integer);\n-      Init_Size             (Any_Modular, Standard_Long_Long_Integer_Size);\n-      Set_Elem_Alignment    (Any_Modular);\n-      Set_Is_Unsigned_Type  (Any_Modular);\n+      Set_Ekind            (Any_Modular, E_Modular_Integer_Type);\n+      Set_Scope            (Any_Modular, Standard_Standard);\n+      Set_Etype            (Any_Modular, Standard_Long_Long_Long_Integer);\n+      Init_Size            (Any_Modular, Standard_Long_Long_Long_Integer_Size);\n+      Set_Elem_Alignment   (Any_Modular);\n+      Set_Is_Unsigned_Type (Any_Modular);\n \n       Any_Numeric := New_Standard_Entity (\"a numeric type\");\n-      Set_Ekind             (Any_Numeric, E_Signed_Integer_Type);\n-      Set_Scope             (Any_Numeric, Standard_Standard);\n-      Set_Etype             (Any_Numeric, Standard_Long_Long_Integer);\n-      Init_Size             (Any_Numeric, Standard_Long_Long_Integer_Size);\n-      Set_Elem_Alignment    (Any_Numeric);\n+      Set_Ekind            (Any_Numeric, E_Signed_Integer_Type);\n+      Set_Scope            (Any_Numeric, Standard_Standard);\n+      Set_Etype            (Any_Numeric, Standard_Long_Long_Long_Integer);\n+      Init_Size            (Any_Numeric, Standard_Long_Long_Long_Integer_Size);\n+      Set_Elem_Alignment   (Any_Numeric);\n \n       Any_Real := New_Standard_Entity (\"a real type\");\n       Set_Ekind             (Any_Real, E_Floating_Point_Type);\n@@ -1339,11 +1347,17 @@ package body CStand is\n       Build_Unsigned_Integer_Type\n         (Standard_Long_Unsigned, Standard_Long_Integer_Size);\n \n-      Standard_Long_Long_Unsigned\n-        := New_Standard_Entity (\"long_long_unsigned\");\n+      Standard_Long_Long_Unsigned :=\n+        New_Standard_Entity (\"long_long_unsigned\");\n       Build_Unsigned_Integer_Type\n         (Standard_Long_Long_Unsigned, Standard_Long_Long_Integer_Size);\n \n+      Standard_Long_Long_Long_Unsigned :=\n+        New_Standard_Entity (\"long_long_long_unsigned\");\n+      Build_Unsigned_Integer_Type\n+        (Standard_Long_Long_Long_Unsigned,\n+         Standard_Long_Long_Long_Integer_Size);\n+\n       --  Standard_Unsigned_64 is not user visible, but is used internally. It\n       --  is an unsigned type mod 2**64 with 64 bits size.\n \n@@ -1358,16 +1372,16 @@ package body CStand is\n \n       --  Note: universal integer and universal real are constructed as fully\n       --  formed signed numeric types, with parameters corresponding to the\n-      --  longest runtime types (Long_Long_Integer and Long_Long_Float). This\n-      --  allows Gigi to properly process references to universal types that\n-      --  are not folded at compile time.\n+      --  longest runtime types (Long_Long_Long_Integer and Long_Long_Float).\n+      --  This allows Gigi to properly process references to universal types\n+      --  that are not folded at compile time.\n \n       Universal_Integer := New_Standard_Entity (\"universal_integer\");\n       Decl := New_Node (N_Full_Type_Declaration, Stloc);\n       Set_Defining_Identifier (Decl, Universal_Integer);\n       Set_Scope (Universal_Integer, Standard_Standard);\n       Build_Signed_Integer_Type\n-        (Universal_Integer, Standard_Long_Long_Integer_Size);\n+        (Universal_Integer, Standard_Long_Long_Long_Integer_Size);\n \n       Universal_Real := New_Standard_Entity (\"universal_real\");\n       Decl := New_Node (N_Full_Type_Declaration, Stloc);\n@@ -1955,6 +1969,13 @@ package body CStand is\n       P (\";\");\n       Write_Eol;\n \n+      Write_Str (\"   type Long_Long_Long_Integer\");\n+      P_Int_Range (Standard_Long_Long_Long_Integer_Size);\n+      Write_Str (\"   for Long_Long_Long_Integer'Size use \");\n+      Write_Int (Standard_Long_Long_Long_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n       --  Floating point types\n \n       P_Float_Type (Standard_Short_Float);"}, {"sha": "fdd4e05b84756b1bb3983caa90a0839d2649d15a", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -4586,7 +4586,7 @@ package body Exp_Attr is\n          --    b) The integer value is negative. In this case, we know that the\n          --    result is modulus + value, where the value might be as small as\n          --    -modulus. The trouble is what type do we use to do the subtract.\n-         --    No type will do, since modulus can be as big as 2**64, and no\n+         --    No type will do, since modulus can be as big as 2**128, and no\n          --    integer type accommodates this value. Let's do bit of algebra\n \n          --         modulus + value"}, {"sha": "3e677e6d5a5d3ad15bed8dd3211bd0487d92d93e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -8565,8 +8565,10 @@ package body Exp_Ch3 is\n                Scal_Typ := Name_Unsigned_16;\n             elsif Size_To_Use <= 32 then\n                Scal_Typ := Name_Unsigned_32;\n-            else\n+            elsif Size_To_Use <= 64 then\n                Scal_Typ := Name_Unsigned_64;\n+            else\n+               Scal_Typ := Name_Unsigned_128;\n             end if;\n \n          --  Signed types\n@@ -8578,8 +8580,10 @@ package body Exp_Ch3 is\n                Scal_Typ := Name_Signed_16;\n             elsif Size_To_Use <= 32 then\n                Scal_Typ := Name_Signed_32;\n-            else\n+            elsif Size_To_Use <= 64 then\n                Scal_Typ := Name_Signed_64;\n+            else\n+               Scal_Typ := Name_Signed_128;\n             end if;\n          end if;\n \n@@ -8633,10 +8637,10 @@ package body Exp_Ch3 is\n          then\n             Expr := Make_Integer_Literal (Loc, 2 ** Size_To_Use - 1);\n \n-            --  Resolve as Long_Long_Unsigned, because the largest number\n+            --  Resolve as Long_Long_Long_Unsigned, because the largest number\n             --  we can generate is out of range of universal integer.\n \n-            Analyze_And_Resolve (Expr, Standard_Long_Long_Unsigned);\n+            Analyze_And_Resolve (Expr, Standard_Long_Long_Long_Unsigned);\n \n          --  Case of signed types\n \n@@ -8724,7 +8728,7 @@ package body Exp_Ch3 is\n          end if;\n \n          --  The maximum size to use is System_Max_Integer_Size bits. This\n-         --  will create values of type Long_Long_Unsigned and the range\n+         --  will create values of type Long_Long_Long_Unsigned and the range\n          --  must fit this type.\n \n          if Size_To_Use /= No_Uint"}, {"sha": "5af4c4cd871bfbbe3c7ef4e2feb306b6c05fc77c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -1385,7 +1385,7 @@ package body Exp_Ch4 is\n          --    (left'address, right'address, left'length, right'length) <op> 0\n \n          --  x = U for unsigned, S for signed\n-         --  n = 8,16,32,64 for component size\n+         --  n = 8,16,32,64,128 for component size\n          --  Add _Unaligned if length < 4 and component size is 8.\n          --  <op> is the standard comparison operator\n \n@@ -1422,12 +1422,19 @@ package body Exp_Ch4 is\n                Comp := RE_Compare_Array_S32;\n             end if;\n \n-         else pragma Assert (Component_Size (Typ1) = 64);\n+         elsif Component_Size (Typ1) = 64 then\n             if Is_Unsigned_Type (Ctyp) then\n                Comp := RE_Compare_Array_U64;\n             else\n                Comp := RE_Compare_Array_S64;\n             end if;\n+\n+         else pragma Assert (Component_Size (Typ1) = 128);\n+            if Is_Unsigned_Type (Ctyp) then\n+               Comp := RE_Compare_Array_U128;\n+            else\n+               Comp := RE_Compare_Array_S128;\n+            end if;\n          end if;\n \n          if RTE_Available (Comp) then\n@@ -8992,15 +8999,18 @@ package body Exp_Ch4 is\n                     Make_Integer_Literal (Loc, Modulus (Rtyp)),\n                     Exp))));\n \n-         --  Binary modular case, in this case, we call one of two routines,\n+         --  Binary modular case, in this case, we call one of three routines,\n          --  either the unsigned integer case, or the unsigned long long\n-         --  integer case, with a final \"and\" operation to do the required mod.\n+         --  integer case, or the unsigned long long long integer case, with a\n+         --  final \"and\" operation to do the required mod.\n \n          else\n-            if UI_To_Int (Esize (Rtyp)) <= Standard_Integer_Size then\n+            if Esize (Rtyp) <= Standard_Integer_Size then\n                Ent := RTE (RE_Exp_Unsigned);\n-            else\n+            elsif Esize (Rtyp) <= Standard_Long_Long_Integer_Size then\n                Ent := RTE (RE_Exp_Long_Long_Unsigned);\n+            else\n+               Ent := RTE (RE_Exp_Long_Long_Long_Unsigned);\n             end if;\n \n             Rewrite (N,\n@@ -9022,36 +9032,43 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Typ);\n          return;\n \n-      --  Signed integer cases, done using either Integer or Long_Long_Integer.\n-      --  It is not worth having routines for Short_[Short_]Integer, since for\n-      --  most machines it would not help, and it would generate more code that\n-      --  might need certification when a certified run time is required.\n+      --  Signed integer cases, using either Integer, Long_Long_Integer or\n+      --  Long_Long_Long_Integer. It is not worth also having routines for\n+      --  Short_[Short_]Integer, since for most machines it would not help,\n+      --  and it would generate more code that might need certification when\n+      --  a certified run time is required.\n \n       --  In the integer cases, we have two routines, one for when overflow\n       --  checks are required, and one when they are not required, since there\n       --  is a real gain in omitting checks on many machines.\n \n-      elsif Rtyp = Base_Type (Standard_Long_Long_Integer)\n-        or else (Rtyp = Base_Type (Standard_Long_Integer)\n-                  and then\n-                    Esize (Standard_Long_Integer) > Esize (Standard_Integer))\n-        or else Rtyp = Universal_Integer\n-      then\n-         Etyp := Standard_Long_Long_Integer;\n+      elsif Is_Signed_Integer_Type (Rtyp) then\n+         if Esize (Rtyp) <= Standard_Integer_Size then\n+            Etyp := Standard_Integer;\n \n-         if Ovflo then\n-            Rent := RE_Exp_Long_Long_Integer;\n-         else\n-            Rent := RE_Exn_Long_Long_Integer;\n-         end if;\n+            if Ovflo then\n+               Rent := RE_Exp_Integer;\n+            else\n+               Rent := RE_Exn_Integer;\n+            end if;\n \n-      elsif Is_Signed_Integer_Type (Rtyp) then\n-         Etyp := Standard_Integer;\n+         elsif Esize (Rtyp) <= Standard_Long_Long_Integer_Size then\n+            Etyp := Standard_Long_Long_Integer;\n+\n+            if Ovflo then\n+               Rent := RE_Exp_Long_Long_Integer;\n+            else\n+               Rent := RE_Exn_Long_Long_Integer;\n+            end if;\n \n-         if Ovflo then\n-            Rent := RE_Exp_Integer;\n          else\n-            Rent := RE_Exn_Integer;\n+            Etyp := Standard_Long_Long_Long_Integer;\n+\n+            if Ovflo then\n+               Rent := RE_Exp_Long_Long_Long_Integer;\n+            else\n+               Rent := RE_Exn_Long_Long_Long_Integer;\n+            end if;\n          end if;\n \n       --  Floating-point cases. We do not need separate routines for the\n@@ -14101,6 +14118,11 @@ package body Exp_Ch4 is\n          elsif Is_OK_For_Range (Uint_64) then\n             return Uint_64;\n \n+         --  If the size of Typ is 128 then check 127\n+\n+         elsif Tsiz = Uint_128 and then Is_OK_For_Range (Uint_127) then\n+            return Uint_127;\n+\n          else\n             return Uint_128;\n          end if;\n@@ -14220,12 +14242,8 @@ package body Exp_Ch4 is\n       --  type instead of the first subtype because operations are done in\n       --  the base type, so this avoids the need for useless conversions.\n \n-      if Nsiz <= Standard_Integer_Size then\n-         Ntyp := Etype (Standard_Integer);\n-\n-      elsif Nsiz <= Standard_Long_Long_Integer_Size then\n-         Ntyp := Etype (Standard_Long_Long_Integer);\n-\n+      if Nsiz <= System_Max_Integer_Size then\n+         Ntyp := Etype (Integer_Type_For (Nsiz, Uns => False));\n       else\n          return;\n       end if;"}, {"sha": "c2e774140ff5878cf164f112522a01ee1498b89c", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -247,7 +247,7 @@ package body Exp_Dbug is\n \n       --  Here we check if the static bounds match the natural size, which is\n       --  the size passed through with the debugging information. This is the\n-      --  Esize rounded up to 8, 16, 32 or 64 as appropriate.\n+      --  Esize rounded up to 8, 16, 32, 64 or 128 as appropriate.\n \n       else\n          declare\n@@ -261,8 +261,10 @@ package body Exp_Dbug is\n                Siz := Uint_16;\n             elsif Esize (E) <= 32 then\n                Siz := Uint_32;\n-            else\n+            elsif Esize (E) <= 64 then\n                Siz := Uint_64;\n+            else\n+               Siz := Uint_128;\n             end if;\n \n             if Is_Modular_Integer_Type (E) or else Is_Enumeration_Type (E) then"}, {"sha": "1cb01888da540f6f9439ac119da72d595d9fafc7", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -620,7 +620,7 @@ package body Exp_Fixd is\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc)),\n \n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Double_Divide), Loc),\n+             Name => New_Occurrence_Of (RTE (RE_Double_Divide64), Loc),\n              Parameter_Associations => New_List (\n                Build_Conversion (N, QR_Typ, X),\n                Build_Conversion (N, QR_Typ, Y),\n@@ -977,7 +977,7 @@ package body Exp_Fixd is\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc)),\n \n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Scaled_Divide), Loc),\n+             Name => New_Occurrence_Of (RTE (RE_Scaled_Divide64), Loc),\n              Parameter_Associations => New_List (\n                Build_Conversion (N, QR_Typ, X),\n                Build_Conversion (N, QR_Typ, Y),"}, {"sha": "78bde893aa463edb44af28efb5366e62f5ed3850", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -205,12 +205,16 @@ package body Exp_Intr is\n          return;\n       end if;\n \n-      --  Use Unsigned_32 for sizes of 32 or below, else Unsigned_64\n+      --  Use the appropriate type for the size\n \n-      if Siz > 32 then\n-         T3 := RTE (RE_Unsigned_64);\n-      else\n+      if Siz <= 32 then\n          T3 := RTE (RE_Unsigned_32);\n+\n+      elsif Siz <= 64 then\n+         T3 := RTE (RE_Unsigned_64);\n+\n+      else pragma Assert (Siz <= 128);\n+         T3 := RTE (RE_Unsigned_128);\n       end if;\n \n       --  Copy operator node, and reset type and entity fields, for"}, {"sha": "07a05a591f40b7d6ff71f498b7aa07e47413db6a", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -233,8 +233,11 @@ package body Exp_Pakd is\n          elsif T_Size <= 32 then\n             Swap_RE := RE_Bswap_32;\n \n-         else pragma Assert (T_Size <= 64);\n+         elsif T_Size <= 64 then\n             Swap_RE := RE_Bswap_64;\n+\n+         else pragma Assert (T_Size <= 128);\n+            Swap_RE := RE_Bswap_128;\n          end if;\n \n          Swap_F := RTE (Swap_RE);"}, {"sha": "559f54a24055cc9501a6d36e0cfdcb54778ead6a", "filename": "gcc/ada/exp_pakd.ads", "status": "modified", "additions": 330, "deletions": 10, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_pakd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_pakd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -217,12 +217,12 @@ package Exp_Pakd is\n    -- Entity Tables for Packed Access Routines --\n    ----------------------------------------------\n \n-   --  For the cases of component size = 3,5-7,9-15,17-31,33-63 we call library\n-   --  routines. These tables provide the entity for the proper routine. They\n-   --  are exposed in the spec to allow checking for the presence of the needed\n-   --  routine when an array is subject to pragma Pack.\n+   --  For the cases of component size = 3,5-7,9-15,17-31,33-63,65-127 we call\n+   --  library routines. These tables provide the entity for the right routine.\n+   --  They are exposed in the spec to allow checking for the presence of the\n+   --  needed routine when an array is subject to pragma Pack.\n \n-   type E_Array is array (Int range 01 .. 63) of RE_Id;\n+   type E_Array is array (Int range 1 .. 127) of RE_Id;\n \n    --  Array of Bits_nn entities. Note that we do not use library routines\n    --  for the 8-bit and 16-bit cases, but we still fill in the table, using\n@@ -292,7 +292,71 @@ package Exp_Pakd is\n       60 => RE_Bits_60,\n       61 => RE_Bits_61,\n       62 => RE_Bits_62,\n-      63 => RE_Bits_63);\n+      63 => RE_Bits_63,\n+      64 => RE_Unsigned_64,\n+      65 => RE_Bits_65,\n+      66 => RE_Bits_66,\n+      67 => RE_Bits_67,\n+      68 => RE_Bits_68,\n+      69 => RE_Bits_69,\n+      70 => RE_Bits_70,\n+      71 => RE_Bits_71,\n+      72 => RE_Bits_72,\n+      73 => RE_Bits_73,\n+      74 => RE_Bits_74,\n+      75 => RE_Bits_75,\n+      76 => RE_Bits_76,\n+      77 => RE_Bits_77,\n+      78 => RE_Bits_78,\n+      79 => RE_Bits_79,\n+      80 => RE_Bits_80,\n+      81 => RE_Bits_81,\n+      82 => RE_Bits_82,\n+      83 => RE_Bits_83,\n+      84 => RE_Bits_84,\n+      85 => RE_Bits_85,\n+      86 => RE_Bits_86,\n+      87 => RE_Bits_87,\n+      88 => RE_Bits_88,\n+      89 => RE_Bits_89,\n+      90 => RE_Bits_90,\n+      91 => RE_Bits_91,\n+      92 => RE_Bits_92,\n+      93 => RE_Bits_93,\n+      94 => RE_Bits_94,\n+      95 => RE_Bits_95,\n+      96 => RE_Bits_96,\n+      97 => RE_Bits_97,\n+      98 => RE_Bits_98,\n+      99 => RE_Bits_99,\n+      100 => RE_Bits_100,\n+      101 => RE_Bits_101,\n+      102 => RE_Bits_102,\n+      103 => RE_Bits_103,\n+      104 => RE_Bits_104,\n+      105 => RE_Bits_105,\n+      106 => RE_Bits_106,\n+      107 => RE_Bits_107,\n+      108 => RE_Bits_108,\n+      109 => RE_Bits_109,\n+      110 => RE_Bits_110,\n+      111 => RE_Bits_111,\n+      112 => RE_Bits_112,\n+      113 => RE_Bits_113,\n+      114 => RE_Bits_114,\n+      115 => RE_Bits_115,\n+      116 => RE_Bits_116,\n+      117 => RE_Bits_117,\n+      118 => RE_Bits_118,\n+      119 => RE_Bits_119,\n+      120 => RE_Bits_120,\n+      121 => RE_Bits_121,\n+      122 => RE_Bits_122,\n+      123 => RE_Bits_123,\n+      124 => RE_Bits_124,\n+      125 => RE_Bits_125,\n+      126 => RE_Bits_126,\n+      127 => RE_Bits_127);\n \n    --  Array of Get routine entities. These are used to obtain an element from\n    --  a packed array. The N'th entry is used to obtain elements from a packed\n@@ -362,7 +426,71 @@ package Exp_Pakd is\n       60 => RE_Get_60,\n       61 => RE_Get_61,\n       62 => RE_Get_62,\n-      63 => RE_Get_63);\n+      63 => RE_Get_63,\n+      64 => RE_Null,\n+      65 => RE_Get_65,\n+      66 => RE_Get_66,\n+      67 => RE_Get_67,\n+      68 => RE_Get_68,\n+      69 => RE_Get_69,\n+      70 => RE_Get_70,\n+      71 => RE_Get_71,\n+      72 => RE_Get_72,\n+      73 => RE_Get_73,\n+      74 => RE_Get_74,\n+      75 => RE_Get_75,\n+      76 => RE_Get_76,\n+      77 => RE_Get_77,\n+      78 => RE_Get_78,\n+      79 => RE_Get_79,\n+      80 => RE_Get_80,\n+      81 => RE_Get_81,\n+      82 => RE_Get_82,\n+      83 => RE_Get_83,\n+      84 => RE_Get_84,\n+      85 => RE_Get_85,\n+      86 => RE_Get_86,\n+      87 => RE_Get_87,\n+      88 => RE_Get_88,\n+      89 => RE_Get_89,\n+      90 => RE_Get_90,\n+      91 => RE_Get_91,\n+      92 => RE_Get_92,\n+      93 => RE_Get_93,\n+      94 => RE_Get_94,\n+      95 => RE_Get_95,\n+      96 => RE_Get_96,\n+      97 => RE_Get_97,\n+      98 => RE_Get_98,\n+      99 => RE_Get_99,\n+      100 => RE_Get_100,\n+      101 => RE_Get_101,\n+      102 => RE_Get_102,\n+      103 => RE_Get_103,\n+      104 => RE_Get_104,\n+      105 => RE_Get_105,\n+      106 => RE_Get_106,\n+      107 => RE_Get_107,\n+      108 => RE_Get_108,\n+      109 => RE_Get_109,\n+      110 => RE_Get_110,\n+      111 => RE_Get_111,\n+      112 => RE_Get_112,\n+      113 => RE_Get_113,\n+      114 => RE_Get_114,\n+      115 => RE_Get_115,\n+      116 => RE_Get_116,\n+      117 => RE_Get_117,\n+      118 => RE_Get_118,\n+      119 => RE_Get_119,\n+      120 => RE_Get_120,\n+      121 => RE_Get_121,\n+      122 => RE_Get_122,\n+      123 => RE_Get_123,\n+      124 => RE_Get_124,\n+      125 => RE_Get_125,\n+      126 => RE_Get_126,\n+      127 => RE_Get_127);\n \n    --  Array of Get routine entities to be used in the case where the packed\n    --  array is itself a component of a packed structure, and therefore may not\n@@ -432,7 +560,71 @@ package Exp_Pakd is\n       60 => RE_GetU_60,\n       61 => RE_Get_61,\n       62 => RE_GetU_62,\n-      63 => RE_Get_63);\n+      63 => RE_Get_63,\n+      64 => RE_Null,\n+      65 => RE_Get_65,\n+      66 => RE_GetU_66,\n+      67 => RE_Get_67,\n+      68 => RE_GetU_68,\n+      69 => RE_Get_69,\n+      70 => RE_GetU_70,\n+      71 => RE_Get_71,\n+      72 => RE_GetU_72,\n+      73 => RE_Get_73,\n+      74 => RE_GetU_74,\n+      75 => RE_Get_75,\n+      76 => RE_GetU_76,\n+      77 => RE_Get_77,\n+      78 => RE_GetU_78,\n+      79 => RE_Get_79,\n+      80 => RE_GetU_80,\n+      81 => RE_Get_81,\n+      82 => RE_GetU_82,\n+      83 => RE_Get_83,\n+      84 => RE_GetU_84,\n+      85 => RE_Get_85,\n+      86 => RE_GetU_86,\n+      87 => RE_Get_87,\n+      88 => RE_GetU_88,\n+      89 => RE_Get_89,\n+      90 => RE_GetU_90,\n+      91 => RE_Get_91,\n+      92 => RE_GetU_92,\n+      93 => RE_Get_93,\n+      94 => RE_GetU_94,\n+      95 => RE_Get_95,\n+      96 => RE_GetU_96,\n+      97 => RE_Get_97,\n+      98 => RE_GetU_98,\n+      99 => RE_Get_99,\n+      100 => RE_GetU_100,\n+      101 => RE_Get_101,\n+      102 => RE_GetU_102,\n+      103 => RE_Get_103,\n+      104 => RE_GetU_104,\n+      105 => RE_Get_105,\n+      106 => RE_GetU_106,\n+      107 => RE_Get_107,\n+      108 => RE_GetU_108,\n+      109 => RE_Get_109,\n+      110 => RE_GetU_110,\n+      111 => RE_Get_111,\n+      112 => RE_GetU_112,\n+      113 => RE_Get_113,\n+      114 => RE_GetU_114,\n+      115 => RE_Get_115,\n+      116 => RE_GetU_116,\n+      117 => RE_Get_117,\n+      118 => RE_GetU_118,\n+      119 => RE_Get_119,\n+      120 => RE_GetU_120,\n+      121 => RE_Get_121,\n+      122 => RE_GetU_122,\n+      123 => RE_Get_123,\n+      124 => RE_GetU_124,\n+      125 => RE_Get_125,\n+      126 => RE_GetU_126,\n+      127 => RE_Get_127);\n \n    --  Array of Set routine entities. These are used to assign an element of a\n    --  packed array. The N'th entry is used to assign elements for a packed\n@@ -502,7 +694,71 @@ package Exp_Pakd is\n       60 => RE_Set_60,\n       61 => RE_Set_61,\n       62 => RE_Set_62,\n-      63 => RE_Set_63);\n+      63 => RE_Set_63,\n+      64 => RE_Null,\n+      65 => RE_Set_65,\n+      66 => RE_Set_66,\n+      67 => RE_Set_67,\n+      68 => RE_Set_68,\n+      69 => RE_Set_69,\n+      70 => RE_Set_70,\n+      71 => RE_Set_71,\n+      72 => RE_Set_72,\n+      73 => RE_Set_73,\n+      74 => RE_Set_74,\n+      75 => RE_Set_75,\n+      76 => RE_Set_76,\n+      77 => RE_Set_77,\n+      78 => RE_Set_78,\n+      79 => RE_Set_79,\n+      80 => RE_Set_80,\n+      81 => RE_Set_81,\n+      82 => RE_Set_82,\n+      83 => RE_Set_83,\n+      84 => RE_Set_84,\n+      85 => RE_Set_85,\n+      86 => RE_Set_86,\n+      87 => RE_Set_87,\n+      88 => RE_Set_88,\n+      89 => RE_Set_89,\n+      90 => RE_Set_90,\n+      91 => RE_Set_91,\n+      92 => RE_Set_92,\n+      93 => RE_Set_93,\n+      94 => RE_Set_94,\n+      95 => RE_Set_95,\n+      96 => RE_Set_96,\n+      97 => RE_Set_97,\n+      98 => RE_Set_98,\n+      99 => RE_Set_99,\n+      100 => RE_Set_100,\n+      101 => RE_Set_101,\n+      102 => RE_Set_102,\n+      103 => RE_Set_103,\n+      104 => RE_Set_104,\n+      105 => RE_Set_105,\n+      106 => RE_Set_106,\n+      107 => RE_Set_107,\n+      108 => RE_Set_108,\n+      109 => RE_Set_109,\n+      110 => RE_Set_110,\n+      111 => RE_Set_111,\n+      112 => RE_Set_112,\n+      113 => RE_Set_113,\n+      114 => RE_Set_114,\n+      115 => RE_Set_115,\n+      116 => RE_Set_116,\n+      117 => RE_Set_117,\n+      118 => RE_Set_118,\n+      119 => RE_Set_119,\n+      120 => RE_Set_120,\n+      121 => RE_Set_121,\n+      122 => RE_Set_122,\n+      123 => RE_Set_123,\n+      124 => RE_Set_124,\n+      125 => RE_Set_125,\n+      126 => RE_Set_126,\n+      127 => RE_Set_127);\n \n    --  Array of Set routine entities to be used in the case where the packed\n    --  array is itself a component of a packed structure, and therefore may not\n@@ -572,7 +828,71 @@ package Exp_Pakd is\n       60 => RE_SetU_60,\n       61 => RE_Set_61,\n       62 => RE_SetU_62,\n-      63 => RE_Set_63);\n+      63 => RE_Set_63,\n+      64 => RE_Null,\n+      65 => RE_Set_65,\n+      66 => RE_SetU_66,\n+      67 => RE_Set_67,\n+      68 => RE_SetU_68,\n+      69 => RE_Set_69,\n+      70 => RE_SetU_70,\n+      71 => RE_Set_71,\n+      72 => RE_SetU_72,\n+      73 => RE_Set_73,\n+      74 => RE_SetU_74,\n+      75 => RE_Set_75,\n+      76 => RE_SetU_76,\n+      77 => RE_Set_77,\n+      78 => RE_SetU_78,\n+      79 => RE_Set_79,\n+      80 => RE_SetU_80,\n+      81 => RE_Set_81,\n+      82 => RE_SetU_82,\n+      83 => RE_Set_83,\n+      84 => RE_SetU_84,\n+      85 => RE_Set_85,\n+      86 => RE_SetU_86,\n+      87 => RE_Set_87,\n+      88 => RE_SetU_88,\n+      89 => RE_Set_89,\n+      90 => RE_SetU_90,\n+      91 => RE_Set_91,\n+      92 => RE_SetU_92,\n+      93 => RE_Set_93,\n+      94 => RE_SetU_94,\n+      95 => RE_Set_95,\n+      96 => RE_SetU_96,\n+      97 => RE_Set_97,\n+      98 => RE_SetU_98,\n+      99 => RE_Set_99,\n+      100 => RE_SetU_100,\n+      101 => RE_Set_101,\n+      102 => RE_SetU_102,\n+      103 => RE_Set_103,\n+      104 => RE_SetU_104,\n+      105 => RE_Set_105,\n+      106 => RE_SetU_106,\n+      107 => RE_Set_107,\n+      108 => RE_SetU_108,\n+      109 => RE_Set_109,\n+      110 => RE_SetU_110,\n+      111 => RE_Set_111,\n+      112 => RE_SetU_112,\n+      113 => RE_Set_113,\n+      114 => RE_SetU_114,\n+      115 => RE_Set_115,\n+      116 => RE_SetU_116,\n+      117 => RE_Set_117,\n+      118 => RE_SetU_118,\n+      119 => RE_Set_119,\n+      120 => RE_SetU_120,\n+      121 => RE_Set_121,\n+      122 => RE_SetU_122,\n+      123 => RE_Set_123,\n+      124 => RE_SetU_124,\n+      125 => RE_Set_125,\n+      126 => RE_SetU_126,\n+      127 => RE_Set_127);\n \n    -----------------\n    -- Subprograms --"}, {"sha": "866044f440e6e3b91018816801b8988ac4c4266f", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -7751,6 +7751,15 @@ package body Exp_Util is\n             return Standard_Long_Long_Integer;\n          end if;\n \n+      --  This is the canonical 128-bit type\n+\n+      elsif S <= Standard_Long_Long_Long_Integer_Size then\n+         if Uns then\n+            return Standard_Long_Long_Long_Unsigned;\n+         else\n+            return Standard_Long_Long_Long_Integer;\n+         end if;\n+\n       else\n          raise Program_Error;\n       end if;\n@@ -13593,6 +13602,13 @@ package body Exp_Util is\n             return Standard_Long_Long_Integer;\n          end if;\n \n+      elsif S <= Standard_Long_Long_Long_Integer_Size then\n+         if Uns then\n+            return Standard_Long_Long_Long_Unsigned;\n+         else\n+            return Standard_Long_Long_Long_Integer;\n+         end if;\n+\n       else\n          raise Program_Error;\n       end if;"}, {"sha": "ee130fdf0a4a5f2338389ca138dcd77601309cb7", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -140,11 +140,13 @@ package body Fname is\n       Renamings_Included : Boolean := True) return Boolean\n    is\n    begin\n-      --  Definitely false if longer than 12 characters (8.3)\n-      --  except for the Interfaces packages\n+      --  Definitely false if longer than 12 characters (8.3), except for the\n+      --  Interfaces packages and also the implementation units of the 128-bit\n+      --  types under System.\n \n       if Fname'Length > 12\n         and then Fname (Fname'First .. Fname'First + 1) /= \"i-\"\n+        and then Fname (Fname'First .. Fname'First + 1) /= \"s-\"\n       then\n          return False;\n       end if;"}, {"sha": "52abb7f4b5f47583ca5408b2d0996096a0367387", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -80,8 +80,8 @@ package body Freeze is\n    --  Typ is a type that is being frozen. If no size clause is given,\n    --  but a default Esize has been computed, then this default Esize is\n    --  adjusted up if necessary to be consistent with a given alignment,\n-   --  but never to a value greater than Long_Long_Integer'Size. This\n-   --  is used for all discrete types and for fixed-point types.\n+   --  but never to a value greater than System_Max_Integer_Size. This is\n+   --  used for all discrete types and for fixed-point types.\n \n    procedure Build_And_Analyze_Renamed_Body\n      (Decl  : Node_Id;\n@@ -231,9 +231,7 @@ package body Freeze is\n       if Known_Esize (Typ) and then Known_Alignment (Typ) then\n          Align := Alignment_In_Bits (Typ);\n \n-         if Align > Esize (Typ)\n-           and then Align <= Standard_Long_Long_Integer_Size\n-         then\n+         if Align > Esize (Typ) and then Align <= System_Max_Integer_Size then\n             Set_Esize (Typ, Align);\n          end if;\n       end if;\n@@ -2204,7 +2202,7 @@ package body Freeze is\n       --  generated a message on the template.\n \n       procedure Check_Suspicious_Modulus (Utype : Entity_Id);\n-      --  Give warning for modulus of 8, 16, 32, or 64 given as an explicit\n+      --  Give warning for modulus of 8, 16, 32, 64 or 128 given as an explicit\n       --  integer literal without an explicit corresponding size clause. The\n       --  caller has checked that Utype is a modular integer type.\n \n@@ -2896,7 +2894,7 @@ package body Freeze is\n                         end if;\n                      end if;\n \n-                     --  Bit packing is never needed for 8, 16, 32, 64\n+                     --  Bit packing is never needed for 8, 16, 32, 64 or 128\n \n                      if Addressable (Csiz) then\n "}, {"sha": "8b35b1c447ef82c588866e28f8dd4acf781b0658", "filename": "gcc/ada/get_targ.adb", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fget_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fget_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -126,6 +126,18 @@ package body Get_Targ is\n       return C_Get_Long_Long_Size;\n    end Get_Long_Long_Size;\n \n+   -----------------------------\n+   -- Get_Long_Long_Long_Size --\n+   -----------------------------\n+\n+   function Get_Long_Long_Long_Size return Pos is\n+      function C_Get_Long_Long_Long_Size return Pos;\n+      pragma Import (C, C_Get_Long_Long_Long_Size,\n+                        \"get_target_long_long_long_size\");\n+   begin\n+      return C_Get_Long_Long_Long_Size;\n+   end Get_Long_Long_Long_Size;\n+\n    ----------------------\n    -- Get_Pointer_Size --\n    ----------------------\n@@ -309,10 +321,11 @@ package body Get_Targ is\n    function Width_From_Size (Size : Pos) return Pos is\n    begin\n       case Size is\n-         when  8     => return  4;\n-         when 16     => return  6;\n-         when 32     => return 11;\n-         when 64     => return 21;\n+         when   8    => return  4;\n+         when  16    => return  6;\n+         when  32    => return 11;\n+         when  64    => return 21;\n+         when 128    => return 40;\n          when others => raise Program_Error;\n       end case;\n    end Width_From_Size;"}, {"sha": "676e117cc806e1c9f00fb0cf682b3c895a14a888", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -68,6 +68,9 @@ package Get_Targ is\n    function Get_Long_Long_Size             return Pos;\n    --  Size of Standard.Long_Long_Integer\n \n+   function Get_Long_Long_Long_Size        return Pos;\n+   --  Size of Standard.Long_Long_Long_Integer\n+\n    function Get_Pointer_Size               return Pos;\n    --  Size of System.Address\n "}, {"sha": "51904f01c9572e07ada658e3048e0392053bd2bb", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -799,6 +799,33 @@ procedure Gnat1drv is\n          Set_Standard_Output;\n       end if;\n \n+      --  Enable or disable the support for 128-bit types\n+\n+      if Enable_128bit_Types then\n+         if Ttypes.Standard_Long_Long_Long_Integer_Size < 128 then\n+            Write_Line\n+              (\"128-bit types not implemented in this configuration\");\n+            raise Unrecoverable_Error;\n+         end if;\n+\n+      --  In GNAT mode the support is automatically enabled if available,\n+      --  so that the runtime is compiled with the support enabled.\n+\n+      elsif GNAT_Mode then\n+         Enable_128bit_Types :=\n+           Ttypes.Standard_Long_Long_Long_Integer_Size = 128;\n+\n+      else\n+         Ttypes.Standard_Long_Long_Long_Integer_Size :=\n+           Ttypes.Standard_Long_Long_Integer_Size;\n+         Ttypes.Standard_Long_Long_Long_Integer_Width :=\n+           Ttypes.Standard_Long_Long_Integer_Width;\n+         Ttypes.System_Max_Integer_Size :=\n+           Ttypes.Standard_Long_Long_Integer_Size;\n+         Ttypes.System_Max_Binary_Modulus_Power :=\n+           Ttypes.Standard_Long_Long_Integer_Size;\n+      end if;\n+\n       --  Finally capture adjusted value of Suppress_Options as the initial\n       --  value for Scope_Suppress, which will be modified as we move from\n       --  scope to scope (by Suppress/Unsuppress/Overflow_Checks pragmas)."}, {"sha": "9eb71740c7cad413ed4dad548e170b57a039fd24", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -687,7 +687,7 @@ package body Impunit is\n    function Get_Kind_Of_File (File : String) return Kind_Of_Unit is\n       pragma Assert (File'First = 1);\n \n-      Buffer : String (1 .. 8);\n+      Buffer : String (1 .. 9);\n \n    begin\n       Error_Msg_Strlen := 0;\n@@ -701,13 +701,6 @@ package body Impunit is\n          return Ada_95_Unit;\n       end if;\n \n-      --  If length of file name is greater than 12, not predefined. The value\n-      --  12 here is an 8 char name with extension .ads.\n-\n-      if File'Length > 12 then\n-         return Not_Predefined_Unit;\n-      end if;\n-\n       --  Not predefined if file name does not start with a- g- s- i-\n \n       if File'Length < 3\n@@ -721,6 +714,16 @@ package body Impunit is\n          return Not_Predefined_Unit;\n       end if;\n \n+      --  If length of file name is greater than 12, not predefined. The value\n+      --  12 here is an 8 char name with extension .ads. The exception of 13 is\n+      --  for the implementation units of the 128-bit types under System.\n+\n+      if File'Length > 12\n+        and then not (File'Length = 13 and then File (1) = 's')\n+      then\n+         return Not_Predefined_Unit;\n+      end if;\n+\n       --  Not predefined if file name does not end in .ads. This can happen\n       --  when non-standard file names are being used.\n \n@@ -739,31 +742,31 @@ package body Impunit is\n       --  See if name is in 95 list\n \n       for J in Non_Imp_File_Names_95'Range loop\n-         if Buffer = Non_Imp_File_Names_95 (J).Fname then\n+         if Buffer (1 .. 8) = Non_Imp_File_Names_95 (J).Fname then\n             return Ada_95_Unit;\n          end if;\n       end loop;\n \n       --  See if name is in 2005 list\n \n       for J in Non_Imp_File_Names_05'Range loop\n-         if Buffer = Non_Imp_File_Names_05 (J).Fname then\n+         if Buffer (1 .. 8) = Non_Imp_File_Names_05 (J).Fname then\n             return Ada_2005_Unit;\n          end if;\n       end loop;\n \n       --  See if name is in 2012 list\n \n       for J in Non_Imp_File_Names_12'Range loop\n-         if Buffer = Non_Imp_File_Names_12 (J).Fname then\n+         if Buffer (1 .. 8) = Non_Imp_File_Names_12 (J).Fname then\n             return Ada_2012_Unit;\n          end if;\n       end loop;\n \n       --  See if name is in 202X list\n \n       for J in Non_Imp_File_Names_2X'Range loop\n-         if Buffer = Non_Imp_File_Names_2X (J).Fname then\n+         if Buffer (1 .. 8) = Non_Imp_File_Names_2X (J).Fname then\n             return Ada_202X_Unit;\n          end if;\n       end loop;\n@@ -927,13 +930,6 @@ package body Impunit is\n          return True;\n       end if;\n \n-      --  If length of file name is greater than 12, then it's a user unit\n-      --  and not a GNAT implementation defined unit.\n-\n-      if Name_Len > 12 then\n-         return True;\n-      end if;\n-\n       --  Implementation defined if unit in the gnat hierarchy\n \n       if (Name_Len = 8 and then Name_Buffer (1 .. 8) = \"gnat.ads\")\n@@ -955,6 +951,16 @@ package body Impunit is\n          return True;\n       end if;\n \n+      --  If length of file name is greater than 12, not predefined. The value\n+      --  12 here is an 8 char name with extension .ads. The exception of 13 is\n+      --  for the implementation units of the 128-bit types under System.\n+\n+      if Name_Len > 12\n+        and then not (Name_Len = 13 and then Name_Buffer (1) = 's')\n+      then\n+         return True;\n+      end if;\n+\n       --  Not impl-defined if file name does not end in .ads. This can happen\n       --  when non-standard file names are being used.\n "}, {"sha": "2b67849c068344828f375d092322f31c00f5c4e2", "filename": "gcc/ada/krunch.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fkrunch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fkrunch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -89,7 +89,20 @@ begin\n       Startloc := 3;\n       Buffer (2 .. Len - 5) := Buffer (7 .. Len);\n       Curlen := Len - 5;\n-      Krlen  := 8;\n+      if Buffer (Curlen - 2 .. Curlen) = \"128\"\n+        or else Buffer (3 .. 9) = \"exn_lll\"\n+        or else Buffer (3 .. 9) = \"exp_lll\"\n+        or else (Buffer (3 .. 6) = \"pack\" and then Curlen = 10)\n+      then\n+         if Buffer (3 .. 15) = \"compare_array\" then\n+            Buffer (3 .. 4) := \"ca\";\n+            Buffer (5 .. Curlen - 11) := Buffer (16 .. Curlen);\n+            Curlen := Curlen - 11;\n+         end if;\n+         Krlen := 9;\n+      else\n+         Krlen := 8;\n+      end if;\n \n    elsif Len >= 11 and then Buffer (1 .. 11) = \"interfaces-\" then\n       Startloc := 3;"}, {"sha": "d5fdf84cf386a99fd034467a9a403e558c70e7c9", "filename": "gcc/ada/krunch.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fkrunch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fkrunch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -114,6 +114,9 @@\n --  we replace the prefix ada.wide_wide_text_io- by a-zt- and then\n --  the normal crunching rules are applied.\n \n+--  The units implementing the support of 128-bit types are crunched to 9 and\n+--  System.Compare_Array_* is replaced with System.CA_* before crunching.\n+\n --  These are the only irregularity required (so far) to keep the file names\n --  unique in the standard predefined libraries.\n "}, {"sha": "6fde60a501280e69f36c667362353014d83eea80", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -436,11 +436,11 @@ package body Layout is\n          end if;\n \n          --  For array base types, set the component size if object size of the\n-         --  component type is known and is a small power of 2 (8, 16, 32, 64),\n-         --  since this is what will always be used, except if a very large\n-         --  alignment was specified and so Adjust_Esize_For_Alignment gave up\n-         --  because, in this case, the object size is not a multiple of the\n-         --  alignment and, therefore, cannot be the component size.\n+         --  component type is known and is a small power of 2 (8, 16, 32, 64\n+         --  or 128), since this is what will always be used, except if a very\n+         --  large alignment was specified and so Adjust_Esize_For_Alignment\n+         --  gave up because, in this case, the object size is not a multiple\n+         --  of the alignment and, therefore, cannot be the component size.\n \n          if Ekind (E) = E_Array_Type and then Unknown_Component_Size (E) then\n             declare\n@@ -455,7 +455,7 @@ package body Layout is\n                  and then Known_Static_Esize (CT)\n                  and then not (Known_Alignment (CT)\n                                 and then Alignment_In_Bits (CT) >\n-                                           Standard_Long_Long_Integer_Size)\n+                                           System_Max_Integer_Size)\n                then\n                   declare\n                      S : constant Uint := Esize (CT);"}, {"sha": "440a77dd59811adf98e33acc8cb205fb12aed34b", "filename": "gcc/ada/libgnat/a-tifiio.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -580,7 +580,7 @@ package body Ada.Text_IO.Fixed_IO is\n                YY := 10**(Integer'Min (Max_Digits, AA - (J - 1) * Max_Digits));\n             end if;\n \n-            Scaled_Divide (XX, YY, Z, Q (J), R => XX, Round => False);\n+            Scaled_Divide64 (XX, YY, Z, Q (J), R => XX, Round => False);\n          end loop;\n \n          if -E > A then"}, {"sha": "2865fc21be53a3e5e369b3202734361b0ac5a56d", "filename": "gcc/ada/libgnat/interfac__2020.ads", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Finterfac__2020.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Finterfac__2020.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Finterfac__2020.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -60,7 +60,12 @@ package Interfaces is\n    --  such as SPARK or CodePeer. In the normal case Long_Long_Integer is\n    --  always 64-bits so we get the desired 64-bit type.\n \n-   type Unsigned_8  is mod 2 ** 8;\n+   type Integer_128 is new Long_Long_Long_Integer;\n+   --  Note: we use Long_Long_Long_Integer instead of literal bounds to allow\n+   --  this unit to be compiled with compilers not supporting 128-bit integers.\n+   --  We do not put a confirming size clause of 128 bits for the same reason.\n+\n+   type Unsigned_8 is mod 2 ** 8;\n    for Unsigned_8'Size use  8;\n \n    type Unsigned_16 is mod 2 ** 16;\n@@ -78,6 +83,9 @@ package Interfaces is\n    for Unsigned_64'Size use 64;\n    --  See comment on Integer_64 above\n \n+   type Unsigned_128 is mod 2 ** Long_Long_Long_Integer'Size;\n+   --  See comment on Integer_128 above\n+\n    function Shift_Left\n      (Value  : Unsigned_8;\n       Amount : Natural) return Unsigned_8\n@@ -178,6 +186,31 @@ package Interfaces is\n       Amount : Natural) return Unsigned_64\n       with Import, Convention => Intrinsic, Static;\n \n+   function Shift_Left\n+     (Value  : Unsigned_128;\n+      Amount : Natural) return Unsigned_128\n+      with Import, Convention => Intrinsic, Static;\n+\n+   function Shift_Right\n+     (Value  : Unsigned_128;\n+      Amount : Natural) return Unsigned_128\n+      with Import, Convention => Intrinsic, Static;\n+\n+   function Shift_Right_Arithmetic\n+     (Value  : Unsigned_128;\n+      Amount : Natural) return Unsigned_128\n+      with Import, Convention => Intrinsic, Static;\n+\n+   function Rotate_Left\n+     (Value  : Unsigned_128;\n+      Amount : Natural) return Unsigned_128\n+      with Import, Convention => Intrinsic, Static;\n+\n+   function Rotate_Right\n+     (Value  : Unsigned_128;\n+      Amount : Natural) return Unsigned_128\n+      with Import, Convention => Intrinsic, Static;\n+\n    --  IEEE Floating point types\n \n    type IEEE_Float_32 is digits 6;"}, {"sha": "05a8c9f96044fcf6104995c12144ebaca81fa1f6", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "added", "additions": 678, "deletions": 0, "changes": 678, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,678 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . A R I T H _ D O U B L E                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Arith_Double is\n+\n+   pragma Suppress (Overflow_Check);\n+   pragma Suppress (Range_Check);\n+\n+   function To_Uns is new Ada.Unchecked_Conversion (Double_Int, Double_Uns);\n+   function To_Int is new Ada.Unchecked_Conversion (Double_Uns, Double_Int);\n+\n+   Double_Size : constant Natural := Double_Int'Size;\n+   Single_Size : constant Natural := Double_Int'Size / 2;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function \"+\" (A, B : Single_Uns) return Double_Uns is\n+     (Double_Uns (A) + Double_Uns (B));\n+   function \"+\" (A : Double_Uns; B : Single_Uns) return Double_Uns is\n+     (A + Double_Uns (B));\n+   --  Length doubling additions\n+\n+   function \"*\" (A, B : Single_Uns) return Double_Uns is\n+     (Double_Uns (A) * Double_Uns (B));\n+   --  Length doubling multiplication\n+\n+   function \"/\" (A : Double_Uns; B : Single_Uns) return Double_Uns is\n+     (A / Double_Uns (B));\n+   --  Length doubling division\n+\n+   function \"&\" (Hi, Lo : Single_Uns) return Double_Uns is\n+     (Shift_Left (Double_Uns (Hi), Single_Size) or Double_Uns (Lo));\n+   --  Concatenate hi, lo values to form double result\n+\n+   function \"abs\" (X : Double_Int) return Double_Uns is\n+     (if X = Double_Int'First\n+      then 2 ** (Double_Size - 1)\n+      else Double_Uns (Double_Int'(abs X)));\n+   --  Convert absolute value of X to unsigned. Note that we can't just use\n+   --  the expression of the Else since it overflows for X = Double_Int'First.\n+\n+   function \"rem\" (A : Double_Uns; B : Single_Uns) return Double_Uns is\n+     (A rem Double_Uns (B));\n+   --  Length doubling remainder\n+\n+   function Le3 (X1, X2, X3, Y1, Y2, Y3 : Single_Uns) return Boolean;\n+   --  Determines if (3 * Single_Size)-bit value X1&X2&X3 <= Y1&Y2&Y3\n+\n+   function Lo (A : Double_Uns) return Single_Uns is\n+     (Single_Uns (A and (2 ** Single_Size - 1)));\n+   --  Low order half of double value\n+\n+   function Hi (A : Double_Uns) return Single_Uns is\n+     (Single_Uns (Shift_Right (A, Single_Size)));\n+   --  High order half of double value\n+\n+   procedure Sub3 (X1, X2, X3 : in out Single_Uns; Y1, Y2, Y3 : Single_Uns);\n+   --  Computes X1&X2&X3 := X1&X2&X3 - Y1&Y1&Y3 mod 2 ** (3 * Single_Size)\n+\n+   function To_Neg_Int (A : Double_Uns) return Double_Int;\n+   --  Convert to negative integer equivalent. If the input is in the range\n+   --  0 .. 2 ** (Double_Size - 1), then the corresponding nonpositive signed\n+   --  integer (obtained by negating the given value) is returned, otherwise\n+   --  constraint error is raised.\n+\n+   function To_Pos_Int (A : Double_Uns) return Double_Int;\n+   --  Convert to positive integer equivalent. If the input is in the range\n+   --  0 .. 2 ** (Double_Size - 1) - 1, then the corresponding non-negative\n+   --  signed integer is returned, otherwise constraint error is raised.\n+\n+   procedure Raise_Error;\n+   pragma No_Return (Raise_Error);\n+   --  Raise constraint error with appropriate message\n+\n+   --------------------------\n+   -- Add_With_Ovflo_Check --\n+   --------------------------\n+\n+   function Add_With_Ovflo_Check (X, Y : Double_Int) return Double_Int is\n+      R : constant Double_Int := To_Int (To_Uns (X) + To_Uns (Y));\n+\n+   begin\n+      if X >= 0 then\n+         if Y < 0 or else R >= 0 then\n+            return R;\n+         end if;\n+\n+      else -- X < 0\n+         if Y > 0 or else R < 0 then\n+            return R;\n+         end if;\n+      end if;\n+\n+      Raise_Error;\n+   end Add_With_Ovflo_Check;\n+\n+   -------------------\n+   -- Double_Divide --\n+   -------------------\n+\n+   procedure Double_Divide\n+     (X, Y, Z : Double_Int;\n+      Q, R    : out Double_Int;\n+      Round   : Boolean)\n+   is\n+      Xu  : constant Double_Uns := abs X;\n+      Yu  : constant Double_Uns := abs Y;\n+\n+      Yhi : constant Single_Uns := Hi (Yu);\n+      Ylo : constant Single_Uns := Lo (Yu);\n+\n+      Zu  : constant Double_Uns := abs Z;\n+      Zhi : constant Single_Uns := Hi (Zu);\n+      Zlo : constant Single_Uns := Lo (Zu);\n+\n+      T1, T2     : Double_Uns;\n+      Du, Qu, Ru : Double_Uns;\n+      Den_Pos    : Boolean;\n+\n+   begin\n+      if Yu = 0 or else Zu = 0 then\n+         Raise_Error;\n+      end if;\n+\n+      --  Set final signs (RM 4.5.5(27-30))\n+\n+      Den_Pos := (Y < 0) = (Z < 0);\n+\n+      --  Compute Y * Z. Note that if the result overflows Double_Uns, then\n+      --  the rounded result is zero, except for the very special case where\n+      --  X = -2 ** (Double_Size - 1) and abs(Y*Z) = 2 ** Double_Size, when\n+      --  Round is True.\n+\n+      if Yhi /= 0 then\n+         if Zhi /= 0 then\n+\n+            --  Handle the special case when Round is True\n+\n+            if Yhi = 1\n+              and then Zhi = 1\n+              and then Ylo = 0\n+              and then Zlo = 0\n+              and then X = Double_Int'First\n+              and then Round\n+            then\n+               Q := (if Den_Pos then -1 else 1);\n+            else\n+               Q := 0;\n+            end if;\n+\n+            R := X;\n+            return;\n+         else\n+            T2 := Yhi * Zlo;\n+         end if;\n+\n+      else\n+         T2 := Ylo * Zhi;\n+      end if;\n+\n+      T1 := Ylo * Zlo;\n+      T2 := T2 + Hi (T1);\n+\n+      if Hi (T2) /= 0 then\n+\n+         --  Handle the special case when Round is True\n+\n+         if Hi (T2) = 1\n+           and then Lo (T2) = 0\n+           and then Lo (T1) = 0\n+           and then X = Double_Int'First\n+           and then Round\n+         then\n+            Q := (if Den_Pos then -1 else 1);\n+         else\n+            Q := 0;\n+         end if;\n+\n+         R := X;\n+         return;\n+      end if;\n+\n+      Du := Lo (T2) & Lo (T1);\n+\n+      --  Check overflow case of largest negative number divided by -1\n+\n+      if X = Double_Int'First and then Du = 1 and then not Den_Pos then\n+         Raise_Error;\n+      end if;\n+\n+      --  Perform the actual division\n+\n+      pragma Assert (Du /= 0);\n+      --  Multiplication of 2-limb arguments Yu and Zu leads to 4-limb result\n+      --  (where each limb is a single value). Cases where 4 limbs are needed\n+      --  require Yhi/=0 and Zhi/=0 and lead to early exit. Remaining cases\n+      --  where 3 limbs are needed correspond to Hi(T2)/=0 and lead to early\n+      --  exit. Thus, at this point, the result fits in 2 limbs which are\n+      --  exactly Lo(T2) and Lo(T1), which corresponds to the value of Du.\n+      --  As the case where one of Yu or Zu is null also led to early exit,\n+      --  we have Du/=0 here.\n+      Qu := Xu / Du;\n+      Ru := Xu rem Du;\n+\n+      --  Deal with rounding case\n+\n+      if Round and then Ru > (Du - Double_Uns'(1)) / Double_Uns'(2) then\n+         Qu := Qu + Double_Uns'(1);\n+      end if;\n+\n+      --  Case of dividend (X) sign positive\n+\n+      if X >= 0 then\n+         R := To_Int (Ru);\n+         Q := (if Den_Pos then To_Int (Qu) else -To_Int (Qu));\n+\n+      --  Case of dividend (X) sign negative\n+\n+      --  We perform the unary minus operation on the unsigned value\n+      --  before conversion to signed, to avoid a possible overflow\n+      --  for value -2 ** (Double_Size - 1), both for computing R and Q.\n+\n+      else\n+         R := To_Int (-Ru);\n+         Q := (if Den_Pos then To_Int (-Qu) else To_Int (Qu));\n+      end if;\n+   end Double_Divide;\n+\n+   ---------\n+   -- Le3 --\n+   ---------\n+\n+   function Le3 (X1, X2, X3, Y1, Y2, Y3 : Single_Uns) return Boolean is\n+   begin\n+      if X1 < Y1 then\n+         return True;\n+      elsif X1 > Y1 then\n+         return False;\n+      elsif X2 < Y2 then\n+         return True;\n+      elsif X2 > Y2 then\n+         return False;\n+      else\n+         return X3 <= Y3;\n+      end if;\n+   end Le3;\n+\n+   -------------------------------\n+   -- Multiply_With_Ovflo_Check --\n+   -------------------------------\n+\n+   function Multiply_With_Ovflo_Check (X, Y : Double_Int) return Double_Int is\n+      Xu  : constant Double_Uns := abs X;\n+      Xhi : constant Single_Uns := Hi (Xu);\n+      Xlo : constant Single_Uns := Lo (Xu);\n+\n+      Yu  : constant Double_Uns := abs Y;\n+      Yhi : constant Single_Uns := Hi (Yu);\n+      Ylo : constant Single_Uns := Lo (Yu);\n+\n+      T1, T2 : Double_Uns;\n+\n+   begin\n+      if Xhi /= 0 then\n+         if Yhi /= 0 then\n+            Raise_Error;\n+         else\n+            T2 := Xhi * Ylo;\n+         end if;\n+\n+      elsif Yhi /= 0 then\n+         T2 := Xlo * Yhi;\n+\n+      else -- Yhi = Xhi = 0\n+         T2 := 0;\n+      end if;\n+\n+      --  Here we have T2 set to the contribution to the upper half of the\n+      --  result from the upper halves of the input values.\n+\n+      T1 := Xlo * Ylo;\n+      T2 := T2 + Hi (T1);\n+\n+      if Hi (T2) /= 0 then\n+         Raise_Error;\n+      end if;\n+\n+      T2 := Lo (T2) & Lo (T1);\n+\n+      if X >= 0 then\n+         if Y >= 0 then\n+            return To_Pos_Int (T2);\n+            pragma Annotate (CodePeer, Intentional, \"precondition\",\n+                             \"Intentional Unsigned->Signed conversion\");\n+         else\n+            return To_Neg_Int (T2);\n+         end if;\n+      else -- X < 0\n+         if Y < 0 then\n+            return To_Pos_Int (T2);\n+            pragma Annotate (CodePeer, Intentional, \"precondition\",\n+                             \"Intentional Unsigned->Signed conversion\");\n+         else\n+            return To_Neg_Int (T2);\n+         end if;\n+      end if;\n+\n+   end Multiply_With_Ovflo_Check;\n+\n+   -----------------\n+   -- Raise_Error --\n+   -----------------\n+\n+   procedure Raise_Error is\n+   begin\n+      raise Constraint_Error with \"Double arithmetic overflow\";\n+   end Raise_Error;\n+\n+   -------------------\n+   -- Scaled_Divide --\n+   -------------------\n+\n+   procedure Scaled_Divide\n+     (X, Y, Z : Double_Int;\n+      Q, R    : out Double_Int;\n+      Round   : Boolean)\n+   is\n+      Xu  : constant Double_Uns := abs X;\n+      Xhi : constant Single_Uns := Hi (Xu);\n+      Xlo : constant Single_Uns := Lo (Xu);\n+\n+      Yu  : constant Double_Uns := abs Y;\n+      Yhi : constant Single_Uns := Hi (Yu);\n+      Ylo : constant Single_Uns := Lo (Yu);\n+\n+      Zu  : Double_Uns := abs Z;\n+      Zhi : Single_Uns := Hi (Zu);\n+      Zlo : Single_Uns := Lo (Zu);\n+\n+      D : array (1 .. 4) of Single_Uns;\n+      --  The dividend, four digits (D(1) is high order)\n+\n+      Qd : array (1 .. 2) of Single_Uns;\n+      --  The quotient digits, two digits (Qd(1) is high order)\n+\n+      S1, S2, S3 : Single_Uns;\n+      --  Value to subtract, three digits (S1 is high order)\n+\n+      Qu : Double_Uns;\n+      Ru : Double_Uns;\n+      --  Unsigned quotient and remainder\n+\n+      Mask : Single_Uns;\n+      --  Mask of bits used to compute the scaling factor below\n+\n+      Scale : Natural;\n+      --  Scaling factor used for multiple-precision divide. Dividend and\n+      --  Divisor are multiplied by 2 ** Scale, and the final remainder is\n+      --  divided by the scaling factor. The reason for this scaling is to\n+      --  allow more accurate estimation of quotient digits.\n+\n+      Shift : Natural;\n+      --  Shift factor used to compute the scaling factor above\n+\n+      T1, T2, T3 : Double_Uns;\n+      --  Temporary values\n+\n+   begin\n+      --  First do the multiplication, giving the four digit dividend\n+\n+      T1 := Xlo * Ylo;\n+      D (4) := Lo (T1);\n+      D (3) := Hi (T1);\n+\n+      if Yhi /= 0 then\n+         T1 := Xlo * Yhi;\n+         T2 := D (3) + Lo (T1);\n+         D (3) := Lo (T2);\n+         D (2) := Hi (T1) + Hi (T2);\n+\n+         if Xhi /= 0 then\n+            T1 := Xhi * Ylo;\n+            T2 := D (3) + Lo (T1);\n+            D (3) := Lo (T2);\n+            T3 := D (2) + Hi (T1);\n+            T3 := T3 + Hi (T2);\n+            D (2) := Lo (T3);\n+            D (1) := Hi (T3);\n+\n+            T1 := (D (1) & D (2)) + Double_Uns'(Xhi * Yhi);\n+            D (1) := Hi (T1);\n+            D (2) := Lo (T1);\n+\n+         else\n+            D (1) := 0;\n+         end if;\n+\n+      else\n+         if Xhi /= 0 then\n+            T1 := Xhi * Ylo;\n+            T2 := D (3) + Lo (T1);\n+            D (3) := Lo (T2);\n+            D (2) := Hi (T1) + Hi (T2);\n+\n+         else\n+            D (2) := 0;\n+         end if;\n+\n+         D (1) := 0;\n+      end if;\n+\n+      --  Now it is time for the dreaded multiple precision division. First an\n+      --  easy case, check for the simple case of a one digit divisor.\n+\n+      if Zhi = 0 then\n+         if D (1) /= 0 or else D (2) >= Zlo then\n+            Raise_Error;\n+\n+         --  Here we are dividing at most three digits by one digit\n+\n+         else\n+            T1 := D (2) & D (3);\n+            T2 := Lo (T1 rem Zlo) & D (4);\n+\n+            Qu := Lo (T1 / Zlo) & Lo (T2 / Zlo);\n+            Ru := T2 rem Zlo;\n+         end if;\n+\n+      --  If divisor is double digit and dividend is too large, raise error\n+\n+      elsif (D (1) & D (2)) >= Zu then\n+         Raise_Error;\n+\n+      --  This is the complex case where we definitely have a double digit\n+      --  divisor and a dividend of at least three digits. We use the classical\n+      --  multiple-precision division algorithm (see section (4.3.1) of Knuth's\n+      --  \"The Art of Computer Programming\", Vol. 2 for a description\n+      --  (algorithm D).\n+\n+      else\n+         --  First normalize the divisor so that it has the leading bit on.\n+         --  We do this by finding the appropriate left shift amount.\n+\n+         Shift := Single_Size / 2;\n+         Mask  := Shift_Left (2 ** (Single_Size / 2) - 1, Shift);\n+         Scale := 0;\n+\n+         while Shift /= 0 loop\n+            if (Hi (Zu) and Mask) = 0 then\n+               Scale := Scale + Shift;\n+               Zu := Shift_Left (Zu, Shift);\n+            end if;\n+\n+            Shift := Shift / 2;\n+            Mask := Shift_Left (Mask, Shift);\n+         end loop;\n+\n+         Zhi := Hi (Zu);\n+         Zlo := Lo (Zu);\n+\n+         pragma Assert (Zhi /= 0);\n+         --  We have Hi(Zu)/=0 before normalization. The sequence of Shift_Left\n+         --  operations results in the leading bit of Zu being 1 by moving the\n+         --  leftmost 1-bit in Zu to leading position, thus Zhi=Hi(Zu)/=0 here.\n+\n+         --  Note that when we scale up the dividend, it still fits in four\n+         --  digits, since we already tested for overflow, and scaling does\n+         --  not change the invariant that (D (1) & D (2)) < Zu.\n+\n+         T1 := Shift_Left (D (1) & D (2), Scale);\n+         D (1) := Hi (T1);\n+         T2 := Shift_Left (0 & D (3), Scale);\n+         D (2) := Lo (T1) or Hi (T2);\n+         T3 := Shift_Left (0 & D (4), Scale);\n+         D (3) := Lo (T2) or Hi (T3);\n+         D (4) := Lo (T3);\n+\n+         --  Loop to compute quotient digits, runs twice for Qd(1) and Qd(2)\n+\n+         for J in 0 .. 1 loop\n+\n+            --  Compute next quotient digit. We have to divide three digits by\n+            --  two digits. We estimate the quotient by dividing the leading\n+            --  two digits by the leading digit. Given the scaling we did above\n+            --  which ensured the first bit of the divisor is set, this gives\n+            --  an estimate of the quotient that is at most two too high.\n+\n+            Qd (J + 1) := (if D (J + 1) = Zhi\n+                           then 2 ** Single_Size - 1\n+                           else Lo ((D (J + 1) & D (J + 2)) / Zhi));\n+\n+            --  Compute amount to subtract\n+\n+            T1 := Qd (J + 1) * Zlo;\n+            T2 := Qd (J + 1) * Zhi;\n+            S3 := Lo (T1);\n+            T1 := Hi (T1) + Lo (T2);\n+            S2 := Lo (T1);\n+            S1 := Hi (T1) + Hi (T2);\n+\n+            --  Adjust quotient digit if it was too high\n+\n+            --  We use the version of the algorithm in the 2nd Edition of\n+            --  \"The Art of Computer Programming\". This had a bug not\n+            --  discovered till 1995, see Vol 2 errata:\n+            --     http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz.\n+            --  Under rare circumstances the expression in the test could\n+            --  overflow. This version was further corrected in 2005, see\n+            --  Vol 2 errata:\n+            --     http://www-cs-faculty.stanford.edu/~uno/all2-pre.ps.gz.\n+            --  This implementation is not impacted by these bugs, due to the\n+            --  use of a word-size comparison done in function Le3 instead of\n+            --  a comparison on two-word integer quantities in the original\n+            --  algorithm.\n+\n+            loop\n+               exit when Le3 (S1, S2, S3, D (J + 1), D (J + 2), D (J + 3));\n+               Qd (J + 1) := Qd (J + 1) - 1;\n+               Sub3 (S1, S2, S3, 0, Zhi, Zlo);\n+            end loop;\n+\n+            --  Now subtract S1&S2&S3 from D1&D2&D3 ready for next step\n+\n+            Sub3 (D (J + 1), D (J + 2), D (J + 3), S1, S2, S3);\n+         end loop;\n+\n+         --  The two quotient digits are now set, and the remainder of the\n+         --  scaled division is in D3&D4. To get the remainder for the\n+         --  original unscaled division, we rescale this dividend.\n+\n+         --  We rescale the divisor as well, to make the proper comparison\n+         --  for rounding below.\n+\n+         Qu := Qd (1) & Qd (2);\n+         Ru := Shift_Right (D (3) & D (4), Scale);\n+         Zu := Shift_Right (Zu, Scale);\n+      end if;\n+\n+      --  Deal with rounding case\n+\n+      if Round and then Ru > (Zu - Double_Uns'(1)) / Double_Uns'(2) then\n+\n+         --  Protect against wrapping around when rounding, by signaling\n+         --  an overflow when the quotient is too large.\n+\n+         if Qu = Double_Uns'Last then\n+            Raise_Error;\n+         end if;\n+\n+         Qu := Qu + Double_Uns'(1);\n+      end if;\n+\n+      --  Set final signs (RM 4.5.5(27-30))\n+\n+      --  Case of dividend (X * Y) sign positive\n+\n+      if (X >= 0 and then Y >= 0) or else (X < 0 and then Y < 0) then\n+         R := To_Pos_Int (Ru);\n+         Q := (if Z > 0 then To_Pos_Int (Qu) else To_Neg_Int (Qu));\n+\n+      --  Case of dividend (X * Y) sign negative\n+\n+      else\n+         R := To_Neg_Int (Ru);\n+         Q := (if Z > 0 then To_Neg_Int (Qu) else To_Pos_Int (Qu));\n+      end if;\n+   end Scaled_Divide;\n+\n+   ----------\n+   -- Sub3 --\n+   ----------\n+\n+   procedure Sub3 (X1, X2, X3 : in out Single_Uns; Y1, Y2, Y3 : Single_Uns) is\n+   begin\n+      if Y3 > X3 then\n+         if X2 = 0 then\n+            X1 := X1 - 1;\n+         end if;\n+\n+         X2 := X2 - 1;\n+      end if;\n+\n+      X3 := X3 - Y3;\n+\n+      if Y2 > X2 then\n+         X1 := X1 - 1;\n+      end if;\n+\n+      X2 := X2 - Y2;\n+      X1 := X1 - Y1;\n+   end Sub3;\n+\n+   -------------------------------\n+   -- Subtract_With_Ovflo_Check --\n+   -------------------------------\n+\n+   function Subtract_With_Ovflo_Check (X, Y : Double_Int) return Double_Int is\n+      R : constant Double_Int := To_Int (To_Uns (X) - To_Uns (Y));\n+\n+   begin\n+      if X >= 0 then\n+         if Y > 0 or else R >= 0 then\n+            return R;\n+         end if;\n+\n+      else -- X < 0\n+         if Y <= 0 or else R < 0 then\n+            return R;\n+         end if;\n+      end if;\n+\n+      Raise_Error;\n+   end Subtract_With_Ovflo_Check;\n+\n+   ----------------\n+   -- To_Neg_Int --\n+   ----------------\n+\n+   function To_Neg_Int (A : Double_Uns) return Double_Int is\n+      R : constant Double_Int :=\n+        (if A = 2 ** (Double_Size - 1) then Double_Int'First else -To_Int (A));\n+      --  Note that we can't just use the expression of the Else, because it\n+      --  overflows for A = 2 ** (Double_Size - 1).\n+   begin\n+      if R <= 0 then\n+         return R;\n+      else\n+         Raise_Error;\n+      end if;\n+   end To_Neg_Int;\n+\n+   ----------------\n+   -- To_Pos_Int --\n+   ----------------\n+\n+   function To_Pos_Int (A : Double_Uns) return Double_Int is\n+      R : constant Double_Int := To_Int (A);\n+   begin\n+      if R >= 0 then\n+         return R;\n+      else\n+         Raise_Error;\n+      end if;\n+   end To_Pos_Int;\n+\n+end System.Arith_Double;"}, {"sha": "f9c03e51afdd23cf66a8f94a756b3f91e9fa16c5", "filename": "gcc/ada/libgnat/s-aridou.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,94 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . A R I T H _ D O U B L E                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides software routines for doing arithmetic on \"double\"\n+--  signed integer values in cases where either overflow checking is required,\n+--  or intermediate results are longer than the result type.\n+\n+generic\n+\n+   type Double_Int is range <>;\n+\n+   type Double_Uns is mod <>;\n+\n+   type Single_Uns is mod <>;\n+\n+   with function Shift_Left (A : Double_Uns; B : Natural) return Double_Uns\n+     is <>;\n+\n+   with function Shift_Right (A : Double_Uns; B : Natural) return Double_Uns\n+     is <>;\n+\n+   with function Shift_Left (A : Single_Uns; B : Natural) return Single_Uns\n+     is <>;\n+\n+package System.Arith_Double is\n+   pragma Pure;\n+\n+   function Add_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   --  Raises Constraint_Error if sum of operands overflows Double_Int,\n+   --  otherwise returns the signed integer sum.\n+\n+   function Subtract_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   --  Raises Constraint_Error if difference of operands overflows Double_Int,\n+   --  otherwise returns the signed integer difference.\n+\n+   function Multiply_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   pragma Convention (C, Multiply_With_Ovflo_Check);\n+   --  Raises Constraint_Error if product of operands overflows Double_Int,\n+   --  otherwise returns the signed integer product. Gigi may also call this\n+   --  routine directly.\n+\n+   procedure Scaled_Divide\n+     (X, Y, Z : Double_Int;\n+      Q, R    : out Double_Int;\n+      Round   : Boolean);\n+   --  Performs the division of (X * Y) / Z, storing the quotient in Q\n+   --  and the remainder in R. Constraint_Error is raised if Z is zero,\n+   --  or if the quotient does not fit in Double_Int. Round indicates if\n+   --  the result should be rounded. If Round is False, then Q, R are\n+   --  the normal quotient and remainder from a truncating division.\n+   --  If Round is True, then Q is the rounded quotient. The remainder\n+   --  R is not affected by the setting of the Round flag.\n+\n+   procedure Double_Divide\n+     (X, Y, Z : Double_Int;\n+      Q, R    : out Double_Int;\n+      Round   : Boolean);\n+   --  Performs the division X / (Y * Z), storing the quotient in Q and\n+   --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n+   --  or if the quotient does not fit in Double_Int. Round indicates if the\n+   --  result should be rounded. If Round is False, then Q, R are the normal\n+   --  quotient and remainder from a truncating division. If Round is True,\n+   --  then Q is the rounded quotient. The remainder R is not affected by the\n+   --  setting of the Round flag.\n+\n+end System.Arith_Double;"}, {"sha": "82c8fc357cb2f788342df0fc29ed783f4abbcb42", "filename": "gcc/ada/libgnat/s-arit128.adb", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit128.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . A R I T H _ 1 2 8                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Arith_Double;\n+\n+package body System.Arith_128 is\n+\n+   subtype Uns128 is Interfaces.Unsigned_128;\n+   subtype Uns64  is Interfaces.Unsigned_64;\n+\n+   use Interfaces;\n+\n+   package Impl is new Arith_Double (Int128, Uns128, Uns64);\n+\n+   function Add_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+     renames Impl.Add_With_Ovflo_Check;\n+\n+   function Subtract_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+     renames Impl.Subtract_With_Ovflo_Check;\n+\n+   function Multiply_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+     renames Impl.Multiply_With_Ovflo_Check;\n+\n+   procedure Scaled_Divide128\n+     (X, Y, Z : Int128;\n+      Q, R    : out Int128;\n+      Round   : Boolean)\n+     renames Impl.Scaled_Divide;\n+\n+   procedure Double_Divide128\n+     (X, Y, Z : Int128;\n+      Q, R    : out Int128;\n+      Round   : Boolean)\n+     renames Impl.Double_Divide;\n+\n+end System.Arith_128;"}, {"sha": "55154daf370961f741ada8941130ce402afe919c", "filename": "gcc/ada/libgnat/s-arit128.ads", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit128.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,84 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . A R I T H _ 1 2 8                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit provides software routines for doing arithmetic on 128-bit\n+--  signed integer values in cases where either overflow checking is\n+--  required, or intermediate results are longer than 128 bits.\n+\n+pragma Restrictions (No_Elaboration_Code);\n+--  Allow direct call from gigi generated code\n+\n+with Interfaces;\n+\n+package System.Arith_128 is\n+   pragma Pure;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   function Add_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   --  Raises Constraint_Error if sum of operands overflows 128 bits,\n+   --  otherwise returns the 128-bit signed integer sum.\n+\n+   function Subtract_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   --  Raises Constraint_Error if difference of operands overflows 128\n+   --  bits, otherwise returns the 128-bit signed integer difference.\n+\n+   function Multiply_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   pragma Export (C, Multiply_With_Ovflo_Check128, \"__gnat_mulv128\");\n+   --  Raises Constraint_Error if product of operands overflows 128\n+   --  bits, otherwise returns the 128-bit signed integer product.\n+   --  Gigi may also call this routine directly.\n+\n+   procedure Scaled_Divide128\n+     (X, Y, Z : Int128;\n+      Q, R    : out Int128;\n+      Round   : Boolean);\n+   --  Performs the division of (X * Y) / Z, storing the quotient in Q\n+   --  and the remainder in R. Constraint_Error is raised if Z is zero,\n+   --  or if the quotient does not fit in 128 bits. Round indicates if\n+   --  the result should be rounded. If Round is False, then Q, R are\n+   --  the normal quotient and remainder from a truncating division.\n+   --  If Round is True, then Q is the rounded quotient. The remainder\n+   --  R is not affected by the setting of the Round flag.\n+\n+   procedure Double_Divide128\n+     (X, Y, Z : Int128;\n+      Q, R    : out Int128;\n+      Round   : Boolean);\n+   --  Performs the division X / (Y * Z), storing the quotient in Q and\n+   --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n+   --  or if the quotient does not fit in 128 bits. Round indicates if the\n+   --  result should be rounded. If Round is False, then Q, R are the normal\n+   --  quotient and remainder from a truncating division. If Round is True,\n+   --  then Q is the rounded quotient. The remainder R is not affected by the\n+   --  setting of the Round flag.\n+\n+end System.Arith_128;"}, {"sha": "a4d60f2d95f433f6c4ff8c0c33f6d13ee100e178", "filename": "gcc/ada/libgnat/s-arit64.adb", "status": "modified", "additions": 15, "deletions": 628, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,649 +29,36 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Interfaces; use Interfaces;\n-\n-with Ada.Unchecked_Conversion;\n+with System.Arith_Double;\n \n package body System.Arith_64 is\n \n-   pragma Suppress (Overflow_Check);\n-   pragma Suppress (Range_Check);\n-\n-   subtype Uns64 is Unsigned_64;\n-   function To_Uns is new Ada.Unchecked_Conversion (Int64, Uns64);\n-   function To_Int is new Ada.Unchecked_Conversion (Uns64, Int64);\n-\n-   subtype Uns32 is Unsigned_32;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function \"+\" (A, B : Uns32) return Uns64 is (Uns64 (A) + Uns64 (B));\n-   function \"+\" (A : Uns64; B : Uns32) return Uns64 is (A + Uns64 (B));\n-   --  Length doubling additions\n-\n-   function \"*\" (A, B : Uns32) return Uns64 is (Uns64 (A) * Uns64 (B));\n-   --  Length doubling multiplication\n-\n-   function \"/\" (A : Uns64; B : Uns32) return Uns64 is (A / Uns64 (B));\n-   --  Length doubling division\n-\n-   function \"&\" (Hi, Lo : Uns32) return Uns64 is\n-     (Shift_Left (Uns64 (Hi), 32) or Uns64 (Lo));\n-   --  Concatenate hi, lo values to form 64-bit result\n-\n-   function \"abs\" (X : Int64) return Uns64 is\n-     (if X = Int64'First then 2**63 else Uns64 (Int64'(abs X)));\n-   --  Convert absolute value of X to unsigned. Note that we can't just use\n-   --  the expression of the Else, because it overflows for X = Int64'First.\n-\n-   function \"rem\" (A : Uns64; B : Uns32) return Uns64 is (A rem Uns64 (B));\n-   --  Length doubling remainder\n-\n-   function Le3 (X1, X2, X3 : Uns32; Y1, Y2, Y3 : Uns32) return Boolean;\n-   --  Determines if 96 bit value X1&X2&X3 <= Y1&Y2&Y3\n-\n-   function Lo (A : Uns64) return Uns32 is (Uns32 (A and 16#FFFF_FFFF#));\n-   --  Low order half of 64-bit value\n-\n-   function Hi (A : Uns64) return Uns32 is (Uns32 (Shift_Right (A, 32)));\n-   --  High order half of 64-bit value\n-\n-   procedure Sub3 (X1, X2, X3 : in out Uns32; Y1, Y2, Y3 : Uns32);\n-   --  Computes X1&X2&X3 := X1&X2&X3 - Y1&Y1&Y3 with mod 2**96 wrap\n-\n-   function To_Neg_Int (A : Uns64) return Int64 with Inline;\n-   --  Convert to negative integer equivalent. If the input is in the range\n-   --  0 .. 2 ** 63, then the corresponding negative signed integer (obtained\n-   --  by negating the given value) is returned, otherwise constraint error\n-   --  is raised.\n-\n-   function To_Pos_Int (A : Uns64) return Int64 with Inline;\n-   --  Convert to positive integer equivalent. If the input is in the range\n-   --  0 .. 2 ** 63-1, then the corresponding non-negative signed integer is\n-   --  returned, otherwise constraint error is raised.\n-\n-   procedure Raise_Error with Inline;\n-   pragma No_Return (Raise_Error);\n-   --  Raise constraint error with appropriate message\n-\n-   --------------------------\n-   -- Add_With_Ovflo_Check --\n-   --------------------------\n+   subtype Uns64 is Interfaces.Unsigned_64;\n+   subtype Uns32 is Interfaces.Unsigned_32;\n \n-   function Add_With_Ovflo_Check (X, Y : Int64) return Int64 is\n-      R : constant Int64 := To_Int (To_Uns (X) + To_Uns (Y));\n+   use Interfaces;\n \n-   begin\n-      if X >= 0 then\n-         if Y < 0 or else R >= 0 then\n-            return R;\n-         end if;\n+   package Impl is new Arith_Double (Int64, Uns64, Uns32);\n \n-      else -- X < 0\n-         if Y > 0 or else R < 0 then\n-            return R;\n-         end if;\n-      end if;\n+   function Add_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+     renames Impl.Add_With_Ovflo_Check;\n \n-      Raise_Error;\n-   end Add_With_Ovflo_Check;\n+   function Subtract_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+     renames Impl.Subtract_With_Ovflo_Check;\n \n-   -------------------\n-   -- Double_Divide --\n-   -------------------\n+   function Multiply_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+     renames Impl.Multiply_With_Ovflo_Check;\n \n-   procedure Double_Divide\n+   procedure Scaled_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n       Round   : Boolean)\n-   is\n-      Xu  : constant Uns64 := abs X;\n-      Yu  : constant Uns64 := abs Y;\n-\n-      Yhi : constant Uns32 := Hi (Yu);\n-      Ylo : constant Uns32 := Lo (Yu);\n-\n-      Zu  : constant Uns64 := abs Z;\n-      Zhi : constant Uns32 := Hi (Zu);\n-      Zlo : constant Uns32 := Lo (Zu);\n-\n-      T1, T2     : Uns64;\n-      Du, Qu, Ru : Uns64;\n-      Den_Pos    : Boolean;\n-\n-   begin\n-      if Yu = 0 or else Zu = 0 then\n-         Raise_Error;\n-      end if;\n-\n-      --  Set final signs (RM 4.5.5(27-30))\n-\n-      Den_Pos := (Y < 0) = (Z < 0);\n-\n-      --  Compute Y * Z. Note that if the result overflows 64 bits unsigned,\n-      --  then the rounded result is zero, except for the very special case\n-      --  where X = -2**63 and abs(Y*Z) = 2**64, when Round is True.\n-\n-      if Yhi /= 0 then\n-         if Zhi /= 0 then\n-\n-            --  Handle the special case when Round is True\n-\n-            if Yhi = 1\n-              and then Zhi = 1\n-              and then Ylo = 0\n-              and then Zlo = 0\n-              and then X = Int64'First\n-              and then Round\n-            then\n-               Q := (if Den_Pos then -1 else 1);\n-            else\n-               Q := 0;\n-            end if;\n-\n-            R := X;\n-            return;\n-         else\n-            T2 := Yhi * Zlo;\n-         end if;\n-\n-      else\n-         T2 := Ylo * Zhi;\n-      end if;\n-\n-      T1 := Ylo * Zlo;\n-      T2 := T2 + Hi (T1);\n-\n-      if Hi (T2) /= 0 then\n-\n-         --  Handle the special case when Round is True\n-\n-         if Hi (T2) = 1\n-           and then Lo (T2) = 0\n-           and then Lo (T1) = 0\n-           and then X = Int64'First\n-           and then Round\n-         then\n-            Q := (if Den_Pos then -1 else 1);\n-         else\n-            Q := 0;\n-         end if;\n-\n-         R := X;\n-         return;\n-      end if;\n+     renames Impl.Scaled_Divide;\n \n-      Du := Lo (T2) & Lo (T1);\n-\n-      --  Check overflow case of largest negative number divided by -1\n-\n-      if X = Int64'First and then Du = 1 and then not Den_Pos then\n-         Raise_Error;\n-      end if;\n-\n-      --  Perform the actual division\n-\n-      pragma Assert (Du /= 0);\n-      --  Multiplication of 2-limbs arguments Yu and Zu leads to 4-limbs\n-      --  result (where each limb is 32bits). Cases where 4 limbs are needed\n-      --  require Yhi/=0 and Zhi/=0 and lead to early exit. Remaining cases\n-      --  where 3 limbs are needed correspond to Hi(T2)/=0 and lead to\n-      --  early exit. Thus at this point result fits in 2 limbs which are\n-      --  exactly Lo(T2) and Lo(T1), which corresponds to the value of Du.\n-      --  As the case where one of Yu or Zu is null also led to early exit,\n-      --  Du/=0 here.\n-      Qu := Xu / Du;\n-      Ru := Xu rem Du;\n-\n-      --  Deal with rounding case\n-\n-      if Round and then Ru > (Du - Uns64'(1)) / Uns64'(2) then\n-         Qu := Qu + Uns64'(1);\n-      end if;\n-\n-      --  Case of dividend (X) sign positive\n-\n-      if X >= 0 then\n-         R := To_Int (Ru);\n-         Q := (if Den_Pos then To_Int (Qu) else -To_Int (Qu));\n-\n-      --  Case of dividend (X) sign negative\n-\n-      --  We perform the unary minus operation on the unsigned value\n-      --  before conversion to signed, to avoid a possible overflow for\n-      --  value -2**63, both for computing R and Q.\n-\n-      else\n-         R := To_Int (-Ru);\n-         Q := (if Den_Pos then To_Int (-Qu) else To_Int (Qu));\n-      end if;\n-   end Double_Divide;\n-\n-   ---------\n-   -- Le3 --\n-   ---------\n-\n-   function Le3 (X1, X2, X3 : Uns32; Y1, Y2, Y3 : Uns32) return Boolean is\n-   begin\n-      if X1 < Y1 then\n-         return True;\n-      elsif X1 > Y1 then\n-         return False;\n-      elsif X2 < Y2 then\n-         return True;\n-      elsif X2 > Y2 then\n-         return False;\n-      else\n-         return X3 <= Y3;\n-      end if;\n-   end Le3;\n-\n-   -------------------------------\n-   -- Multiply_With_Ovflo_Check --\n-   -------------------------------\n-\n-   function Multiply_With_Ovflo_Check (X, Y : Int64) return Int64 is\n-      Xu  : constant Uns64 := abs X;\n-      Xhi : constant Uns32 := Hi (Xu);\n-      Xlo : constant Uns32 := Lo (Xu);\n-\n-      Yu  : constant Uns64 := abs Y;\n-      Yhi : constant Uns32 := Hi (Yu);\n-      Ylo : constant Uns32 := Lo (Yu);\n-\n-      T1, T2 : Uns64;\n-\n-   begin\n-      if Xhi /= 0 then\n-         if Yhi /= 0 then\n-            Raise_Error;\n-         else\n-            T2 := Xhi * Ylo;\n-         end if;\n-\n-      elsif Yhi /= 0 then\n-         T2 := Xlo * Yhi;\n-\n-      else -- Yhi = Xhi = 0\n-         T2 := 0;\n-      end if;\n-\n-      --  Here we have T2 set to the contribution to the upper half of the\n-      --  result from the upper halves of the input values.\n-\n-      T1 := Xlo * Ylo;\n-      T2 := T2 + Hi (T1);\n-\n-      if Hi (T2) /= 0 then\n-         Raise_Error;\n-      end if;\n-\n-      T2 := Lo (T2) & Lo (T1);\n-\n-      if X >= 0 then\n-         if Y >= 0 then\n-            return To_Pos_Int (T2);\n-            pragma Annotate (CodePeer, Intentional, \"precondition\",\n-                             \"Intentional Unsigned->Signed conversion\");\n-         else\n-            return To_Neg_Int (T2);\n-         end if;\n-      else -- X < 0\n-         if Y < 0 then\n-            return To_Pos_Int (T2);\n-            pragma Annotate (CodePeer, Intentional, \"precondition\",\n-                             \"Intentional Unsigned->Signed conversion\");\n-         else\n-            return To_Neg_Int (T2);\n-         end if;\n-      end if;\n-\n-   end Multiply_With_Ovflo_Check;\n-\n-   -----------------\n-   -- Raise_Error --\n-   -----------------\n-\n-   procedure Raise_Error is\n-   begin\n-      raise Constraint_Error with \"64-bit arithmetic overflow\";\n-   end Raise_Error;\n-\n-   -------------------\n-   -- Scaled_Divide --\n-   -------------------\n-\n-   procedure Scaled_Divide\n+   procedure Double_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n       Round   : Boolean)\n-   is\n-      Xu  : constant Uns64 := abs X;\n-      Xhi : constant Uns32 := Hi (Xu);\n-      Xlo : constant Uns32 := Lo (Xu);\n-\n-      Yu  : constant Uns64 := abs Y;\n-      Yhi : constant Uns32 := Hi (Yu);\n-      Ylo : constant Uns32 := Lo (Yu);\n-\n-      Zu  : Uns64 := abs Z;\n-      Zhi : Uns32 := Hi (Zu);\n-      Zlo : Uns32 := Lo (Zu);\n-\n-      D : array (1 .. 4) of Uns32;\n-      --  The dividend, four digits (D(1) is high order)\n-\n-      Qd : array (1 .. 2) of Uns32;\n-      --  The quotient digits, two digits (Qd(1) is high order)\n-\n-      S1, S2, S3 : Uns32;\n-      --  Value to subtract, three digits (S1 is high order)\n-\n-      Qu : Uns64;\n-      Ru : Uns64;\n-      --  Unsigned quotient and remainder\n-\n-      Scale : Natural;\n-      --  Scaling factor used for multiple-precision divide. Dividend and\n-      --  Divisor are multiplied by 2 ** Scale, and the final remainder is\n-      --  divided by the scaling factor. The reason for this scaling is to\n-      --  allow more accurate estimation of quotient digits.\n-\n-      T1, T2, T3 : Uns64;\n-      --  Temporary values\n-\n-   begin\n-      --  First do the multiplication, giving the four digit dividend\n-\n-      T1 := Xlo * Ylo;\n-      D (4) := Lo (T1);\n-      D (3) := Hi (T1);\n-\n-      if Yhi /= 0 then\n-         T1 := Xlo * Yhi;\n-         T2 := D (3) + Lo (T1);\n-         D (3) := Lo (T2);\n-         D (2) := Hi (T1) + Hi (T2);\n-\n-         if Xhi /= 0 then\n-            T1 := Xhi * Ylo;\n-            T2 := D (3) + Lo (T1);\n-            D (3) := Lo (T2);\n-            T3 := D (2) + Hi (T1);\n-            T3 := T3 + Hi (T2);\n-            D (2) := Lo (T3);\n-            D (1) := Hi (T3);\n-\n-            T1 := (D (1) & D (2)) + Uns64'(Xhi * Yhi);\n-            D (1) := Hi (T1);\n-            D (2) := Lo (T1);\n-\n-         else\n-            D (1) := 0;\n-         end if;\n-\n-      else\n-         if Xhi /= 0 then\n-            T1 := Xhi * Ylo;\n-            T2 := D (3) + Lo (T1);\n-            D (3) := Lo (T2);\n-            D (2) := Hi (T1) + Hi (T2);\n-\n-         else\n-            D (2) := 0;\n-         end if;\n-\n-         D (1) := 0;\n-      end if;\n-\n-      --  Now it is time for the dreaded multiple precision division. First an\n-      --  easy case, check for the simple case of a one digit divisor.\n-\n-      if Zhi = 0 then\n-         if D (1) /= 0 or else D (2) >= Zlo then\n-            Raise_Error;\n-\n-         --  Here we are dividing at most three digits by one digit\n-\n-         else\n-            T1 := D (2) & D (3);\n-            T2 := Lo (T1 rem Zlo) & D (4);\n-\n-            Qu := Lo (T1 / Zlo) & Lo (T2 / Zlo);\n-            Ru := T2 rem Zlo;\n-         end if;\n-\n-      --  If divisor is double digit and dividend is too large, raise error\n-\n-      elsif (D (1) & D (2)) >= Zu then\n-         Raise_Error;\n-\n-      --  This is the complex case where we definitely have a double digit\n-      --  divisor and a dividend of at least three digits. We use the classical\n-      --  multiple-precision division algorithm (see section (4.3.1) of Knuth's\n-      --  \"The Art of Computer Programming\", Vol. 2 for a description\n-      --  (algorithm D).\n-\n-      else\n-         --  First normalize the divisor so that it has the leading bit on.\n-         --  We do this by finding the appropriate left shift amount.\n-\n-         Scale := 0;\n-\n-         if (Zhi and 16#FFFF0000#) = 0 then\n-            Scale := 16;\n-            Zu := Shift_Left (Zu, 16);\n-         end if;\n-\n-         if (Hi (Zu) and 16#FF00_0000#) = 0 then\n-            Scale := Scale + 8;\n-            Zu := Shift_Left (Zu, 8);\n-         end if;\n-\n-         if (Hi (Zu) and 16#F000_0000#) = 0 then\n-            Scale := Scale + 4;\n-            Zu := Shift_Left (Zu, 4);\n-         end if;\n-\n-         if (Hi (Zu) and 16#C000_0000#) = 0 then\n-            Scale := Scale + 2;\n-            Zu := Shift_Left (Zu, 2);\n-         end if;\n-\n-         if (Hi (Zu) and 16#8000_0000#) = 0 then\n-            Scale := Scale + 1;\n-            Zu := Shift_Left (Zu, 1);\n-         end if;\n-\n-         Zhi := Hi (Zu);\n-         Zlo := Lo (Zu);\n-\n-         pragma Assert (Zhi /= 0);\n-         --  Hi(Zu)/=0 before normalization. The sequence of Shift_Left\n-         --  operations results in the leading bit of Zu being 1 by moving\n-         --  the leftmost 1-bit in Zu to leading position, thus Zhi=Hi(Zu)/=0\n-         --  here.\n-\n-         --  Note that when we scale up the dividend, it still fits in four\n-         --  digits, since we already tested for overflow, and scaling does\n-         --  not change the invariant that (D (1) & D (2)) < Zu.\n-\n-         T1 := Shift_Left (D (1) & D (2), Scale);\n-         D (1) := Hi (T1);\n-         T2 := Shift_Left (0 & D (3), Scale);\n-         D (2) := Lo (T1) or Hi (T2);\n-         T3 := Shift_Left (0 & D (4), Scale);\n-         D (3) := Lo (T2) or Hi (T3);\n-         D (4) := Lo (T3);\n-\n-         --  Loop to compute quotient digits, runs twice for Qd(1) and Qd(2)\n-\n-         for J in 0 .. 1 loop\n-\n-            --  Compute next quotient digit. We have to divide three digits by\n-            --  two digits. We estimate the quotient by dividing the leading\n-            --  two digits by the leading digit. Given the scaling we did above\n-            --  which ensured the first bit of the divisor is set, this gives\n-            --  an estimate of the quotient that is at most two too high.\n-\n-            Qd (J + 1) := (if D (J + 1) = Zhi\n-                           then 2 ** 32 - 1\n-                           else Lo ((D (J + 1) & D (J + 2)) / Zhi));\n-\n-            --  Compute amount to subtract\n-\n-            T1 := Qd (J + 1) * Zlo;\n-            T2 := Qd (J + 1) * Zhi;\n-            S3 := Lo (T1);\n-            T1 := Hi (T1) + Lo (T2);\n-            S2 := Lo (T1);\n-            S1 := Hi (T1) + Hi (T2);\n-\n-            --  Adjust quotient digit if it was too high\n-\n-            --  We use the version of the algorithm in the 2nd Edition of\n-            --  \"The Art of Computer Programming\". This had a bug not\n-            --  discovered till 1995, see Vol 2 errata:\n-            --     http://www-cs-faculty.stanford.edu/~uno/err2-2e.ps.gz.\n-            --  Under rare circumstances the expression in the test could\n-            --  overflow. This version was further corrected in 2005, see\n-            --  Vol 2 errata:\n-            --     http://www-cs-faculty.stanford.edu/~uno/all2-pre.ps.gz.\n-            --  This implementation is not impacted by these bugs, due to the\n-            --  use of a word-size comparison done in function Le3 instead of\n-            --  a comparison on two-word integer quantities in the original\n-            --  algorithm.\n-\n-            loop\n-               exit when Le3 (S1, S2, S3, D (J + 1), D (J + 2), D (J + 3));\n-               Qd (J + 1) := Qd (J + 1) - 1;\n-               Sub3 (S1, S2, S3, 0, Zhi, Zlo);\n-            end loop;\n-\n-            --  Now subtract S1&S2&S3 from D1&D2&D3 ready for next step\n-\n-            Sub3 (D (J + 1), D (J + 2), D (J + 3), S1, S2, S3);\n-         end loop;\n-\n-         --  The two quotient digits are now set, and the remainder of the\n-         --  scaled division is in D3&D4. To get the remainder for the\n-         --  original unscaled division, we rescale this dividend.\n-\n-         --  We rescale the divisor as well, to make the proper comparison\n-         --  for rounding below.\n-\n-         Qu := Qd (1) & Qd (2);\n-         Ru := Shift_Right (D (3) & D (4), Scale);\n-         Zu := Shift_Right (Zu, Scale);\n-      end if;\n-\n-      --  Deal with rounding case\n-\n-      if Round and then Ru > (Zu - Uns64'(1)) / Uns64'(2) then\n-\n-         --  Protect against wrapping around when rounding, by signaling\n-         --  an overflow when the quotient is too large.\n-\n-         if Qu = Uns64'Last then\n-            Raise_Error;\n-         end if;\n-\n-         Qu := Qu + Uns64 (1);\n-      end if;\n-\n-      --  Set final signs (RM 4.5.5(27-30))\n-\n-      --  Case of dividend (X * Y) sign positive\n-\n-      if (X >= 0 and then Y >= 0) or else (X < 0 and then Y < 0) then\n-         R := To_Pos_Int (Ru);\n-         Q := (if Z > 0 then To_Pos_Int (Qu) else To_Neg_Int (Qu));\n-\n-      --  Case of dividend (X * Y) sign negative\n-\n-      else\n-         R := To_Neg_Int (Ru);\n-         Q := (if Z > 0 then To_Neg_Int (Qu) else To_Pos_Int (Qu));\n-      end if;\n-   end Scaled_Divide;\n-\n-   ----------\n-   -- Sub3 --\n-   ----------\n-\n-   procedure Sub3 (X1, X2, X3 : in out Uns32; Y1, Y2, Y3 : Uns32) is\n-   begin\n-      if Y3 > X3 then\n-         if X2 = 0 then\n-            X1 := X1 - 1;\n-         end if;\n-\n-         X2 := X2 - 1;\n-      end if;\n-\n-      X3 := X3 - Y3;\n-\n-      if Y2 > X2 then\n-         X1 := X1 - 1;\n-      end if;\n-\n-      X2 := X2 - Y2;\n-      X1 := X1 - Y1;\n-   end Sub3;\n-\n-   -------------------------------\n-   -- Subtract_With_Ovflo_Check --\n-   -------------------------------\n-\n-   function Subtract_With_Ovflo_Check (X, Y : Int64) return Int64 is\n-      R : constant Int64 := To_Int (To_Uns (X) - To_Uns (Y));\n-\n-   begin\n-      if X >= 0 then\n-         if Y > 0 or else R >= 0 then\n-            return R;\n-         end if;\n-\n-      else -- X < 0\n-         if Y <= 0 or else R < 0 then\n-            return R;\n-         end if;\n-      end if;\n-\n-      Raise_Error;\n-   end Subtract_With_Ovflo_Check;\n-\n-   ----------------\n-   -- To_Neg_Int --\n-   ----------------\n-\n-   function To_Neg_Int (A : Uns64) return Int64 is\n-      R : constant Int64 := (if A = 2**63 then Int64'First else -To_Int (A));\n-      --  Note that we can't just use the expression of the Else, because it\n-      --  overflows for A = 2**63.\n-   begin\n-      if R <= 0 then\n-         return R;\n-      else\n-         Raise_Error;\n-      end if;\n-   end To_Neg_Int;\n-\n-   ----------------\n-   -- To_Pos_Int --\n-   ----------------\n-\n-   function To_Pos_Int (A : Uns64) return Int64 is\n-      R : constant Int64 := To_Int (A);\n-   begin\n-      if R >= 0 then\n-         return R;\n-      else\n-         Raise_Error;\n-      end if;\n-   end To_Pos_Int;\n+     renames Impl.Double_Divide;\n \n end System.Arith_64;"}, {"sha": "90d5c2557bbaeb098e5fe6c864da4bec665c2721", "filename": "gcc/ada/libgnat/s-arit64.ads", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -43,42 +43,54 @@ package System.Arith_64 is\n \n    subtype Int64 is Interfaces.Integer_64;\n \n-   function Add_With_Ovflo_Check (X, Y : Int64) return Int64;\n+   function Add_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n    --  Raises Constraint_Error if sum of operands overflows 64 bits,\n    --  otherwise returns the 64-bit signed integer sum.\n \n-   function Subtract_With_Ovflo_Check (X, Y : Int64) return Int64;\n+   function Subtract_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n    --  Raises Constraint_Error if difference of operands overflows 64\n    --  bits, otherwise returns the 64-bit signed integer difference.\n \n-   function Multiply_With_Ovflo_Check (X, Y : Int64) return Int64;\n-   pragma Export (C, Multiply_With_Ovflo_Check, \"__gnat_mulv64\");\n+   function Multiply_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n+   pragma Export (C, Multiply_With_Ovflo_Check64, \"__gnat_mulv64\");\n    --  Raises Constraint_Error if product of operands overflows 64\n    --  bits, otherwise returns the 64-bit signed integer product.\n-   --  GIGI may also call this routine directly.\n+   --  Gigi may also call this routine directly.\n \n-   procedure Scaled_Divide\n+   procedure Scaled_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n       Round   : Boolean);\n    --  Performs the division of (X * Y) / Z, storing the quotient in Q\n    --  and the remainder in R. Constraint_Error is raised if Z is zero,\n-   --  or if the quotient does not fit in 64-bits. Round indicates if\n+   --  or if the quotient does not fit in 64 bits. Round indicates if\n    --  the result should be rounded. If Round is False, then Q, R are\n    --  the normal quotient and remainder from a truncating division.\n    --  If Round is True, then Q is the rounded quotient. The remainder\n    --  R is not affected by the setting of the Round flag.\n \n-   procedure Double_Divide\n+   procedure Scaled_Divide\n+     (X, Y, Z : Int64;\n+      Q, R    : out Int64;\n+      Round   : Boolean) renames Scaled_Divide64;\n+   --  Renamed procedure to preserve compatibility with earlier versions\n+\n+   procedure Double_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n       Round   : Boolean);\n    --  Performs the division X / (Y * Z), storing the quotient in Q and\n    --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n-   --  or if the quotient does not fit in 64-bits. Round indicates if the\n+   --  or if the quotient does not fit in 64 bits. Round indicates if the\n    --  result should be rounded. If Round is False, then Q, R are the normal\n    --  quotient and remainder from a truncating division. If Round is True,\n    --  then Q is the rounded quotient. The remainder R is not affected by the\n    --  setting of the Round flag.\n \n+   procedure Double_Divide\n+     (X, Y, Z : Int64;\n+      Q, R    : out Int64;\n+      Round   : Boolean) renames Double_Divide64;\n+   --  Renamed procedure to preserve compatibility with earlier versions\n+\n end System.Arith_64;"}, {"sha": "1eac50db0dcbcd5d54e9b6f27a9fb2423dc4c689", "filename": "gcc/ada/libgnat/s-bytswa.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bytswa.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -33,13 +33,16 @@\n --  (supporting alternative byte ordering), and by the GNAT.Byte_Swapping run\n --  time package which provides user level routines for byte swapping.\n \n+with Interfaces;\n+\n package System.Byte_Swapping is\n \n    pragma Pure;\n \n-   type U16 is mod 2**16;\n-   type U32 is mod 2**32;\n-   type U64 is mod 2**64;\n+   subtype U16  is Interfaces.Unsigned_16;\n+   subtype U32  is Interfaces.Unsigned_32;\n+   subtype U64  is Interfaces.Unsigned_64;\n+   subtype U128 is Interfaces.Unsigned_128;\n \n    function Bswap_16 (X : U16) return U16;\n    pragma Import (Intrinsic, Bswap_16, \"__builtin_bswap16\");\n@@ -50,4 +53,7 @@ package System.Byte_Swapping is\n    function Bswap_64 (X : U64) return U64;\n    pragma Import (Intrinsic, Bswap_64, \"__builtin_bswap64\");\n \n+   function Bswap_128 (X : U128) return U128;\n+   pragma Import (Intrinsic, Bswap_128, \"__builtin_bswap128\");\n+\n end System.Byte_Swapping;"}, {"sha": "96a8f3dd6b3b27c01ecd7c5b3bea8b15e1efce05", "filename": "gcc/ada/libgnat/s-casi128.adb", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-casi128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-casi128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-casi128.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                    GNAT RUN-TIME LIBRARY COMPONENTS                      --\n+--                                                                          --\n+--       S Y S T E M . C O M P A R E _ A R R A Y _ S I G N E D _ 1 2 8      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2002-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Address_Operations; use System.Address_Operations;\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Compare_Array_Signed_128 is\n+\n+   type Word is range -2**127 .. 2**127 - 1;\n+   for Word'Size use 128;\n+   --  Used to process operands by 128-bit words\n+\n+   type Uword is new Word;\n+   for Uword'Alignment use 1;\n+   --  Used to process operands when unaligned\n+\n+   type WP is access Word;\n+   type UP is access Uword;\n+\n+   function W is new Ada.Unchecked_Conversion (Address, WP);\n+   function U is new Ada.Unchecked_Conversion (Address, UP);\n+\n+   ------------------------\n+   -- Compare_Array_S128 --\n+   ------------------------\n+\n+   function Compare_Array_S128\n+     (Left      : System.Address;\n+      Right     : System.Address;\n+      Left_Len  : Natural;\n+      Right_Len : Natural) return Integer\n+   is\n+      Clen : Natural := Natural'Min (Left_Len, Right_Len);\n+      --  Number of elements left to compare\n+\n+      L : Address := Left;\n+      R : Address := Right;\n+      --  Pointers to next elements to compare\n+\n+   begin\n+      --  Case of going by aligned quadruple words\n+\n+      if ModA (OrA (Left, Right), 16) = 0 then\n+         while Clen /= 0 loop\n+            if W (L).all /= W (R).all then\n+               if W (L).all > W (R).all then\n+                  return +1;\n+               else\n+                  return -1;\n+               end if;\n+            end if;\n+\n+            Clen := Clen - 1;\n+            L := AddA (L, 16);\n+            R := AddA (R, 16);\n+         end loop;\n+\n+      --  Case of going by unaligned quadruple words\n+\n+      else\n+         while Clen /= 0 loop\n+            if U (L).all /= U (R).all then\n+               if U (L).all > U (R).all then\n+                  return +1;\n+               else\n+                  return -1;\n+               end if;\n+            end if;\n+\n+            Clen := Clen - 1;\n+            L := AddA (L, 16);\n+            R := AddA (R, 16);\n+         end loop;\n+      end if;\n+\n+      --  Here if common section equal, result decided by lengths\n+\n+      if Left_Len = Right_Len then\n+         return 0;\n+      elsif Left_Len > Right_Len then\n+         return +1;\n+      else\n+         return -1;\n+      end if;\n+   end Compare_Array_S128;\n+\n+end System.Compare_Array_Signed_128;"}, {"sha": "0893bad50882913a0f8bf184da8ee2475e858cde", "filename": "gcc/ada/libgnat/s-casi128.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-casi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-casi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-casi128.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                    GNAT RUN-TIME LIBRARY COMPONENTS                      --\n+--                                                                          --\n+--       S Y S T E M . C O M P A R E _ A R R A Y _ S I G N E D _ 1 2 8      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2002-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains functions for runtime comparisons on arrays whose\n+--  elements are 128-bit discrete type values to be treated as signed.\n+\n+package System.Compare_Array_Signed_128 is\n+\n+   --  Note: although the functions in this package are in a sense Pure, the\n+   --  package cannot be declared as Pure, since the arguments are addresses,\n+   --  not the data, and the result is not pure wrt the address values.\n+\n+   function Compare_Array_S128\n+     (Left      : System.Address;\n+      Right     : System.Address;\n+      Left_Len  : Natural;\n+      Right_Len : Natural) return Integer;\n+   --  Compare the array starting at address Left of length Left_Len\n+   --  with the array starting at address Right of length Right_Len.\n+   --  The comparison is in the normal Ada semantic sense of array\n+   --  comparison. The result is -1,0,+1 for Left<Right, Left=Right,\n+   --  Left>Right respectively.\n+\n+end System.Compare_Array_Signed_128;"}, {"sha": "bb69793d54106d5b769396c3487c48852140cf4c", "filename": "gcc/ada/libgnat/s-caun128.adb", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-caun128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-caun128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-caun128.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,115 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                    GNAT RUN-TIME LIBRARY COMPONENTS                      --\n+--                                                                          --\n+--     S Y S T E M . C O M P A R E _ A R R A Y _ U N S I G N E D _ 1 2 8    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2002-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Address_Operations; use System.Address_Operations;\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Compare_Array_Unsigned_128 is\n+\n+   type Word is mod 2 ** 128;\n+   --  Used to process operands by 128-bit words\n+\n+   type Uword is new Word;\n+   for Uword'Alignment use 1;\n+   --  Used to process operands when unaligned\n+\n+   type WP is access Word;\n+   type UP is access Uword;\n+\n+   function W is new Ada.Unchecked_Conversion (Address, WP);\n+   function U is new Ada.Unchecked_Conversion (Address, UP);\n+\n+   ------------------------\n+   -- Compare_Array_U128 --\n+   ------------------------\n+\n+   function Compare_Array_U128\n+     (Left      : System.Address;\n+      Right     : System.Address;\n+      Left_Len  : Natural;\n+      Right_Len : Natural) return Integer\n+   is\n+      Clen : Natural := Natural'Min (Left_Len, Right_Len);\n+      --  Number of elements left to compare\n+\n+      L : Address := Left;\n+      R : Address := Right;\n+      --  Pointers to next elements to compare\n+\n+   begin\n+      --  Case of going by aligned quadruple words\n+\n+      if ModA (OrA (Left, Right), 16) = 0 then\n+         while Clen /= 0 loop\n+            if W (L).all /= W (R).all then\n+               if W (L).all > W (R).all then\n+                  return +1;\n+               else\n+                  return -1;\n+               end if;\n+            end if;\n+\n+            Clen := Clen - 1;\n+            L := AddA (L, 16);\n+            R := AddA (R, 16);\n+         end loop;\n+\n+      --  Case of going by unaligned quadruple words\n+\n+      else\n+         while Clen /= 0 loop\n+            if U (L).all /= U (R).all then\n+               if U (L).all > U (R).all then\n+                  return +1;\n+               else\n+                  return -1;\n+               end if;\n+            end if;\n+\n+            Clen := Clen - 1;\n+            L := AddA (L, 16);\n+            R := AddA (R, 16);\n+         end loop;\n+      end if;\n+\n+      --  Here if common section equal, result decided by lengths\n+\n+      if Left_Len = Right_Len then\n+         return 0;\n+      elsif Left_Len > Right_Len then\n+         return +1;\n+      else\n+         return -1;\n+      end if;\n+   end Compare_Array_U128;\n+\n+end System.Compare_Array_Unsigned_128;"}, {"sha": "c96983da39c90def45b8c240865d72f7c0b47b17", "filename": "gcc/ada/libgnat/s-caun128.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-caun128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-caun128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-caun128.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                    GNAT RUN-TIME LIBRARY COMPONENTS                      --\n+--                                                                          --\n+--     S Y S T E M . C O M P A R E _ A R R A Y _ U N S I G N E D _ 1 2 8    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2002-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains functions for runtime comparisons on arrays whose\n+--  elements are 128-bit discrete type values to be treated as unsigned.\n+\n+package System.Compare_Array_Unsigned_128 is\n+\n+   --  Note: although the functions in this package are in a sense Pure, the\n+   --  package cannot be declared as Pure, since the arguments are addresses,\n+   --  not the data, and the result is not pure wrt the address values.\n+\n+   function Compare_Array_U128\n+     (Left      : System.Address;\n+      Right     : System.Address;\n+      Left_Len  : Natural;\n+      Right_Len : Natural) return Integer;\n+   --  Compare the array starting at address Left of length Left_Len\n+   --  with the array starting at address Right of length Right_Len.\n+   --  The comparison is in the normal Ada semantic sense of array\n+   --  comparison. The result is -1,0,+1 for Left<Right, Left=Right,\n+   --  Left>Right respectively.\n+\n+end System.Compare_Array_Unsigned_128;"}, {"sha": "3914192c1af71c0862d04597155c5a4c2d739461", "filename": "gcc/ada/libgnat/s-exnint.adb", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exnint.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,42 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Exn_Int is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   -----------------\n-   -- Exn_Integer --\n-   -----------------\n-\n-   function Exn_Integer (Left : Integer; Right : Natural) return Integer is\n-      pragma Suppress (Division_Check);\n-      pragma Suppress (Overflow_Check);\n-\n-      Result : Integer := 1;\n-      Factor : Integer := Left;\n-      Exp    : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing base values -1, 0, +1 since\n-      --  the expander does this when the base is a literal, and other cases\n-      --  will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               Result := Result * Factor;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-            Factor := Factor * Factor;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Exn_Integer;\n-\n-end System.Exn_Int;\n+pragma No_Body;"}, {"sha": "ac64e58eb525615890e75f43dc4720d5a7880ab8", "filename": "gcc/ada/libgnat/s-exnint.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exnint.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -31,9 +31,11 @@\n \n --  Integer exponentiation (checks off)\n \n+with System.Exponn;\n+\n package System.Exn_Int is\n-   pragma Pure;\n \n-   function Exn_Integer (Left : Integer; Right : Natural) return Integer;\n+   function Exn_Integer is new Exponn (Integer);\n+   pragma Pure_Function (Exn_Integer);\n \n end System.Exn_Int;"}, {"sha": "b1c33eaa36f1c0b36ba9cd12581b969603beed86", "filename": "gcc/ada/libgnat/s-exnlli.adb", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exnlli.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,46 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Exn_LLI is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   ---------------------------\n-   -- Exn_Long_Long_Integer --\n-   ---------------------------\n-\n-   function Exn_Long_Long_Integer\n-     (Left  : Long_Long_Integer;\n-      Right : Natural)\n-      return  Long_Long_Integer\n-   is\n-      pragma Suppress (Division_Check);\n-      pragma Suppress (Overflow_Check);\n-\n-      Result : Long_Long_Integer := 1;\n-      Factor : Long_Long_Integer := Left;\n-      Exp    : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing base values -1, 0, +1 since\n-      --  the expander does this when the base is a literal, and other cases\n-      --  will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               Result := Result * Factor;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-            Factor := Factor * Factor;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Exn_Long_Long_Integer;\n-\n-end System.Exn_LLI;\n+pragma No_Body;"}, {"sha": "3c2786b748ab6e59b4cd0dfa4f2e60e6060e04d7", "filename": "gcc/ada/libgnat/s-exnlli.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exnlli.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -31,12 +31,11 @@\n \n --  Long_Long_Integer exponentiation (checks off)\n \n+with System.Exponn;\n+\n package System.Exn_LLI is\n-   pragma Pure;\n \n-   function Exn_Long_Long_Integer\n-     (Left  : Long_Long_Integer;\n-      Right : Natural)\n-      return  Long_Long_Integer;\n+   function Exn_Long_Long_Integer is new Exponn (Long_Long_Integer);\n+   pragma Pure_Function (Exn_Long_Long_Integer);\n \n end System.Exn_LLI;"}, {"sha": "9573d7d02afdadbf52b42a63b9de1bf450582ab7", "filename": "gcc/ada/libgnat/s-exnllli.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exnllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exnllli.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . E X N _ L L L I                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Long_Long_Long_Integer exponentiation (checks off)\n+\n+with System.Exponn;\n+\n+package System.Exn_LLLI is\n+\n+   function Exn_Long_Long_Long_Integer is new Exponn (Long_Long_Long_Integer);\n+   pragma Pure_Function (Exn_Long_Long_Long_Integer);\n+\n+end System.Exn_LLLI;"}, {"sha": "489d76815cf261e337664a9e55b776595a5c7357", "filename": "gcc/ada/libgnat/s-expint.adb", "status": "modified", "additions": 4, "deletions": 51, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expint.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,55 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Exp_Int is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   -----------------\n-   -- Exp_Integer --\n-   -----------------\n-\n-   --  Note that negative exponents get a constraint error because the\n-   --  subtype of the Right argument (the exponent) is Natural.\n-\n-   function Exp_Integer\n-     (Left  : Integer;\n-      Right : Natural)\n-      return  Integer\n-   is\n-      Result : Integer := 1;\n-      Factor : Integer := Left;\n-      Exp    : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing base values -1, 0, +1 since\n-      --  the expander does this when the base is a literal, and other cases\n-      --  will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               declare\n-                  pragma Unsuppress (All_Checks);\n-               begin\n-                  Result := Result * Factor;\n-               end;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-\n-            declare\n-               pragma Unsuppress (All_Checks);\n-            begin\n-               Factor := Factor * Factor;\n-            end;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Exp_Integer;\n-\n-end System.Exp_Int;\n+pragma No_Body;"}, {"sha": "70d16e0fd4f7d1617dcab3bf5946040e76f14b06", "filename": "gcc/ada/libgnat/s-expint.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expint.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -31,12 +31,11 @@\n \n --  Integer exponentiation (checks on)\n \n+with System.Expont;\n+\n package System.Exp_Int is\n-   pragma Pure;\n \n-   function Exp_Integer\n-     (Left  : Integer;\n-      Right : Natural)\n-      return  Integer;\n+   function Exp_Integer is new Expont (Integer);\n+   pragma Pure_Function (Exp_Integer);\n \n end System.Exp_Int;"}, {"sha": "98946dcb6f4c1debaeda1d0dca9803dc0092ef26", "filename": "gcc/ada/libgnat/s-explli.adb", "status": "modified", "additions": 5, "deletions": 52, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-explli.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                        S Y S T E M . E X P L L I                         --\n+--                       S Y S T E M . E X P _ L L I                        --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -29,55 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Exp_LLI is\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-   ---------------------------\n-   -- Exp_Long_Long_Integer --\n-   ---------------------------\n-\n-   --  Note that negative exponents get a constraint error because the\n-   --  subtype of the Right argument (the exponent) is Natural.\n-\n-   function Exp_Long_Long_Integer\n-     (Left  : Long_Long_Integer;\n-      Right : Natural)\n-      return  Long_Long_Integer\n-   is\n-      Result : Long_Long_Integer := 1;\n-      Factor : Long_Long_Integer := Left;\n-      Exp    : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing base values -1, 0, +1 since\n-      --  the expander does this when the base is a literal, and other cases\n-      --  will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               declare\n-                  pragma Unsuppress (All_Checks);\n-               begin\n-                  Result := Result * Factor;\n-               end;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-\n-            declare\n-               pragma Unsuppress (All_Checks);\n-            begin\n-               Factor := Factor * Factor;\n-            end;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Exp_Long_Long_Integer;\n-\n-end System.Exp_LLI;\n+pragma No_Body;"}, {"sha": "bf58a9a0da4040e2191b30aefcac1b61fc32a8e7", "filename": "gcc/ada/libgnat/s-explli.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-explli.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,14 +29,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Long_Long_Integer exponentiation\n+--  Long_Long_Integer exponentiation (checks on)\n+\n+with System.Expont;\n \n package System.Exp_LLI is\n-   pragma Pure;\n \n-   function Exp_Long_Long_Integer\n-     (Left  : Long_Long_Integer;\n-      Right : Natural)\n-      return  Long_Long_Integer;\n+   function Exp_Long_Long_Integer is new Expont (Long_Long_Integer);\n+   pragma Pure_Function (Exp_Long_Long_Integer);\n \n end System.Exp_LLI;"}, {"sha": "0e4375dabb6a316fef7090820100bbed99b45919", "filename": "gcc/ada/libgnat/s-expllli.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expllli.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . E X P _ L L L I                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Long_Long_Long_Integer exponentiation (checks on)\n+\n+with System.Expont;\n+\n+package System.Exp_LLLI is\n+\n+   function Exp_Long_Long_Long_Integer is new Expont (Long_Long_Long_Integer);\n+   pragma Pure_Function (Exp_Long_Long_Long_Integer);\n+\n+end System.Exp_LLLI;"}, {"sha": "2f7c6a9edbe7059ff74ee4ed9ca448b44b4f3fa7", "filename": "gcc/ada/libgnat/s-explllu.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-explllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-explllu.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . E X P _ L L L U                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This function performs exponentiation of unsigned types with binary modulus\n+--  values exceeding that of System.Unsigned_Types.Long_Long_Unsigned.\n+--  The result is always full width, the caller must do a masking operation if\n+--  the modulus is less than 2 ** Long_Long_Long_Unsigned'Size.\n+\n+with System.Exponu;\n+with System.Unsigned_Types;\n+\n+package System.Exp_LLLU is\n+\n+   subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n+\n+   function Exp_Long_Long_Long_Unsigned is\n+     new Exponu (Long_Long_Long_Unsigned);\n+   pragma Pure_Function (Exp_Long_Long_Long_Unsigned);\n+\n+end System.Exp_LLLU;"}, {"sha": "3a383f7acb4119cc9f57dbdf9c44d8f06992151a", "filename": "gcc/ada/libgnat/s-expllu.adb", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expllu.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                        S Y S T E M . X P _ B M L                         --\n+--                       S Y S T E M . E X P _ L L U                        --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -29,46 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Exp_LLU is\n-\n-   ----------------------------\n-   -- Exp_Long_Long_Unsigned --\n-   ----------------------------\n-\n-   function Exp_Long_Long_Unsigned\n-     (Left  : Long_Long_Unsigned;\n-      Right : Natural)\n-      return  Long_Long_Unsigned\n-   is\n-      Result : Long_Long_Unsigned := 1;\n-      Factor : Long_Long_Unsigned := Left;\n-      Exp    : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing the cases of base values -1,0,+1\n-      --  since the expander does this when the base is a literal, and other\n-      --  cases will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               Result := Result * Factor;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-            Factor := Factor * Factor;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-\n-   end Exp_Long_Long_Unsigned;\n-\n-end System.Exp_LLU;\n+pragma No_Body;"}, {"sha": "9e30090861efa75652bed6d492306d4debe5e962", "filename": "gcc/ada/libgnat/s-expllu.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expllu.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,19 +29,19 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This function performs exponentiation of unsigned types (with binary\n---  modulus values exceeding that of Unsigned_Types.Unsigned). The result\n---  is always full width, the caller must do a masking operation if the\n---  modulus is less than 2 ** (Long_Long_Unsigned'Size).\n+--  This function performs exponentiation of unsigned types with binary modulus\n+--  values exceeding that of System.Unsigned_Types.Unsigned.\n+--  The result is always full width, the caller must do a masking operation if\n+--  the modulus is less than 2 ** Long_Long_Unsigned'Size.\n \n+with System.Exponu;\n with System.Unsigned_Types;\n \n package System.Exp_LLU is\n-   pragma Pure;\n \n-   function Exp_Long_Long_Unsigned\n-     (Left  : System.Unsigned_Types.Long_Long_Unsigned;\n-      Right : Natural)\n-      return  System.Unsigned_Types.Long_Long_Unsigned;\n+   subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n+\n+   function Exp_Long_Long_Unsigned is new Exponu (Long_Long_Unsigned);\n+   pragma Pure_Function (Exp_Long_Long_Unsigned);\n \n end System.Exp_LLU;"}, {"sha": "f1522d0615c6bf78b80e7fda69846b350cbec52f", "filename": "gcc/ada/libgnat/s-exponn.adb", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exponn.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,72 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N N                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+function System.Exponn (Left : Int; Right : Natural) return Int is\n+\n+   --  Note that negative exponents get a constraint error because the\n+   --  subtype of the Right argument (the exponent) is Natural.\n+\n+   Result : Int     := 1;\n+   Factor : Int     := Left;\n+   Exp    : Natural := Right;\n+\n+begin\n+   --  We use the standard logarithmic approach, Exp gets shifted right\n+   --  testing successive low order bits and Factor is the value of the\n+   --  base raised to the next power of 2.\n+\n+   --  Note: it is not worth special casing base values -1, 0, +1 since\n+   --  the expander does this when the base is a literal, and other cases\n+   --  will be extremely rare.\n+\n+   if Exp /= 0 then\n+      loop\n+         if Exp rem 2 /= 0 then\n+            declare\n+               pragma Suppress (Overflow_Check);\n+            begin\n+               Result := Result * Factor;\n+            end;\n+         end if;\n+\n+         Exp := Exp / 2;\n+         exit when Exp = 0;\n+\n+         declare\n+            pragma Suppress (Overflow_Check);\n+         begin\n+            Factor := Factor * Factor;\n+         end;\n+      end loop;\n+   end if;\n+\n+   return Result;\n+end System.Exponn;"}, {"sha": "f4cd18f4b738a7bf06e29eb2fdefe4ee9ab8b040", "filename": "gcc/ada/libgnat/s-exponn.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exponn.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N N                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Signed integer exponentiation (checks off)\n+\n+generic\n+\n+   type Int is range <>;\n+\n+function System.Exponn (Left : Int; Right : Natural) return Int;"}, {"sha": "bcdcae43bce3acbf757468070b69f5c832b0c2f8", "filename": "gcc/ada/libgnat/s-expont.adb", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expont.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expont.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expont.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,72 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N T                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+function System.Expont (Left : Int; Right : Natural) return Int is\n+\n+   --  Note that negative exponents get a constraint error because the\n+   --  subtype of the Right argument (the exponent) is Natural.\n+\n+   Result : Int     := 1;\n+   Factor : Int     := Left;\n+   Exp    : Natural := Right;\n+\n+begin\n+   --  We use the standard logarithmic approach, Exp gets shifted right\n+   --  testing successive low order bits and Factor is the value of the\n+   --  base raised to the next power of 2.\n+\n+   --  Note: it is not worth special casing base values -1, 0, +1 since\n+   --  the expander does this when the base is a literal, and other cases\n+   --  will be extremely rare.\n+\n+   if Exp /= 0 then\n+      loop\n+         if Exp rem 2 /= 0 then\n+            declare\n+               pragma Unsuppress (Overflow_Check);\n+            begin\n+               Result := Result * Factor;\n+            end;\n+         end if;\n+\n+         Exp := Exp / 2;\n+         exit when Exp = 0;\n+\n+         declare\n+            pragma Unsuppress (Overflow_Check);\n+         begin\n+            Factor := Factor * Factor;\n+         end;\n+      end loop;\n+   end if;\n+\n+   return Result;\n+end System.Expont;"}, {"sha": "7a519fd8771ea5615bb18fdab068905f624fe98f", "filename": "gcc/ada/libgnat/s-expont.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expont.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expont.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expont.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N T                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Signed integer exponentiation (checks on)\n+\n+generic\n+\n+   type Int is range <>;\n+\n+function System.Expont (Left : Int; Right : Natural) return Int;"}, {"sha": "d2b9305718d115382505dbb7dd9c9b5513fbc96f", "filename": "gcc/ada/libgnat/s-exponu.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exponu.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N U                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+function System.Exponu (Left : Int; Right : Natural) return Int is\n+\n+   --  Note that negative exponents get a constraint error because the\n+   --  subtype of the Right argument (the exponent) is Natural.\n+\n+   Result : Int     := 1;\n+   Factor : Int     := Left;\n+   Exp    : Natural := Right;\n+\n+begin\n+   --  We use the standard logarithmic approach, Exp gets shifted right\n+   --  testing successive low order bits and Factor is the value of the\n+   --  base raised to the next power of 2.\n+\n+   --  Note: it is not worth special casing base values -1, 0, +1 since\n+   --  the expander does this when the base is a literal, and other cases\n+   --  will be extremely rare.\n+\n+   if Exp /= 0 then\n+      loop\n+         if Exp rem 2 /= 0 then\n+            Result := Result * Factor;\n+         end if;\n+\n+         Exp := Exp / 2;\n+         exit when Exp = 0;\n+         Factor := Factor * Factor;\n+      end loop;\n+   end if;\n+\n+   return Result;\n+end System.Exponu;"}, {"sha": "2a913d693ac34db50720643d426e41cff303e0b6", "filename": "gcc/ada/libgnat/s-exponu.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-exponu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-exponu.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . E X P O N U                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Modular integer exponentiation\n+\n+generic\n+\n+   type Int is mod <>;\n+\n+function System.Exponu (Left : Int; Right : Natural) return Int;"}, {"sha": "f513da2985f120777e8cca87d0604d5ddf15f2c1", "filename": "gcc/ada/libgnat/s-expuns.adb", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expuns.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expuns.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expuns.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,45 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Unsigned_Types; use System.Unsigned_Types;\n+--  This package does not require a body, since it is an instantiation. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body System.Exp_Uns is\n-\n-   ------------------\n-   -- Exp_Unsigned --\n-   ------------------\n-\n-   function Exp_Unsigned\n-     (Left  : Unsigned;\n-      Right : Natural)\n-      return  Unsigned\n-   is\n-      Result  : Unsigned := 1;\n-      Factor  : Unsigned := Left;\n-      Exp     : Natural := Right;\n-\n-   begin\n-      --  We use the standard logarithmic approach, Exp gets shifted right\n-      --  testing successive low order bits and Factor is the value of the\n-      --  base raised to the next power of 2.\n-\n-      --  Note: it is not worth special casing the cases of base values -1,0,+1\n-      --  since the expander does this when the base is a literal, and other\n-      --  cases will be extremely rare.\n-\n-      if Exp /= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               Result := Result * Factor;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-            Factor := Factor * Factor;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Exp_Unsigned;\n-\n-end System.Exp_Uns;\n+pragma No_Body;"}, {"sha": "3826f4f5e4313ade6d24e45920a12bd4100ccde8", "filename": "gcc/ada/libgnat/s-expuns.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expuns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-expuns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expuns.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -29,19 +29,19 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This function performs exponentiation of unsigned types (with binary\n---  modulus values up to and including that of Unsigned_Types.Unsigned).\n---  The result is always full width, the caller must do a masking operation\n---  the modulus is less than 2 ** (Unsigned'Size).\n+--  This function performs exponentiation of unsigned types with binary modulus\n+--  values up to and including that of System.Unsigned_Types.Unsigned.\n+--  The result is always full width, the caller must do a masking operation if\n+--  the modulus is less than 2 ** Unsigned'Size.\n \n+with System.Exponu;\n with System.Unsigned_Types;\n \n package System.Exp_Uns is\n-   pragma Pure;\n \n-   function Exp_Unsigned\n-     (Left  : System.Unsigned_Types.Unsigned;\n-      Right : Natural)\n-      return  System.Unsigned_Types.Unsigned;\n+   subtype Unsigned is Unsigned_Types.Unsigned;\n+\n+   function Exp_Unsigned is new Exponu (Unsigned);\n+   pragma Pure_Function (Exp_Unsigned);\n \n end System.Exp_Uns;"}, {"sha": "bae251cfaebf2a4821c280826577ca34465ac2bc", "filename": "gcc/ada/libgnat/s-pack100.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack100.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack100.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack100.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 0                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_100 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_100;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_100 or SetU_100 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_100 --\n+   ------------\n+\n+   function Get_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_100\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_100;\n+\n+   -------------\n+   -- GetU_100 --\n+   -------------\n+\n+   function GetU_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_100\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_100;\n+\n+   ------------\n+   -- Set_100 --\n+   ------------\n+\n+   procedure Set_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_100;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_100;\n+\n+   -------------\n+   -- SetU_100 --\n+   -------------\n+\n+   procedure SetU_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_100;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_100;\n+\n+end System.Pack_100;"}, {"sha": "dfb3e627a650f7d61e1a1a5a3eb8562d40492ec5", "filename": "gcc/ada/libgnat/s-pack100.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack100.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack100.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack100.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 0                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 100\n+\n+package System.Pack_100 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 100;\n+\n+   type Bits_100 is mod 2 ** Bits;\n+   for Bits_100'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_100 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_100;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_100 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_100\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_100;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_100;"}, {"sha": "dfa1cf3e28b01cbd580e3c5fefc857e917e6a9e9", "filename": "gcc/ada/libgnat/s-pack101.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack101.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack101.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack101.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 1                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_101 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_101;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_101 --\n+   ------------\n+\n+   function Get_101\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_101\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_101;\n+\n+   ------------\n+   -- Set_101 --\n+   ------------\n+\n+   procedure Set_101\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_101;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_101;\n+\n+end System.Pack_101;"}, {"sha": "2e77051d388a5e8ff1979c84ad8df018881362f3", "filename": "gcc/ada/libgnat/s-pack101.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack101.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack101.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack101.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 1                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 101\n+\n+package System.Pack_101 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 101;\n+\n+   type Bits_101 is mod 2 ** Bits;\n+   for Bits_101'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_101\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_101 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_101\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_101;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_101;"}, {"sha": "ebf109460ad1197d227a5d7fdcaad91b492c5965", "filename": "gcc/ada/libgnat/s-pack102.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack102.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack102.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack102.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 2                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_102 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_102;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_102 or SetU_102 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_102 --\n+   ------------\n+\n+   function Get_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_102\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_102;\n+\n+   -------------\n+   -- GetU_102 --\n+   -------------\n+\n+   function GetU_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_102\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_102;\n+\n+   ------------\n+   -- Set_102 --\n+   ------------\n+\n+   procedure Set_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_102;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_102;\n+\n+   -------------\n+   -- SetU_102 --\n+   -------------\n+\n+   procedure SetU_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_102;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_102;\n+\n+end System.Pack_102;"}, {"sha": "065f33826f9d01db1a3b641e6538abc1521700ba", "filename": "gcc/ada/libgnat/s-pack102.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack102.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack102.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack102.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 2                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 102\n+\n+package System.Pack_102 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 102;\n+\n+   type Bits_102 is mod 2 ** Bits;\n+   for Bits_102'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_102 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_102;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_102 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_102\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_102;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_102;"}, {"sha": "b5df31e743834b48293519545b7b74ba7adbf69e", "filename": "gcc/ada/libgnat/s-pack103.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack103.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack103.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack103.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 3                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_103 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_103;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_103 --\n+   ------------\n+\n+   function Get_103\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_103\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_103;\n+\n+   ------------\n+   -- Set_103 --\n+   ------------\n+\n+   procedure Set_103\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_103;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_103;\n+\n+end System.Pack_103;"}, {"sha": "ad12b0e3bfcda4b979c403e945797ab918307481", "filename": "gcc/ada/libgnat/s-pack103.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack103.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack103.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack103.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 3                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 103\n+\n+package System.Pack_103 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 103;\n+\n+   type Bits_103 is mod 2 ** Bits;\n+   for Bits_103'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_103\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_103 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_103\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_103;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_103;"}, {"sha": "573fe4a39cfdc5f656a6a73cb30c1279aee02fd1", "filename": "gcc/ada/libgnat/s-pack104.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack104.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack104.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack104.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 4                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_104 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_104;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_104 or SetU_104 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_104 --\n+   ------------\n+\n+   function Get_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_104\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_104;\n+\n+   -------------\n+   -- GetU_104 --\n+   -------------\n+\n+   function GetU_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_104\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_104;\n+\n+   ------------\n+   -- Set_104 --\n+   ------------\n+\n+   procedure Set_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_104;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_104;\n+\n+   -------------\n+   -- SetU_104 --\n+   -------------\n+\n+   procedure SetU_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_104;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_104;\n+\n+end System.Pack_104;"}, {"sha": "3dee1a7dd7a6e25780bd9111b1a7f9ef7814efa5", "filename": "gcc/ada/libgnat/s-pack104.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack104.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack104.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack104.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 4                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 104\n+\n+package System.Pack_104 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 104;\n+\n+   type Bits_104 is mod 2 ** Bits;\n+   for Bits_104'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_104 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_104;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_104 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_104\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_104;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_104;"}, {"sha": "b5e2aab7955080cc631fc10148973c4ef870cbd9", "filename": "gcc/ada/libgnat/s-pack105.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack105.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack105.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack105.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 5                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_105 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_105;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_105 --\n+   ------------\n+\n+   function Get_105\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_105\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_105;\n+\n+   ------------\n+   -- Set_105 --\n+   ------------\n+\n+   procedure Set_105\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_105;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_105;\n+\n+end System.Pack_105;"}, {"sha": "2faf652d4c6ec1da063b3ea5edd6c426bb12e949", "filename": "gcc/ada/libgnat/s-pack105.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack105.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack105.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack105.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 5                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 105\n+\n+package System.Pack_105 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 105;\n+\n+   type Bits_105 is mod 2 ** Bits;\n+   for Bits_105'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_105\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_105 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_105\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_105;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_105;"}, {"sha": "645b5a2552b8eef020660baad325a4fb1c4d4349", "filename": "gcc/ada/libgnat/s-pack106.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack106.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack106.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack106.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 6                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_106 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_106;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_106 or SetU_106 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_106 --\n+   ------------\n+\n+   function Get_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_106\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_106;\n+\n+   -------------\n+   -- GetU_106 --\n+   -------------\n+\n+   function GetU_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_106\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_106;\n+\n+   ------------\n+   -- Set_106 --\n+   ------------\n+\n+   procedure Set_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_106;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_106;\n+\n+   -------------\n+   -- SetU_106 --\n+   -------------\n+\n+   procedure SetU_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_106;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_106;\n+\n+end System.Pack_106;"}, {"sha": "27c7efa9e308c958005816bb8f7df385c009d847", "filename": "gcc/ada/libgnat/s-pack106.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack106.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack106.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack106.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 6                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 106\n+\n+package System.Pack_106 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 106;\n+\n+   type Bits_106 is mod 2 ** Bits;\n+   for Bits_106'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_106 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_106;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_106 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_106\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_106;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_106;"}, {"sha": "7e1a86a530a3c591ceb8c21fab8bcf8fbf757fcf", "filename": "gcc/ada/libgnat/s-pack107.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack107.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack107.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack107.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 7                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_107 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_107;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_107 --\n+   ------------\n+\n+   function Get_107\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_107\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_107;\n+\n+   ------------\n+   -- Set_107 --\n+   ------------\n+\n+   procedure Set_107\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_107;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_107;\n+\n+end System.Pack_107;"}, {"sha": "3eba81d144ded36f3140a76b7230b6eb06091be0", "filename": "gcc/ada/libgnat/s-pack107.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack107.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack107.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack107.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 7                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 107\n+\n+package System.Pack_107 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 107;\n+\n+   type Bits_107 is mod 2 ** Bits;\n+   for Bits_107'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_107\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_107 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_107\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_107;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_107;"}, {"sha": "afe28a5fa733b33992adaf9ba24f3520bf687a74", "filename": "gcc/ada/libgnat/s-pack108.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack108.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack108.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack108.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 8                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_108 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_108;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_108 or SetU_108 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_108 --\n+   ------------\n+\n+   function Get_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_108\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_108;\n+\n+   -------------\n+   -- GetU_108 --\n+   -------------\n+\n+   function GetU_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_108\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_108;\n+\n+   ------------\n+   -- Set_108 --\n+   ------------\n+\n+   procedure Set_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_108;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_108;\n+\n+   -------------\n+   -- SetU_108 --\n+   -------------\n+\n+   procedure SetU_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_108;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_108;\n+\n+end System.Pack_108;"}, {"sha": "e751654f93a18bd992690c9350a9160b3c3dc136", "filename": "gcc/ada/libgnat/s-pack108.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack108.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack108.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack108.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 8                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 108\n+\n+package System.Pack_108 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 108;\n+\n+   type Bits_108 is mod 2 ** Bits;\n+   for Bits_108'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_108 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_108;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_108 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_108\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_108;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_108;"}, {"sha": "e976ed4ee881999c49adf07d08a4697200b959b3", "filename": "gcc/ada/libgnat/s-pack109.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack109.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack109.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack109.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 9                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_109 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_109;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_109 --\n+   ------------\n+\n+   function Get_109\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_109\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_109;\n+\n+   ------------\n+   -- Set_109 --\n+   ------------\n+\n+   procedure Set_109\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_109;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_109;\n+\n+end System.Pack_109;"}, {"sha": "2ea8b421e7270a400c19d1aba1c68fa9658a985b", "filename": "gcc/ada/libgnat/s-pack109.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack109.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack109.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack109.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 0 9                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 109\n+\n+package System.Pack_109 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 109;\n+\n+   type Bits_109 is mod 2 ** Bits;\n+   for Bits_109'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_109\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_109 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_109\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_109;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_109;"}, {"sha": "a85eb3d6db4d8e84dff7249a60beb2159c8ea2c1", "filename": "gcc/ada/libgnat/s-pack110.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack110.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack110.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack110.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 0                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_110 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_110;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_110 or SetU_110 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_110 --\n+   ------------\n+\n+   function Get_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_110\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_110;\n+\n+   -------------\n+   -- GetU_110 --\n+   -------------\n+\n+   function GetU_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_110\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_110;\n+\n+   ------------\n+   -- Set_110 --\n+   ------------\n+\n+   procedure Set_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_110;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_110;\n+\n+   -------------\n+   -- SetU_110 --\n+   -------------\n+\n+   procedure SetU_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_110;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_110;\n+\n+end System.Pack_110;"}, {"sha": "570a9943e5fad2ee6c624d9661cdb26bd7d0d290", "filename": "gcc/ada/libgnat/s-pack110.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack110.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack110.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack110.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 0                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 110\n+\n+package System.Pack_110 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 110;\n+\n+   type Bits_110 is mod 2 ** Bits;\n+   for Bits_110'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_110 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_110;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_110 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_110\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_110;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_110;"}, {"sha": "168877be44ce0d1d11282006155967b5b336aa2a", "filename": "gcc/ada/libgnat/s-pack111.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack111.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack111.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack111.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 1                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_111 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_111;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_111 --\n+   ------------\n+\n+   function Get_111\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_111\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_111;\n+\n+   ------------\n+   -- Set_111 --\n+   ------------\n+\n+   procedure Set_111\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_111;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_111;\n+\n+end System.Pack_111;"}, {"sha": "784b86188685a22e2515ac15ab372a8bab67d684", "filename": "gcc/ada/libgnat/s-pack111.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack111.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack111.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack111.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 1                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 111\n+\n+package System.Pack_111 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 111;\n+\n+   type Bits_111 is mod 2 ** Bits;\n+   for Bits_111'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_111\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_111 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_111\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_111;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_111;"}, {"sha": "b8acf5672a357990b83f1348183d605eb11d91a8", "filename": "gcc/ada/libgnat/s-pack112.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack112.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack112.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack112.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 2                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_112 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_112;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_112 or SetU_112 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_112 --\n+   ------------\n+\n+   function Get_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_112\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_112;\n+\n+   -------------\n+   -- GetU_112 --\n+   -------------\n+\n+   function GetU_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_112\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_112;\n+\n+   ------------\n+   -- Set_112 --\n+   ------------\n+\n+   procedure Set_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_112;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_112;\n+\n+   -------------\n+   -- SetU_112 --\n+   -------------\n+\n+   procedure SetU_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_112;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_112;\n+\n+end System.Pack_112;"}, {"sha": "6b36a8befcefe64c661f2231c5ccc601e14b4d88", "filename": "gcc/ada/libgnat/s-pack112.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack112.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack112.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack112.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 2                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 112\n+\n+package System.Pack_112 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 112;\n+\n+   type Bits_112 is mod 2 ** Bits;\n+   for Bits_112'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_112 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_112;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_112 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_112\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_112;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_112;"}, {"sha": "58f84d4b9167e470c7aafc6aa24a77a4c4e500be", "filename": "gcc/ada/libgnat/s-pack113.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack113.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack113.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack113.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 3                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_113 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_113;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_113 --\n+   ------------\n+\n+   function Get_113\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_113\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_113;\n+\n+   ------------\n+   -- Set_113 --\n+   ------------\n+\n+   procedure Set_113\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_113;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_113;\n+\n+end System.Pack_113;"}, {"sha": "2f0bfc2ac44ef1698d63bc826a84afc43a18002c", "filename": "gcc/ada/libgnat/s-pack113.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack113.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack113.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack113.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 3                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 113\n+\n+package System.Pack_113 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 113;\n+\n+   type Bits_113 is mod 2 ** Bits;\n+   for Bits_113'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_113\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_113 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_113\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_113;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_113;"}, {"sha": "079abebbe982b34f6e35ba68804b0a40fd2ed00e", "filename": "gcc/ada/libgnat/s-pack114.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack114.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack114.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack114.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 4                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_114 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_114;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_114 or SetU_114 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_114 --\n+   ------------\n+\n+   function Get_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_114\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_114;\n+\n+   -------------\n+   -- GetU_114 --\n+   -------------\n+\n+   function GetU_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_114\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_114;\n+\n+   ------------\n+   -- Set_114 --\n+   ------------\n+\n+   procedure Set_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_114;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_114;\n+\n+   -------------\n+   -- SetU_114 --\n+   -------------\n+\n+   procedure SetU_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_114;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_114;\n+\n+end System.Pack_114;"}, {"sha": "046026ed987e8bee2ce9421e2e2052f71f3e0c7d", "filename": "gcc/ada/libgnat/s-pack114.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack114.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack114.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack114.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 4                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 114\n+\n+package System.Pack_114 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 114;\n+\n+   type Bits_114 is mod 2 ** Bits;\n+   for Bits_114'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_114 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_114;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_114 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_114\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_114;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_114;"}, {"sha": "0459777685c60e0d1bbb6606b24d95b6a6694df1", "filename": "gcc/ada/libgnat/s-pack115.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack115.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack115.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack115.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 5                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_115 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_115;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_115 --\n+   ------------\n+\n+   function Get_115\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_115\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_115;\n+\n+   ------------\n+   -- Set_115 --\n+   ------------\n+\n+   procedure Set_115\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_115;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_115;\n+\n+end System.Pack_115;"}, {"sha": "a2063a6683d109be4f4ed70c85e813a421287990", "filename": "gcc/ada/libgnat/s-pack115.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack115.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack115.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack115.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 5                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 115\n+\n+package System.Pack_115 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 115;\n+\n+   type Bits_115 is mod 2 ** Bits;\n+   for Bits_115'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_115\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_115 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_115\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_115;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_115;"}, {"sha": "d03c8578679af7f46c630239bddfee0e886566b5", "filename": "gcc/ada/libgnat/s-pack116.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack116.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack116.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack116.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 6                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_116 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_116;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_116 or SetU_116 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_116 --\n+   ------------\n+\n+   function Get_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_116\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_116;\n+\n+   -------------\n+   -- GetU_116 --\n+   -------------\n+\n+   function GetU_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_116\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_116;\n+\n+   ------------\n+   -- Set_116 --\n+   ------------\n+\n+   procedure Set_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_116;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_116;\n+\n+   -------------\n+   -- SetU_116 --\n+   -------------\n+\n+   procedure SetU_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_116;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_116;\n+\n+end System.Pack_116;"}, {"sha": "3cd556dbd67371b917b9c8186c0f006520445951", "filename": "gcc/ada/libgnat/s-pack116.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack116.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack116.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack116.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 6                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 116\n+\n+package System.Pack_116 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 116;\n+\n+   type Bits_116 is mod 2 ** Bits;\n+   for Bits_116'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_116 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_116;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_116 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_116\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_116;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_116;"}, {"sha": "92da4707869eee92379235a505e4bdcaf3281765", "filename": "gcc/ada/libgnat/s-pack117.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack117.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack117.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack117.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 7                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_117 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_117;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_117 --\n+   ------------\n+\n+   function Get_117\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_117\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_117;\n+\n+   ------------\n+   -- Set_117 --\n+   ------------\n+\n+   procedure Set_117\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_117;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_117;\n+\n+end System.Pack_117;"}, {"sha": "478663abbe300fe547af52e06d524f931575546e", "filename": "gcc/ada/libgnat/s-pack117.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack117.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack117.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack117.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 7                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 117\n+\n+package System.Pack_117 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 117;\n+\n+   type Bits_117 is mod 2 ** Bits;\n+   for Bits_117'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_117\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_117 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_117\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_117;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_117;"}, {"sha": "aa1d76345aa9abdf79ac9d4ceefdd1b79ce114da", "filename": "gcc/ada/libgnat/s-pack118.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack118.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack118.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack118.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 8                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_118 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_118;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_118 or SetU_118 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_118 --\n+   ------------\n+\n+   function Get_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_118\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_118;\n+\n+   -------------\n+   -- GetU_118 --\n+   -------------\n+\n+   function GetU_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_118\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_118;\n+\n+   ------------\n+   -- Set_118 --\n+   ------------\n+\n+   procedure Set_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_118;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_118;\n+\n+   -------------\n+   -- SetU_118 --\n+   -------------\n+\n+   procedure SetU_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_118;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_118;\n+\n+end System.Pack_118;"}, {"sha": "0902c5c0d6d29d58c83cfabb01cd958d3ec87b43", "filename": "gcc/ada/libgnat/s-pack118.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack118.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack118.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack118.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 8                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 118\n+\n+package System.Pack_118 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 118;\n+\n+   type Bits_118 is mod 2 ** Bits;\n+   for Bits_118'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_118 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_118;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_118 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_118\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_118;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_118;"}, {"sha": "90031756848f5af603b6e85c7746ec8c4810c478", "filename": "gcc/ada/libgnat/s-pack119.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack119.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack119.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack119.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 9                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_119 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_119;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_119 --\n+   ------------\n+\n+   function Get_119\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_119\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_119;\n+\n+   ------------\n+   -- Set_119 --\n+   ------------\n+\n+   procedure Set_119\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_119;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_119;\n+\n+end System.Pack_119;"}, {"sha": "75d1c4ab56a373cce65a6fd07a7efcf60863a16a", "filename": "gcc/ada/libgnat/s-pack119.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack119.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack119.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack119.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 1 9                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 119\n+\n+package System.Pack_119 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 119;\n+\n+   type Bits_119 is mod 2 ** Bits;\n+   for Bits_119'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_119\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_119 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_119\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_119;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_119;"}, {"sha": "774085c228fedfb32325d35883e5b9fd3111c436", "filename": "gcc/ada/libgnat/s-pack120.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack120.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack120.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack120.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 0                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_120 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_120;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_120 or SetU_120 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_120 --\n+   ------------\n+\n+   function Get_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_120\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_120;\n+\n+   -------------\n+   -- GetU_120 --\n+   -------------\n+\n+   function GetU_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_120\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_120;\n+\n+   ------------\n+   -- Set_120 --\n+   ------------\n+\n+   procedure Set_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_120;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_120;\n+\n+   -------------\n+   -- SetU_120 --\n+   -------------\n+\n+   procedure SetU_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_120;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_120;\n+\n+end System.Pack_120;"}, {"sha": "ae5580a2e31f32c6442beb4787f29c49dc6a014d", "filename": "gcc/ada/libgnat/s-pack120.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack120.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack120.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack120.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 0                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 120\n+\n+package System.Pack_120 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 120;\n+\n+   type Bits_120 is mod 2 ** Bits;\n+   for Bits_120'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_120 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_120;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_120 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_120\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_120;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_120;"}, {"sha": "a44f14482c46ceffb068bf6e5727c8f6e53f0620", "filename": "gcc/ada/libgnat/s-pack121.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack121.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack121.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack121.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 1                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_121 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_121;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_121 --\n+   ------------\n+\n+   function Get_121\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_121\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_121;\n+\n+   ------------\n+   -- Set_121 --\n+   ------------\n+\n+   procedure Set_121\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_121;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_121;\n+\n+end System.Pack_121;"}, {"sha": "5f4f5edb482bc55b5705deaf7302c694428ad00b", "filename": "gcc/ada/libgnat/s-pack121.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack121.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack121.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack121.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 1                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 121\n+\n+package System.Pack_121 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 121;\n+\n+   type Bits_121 is mod 2 ** Bits;\n+   for Bits_121'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_121\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_121 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_121\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_121;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_121;"}, {"sha": "13c59ac0a145b56e0cb1c2fa6fa92569cb6cbb91", "filename": "gcc/ada/libgnat/s-pack122.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack122.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack122.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack122.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 2                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_122 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_122;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_122 or SetU_122 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_122 --\n+   ------------\n+\n+   function Get_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_122\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_122;\n+\n+   -------------\n+   -- GetU_122 --\n+   -------------\n+\n+   function GetU_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_122\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_122;\n+\n+   ------------\n+   -- Set_122 --\n+   ------------\n+\n+   procedure Set_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_122;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_122;\n+\n+   -------------\n+   -- SetU_122 --\n+   -------------\n+\n+   procedure SetU_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_122;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_122;\n+\n+end System.Pack_122;"}, {"sha": "0094896ecee86d252cb2b9b910955cd33ce37df0", "filename": "gcc/ada/libgnat/s-pack122.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack122.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack122.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack122.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 2                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 122\n+\n+package System.Pack_122 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 122;\n+\n+   type Bits_122 is mod 2 ** Bits;\n+   for Bits_122'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_122 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_122;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_122 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_122\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_122;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_122;"}, {"sha": "27d7417f01508976699b27aaf0d52d24ac9d89dc", "filename": "gcc/ada/libgnat/s-pack123.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack123.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack123.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack123.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 3                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_123 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_123;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_123 --\n+   ------------\n+\n+   function Get_123\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_123\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_123;\n+\n+   ------------\n+   -- Set_123 --\n+   ------------\n+\n+   procedure Set_123\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_123;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_123;\n+\n+end System.Pack_123;"}, {"sha": "f40fe87628f5b6da36d8729b8736a56aa6ce6559", "filename": "gcc/ada/libgnat/s-pack123.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack123.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack123.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack123.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 3                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 123\n+\n+package System.Pack_123 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 123;\n+\n+   type Bits_123 is mod 2 ** Bits;\n+   for Bits_123'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_123\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_123 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_123\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_123;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_123;"}, {"sha": "2e6d9c037cbbcb40a40e157995f1a119f3f60643", "filename": "gcc/ada/libgnat/s-pack124.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack124.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack124.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack124.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 4                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_124 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_124;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_124 or SetU_124 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_124 --\n+   ------------\n+\n+   function Get_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_124\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_124;\n+\n+   -------------\n+   -- GetU_124 --\n+   -------------\n+\n+   function GetU_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_124\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_124;\n+\n+   ------------\n+   -- Set_124 --\n+   ------------\n+\n+   procedure Set_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_124;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_124;\n+\n+   -------------\n+   -- SetU_124 --\n+   -------------\n+\n+   procedure SetU_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_124;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_124;\n+\n+end System.Pack_124;"}, {"sha": "3a4f159b04c79d417cb14517c76d3918c313e4e7", "filename": "gcc/ada/libgnat/s-pack124.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack124.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack124.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack124.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 4                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 124\n+\n+package System.Pack_124 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 124;\n+\n+   type Bits_124 is mod 2 ** Bits;\n+   for Bits_124'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_124 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_124;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_124 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_124\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_124;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_124;"}, {"sha": "ffc2c1cd3e8f605dddfa644658927a6cdf70cde9", "filename": "gcc/ada/libgnat/s-pack125.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack125.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack125.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack125.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 5                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_125 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_125;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_125 --\n+   ------------\n+\n+   function Get_125\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_125\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_125;\n+\n+   ------------\n+   -- Set_125 --\n+   ------------\n+\n+   procedure Set_125\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_125;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_125;\n+\n+end System.Pack_125;"}, {"sha": "dc4fdc98b3f410d8c5faddcc7c4372e0171a54ee", "filename": "gcc/ada/libgnat/s-pack125.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack125.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack125.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack125.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 5                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 125\n+\n+package System.Pack_125 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 125;\n+\n+   type Bits_125 is mod 2 ** Bits;\n+   for Bits_125'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_125\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_125 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_125\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_125;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_125;"}, {"sha": "c566fc958d00aac1c8878280c992af697c8a6d03", "filename": "gcc/ada/libgnat/s-pack126.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack126.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack126.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack126.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 6                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_126 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_126;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_126 or SetU_126 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_126 --\n+   ------------\n+\n+   function Get_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_126\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_126;\n+\n+   -------------\n+   -- GetU_126 --\n+   -------------\n+\n+   function GetU_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_126\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_126;\n+\n+   ------------\n+   -- Set_126 --\n+   ------------\n+\n+   procedure Set_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_126;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_126;\n+\n+   -------------\n+   -- SetU_126 --\n+   -------------\n+\n+   procedure SetU_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_126;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_126;\n+\n+end System.Pack_126;"}, {"sha": "fd83f78fb7ed5bd0c52dcb9ac2d820935f1554f1", "filename": "gcc/ada/libgnat/s-pack126.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack126.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack126.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack126.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 6                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 126\n+\n+package System.Pack_126 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 126;\n+\n+   type Bits_126 is mod 2 ** Bits;\n+   for Bits_126'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_126 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_126;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_126 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_126\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_126;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_126;"}, {"sha": "3895c1f182ec9ffb3b859e55938626053fdf7dac", "filename": "gcc/ada/libgnat/s-pack127.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack127.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack127.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack127.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 7                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_127 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_127;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_127 --\n+   ------------\n+\n+   function Get_127\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_127\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_127;\n+\n+   ------------\n+   -- Set_127 --\n+   ------------\n+\n+   procedure Set_127\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_127;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_127;\n+\n+end System.Pack_127;"}, {"sha": "c37ae592ea068f2d5e5aebee5e3b1ae938c9df54", "filename": "gcc/ada/libgnat/s-pack127.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack127.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack127.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack127.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 1 2 7                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 127\n+\n+package System.Pack_127 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 127;\n+\n+   type Bits_127 is mod 2 ** Bits;\n+   for Bits_127'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_127\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_127 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_127\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_127;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_127;"}, {"sha": "c5b7310c5d4cf74af8256a24db60bd0453eda36b", "filename": "gcc/ada/libgnat/s-pack65.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack65.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack65.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack65.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 5                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_65 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_65;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_65 --\n+   ------------\n+\n+   function Get_65\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_65\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_65;\n+\n+   ------------\n+   -- Set_65 --\n+   ------------\n+\n+   procedure Set_65\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_65;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_65;\n+\n+end System.Pack_65;"}, {"sha": "8752c9c3013e7214f971b82daaf808bc389ac9b7", "filename": "gcc/ada/libgnat/s-pack65.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack65.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack65.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack65.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 5                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 65\n+\n+package System.Pack_65 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 65;\n+\n+   type Bits_65 is mod 2 ** Bits;\n+   for Bits_65'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_65\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_65 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_65\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_65;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_65;"}, {"sha": "5e90ceb1869d7e4c5d63599452bbe9144904849a", "filename": "gcc/ada/libgnat/s-pack66.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack66.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack66.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack66.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 6                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_66 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_66;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_66 or SetU_66 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_66 --\n+   ------------\n+\n+   function Get_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_66\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_66;\n+\n+   -------------\n+   -- GetU_66 --\n+   -------------\n+\n+   function GetU_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_66\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_66;\n+\n+   ------------\n+   -- Set_66 --\n+   ------------\n+\n+   procedure Set_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_66;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_66;\n+\n+   -------------\n+   -- SetU_66 --\n+   -------------\n+\n+   procedure SetU_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_66;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_66;\n+\n+end System.Pack_66;"}, {"sha": "b45d3179214f2849383270666848dc61f4ea5783", "filename": "gcc/ada/libgnat/s-pack66.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack66.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack66.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack66.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 6                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 66\n+\n+package System.Pack_66 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 66;\n+\n+   type Bits_66 is mod 2 ** Bits;\n+   for Bits_66'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_66 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_66;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_66 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_66\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_66;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_66;"}, {"sha": "d7c77e8f4c5537b183e51f1deac8069126c44329", "filename": "gcc/ada/libgnat/s-pack67.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack67.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack67.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack67.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 7                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_67 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_67;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_67 --\n+   ------------\n+\n+   function Get_67\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_67\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_67;\n+\n+   ------------\n+   -- Set_67 --\n+   ------------\n+\n+   procedure Set_67\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_67;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_67;\n+\n+end System.Pack_67;"}, {"sha": "f77b651f94b1b1271c4aafc880b6d60c147c47d1", "filename": "gcc/ada/libgnat/s-pack67.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack67.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack67.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack67.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 7                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 67\n+\n+package System.Pack_67 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 67;\n+\n+   type Bits_67 is mod 2 ** Bits;\n+   for Bits_67'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_67\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_67 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_67\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_67;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_67;"}, {"sha": "03a0361f29dae7aa510d2017aa56255d71039081", "filename": "gcc/ada/libgnat/s-pack68.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack68.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack68.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack68.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 8                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_68 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_68;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_68 or SetU_68 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_68 --\n+   ------------\n+\n+   function Get_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_68\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_68;\n+\n+   -------------\n+   -- GetU_68 --\n+   -------------\n+\n+   function GetU_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_68\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_68;\n+\n+   ------------\n+   -- Set_68 --\n+   ------------\n+\n+   procedure Set_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_68;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_68;\n+\n+   -------------\n+   -- SetU_68 --\n+   -------------\n+\n+   procedure SetU_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_68;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_68;\n+\n+end System.Pack_68;"}, {"sha": "5565b329d2b71adc1f748b1fa612239ae5468775", "filename": "gcc/ada/libgnat/s-pack68.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack68.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack68.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack68.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 8                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 68\n+\n+package System.Pack_68 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 68;\n+\n+   type Bits_68 is mod 2 ** Bits;\n+   for Bits_68'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_68 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_68;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_68 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_68\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_68;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_68;"}, {"sha": "f3830297d5844b987b2bb96f3970d58cb75cfc5a", "filename": "gcc/ada/libgnat/s-pack69.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack69.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack69.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack69.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 9                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_69 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_69;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_69 --\n+   ------------\n+\n+   function Get_69\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_69\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_69;\n+\n+   ------------\n+   -- Set_69 --\n+   ------------\n+\n+   procedure Set_69\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_69;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_69;\n+\n+end System.Pack_69;"}, {"sha": "76a221d2b0e7dfcb04a735d8de545e91e3ab87c2", "filename": "gcc/ada/libgnat/s-pack69.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack69.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack69.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack69.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 6 9                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 69\n+\n+package System.Pack_69 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 69;\n+\n+   type Bits_69 is mod 2 ** Bits;\n+   for Bits_69'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_69\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_69 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_69\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_69;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_69;"}, {"sha": "7dab227efab8ee98741b062ae933647bee5d7365", "filename": "gcc/ada/libgnat/s-pack70.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack70.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack70.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack70.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 0                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_70 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_70;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_70 or SetU_70 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_70 --\n+   ------------\n+\n+   function Get_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_70\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_70;\n+\n+   -------------\n+   -- GetU_70 --\n+   -------------\n+\n+   function GetU_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_70\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_70;\n+\n+   ------------\n+   -- Set_70 --\n+   ------------\n+\n+   procedure Set_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_70;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_70;\n+\n+   -------------\n+   -- SetU_70 --\n+   -------------\n+\n+   procedure SetU_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_70;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_70;\n+\n+end System.Pack_70;"}, {"sha": "b978d1c27d4c70114b90b51b086790414ae070ca", "filename": "gcc/ada/libgnat/s-pack70.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack70.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack70.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack70.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 0                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 70\n+\n+package System.Pack_70 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 70;\n+\n+   type Bits_70 is mod 2 ** Bits;\n+   for Bits_70'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_70 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_70;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_70 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_70\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_70;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_70;"}, {"sha": "f3560de2316b62b3b87a3ee5051083c0609d5873", "filename": "gcc/ada/libgnat/s-pack71.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack71.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack71.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack71.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 1                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_71 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_71;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_71 --\n+   ------------\n+\n+   function Get_71\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_71\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_71;\n+\n+   ------------\n+   -- Set_71 --\n+   ------------\n+\n+   procedure Set_71\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_71;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_71;\n+\n+end System.Pack_71;"}, {"sha": "842a2324ae7cc78f560fc22fcb6060013d62c18b", "filename": "gcc/ada/libgnat/s-pack71.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack71.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack71.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack71.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 1                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 71\n+\n+package System.Pack_71 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 71;\n+\n+   type Bits_71 is mod 2 ** Bits;\n+   for Bits_71'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_71\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_71 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_71\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_71;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_71;"}, {"sha": "14fbb15c25c209d2d0cefdd566671677b681bbe3", "filename": "gcc/ada/libgnat/s-pack72.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack72.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack72.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack72.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 2                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_72 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_72;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_72 or SetU_72 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_72 --\n+   ------------\n+\n+   function Get_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_72\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_72;\n+\n+   -------------\n+   -- GetU_72 --\n+   -------------\n+\n+   function GetU_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_72\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_72;\n+\n+   ------------\n+   -- Set_72 --\n+   ------------\n+\n+   procedure Set_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_72;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_72;\n+\n+   -------------\n+   -- SetU_72 --\n+   -------------\n+\n+   procedure SetU_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_72;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_72;\n+\n+end System.Pack_72;"}, {"sha": "b1add3518111ac3caca45b727e6b94eb772e4193", "filename": "gcc/ada/libgnat/s-pack72.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack72.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack72.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack72.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 2                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 72\n+\n+package System.Pack_72 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 72;\n+\n+   type Bits_72 is mod 2 ** Bits;\n+   for Bits_72'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_72 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_72;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_72 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_72\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_72;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_72;"}, {"sha": "f4853cb4e97505d5ad98625efdcf8d6480bf10db", "filename": "gcc/ada/libgnat/s-pack73.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack73.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack73.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack73.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 3                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_73 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_73;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_73 --\n+   ------------\n+\n+   function Get_73\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_73\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_73;\n+\n+   ------------\n+   -- Set_73 --\n+   ------------\n+\n+   procedure Set_73\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_73;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_73;\n+\n+end System.Pack_73;"}, {"sha": "5f103de536bce66b484aa1dbfcff69ba833d076f", "filename": "gcc/ada/libgnat/s-pack73.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack73.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack73.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack73.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 3                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 73\n+\n+package System.Pack_73 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 73;\n+\n+   type Bits_73 is mod 2 ** Bits;\n+   for Bits_73'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_73\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_73 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_73\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_73;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_73;"}, {"sha": "984b4c0ce574ad00a317b2c7078a5ba570d5d7c1", "filename": "gcc/ada/libgnat/s-pack74.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack74.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack74.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack74.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 4                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_74 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_74;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_74 or SetU_74 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_74 --\n+   ------------\n+\n+   function Get_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_74\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_74;\n+\n+   -------------\n+   -- GetU_74 --\n+   -------------\n+\n+   function GetU_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_74\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_74;\n+\n+   ------------\n+   -- Set_74 --\n+   ------------\n+\n+   procedure Set_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_74;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_74;\n+\n+   -------------\n+   -- SetU_74 --\n+   -------------\n+\n+   procedure SetU_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_74;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_74;\n+\n+end System.Pack_74;"}, {"sha": "5dde51b770beacdd5a5942df41676e4a21dbfa19", "filename": "gcc/ada/libgnat/s-pack74.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack74.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack74.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack74.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 4                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 74\n+\n+package System.Pack_74 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 74;\n+\n+   type Bits_74 is mod 2 ** Bits;\n+   for Bits_74'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_74 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_74;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_74 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_74\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_74;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_74;"}, {"sha": "6c7c14f2554693e0976e6ce3b3eb327e2b399328", "filename": "gcc/ada/libgnat/s-pack75.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack75.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack75.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack75.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 5                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_75 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_75;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_75 --\n+   ------------\n+\n+   function Get_75\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_75\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_75;\n+\n+   ------------\n+   -- Set_75 --\n+   ------------\n+\n+   procedure Set_75\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_75;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_75;\n+\n+end System.Pack_75;"}, {"sha": "551833a35529430bffceb598d49f6697a82b400f", "filename": "gcc/ada/libgnat/s-pack75.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack75.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack75.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack75.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 5                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 75\n+\n+package System.Pack_75 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 75;\n+\n+   type Bits_75 is mod 2 ** Bits;\n+   for Bits_75'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_75\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_75 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_75\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_75;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_75;"}, {"sha": "6a7c5fabd767dfc753f7eb853a7f8407057731d6", "filename": "gcc/ada/libgnat/s-pack76.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack76.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack76.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack76.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 6                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_76 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_76;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_76 or SetU_76 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_76 --\n+   ------------\n+\n+   function Get_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_76\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_76;\n+\n+   -------------\n+   -- GetU_76 --\n+   -------------\n+\n+   function GetU_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_76\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_76;\n+\n+   ------------\n+   -- Set_76 --\n+   ------------\n+\n+   procedure Set_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_76;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_76;\n+\n+   -------------\n+   -- SetU_76 --\n+   -------------\n+\n+   procedure SetU_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_76;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_76;\n+\n+end System.Pack_76;"}, {"sha": "6a600c9d03a09ddea56e981fafdb15b538c5c5a4", "filename": "gcc/ada/libgnat/s-pack76.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack76.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack76.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack76.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 6                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 76\n+\n+package System.Pack_76 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 76;\n+\n+   type Bits_76 is mod 2 ** Bits;\n+   for Bits_76'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_76 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_76;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_76 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_76\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_76;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_76;"}, {"sha": "f29cdf1f895967337be1d71badeacb22814b3925", "filename": "gcc/ada/libgnat/s-pack77.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack77.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack77.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack77.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 7                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_77 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_77;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_77 --\n+   ------------\n+\n+   function Get_77\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_77\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_77;\n+\n+   ------------\n+   -- Set_77 --\n+   ------------\n+\n+   procedure Set_77\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_77;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_77;\n+\n+end System.Pack_77;"}, {"sha": "9308a7871d2c2824cc39e979812817ebdb1df1f3", "filename": "gcc/ada/libgnat/s-pack77.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack77.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack77.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack77.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 7                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 77\n+\n+package System.Pack_77 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 77;\n+\n+   type Bits_77 is mod 2 ** Bits;\n+   for Bits_77'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_77\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_77 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_77\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_77;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_77;"}, {"sha": "e321c1e4b78f18270dbeb8975dd27dcc205b013d", "filename": "gcc/ada/libgnat/s-pack78.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack78.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack78.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack78.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 8                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_78 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_78;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_78 or SetU_78 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_78 --\n+   ------------\n+\n+   function Get_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_78\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_78;\n+\n+   -------------\n+   -- GetU_78 --\n+   -------------\n+\n+   function GetU_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_78\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_78;\n+\n+   ------------\n+   -- Set_78 --\n+   ------------\n+\n+   procedure Set_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_78;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_78;\n+\n+   -------------\n+   -- SetU_78 --\n+   -------------\n+\n+   procedure SetU_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_78;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_78;\n+\n+end System.Pack_78;"}, {"sha": "54fdd9571e882ce0840ac8191d53a4511d2e8adc", "filename": "gcc/ada/libgnat/s-pack78.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack78.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack78.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack78.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 8                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 78\n+\n+package System.Pack_78 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 78;\n+\n+   type Bits_78 is mod 2 ** Bits;\n+   for Bits_78'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_78 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_78;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_78 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_78\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_78;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_78;"}, {"sha": "75fb14c172eeab8579059109e9c619de6dfe15c7", "filename": "gcc/ada/libgnat/s-pack79.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack79.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack79.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack79.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 9                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_79 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_79;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_79 --\n+   ------------\n+\n+   function Get_79\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_79\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_79;\n+\n+   ------------\n+   -- Set_79 --\n+   ------------\n+\n+   procedure Set_79\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_79;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_79;\n+\n+end System.Pack_79;"}, {"sha": "337be868efc30c749027a28f623cbfb2e5a35ab2", "filename": "gcc/ada/libgnat/s-pack79.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack79.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack79.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack79.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 7 9                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 79\n+\n+package System.Pack_79 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 79;\n+\n+   type Bits_79 is mod 2 ** Bits;\n+   for Bits_79'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_79\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_79 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_79\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_79;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_79;"}, {"sha": "d66588b3e0083c1a6fc0087a6edfac9f6652ef67", "filename": "gcc/ada/libgnat/s-pack80.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack80.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack80.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack80.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 0                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_80 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_80;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_80 or SetU_80 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_80 --\n+   ------------\n+\n+   function Get_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_80\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_80;\n+\n+   -------------\n+   -- GetU_80 --\n+   -------------\n+\n+   function GetU_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_80\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_80;\n+\n+   ------------\n+   -- Set_80 --\n+   ------------\n+\n+   procedure Set_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_80;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_80;\n+\n+   -------------\n+   -- SetU_80 --\n+   -------------\n+\n+   procedure SetU_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_80;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_80;\n+\n+end System.Pack_80;"}, {"sha": "c1f0de4a08e25fffc09898ab184a8d02ecb86dd1", "filename": "gcc/ada/libgnat/s-pack80.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack80.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack80.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack80.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 0                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 80\n+\n+package System.Pack_80 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 80;\n+\n+   type Bits_80 is mod 2 ** Bits;\n+   for Bits_80'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_80 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_80;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_80 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_80\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_80;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_80;"}, {"sha": "5157882bcff51dd7ede14b123bfcda7eb52413b8", "filename": "gcc/ada/libgnat/s-pack81.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack81.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack81.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack81.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 1                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_81 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_81;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_81 --\n+   ------------\n+\n+   function Get_81\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_81\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_81;\n+\n+   ------------\n+   -- Set_81 --\n+   ------------\n+\n+   procedure Set_81\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_81;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_81;\n+\n+end System.Pack_81;"}, {"sha": "9f17734d899976ff715c7ccf73377bcc5df655e3", "filename": "gcc/ada/libgnat/s-pack81.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack81.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack81.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack81.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 1                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 81\n+\n+package System.Pack_81 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 81;\n+\n+   type Bits_81 is mod 2 ** Bits;\n+   for Bits_81'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_81\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_81 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_81\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_81;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_81;"}, {"sha": "7e409dd861ea3058b948b556f5f763ecffa98be1", "filename": "gcc/ada/libgnat/s-pack82.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack82.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack82.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack82.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 2                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_82 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_82;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_82 or SetU_82 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_82 --\n+   ------------\n+\n+   function Get_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_82\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_82;\n+\n+   -------------\n+   -- GetU_82 --\n+   -------------\n+\n+   function GetU_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_82\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_82;\n+\n+   ------------\n+   -- Set_82 --\n+   ------------\n+\n+   procedure Set_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_82;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_82;\n+\n+   -------------\n+   -- SetU_82 --\n+   -------------\n+\n+   procedure SetU_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_82;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_82;\n+\n+end System.Pack_82;"}, {"sha": "96a75bf7ad5138bb2a974ec1731cc393281b2a85", "filename": "gcc/ada/libgnat/s-pack82.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack82.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack82.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack82.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 2                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 82\n+\n+package System.Pack_82 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 82;\n+\n+   type Bits_82 is mod 2 ** Bits;\n+   for Bits_82'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_82 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_82;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_82 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_82\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_82;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_82;"}, {"sha": "5fe2441e90cf6febb08d9ef6045a7d4882729c74", "filename": "gcc/ada/libgnat/s-pack83.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack83.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack83.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack83.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 3                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_83 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_83;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_83 --\n+   ------------\n+\n+   function Get_83\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_83\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_83;\n+\n+   ------------\n+   -- Set_83 --\n+   ------------\n+\n+   procedure Set_83\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_83;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_83;\n+\n+end System.Pack_83;"}, {"sha": "75ccd5bbfddc60f869eaf160b9161869be153661", "filename": "gcc/ada/libgnat/s-pack83.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack83.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack83.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack83.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 3                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 83\n+\n+package System.Pack_83 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 83;\n+\n+   type Bits_83 is mod 2 ** Bits;\n+   for Bits_83'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_83\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_83 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_83\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_83;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_83;"}, {"sha": "29b645421eaa7c1ff17501c8d18f340c71390e04", "filename": "gcc/ada/libgnat/s-pack84.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack84.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack84.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack84.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 4                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_84 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_84;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_84 or SetU_84 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_84 --\n+   ------------\n+\n+   function Get_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_84\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_84;\n+\n+   -------------\n+   -- GetU_84 --\n+   -------------\n+\n+   function GetU_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_84\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_84;\n+\n+   ------------\n+   -- Set_84 --\n+   ------------\n+\n+   procedure Set_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_84;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_84;\n+\n+   -------------\n+   -- SetU_84 --\n+   -------------\n+\n+   procedure SetU_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_84;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_84;\n+\n+end System.Pack_84;"}, {"sha": "c3055f9c2b06215096fd111acc8bc5df85dbee2f", "filename": "gcc/ada/libgnat/s-pack84.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack84.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack84.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack84.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 4                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 84\n+\n+package System.Pack_84 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 84;\n+\n+   type Bits_84 is mod 2 ** Bits;\n+   for Bits_84'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_84 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_84;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_84 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_84\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_84;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_84;"}, {"sha": "6edf9d1d8ce98354b4c7e1ffe84e900800798ad8", "filename": "gcc/ada/libgnat/s-pack85.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack85.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack85.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack85.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 5                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_85 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_85;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_85 --\n+   ------------\n+\n+   function Get_85\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_85\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_85;\n+\n+   ------------\n+   -- Set_85 --\n+   ------------\n+\n+   procedure Set_85\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_85;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_85;\n+\n+end System.Pack_85;"}, {"sha": "71bb986c0d01c2931b5347e925922779197d7187", "filename": "gcc/ada/libgnat/s-pack85.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack85.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack85.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack85.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 5                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 85\n+\n+package System.Pack_85 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 85;\n+\n+   type Bits_85 is mod 2 ** Bits;\n+   for Bits_85'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_85\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_85 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_85\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_85;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_85;"}, {"sha": "39e8bca06fa6ad60953b1a2c6b4595685e14cb47", "filename": "gcc/ada/libgnat/s-pack86.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack86.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 6                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_86 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_86;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_86 or SetU_86 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_86 --\n+   ------------\n+\n+   function Get_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_86\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_86;\n+\n+   -------------\n+   -- GetU_86 --\n+   -------------\n+\n+   function GetU_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_86\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_86;\n+\n+   ------------\n+   -- Set_86 --\n+   ------------\n+\n+   procedure Set_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_86;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_86;\n+\n+   -------------\n+   -- SetU_86 --\n+   -------------\n+\n+   procedure SetU_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_86;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_86;\n+\n+end System.Pack_86;"}, {"sha": "0dee4491b05c3d0b0f1027078deda81f69a65ada", "filename": "gcc/ada/libgnat/s-pack86.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack86.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 6                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 86\n+\n+package System.Pack_86 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 86;\n+\n+   type Bits_86 is mod 2 ** Bits;\n+   for Bits_86'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_86 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_86;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_86 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_86\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_86;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_86;"}, {"sha": "8bfc7b408745220eada45d8e9f9bde8671d1ad8e", "filename": "gcc/ada/libgnat/s-pack87.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack87.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack87.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack87.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 7                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_87 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_87;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_87 --\n+   ------------\n+\n+   function Get_87\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_87\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_87;\n+\n+   ------------\n+   -- Set_87 --\n+   ------------\n+\n+   procedure Set_87\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_87;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_87;\n+\n+end System.Pack_87;"}, {"sha": "ad8071328346f28177011208e05d21a7898273a3", "filename": "gcc/ada/libgnat/s-pack87.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack87.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack87.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack87.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 7                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 87\n+\n+package System.Pack_87 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 87;\n+\n+   type Bits_87 is mod 2 ** Bits;\n+   for Bits_87'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_87\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_87 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_87\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_87;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_87;"}, {"sha": "638581a299d20a5172e03dc125f39509c311b115", "filename": "gcc/ada/libgnat/s-pack88.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack88.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack88.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack88.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 8                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_88 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_88;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_88 or SetU_88 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_88 --\n+   ------------\n+\n+   function Get_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_88\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_88;\n+\n+   -------------\n+   -- GetU_88 --\n+   -------------\n+\n+   function GetU_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_88\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_88;\n+\n+   ------------\n+   -- Set_88 --\n+   ------------\n+\n+   procedure Set_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_88;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_88;\n+\n+   -------------\n+   -- SetU_88 --\n+   -------------\n+\n+   procedure SetU_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_88;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_88;\n+\n+end System.Pack_88;"}, {"sha": "bd38bd79ace9399420fa25bd546aae1378027671", "filename": "gcc/ada/libgnat/s-pack88.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack88.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack88.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack88.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 8                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 88\n+\n+package System.Pack_88 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 88;\n+\n+   type Bits_88 is mod 2 ** Bits;\n+   for Bits_88'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_88 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_88;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_88 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_88\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_88;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_88;"}, {"sha": "eff29c0cbcc222bf424fb989443605b4ae26a0af", "filename": "gcc/ada/libgnat/s-pack89.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack89.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack89.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack89.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 9                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_89 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_89;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_89 --\n+   ------------\n+\n+   function Get_89\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_89\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_89;\n+\n+   ------------\n+   -- Set_89 --\n+   ------------\n+\n+   procedure Set_89\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_89;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_89;\n+\n+end System.Pack_89;"}, {"sha": "5ab81020da1af453f944360961d1cc44800b56a0", "filename": "gcc/ada/libgnat/s-pack89.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack89.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack89.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack89.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 8 9                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 89\n+\n+package System.Pack_89 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 89;\n+\n+   type Bits_89 is mod 2 ** Bits;\n+   for Bits_89'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_89\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_89 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_89\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_89;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_89;"}, {"sha": "bed48459d27812bae836ac483b87ef45e1319210", "filename": "gcc/ada/libgnat/s-pack90.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack90.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack90.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack90.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 0                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_90 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_90;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_90 or SetU_90 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_90 --\n+   ------------\n+\n+   function Get_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_90\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_90;\n+\n+   -------------\n+   -- GetU_90 --\n+   -------------\n+\n+   function GetU_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_90\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_90;\n+\n+   ------------\n+   -- Set_90 --\n+   ------------\n+\n+   procedure Set_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_90;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_90;\n+\n+   -------------\n+   -- SetU_90 --\n+   -------------\n+\n+   procedure SetU_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_90;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_90;\n+\n+end System.Pack_90;"}, {"sha": "29602936b2a6f46cd2a425e2fd7da763bd8beeff", "filename": "gcc/ada/libgnat/s-pack90.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack90.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack90.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack90.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 0                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 90\n+\n+package System.Pack_90 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 90;\n+\n+   type Bits_90 is mod 2 ** Bits;\n+   for Bits_90'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_90 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_90;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_90 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_90\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_90;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_90;"}, {"sha": "25c9f14363ea0016f58e34498c536747afa068e3", "filename": "gcc/ada/libgnat/s-pack91.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack91.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack91.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack91.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 1                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_91 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_91;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_91 --\n+   ------------\n+\n+   function Get_91\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_91\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_91;\n+\n+   ------------\n+   -- Set_91 --\n+   ------------\n+\n+   procedure Set_91\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_91;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_91;\n+\n+end System.Pack_91;"}, {"sha": "065c1b5d2311a755d0ce4fa2f6a3523632795d69", "filename": "gcc/ada/libgnat/s-pack91.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack91.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack91.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack91.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 1                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 91\n+\n+package System.Pack_91 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 91;\n+\n+   type Bits_91 is mod 2 ** Bits;\n+   for Bits_91'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_91\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_91 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_91\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_91;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_91;"}, {"sha": "b9ea0a692d81b15e9cba15b3f5c4f8d2b026f226", "filename": "gcc/ada/libgnat/s-pack92.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack92.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack92.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack92.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,250 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 2                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_92 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_92;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   --  The following declarations are for the case where the address\n+   --  passed to GetU_92 or SetU_92 is not guaranteed to be aligned.\n+   --  These routines are used when the packed array is itself a\n+   --  component of a packed record, and therefore may not be aligned.\n+\n+   type ClusterU is new Cluster;\n+   for ClusterU'Alignment use 1;\n+\n+   type ClusterU_Ref is access ClusterU;\n+\n+   type Rev_ClusterU is new ClusterU\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_ClusterU_Ref is access Rev_ClusterU;\n+\n+   ------------\n+   -- Get_92 --\n+   ------------\n+\n+   function Get_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_92\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_92;\n+\n+   -------------\n+   -- GetU_92 --\n+   -------------\n+\n+   function GetU_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_92\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end GetU_92;\n+\n+   ------------\n+   -- Set_92 --\n+   ------------\n+\n+   procedure Set_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_92;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_92;\n+\n+   -------------\n+   -- SetU_92 --\n+   -------------\n+\n+   procedure SetU_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_92;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : ClusterU_Ref     with Address => A'Address, Import;\n+      RC : Rev_ClusterU_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end SetU_92;\n+\n+end System.Pack_92;"}, {"sha": "5184bc638b83bd7fc569ed5ae1074c9279260587", "filename": "gcc/ada/libgnat/s-pack92.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack92.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack92.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack92.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 2                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 92\n+\n+package System.Pack_92 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 92;\n+\n+   type Bits_92 is mod 2 ** Bits;\n+   for Bits_92'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_92 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_92;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+   function GetU_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_92 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned. This version\n+   --  is used when Arr may represent an unaligned address.\n+\n+   procedure SetU_92\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_92;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value. This version\n+   --  is used when Arr may represent an unaligned address\n+\n+end System.Pack_92;"}, {"sha": "1fe486c1eee2b74d1ee4474eeb8b54f161e2c6bd", "filename": "gcc/ada/libgnat/s-pack93.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack93.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack93.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack93.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 3                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+with System.Unsigned_Types;\n+\n+package body System.Pack_93 is\n+\n+   subtype Bit_Order is System.Bit_Order;\n+   Reverse_Bit_Order : constant Bit_Order :=\n+     Bit_Order'Val (1 - Bit_Order'Pos (System.Default_Bit_Order));\n+\n+   subtype Ofs is System.Storage_Elements.Storage_Offset;\n+   subtype Uns is System.Unsigned_Types.Unsigned;\n+   subtype N07 is System.Unsigned_Types.Unsigned range 0 .. 7;\n+\n+   use type System.Storage_Elements.Storage_Offset;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   type Cluster is record\n+      E0, E1, E2, E3, E4, E5, E6, E7 : Bits_93;\n+   end record;\n+\n+   for Cluster use record\n+      E0 at 0 range 0 * Bits .. 0 * Bits + Bits - 1;\n+      E1 at 0 range 1 * Bits .. 1 * Bits + Bits - 1;\n+      E2 at 0 range 2 * Bits .. 2 * Bits + Bits - 1;\n+      E3 at 0 range 3 * Bits .. 3 * Bits + Bits - 1;\n+      E4 at 0 range 4 * Bits .. 4 * Bits + Bits - 1;\n+      E5 at 0 range 5 * Bits .. 5 * Bits + Bits - 1;\n+      E6 at 0 range 6 * Bits .. 6 * Bits + Bits - 1;\n+      E7 at 0 range 7 * Bits .. 7 * Bits + Bits - 1;\n+   end record;\n+\n+   for Cluster'Size use Bits * 8;\n+\n+   for Cluster'Alignment use Integer'Min (Standard'Maximum_Alignment,\n+     1 +\n+     1 * Boolean'Pos (Bits mod 2 = 0) +\n+     2 * Boolean'Pos (Bits mod 4 = 0));\n+   --  Use maximum possible alignment, given the bit field size, since this\n+   --  will result in the most efficient code possible for the field.\n+\n+   type Cluster_Ref is access Cluster;\n+\n+   type Rev_Cluster is new Cluster\n+     with Bit_Order            => Reverse_Bit_Order,\n+          Scalar_Storage_Order => Reverse_Bit_Order;\n+   type Rev_Cluster_Ref is access Rev_Cluster;\n+\n+   ------------\n+   -- Get_93 --\n+   ------------\n+\n+   function Get_93\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_93\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return RC.E0;\n+            when 1 => return RC.E1;\n+            when 2 => return RC.E2;\n+            when 3 => return RC.E3;\n+            when 4 => return RC.E4;\n+            when 5 => return RC.E5;\n+            when 6 => return RC.E6;\n+            when 7 => return RC.E7;\n+         end case;\n+\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => return C.E0;\n+            when 1 => return C.E1;\n+            when 2 => return C.E2;\n+            when 3 => return C.E3;\n+            when 4 => return C.E4;\n+            when 5 => return C.E5;\n+            when 6 => return C.E6;\n+            when 7 => return C.E7;\n+         end case;\n+      end if;\n+   end Get_93;\n+\n+   ------------\n+   -- Set_93 --\n+   ------------\n+\n+   procedure Set_93\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_93;\n+      Rev_SSO : Boolean)\n+   is\n+      A  : constant System.Address := Arr + Bits * Ofs (Uns (N) / 8);\n+      C  : Cluster_Ref     with Address => A'Address, Import;\n+      RC : Rev_Cluster_Ref with Address => A'Address, Import;\n+   begin\n+      if Rev_SSO then\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => RC.E0 := E;\n+            when 1 => RC.E1 := E;\n+            when 2 => RC.E2 := E;\n+            when 3 => RC.E3 := E;\n+            when 4 => RC.E4 := E;\n+            when 5 => RC.E5 := E;\n+            when 6 => RC.E6 := E;\n+            when 7 => RC.E7 := E;\n+         end case;\n+      else\n+         case N07 (Uns (N) mod 8) is\n+            when 0 => C.E0 := E;\n+            when 1 => C.E1 := E;\n+            when 2 => C.E2 := E;\n+            when 3 => C.E3 := E;\n+            when 4 => C.E4 := E;\n+            when 5 => C.E5 := E;\n+            when 6 => C.E6 := E;\n+            when 7 => C.E7 := E;\n+         end case;\n+      end if;\n+   end Set_93;\n+\n+end System.Pack_93;"}, {"sha": "618ab641203c0a992b089eac22646eef49025c1e", "filename": "gcc/ada/libgnat/s-pack93.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack93.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack93.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack93.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . P A C K _ 9 3                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Handling of packed arrays with Component_Size = 93\n+\n+package System.Pack_93 is\n+   pragma Preelaborate;\n+\n+   Bits : constant := 93;\n+\n+   type Bits_93 is mod 2 ** Bits;\n+   for Bits_93'Size use Bits;\n+\n+   --  In all subprograms below, Rev_SSO is set True if the array has the\n+   --  non-default scalar storage order.\n+\n+   function Get_93\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      Rev_SSO : Boolean) return Bits_93 with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is extracted and returned.\n+\n+   procedure Set_93\n+     (Arr     : System.Address;\n+      N       : Natural;\n+      E       : Bits_93;\n+      Rev_SSO : Boolean) with Inline;\n+   --  Arr is the address of the packed array, N is the zero-based\n+   --  subscript. This element is set to the given value.\n+\n+end System.Pack_93;"}, {"sha": "5a659083f350ea6dc3b7cf72837d0b14a46bac85", "filename": "gcc/ada/libgnat/s-pack94.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack94.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack94.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack94.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "692a4dc068996e5939109ddca1045443e82f1158", "filename": "gcc/ada/libgnat/s-pack94.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack94.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack94.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack94.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "f8d6be6683558c6c63dc0bc44c5f1854f9976503", "filename": "gcc/ada/libgnat/s-pack95.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack95.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack95.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack95.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "288a78794c9faf387cd63019d7b1c899384f9a19", "filename": "gcc/ada/libgnat/s-pack95.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack95.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack95.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack95.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "1371ee15d8e032fbba0d6c3bfb383c1a2c60febb", "filename": "gcc/ada/libgnat/s-pack96.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack96.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack96.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack96.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "355f00a579b322160cfba1bb027657bb2428e5a1", "filename": "gcc/ada/libgnat/s-pack96.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack96.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack96.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack96.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "000f8ed96446514421fea8eb076477c83094ca7d", "filename": "gcc/ada/libgnat/s-pack97.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack97.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack97.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack97.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "4c8a936526e9e112b243212efa8178ba95f73579", "filename": "gcc/ada/libgnat/s-pack97.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack97.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack97.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack97.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "1ac4c66fdd1f95626dbbd44ecee5ac97b62e3dcf", "filename": "gcc/ada/libgnat/s-pack98.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack98.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack98.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack98.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "239eca13d5388ff1ed45727999423a9385018f94", "filename": "gcc/ada/libgnat/s-pack98.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack98.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack98.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack98.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "a8bde8887662eaedf91c604751e955023fc0c12c", "filename": "gcc/ada/libgnat/s-pack99.adb", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack99.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack99.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack99.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "fa805c4acff627c3530bd1d0170fb07f0917daca", "filename": "gcc/ada/libgnat/s-pack99.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack99.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-pack99.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pack99.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "e65e6a7723344810a3d1cef569e3dac2e0678bca", "filename": "gcc/ada/libgnat/s-rannum.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-rannum.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "6cbba3e4b4e34ffd3ff14d45ab2bf7552a5de5fd", "filename": "gcc/ada/libgnat/s-rannum.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-rannum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-rannum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-rannum.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "5a88111e3b35a097b0f82ce2d866dbc245fb3ab0", "filename": "gcc/ada/libgnat/s-scaval.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-scaval.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "6d13262503792120776185b87595175b569305b0", "filename": "gcc/ada/libgnat/s-scaval.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-scaval.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "53110c23e86b967eb6b3bf15368b6d6b36ce068b", "filename": "gcc/ada/libgnat/s-scaval__128.adb", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-scaval__128.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "8eb1b6546fbdc6266fe27980edb663557d4ea7a3", "filename": "gcc/ada/libgnat/s-scaval__128.ads", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval__128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-scaval__128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-scaval__128.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "86c5d7f81375c00ba7b65e7f2b4d3d9d1dc5e967", "filename": "gcc/ada/libgnat/s-unstyp.ads", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-unstyp.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "28c6aca867573afa5332e5dcf36699ff6257bb75", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 749, "deletions": 31, "changes": 780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "b4872f0027631f8946a7716ef7a909c504df5313", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "636d44f99aed10ffecb2ff403c3c3fa42ac42b1e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "e103793f14b5012227a252621493c21107ecaddc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "0efe8f36204db63bc5097fd4e80b089c83419be8", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "f3d9f44295e6d24be66dd62108e50856eeae5986", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "ba867231685a5700f534de705c4cc93c3fc7b9ce", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "f59df36d66b628cde7a9e8141c2193cda2b2a590", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "9c7b8ca835a39d6714fe46bdbab798b8af22d34e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "c1c83cb5751dbb1502f853034dc7ec45311a5a3f", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "e25f351f0b39ee5f57eaaceddb558cc760b49877", "filename": "gcc/ada/set_targ.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fset_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fset_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "af69d773950cea69b19889e6080d3634482f232f", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "be9d215141e8839fad6bf81b52c18d287d662ded", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "0851307cd2dde74f5b7456308b282b4b9134efd7", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "ebd02b3d6af2bfc1f1fd941eae44eb095873bd7a", "filename": "gcc/ada/ttypes.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "060971c132aee2d86ac8654de1c3f00aced125cd", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "895aeb183768394adbefe63aa27dc2af3b753cf1", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "133e34fd7ce3a969e03cf896844d4514a804c31f", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}, {"sha": "572cd32c748676c057868b425515004ae6526df7", "filename": "gcc/testsuite/gnat.dg/multfixed.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb?ref=a5476382a7f9a9732b1c0095cbd9cbc3ecd99edb"}]}