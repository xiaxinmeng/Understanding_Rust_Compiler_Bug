{"sha": "e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNkMGVlNGFjZjJiYzg0YTNlMDgxNDQyYmEwMjJhYjE0ODk1OGE3Yg==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-11-13T12:37:44Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-11-13T12:37:44Z"}, "message": "Move gcn-run heap into GPU memory.\n\n2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/gcn-run.c (heap_region): New global variable.\n\t(struct hsa_runtime_fn_info): Add hsa_memory_assign_agent_fn.\n\t(init_hsa_runtime_functions): Initialize hsa_memory_assign_agent.\n\t(get_kernarg_region): Move contents to ....\n\t(get_memory_region): .... here.\n\t(get_heap_region): New function.\n\t(init_device): Initialize the heap_region.\n\t(device_malloc): Add region parameter.\n\t(struct kernargs): Move heap ....\n\t(heap): ... to global scope.\n\t(main): Allocate heap separate to kernargs.\n\nFrom-SVN: r278131", "tree": {"sha": "dc7b37e290a51a82d5c0a53b97e6eda34d57614b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc7b37e290a51a82d5c0a53b97e6eda34d57614b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d0ee4acf2bc84a3e081442ba022ab148958a7b/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2dbad62da9a2b1734aa74b2b0fcf6fb3ff52a4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbad62da9a2b1734aa74b2b0fcf6fb3ff52a4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dbad62da9a2b1734aa74b2b0fcf6fb3ff52a4ac"}], "stats": {"total": 78, "additions": 62, "deletions": 16}, "files": [{"sha": "c2daf40682654cbe0546b1aa94bd4f6e631d188c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d0ee4acf2bc84a3e081442ba022ab148958a7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d0ee4acf2bc84a3e081442ba022ab148958a7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "patch": "@@ -1,3 +1,17 @@\n+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/gcn-run.c (heap_region): New global variable.\n+\t(struct hsa_runtime_fn_info): Add hsa_memory_assign_agent_fn.\n+\t(init_hsa_runtime_functions): Initialize hsa_memory_assign_agent.\n+\t(get_kernarg_region): Move contents to ....\n+\t(get_memory_region): .... here.\n+\t(get_heap_region): New function.\n+\t(init_device): Initialize the heap_region.\n+\t(device_malloc): Add region parameter.\n+\t(struct kernargs): Move heap ....\n+\t(heap): ... to global scope.\n+\t(main): Allocate heap separate to kernargs.\n+\n 2019-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (ipa_print_node_jump_functions,"}, {"sha": "cf4870ff4be72cd1a4298f4bc535ae11a3573743", "filename": "gcc/config/gcn/gcn-run.c", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d0ee4acf2bc84a3e081442ba022ab148958a7b/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d0ee4acf2bc84a3e081442ba022ab148958a7b/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-run.c?ref=e3d0ee4acf2bc84a3e081442ba022ab148958a7b", "patch": "@@ -72,6 +72,7 @@ uint64_t main_kernel = 0;\n hsa_executable_t executable = { 0 };\n \n hsa_region_t kernargs_region = { 0 };\n+hsa_region_t heap_region = { 0 };\n uint32_t kernarg_segment_size = 0;\n uint32_t group_segment_size = 0;\n uint32_t private_segment_size = 0;\n@@ -135,6 +136,8 @@ struct hsa_runtime_fn_info\n \t\t\t\t\thsa_signal_t *signal);\n   hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,\n \t\t\t\t\t  void **ptr);\n+  hsa_status_t (*hsa_memory_assign_agent_fn) (void *ptr, hsa_agent_t agent,\n+\t\t\t\t\t      hsa_access_permission_t access);\n   hsa_status_t (*hsa_memory_copy_fn) (void *dst, const void *src,\n \t\t\t\t      size_t size);\n   hsa_status_t (*hsa_memory_free_fn) (void *ptr);\n@@ -204,6 +207,7 @@ init_hsa_runtime_functions (void)\n   DLSYM_FN (hsa_executable_freeze)\n   DLSYM_FN (hsa_signal_create)\n   DLSYM_FN (hsa_memory_allocate)\n+  DLSYM_FN (hsa_memory_assign_agent)\n   DLSYM_FN (hsa_memory_copy)\n   DLSYM_FN (hsa_memory_free)\n   DLSYM_FN (hsa_signal_destroy)\n@@ -282,7 +286,8 @@ get_gpu_agent (hsa_agent_t agent, void *data __attribute__ ((unused)))\n    suitable one has been found.  */\n \n static hsa_status_t\n-get_kernarg_region (hsa_region_t region, void *data __attribute__ ((unused)))\n+get_memory_region (hsa_region_t region, hsa_region_t *retval,\n+\t\t   hsa_region_global_flag_t kind)\n {\n   /* Reject non-global regions.  */\n   hsa_region_segment_t segment;\n@@ -294,16 +299,30 @@ get_kernarg_region (hsa_region_t region, void *data __attribute__ ((unused)))\n   hsa_region_global_flag_t flags;\n   hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,\n \t\t\t\t  &flags);\n-  if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)\n+  if (flags & kind)\n     {\n-      kernargs_region = region;\n+      *retval = region;\n       return HSA_STATUS_INFO_BREAK;\n     }\n \n   /* The region was not suitable.  */\n   return HSA_STATUS_SUCCESS;\n }\n \n+static hsa_status_t\n+get_kernarg_region (hsa_region_t region, void *data __attribute__((unused)))\n+{\n+  return get_memory_region (region, &kernargs_region,\n+\t\t\t    HSA_REGION_GLOBAL_FLAG_KERNARG);\n+}\n+\n+static hsa_status_t\n+get_heap_region (hsa_region_t region, void *data __attribute__((unused)))\n+{\n+  return get_memory_region (region, &heap_region,\n+\t\t\t    HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED);\n+}\n+\n /* Initialize the HSA Runtime library and GPU device.  */\n \n static void\n@@ -338,6 +357,13 @@ init_device ()\n \t\t\t\t\t\t  NULL),\n \t    status == HSA_STATUS_SUCCESS || status == HSA_STATUS_INFO_BREAK,\n \t    \"Locate kernargs memory\");\n+\n+  /* Select a memory region for the kernel heap.\n+     The call-back function, get_heap_region, does the selection.  */\n+  XHSA_CMP (hsa_fns.hsa_agent_iterate_regions_fn (device, get_heap_region,\n+\t\t\t\t\t\t  NULL),\n+\t    status == HSA_STATUS_SUCCESS || status == HSA_STATUS_INFO_BREAK,\n+\t    \"Locate device memory\");\n }\n \n \n@@ -593,10 +619,10 @@ found_main:;\n    __flat_scalar GCN address space).  */\n \n static void *\n-device_malloc (size_t size)\n+device_malloc (size_t size, hsa_region_t region)\n {\n   void *result;\n-  XHSA (hsa_fns.hsa_memory_allocate_fn (kernargs_region, size, &result),\n+  XHSA (hsa_fns.hsa_memory_allocate_fn (region, size, &result),\n \t\"Allocate device memory\");\n   return result;\n }\n@@ -634,14 +660,14 @@ struct kernargs\n     } queue[1024];\n     unsigned int consumed;\n   } output_data;\n-\n-  struct heap\n-  {\n-    int64_t size;\n-    char data[0];\n-  } heap;\n };\n \n+struct heap\n+{\n+  int64_t size;\n+  char data[0];\n+} heap;\n+\n /* Print any console output from the kernel.\n    We print all entries from \"consumed\" to the next entry without a \"written\"\n    flag, or \"next_output\" is reached.  The buffer is circular, but the\n@@ -811,13 +837,19 @@ main (int argc, char *argv[])\n \n   /* Allocate device memory for both function parameters and the argv\n      data.  */\n-  size_t heap_size = 10 * 1024 * 1024;\t/* 10MB.  */\n-  struct kernargs *kernargs = device_malloc (sizeof (*kernargs) + heap_size);\n+  struct kernargs *kernargs = device_malloc (sizeof (*kernargs),\n+\t\t\t\t\t     kernargs_region);\n   struct argdata\n   {\n     int64_t argv_data[kernel_argc];\n     char strings[args_size];\n-  } *args = device_malloc (sizeof (struct argdata));\n+  } *args = device_malloc (sizeof (struct argdata), kernargs_region);\n+\n+  size_t heap_size = 10 * 1024 * 1024;\t/* 10MB.  */\n+  struct heap *heap = device_malloc (heap_size, heap_region);\n+  XHSA (hsa_fns.hsa_memory_assign_agent_fn (heap, device,\n+\t\t\t\t\t    HSA_ACCESS_PERMISSION_RW),\n+\t\"Assign heap to device agent\");\n \n   /* Write the data to the target.  */\n   kernargs->argc = kernel_argc;\n@@ -837,8 +869,8 @@ main (int argc, char *argv[])\n       memcpy (&args->strings[offset], kernel_argv[i], arg_len + 1);\n       offset += arg_len;\n     }\n-  kernargs->heap_ptr = (int64_t) &kernargs->heap;\n-  kernargs->heap.size = heap_size;\n+  kernargs->heap_ptr = (int64_t) heap;\n+  hsa_fns.hsa_memory_copy_fn (&heap->size, &heap_size, sizeof (heap_size));\n \n   /* Run constructors on the GPU.  */\n   run (init_array_kernel, kernargs);"}]}