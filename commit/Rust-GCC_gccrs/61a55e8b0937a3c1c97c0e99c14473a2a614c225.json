{"sha": "61a55e8b0937a3c1c97c0e99c14473a2a614c225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhNTVlOGIwOTM3YTNjMWM5N2MwZTk5YzE0NDczYTJhNjE0YzIyNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:49:12Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:49:12Z"}, "message": "sparc.c (SKIP_CALLERS_UNIMP_P): Define.\n\n\t* sparc/sparc.c (SKIP_CALLERS_UNIMP_P): Define.\n\t(sparc_cpu_type, sparc_arg_count, sparc_n_named_args,\n\tframe_base_offset, fpconv_stack_temp): New globals.\n\t(leaf_reg_remap): Add additional registers for v9.\n\t(sparc_override_options, sparc64_init_expanders,\n\tsparc64_fpconv_stack_temp, intreg_operand, ccfp_reg_operand,\n\tdata_segment_operand, text_segment_operand, v9_regcmp_op,\n\tarith11_operand, arith10_operand, arith11_double_operand,\n\tarith10_double_operand, gen_v9_scc, emit_v9_brxx_insn,\n\tsparc_init_modes, build_big_number, output_v9branch,\n\tsparc_initialize_trampoline, sparc64_initialize_trampoline):\n\tNew functions.\n\t(arith_double_operand, gen_compare_reg, finalize_pic,\n\temit_move_sequence, mem_aligned_8, output_move_double,\n\toutput_move_quad, output_fp_move_double, output_fp_move_quad,\n\toutput_block_move, save_regs, restore_regs): Add v9 support.\n\t(sparc_mode_class): New enum.\n\t(*_MODES): Redefine to use it.\n\t(hard_32bit_mode_classes): Renamed from hard_regno_mode_ok.\n\t(hard_regno_mode_classes, hard_64bit_mode_classes,\n\tsparc_mode_class): New globals.\n\t(num_gfregs): Renamed from num_fregs.\n\t(compute_frame_size): Add v9 support.  Simplify calculations.\n\t(output_function_prologue): Call build_big_number to compute stack\n\tsize in %g1, then adjust %sp.\n\tFix saving of call saved registers.  Handle new v9 registers.\n\t(output_function_epilogue): Fix restoration of call saved registers.\n\tHandle new v9 registers.\n\tUse SKIP_CALLERS_UNIMP_P to see if unimp insn is at return address.\n\t(sparc_builtin_saveregs): Define v9 version.\n\t(output_cbranch): New argument fp_cond_reg.  All callers changed.\n\tAdd v9 support.\n\t(output_return): Use SKIP_CALLERS_UNIMP_P.\n\t(print_operand): New codes '_', '@', 'C', 'D'.\n\t(output_double_int): Handle LABEL_REF and MINUS for v9.\n\tUse ASM_LONGLONG if assembler can handle it.\n\nFrom-SVN: r7486", "tree": {"sha": "742dca466cb260888d3c6c8fcb151283215bcfee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/742dca466cb260888d3c6c8fcb151283215bcfee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a55e8b0937a3c1c97c0e99c14473a2a614c225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a55e8b0937a3c1c97c0e99c14473a2a614c225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a55e8b0937a3c1c97c0e99c14473a2a614c225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a55e8b0937a3c1c97c0e99c14473a2a614c225/comments", "author": null, "committer": null, "parents": [{"sha": "7a6cf439109c013148426537f69468fe60add3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6cf439109c013148426537f69468fe60add3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6cf439109c013148426537f69468fe60add3a2"}], "stats": {"total": 1547, "additions": 1357, "deletions": 190}, "files": [{"sha": "654096d35469f82bbb9de658954ff3c1c144653a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1357, "deletions": 190, "changes": 1547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a55e8b0937a3c1c97c0e99c14473a2a614c225/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a55e8b0937a3c1c97c0e99c14473a2a614c225/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=61a55e8b0937a3c1c97c0e99c14473a2a614c225", "patch": "@@ -1,6 +1,8 @@\n /* Subroutines for insn-output.c for Sun SPARC.\n    Copyright (C) 1987, 88, 89, 92, 93, 1994 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n+   64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n+   at Cygnus Support.\n \n This file is part of GNU CC.\n \n@@ -34,13 +36,42 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"expr.h\"\n #include \"recog.h\"\n \n+/* 1 if the caller has placed an \"unimp\" insn immediately after the call.\n+   This is used in v8 code when calling a function that returns a structure.\n+   v9 doesn't have this.  */\n+\n+#define SKIP_CALLERS_UNIMP_P (!TARGET_V9 && current_function_returns_struct)\n+\n /* Global variables for machine-dependent things.  */\n \n+/* Says what cpu we're compiling for.  */\n+enum cpu_type sparc_cpu_type;\n+\n+/* Size of frame.  Need to know this to emit return insns from leaf procedures.\n+   ACTUAL_FSIZE is set by compute_frame_size() which is called during the\n+   reload pass.  This is important as the value is later used in insn\n+   scheduling (to see what can go in a delay slot).\n+   APPARENT_FSIZE is the size of the stack less the register save area and less\n+   the outgoing argument area.  It is used when saving call preserved regs.  */\n+static int apparent_fsize;\n+static int actual_fsize;\n+\n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n \n rtx sparc_compare_op0, sparc_compare_op1;\n \n+/* Count of named arguments (v9 only).\n+   ??? INIT_CUMULATIVE_ARGS initializes these, and FUNCTION_ARG_ADVANCE\n+   increments SPARC_ARG_COUNT. They are then used by\n+   FUNCTION_ARG_CALLEE_COPIES to determine if the argument is really a named\n+   argument or not.  This hack is necessary because the NAMED argument to the\n+   FUNCTION_ARG_XXX macros is not what it says it is: it does not include the\n+   last named argument.  */\n+\n+int sparc_arg_count;\n+int sparc_n_named_args;\n+\n /* We may need an epilogue if we spill too many registers.\n    If this is non-zero, then we branch here for the epilogue.  */\n static rtx leaf_label;\n@@ -60,23 +91,123 @@ char leaf_reg_remap[] =\n   32, 33, 34, 35, 36, 37, 38, 39,\n   40, 41, 42, 43, 44, 45, 46, 47,\n   48, 49, 50, 51, 52, 53, 54, 55,\n-  56, 57, 58, 59, 60, 61, 62, 63};\n+  56, 57, 58, 59, 60, 61, 62, 63,\n+  64, 65, 66, 67, 68, 69, 70, 71,\n+  72, 73, 74, 75, 76, 77, 78, 79,\n+  80, 81, 82, 83, 84, 85, 86, 87,\n+  88, 89, 90, 91, 92, 93, 94, 95,\n+  96, 97, 98, 99};\n \n #endif\n \n-/* Global variables set by FUNCTION_PROLOGUE.  */\n-/* Size of frame.  Need to know this to emit return insns from\n-   leaf procedures.  */\n-static int apparent_fsize;\n-static int actual_fsize;\n-\n /* Name of where we pretend to think the frame pointer points.\n    Normally, this is \"%fp\", but if we are in a leaf procedure,\n-   this is \"%sp+something\".  */\n-char *frame_base_name;\n+   this is \"%sp+something\".  We record \"something\" separately as it may be\n+   too big for reg+constant addressing.  */\n+\n+static char *frame_base_name;\n+static int frame_base_offset;\n \n static rtx find_addr_reg ();\n+static void sparc_init_modes ();\n+\f\n+/* Option handling.  */\n+\n+/* Contains one of: medium-low, medium-anywhere.  */\n+/* ??? These names are quite long.  */\n+\n+char *sparc_code_model;\n+\n+/* Validate and override various options, and do some machine dependent\n+   initialization.  */\n+\n+void\n+sparc_override_options ()\n+{\n+  if (sparc_code_model == 0)\n+    /* Nothing to do.  */\n+    ;\n+  else if (! TARGET_V9)\n+    error (\"code model support is only available with -mv9\");\n+  else if (strcmp (sparc_code_model, \"medium-low\") == 0)\n+    {\n+      target_flags &= ~MASK_CODE_MODEL;\n+      target_flags |= MASK_MEDLOW;\n+    }\n+  else if (strcmp (sparc_code_model, \"medium-anywhere\") == 0)\n+    {\n+      target_flags &= ~MASK_CODE_MODEL;\n+      target_flags |= MASK_MEDANY;\n+    }\n+  else\n+    error (\"bad value (%s) for -mcode-model switch\", sparc_code_model);\n+\n+  /* Check for any conflicts in the choice of options.  */\n+  /* ??? This stuff isn't really usable yet.  */\n+\n+  if (! TARGET_V9)\n+    {\n+      if (TARGET_INT64)\n+\terror (\"-mint64 is only available with -mv9\");\n+      if (TARGET_LONG64)\n+\terror (\"-mlong64 is only available with -mv9\");\n+      if (TARGET_PTR64)\n+\terror (\"-mptr64 is only available with -mv9\");\n+      if (TARGET_ENV32)\n+\terror (\"-menv32 is only available with -mv9\");\n+      if (TARGET_STACK_BIAS)\n+\terror (\"-mstack-bias is only available with -mv9\");\n+    }\n+  else\n+    {\n+      /* ??? Are there any options that aren't usable with v9.\n+\t -munaligned-doubles?  */\n+    }\n+\n+  /* Check for conflicts in cpu specification.\n+     If we use -mcpu=xxx, this can be removed.  */\n+\n+  if ((TARGET_V8 != 0) + (TARGET_SPARCLITE != 0) + (TARGET_V9 != 0) > 1)\n+    error (\"conflicting architectures defined\");\n+\n+  /* Do various machine dependent initializations.  */\n+  sparc_init_modes ();\n+}\n+\f\n+/* Float conversions (v9 only).\n+\n+   The floating point registers cannot hold DImode values because SUBREG's\n+   on them get the wrong register.   \"(subreg:SI (reg:DI M int-reg) 0)\" is the\n+   same as \"(subreg:SI (reg:DI N float-reg) 1)\", but gcc doesn't know how to\n+   turn the \"0\" to a \"1\".  Therefore, we must explicitly do the conversions\n+   to/from int/fp regs.  `sparc64_fpconv_stack_slot' is the address of an\n+   8 byte stack slot used during the transfer.\n+   ??? I could have used [%fp-16] but I didn't want to add yet another\n+   dependence on this.  */\n+/* ??? Can we use assign_stack_temp here?  */\n+\n+static rtx fpconv_stack_temp;\n+\n+/* Called once for each function.  */\n+\n+void\n+sparc64_init_expanders ()\n+{\n+  fpconv_stack_temp = NULL_RTX;\n+}\n+\n+/* Assign a stack temp for fp/int DImode conversions.  */\n \n+rtx\n+sparc64_fpconv_stack_temp ()\n+{\n+  if (fpconv_stack_temp == NULL_RTX)\n+      fpconv_stack_temp =\n+\tassign_stack_local (DImode, GET_MODE_SIZE (DImode), 0);\n+\n+    return fpconv_stack_temp;\n+}\n+\f\n /* Return non-zero only if OP is a register of mode MODE,\n    or const0_rtx.  */\n int\n@@ -108,6 +239,40 @@ fp_zero_operand (op)\n   return REAL_VALUES_EQUAL (r, dconst0);\n }\n \n+/* Nonzero if OP is an integer register.  */\n+\n+int\n+intreg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, SImode)\n+\t  || (TARGET_V9 && register_operand (op, DImode)));\n+}\n+\n+/* Nonzero if OP is a floating point condition code register.  */\n+\n+int\n+ccfp_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* This can happen when recog is called from combine.  Op may be a MEM.\n+     Fail instead of calling abort in this case.  */\n+  if (GET_CODE (op) != REG || REGNO (op) == 0)\n+    return 0;\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+#if 0\t/* ??? ==> 1 when %fcc1-3 are pseudos first.  See gen_compare_reg().  */\n+  if (reg_renumber == 0)\n+    return REGNO (op) >= FIRST_PSEUDO_REGISTER;\n+  return REGNO_OK_FOR_CCFP_P (REGNO (op));\n+#else\n+  return (unsigned) REGNO (op) - 96 < 4;\n+#endif\n+}\n+\n /* Nonzero if OP can appear as the dest of a RESTORE insn.  */\n int\n restore_operand (op, mode)\n@@ -186,6 +351,52 @@ symbolic_memory_operand (op, mode)\n \t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n }\n \n+/* Return 1 if the operand is a data segment reference.  This includes\n+   the readonly data segment, or in other words anything but the text segment.\n+   This is needed in the medium/anywhere code model on v9.  These values\n+   are accessed with MEDANY_BASE_REG.  */\n+\n+int\n+data_segment_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+      return ! SYMBOL_REF_FLAG (op);\n+    case PLUS :\n+      /* Assume canonical format of symbol + constant.  */\n+    case CONST :\n+      return data_segment_operand (XEXP (op, 0));\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if the operand is a text segment reference.\n+   This is needed in the medium/anywhere code model on v9.  */\n+\n+int\n+text_segment_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF :\n+      return 1;\n+    case SYMBOL_REF :\n+      return SYMBOL_REF_FLAG (op);\n+    case PLUS :\n+      /* Assume canonical format of symbol + constant.  */\n+    case CONST :\n+      return text_segment_operand (XEXP (op, 0));\n+    default :\n+      return 0;\n+    }\n+}\n+\n /* Return 1 if the operand is either a register or a memory operand that is\n    not symbolic.  */\n \n@@ -321,6 +532,23 @@ noov_compare_op (op, mode)\n   return 1;\n }\n \n+/* Nonzero if OP is a comparison operator suitable for use in v9\n+   conditional move or branch on register contents instructions.  */\n+\n+int\n+v9_regcmp_op (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  return (code == EQ || code == NE || code == GE || code == LT\n+\t  || code == LE || code == GT);\n+}\n+\n /* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */\n \n int\n@@ -375,9 +603,40 @@ arith_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n }\n \n+/* Return true if OP is a register, or is a CONST_INT that can fit in an 11\n+   bit immediate field.  This is an acceptable SImode operand for the movcc\n+   instructions.  */\n+\n+int\n+arith11_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && ((unsigned) (INTVAL (op) + 0x400) < 0x800)));\n+}\n+\n+/* Return true if OP is a register, or is a CONST_INT that can fit in an 10\n+   bit immediate field.  This is an acceptable SImode operand for the movrcc\n+   instructions.  */\n+\n+int\n+arith10_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && ((unsigned) (INTVAL (op) + 0x200) < 0x400)));\n+}\n+\n /* Return true if OP is a register, is a CONST_INT that fits in a 13 bit\n    immediate field, or is a CONST_DOUBLE whose both parts fit in a 13 bit\n-   immediate field.  */\n+   immediate field.\n+   v9: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n+   can fit in a 13 bit immediate field.  This is an acceptable DImode operand\n+   for most 3 address instructions.  */\n \n int\n arith_double_operand (op, mode)\n@@ -386,9 +645,63 @@ arith_double_operand (op, mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t  || (! TARGET_V9\n+\t      && GET_CODE (op) == CONST_DOUBLE\n+\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n+\t      && (unsigned) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000)\n+\t  || (TARGET_V9\n+\t      && GET_CODE (op) == CONST_DOUBLE\n \t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n-\t      && (unsigned) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000));\n+\t      && ((CONST_DOUBLE_HIGH (op) == -1\n+\t\t   && (CONST_DOUBLE_LOW (op) & 0x1000) == 0x1000)\n+\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n+\t\t      && (CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n+}\n+\n+/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n+   can fit in an 11 bit immediate field.  This is an acceptable DImode\n+   operand for the movcc instructions.  */\n+/* ??? Replace with arith11_operand?  */\n+\n+int\n+arith11_double_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n+\t      && ((CONST_DOUBLE_HIGH (op) == -1\n+\t\t   && (CONST_DOUBLE_LOW (op) & 0x400) == 0x400)\n+\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n+\t\t      && (CONST_DOUBLE_LOW (op) & 0x400) == 0)))\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (INTVAL (op) + 0x400) < 0x800));\n+}\n+\n+/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n+   can fit in an 10 bit immediate field.  This is an acceptable DImode\n+   operand for the movrcc instructions.  */\n+/* ??? Replace with arith10_operand?  */\n+\n+int\n+arith10_double_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x200) < 0x400\n+\t      && ((CONST_DOUBLE_HIGH (op) == -1\n+\t\t   && (CONST_DOUBLE_LOW (op) & 0x200) == 0x200)\n+\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n+\t\t      && (CONST_DOUBLE_LOW (op) & 0x200) == 0)))\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n+\t      && (unsigned) (INTVAL (op) + 0x200) < 0x400));\n }\n \n /* Return truth value of whether OP is a integer which fits the\n@@ -443,21 +756,191 @@ clobbered_register (op, mode)\n }\n \f\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for register 0 in the proper mode.  */\n+   return the rtx for the cc reg in the proper mode.  */\n \n rtx\n gen_compare_reg (code, x, y)\n      enum rtx_code code;\n      rtx x, y;\n {\n   enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg = gen_rtx (REG, mode, 0);\n+  rtx cc_reg;\n+\n+  /* ??? We don't have movcc patterns so we cannot generate pseudo regs for the\n+     fpcc regs (cse can't tell they're really call clobbered regs and will\n+     remove a duplicate comparison even if there is an intervening function\n+     call - it will then try to reload the cc reg via an int reg which is why\n+     we need the movcc patterns).  It is possible to provide the movcc\n+     patterns by using the ldxfsr/stxfsr v9 insns.  I tried it: you need two\n+     registers (say %g1,%g5) and it takes about 6 insns.  A better fix would be\n+     to tell cse that CCFPE mode registers (even pseudoes) are call\n+     clobbered.  */\n+\n+  /* ??? This is an experiment.  Rather than making changes to cse which may\n+     or may not be easy/clean, we do our own cse.  This is possible because\n+     we will generate hard registers.  Cse knows they're call clobbered (it\n+     doesn't know the same thing about pseudos). If we guess wrong, no big\n+     deal, but if we win, great!  */\n+\n+  if (TARGET_V9 && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+#if 1 /* experiment */\n+    {\n+      int reg;\n+      /* We cycle through the registers to ensure they're all exercised.  */\n+      static int next_fpcc_reg = 0;\n+      /* Previous x,y for each fpcc reg.  */\n+      static rtx prev_args[4][2];\n+\n+      /* Scan prev_args for x,y.  */\n+      for (reg = 0; reg < 4; reg++)\n+\tif (prev_args[reg][0] == x && prev_args[reg][1] == y)\n+\t  break;\n+      if (reg == 4)\n+\t{\n+\t  reg = next_fpcc_reg;\n+\t  prev_args[reg][0] = x;\n+\t  prev_args[reg][1] = y;\n+\t  next_fpcc_reg = (next_fpcc_reg + 1) & 3;\n+\t}\n+      cc_reg = gen_rtx (REG, mode, reg + 96);\n+    }\n+#else\n+    cc_reg = gen_reg_rtx (mode);\n+#endif /* ! experiment */\n+  else\n+    cc_reg = gen_rtx (REG, mode, 0);\n \n   emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n \t\t      gen_rtx (COMPARE, mode, x, y)));\n \n   return cc_reg;\n }\n+\n+/* This function is used for v9 only.\n+   CODE is the code for an Scc's comparison.\n+   OPERANDS[0] is the target of the Scc insn.\n+   OPERANDS[1] is the value we compare against const0_rtx (which hasn't\n+   been generated yet).\n+\n+   This function is needed to turn\n+\n+\t   (set (reg:SI 110)\n+\t       (gt (reg:CCX 0 %g0)\n+\t           (const_int 0)))\n+   into\n+\t   (set (reg:SI 110)\n+\t       (gt:DI (reg:CCX 0 %g0)\n+\t           (const_int 0)))\n+\n+   IE: The instruction recognizer needs to see the mode of the comparison to\n+   find the right instruction. We could use \"gt:DI\" right in the\n+   define_expand, but leaving it out allows us to handle DI, SI, etc.\n+\n+   We refer to the global sparc compare operands sparc_compare_op0 and\n+   sparc_compare_op1.  \n+\n+   ??? Some of this is outdated as the scc insns set the mode of the\n+   comparison now.\n+\n+   ??? We optimize for the case where op1 is 0 and the comparison allows us to\n+   use the \"movrCC\" insns. This reduces the generated code from three to two\n+   insns.  This way seems too brute force though.  Is there a more elegant way\n+   to achieve the same effect?\n+\n+   Currently, this function always returns 1.  ??? Can it ever fail?  */\n+\n+int\n+gen_v9_scc (compare_code, operands)\n+     enum rtx_code compare_code;\n+     register rtx *operands;\n+{\n+  rtx temp;\n+\n+  if (GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_INT\n+      && sparc_compare_op1 == const0_rtx\n+      && (compare_code == EQ || compare_code == NE\n+\t  || compare_code == LT || compare_code == LE\n+\t  || compare_code == GT || compare_code == GE))\n+    {\n+      /* Special case for op0 != 0.  This can be done with one instruction if\n+\t op0 can be clobbered.  We store to a temp, and then clobber the temp,\n+\t but the combiner will remove the first insn.  */\n+\n+      if (compare_code == NE\n+\t  && GET_MODE (operands[0]) == DImode\n+\t  && GET_MODE (sparc_compare_op0) == DImode)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0], sparc_compare_op0));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t      gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t       gen_rtx (compare_code, DImode,\n+\t\t\t\t\t\tsparc_compare_op0, const0_rtx),\n+\t\t\t\t       const1_rtx,\n+\t\t\t\t       operands[0])));\n+\t  return 1;\n+\t}\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0], const0_rtx));\n+      if (GET_MODE (sparc_compare_op0) != DImode)\n+\t{\n+\t  temp = gen_reg_rtx (DImode);\n+\t  convert_move (temp, sparc_compare_op0, 0);\n+\t}\n+      else\n+\t{\n+\t  temp = sparc_compare_op0;\n+\t}\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t  gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t   gen_rtx (compare_code, DImode,\n+\t\t\t\t\t    temp, const0_rtx),\n+\t\t\t\t   const1_rtx,\n+\t\t\t\t   operands[0])));\n+      return 1;\n+    }\n+  else\n+    {\n+      operands[1] = gen_compare_reg (compare_code,\n+\t\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+\n+      switch (GET_MODE (operands[1]))\n+\t{\n+\t  case CCmode :\n+\t  case CCXmode :\n+\t  case CCFPEmode :\n+\t  case CCFPmode :\n+\t    break;\n+\t  default :\n+\t    abort ();\n+\t}\n+\temit_insn (gen_rtx (SET, VOIDmode, operands[0], const0_rtx));\n+\temit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t    gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t     gen_rtx (compare_code,\n+\t\t\t\t\t      GET_MODE (operands[1]),\n+\t\t\t\t\t      operands[1], const0_rtx),\n+\t\t\t\t\t      const1_rtx, operands[0])));\n+\treturn 1;\n+    }\n+}\n+\n+/* Emit a conditional jump insn for the v9 architecture using comparison code\n+   CODE and jump target LABEL.\n+   This function exists to take advantage of the v9 brxx insns.  */\n+\n+void\n+emit_v9_brxx_insn (code, op0, label)\n+     enum rtx_code code;\n+     rtx op0, label;\n+{\n+  emit_jump_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t   pc_rtx,\n+\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t    gen_rtx (code, GET_MODE (op0),\n+\t\t\t\t\t     op0, const0_rtx),\n+\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, label),\n+\t\t\t\t    pc_rtx)));\n+}\n \f\n /* Return nonzero if a return peephole merging return with\n    setting of output register is ok.  */\n@@ -779,8 +1262,16 @@ finalize_pic ()\n \t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n \t\t\t\t\t\t   pc_rtx))));\n \n-  emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t      gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+  if (Pmode == DImode)\n+    emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\tgen_rtvec (2,\n+\t\t\t\t   gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\t\t\t    gen_rtx (HIGH, Pmode, pic_pc_rtx)),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 1)))));\n+  else\n+    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+\n   emit_insn (gen_rtx (SET, VOIDmode,\n \t\t      pic_offset_table_rtx,\n \t\t      gen_rtx (LO_SUM, Pmode,\n@@ -886,8 +1377,34 @@ emit_move_sequence (operands, mode)\n \t  rtx temp = ((reload_in_progress || mode == DImode)\n \t\t      ? operand0 : gen_reg_rtx (mode));\n \n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t      gen_rtx (HIGH, mode, operand1)));\n+\t  if (TARGET_V9 && mode == DImode)\n+\t    {\n+\t      int high_operand = 0;\n+\n+\t      /* If the operand is already a HIGH, then remove the HIGH so\n+\t\t that we won't get duplicate HIGH operators in this insn.\n+\t\t Also, we must store the result into the original dest,\n+\t\t because that is where the following LO_SUM expects it.  */\n+\t      if (GET_CODE (operand1) == HIGH)\n+\t\t{\n+\t\t  operand1 = XEXP (operand1, 0);\n+\t\t  high_operand = 1;\n+\t\t}\n+\n+\t      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t  gen_rtvec (2,\n+\t\t\t\t\t     gen_rtx (SET, VOIDmode, temp,\n+\t\t\t\t\t\t      gen_rtx (HIGH, mode, operand1)),\n+\t\t\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, DImode, 1)))));\n+\n+\t      /* If this was a high operand, then we are now finished.  */\n+\t      if (high_operand)\n+\t\treturn 1;\n+\t    }\n+\t  else\n+\t    emit_insn (gen_rtx (SET, VOIDmode, temp,\n+\t\t\t\tgen_rtx (HIGH, mode, operand1)));\n+\n \t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n \t}\n     }\n@@ -1009,7 +1526,7 @@ mem_aligned_8 (mem)\n       && (REGNO (base) == FRAME_POINTER_REGNUM\n \t  || REGNO (base) == STACK_POINTER_REGNUM))\n     {\n-      if ((INTVAL (offset) & 0x7) == 0)\n+      if (((INTVAL (offset) - SPARC_STACK_BIAS) & 0x7) == 0)\n \treturn 1;\n     }\n   /* Anything else we know is properly aligned unless TARGET_UNALIGNED_DOUBLES\n@@ -1103,26 +1620,72 @@ output_move_double (operands)\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (op1, 4);\n   else if (optype1 == CNSTOP)\n-    split_double (op1, &operands[1], &latehalf[1]);\n+    {\n+      if (TARGET_V9)\n+\t{\n+\t  if (arith_double_operand (op1, DImode))\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     CONST_DOUBLE_LOW (op1));\n+\t      return \"mov %1,%0\";\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The only way to handle CONST_DOUBLEs or other 64 bit\n+\t\t constants here is to use a temporary, such as is done\n+\t\t for the V9 DImode sethi insn pattern.  This is not\n+\t\t a practical solution, so abort if we reach here.\n+\t\t The md file should always force such constants to\n+\t\t memory.  */\n+\t      abort ();\n+\t    }\n+\t}\n+      else\n+\tsplit_double (op1, &operands[1], &latehalf[1]);\n+    }\n   else\n     latehalf[1] = op1;\n \n   /* Easy case: try moving both words at once.  Check for moving between\n      an even/odd register pair and a memory location.  */\n   if ((optype0 == REGOP && optype1 != REGOP && optype1 != CNSTOP\n-       && (REGNO (op0) & 1) == 0)\n+       && (TARGET_V9 || (REGNO (op0) & 1) == 0))\n       || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n-\t  && (REGNO (op1) & 1) == 0))\n+\t  && (TARGET_V9 || (REGNO (op1) & 1) == 0)))\n     {\n-      register rtx mem;\n+      register rtx mem,reg;\n \n       if (optype0 == REGOP)\n-\tmem = op1;\n+\tmem = op1, reg = op0;\n       else\n-\tmem = op0;\n+\tmem = op0, reg = op1;\n+\n+      /* In v9, ldd can be used for word aligned addresses, so technically\n+\t some of this logic is unneeded.  We still avoid ldd if the address\n+\t is obviously unaligned though.  */\n \n-      if (mem_aligned_8 (mem))\n-\treturn (mem == op1 ? \"ldd %1,%0\" : \"std %1,%0\");\n+      if (mem_aligned_8 (mem)\n+\t  /* If this is a floating point register higher than %f31,\n+\t     then we *must* use an aligned load, since `ld' will not accept\n+\t     the register number.  */\n+\t  || (TARGET_V9 && REGNO (reg) >= 64))\n+\t{\n+\t  if (FP_REG_P (reg) || ! TARGET_V9)\n+\t    return (mem == op1 ? \"ldd %1,%0\" : \"std %1,%0\");\n+\t  else\n+\t    return (mem == op1 ? \"ldx %1,%0\" : \"stx %1,%0\");\n+\t}\n+    }\n+\n+  if (TARGET_V9)\n+    {\n+      if (optype0 == REGOP && optype1 == REGOP)\n+\t{\n+\t  if (FP_REG_P (op0))\n+\t    return \"fmovd %1,%0\";\n+\t  else\n+\t    return \"mov %1,%0\";\n+\t}\n     }\n \n   /* If the first move would clobber the source of the second one,\n@@ -1317,27 +1880,38 @@ output_move_quad (operands)\n     }\n \n   /* Easy case: try moving the quad as two pairs.  Check for moving between\n-     an even/odd register pair and a memory location.  */\n+     an even/odd register pair and a memory location.\n+     Also handle new v9 fp regs here.  */\n   /* ??? Should also handle the case of non-offsettable addresses here.\n      We can at least do the first pair as a ldd/std, and then do the third\n      and fourth words individually.  */\n   if ((optype0 == REGOP && optype1 == OFFSOP && (REGNO (op0) & 1) == 0)\n       || (optype0 == OFFSOP && optype1 == REGOP && (REGNO (op1) & 1) == 0))\n     {\n-      rtx mem;\n+      rtx mem, reg;\n \n       if (optype0 == REGOP)\n-\tmem = op1;\n+\tmem = op1, reg = op0;\n       else\n-\tmem = op0;\n+\tmem = op0, reg = op1;\n \n-      if (mem_aligned_8 (mem))\n+      if (mem_aligned_8 (mem)\n+\t  /* If this is a floating point register higher than %f31,\n+\t     then we *must* use an aligned load, since `ld' will not accept\n+\t     the register number.  */\n+\t  || (TARGET_V9 && REGNO (reg) >= 64))\n \t{\n+\t  if (TARGET_V9 && FP_REG_P (reg))\n+\t    {\n+\t      if ((REGNO (reg) & 3) != 0)\n+\t\tabort ();\n+\t      return (mem == op1 ? \"ldq %1,%0\" : \"stq %1,%0\");\n+\t    }\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n \t  if (mem == op1)\n-\t    return \"ldd %1,%0;ldd %2,%S0\";\n+\t    return TARGET_V9 ? \"ldx %1,%0;ldx %2,%R0\" : \"ldd %1,%0;ldd %2,%S0\";\n \t  else\n-\t    return \"std %1,%0;std %S1,%2\";\n+\t    return TARGET_V9 ? \"stx %1,%0;stx %R1,%2\" : \"std %1,%0;std %S1,%2\";\n \t}\n     }\n \n@@ -1421,7 +1995,12 @@ output_fp_move_double (operands)\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n-\treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\";\n+\t{\n+\t  if (TARGET_V9)\n+\t    return \"fmovd %1,%0\";\n+\t  else\n+\t    return \"fmovs %1,%0\\n\\tfmovs %R1,%R0\";\n+\t}\n       else if (GET_CODE (operands[1]) == REG)\n \tabort ();\n       else\n@@ -1450,7 +2029,12 @@ output_fp_move_quad (operands)\n   if (FP_REG_P (op0))\n     {\n       if (FP_REG_P (op1))\n-\treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n+\t{\n+\t  if (TARGET_V9)\n+\t    return \"fmovq %1,%0\";\n+\t  else\n+\t    return \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n+\t}\n       else if (GET_CODE (op1) == REG)\n \tabort ();\n       else\n@@ -1705,9 +2289,23 @@ output_block_move (operands)\n \n       /* This case is currently not handled.  Abort instead of generating\n \t bad code.  */\n-      if (align > 4)\n+      if (align > UNITS_PER_WORD)\n \tabort ();\n \n+      if (TARGET_V9 && align >= 8)\n+\t{\n+\t  for (i = (size >> 3) - 1; i >= 0; i--)\n+\t    {\n+\t      INTVAL (xoperands[2]) = (i << 3) + offset;\n+\t      output_asm_insn (\"ldx [%a1+%2],%%g1\\n\\tstx %%g1,[%a0+%2]\",\n+\t\t\t       xoperands);\n+\t    }\n+\t  offset += (size & ~0x7);\n+\t  size = size & 0x7;\n+\t  if (size == 0)\n+\t    return \"\";\n+\t}\n+\n       if (align >= 4)\n \t{\n \t  for (i = (size >> 2) - 1; i >= 0; i--)\n@@ -1814,8 +2412,10 @@ output_block_move (operands)\n \n   {\n     char pattern[200];\n-    register char *ld_suffix = (align == 1) ? \"ub\" : (align == 2) ? \"uh\" : \"\";\n-    register char *st_suffix = (align == 1) ? \"b\" : (align == 2) ? \"h\" : \"\";\n+    register char *ld_suffix = ((align == 1) ? \"ub\" : (align == 2) ? \"uh\"\n+\t\t\t\t: (align == 8 && TARGET_V9) ? \"x\" : \"\");\n+    register char *st_suffix = ((align == 1) ? \"b\" : (align == 2) ? \"h\"\n+\t\t\t\t: (align == 8 && TARGET_V9) ? \"x\" : \"\");\n \n     sprintf (pattern, \"ld%s [%%1+%%2],%%%%g1\\n\\tsubcc %%2,%%4,%%2\\n\\tbge %s\\n\\tst%s %%%%g1,[%%0+%%2]\\n%s:\", ld_suffix, &label3[1], st_suffix, &label5[1]);\n     output_asm_insn (pattern, xoperands);\n@@ -1899,12 +2499,12 @@ output_scc_insn (operands, insn)\n   if (final_sequence)\n     {\n       strcpy (string, \"mov 0,%0\\n\\t\");\n-      strcat (string, output_cbranch (operands[1], 2, 0, 1, 0));\n+      strcat (string, output_cbranch (operands[1], 0, 2, 0, 1, 0));\n       strcat (string, \"\\n\\tmov 1,%0\");\n     }\n   else\n     {\n-      strcpy (string, output_cbranch (operands[1], 2, 0, 1, 0));\n+      strcpy (string, output_cbranch (operands[1], 0, 2, 0, 1, 0));\n       strcat (string, \"\\n\\tmov 1,%0\\n\\tmov 0,%0\");\n     }\n \n@@ -1914,48 +2514,71 @@ output_scc_insn (operands, insn)\n   return string;\n }\n \f\n-/* Vectors to keep interesting information about registers where\n-   it can easily be got.  */\n+/* Vectors to keep interesting information about registers where it can easily\n+   be got.  We use to use the actual mode value as the bit number, but there\n+   are more than 32 modes now.  Instead we use two tables: one indexed by\n+   hard register number, and one indexed by mode.  */\n+\n+/* The purpose of sparc_mode_class is to shrink the range of modes so that\n+   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   mapped into one sparc_mode_class mode.  */\n+\n+enum sparc_mode_class {\n+  C_MODE, CCFP_MODE,\n+  S_MODE, D_MODE, T_MODE, O_MODE,\n+  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n+};\n \n /* Modes for condition codes.  */\n-#define C_MODES\t\t\t\t\t\t\\\n-  ((1 << (int) CCmode) | (1 << (int) CC_NOOVmode)\t\\\n-   | (1 << (int) CCFPmode) | (1 << (int) CCFPEmode))\n-\n-/* Modes for single-word (and smaller) quantities.  */\n-#define S_MODES\t\t\t\t\t\t\t\t\\\n- ((1 << (int) QImode) | (1 << (int) HImode) | (1 << (int) SImode)\t\\\n-  | (1 << (int) QFmode) | (1 << (int) HFmode) | (1 << (int) SFmode)\t\\\n-  | (1 << (int) CQImode) | (1 << (int) CHImode))\n-\n-/* Modes for double-word (and smaller) quantities.  */\n-#define D_MODES\t\t\t\t\t\t\\\n- (S_MODES | (1 << (int) DImode) | (1 << (int) DFmode)\t\\\n-  | (1 << (int) CSImode) | (1 << (int) SCmode))\n-\n-/* Modes for quad-word quantities.  */\n-#define T_MODES\t\t\t\t\t\t\\\n- (D_MODES | (1 << (int) TImode) | (1 << (int) TFmode)\t\\\n-  | (1 << (int) DCmode) | (1 << (int) CDImode))\n+#define C_MODES ((1 << (int) C_MODE) | (1 << (int) CCFP_MODE))\n+#define CCFP_MODES (1 << (int) CCFP_MODE)\n+\n+/* Modes for single-word and smaller quantities.  */\n+#define S_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n+\n+/* Modes for double-word and smaller quantities.  */\n+#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n+\n+/* Modes for quad-word and smaller quantities.  */\n+#define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n \n /* Modes for single-float quantities.  We must allow any single word or\n    smaller quantity.  This is because the fix/float conversion instructions\n    take integer inputs/outputs from the float registers.  */\n #define SF_MODES (S_MODES)\n \n-/* Modes for double-float quantities.  */\n-#define DF_MODES (SF_MODES | (1 << (int) DFmode) | (1 << (int) SCmode))\n+/* Modes for double-float and smaller quantities.  */\n+#define DF_MODES (S_MODES | D_MODES)\n+\n+/* ??? Sparc64 fp regs cannot hold DImode values.  */\n+#define DF_MODES64 (SF_MODES | DF_MODE /* | D_MODE*/)\n \n-/* Modes for quad-float quantities.  */\n-#define TF_MODES (DF_MODES | (1 << (int) TFmode) | (1 << (int) DCmode))\n+/* Modes for double-float only quantities.  */\n+/* ??? Sparc64 fp regs cannot hold DImode values.  */\n+#define DF_ONLY_MODES ((1 << (int) DF_MODE) /*| (1 << (int) D_MODE)*/)\n+\n+/* Modes for double-float and larger quantities.  */\n+#define DF_UP_MODES (DF_ONLY_MODES | TF_ONLY_MODES)\n+\n+/* Modes for quad-float only quantities.  */\n+#define TF_ONLY_MODES (1 << (int) TF_MODE)\n+\n+/* Modes for quad-float and smaller quantities.  */\n+#define TF_MODES (DF_MODES | TF_ONLY_MODES)\n+\n+/* ??? Sparc64 fp regs cannot hold DImode values.  */\n+#define TF_MODES64 (DF_MODES64 | TF_ONLY_MODES)\n \n /* Value is 1 if register/mode pair is acceptable on sparc.\n    The funny mixture of D and T modes is because integer operations\n    do not specially operate on tetra quantities, so non-quad-aligned\n    registers can hold quadword quantities (except %o4 and %i4 because\n    they cross fixed registers.  */\n \n-int hard_regno_mode_ok[] = {\n+/* This points to either the 32 bit or the 64 bit version.  */\n+int *hard_regno_mode_classes;\n+\n+static int hard_32bit_mode_classes[] = {\n   C_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n@@ -1964,116 +2587,298 @@ int hard_regno_mode_ok[] = {\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n-  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES};\n+  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+};\n+\n+static int hard_64bit_mode_classes[] = {\n+  C_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+\n+  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n+  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n+  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n+  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n+\n+  /* The remaining registers do not exist on a non-v9 sparc machine.\n+     FP regs f32 to f63.  Only the even numbered registers actually exist,\n+     and none can hold SFmode/SImode values.  */\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+\n+  /* %fcc[0123] */\n+  CCFP_MODE, CCFP_MODE, CCFP_MODE, CCFP_MODE\n+};\n+\n+int sparc_mode_class [NUM_MACHINE_MODES];\n+\n+static void\n+sparc_init_modes ()\n+{\n+  int i;\n+\n+  sparc_cpu_type = TARGET_V9 ? CPU_64BIT : CPU_32BIT;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      switch (GET_MODE_CLASS (i))\n+\t{\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\tcase MODE_COMPLEX_INT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    sparc_mode_class[i] = 1 << (int) S_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    sparc_mode_class[i] = 1 << (int) D_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    sparc_mode_class[i] = 1 << (int) T_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    sparc_mode_class[i] = 1 << (int) O_MODE;\n+\t  else \n+\t    sparc_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_FLOAT:\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    sparc_mode_class[i] = 1 << (int) SF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    sparc_mode_class[i] = 1 << (int) DF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    sparc_mode_class[i] = 1 << (int) TF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    sparc_mode_class[i] = 1 << (int) OF_MODE;\n+\t  else \n+\t    sparc_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_CC:\n+\tdefault:\n+\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n+\t     we must explicitly check for them here.  */\n+\t  if (i == (int) CCFPmode || i == (int) CCFPEmode)\n+\t    sparc_mode_class[i] = 1 << (int) CCFP_MODE;\n+\t  else if (i == (int) CCmode || i == (int) CC_NOOVmode\n+#ifdef SPARCV9\n+\t\t   || i == (int) CCXmode\n+\t\t   || i == (int) CCX_NOOVmode\n+#endif\n+\t\t   )\n+\t    sparc_mode_class[i] = 1 << (int) C_MODE;\n+\t  else\n+\t    sparc_mode_class[i] = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  if (TARGET_V9)\n+    hard_regno_mode_classes = hard_64bit_mode_classes;\n+  else\n+    hard_regno_mode_classes = hard_32bit_mode_classes;\n+}\n \f\n+/* Save non call used registers from LOW to HIGH at BASE+OFFSET.\n+   N_REGS is the number of 4-byte regs saved thus far.  This applies even to\n+   v9 int regs as it simplifies the code.  */\n+\n #ifdef __GNUC__\n __inline__\n #endif\n static int\n-save_regs (file, low, high, base, offset, n_fregs)\n+save_regs (file, low, high, base, offset, n_regs)\n      FILE *file;\n      int low, high;\n      char *base;\n      int offset;\n-     int n_fregs;\n+     int n_regs;\n {\n   int i;\n \n-  for (i = low; i < high; i += 2)\n+  if (TARGET_V9 && high <= 32)\n     {\n-      if (regs_ever_live[i] && ! call_used_regs[i])\n-\tif (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t  fprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n-\t\t   reg_names[i], base, offset + 4 * n_fregs),\n-\t  n_fregs += 2;\n-\telse\n-\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n-\t\t   reg_names[i], base, offset + 4 * n_fregs),\n-\t  n_fregs += 2;\n-      else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\tfprintf (file, \"\\tst %s,[%s+%d]\\n\",\n-\t\t reg_names[i+1], base, offset + 4 * n_fregs),\n-\tn_fregs += 2;\n+      for (i = low; i < high; i++)\n+\t{\n+\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    fprintf (file, \"\\tstx %s,[%s+%d]\\n\",\n+\t      reg_names[i], base, offset + 4 * n_regs),\n+\t    n_regs += 2;\n+\t}\n     }\n-  return n_fregs;\n+  else\n+    {\n+      for (i = low; i < high; i += 2)\n+\t{\n+\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t      fprintf (file, \"\\tstd %s,[%s+%d]\\n\",\n+\t\t       reg_names[i], base, offset + 4 * n_regs),\n+\t      n_regs += 2;\n+\t    else\n+\t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t       reg_names[i], base, offset + 4 * n_regs),\n+\t      n_regs += 2;\n+\t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t    fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t     reg_names[i+1], base, offset + 4 * n_regs + 4),\n+\t    n_regs += 2;\n+\t}\n+    }\n+  return n_regs;\n }\n \n+/* Restore non call used registers from LOW to HIGH at BASE+OFFSET.\n+\n+   N_REGS is the number of 4-byte regs saved thus far.  This applies even to\n+   v9 int regs as it simplifies the code.  */\n+\n #ifdef __GNUC__\n __inline__\n #endif\n static int\n-restore_regs (file, low, high, base, offset, n_fregs)\n+restore_regs (file, low, high, base, offset, n_regs)\n      FILE *file;\n      int low, high;\n      char *base;\n      int offset;\n+     int n_regs;\n {\n   int i;\n \n-  for (i = low; i < high; i += 2)\n+  if (TARGET_V9 && high <= 32)\n+    {\n+      for (i = low; i < high; i++)\n+\t{\n+\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    fprintf (file, \"\\tldx [%s+%d], %s\\n\",\n+\t      base, offset + 4 * n_regs, reg_names[i]),\n+\t    n_regs += 2;\n+\t}\n+    }\n+  else\n     {\n-      if (regs_ever_live[i] && ! call_used_regs[i])\n-\tif (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t  fprintf (file, \"\\tldd [%s+%d], %s\\n\",\n-\t\t   base, offset + 4 * n_fregs, reg_names[i]),\n-\t  n_fregs += 2;\n-\telse\n-\t  fprintf (file, \"\\tld [%s+%d],%s\\n\",\n-\t\t   base, offset + 4 * n_fregs, reg_names[i]),\n-\t  n_fregs += 2;\n-      else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\tfprintf (file, \"\\tld [%s+%d],%s\\n\",\n-\t\t base, offset + 4 * n_fregs, reg_names[i+1]),\n-\tn_fregs += 2;\n+      for (i = low; i < high; i += 2)\n+\t{\n+\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t      fprintf (file, \"\\tldd [%s+%d], %s\\n\",\n+\t\t       base, offset + 4 * n_regs, reg_names[i]),\n+\t      n_regs += 2;\n+\t    else\n+\t      fprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t       base, offset + 4 * n_regs, reg_names[i]),\n+\t      n_regs += 2;\n+\t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n+\t    fprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t     base, offset + 4 * n_regs + 4, reg_names[i+1]),\n+\t    n_regs += 2;\n+\t}\n     }\n-  return n_fregs;\n+  return n_regs;\n }\n \n /* Static variables we want to share between prologue and epilogue.  */\n \n-/* Number of live floating point registers needed to be saved.  */\n-static int num_fregs;\n+/* Number of live general or floating point registers needed to be saved\n+   (as 4-byte quantities).  This is only done if TARGET_EPILOGUE.  */\n+static int num_gfregs;\n+\n+/* Compute the frame size required by the function.  This function is called\n+   during the reload pass and also by output_function_prologue().  */\n \n int\n compute_frame_size (size, leaf_function)\n      int size;\n      int leaf_function;\n {\n-  int fregs_ever_live = 0;\n-  int n_fregs = 0, i;\n+  int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n-\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n-\n-  apparent_fsize = ((size) + 7 - STARTING_FRAME_OFFSET) & -8;\n-  for (i = 32; i < FIRST_PSEUDO_REGISTER; i += 2)\n-    fregs_ever_live |= regs_ever_live[i]|regs_ever_live[i+1];\n+#ifndef SPARCV9\n+\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl)\n+#endif\n+\t\t\t    );\n \n-  if (TARGET_EPILOGUE && fregs_ever_live)\n+  if (TARGET_EPILOGUE)\n     {\n-      for (i = 32; i < FIRST_PSEUDO_REGISTER; i += 2)\n+      /* N_REGS is the number of 4-byte regs saved thus far.  This applies\n+\t even to v9 int regs to be consistent with save_regs/restore_regs.  */\n+\n+      if (TARGET_V9)\n+\t{\n+\t  for (i = 0; i < 8; i++)\n+\t    if (regs_ever_live[i] && ! call_used_regs[i])\n+\t      n_regs += 2;\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < 8; i += 2)\n+\t    if ((regs_ever_live[i] && ! call_used_regs[i])\n+\t\t|| (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n+\t      n_regs += 2;\n+\t}\n+\n+      for (i = 32; i < (TARGET_V9 ? 96 : 64); i += 2)\n \tif ((regs_ever_live[i] && ! call_used_regs[i])\n \t    || (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n-\t  n_fregs += 2;\n+\t  n_regs += 2;\n     }\n \n   /* Set up values for use in `function_epilogue'.  */\n-  num_fregs = n_fregs;\n+  num_gfregs = n_regs;\n \n-  apparent_fsize += (outgoing_args_size+7) & -8;\n-  if (leaf_function && n_fregs == 0\n-      && apparent_fsize == (REG_PARM_STACK_SPACE (current_function_decl)\n-\t\t\t    - STARTING_FRAME_OFFSET))\n-    apparent_fsize = 0;\n-\n-  actual_fsize = apparent_fsize + n_fregs*4;\n+  if (leaf_function && n_regs == 0\n+      && size == 0 && current_function_outgoing_args_size == 0)\n+    {\n+      actual_fsize = apparent_fsize = 0;\n+    }\n+  else\n+    {\n+      /* We subtract STARTING_FRAME_OFFSET, remember it's negative.\n+         The stack bias (if any) is taken out to undo its effects.  */\n+      apparent_fsize = (size - STARTING_FRAME_OFFSET + SPARC_STACK_BIAS + 7) & -8;\n+      apparent_fsize += n_regs * 4;\n+      actual_fsize = apparent_fsize + ((outgoing_args_size + 7) & -8);\n+    }\n \n   /* Make sure nothing can clobber our register windows.\n      If a SAVE must be done, or there is a stack-local variable,\n-     the register window area must be allocated.  */\n+     the register window area must be allocated.\n+     ??? For v9 we need an additional 8 bytes of reserved space, apparently\n+     it's needed by v8 as well.  */\n   if (leaf_function == 0 || size > 0)\n-    actual_fsize += (16 * UNITS_PER_WORD)+8;\n+    actual_fsize += (16 * UNITS_PER_WORD) + 8;\n \n-  return actual_fsize;\n+  return SPARC_STACK_ALIGN (actual_fsize);\n+}\n+\n+/* Build a (32 bit) big number in a register.  */\n+\n+static void\n+build_big_number (file, num, reg)\n+     FILE *file;\n+     int num;\n+     char *reg;\n+{\n+  if (num >= 0 || ! TARGET_V9)\n+    {\n+      fprintf (file, \"\\tsethi %%hi(%d),%s\\n\", num, reg);\n+      if ((num & 0x3ff) != 0)\n+\tfprintf (file, \"\\tor %s,%%lo(%d),%s\\n\", reg, num, reg);\n+    }\n+  else /* num < 0 && TARGET_V9 */\n+    {\n+      /* Sethi does not sign extend, so we must use a little trickery\n+\t to use it for negative numbers.  Invert the constant before\n+\t loading it in, then use xor immediate to invert the loaded bits\n+\t (along with the upper 32 bits) to the desired constant.  This\n+\t works because the sethi and immediate fields overlap.  */\n+      int asize = num;\n+      int inv = ~asize;\n+      int low = -0x400 + (asize & 0x3FF);\n+\t  \n+      fprintf (file, \"\\tsethi %%hi(%d),%s\\n\\txor %s,%d,%s\\n\",\n+\t       inv, reg, reg, low, reg);\n+    }\n }\n \n /* Output code for the function prologue.  */\n@@ -2084,17 +2889,21 @@ output_function_prologue (file, size, leaf_function)\n      int size;\n      int leaf_function;\n {\n-  /* ??? This should be %sp+actual_fsize for a leaf function.  I think it\n-     works only because it is never used.  */\n-  if (leaf_function)\n-    frame_base_name = \"%sp+80\";\n-  else\n-    frame_base_name = \"%fp\";\n-\n   /* Need to use actual_fsize, since we are also allocating\n      space for our callee (and our own register save area).  */\n   actual_fsize = compute_frame_size (size, leaf_function);\n \n+  if (leaf_function)\n+    {\n+      frame_base_name = \"%sp\";\n+      frame_base_offset = actual_fsize + SPARC_STACK_BIAS;\n+    }\n+  else\n+    {\n+      frame_base_name = \"%fp\";\n+      frame_base_offset = SPARC_STACK_BIAS;\n+    }\n+\n   /* This is only for the human reader.  */\n   fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n \n@@ -2123,44 +2932,50 @@ output_function_prologue (file, size, leaf_function)\n     }\n   else\n     {\n+      build_big_number (file, -actual_fsize, \"%g1\");\n       if (! leaf_function)\n-\t{\n-\t  fprintf (file, \"\\tsethi %%hi(-%d),%%g1\\n\", actual_fsize);\n-\t  if ((actual_fsize & 0x3ff) != 0)\n-\t    fprintf (file, \"\\tor %%g1,%%lo(-%d),%%g1\\n\", actual_fsize);\n-\t  fprintf (file, \"\\tsave %%sp,%%g1,%%sp\\n\");\n-\t}\n+\tfprintf (file, \"\\tsave %%sp,%%g1,%%sp\\n\");\n       else\n-\t{\n-\t  fprintf (file, \"\\tsethi %%hi(-%d),%%g1\\n\", actual_fsize);\n-\t  if ((actual_fsize & 0x3ff) != 0)\n-\t    fprintf (file, \"\\tor %%g1,%%lo(-%d),%%g1\\n\", actual_fsize);\n-\t  fprintf (file, \"\\tadd %%sp,%%g1,%%sp\\n\");\n-\t}\n+\tfprintf (file, \"\\tadd %%sp,%%g1,%%sp\\n\");\n     }\n \n   /* If doing anything with PIC, do it now.  */\n   if (! flag_pic)\n     fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n \n-  /* Figure out where to save any special registers.  */\n-  if (num_fregs)\n+  /* Call saved registers are saved just above the outgoing argument area.  */\n+  if (num_gfregs)\n     {\n-      int offset, n_fregs = num_fregs;\n+      int offset, n_regs;\n+      char *base;\n \n-      /* ??? This should always be -apparent_fsize.  */\n-      if (! leaf_function)\n-\toffset = -apparent_fsize;\n+      offset = -apparent_fsize + frame_base_offset;\n+      if (offset < -4096 || offset + num_gfregs * 4 > 4096)\n+\t{\n+\t  /* ??? This might be optimized a little as %g1 might already have a\n+\t     value close enough that a single add insn will do.  */\n+\t  /* ??? Although, all of this is probably only a temporary fix\n+\t     because if %g1 can hold a function result, then\n+\t     output_function_epilogue will lose (the result will get\n+\t     clobbered).  */\n+\t  build_big_number (file, offset, \"%g1\");\n+\t  fprintf (file, \"\\tadd %s,%%g1,%%g1\\n\", frame_base_name);\n+\t  base = \"%g1\";\n+\t  offset = 0;\n+\t}\n       else\n-\toffset = 0;\n+\t{\n+\t  base = frame_base_name;\n+\t}\n \n       if (TARGET_EPILOGUE && ! leaf_function)\n-\tn_fregs = save_regs (file, 0, 16, frame_base_name, offset, 0);\n+\t/* ??? Originally saved regs 0-15 here.  */\n+\tn_regs = save_regs (file, 0, 8, base, offset, 0);\n       else if (leaf_function)\n-\tn_fregs = save_regs (file, 0, 32, frame_base_name, offset, 0);\n+\t/* ??? Originally saved regs 0-31 here.  */\n+\tn_regs = save_regs (file, 0, 8, base, offset, 0);\n       if (TARGET_EPILOGUE)\n-\tsave_regs (file, 32, FIRST_PSEUDO_REGISTER,\n-\t\t   frame_base_name, offset, n_fregs);\n+\tsave_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n     }\n \n   leaf_label = 0;\n@@ -2188,30 +3003,40 @@ output_function_epilogue (file, size, leaf_function)\n       final_scan_insn (get_last_insn (), file, 0, 0, 1);\n     }\n \n-  if (num_fregs)\n+  /* Restore any call saved registers.  */\n+  if (num_gfregs)\n     {\n-      int offset, n_fregs = num_fregs;\n+      int offset, n_regs;\n+      char *base;\n \n-      /* ??? This should always be -apparent_fsize.  */\n-      if (! leaf_function)\n-\toffset = -apparent_fsize;\n+      offset = -apparent_fsize + frame_base_offset;\n+      if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n+\t{\n+\t  build_big_number (file, offset, \"%g1\");\n+\t  fprintf (file, \"\\tadd %s,%%g1,%%g1\\n\", frame_base_name);\n+\t  base = \"%g1\";\n+\t  offset = 0;\n+\t}\n       else\n-\toffset = 0;\n+\t{\n+\t  base = frame_base_name;\n+\t}\n \n       if (TARGET_EPILOGUE && ! leaf_function)\n-\tn_fregs = restore_regs (file, 0, 16, frame_base_name, offset, 0);\n+\t/* ??? Originally saved regs 0-15 here.  */\n+\tn_regs = restore_regs (file, 0, 8, base, offset, 0);\n       else if (leaf_function)\n-\tn_fregs = restore_regs (file, 0, 32, frame_base_name, offset, 0);\n+\t/* ??? Originally saved regs 0-31 here.  */\n+\tn_regs = restore_regs (file, 0, 8, base, offset, 0);\n       if (TARGET_EPILOGUE)\n-\trestore_regs (file, 32, FIRST_PSEUDO_REGISTER,\n-\t\t      frame_base_name, offset, n_fregs);\n+\trestore_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n     }\n \n   /* Work out how to skip the caller's unimp instruction if required.  */\n   if (leaf_function)\n-    ret = (current_function_returns_struct ? \"jmp %o7+12\" : \"retl\");\n+    ret = (SKIP_CALLERS_UNIMP_P ? \"jmp %o7+12\" : \"retl\");\n   else\n-    ret = (current_function_returns_struct ? \"jmp %i7+12\" : \"ret\");\n+    ret = (SKIP_CALLERS_UNIMP_P ? \"jmp %i7+12\" : \"ret\");\n \n   if (TARGET_EPILOGUE || leaf_label)\n     {\n@@ -2266,9 +3091,76 @@ output_function_epilogue (file, size, leaf_function)\n     }\n }\n \n-/* Do what is necessary for `va_start'.  The argument is ignored;\n-   We look at the current function to determine if stdarg or varargs\n-   is used and return the address of the first unnamed parameter.  */\n+/* Do what is necessary for `va_start'.  The argument is ignored.\n+   !v9: We look at the current function to determine if stdarg or varargs\n+   is used and return the address of the first unnamed parameter.\n+   v9: We save the argument integer and floating point regs in a buffer, and\n+   return the address of this buffer.  The rest is handled in va-sparc.h.  */\n+/* ??? This is currently conditioned on #ifdef SPARCV9 because\n+   current_function_args_info is different in each compiler.  */\n+\n+#ifdef SPARCV9\n+\n+rtx\n+sparc_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  /* First unnamed integer register.  */\n+  int first_intreg = current_function_args_info.arg_count[0];\n+  /* Number of integer registers we need to save.  */\n+  int n_intregs = MAX (0, NPARM_REGS (SImode) - first_intreg);\n+  /* First unnamed SFmode float reg (no, you can't pass SFmode floats as\n+     unnamed arguments, we just number them that way).  */\n+  int first_floatreg = current_function_args_info.arg_count[1] + 1 & ~1;\n+  /* Number of SFmode float regs to save.  */\n+  int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n+  int ptrsize = GET_MODE_SIZE (Pmode);\n+  rtx valist, regbuf, fpregs;\n+  int regno;\n+\n+  /* Allocate block of memory for the regs.\n+     We only allocate as much as we need.  */\n+  /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n+     Or can assign_stack_local accept a 0 SIZE argument?  */\n+\n+  regbuf = assign_stack_local (BLKmode,\n+\t\t\t       (n_intregs * UNITS_PER_WORD\n+\t\t\t\t+ n_floatregs * FLOAT_TYPE_SIZE/BITS_PER_UNIT),\n+\t\t\t       BITS_PER_WORD);\n+  MEM_IN_STRUCT_P (regbuf) = 1;\n+\n+  /* Save int args.\n+     This is optimized to only save the regs that are necessary.  Explicitly\n+     named args need not be saved.  */\n+\n+  if (n_intregs > 0)\n+    move_block_from_reg (BASE_INCOMING_ARG_REG (SImode) + first_intreg,\n+\t\t\t regbuf, n_intregs, n_intregs * UNITS_PER_WORD);\n+\n+  /* Save float args.\n+     This is optimized to only save the regs that are necessary.  Explicitly\n+     named args need not be saved.\n+     We explicitly build a pointer to the buffer because it halves the insn\n+     count when not optimizing (otherwise the pointer is built for each reg\n+     saved).  */\n+\n+  fpregs = gen_reg_rtx (Pmode);\n+  emit_move_insn (fpregs, plus_constant (XEXP (regbuf, 0),\n+\t\t\t\t\t n_intregs * UNITS_PER_WORD));\n+  for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno += 2)\n+    emit_move_insn (gen_rtx (MEM, DFmode,\n+\t\t\t     plus_constant (fpregs,\n+\t\t\t\t\t    GET_MODE_SIZE (SFmode) * regno)),\n+\t\t    gen_rtx (REG, DFmode, BASE_INCOMING_ARG_REG (DFmode)\n+\t\t\t     + regno));\n+\n+  /* Return the address of the regbuf.  */\n+\n+  return XEXP (regbuf, 0);\n+}\n+\n+#else /* ! SPARCV9 */\n \n rtx\n sparc_builtin_saveregs (arglist)\n@@ -2288,7 +3180,7 @@ sparc_builtin_saveregs (arglist)\n     first_reg = 0;\n #endif\n \n-  for (regno = first_reg; regno < NPARM_REGS; regno++)\n+  for (regno = first_reg; regno < NPARM_REGS (SImode); regno++)\n     emit_move_insn (gen_rtx (MEM, word_mode,\n \t\t\t     gen_rtx (PLUS, Pmode,\n \t\t\t\t      frame_pointer_rtx,\n@@ -2304,34 +3196,46 @@ sparc_builtin_saveregs (arglist)\n \n   return address;\n }\n+\n+#endif /* ! SPARCV9 */\n \f\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label.  OP is the conditional expression.  The\n    mode of register 0 says what kind of comparison we made.\n \n+   FP_COND_REG indicates which fp condition code register to use if this is\n+   a floating point branch.\n+\n    REVERSED is non-zero if we should reverse the sense of the comparison.\n \n    ANNUL is non-zero if we should generate an annulling branch.\n \n    NOOP is non-zero if we have to follow this branch by a noop.  */\n \n char *\n-output_cbranch (op, label, reversed, annul, noop)\n-     rtx op;\n+output_cbranch (op, fp_cond_reg, label, reversed, annul, noop)\n+     rtx op, fp_cond_reg;\n      int label;\n      int reversed, annul, noop;\n {\n   static char string[20];\n   enum rtx_code code = GET_CODE (op);\n   enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-  static char labelno[] = \" %lX\";\n-\n-  /* ??? FP branches can not be preceded by another floating point insn.\n+  static char v8_labelno[] = \" %lX\";\n+  static char v9_icc_labelno[] = \" %%icc,%lX\";\n+  static char v9_xcc_labelno[] = \" %%xcc,%lX\";\n+  static char v9_fcc_labelno[] = \" %%fccX,%lY\";\n+  char *labelno;\n+  int labeloff;\n+\n+  /* ??? !v9: FP branches cannot be preceded by another floating point insn.\n      Because there is currently no concept of pre-delay slots, we can fix\n      this only by always emitting a nop before a floating point branch.  */\n \n-  if (mode == CCFPmode || mode == CCFPEmode)\n+  if ((mode == CCFPmode || mode == CCFPEmode) && ! TARGET_V9)\n     strcpy (string, \"nop\\n\\t\");\n+  else\n+    string[0] = '\\0';\n \n   /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n   if (reversed\n@@ -2428,7 +3332,109 @@ output_cbranch (op, label, reversed, annul, noop)\n   if (annul)\n     strcat (string, \",a\");\n \n-  labelno[3] = label + '0';\n+  /* ??? If v9, optional prediction bit \",pt\" or \",pf\" goes here.  */\n+\n+  if (! TARGET_V9)\n+    {\n+      labeloff = 3;\n+      labelno = v8_labelno;\n+    }\n+  else\n+    {\n+      labeloff = 9;\n+      if (mode == CCFPmode || mode == CCFPEmode)\n+\t{\n+\t  labeloff = 10;\n+\t  labelno = v9_fcc_labelno;\n+\t  /* Set the char indicating the number of the fcc reg to use.  */\n+\t  labelno[6] = REGNO (fp_cond_reg) - 96 + '0';\n+\t}\n+      else if (mode == CCXmode || mode == CCX_NOOVmode)\n+\tlabelno = v9_xcc_labelno;\n+      else\n+\tlabelno = v9_icc_labelno;\n+    }\n+  /* Set the char indicating the number of the operand containing the\n+     label_ref.  */\n+  labelno[labeloff] = label + '0';\n+  strcat (string, labelno);\n+\n+  if (noop)\n+    strcat (string, \"\\n\\tnop\");\n+\n+  return string;\n+}\n+\n+/* Return the string to output a conditional branch to LABEL, testing\n+   register REG.  LABEL is the operand number of the label; REG is the\n+   operand number of the reg.  OP is the conditional expression.  The mode\n+   of REG says what kind of comparison we made.\n+\n+   REVERSED is non-zero if we should reverse the sense of the comparison.\n+\n+   ANNUL is non-zero if we should generate an annulling branch.\n+\n+   NOOP is non-zero if we have to follow this branch by a noop.  */\n+\n+char *\n+output_v9branch (op, reg, label, reversed, annul, noop)\n+     rtx op;\n+     int reg, label;\n+     int reversed, annul, noop;\n+{\n+  static char string[20];\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  static char labelno[] = \" %X,%lX\";\n+\n+  /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n+  if (reversed)\n+    code = reverse_condition (code), reversed = 0;\n+\n+  /* Only 64 bit versions of these instructions exist.  */\n+  if (mode != DImode)\n+    abort ();\n+\n+  /* Start by writing the branch condition.  */\n+\n+  switch (code)\n+    {\n+    case NE:\n+      strcpy (string, \"brnz\");\n+      break;\n+\n+    case EQ:\n+      strcpy (string, \"brz\");\n+      break;\n+\n+    case GE:\n+      strcpy (string, \"brgez\");\n+      break;\n+\n+    case LT:\n+      strcpy (string, \"brlz\");\n+      break;\n+\n+    case LE:\n+      strcpy (string, \"brlez\");\n+      break;\n+\n+    case GT:\n+      strcpy (string, \"brgz\");\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* Now add the annulling, reg, label, and nop.  */\n+  if (annul)\n+    strcat (string, \",a\");\n+\n+  /* ??? Optional prediction bit \",pt\" or \",pf\" goes here.  */\n+\n+  labelno[2] = reg + '0';\n+  labelno[6] = label + '0';\n   strcat (string, labelno);\n \n   if (noop)\n@@ -2439,6 +3445,9 @@ output_cbranch (op, label, reversed, annul, noop)\n \n /* Output assembler code to return from a function.  */\n \n+/* ??? v9: Update to use the new `return' instruction.  Also, add patterns to\n+   md file for the `return' instruction.  */\n+\n char *\n output_return (operands)\n      rtx *operands;\n@@ -2461,20 +3470,20 @@ output_return (operands)\n \n       if (actual_fsize <= 4096)\n \t{\n-\t  if (current_function_returns_struct)\n+\t  if (SKIP_CALLERS_UNIMP_P)\n \t    return \"jmp %%o7+12\\n\\tsub %%sp,-%0,%%sp\";\n \t  else\n \t    return \"retl\\n\\tsub %%sp,-%0,%%sp\";\n \t}\n       else if (actual_fsize <= 8192)\n \t{\n \t  operands[0] = gen_rtx (CONST_INT, VOIDmode, actual_fsize - 4096);\n-\t  if (current_function_returns_struct)\n+\t  if (SKIP_CALLERS_UNIMP_P)\n \t    return \"sub %%sp,-4096,%%sp\\n\\tjmp %%o7+12\\n\\tsub %%sp,-%0,%%sp\";\n \t  else\n \t    return \"sub %%sp,-4096,%%sp\\n\\tretl\\n\\tsub %%sp,-%0,%%sp\";\n \t}\n-      else if (current_function_returns_struct)\n+      else if (SKIP_CALLERS_UNIMP_P)\n \t{\n \t  if ((actual_fsize & 0x3ff) != 0)\n \t    return \"sethi %%hi(%a0),%%g1\\n\\tor %%g1,%%lo(%a0),%%g1\\n\\tjmp %%o7+12\\n\\tadd %%sp,%%g1,%%sp\";\n@@ -2491,7 +3500,7 @@ output_return (operands)\n     }\n   else\n     {\n-      if (current_function_returns_struct)\n+      if (SKIP_CALLERS_UNIMP_P)\n \treturn \"jmp %%i7+12\\n\\trestore\";\n       else\n \treturn \"ret\\n\\trestore\";\n@@ -2533,7 +3542,6 @@ int\n registers_ok_for_ldd_peep (reg1, reg2)\n      rtx reg1, reg2;\n {\n-\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n     return 0;\n@@ -2542,7 +3550,6 @@ registers_ok_for_ldd_peep (reg1, reg2)\n     return 0;\n \n   return (REGNO (reg1) == REGNO (reg2) - 1);\n-  \n }\n \n /* Return 1 if addr1 and addr2 are suitable for use in an ldd or \n@@ -2627,7 +3634,6 @@ int\n register_ok_for_ldd (reg)\n      rtx reg;\n {\n-\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg) != REG) \n     return 0;\n@@ -2636,7 +3642,6 @@ register_ok_for_ldd (reg)\n     return (REGNO (reg) % 2 == 0);\n   else \n     return 1;\n-\n }\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n@@ -2670,6 +3675,16 @@ print_operand (file, x, code)\n       if (dbr_sequence_length () == 0 && ! optimize)\n \tfputs (\"\\n\\tnop\", file);\n       return;\n+    case '_':\n+      /* Output the Medium/Anywhere code model base register.  */\n+      fputs (MEDANY_BASE_REG, file);\n+      return;\n+    case '@':\n+      /* Print out what we are using as the frame pointer.  This might\n+\t be %fp, or might be %sp+offset.  */\n+      /* ??? What if offset is too big? Perhaps the caller knows it isn't? */\n+      fprintf (file, \"%s+%d\", frame_base_name, frame_base_offset);\n+      return;\n     case 'Y':\n       /* Adjust the operand to take into account a RESTORE operation.  */\n       if (GET_CODE (x) != REG)\n@@ -2712,7 +3727,7 @@ print_operand (file, x, code)\n       else\n \tbreak;\n \n-    case  'A':\n+    case 'A':\n       switch (GET_CODE (x))\n \t{\n \tcase IOR: fputs (\"or\", file); break;\n@@ -2732,6 +3747,38 @@ print_operand (file, x, code)\n \t}\n       return;\n \n+      /* This is used by the conditional move instructions.  */\n+    case 'C':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase NE: fputs (\"ne\", file); break;\n+\tcase EQ: fputs (\"e\", file); break;\n+\tcase GE: fputs (\"ge\", file); break;\n+\tcase GT: fputs (\"g\", file); break;\n+\tcase LE: fputs (\"le\", file); break;\n+\tcase LT: fputs (\"l\", file); break;\n+\tcase GEU: fputs (\"geu\", file); break;\n+\tcase GTU: fputs (\"gu\", file); break;\n+\tcase LEU: fputs (\"leu\", file); break;\n+\tcase LTU: fputs (\"lu\", file); break;\n+\tdefault: output_operand_lossage (\"Invalid %%C operand\");\n+\t}\n+      return;\n+\n+      /* This is used by the movr instruction pattern.  */\n+    case 'D':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase NE: fputs (\"ne\", file); break;\n+\tcase EQ: fputs (\"e\", file); break;\n+\tcase GE: fputs (\"gez\", file); break;\n+\tcase LT: fputs (\"lz\", file); break;\n+\tcase LE: fputs (\"lez\", file); break;\n+\tcase GT: fputs (\"gz\", file); break;\n+\tdefault: output_operand_lossage (\"Invalid %%D operand\");\n+\t}\n+      return;\n+\n     case 'b':\n       {\n \t/* Print a sign-extended character.  */\n@@ -2797,6 +3844,8 @@ print_operand (file, x, code)\n \n /* ??? If there is a 64 bit counterpart to .word that the assembler\n    understands, then using that would simply this code greatly.  */\n+/* ??? We only output .xword's for symbols and only then in environments\n+   where the assembler can handle them.  */\n \n void\n output_double_int (file, value)\n@@ -2820,11 +3869,22 @@ output_double_int (file, value)\n     }\n   else if (GET_CODE (value) == SYMBOL_REF\n \t   || GET_CODE (value) == CONST\n-\t   || GET_CODE (value) == PLUS)\n+\t   || GET_CODE (value) == PLUS\n+\t   || (TARGET_V9 &&\n+\t       (GET_CODE (value) == LABEL_REF\n+\t\t|| GET_CODE (value) == MINUS)))\n     {\n-      /* Addresses are only 32 bits.  */\n-      ASM_OUTPUT_INT (file, const0_rtx);\n-      ASM_OUTPUT_INT (file, value);\n+      if (!TARGET_V9 || TARGET_ENV32)\n+\t{\n+\t  ASM_OUTPUT_INT (file, const0_rtx);\n+\t  ASM_OUTPUT_INT (file, value);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\t%s\\t\", ASM_LONGLONG);\n+\t  output_addr_const (file, value);\n+\t  fprintf (file, \"\\n\");\n+\t}\n     }\n   else\n     abort ();\n@@ -2983,6 +4043,112 @@ sparc_type_code (type)\n     }\n }\n \f\n+/* Nested function support.  */\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   This takes 16 insns: 2 shifts & 2 ands (to split up addresses), 4 sethi\n+   (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes\n+   (to store insns).  This is a bit excessive.  Perhaps a different\n+   mechanism would be better here.\n+\n+   Emit 3 FLUSH instructions (UNSPEC_VOLATILE 2) to synchonize the data\n+   and instruction caches.\n+\n+   ??? v9: We assume the top 32 bits of function addresses are 0.  */\n+\n+void\n+sparc_initialize_trampoline (tramp, fnaddr, cxt)\n+     rtx tramp, fnaddr, cxt;\n+{\n+  rtx high_cxt = expand_shift (RSHIFT_EXPR, SImode, cxt,\n+\t\t\t      size_int (10), 0, 1);\n+  rtx high_fn = expand_shift (RSHIFT_EXPR, SImode, fnaddr,\n+\t\t\t     size_int (10), 0, 1);\n+  rtx low_cxt = expand_and (cxt, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0);\n+  rtx low_fn = expand_and (fnaddr, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0);\n+  rtx g1_sethi = gen_rtx (HIGH, SImode,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x03000000));\n+  rtx g2_sethi = gen_rtx (HIGH, SImode,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x05000000));\n+  rtx g1_ori = gen_rtx (HIGH, SImode,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x82106000));\n+  rtx g2_ori = gen_rtx (HIGH, SImode,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x8410A000));\n+  rtx tem = gen_reg_rtx (SImode);\n+  emit_move_insn (tem, g1_sethi);\n+  emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 0)), high_fn);\n+  emit_move_insn (tem, g1_ori);\n+  emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 4)), low_fn);\n+  emit_move_insn (tem, g2_sethi);\n+  emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 8)), high_cxt);\n+  emit_move_insn (tem, g2_ori);\n+  emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 16)), low_cxt);\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 0)),\n+\t\t      2));\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 8)),\n+\t\t      2));\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 16)),\n+\t\t      2));\n+}\n+\n+void\n+sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n+     rtx tramp, fnaddr, cxt;\n+{\n+  rtx fnaddrdi = gen_reg_rtx (Pmode);\n+  rtx fnaddrsi = (emit_move_insn (fnaddrdi, fnaddr),\n+\t\tgen_rtx (SUBREG, SImode, fnaddrdi, 0));\n+  rtx cxtdi = gen_reg_rtx (Pmode);\n+  rtx cxtsi = (emit_move_insn (cxtdi, cxt),\n+\t\tgen_rtx (SUBREG, SImode, cxtdi, 0));\n+  rtx high_cxt = expand_shift (RSHIFT_EXPR, SImode, cxtsi,\n+\t\t\t      size_int (10), 0, 1);\n+  rtx high_fn = expand_shift (RSHIFT_EXPR, SImode, fnaddrsi,\n+\t\t\t     size_int (10), 0, 1);\n+  rtx low_cxt = expand_and (cxtsi, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \n+  rtx low_fn = expand_and (fnaddrsi, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \n+  rtx g1_sethi = gen_rtx (HIGH, SImode,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x03000000));\n+  rtx g2_sethi = gen_rtx (HIGH, SImode,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x05000000));\n+  rtx g1_ori = gen_rtx (HIGH, SImode,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x82106000));\n+  rtx g2_ori = gen_rtx (HIGH, SImode,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x8410A000));\n+  rtx tem = gen_reg_rtx (SImode);\n+  emit_move_insn (tem, g2_sethi);\n+  emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 0)), high_fn);\n+  emit_move_insn (tem, g2_ori);\n+  emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 4)), low_fn);\n+  emit_move_insn (tem, g1_sethi);\n+  emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 8)), high_cxt);\n+  emit_move_insn (tem, g1_ori);\n+  emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 16)), low_cxt);\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 0)),\n+\t\t      2));\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 8)),\n+\t\t      2));\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, plus_constant (tramp, 16)),\n+\t\t      2));\n+}\n+\f\n /* Subroutines to support a flat (single) register window calling\n    convention.  */\n \n@@ -3095,6 +4261,7 @@ sparc_flat_compute_frame_size (size)\n \n   /* This is the size of the 16 word reg save area, 1 word struct addr\n      area, and 4 word fp/alu register copy area.  */\n+  /* ??? Is the stack bias taken into account here?  */\n   extra_size\t = -STARTING_FRAME_OFFSET + FIRST_PARM_OFFSET(0);\n   var_size\t = size;\n   /* Also include the size needed for the 6 parameter registers.  */"}]}