{"sha": "a53785f90e37e767cd96210da2f7c73ad8621d37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzNzg1ZjkwZTM3ZTc2N2NkOTYyMTBkYTJmN2M3M2FkODYyMWQzNw==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-11-03T08:04:33Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-11-03T08:04:33Z"}, "message": "ObjectInputStream.java (readObject): Added code to conditionally dump out the serialized data.\n\n\t* java/io/ObjectInputStream.java (readObject): Added code to\n\tconditionally dump out the serialized data.\n\tHandle ENDBLOCKDATA case a bit more gracefully since the current\n\tbehavior doesn't seem to work as expected.\n\t(readStreamHeader): Added code for serialized data dumper.\n\t(readNextBlock): Ditto.\n\t(readFields): Ditto.\n\t(dump): New private static field for turning on/off dumper.\n\t(setDump): New native method.\n\t(dumpElement): New native method.\n\t(dumpElementln): New native method.\n\t* java/io/natObjectInputStream.cc (setDump): New method.\n\t(dumpElement): New method.\n\t(dumpElementln): New method.\n\nSerialization dumper.  Enable by configuring with --enable-libgcj-debug\nand calling java.io.ObjectInputStream.setDump(true) in your test program.\nThe output will be generated as the object is deserialized (i.e. the\nreadObject() method is executed).\n\nFrom-SVN: r37223", "tree": {"sha": "c6e8c834e2c535007905e93116b1ce98ae2be3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e8c834e2c535007905e93116b1ce98ae2be3c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a53785f90e37e767cd96210da2f7c73ad8621d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53785f90e37e767cd96210da2f7c73ad8621d37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53785f90e37e767cd96210da2f7c73ad8621d37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53785f90e37e767cd96210da2f7c73ad8621d37/comments", "author": null, "committer": null, "parents": [{"sha": "6678181b3c0196dc782aec1bbf16182cd92c0257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6678181b3c0196dc782aec1bbf16182cd92c0257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6678181b3c0196dc782aec1bbf16182cd92c0257"}], "stats": {"total": 157, "additions": 136, "deletions": 21}, "files": [{"sha": "b893a063463a2f6e90465cc989b8594f993f1572", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a53785f90e37e767cd96210da2f7c73ad8621d37", "patch": "@@ -1,3 +1,20 @@\n+2000-11-02  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/io/ObjectInputStream.java (readObject): Added code to\n+\tconditionally dump out the serialized data.\n+\tHandle ENDBLOCKDATA case a bit more gracefully since the current\n+\tbehavior doesn't seem to work as expected.\n+\t(readStreamHeader): Added code for serialized data dumper.\n+\t(readNextBlock): Ditto.\n+\t(readFields): Ditto.\n+\t(dump): New private static field for turning on/off dumper.\n+\t(setDump): New native method.\n+\t(dumpElement): New native method.\n+\t(dumpElementln): New native method.\n+\t* java/io/natObjectInputStream.cc (setDump): New method.\n+\t(dumpElement): New method.\n+\t(dumpElementln): New method.\n+\n 2000-11-02  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/net/InetAddress.java (addr): Renamed from 'address'."}, {"sha": "2a90ba36884a39e2d714d42a7d817803c2daed30", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 78, "deletions": 21, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=a53785f90e37e767cd96210da2f7c73ad8621d37", "patch": "@@ -106,31 +106,38 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n     this.isDeserializing = true;\n \n-//    DEBUG (\"MARKER \");\n     byte marker = this.realInputStream.readByte ();\n+    dumpElement (\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n \n     switch (marker)\n     {\n       case TC_BLOCKDATA:\n       case TC_BLOCKDATALONG:\n+\tif (marker == TC_BLOCKDATALONG) \n+\t  dumpElementln (\"BLOCKDATALONG\");\n+\telse\n+\t  dumpElementln (\"BLOCKDATA\");\n \treadNextBlock (marker);\n \tthrow new BlockDataException (this.blockDataBytes);\n \n       case TC_NULL:\n+\tdumpElementln (\"NULL\");\n \tret_val = null;\n \tbreak;\n \n       case TC_REFERENCE:\n       {\n-//\tDEBUG (\"REFERENCE \");\n+\tdumpElement (\"REFERENCE \");\n \tInteger oid = new Integer (this.realInputStream.readInt ());\n+\tdumpElementln (Integer.toHexString(oid.intValue()));\n \tret_val = ((ObjectIdentityWrapper)\n \t\t   this.objectLookupTable.get (oid)).object;\n \tbreak;\n       }\n \n       case TC_CLASS:\n       {\n+\tdumpElementln (\"CLASS\");\n \tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n \tClass clazz = osc.forClass ();\n \tassignNewHandle (clazz);\n@@ -140,14 +147,15 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n       case TC_CLASSDESC:\n       {\n-//\tDEBUG (\"CLASSDESC NAME \");\n+\tdumpElement (\"CLASSDESC NAME=\");\n \tString name = this.realInputStream.readUTF ();\n-//\tDEBUG (\"UID \");\n+\tdumpElement (name + \"; UID=\");\n \tlong uid = this.realInputStream.readLong ();\n-//\tDEBUG (\"FLAGS \");\n+\tdumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n \tbyte flags = this.realInputStream.readByte ();\n-//\tDEBUG (\"FIELD COUNT \");\n+\tdumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n \tshort field_count = this.realInputStream.readShort ();\n+\tdumpElementln (Short.toString(field_count));\n \tObjectStreamField[] fields = new ObjectStreamField[field_count];\n \n \tObjectStreamClass osc = new ObjectStreamClass (name, uid,\n@@ -156,10 +164,11 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n \tfor (int i=0; i < field_count; i++)\n \t{\n-//\t  DEBUG (\"TYPE CODE \");\n+\t  dumpElement (\"  TYPE CODE=\");\n \t  char type_code = (char)this.realInputStream.readByte ();\n-//\t  DEBUG (\"FIELD NAME \");\n+\t  dumpElement (type_code + \"; FIELD NAME=\");\n \t  String field_name = this.realInputStream.readUTF ();\n+\t  dumpElementln (field_name);\n \t  String class_name;\n \n \t  if (type_code == 'L' || type_code == '[')\n@@ -177,9 +186,9 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \tosc.setClass (resolveClass (osc));\n \tsetBlockDataMode (false);\n \n-//\tDEBUG (\"ENDBLOCKDATA \");\n \tif (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n \t  throw new IOException (\"Data annotated to class was not consumed.\");\n+\tdumpElementln (\"ENDBLOCKDATA \");\n \n \tosc.setSuperclass ((ObjectStreamClass)readObject ());\n \tret_val = osc;\n@@ -188,27 +197,33 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n       case TC_STRING:\n       {\n-//\tDEBUG (\"STRING \");\n+\tdumpElement (\"STRING=\");\n \tString s = this.realInputStream.readUTF ();\n+\tdumpElementln (s);\n \tret_val = processResolution (s, assignNewHandle (s));\n \tbreak;\n       }\n \n       case TC_ARRAY:\n       {\n+\tdumpElementln (\"ARRAY\");\n \tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n \tClass componenetType = osc.forClass ().getComponentType ();\n-//\tDEBUG (\"ARRAY LENGTH \");\n+\tdumpElement (\"ARRAY LENGTH=\");\n \tint length = this.realInputStream.readInt ();\n+\tdumpElementln (length + \"; COMPONENT TYPE=\" + componenetType);\n \tObject array = Array.newInstance (componenetType, length);\n \tint handle = assignNewHandle (array);\n \treadArrayElements (array, componenetType);\n+\tfor (int i=0, len=Array.getLength(array); i < len; i++)\n+\t  dumpElementln (\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i).toString());\n \tret_val = processResolution (array, handle);\n \tbreak;\n       }\n \n       case TC_OBJECT:\n       {\n+\tdumpElementln (\"OBJECT\");\n \tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n \tClass clazz = osc.forClass ();\n \n@@ -284,8 +299,8 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t{\n \t  this.currentObjectStreamClass = hierarchy[i];\n \n-//\t  DEBUGln (\"Reading fields of \"\n-//\t\t   + this.currentObjectStreamClass.getName ());\n+\t  dumpElementln (\"Reading fields of \"\n+\t\t   + this.currentObjectStreamClass.getName ());\n \n \t  has_read = true;\n \n@@ -308,9 +323,23 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n \t  if (has_read)\n \t  {\n-//\t    DEBUG (\"ENDBLOCKDATA? \");\n-\t    if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n-\t      throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n+\t    dumpElement (\"ENDBLOCKDATA? \");\n+\t    try\n+\t      {\n+\t\t// FIXME: XXX: This try block is to catch EOF which is\n+\t\t// thrown for some objects.  That indicates a bug in the logic.\n+\t        if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n+\t\t  throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n+\t        dumpElementln (\"yes\");\n+\t      }\n+\t    catch (EOFException e)\n+\t      {\n+\t        dumpElementln (\"no, got EOFException\");\n+\t      }\n+\t    catch (IOException e)\n+\t      {\n+\t        dumpElementln (\"no, got IOException\");\n+\t      }\n \t  }\n \t}\n \n@@ -321,13 +350,16 @@ public final Object readObject () throws ClassNotFoundException, IOException\n       }\n \n       case TC_RESET:\n+\tdumpElementln (\"RESET\");\n \tclearHandles ();\n \tret_val = readObject ();\n \tbreak;\n \n       case TC_EXCEPTION:\n       {\n+\tdumpElement (\"EXCEPTION=\");\n \tException e = (Exception)readObject ();\n+\tdumpElementln (e.toString());\n \tclearHandles ();\n \tthrow new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n       }\n@@ -512,11 +544,11 @@ protected boolean enableResolveObject (boolean enable)\n   protected void readStreamHeader ()\n     throws IOException, StreamCorruptedException\n   {\n-//    DEBUG (\"STREAM MAGIC \");\n+    dumpElement (\"STREAM MAGIC \");\n     if (this.realInputStream.readShort () != STREAM_MAGIC)\n       throw new StreamCorruptedException (\"Invalid stream magic number\");\n \n-//    DEBUG (\"STREAM VERSION \");\n+    dumpElementln (\"STREAM VERSION \");\n     if (this.realInputStream.readShort () != STREAM_VERSION)\n       throw new StreamCorruptedException (\"Invalid stream version number\");\n   }\n@@ -982,7 +1014,7 @@ private void clearHandles ()\n \n   private void readNextBlock () throws IOException\n   {\n-//    DEBUG (\"MARKER \");\n+//  DEBUGln (\"In readNextBlock \");\n     readNextBlock (this.realInputStream.readByte ());\n   }\n \n@@ -991,13 +1023,15 @@ private void readNextBlock (byte marker) throws IOException\n   {\n     if (marker == TC_BLOCKDATA)\n     {\n-//      DEBUG (\"BLOCK DATA SIZE \");\n+      dumpElement (\"BLOCK DATA SIZE=\");\n       this.blockDataBytes = this.realInputStream.readUnsignedByte ();\n+      dumpElementln (Integer.toString(this.blockDataBytes));\n     }\n     else if (marker == TC_BLOCKDATALONG)\n     {\n-//      DEBUG (\"BLOCK DATA LONG SIZE \");\n+      dumpElement (\"BLOCK DATA LONG SIZE=\");\n       this.blockDataBytes = this.realInputStream.readInt ();\n+      dumpElementln (Integer.toString(this.blockDataBytes));\n     }\n     else\n     {\n@@ -1088,8 +1122,10 @@ private void readFields (Object obj, ObjectStreamField[] stream_fields,\n \t\t\t   ObjectStreamClass stream_osc)\n     throws ClassNotFoundException, IOException\n   {\n+//  DEBUGln (\"In readFields\");\n     if (call_read_method)\n     {\n+//    DEBUGln (\"  call_read_method is true\");\n       fieldsAlreadyRead = false;\n       setBlockDataMode (true);\n       callReadMethod (obj, stream_osc.forClass ());\n@@ -1157,55 +1193,71 @@ else if (comp_val > 0)\n       {\n \tboolean value =\n \t  default_initialize ? false : this.realInputStream.readBoolean ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setBooleanField (obj, field_name, value);\n       }\n       else if (type == Byte.TYPE)\n       {\n \tbyte value =\n \t  default_initialize ? 0 : this.realInputStream.readByte ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setByteField (obj, field_name, value);\n       }\n       else if (type == Character.TYPE)\n       {\n \tchar value =\n \t  default_initialize ? (char)0 : this.realInputStream.readChar ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setCharField (obj, field_name, value);\n       }\n       else if (type == Double.TYPE)\n       {\n \tdouble value =\n \t  default_initialize ? 0 : this.realInputStream.readDouble ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setDoubleField (obj, field_name, value);\n       }\n       else if (type == Float.TYPE)\n       {\n \tfloat value =\n \t  default_initialize ? 0 : this.realInputStream.readFloat ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setFloatField (obj, field_name, value);\n       }\n       else if (type == Integer.TYPE)\n       {\n \tint value =\n \t  default_initialize ? 0 : this.realInputStream.readInt ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setIntField (obj, field_name, value);\n       }\n       else if (type == Long.TYPE)\n       {\n \tlong value =\n \t  default_initialize ? 0 : this.realInputStream.readLong ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setLongField (obj, field_name, value);\n       }\n       else if (type == Short.TYPE)\n       {\n \tshort value =\n \t  default_initialize ? (short)0 : this.realInputStream.readShort ();\n+\tif (!default_initialize && set_value)\n+\t  dumpElementln (\"  \" + field_name + \": \" + value);\n \tif (set_value)\n \t  setShortField (obj, field_name, value);\n       }\n@@ -1458,6 +1510,11 @@ private void setObjectField (Object obj, String field_name, String type_code,\n   private boolean fieldsAlreadyRead;\n   private Vector validators;\n \n+  private static boolean dump;\n+  public native static void setDump (boolean dump);\n+  private native void dumpElement (String msg);\n+  private native void dumpElementln (String msg);\n+\n \n /* FIXME: These 2 methods cause a build error on i686-pc-linux-gnu.\n   private void DEBUG (String msg)"}, {"sha": "ac72ecf2b05bdc6583a4dc06a6bfb6d00243ee62", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53785f90e37e767cd96210da2f7c73ad8621d37/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=a53785f90e37e767cd96210da2f7c73ad8621d37", "patch": "@@ -20,6 +20,11 @@ details.  */\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/reflect/Method.h>\n \n+#ifdef DEBUG\n+#include <java/lang/System.h>\n+#include <java/io/PrintStream.h>\n+#endif\n+\n jobject\n java::io::ObjectInputStream::allocateObject (jclass klass)\n {\n@@ -74,3 +79,39 @@ java::io::ObjectInputStream::getMethod (jclass klass, jstring name,\n   return klass->getPrivateMethod (name, arg_types);\n }\n \n+#ifdef DEBUG\n+void\n+java::io::ObjectInputStream::setDump (jboolean dump)\n+{\n+  java::io::ObjectInputStream::dump = dump;\n+}\n+\n+void\n+java::io::ObjectInputStream::dumpElement (jstring msg)\n+{\n+  if (dump)\n+    java::lang::System::out->print (msg);\n+}\n+\n+void\n+java::io::ObjectInputStream::dumpElementln (jstring msg)\n+{\n+  if (dump)\n+    java::lang::System::out->println (msg);\n+}\n+#else\n+void\n+java::io::ObjectInputStream::setDump (jboolean dump)\n+{\n+}\n+\n+void\n+java::io::ObjectInputStream::dumpElement (jstring msg)\n+{\n+}\n+\n+void\n+java::io::ObjectInputStream::dumpElementln (jstring msg)\n+{\n+}\n+#endif"}]}