{"sha": "e5f614d77706f400f88be4def09c8eaff46d9fc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVmNjE0ZDc3NzA2ZjQwMGY4OGJlNGRlZjA5YzhlYWZmNDZkOWZjNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "sidwell@codesourcery.com", "date": "2000-01-18T10:23:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-01-18T10:23:31Z"}, "message": "cp-tree.h (get_tinfo_fn_dynamic): Remove prototype.\n\n\t* cp-tree.h (get_tinfo_fn_dynamic): Remove prototype.\n\t(build_x_typeid): Likewise.\n\t(get_tinfo_fn): Likewise.\n\t(get_tinfo_fn_unused): Rename to ...\n\t(get_tinfo_decl): ... here.\n\t* rtti.c (build_headof): Replace logic error with assertion.\n\t(get_tinfo_fn_dynamic): Rename to ...\n\t(get_tinfo_decl_dynamic): ... here. Make static. Use\n\tcomplete_type_or_else.\n\t(build_x_typeid): Move into ...\n\t(build_typeid): ... here. Adjust call to\n\tget_tinfo_decl_dynamic. Use tinfo_from_decl. Simplify\n\tthrow_bad_typeid expression.\n\t(get_tinfo_fn_unused): Rename to ...\n\t(get_tinfo_decl): ... here. Adjust comment.\n\t(get_tinfo_fn): Delete.\n\t(tinfo_from_decl): New static function.\n\t(get_typeid_1): Call get_tinfo_decl and tinfo_from_decl.\n\t(get_typeid): Use complete_type_or_else.\n\t(build_dynamic_cast_1): Adjust calls to\n\tget_tinfo_decl_dynamic. Simplify throw_bad_cast expression.\n\t* parse.y (primary): Adjust call to build_typeid.\n\t* except.c (build_eh_type_type_ref): Adjust call to\n\tget_tinfo_decl. Mark as used.\n\t* class.c (set_rtti_entry): Adjust call to get_tinfo_decl.\n\t* decl2.c (build_expr_from_tree): Adjust call to build_typeid.\n\t* parse.c: Regenerated.\n\nFrom-SVN: r31485", "tree": {"sha": "6e4197a8cde80dd6c8daf7cbe8b8ec6e492caf3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e4197a8cde80dd6c8daf7cbe8b8ec6e492caf3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5f614d77706f400f88be4def09c8eaff46d9fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f614d77706f400f88be4def09c8eaff46d9fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f614d77706f400f88be4def09c8eaff46d9fc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f614d77706f400f88be4def09c8eaff46d9fc6/comments", "author": null, "committer": null, "parents": [{"sha": "c399e76da6fe124f13dc45c5d85df8138bff7284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c399e76da6fe124f13dc45c5d85df8138bff7284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c399e76da6fe124f13dc45c5d85df8138bff7284"}], "stats": {"total": 172, "additions": 87, "deletions": 85}, "files": [{"sha": "5be6a0f51d08d1564ab055141d6ef2430e46e86b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -1,3 +1,33 @@\n+2000-01-18  Nathan Sidwell  <sidwell@codesourcery.com>\n+\n+\t* cp-tree.h (get_tinfo_fn_dynamic): Remove prototype.\n+\t(build_x_typeid): Likewise.\n+\t(get_tinfo_fn): Likewise.\n+\t(get_tinfo_fn_unused): Rename to ...\n+\t(get_tinfo_decl): ... here.\n+\t* rtti.c (build_headof): Replace logic error with assertion.\n+\t(get_tinfo_fn_dynamic): Rename to ...\n+\t(get_tinfo_decl_dynamic): ... here. Make static. Use\n+\tcomplete_type_or_else.\n+\t(build_x_typeid): Move into ...\n+\t(build_typeid): ... here. Adjust call to\n+\tget_tinfo_decl_dynamic. Use tinfo_from_decl. Simplify\n+\tthrow_bad_typeid expression.\n+\t(get_tinfo_fn_unused): Rename to ...\n+\t(get_tinfo_decl): ... here. Adjust comment.\n+\t(get_tinfo_fn): Delete.\n+\t(tinfo_from_decl): New static function.\n+\t(get_typeid_1): Call get_tinfo_decl and tinfo_from_decl.\n+\t(get_typeid): Use complete_type_or_else.\n+\t(build_dynamic_cast_1): Adjust calls to\n+\tget_tinfo_decl_dynamic. Simplify throw_bad_cast expression.\n+\t* parse.y (primary): Adjust call to build_typeid.\n+\t* except.c (build_eh_type_type_ref): Adjust call to\n+\tget_tinfo_decl. Mark as used.\n+\t* class.c (set_rtti_entry): Adjust call to get_tinfo_decl.\n+\t* decl2.c (build_expr_from_tree): Adjust call to build_typeid.\n+\t* parse.c: Regenerated.\n+\n 2000-01-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (fixed_type_or_null): Don't clear NONNULL.  Document"}, {"sha": "91d41ae63ff134485c0d7d7542bd00dc31b6c333", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -829,7 +829,7 @@ set_rtti_entry (virtuals, offset, type)\n     return;\n \n   if (flag_rtti)\n-    fn = get_tinfo_fn_unused (type);\n+    fn = get_tinfo_decl (type);\n   else\n     /* If someone tries to get RTTI information for a type compiled\n        without RTTI, they're out of luck.  By calling __pure_virtual"}, {"sha": "1af012d99a0b8b87c8462346fe88bed13c574a6a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -3961,11 +3961,8 @@ extern void finish_repo\t\t\t\tPROTO((void));\n \n /* in rtti.c */\n extern void init_rtti_processing\t\tPROTO((void));\n-extern tree get_tinfo_fn_dynamic\t\tPROTO((tree));\n extern tree build_typeid\t\t\tPROTO((tree));\n-extern tree build_x_typeid\t\t\tPROTO((tree));\n-extern tree get_tinfo_fn\t\t\tPROTO((tree));\n-extern tree get_tinfo_fn_unused\t\t\tPROTO((tree));\n+extern tree get_tinfo_decl                      PROTO((tree));\n extern tree get_typeid\t\t\t\tPROTO((tree));\n extern tree get_typeid_1\t\t\tPROTO((tree));\n extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));"}, {"sha": "bd3c08aedc467e20e6f4a4ca9205f166a36b950a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -3999,7 +3999,7 @@ build_expr_from_tree (t)\n     case TYPEID_EXPR:\n       if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 0))) == 't')\n \treturn get_typeid (TREE_OPERAND (t, 0));\n-      return build_x_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n+      return build_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n     case VAR_DECL:\n       return convert_from_reference (t);"}, {"sha": "363c4bff247e95ae6ce8039f5a18e6dc42d61b7f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -343,7 +343,7 @@ build_eh_type_type (type)\n   return build1 (ADDR_EXPR, ptr_type_node, get_typeid_1 (type));\n }\n \n-/* Build the address of a typeinfo function for use in the runtime\n+/* Build the address of a typeinfo decl for use in the runtime\n    matching field of the new exception model */\n \n static tree\n@@ -362,7 +362,8 @@ build_eh_type_type_ref (type)\n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  exp = get_tinfo_fn (type);\n+  exp = get_tinfo_decl (type);\n+  mark_used (exp);\n   exp = build1 (ADDR_EXPR, ptr_type_node, exp);\n \n   return (exp);"}, {"sha": "840b04cc76c14fa60360de55afe351d112731077", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -5748,7 +5748,7 @@ case 327:\n     break;}\n case 328:\n #line 1460 \"parse.y\"\n-{ yyval.ttype = build_x_typeid (yyvsp[-1].ttype); ;\n+{ yyval.ttype = build_typeid (yyvsp[-1].ttype); ;\n     break;}\n case 329:\n #line 1462 \"parse.y\""}, {"sha": "7a236e02b676c5b6bf4135cbdb7e75a6fa29a06f", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -1457,7 +1457,7 @@ primary:\n \t\t  check_for_new_type (\"const_cast\", $3);\n \t\t  $$ = build_const_cast (type, $6); }\n \t| TYPEID '(' expr ')'\n-\t\t{ $$ = build_x_typeid ($3); }\n+\t\t{ $$ = build_typeid ($3); }\n \t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3.t);\n \t\t  check_for_new_type (\"typeid\", $3);"}, {"sha": "079d5b481ed491ce50fe92ca5d87cd0bf905b674", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 49, "deletions": 75, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f614d77706f400f88be4def09c8eaff46d9fc6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=e5f614d77706f400f88be4def09c8eaff46d9fc6", "patch": "@@ -48,6 +48,8 @@ static void expand_ptr_desc PROTO((tree, tree));\n static void expand_generic_desc PROTO((tree, tree, const char *));\n static tree throw_bad_cast PROTO((void));\n static tree throw_bad_typeid PROTO((void));\n+static tree get_tinfo_decl_dynamic PROTO((tree));\n+static tree tinfo_from_decl PROTO((tree));\n \f\n void\n init_rtti_processing ()\n@@ -95,11 +97,7 @@ build_headof (exp)\n   tree aref;\n   tree offset;\n \n-  if (TREE_CODE (type) != POINTER_TYPE)\n-    {\n-      error (\"`headof' applied to non-pointer type\");\n-      return error_mark_node;\n-    }\n+  my_friendly_assert (TREE_CODE (type) == POINTER_TYPE, 20000112);\n   type = TREE_TYPE (type);\n \n   if (!TYPE_POLYMORPHIC_P (type))\n@@ -172,25 +170,19 @@ throw_bad_typeid ()\n   return call_void_fn (\"__throw_bad_typeid\");\n }\n \f\n-/* Return the type_info function associated with the expression EXP.  If\n-   EXP is a reference to a polymorphic class, return the dynamic type;\n+/* Return a pointer to type_info function associated with the expression EXP.\n+   If EXP is a reference to a polymorphic class, return the dynamic type;\n    otherwise return the static type of the expression.  */\n \n-tree\n-get_tinfo_fn_dynamic (exp)\n+static tree\n+get_tinfo_decl_dynamic (exp)\n      tree exp;\n {\n   tree type;\n-\n+  \n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  if (type_unknown_p (exp))\n-    {\n-      error (\"typeid of overloaded function\");\n-      return error_mark_node;\n-    }\n-\n   type = TREE_TYPE (exp);\n \n   /* peel back references, so they match.  */\n@@ -199,12 +191,12 @@ get_tinfo_fn_dynamic (exp)\n \n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n-\n-  if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n-    {\n-      cp_error (\"taking typeid of incomplete type `%T'\", type);\n-      return error_mark_node;\n-    }\n+  \n+  if (type != void_type_node)\n+    type = complete_type_or_else (type, exp);\n+  \n+  if (!type)\n+    return error_mark_node;\n \n   /* If exp is a reference to polymorphic type, get the real type_info.  */\n   if (TYPE_POLYMORPHIC_P (type) && ! resolves_to_fixed_type_p (exp, 0))\n@@ -223,7 +215,7 @@ get_tinfo_fn_dynamic (exp)\n       /* If we don't have rtti stuff, get to a sub-object that does.  */\n       if (! CLASSTYPE_VFIELDS (type))\n \t{\n-\t  exp = build_unary_op (ADDR_EXPR, exp, 0);\n+      \t  exp = build_unary_op (ADDR_EXPR, exp, 0);\n \t  exp = build_headof_sub (exp);\n \t  exp = build_indirect_ref (exp, NULL_PTR);\n \t}\n@@ -237,21 +229,13 @@ get_tinfo_fn_dynamic (exp)\n     }\n \n   /* otherwise return the type_info for the static type of the expr.  */\n-  return get_tinfo_fn (TYPE_MAIN_VARIANT (type));\n+  exp = get_tinfo_decl (TYPE_MAIN_VARIANT (type));\n+  return build_unary_op (ADDR_EXPR, exp, 0);\n }\n \n tree\n build_typeid (exp)\n      tree exp;\n-{\n-  exp = get_tinfo_fn_dynamic (exp);\n-  exp = build_call (exp, TREE_TYPE (tinfo_fn_type), NULL_TREE);\n-  return convert_from_reference (exp);\n-}  \n-\n-tree\n-build_x_typeid (exp)\n-     tree exp;\n {\n   tree cond = NULL_TREE;\n   tree type;\n@@ -282,22 +266,18 @@ build_x_typeid (exp)\n       cond = cp_convert (boolean_type_node, TREE_OPERAND (exp, 0));\n     }\n \n-  exp = get_tinfo_fn_dynamic (exp);\n+  exp = get_tinfo_decl_dynamic (exp);\n \n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  type = TREE_TYPE (tinfo_fn_type);\n-  exp = build_call (exp, type, NULL_TREE);\n+  exp = tinfo_from_decl (exp);\n \n   if (cond)\n     {\n       tree bad = throw_bad_typeid ();\n \n-      bad = build_compound_expr\n-\t(tree_cons (NULL_TREE, bad, build_tree_list\n-\t\t    (NULL_TREE, cp_convert (type, integer_zero_node))));\n-      exp = build (COND_EXPR, type, cond, exp, bad);\n+      exp = build (COND_EXPR, TREE_TYPE (exp), cond, exp, bad);\n     }\n \n   return convert_from_reference (exp);\n@@ -345,19 +325,16 @@ get_tinfo_var (type)\n   return declare_global_var (tname, arrtype);\n }\n \n-/* Returns the decl for a function which will return a type_info node for\n-   TYPE.  This version does not mark the function used, for use in\n-   set_rtti_entry; for the vtable case, we'll get marked in\n-   finish_vtable_vardecl, when we know that we want to be emitted.\n-\n-   We do this to avoid emitting the tinfo node itself, since we don't\n-   currently support DECL_DEFER_OUTPUT for variables.  Also, we don't\n-   associate constant pools with their functions properly, so we would\n-   emit string constants and such even though we don't emit the actual\n-   function.  When those bugs are fixed, this function should go away.  */\n+/* Returns a decl for a function or variable which can be used to obtain a\n+   type_info object for TYPE.  The old-abi uses functions, the new-abi will\n+   use the type_info object directly.  You can take the address of the\n+   returned decl, to save the decl.  To use the generator call\n+   tinfo_from_generator.  You must arrange that the decl is mark_used, if\n+   actually use it --- decls in vtables are only used if the vtable is\n+   output.  */\n \n tree\n-get_tinfo_fn_unused (type)\n+get_tinfo_decl (type)\n      tree type;\n {\n   tree name;\n@@ -385,19 +362,20 @@ get_tinfo_fn_unused (type)\n   pushdecl_top_level (d);\n   make_function_rtl (d);\n   mark_inline_for_output (d);\n-\n+  \n   return d;\n }\n \n-/* Likewise, but also mark it used.  Called by various EH and RTTI code.  */\n+/* Given an expr produced by get_tinfo_decl, return an expr which\n+   produces a reference to the type_info object.  */\n \n-tree\n-get_tinfo_fn (type)\n-     tree type;\n+static tree\n+tinfo_from_decl (expr)\n+     tree expr;\n {\n-  tree d = get_tinfo_fn_unused (type);\n-  mark_used (d);\n-  return d;\n+  tree t = build_call (expr, TREE_TYPE (tinfo_fn_type), NULL_TREE);\n+  \n+  return t;\n }\n \n tree\n@@ -406,12 +384,12 @@ get_typeid_1 (type)\n {\n   tree t;\n \n-  t = build_call\n-    (get_tinfo_fn (type), TREE_TYPE (tinfo_fn_type), NULL_TREE);\n+  t = get_tinfo_decl (type);\n+  t = tinfo_from_decl (t);\n   return convert_from_reference (t);\n }\n   \n-/* Return the type_info object for TYPE, creating it if necessary.  */\n+/* Return the type_info object for TYPE.  */\n \n tree\n get_typeid (type)\n@@ -439,11 +417,11 @@ get_typeid (type)\n      that is the operand of typeid are always ignored.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n-    {\n-      cp_error (\"taking typeid of incomplete type `%T'\", type);\n-      return error_mark_node;\n-    }\n+  if (type != void_type_node)\n+    type = complete_type_or_else (type, NULL_TREE);\n+  \n+  if (!type)\n+    return error_mark_node;\n \n   return get_typeid_1 (type);\n }\n@@ -627,15 +605,15 @@ build_dynamic_cast_1 (type, expr)\n \t  expr2 = build_headof (expr1);\n \n \t  if (ec == POINTER_TYPE)\n-\t    td1 = get_tinfo_fn_dynamic (build_indirect_ref (expr, NULL_PTR));\n+\t    td1 = get_tinfo_decl_dynamic (build_indirect_ref (expr, NULL_PTR));\n \t  else\n-\t    td1 = get_tinfo_fn_dynamic (expr);\n+\t    td1 = get_tinfo_decl_dynamic (expr);\n \t  td1 = decay_conversion (td1);\n \t  \n \t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n-\t  td2 = decay_conversion (get_tinfo_fn (target_type));\n-\t  td3 = decay_conversion (get_tinfo_fn (static_type));\n+\t  td2 = decay_conversion (get_tinfo_decl (target_type));\n+\t  td3 = decay_conversion (get_tinfo_decl (static_type));\n \n           /* Determine how T and V are related.  */\n           boff = get_dynamic_cast_base_type (static_type, target_type);\n@@ -678,10 +656,6 @@ build_dynamic_cast_1 (type, expr)\n \t  if (tc == REFERENCE_TYPE)\n \t    {\n \t      expr1 = throw_bad_cast ();\n-\t      expr1 = build_compound_expr\n-\t\t(tree_cons (NULL_TREE, expr1,\n-\t\t\t    build_tree_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n-\t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n \t      return build (COND_EXPR, type, result, result, expr1);\n \t    }"}]}