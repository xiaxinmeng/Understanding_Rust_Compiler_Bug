{"sha": "bfac633a90588e96050f8767052d59efd7307cb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhYzYzM2E5MDU4OGU5NjA1MGY4NzY3MDUyZDU5ZWZkNzMwN2NiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-15T07:32:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-15T07:32:28Z"}, "message": "df.h (DF_INSN_INFO_MWS, [...]): New macros.\n\ngcc/\n\t* df.h (DF_INSN_INFO_MWS, FOR_EACH_INSN_INFO_DEF): New macros.\n\t(FOR_EACH_INSN_INFO_USE, FOR_EACH_INSN_INFO_EQ_USE): Likewise.\n\t(FOR_EACH_INSN_DEF, FOR_EACH_INSN_USE, FOR_EACH_INSN_EQ_USE): Likewise.\n\t* auto-inc-dec.c (find_inc, merge_in_block): Use them.\n\t* combine.c (create_log_links): Likewise.\n\t* compare-elim.c (find_flags_uses_in_insn): Likewise.\n\t(try_eliminate_compare): Likewise.\n\t* cprop.c (make_set_regs_unavailable, mark_oprs_set): Likewise.\n\t* dce.c (deletable_insn_p, find_call_stack_args): Likewise.\n\t(remove_reg_equal_equiv_notes_for_defs): Likewise.\n\t(reset_unmarked_insns_debug_uses, mark_reg_dependencies): Likewise.\n\t(word_dce_process_block, dce_process_block): Likewise.\n\t* ddg.c (def_has_ccmode_p): Likewise.\n\t* df-core.c (df_bb_regno_first_def_find): Likewise.\n\t(df_bb_regno_last_def_find, df_find_def, df_find_use): Likewise.\n\t* df-problems.c (df_rd_simulate_one_insn): Likewise.\n\t(df_lr_bb_local_compute, df_live_bb_local_compute): Likewise.\n\t(df_chain_remove_problem, df_chain_insn_top_dump): Likewise.\n\t(df_chain_insn_bottom_dump, df_word_lr_bb_local_compute): Likewise.\n\t(df_word_lr_simulate_defs, df_word_lr_simulate_uses): Likewise.\n\t(df_remove_dead_eq_notes, df_note_bb_compute): Likewise.\n\t(df_simulate_find_defs, df_simulate_find_uses): Likewise.\n\t(df_simulate_find_noclobber_defs, df_simulate_defs): Likewise.\n\t(df_simulate_uses, df_md_simulate_one_insn): Likewise.\n\t* df-scan.c (df_reorganize_refs_by_reg_by_insn): Likewise.\n\t* fwprop.c (local_ref_killed_between_p): Likewise.\n\t(all_uses_available_at, free_load_extend): Likewise.\n\t* gcse.c (update_bb_reg_pressure, calculate_bb_reg_pressure): Likewise.\n\t* hw-doloop.c (scan_loop): Likewise.\n\t* ifcvt.c (dead_or_predicable): Likewise.\n\t* init-regs.c (initialize_uninitialized_regs): Likewise.\n\t* ira-lives.c (mark_hard_reg_early_clobbers): Likewise.\n\t(process_bb_node_lives): Likewise.\n\t* ira.c (compute_regs_asm_clobbered, build_insn_chain): Likewise.\n\t(find_moveable_pseudos): Likewise.\n\t* loop-invariant.c (check_dependencies, record_uses): Likewise.\n\t* recog.c (peep2_find_free_register): Likewise.\n\t* ree.c (get_defs): Likewise.\n\t* regstat.c (regstat_bb_compute_ri): Likewise.\n\t(regstat_bb_compute_calls_crossed): Likewise.\n\t* sched-deps.c (find_inc, find_mem): Likewise.\n\t* sel-sched-ir.c (maybe_downgrade_id_to_use): Likewise.\n\t(maybe_downgrade_id_to_use, setup_id_reg_sets): Likewise.\n\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n\t(prepare_shrink_wrap): Likewise.\n\t* store-motion.c (compute_store_table, build_store_vectors): Likewise.\n\t* web.c (union_defs, pass_web::execute): Likewise.\n\t* config/i386/i386.c (increase_distance, insn_defines_reg): Likewise.\n\t(insn_uses_reg_mem, ix86_ok_to_clobber_flags): Likewise.\n\nFrom-SVN: r211678", "tree": {"sha": "00fa07671c5adda4b362c1895d5e45e61ae0175b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00fa07671c5adda4b362c1895d5e45e61ae0175b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfac633a90588e96050f8767052d59efd7307cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfac633a90588e96050f8767052d59efd7307cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfac633a90588e96050f8767052d59efd7307cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfac633a90588e96050f8767052d59efd7307cb1/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c73339ae90070d7b33cb64a6d7461fbf676a53e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c73339ae90070d7b33cb64a6d7461fbf676a53e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c73339ae90070d7b33cb64a6d7461fbf676a53e"}], "stats": {"total": 1206, "additions": 540, "deletions": 666}, "files": [{"sha": "10d612adaacfe94aa61b0696c84763488f5027b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -1,3 +1,55 @@\n+2014-06-15  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* df.h (DF_INSN_INFO_MWS, FOR_EACH_INSN_INFO_DEF): New macros.\n+\t(FOR_EACH_INSN_INFO_USE, FOR_EACH_INSN_INFO_EQ_USE): Likewise.\n+\t(FOR_EACH_INSN_DEF, FOR_EACH_INSN_USE, FOR_EACH_INSN_EQ_USE): Likewise.\n+\t* auto-inc-dec.c (find_inc, merge_in_block): Use them.\n+\t* combine.c (create_log_links): Likewise.\n+\t* compare-elim.c (find_flags_uses_in_insn): Likewise.\n+\t(try_eliminate_compare): Likewise.\n+\t* cprop.c (make_set_regs_unavailable, mark_oprs_set): Likewise.\n+\t* dce.c (deletable_insn_p, find_call_stack_args): Likewise.\n+\t(remove_reg_equal_equiv_notes_for_defs): Likewise.\n+\t(reset_unmarked_insns_debug_uses, mark_reg_dependencies): Likewise.\n+\t(word_dce_process_block, dce_process_block): Likewise.\n+\t* ddg.c (def_has_ccmode_p): Likewise.\n+\t* df-core.c (df_bb_regno_first_def_find): Likewise.\n+\t(df_bb_regno_last_def_find, df_find_def, df_find_use): Likewise.\n+\t* df-problems.c (df_rd_simulate_one_insn): Likewise.\n+\t(df_lr_bb_local_compute, df_live_bb_local_compute): Likewise.\n+\t(df_chain_remove_problem, df_chain_insn_top_dump): Likewise.\n+\t(df_chain_insn_bottom_dump, df_word_lr_bb_local_compute): Likewise.\n+\t(df_word_lr_simulate_defs, df_word_lr_simulate_uses): Likewise.\n+\t(df_remove_dead_eq_notes, df_note_bb_compute): Likewise.\n+\t(df_simulate_find_defs, df_simulate_find_uses): Likewise.\n+\t(df_simulate_find_noclobber_defs, df_simulate_defs): Likewise.\n+\t(df_simulate_uses, df_md_simulate_one_insn): Likewise.\n+\t* df-scan.c (df_reorganize_refs_by_reg_by_insn): Likewise.\n+\t* fwprop.c (local_ref_killed_between_p): Likewise.\n+\t(all_uses_available_at, free_load_extend): Likewise.\n+\t* gcse.c (update_bb_reg_pressure, calculate_bb_reg_pressure): Likewise.\n+\t* hw-doloop.c (scan_loop): Likewise.\n+\t* ifcvt.c (dead_or_predicable): Likewise.\n+\t* init-regs.c (initialize_uninitialized_regs): Likewise.\n+\t* ira-lives.c (mark_hard_reg_early_clobbers): Likewise.\n+\t(process_bb_node_lives): Likewise.\n+\t* ira.c (compute_regs_asm_clobbered, build_insn_chain): Likewise.\n+\t(find_moveable_pseudos): Likewise.\n+\t* loop-invariant.c (check_dependencies, record_uses): Likewise.\n+\t* recog.c (peep2_find_free_register): Likewise.\n+\t* ree.c (get_defs): Likewise.\n+\t* regstat.c (regstat_bb_compute_ri): Likewise.\n+\t(regstat_bb_compute_calls_crossed): Likewise.\n+\t* sched-deps.c (find_inc, find_mem): Likewise.\n+\t* sel-sched-ir.c (maybe_downgrade_id_to_use): Likewise.\n+\t(maybe_downgrade_id_to_use, setup_id_reg_sets): Likewise.\n+\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n+\t(prepare_shrink_wrap): Likewise.\n+\t* store-motion.c (compute_store_table, build_store_vectors): Likewise.\n+\t* web.c (union_defs, pass_web::execute): Likewise.\n+\t* config/i386/i386.c (increase_distance, insn_defines_reg): Likewise.\n+\t(insn_uses_reg_mem, ix86_ok_to_clobber_flags): Likewise.\n+\n 2014-06-13  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-assign.c (assign_by_spills): Add code to assign vector regs"}, {"sha": "64a370655f6996eda3d7a9b6ce8141aa159ed816", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -969,7 +969,7 @@ find_inc (bool first_try)\n   rtx insn;\n   basic_block bb = BLOCK_FOR_INSN (mem_insn.insn);\n   rtx other_insn;\n-  df_ref *def_rec;\n+  df_ref def;\n \n   /* Make sure this reg appears only once in this insn.  */\n   if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg0, 1) != 1)\n@@ -1013,9 +1013,8 @@ find_inc (bool first_try)\n \n   /* Need to assure that none of the operands of the inc instruction are\n      assigned to by the mem insn.  */\n-  for (def_rec = DF_INSN_DEFS (mem_insn.insn); *def_rec; def_rec++)\n+  FOR_EACH_INSN_DEF (def, mem_insn.insn)\n     {\n-      df_ref def = *def_rec;\n       unsigned int regno = DF_REF_REGNO (def);\n       if ((regno == REGNO (inc_insn.reg0))\n \t  || (regno == REGNO (inc_insn.reg_res)))\n@@ -1342,7 +1341,7 @@ merge_in_block (int max_reg, basic_block bb)\n \n   FOR_BB_INSNS_REVERSE_SAFE (bb, insn, curr)\n     {\n-      unsigned int uid = INSN_UID (insn);\n+      df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       bool insn_is_add_or_inc = true;\n \n       if (!NONDEBUG_INSN_P (insn))\n@@ -1418,22 +1417,20 @@ merge_in_block (int max_reg, basic_block bb)\n \n       /* If the inc insn was merged with a mem, the inc insn is gone\n \t and there is noting to update.  */\n-      if (DF_INSN_UID_GET (uid))\n+      if (insn_info)\n \t{\n-\t  df_ref *def_rec;\n-\t  df_ref *use_rec;\n+\t  df_ref def, use;\n+\n \t  /* Need to update next use.  */\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t    {\n-\t      df_ref def = *def_rec;\n \t      reg_next_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_inc_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_def[DF_REF_REGNO (def)] = insn;\n \t    }\n \n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t    {\n-\t      df_ref use = *use_rec;\n \t      reg_next_use[DF_REF_REGNO (use)] = insn;\n \t      if (insn_is_add_or_inc)\n \t\treg_next_inc_use[DF_REF_REGNO (use)] = insn;"}, {"sha": "4e7ef55126e42638c63f5ffab92bad68d93edb55", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -985,7 +985,7 @@ create_log_links (void)\n {\n   basic_block bb;\n   rtx *next_use, insn;\n-  df_ref *def_vec, *use_vec;\n+  df_ref def, use;\n \n   next_use = XCNEWVEC (rtx, max_reg_num ());\n \n@@ -1008,9 +1008,8 @@ create_log_links (void)\n \t  /* Log links are created only once.  */\n \t  gcc_assert (!LOG_LINKS (insn));\n \n-          for (def_vec = DF_INSN_DEFS (insn); *def_vec; def_vec++)\n+\t  FOR_EACH_INSN_DEF (def, insn)\n             {\n-\t      df_ref def = *def_vec;\n               int regno = DF_REF_REGNO (def);\n               rtx use_insn;\n \n@@ -1061,9 +1060,8 @@ create_log_links (void)\n               next_use[regno] = NULL_RTX;\n             }\n \n-          for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n+\t  FOR_EACH_INSN_USE (use, insn)\n             {\n-\t      df_ref use = *use_vec;\n \t      int regno = DF_REF_REGNO (use);\n \n               /* Do not consider the usage of the stack pointer"}, {"sha": "2fbb75bd07f563e115198ed26803b4df995b2390", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -193,14 +193,14 @@ arithmetic_flags_clobber_p (rtx insn)\n static void\n find_flags_uses_in_insn (struct comparison *cmp, rtx insn)\n {\n-  df_ref *use_rec, use;\n+  df_ref use;\n \n   /* If we've already lost track of uses, don't bother collecting more.  */\n   if (cmp->missing_uses)\n     return;\n \n   /* Find a USE of the flags register.  */\n-  for (use_rec = DF_INSN_USES (insn); (use = *use_rec) != NULL; use_rec++)\n+  FOR_EACH_INSN_USE (use, insn)\n     if (DF_REF_REGNO (use) == targetm.flags_regnum)\n       {\n \trtx x, *loc;\n@@ -522,7 +522,7 @@ try_eliminate_compare (struct comparison *cmp)\n \t   | DF_REF_MUST_CLOBBER | DF_REF_SIGN_EXTRACT\n \t   | DF_REF_ZERO_EXTRACT | DF_REF_STRICT_LOW_PART\n \t   | DF_REF_PRE_POST_MODIFY);\n-      df_ref *def_rec, def;\n+      df_ref def;\n \n       /* Note that the BB_HEAD is always either a note or a label, but in\n \t any case it means that IN_A is defined outside the block.  */\n@@ -532,7 +532,7 @@ try_eliminate_compare (struct comparison *cmp)\n \tcontinue;\n \n       /* Find a possible def of IN_A in INSN.  */\n-      for (def_rec = DF_INSN_DEFS (insn); (def = *def_rec) != NULL; def_rec++)\n+      FOR_EACH_INSN_DEF (def, insn)\n \tif (DF_REF_REGNO (def) == REGNO (in_a))\n \t  break;\n "}, {"sha": "d46f5832ecad41be29258c3846f318b3791f70a8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -17764,19 +17764,18 @@ ix86_emit_cfi ()\n static unsigned int\n increase_distance (rtx prev, rtx next, unsigned int distance)\n {\n-  df_ref *use_rec;\n-  df_ref *def_rec;\n+  df_ref def, use;\n \n   if (!prev || !next)\n     return distance + (distance & 1) + 2;\n \n   if (!DF_INSN_USES (next) || !DF_INSN_DEFS (prev))\n     return distance + 1;\n \n-  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n-    for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n-      if (!DF_REF_IS_ARTIFICIAL (*def_rec)\n-\t  && DF_REF_REGNO (*use_rec) == DF_REF_REGNO (*def_rec))\n+  FOR_EACH_INSN_USE (use, next)\n+    FOR_EACH_INSN_DEF (def, prev)\n+      if (!DF_REF_IS_ARTIFICIAL (def)\n+\t  && DF_REF_REGNO (use) == DF_REF_REGNO (def))\n \treturn distance + (distance & 1) + 2;\n \n   return distance + 1;\n@@ -17789,16 +17788,14 @@ static bool\n insn_defines_reg (unsigned int regno1, unsigned int regno2,\n \t\t  rtx insn)\n {\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-    if (DF_REF_REG_DEF_P (*def_rec)\n-\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n-\t&& (regno1 == DF_REF_REGNO (*def_rec)\n-\t    || regno2 == DF_REF_REGNO (*def_rec)))\n-      {\n-\treturn true;\n-      }\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (DF_REF_REG_DEF_P (def)\n+\t&& !DF_REF_IS_ARTIFICIAL (def)\n+\t&& (regno1 == DF_REF_REGNO (def)\n+\t    || regno2 == DF_REF_REGNO (def)))\n+      return true;\n \n   return false;\n }\n@@ -17809,10 +17806,10 @@ insn_defines_reg (unsigned int regno1, unsigned int regno2,\n static bool\n insn_uses_reg_mem (unsigned int regno, rtx insn)\n {\n-  df_ref *use_rec;\n+  df_ref use;\n \n-  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-    if (DF_REF_REG_MEM_P (*use_rec) && regno == DF_REF_REGNO (*use_rec))\n+  FOR_EACH_INSN_USE (use, insn)\n+    if (DF_REF_REG_MEM_P (use) && regno == DF_REF_REGNO (use))\n       return true;\n \n   return false;\n@@ -18144,15 +18141,15 @@ static bool\n ix86_ok_to_clobber_flags (rtx insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n-  df_ref *use;\n+  df_ref use;\n   bitmap live;\n \n   while (insn)\n     {\n       if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  for (use = DF_INSN_USES (insn); *use; use++)\n-\t    if (DF_REF_REG_USE_P (*use) && DF_REF_REGNO (*use) == FLAGS_REG)\n+\t  FOR_EACH_INSN_USE (use, insn)\n+\t    if (DF_REF_REG_USE_P (use) && DF_REF_REGNO (use) == FLAGS_REG)\n \t      return false;\n \n \t  if (insn_defines_reg (FLAGS_REG, INVALID_REGNUM, insn))"}, {"sha": "d07bf31e7e2bf9481a646af56fa32e6b9105fbc0", "filename": "gcc/cprop.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -374,11 +374,10 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n static void\n make_set_regs_unavailable (rtx insn)\n {\n-  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n-    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n+  FOR_EACH_INSN_DEF (def, insn)\n+    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (def));\n }\n \n /* Top level function to create an assignment hash table.\n@@ -533,11 +532,10 @@ reg_not_set_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n static void\n mark_oprs_set (rtx insn)\n {\n-  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n-    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n+  FOR_EACH_INSN_DEF (def, insn)\n+    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (def));\n }\n \f\n /* Compute copy/constant propagation working variables.  */"}, {"sha": "252bc7a68e5f1e0bb50cbe3e53345761b56d35d6", "filename": "gcc/dce.c", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -96,6 +96,7 @@ deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n {\n   rtx body, x;\n   int i;\n+  df_ref def;\n \n   if (CALL_P (insn)\n       /* We cannot delete calls inside of the recursive dce because\n@@ -121,9 +122,9 @@ deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n     return false;\n \n   /* If INSN sets a global_reg, leave it untouched.  */\n-  for (df_ref *def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-    if (HARD_REGISTER_NUM_P (DF_REF_REGNO (*def_rec))\n-\t&& global_regs[DF_REF_REGNO (*def_rec)])\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (HARD_REGISTER_NUM_P (DF_REF_REGNO (def))\n+\t&& global_regs[DF_REF_REGNO (def)])\n       return false;\n \n   body = PATTERN (insn);\n@@ -305,18 +306,18 @@ find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n \t       sp + offset.  */\n \t    if (!fast)\n \t      {\n-\t\tdf_ref *use_rec;\n+\t\tdf_ref use;\n \t\tstruct df_link *defs;\n \t\trtx set;\n \n-\t\tfor (use_rec = DF_INSN_USES (call_insn); *use_rec; use_rec++)\n-\t\t  if (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t\tFOR_EACH_INSN_USE (use, call_insn)\n+\t\t  if (rtx_equal_p (addr, DF_REF_REG (use)))\n \t\t    break;\n \n-\t\tif (*use_rec == NULL)\n+\t\tif (use == NULL)\n \t\t  return false;\n \n-\t\tfor (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t\tfor (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n \t\t  if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n \t\t    break;\n \n@@ -364,15 +365,15 @@ find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n \t  }\n \tif (addr != stack_pointer_rtx)\n \t  {\n-\t    df_ref *use_rec;\n+\t    df_ref use;\n \t    struct df_link *defs;\n \t    rtx set;\n \n-\t    for (use_rec = DF_INSN_USES (call_insn); *use_rec; use_rec++)\n-\t      if (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t    FOR_EACH_INSN_USE (use, call_insn)\n+\t      if (rtx_equal_p (addr, DF_REF_REG (use)))\n \t\tbreak;\n \n-\t    for (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t    for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n \t      if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n \t\tbreak;\n \n@@ -429,18 +430,18 @@ find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n \t    break;\n \t  if (!fast)\n \t    {\n-\t      df_ref *use_rec;\n+\t      df_ref use;\n \t      struct df_link *defs;\n \t      rtx set;\n \n-\t      for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-\t\tif (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t      FOR_EACH_INSN_USE (use, insn)\n+\t\tif (rtx_equal_p (addr, DF_REF_REG (use)))\n \t\t  break;\n \n-\t      if (*use_rec == NULL)\n+\t      if (use == NULL)\n \t\tbreak;\n \n-\t      for (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n \t\tif (! DF_REF_IS_ARTIFICIAL (defs->ref))\n \t\t  break;\n \n@@ -496,10 +497,10 @@ find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n static void\n remove_reg_equal_equiv_notes_for_defs (rtx insn)\n {\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-    remove_reg_equal_equiv_notes_for_regno (DF_REF_REGNO (*def_rec));\n+  FOR_EACH_INSN_DEF (def, insn)\n+    remove_reg_equal_equiv_notes_for_regno (DF_REF_REGNO (def));\n }\n \n /* Scan all BBs for debug insns and reset those that reference values\n@@ -515,11 +516,10 @@ reset_unmarked_insns_debug_uses (void)\n     FOR_BB_INSNS_REVERSE_SAFE (bb, insn, next)\n       if (DEBUG_INSN_P (insn))\n \t{\n-\t  df_ref *use_rec;\n+\t  df_ref use;\n \n-\t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t  FOR_EACH_INSN_USE (use, insn)\n \t    {\n-\t      df_ref use = *use_rec;\n \t      struct df_link *defs;\n \t      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n \t\t{\n@@ -680,14 +680,13 @@ static void\n mark_reg_dependencies (rtx insn)\n {\n   struct df_link *defs;\n-  df_ref *use_rec;\n+  df_ref use;\n \n   if (DEBUG_INSN_P (insn))\n     return;\n \n-  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+  FOR_EACH_INSN_USE (use, insn)\n     {\n-      df_ref use = *use_rec;\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Processing use of \");\n@@ -868,14 +867,14 @@ word_dce_process_block (basic_block bb, bool redo_out,\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (DEBUG_INSN_P (insn))\n       {\n-\tdf_ref *use_rec;\n-\tfor (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-\t  if (DF_REF_REGNO (*use_rec) >= FIRST_PSEUDO_REGISTER\n-\t      && (GET_MODE_SIZE (GET_MODE (DF_REF_REAL_REG (*use_rec)))\n+\tdf_ref use;\n+\tFOR_EACH_INSN_USE (use, insn)\n+\t  if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER\n+\t      && (GET_MODE_SIZE (GET_MODE (DF_REF_REAL_REG (use)))\n \t\t  == 2 * UNITS_PER_WORD)\n-\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (*use_rec))\n-\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (*use_rec) + 1))\n-\t    dead_debug_add (&debug, *use_rec, DF_REF_REGNO (*use_rec));\n+\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (use))\n+\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (use) + 1))\n+\t    dead_debug_add (&debug, use, DF_REF_REGNO (use));\n       }\n     else if (INSN_P (insn))\n       {\n@@ -898,10 +897,10 @@ word_dce_process_block (basic_block bb, bool redo_out,\n \t   death.  */\n \tif (debug.used && !bitmap_empty_p (debug.used))\n \t  {\n-\t    df_ref *def_rec;\n+\t    df_ref def;\n \n-\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t      dead_debug_insert_temp (&debug, DF_REF_REGNO (*def_rec), insn,\n+\t    FOR_EACH_INSN_DEF (def, insn)\n+\t      dead_debug_insert_temp (&debug, DF_REF_REGNO (def), insn,\n \t\t\t\t      marked_insn_p (insn)\n \t\t\t\t      && !control_flow_insn_p (insn)\n \t\t\t\t      ? DEBUG_TEMP_AFTER_WITH_REG_FORCE\n@@ -939,7 +938,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au,\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n   rtx insn;\n   bool block_changed;\n-  df_ref *def_rec;\n+  df_ref def;\n   struct dead_debug_local debug;\n \n   if (redo_out)\n@@ -969,21 +968,21 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au,\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (DEBUG_INSN_P (insn))\n       {\n-\tdf_ref *use_rec;\n-\tfor (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-\t  if (!bitmap_bit_p (local_live, DF_REF_REGNO (*use_rec))\n-\t      && !bitmap_bit_p (au, DF_REF_REGNO (*use_rec)))\n-\t    dead_debug_add (&debug, *use_rec, DF_REF_REGNO (*use_rec));\n+\tdf_ref use;\n+\tFOR_EACH_INSN_USE (use, insn)\n+\t  if (!bitmap_bit_p (local_live, DF_REF_REGNO (use))\n+\t      && !bitmap_bit_p (au, DF_REF_REGNO (use)))\n+\t    dead_debug_add (&debug, use, DF_REF_REGNO (use));\n       }\n     else if (INSN_P (insn))\n       {\n \tbool needed = marked_insn_p (insn);\n \n \t/* The insn is needed if there is someone who uses the output.  */\n \tif (!needed)\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec))\n-\t\t|| bitmap_bit_p (au, DF_REF_REGNO (*def_rec)))\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (bitmap_bit_p (local_live, DF_REF_REGNO (def))\n+\t\t|| bitmap_bit_p (au, DF_REF_REGNO (def)))\n \t      {\n \t\tneeded = true;\n \t\tmark_insn (insn, true);\n@@ -1004,8 +1003,8 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au,\n \t   was marked, in case the debug use was after the point of\n \t   death.  */\n \tif (debug.used && !bitmap_empty_p (debug.used))\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    dead_debug_insert_temp (&debug, DF_REF_REGNO (*def_rec), insn,\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    dead_debug_insert_temp (&debug, DF_REF_REGNO (def), insn,\n \t\t\t\t    needed && !control_flow_insn_p (insn)\n \t\t\t\t    ? DEBUG_TEMP_AFTER_WITH_REG_FORCE\n \t\t\t\t    : DEBUG_TEMP_BEFORE_WITH_VALUE);"}, {"sha": "7ba6831647dd8642e3fc014a3d3c2d3ed3ce4ba8", "filename": "gcc/ddg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -169,11 +169,11 @@ autoinc_var_is_used_p (rtx def_insn, rtx use_insn)\n static bool\n def_has_ccmode_p (rtx insn)\n {\n-  df_ref *def;\n+  df_ref def;\n \n-  for (def = DF_INSN_DEFS (insn); *def; def++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      enum machine_mode mode = GET_MODE (DF_REF_REG (*def));\n+      enum machine_mode mode = GET_MODE (DF_REF_REG (def));\n \n       if (GET_MODE_CLASS (mode) == MODE_CC)\n \treturn true;"}, {"sha": "01d3beee9349c3e098f763352d27e9af408dc78e", "filename": "gcc/df-core.c", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -1947,21 +1947,16 @@ df_ref\n df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  df_ref *def_rec;\n-  unsigned int uid;\n+  df_ref def;\n \n   FOR_BB_INSNS (bb, insn)\n     {\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      uid = INSN_UID (insn);\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  if (DF_REF_REGNO (def) == regno)\n-\t    return def;\n-\t}\n+      FOR_EACH_INSN_DEF (def, insn)\n+\tif (DF_REF_REGNO (def) == regno)\n+\t  return def;\n     }\n   return NULL;\n }\n@@ -1973,21 +1968,16 @@ df_ref\n df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  df_ref *def_rec;\n-  unsigned int uid;\n+  df_ref def;\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      uid = INSN_UID (insn);\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  if (DF_REF_REGNO (def) == regno)\n-\t    return def;\n-\t}\n+      FOR_EACH_INSN_DEF (def, insn)\n+\tif (DF_REF_REGNO (def) == regno)\n+\t  return def;\n     }\n \n   return NULL;\n@@ -1999,20 +1989,15 @@ df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n df_ref\n df_find_def (rtx insn, rtx reg)\n {\n-  unsigned int uid;\n-  df_ref *def_rec;\n+  df_ref def;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n \n-  uid = INSN_UID (insn);\n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_REGNO (def) == REGNO (reg))\n-\treturn def;\n-    }\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (DF_REF_REGNO (def) == REGNO (reg))\n+      return def;\n \n   return NULL;\n }\n@@ -2033,27 +2018,20 @@ df_reg_defined (rtx insn, rtx reg)\n df_ref\n df_find_use (rtx insn, rtx reg)\n {\n-  unsigned int uid;\n-  df_ref *use_rec;\n+  df_ref use;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n \n-  uid = INSN_UID (insn);\n-  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n+  df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    if (DF_REF_REGNO (use) == REGNO (reg))\n+      return use;\n+  if (df->changeable_flags & DF_EQ_NOTES)\n+    FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n       if (DF_REF_REGNO (use) == REGNO (reg))\n \treturn use;\n-    }\n-  if (df->changeable_flags & DF_EQ_NOTES)\n-    for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-      {\n-\tdf_ref use = *use_rec;\n-\tif (DF_REF_REGNO (use) == REGNO (reg))\n-\t  return use;\n-      }\n   return NULL;\n }\n "}, {"sha": "d2fb13b49cf5f10462903afeec365e97944022b1", "filename": "gcc/df-problems.c", "status": "modified", "additions": 130, "deletions": 195, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -268,12 +268,10 @@ void\n df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n \t\t\t bitmap local_rd)\n {\n-  unsigned uid = INSN_UID (insn);\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      df_ref def = *def_rec;\n       unsigned int dregno = DF_REF_REGNO (def);\n       if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n           || (dregno >= FIRST_PSEUDO_REGISTER))\n@@ -838,6 +836,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  df_ref def, use;\n \n   /* Process the registers set in an exception handler.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n@@ -862,30 +861,23 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n-\n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  /* If the def is to only part of the reg, it does\n-\t     not kill the other defs that reach here.  */\n-\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    {\n-\t      unsigned int dregno = DF_REF_REGNO (def);\n-\t      bitmap_set_bit (&bb_info->def, dregno);\n-\t      bitmap_clear_bit (&bb_info->use, dregno);\n-\t    }\n-\t}\n+      df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t/* If the def is to only part of the reg, it does\n+\t   not kill the other defs that reach here.  */\n+\tif (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t  {\n+\t    unsigned int dregno = DF_REF_REGNO (def);\n+\t    bitmap_set_bit (&bb_info->def, dregno);\n+\t    bitmap_clear_bit (&bb_info->use, dregno);\n+\t  }\n \n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t{\n-\t  df_ref use = *use_rec;\n-\t  /* Add use to set of uses in this BB.  */\n-\t  bitmap_set_bit (&bb_info->use, DF_REF_REGNO (use));\n-\t}\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t/* Add use to set of uses in this BB.  */\n+\tbitmap_set_bit (&bb_info->use, DF_REF_REGNO (use));\n     }\n \n   /* Process the registers set in an exception handler or the hard\n@@ -1463,7 +1455,7 @@ df_live_bb_local_compute (unsigned int bb_index)\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n   struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n   rtx insn;\n-  df_ref *def_rec;\n+  df_ref def, *def_rec;\n   int luid = 0;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -1484,9 +1476,8 @@ df_live_bb_local_compute (unsigned int bb_index)\n \tcontinue;\n \n       luid++;\n-      for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t{\n-\t  df_ref def = *def_rec;\n \t  unsigned int regno = DF_REF_REGNO (def);\n \n \t  if (DF_REF_FLAGS_IS_SET (def,\n@@ -1985,6 +1976,7 @@ df_chain_remove_problem (void)\n       rtx insn;\n       df_ref *def_rec;\n       df_ref *use_rec;\n+      df_ref def, use;\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n \n       if (df_chain_problem_p (DF_DU_CHAIN))\n@@ -1995,23 +1987,20 @@ df_chain_remove_problem (void)\n \t  DF_REF_CHAIN (*use_rec) = NULL;\n \n       FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  unsigned int uid = INSN_UID (insn);\n-\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      if (df_chain_problem_p (DF_DU_CHAIN))\n-\t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t\t  DF_REF_CHAIN (*def_rec) = NULL;\n-\t      if (df_chain_problem_p (DF_UD_CHAIN))\n-\t\t{\n-\t\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t\t    DF_REF_CHAIN (*use_rec) = NULL;\n-\t\t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-\t\t    DF_REF_CHAIN (*use_rec) = NULL;\n-\t\t}\n-\t    }\n-\t}\n+\tif (INSN_P (insn))\n+\t  {\n+\t    df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t    if (df_chain_problem_p (DF_DU_CHAIN))\n+\t      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t\tDF_REF_CHAIN (def) = NULL;\n+\t    if (df_chain_problem_p (DF_UD_CHAIN))\n+\t      {\n+\t\tFOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t\t  DF_REF_CHAIN (use) = NULL;\n+\t\tFOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\t\t  DF_REF_CHAIN (use) = NULL;\n+\t      }\n+\t  }\n     }\n \n   bitmap_clear (df_chain->out_of_date_transfer_functions);\n@@ -2254,39 +2243,28 @@ df_chain_insn_top_dump (const_rtx insn, FILE *file)\n   if (df_chain_problem_p (DF_UD_CHAIN) && INSN_P (insn))\n     {\n       struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-      df_ref *use_rec = DF_INSN_INFO_USES (insn_info);\n-      df_ref *eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n+      df_ref use;\n+\n       fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\",\n \t       DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-      if (*use_rec || *eq_use_rec)\n-\t{\n-\t  while (*use_rec)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n-\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n-\t\t{\n-\t\t  fprintf (file, \";;      reg %d \", DF_REF_REGNO (use));\n-\t\t  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n-\t\t    fprintf (file, \"read/write \");\n-\t\t  df_chain_dump (DF_REF_CHAIN (use), file);\n-\t\t  fprintf (file, \"\\n\");\n-\t\t}\n-\t      use_rec++;\n-\t    }\n-\t  while (*eq_use_rec)\n-\t    {\n-\t      df_ref use = *eq_use_rec;\n-\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n-\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n-\t\t{\n-\t\t  fprintf (file, \";;   eq_note reg %d \", DF_REF_REGNO (use));\n-\t\t  df_chain_dump (DF_REF_CHAIN (use), file);\n-\t\t  fprintf (file, \"\\n\");\n-\t\t}\n-\t      eq_use_rec++;\n-\t    }\n-\t}\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\tif (!HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n+\t    || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t  {\n+\t    fprintf (file, \";;      reg %d \", DF_REF_REGNO (use));\n+\t    if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n+\t      fprintf (file, \"read/write \");\n+\t    df_chain_dump (DF_REF_CHAIN (use), file);\n+\t    fprintf (file, \"\\n\");\n+\t  }\n+      FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\tif (!HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n+\t    || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t  {\n+\t    fprintf (file, \";;   eq_note reg %d \", DF_REF_REGNO (use));\n+\t    df_chain_dump (DF_REF_CHAIN (use), file);\n+\t    fprintf (file, \"\\n\");\n+\t  }\n     }\n }\n \n@@ -2296,26 +2274,19 @@ df_chain_insn_bottom_dump (const_rtx insn, FILE *file)\n   if (df_chain_problem_p (DF_DU_CHAIN) && INSN_P (insn))\n     {\n       struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-      df_ref *def_rec = DF_INSN_INFO_DEFS (insn_info);\n+      df_ref def;\n       fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\",\n \t       DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-      if (*def_rec)\n-\t{\n-\t  while (*def_rec)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (def))\n-\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n-\t\t{\n-\t\t  fprintf (file, \";;      reg %d \", DF_REF_REGNO (def));\n-\t\t  if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n-\t\t    fprintf (file, \"read/write \");\n-\t\t  df_chain_dump (DF_REF_CHAIN (def), file);\n-\t\t  fprintf (file, \"\\n\");\n-\t\t}\n-\t      def_rec++;\n-\t    }\n-\t}\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\tif (!HARD_REGISTER_NUM_P (DF_REF_REGNO (def))\n+\t    || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t  {\n+\t    fprintf (file, \";;      reg %d \", DF_REF_REGNO (def));\n+\t    if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n+\t      fprintf (file, \"read/write \");\n+\t    df_chain_dump (DF_REF_CHAIN (def), file);\n+\t    fprintf (file, \"\\n\");\n+\t  }\n       fprintf (file, \"\\n\");\n     }\n }\n@@ -2534,6 +2505,7 @@ df_word_lr_bb_local_compute (unsigned int bb_index)\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  df_ref def, use;\n \n   /* Ensure that artificial refs don't contain references to pseudos.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n@@ -2550,26 +2522,20 @@ df_word_lr_bb_local_compute (unsigned int bb_index)\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n-\n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  /* If the def is to only part of the reg, it does\n-\t     not kill the other defs that reach here.  */\n-\t  if (!(DF_REF_FLAGS (def) & (DF_REF_CONDITIONAL)))\n-\t    {\n-\t      df_word_lr_mark_ref (def, true, &bb_info->def);\n-\t      df_word_lr_mark_ref (def, false, &bb_info->use);\n-\t    }\n-\t}\n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t{\n-\t  df_ref use = *use_rec;\n-\t  df_word_lr_mark_ref (use, true, &bb_info->use);\n-\t}\n+\n+      df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t/* If the def is to only part of the reg, it does\n+\t   not kill the other defs that reach here.  */\n+\tif (!(DF_REF_FLAGS (def) & (DF_REF_CONDITIONAL)))\n+\t  {\n+\t    df_word_lr_mark_ref (def, true, &bb_info->def);\n+\t    df_word_lr_mark_ref (def, false, &bb_info->use);\n+\t  }\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\tdf_word_lr_mark_ref (use, true, &bb_info->use);\n     }\n }\n \n@@ -2753,17 +2719,13 @@ bool\n df_word_lr_simulate_defs (rtx insn, bitmap live)\n {\n   bool changed = false;\n-  df_ref *def_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_CONDITIONAL)\n-\tchanged = true;\n-      else\n-\tchanged |= df_word_lr_mark_ref (*def_rec, false, live);\n-    }\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (DF_REF_FLAGS (def) & DF_REF_CONDITIONAL)\n+      changed = true;\n+    else\n+      changed |= df_word_lr_mark_ref (def, false, live);\n   return changed;\n }\n \n@@ -2773,11 +2735,10 @@ df_word_lr_simulate_defs (rtx insn, bitmap live)\n void\n df_word_lr_simulate_uses (rtx insn, bitmap live)\n {\n-  df_ref *use_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref use;\n \n-  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-    df_word_lr_mark_ref (*use_rec, true, live);\n+  FOR_EACH_INSN_USE (use, insn)\n+    df_word_lr_mark_ref (use, true, live);\n }\n \f\n /*----------------------------------------------------------------------------\n@@ -2899,22 +2860,19 @@ df_remove_dead_eq_notes (rtx insn, bitmap live)\n \t       one REG_EQUAL/EQUIV note, all of EQ_USES will refer to this note\n \t       so we need to purge the complete EQ_USES vector when removing\n \t       the note using df_notes_rescan.  */\n-\t    df_ref *use_rec;\n+\t    df_ref use;\n \t    bool deleted = false;\n \n-\t    for (use_rec = DF_INSN_EQ_USES (insn); *use_rec; use_rec++)\n-\t      {\n-\t\tdf_ref use = *use_rec;\n-\t\tif (DF_REF_REGNO (use) > FIRST_PSEUDO_REGISTER\n-\t\t    && DF_REF_LOC (use)\n-\t\t    && (DF_REF_FLAGS (use) & DF_REF_IN_NOTE)\n-\t\t    && ! bitmap_bit_p (live, DF_REF_REGNO (use))\n-\t\t    && loc_mentioned_in_p (DF_REF_LOC (use), XEXP (link, 0)))\n-\t\t  {\n-\t\t    deleted = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n+\t    FOR_EACH_INSN_EQ_USE (use, insn)\n+\t      if (DF_REF_REGNO (use) > FIRST_PSEUDO_REGISTER\n+\t\t  && DF_REF_LOC (use)\n+\t\t  && (DF_REF_FLAGS (use) & DF_REF_IN_NOTE)\n+\t\t  && !bitmap_bit_p (live, DF_REF_REGNO (use))\n+\t\t  && loc_mentioned_in_p (DF_REF_LOC (use), XEXP (link, 0)))\n+\t\t{\n+\t\t  deleted = true;\n+\t\t  break;\n+\t\t}\n \t    if (deleted)\n \t      {\n \t\trtx next;\n@@ -3156,6 +3114,7 @@ df_note_bb_compute (unsigned int bb_index,\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  df_ref def, use;\n   struct dead_debug_local debug;\n \n   dead_debug_local_init (&debug, NULL, NULL);\n@@ -3204,7 +3163,7 @@ df_note_bb_compute (unsigned int bb_index,\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n+      df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       struct df_mw_hardreg **mws_rec;\n       int debug_insn;\n \n@@ -3221,13 +3180,14 @@ df_note_bb_compute (unsigned int bb_index,\n \t{\n \t  if (REG_DEAD_DEBUGGING && dump_file)\n \t    {\n-\t      fprintf (dump_file, \"processing call %d\\n  live =\", INSN_UID (insn));\n+\t      fprintf (dump_file, \"processing call %d\\n  live =\",\n+\t\t       INSN_UID (insn));\n \t      df_print_regset (dump_file, live);\n \t    }\n \n \t  /* We only care about real sets for calls.  Clobbers cannot\n \t     be depended on to really die.  */\n-\t  mws_rec = DF_INSN_UID_MWS (uid);\n+\t  mws_rec = DF_INSN_INFO_MWS (insn_info);\n \t  while (*mws_rec)\n \t    {\n \t      struct df_mw_hardreg *mws = *mws_rec;\n@@ -3241,9 +3201,8 @@ df_note_bb_compute (unsigned int bb_index,\n \n \t  /* All of the defs except the return value are some sort of\n \t     clobber.  This code is for the return.  */\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t    {\n-\t      df_ref def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n \t\t{\n@@ -3259,7 +3218,7 @@ df_note_bb_compute (unsigned int bb_index,\n       else\n \t{\n \t  /* Regular insn.  */\n-\t  mws_rec = DF_INSN_UID_MWS (uid);\n+\t  mws_rec = DF_INSN_INFO_MWS (insn_info);\n \t  while (*mws_rec)\n \t    {\n \t      struct df_mw_hardreg *mws = *mws_rec;\n@@ -3270,9 +3229,8 @@ df_note_bb_compute (unsigned int bb_index,\n \t      mws_rec++;\n \t    }\n \n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t    {\n-\t      df_ref def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      df_create_unused_note (insn,\n \t\t\t\t     def, live, artificial_uses, &debug);\n@@ -3286,7 +3244,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t}\n \n       /* Process the uses.  */\n-      mws_rec = DF_INSN_UID_MWS (uid);\n+      mws_rec = DF_INSN_INFO_MWS (insn_info);\n       while (*mws_rec)\n \t{\n \t  struct df_mw_hardreg *mws = *mws_rec;\n@@ -3306,9 +3264,8 @@ df_note_bb_compute (unsigned int bb_index,\n \t  mws_rec++;\n \t}\n \n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t{\n-\t  df_ref use = *use_rec;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n \t  if (REG_DEAD_DEBUGGING && dump_file && !debug_insn)\n@@ -3475,51 +3432,37 @@ df_note_add_problem (void)\n void\n df_simulate_find_defs (rtx insn, bitmap defs)\n {\n-  df_ref *def_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      bitmap_set_bit (defs, DF_REF_REGNO (def));\n-    }\n+  FOR_EACH_INSN_DEF (def, insn)\n+    bitmap_set_bit (defs, DF_REF_REGNO (def));\n }\n \n /* Find the set of uses for INSN.  This includes partial defs.  */\n \n static void\n df_simulate_find_uses (rtx insn, bitmap uses)\n {\n-  df_ref *rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref def, use;\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \n-  for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n-    {\n-      df_ref def = *rec;\n-      if (DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n-\tbitmap_set_bit (uses, DF_REF_REGNO (def));\n-    }\n-  for (rec = DF_INSN_UID_USES (uid); *rec; rec++)\n-    {\n-      df_ref use = *rec;\n-      bitmap_set_bit (uses, DF_REF_REGNO (use));\n-    }\n+  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+    if (DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n+      bitmap_set_bit (uses, DF_REF_REGNO (def));\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    bitmap_set_bit (uses, DF_REF_REGNO (use));\n }\n \n /* Find the set of real DEFs, which are not clobbers, for INSN.  */\n \n void\n df_simulate_find_noclobber_defs (rtx insn, bitmap defs)\n {\n-  df_ref *def_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n-\tbitmap_set_bit (defs, DF_REF_REGNO (def));\n-    }\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n+      bitmap_set_bit (defs, DF_REF_REGNO (def));\n }\n \n \n@@ -3528,12 +3471,10 @@ df_simulate_find_noclobber_defs (rtx insn, bitmap defs)\n void\n df_simulate_defs (rtx insn, bitmap live)\n {\n-  df_ref *def_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      df_ref def = *def_rec;\n       unsigned int dregno = DF_REF_REGNO (def);\n \n       /* If the def is to only part of the reg, it does\n@@ -3549,18 +3490,14 @@ df_simulate_defs (rtx insn, bitmap live)\n void\n df_simulate_uses (rtx insn, bitmap live)\n {\n-  df_ref *use_rec;\n-  unsigned int uid = INSN_UID (insn);\n+  df_ref use;\n \n   if (DEBUG_INSN_P (insn))\n     return;\n \n-  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n-      /* Add use to set of uses in this BB.  */\n-      bitmap_set_bit (live, DF_REF_REGNO (use));\n-    }\n+  FOR_EACH_INSN_USE (use, insn)\n+    /* Add use to set of uses in this BB.  */\n+    bitmap_set_bit (live, DF_REF_REGNO (use));\n }\n \n \n@@ -4206,14 +4143,12 @@ df_md_simulate_artificial_defs_at_top (basic_block bb, bitmap local_md)\n \n void\n df_md_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n-                        bitmap local_md)\n+\t\t\t bitmap local_md)\n {\n-  unsigned uid = INSN_UID (insn);\n-  df_ref *def_rec;\n+  df_ref def;\n \n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      df_ref def = *def_rec;\n       unsigned int dregno = DF_REF_REGNO (def);\n       if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n           || (dregno >= FIRST_PSEUDO_REGISTER))"}, {"sha": "d4dc48de864424cb22d9feb247cc34c44940be36", "filename": "gcc/df-scan.c", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -1640,6 +1640,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n       rtx insn;\n       df_ref *ref_rec;\n+      df_ref def, use;\n \n       if (include_defs)\n \tfor (ref_rec = df_get_artificial_defs (bb_index); *ref_rec; ref_rec++)\n@@ -1658,24 +1659,24 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t{\n \t  if (INSN_P (insn))\n \t    {\n-\t      unsigned int uid = INSN_UID (insn);\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \n \t      if (include_defs)\n-\t\tfor (ref_rec = DF_INSN_UID_DEFS (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t\t  {\n-\t\t    unsigned int regno = DF_REF_REGNO (*ref_rec);\n+\t\t    unsigned int regno = DF_REF_REGNO (def);\n \t\t    ref_info->count[regno]++;\n \t\t  }\n \t      if (include_uses)\n-\t\tfor (ref_rec = DF_INSN_UID_USES (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_USE (use, insn_info)\n \t\t  {\n-\t\t    unsigned int regno = DF_REF_REGNO (*ref_rec);\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    ref_info->count[regno]++;\n \t\t  }\n \t      if (include_eq_uses)\n-\t\tfor (ref_rec = DF_INSN_UID_EQ_USES (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n \t\t  {\n-\t\t    unsigned int regno = DF_REF_REGNO (*ref_rec);\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    ref_info->count[regno]++;\n \t\t  }\n \t    }\n@@ -1694,6 +1695,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n       rtx insn;\n       df_ref *ref_rec;\n+      df_ref def, use;\n \n       if (include_defs)\n \tfor (ref_rec = df_get_artificial_defs (bb_index); *ref_rec; ref_rec++)\n@@ -1726,45 +1728,42 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t{\n \t  if (INSN_P (insn))\n \t    {\n-\t      unsigned int uid = INSN_UID (insn);\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \n \t      if (include_defs)\n-\t\tfor (ref_rec = DF_INSN_UID_DEFS (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t\t  {\n-\t\t    df_ref ref = *ref_rec;\n-\t\t    unsigned int regno = DF_REF_REGNO (ref);\n+\t\t    unsigned int regno = DF_REF_REGNO (def);\n \t\t    if (regno >= start)\n \t\t      {\n \t\t\tunsigned int id\n \t\t\t  = ref_info->begin[regno] + ref_info->count[regno]++;\n-\t\t\tDF_REF_ID (ref) = id;\n-\t\t\tref_info->refs[id] = ref;\n+\t\t\tDF_REF_ID (def) = id;\n+\t\t\tref_info->refs[id] = def;\n \t\t      }\n \t\t  }\n \t      if (include_uses)\n-\t\tfor (ref_rec = DF_INSN_UID_USES (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_USE (use, insn_info)\n \t\t  {\n-\t\t    df_ref ref = *ref_rec;\n-\t\t    unsigned int regno = DF_REF_REGNO (ref);\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    if (regno >= start)\n \t\t      {\n \t\t\tunsigned int id\n \t\t\t  = ref_info->begin[regno] + ref_info->count[regno]++;\n-\t\t\tDF_REF_ID (ref) = id;\n-\t\t\tref_info->refs[id] = ref;\n+\t\t\tDF_REF_ID (use) = id;\n+\t\t\tref_info->refs[id] = use;\n \t\t      }\n \t\t  }\n \t      if (include_eq_uses)\n-\t\tfor (ref_rec = DF_INSN_UID_EQ_USES (uid); *ref_rec; ref_rec++)\n+\t\tFOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n \t\t  {\n-\t\t    df_ref ref = *ref_rec;\n-\t\t    unsigned int regno = DF_REF_REGNO (ref);\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    if (regno >= start)\n \t\t      {\n \t\t\tunsigned int id\n \t\t\t  = ref_info->begin[regno] + ref_info->count[regno]++;\n-\t\t\tDF_REF_ID (ref) = id;\n-\t\t\tref_info->refs[id] = ref;\n+\t\t\tDF_REF_ID (use) = id;\n+\t\t\tref_info->refs[id] = use;\n \t\t      }\n \t\t  }\n \t    }"}, {"sha": "809175c62a431b84664ebd68f9283d33b87e556f", "filename": "gcc/df.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -736,6 +736,7 @@ struct df_d\n #define DF_INSN_INFO_DEFS(II) ((II)->defs)\n #define DF_INSN_INFO_USES(II) ((II)->uses)\n #define DF_INSN_INFO_EQ_USES(II) ((II)->eq_uses)\n+#define DF_INSN_INFO_MWS(II) ((II)->mw_hardregs)\n \n #define DF_INSN_LUID(INSN) (DF_INSN_INFO_LUID (DF_INSN_INFO_GET (INSN)))\n #define DF_INSN_DEFS(INSN) (DF_INSN_INFO_DEFS (DF_INSN_INFO_GET (INSN)))\n@@ -753,6 +754,27 @@ struct df_d\n #define DF_INSN_UID_EQ_USES(INSN) (DF_INSN_UID_GET (INSN)->eq_uses)\n #define DF_INSN_UID_MWS(INSN) (DF_INSN_UID_GET (INSN)->mw_hardregs)\n \n+#define FOR_EACH_INSN_INFO_DEF(ITER, INSN) \\\n+  for (df_ref *ITER##_ = DF_INSN_INFO_DEFS (INSN); (ITER = *ITER##_); \\\n+       ++ITER##_)\n+\n+#define FOR_EACH_INSN_INFO_USE(ITER, INSN) \\\n+  for (df_ref *ITER##_ = DF_INSN_INFO_USES (INSN); (ITER = *ITER##_); \\\n+       ++ITER##_)\n+\n+#define FOR_EACH_INSN_INFO_EQ_USE(ITER, INSN) \\\n+  for (df_ref *ITER##_ = DF_INSN_INFO_EQ_USES (INSN); (ITER = *ITER##_); \\\n+       ++ITER##_)\n+\n+#define FOR_EACH_INSN_DEF(ITER, INSN) \\\n+  FOR_EACH_INSN_INFO_DEF(ITER, DF_INSN_INFO_GET (INSN))\n+\n+#define FOR_EACH_INSN_USE(ITER, INSN) \\\n+  FOR_EACH_INSN_INFO_USE(ITER, DF_INSN_INFO_GET (INSN))\n+\n+#define FOR_EACH_INSN_EQ_USE(ITER, INSN) \\\n+  FOR_EACH_INSN_INFO_EQ_USE(ITER, DF_INSN_INFO_GET (INSN))\n+\n /* An obstack for bitmap not related to specific dataflow problems.\n    This obstack should e.g. be used for bitmaps with a short life time\n    such as temporary bitmaps.  This obstack is declared in df-core.c.  */"}, {"sha": "eb21d02e36fe37dc51c6411c0419b620fd14375e", "filename": "gcc/fwprop.c", "status": "modified", "additions": 19, "deletions": 35, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -700,16 +700,13 @@ local_ref_killed_between_p (df_ref ref, rtx from, rtx to)\n \n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n     {\n-      df_ref *def_rec;\n+      df_ref def;\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  if (DF_REF_REGNO (ref) == DF_REF_REGNO (def))\n-\t    return true;\n-\t}\n+      FOR_EACH_INSN_DEF (def, insn)\n+\tif (DF_REF_REGNO (ref) == DF_REF_REGNO (def))\n+\t  return true;\n     }\n   return false;\n }\n@@ -790,7 +787,7 @@ use_killed_between (df_ref use, rtx def_insn, rtx target_insn)\n static bool\n all_uses_available_at (rtx def_insn, rtx target_insn)\n {\n-  df_ref *use_rec;\n+  df_ref use;\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n   rtx def_set = single_set (def_insn);\n   rtx next;\n@@ -809,36 +806,28 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n \n       /* If the insn uses the reg that it defines, the substitution is\n          invalid.  */\n-      for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n-\t{\n-\t  df_ref use = *use_rec;\n-\t  if (rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t    return false;\n-\t}\n-      for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n-\t{\n-\t  df_ref use = *use_rec;\n-\t  if (rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t    return false;\n-\t}\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\tif (rtx_equal_p (DF_REF_REG (use), def_reg))\n+\t  return false;\n+      FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\tif (rtx_equal_p (DF_REF_REG (use), def_reg))\n+\t  return false;\n     }\n   else\n     {\n       rtx def_reg = REG_P (SET_DEST (def_set)) ? SET_DEST (def_set) : NULL_RTX;\n \n       /* Look at all the uses of DEF_INSN, and see if they are not\n \t killed between DEF_INSN and TARGET_INSN.  */\n-      for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t{\n-\t  df_ref use = *use_rec;\n \t  if (def_reg && rtx_equal_p (DF_REF_REG (use), def_reg))\n \t    return false;\n \t  if (use_killed_between (use, def_insn, target_insn))\n \t    return false;\n \t}\n-      for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n+      FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n \t{\n-\t  df_ref use = *use_rec;\n \t  if (def_reg && rtx_equal_p (DF_REF_REG (use), def_reg))\n \t    return false;\n \t  if (use_killed_between (use, def_insn, target_insn))\n@@ -1034,24 +1023,19 @@ static bool\n free_load_extend (rtx src, rtx insn)\n {\n   rtx reg;\n-  df_ref *use_vec;\n-  df_ref use = 0, def;\n+  df_ref def, use;\n \n   reg = XEXP (src, 0);\n #ifdef LOAD_EXTEND_OP\n   if (LOAD_EXTEND_OP (GET_MODE (reg)) != GET_CODE (src))\n #endif\n     return false;\n \n-  for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n-    {\n-      use = *use_vec;\n-\n-      if (!DF_REF_IS_ARTIFICIAL (use)\n-\t  && DF_REF_TYPE (use) == DF_REF_REG_USE\n-\t  && DF_REF_REG (use) == reg)\n-\tbreak;\n-    }\n+  FOR_EACH_INSN_USE (use, insn)\n+    if (!DF_REF_IS_ARTIFICIAL (use)\n+\t&& DF_REF_TYPE (use) == DF_REF_REG_USE\n+\t&& DF_REF_REG (use) == reg)\n+      break;\n   if (!use)\n     return false;\n "}, {"sha": "8de596d2fac2176103dbe00fda329cbfa8a53065", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -2961,16 +2961,16 @@ update_bb_reg_pressure (basic_block bb, rtx from)\n {\n   rtx dreg, insn;\n   basic_block succ_bb;\n-  df_ref *op, op_ref;\n+  df_ref use, op_ref;\n   edge succ;\n   edge_iterator ei;\n   int decreased_pressure = 0;\n   int nregs;\n   enum reg_class pressure_class;\n-  \n-  for (op = DF_INSN_USES (from); *op; op++)\n+\n+  FOR_EACH_INSN_USE (use, from)\n     {\n-      dreg = DF_REF_REAL_REG (*op);\n+      dreg = DF_REF_REAL_REG (use);\n       /* The live range of register is shrunk only if it isn't:\n \t 1. referred on any path from the end of this block to EXIT, or\n \t 2. referred by insns other than FROM in this block.  */\n@@ -3593,27 +3593,27 @@ calculate_bb_reg_pressure (void)\n \t{\n \t  rtx dreg;\n \t  int regno;\n-\t  df_ref *def_rec, *use_rec;\n+\t  df_ref def, use;\n \n \t  if (! NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t  FOR_EACH_INSN_DEF (def, insn)\n \t    {\n-\t      dreg = DF_REF_REAL_REG (*def_rec);\n+\t      dreg = DF_REF_REAL_REG (def);\n \t      gcc_assert (REG_P (dreg));\n \t      regno = REGNO (dreg);\n-\t      if (!(DF_REF_FLAGS (*def_rec) \n+\t      if (!(DF_REF_FLAGS (def)\n \t\t    & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n \t\t{\n \t\t  if (bitmap_clear_bit (curr_regs_live, regno))\n \t\t    change_pressure (regno, false);\n \t\t}\n \t    }\n \n-\t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t  FOR_EACH_INSN_USE (use, insn)\n \t    {\n-\t      dreg = DF_REF_REAL_REG (*use_rec);\n+\t      dreg = DF_REF_REAL_REG (use);\n \t      gcc_assert (REG_P (dreg));\n \t      regno = REGNO (dreg);\n \t      if (bitmap_set_bit (curr_regs_live, regno))"}, {"sha": "9ab7e65db5f4d728bc51049740c43dd0e77bd7a6", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -119,7 +119,7 @@ scan_loop (hwloop_info loop)\n \t   insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n-\t  df_ref *def_rec;\n+\t  df_ref def;\n \t  HARD_REG_SET set_this_insn;\n \n \t  if (!NONDEBUG_INSN_P (insn))\n@@ -131,9 +131,9 @@ scan_loop (hwloop_info loop)\n \t    loop->has_asm = true;\n \n \t  CLEAR_HARD_REG_SET (set_this_insn);\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t  FOR_EACH_INSN_DEF (def, insn)\n \t    {\n-\t      rtx dreg = DF_REF_REG (*def_rec);\n+\t      rtx dreg = DF_REF_REG (def);\n \n \t      if (!REG_P (dreg))\n \t\tcontinue;"}, {"sha": "816cdaa2a07ed792a290649d31bbe683bc090db4", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -4279,22 +4279,16 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t      FOR_BB_INSNS_REVERSE (new_dest, insn)\n \t\tif (NONDEBUG_INSN_P (insn))\n \t\t  {\n-\t\t    df_ref *def_rec;\n-\t\t    unsigned int uid = INSN_UID (insn);\n-\n-\t\t    /* If this insn sets any reg in return_regs..  */\n-\t\t    for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t\t      {\n-\t\t\tdf_ref def = *def_rec;\n-\t\t\tunsigned r = DF_REF_REGNO (def);\n-\n-\t\t\tif (bitmap_bit_p (return_regs, r))\n+\t\t    df_ref def;\n+\n+\t\t    /* If this insn sets any reg in return_regs, add all\n+\t\t       reg uses to the set of regs we're interested in.  */\n+\t\t    FOR_EACH_INSN_DEF (def, insn)\n+\t\t      if (bitmap_bit_p (return_regs, DF_REF_REGNO (def)))\n+\t\t\t{\n+\t\t\t  df_simulate_uses (insn, return_regs);\n \t\t\t  break;\n-\t\t      }\n-\t\t    /* ..then add all reg uses to the set of regs\n-\t\t       we're interested in.  */\n-\t\t    if (*def_rec)\n-\t\t      df_simulate_uses (insn, return_regs);\n+\t\t\t}\n \t\t  }\n \t      if (bitmap_intersect_p (merge_set, return_regs))\n \t\t{"}, {"sha": "4080d0f91f353ac1f88105b78ae85e526301014a", "filename": "gcc/init-regs.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -68,14 +68,12 @@ initialize_uninitialized_regs (void)\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  unsigned int uid = INSN_UID (insn);\n-\t  df_ref *use_rec;\n+\t  df_ref use;\n \t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t  FOR_EACH_INSN_USE (use, insn)\n \t    {\n-\t      df_ref use = *use_rec;\n \t      unsigned int regno = DF_REF_REGNO (use);\n \n \t      /* Only do this for the pseudos.  */\n@@ -109,7 +107,8 @@ initialize_uninitialized_regs (void)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"adding initialization in %s of reg %d at in block %d for insn %d.\\n\",\n-\t\t\t     current_function_name (), regno, bb->index, uid);\n+\t\t\t     current_function_name (), regno, bb->index,\n+\t\t\t     INSN_UID (insn));\n \t\t}\n \t    }\n \t}"}, {"sha": "ec8f679bcee5d636af858bf58de791f7e006d94b", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -725,13 +725,13 @@ make_early_clobber_and_input_conflicts (void)\n static bool\n mark_hard_reg_early_clobbers (rtx insn, bool live_p)\n {\n-  df_ref *def_rec;\n+  df_ref def;\n   bool set_p = false;\n \n-  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-    if (DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MUST_CLOBBER))\n+  FOR_EACH_INSN_DEF (def, insn)\n+    if (DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER))\n       {\n-\trtx dreg = DF_REF_REG (*def_rec);\n+\trtx dreg = DF_REF_REG (def);\n \n \tif (GET_CODE (dreg) == SUBREG)\n \t  dreg = SUBREG_REG (dreg);\n@@ -742,9 +742,9 @@ mark_hard_reg_early_clobbers (rtx insn, bool live_p)\n \t   because there is no way to say that non-operand hard\n \t   register clobbers are not early ones.  */\n \tif (live_p)\n-\t  mark_ref_live (*def_rec);\n+\t  mark_ref_live (def);\n \telse\n-\t  mark_ref_dead (*def_rec);\n+\t  mark_ref_dead (def);\n \tset_p = true;\n       }\n \n@@ -1114,7 +1114,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t pessimistic, but it probably doesn't matter much in practice.  */\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  df_ref *def_rec, *use_rec;\n+\t  df_ref def, use;\n \t  bool call_p;\n \n \t  if (!NONDEBUG_INSN_P (insn))\n@@ -1135,9 +1135,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t     live would stop us from allocating it to a call-crossing\n \t     allocno.  */\n \t  call_p = CALL_P (insn);\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (!call_p || !DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MAY_CLOBBER))\n-\t      mark_ref_live (*def_rec);\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (!call_p || !DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t      mark_ref_live (def);\n \n \t  /* If INSN has multiple outputs, then any value used in one\n \t     of the outputs conflicts with the other outputs.  Model this\n@@ -1151,12 +1151,12 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t     to the same hard register as an unused output we could\n \t     set the hard register before the output reload insn.  */\n \t  if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n-\t    for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t    FOR_EACH_INSN_USE (use, insn)\n \t      {\n \t\tint i;\n \t\trtx reg;\n \n-\t\treg = DF_REF_REG (*use_rec);\n+\t\treg = DF_REF_REG (use);\n \t\tfor (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n \t\t  {\n \t\t    rtx set;\n@@ -1167,7 +1167,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t      {\n \t\t\t/* After the previous loop, this is a no-op if\n \t\t\t   REG is contained within SET_DEST (SET).  */\n-\t\t\tmark_ref_live (*use_rec);\n+\t\t\tmark_ref_live (use);\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -1178,9 +1178,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  process_single_reg_class_operands (false, freq);\n \n \t  /* See which defined values die here.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (!call_p || !DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MAY_CLOBBER))\n-\t      mark_ref_dead (*def_rec);\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (!call_p || !DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t      mark_ref_dead (def);\n \n \t  if (call_p)\n \t    {\n@@ -1249,8 +1249,8 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  curr_point++;\n \n \t  /* Mark each used value as live.  */\n-\t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-\t    mark_ref_live (*use_rec);\n+\t  FOR_EACH_INSN_USE (use, insn)\n+\t    mark_ref_live (use);\n \n \t  process_single_reg_class_operands (true, freq);\n \n@@ -1263,16 +1263,16 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      /* Mark each hard reg as live again.  For example, a\n \t\t hard register can be in clobber and in an insn\n \t\t input.  */\n-\t      for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t      FOR_EACH_INSN_USE (use, insn)\n \t\t{\n-\t\t  rtx ureg = DF_REF_REG (*use_rec);\n+\t\t  rtx ureg = DF_REF_REG (use);\n \n \t\t  if (GET_CODE (ureg) == SUBREG)\n \t\t    ureg = SUBREG_REG (ureg);\n \t\t  if (! REG_P (ureg) || REGNO (ureg) >= FIRST_PSEUDO_REGISTER)\n \t\t    continue;\n \n-\t\t  mark_ref_live (*use_rec);\n+\t\t  mark_ref_live (use);\n \t\t}\n \t    }\n "}, {"sha": "bbb20562b10764ac96206fffc0f422dc763ad4c8", "filename": "gcc/ira.c", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -2251,12 +2251,11 @@ compute_regs_asm_clobbered (void)\n       rtx insn;\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  df_ref *def_rec;\n+\t  df_ref def;\n \n \t  if (insn_contains_asm (insn))\n-\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    FOR_EACH_INSN_DEF (def, insn)\n \t      {\n-\t\tdf_ref def = *def_rec;\n \t\tunsigned int dregno = DF_REF_REGNO (def);\n \t\tif (HARD_REGISTER_NUM_P (dregno))\n \t\t  add_to_hard_reg_set (&crtl->asm_clobbers,\n@@ -4041,9 +4040,8 @@ build_insn_chain (void)\n \t{\n \t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n \t    {\n-\t      unsigned int uid = INSN_UID (insn);\n-\t      df_ref *def_rec;\n-\t      df_ref *use_rec;\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t      df_ref def, use;\n \n \t      c = new_insn_chain ();\n \t      c->next = next;\n@@ -4055,9 +4053,8 @@ build_insn_chain (void)\n \t      c->block = bb->index;\n \n \t      if (NONDEBUG_INSN_P (insn))\n-\t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t\tFOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t\t  {\n-\t\t    df_ref def = *def_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (def);\n \n \t\t    /* Ignore may clobbers because these are generated\n@@ -4146,9 +4143,8 @@ build_insn_chain (void)\n \t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n \n \t      if (NONDEBUG_INSN_P (insn))\n-\t\tfor (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t\tFOR_EACH_INSN_INFO_USE (use, insn_info)\n \t\t  {\n-\t\t    df_ref use = *use_rec;\n \t\t    unsigned int regno = DF_REF_REGNO (use);\n \t\t    rtx reg = DF_REF_REG (use);\n \n@@ -4440,12 +4436,14 @@ find_moveable_pseudos (void)\n       FOR_BB_INSNS (bb, insn)\n \tif (NONDEBUG_INSN_P (insn))\n \t  {\n+\t    df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \t    df_ref *u_rec, *d_rec;\n+\t    df_ref def, use;\n \n \t    uid_luid[INSN_UID (insn)] = i++;\n \t    \n-\t    u_rec = DF_INSN_USES (insn);\n-\t    d_rec = DF_INSN_DEFS (insn);\n+\t    u_rec = DF_INSN_INFO_USES (insn_info);\n+\t    d_rec = DF_INSN_INFO_DEFS (insn_info);\n \t    if (d_rec[0] != NULL && d_rec[1] == NULL\n \t\t&& u_rec[0] != NULL && u_rec[1] == NULL\n \t\t&& DF_REF_REGNO (*u_rec) == DF_REF_REGNO (*d_rec)\n@@ -4459,22 +4457,20 @@ find_moveable_pseudos (void)\n \t\tbitmap_clear_bit (transp, regno);\n \t\tcontinue;\n \t      }\n-\t    while (*u_rec)\n+\t    FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t      {\n-\t\tunsigned regno = DF_REF_REGNO (*u_rec);\n+\t\tunsigned regno = DF_REF_REGNO (use);\n \t\tbitmap_set_bit (&used, regno);\n \t\tif (bitmap_clear_bit (moveable, regno))\n \t\t  bitmap_clear_bit (transp, regno);\n-\t\tu_rec++;\n \t      }\n \n-\t    while (*d_rec)\n+\t    FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t      {\n-\t\tunsigned regno = DF_REF_REGNO (*d_rec);\n+\t\tunsigned regno = DF_REF_REGNO (def);\n \t\tbitmap_set_bit (&set, regno);\n \t\tbitmap_clear_bit (transp, regno);\n \t\tbitmap_clear_bit (moveable, regno);\n-\t\td_rec++;\n \t      }\n \t  }\n     }\n@@ -4612,7 +4608,7 @@ find_moveable_pseudos (void)\n       bitmap def_bb_transp = bb_transp_live + def_block->index;\n       bool local_to_bb_p = bitmap_bit_p (def_bb_local, i);\n       rtx use_insn = closest_uses[i];\n-      df_ref *def_insn_use_rec = DF_INSN_USES (def_insn);\n+      df_ref use;\n       bool all_ok = true;\n       bool all_transp = true;\n \n@@ -4643,9 +4639,8 @@ find_moveable_pseudos (void)\n       if (dump_file)\n \tfprintf (dump_file, \"Examining insn %d, def for %d\\n\",\n \t\t INSN_UID (def_insn), i);\n-      while (*def_insn_use_rec != NULL)\n+      FOR_EACH_INSN_USE (use, def_insn)\n \t{\n-\t  df_ref use = *def_insn_use_rec;\n \t  unsigned regno = DF_REF_REGNO (use);\n \t  if (bitmap_bit_p (&unusable_as_input, regno))\n \t    {\n@@ -4688,8 +4683,6 @@ find_moveable_pseudos (void)\n \t      else\n \t\tall_transp = false;\n \t    }\n-\n-\t  def_insn_use_rec++;\n \t}\n       if (!all_ok)\n \tcontinue;"}, {"sha": "898a431af2c0eb6a25735367d472bba49ed8b8bb", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -826,14 +826,14 @@ static bool\n check_dependencies (rtx insn, bitmap depends_on)\n {\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  df_ref *use_rec;\n+  df_ref use;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n-  for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n-    if (!check_dependency (bb, *use_rec, depends_on))\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    if (!check_dependency (bb, use, depends_on))\n       return false;\n-  for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n-    if (!check_dependency (bb, *use_rec, depends_on))\n+  FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+    if (!check_dependency (bb, use, depends_on))\n       return false;\n \n   return true;\n@@ -909,19 +909,17 @@ static void\n record_uses (rtx insn)\n {\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  df_ref *use_rec;\n+  df_ref use;\n   struct invariant *inv;\n \n-  for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n     {\n-      df_ref use = *use_rec;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, use);\n     }\n-  for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n+  FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n     {\n-      df_ref use = *use_rec;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, use);"}, {"sha": "21bce78f8a0aa8f99440ae82d1384eff40c91855", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -3024,7 +3024,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n {\n   enum reg_class cl;\n   HARD_REG_SET live;\n-  df_ref *def_rec;\n+  df_ref def;\n   int i;\n \n   gcc_assert (from < MAX_INSNS_PER_PEEP2 + 1);\n@@ -3041,9 +3041,8 @@ peep2_find_free_register (int from, int to, const char *class_str,\n       gcc_assert (peep2_insn_data[from].insn != NULL_RTX);\n \n       /* Don't use registers set or clobbered by the insn.  */\n-      for (def_rec = DF_INSN_DEFS (peep2_insn_data[from].insn);\n-\t   *def_rec; def_rec++)\n-\tSET_HARD_REG_BIT (live, DF_REF_REGNO (*def_rec));\n+      FOR_EACH_INSN_DEF (def, peep2_insn_data[from].insn)\n+\tSET_HARD_REG_BIT (live, DF_REF_REGNO (def));\n \n       from = peep2_buf_position (from + 1);\n     }"}, {"sha": "f5d521b0ddd40408cd2992861c114e27922016ba", "filename": "gcc/ree.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -431,23 +431,20 @@ transform_ifelse (ext_cand *cand, rtx def_insn)\n static struct df_link *\n get_defs (rtx insn, rtx reg, vec<rtx> *dest)\n {\n-  df_ref reg_info, *uses;\n+  df_ref use;\n   struct df_link *ref_chain, *ref_link;\n \n-  reg_info = NULL;\n-\n-  for (uses = DF_INSN_USES (insn); *uses; uses++)\n+  FOR_EACH_INSN_USE (use, insn)\n     {\n-      reg_info = *uses;\n-      if (GET_CODE (DF_REF_REG (reg_info)) == SUBREG)\n+      if (GET_CODE (DF_REF_REG (use)) == SUBREG)\n         return NULL;\n-      if (REGNO (DF_REF_REG (reg_info)) == REGNO (reg))\n-        break;\n+      if (REGNO (DF_REF_REG (use)) == REGNO (reg))\n+\tbreak;\n     }\n \n-  gcc_assert (reg_info != NULL && uses != NULL);\n+  gcc_assert (use != NULL);\n \n-  ref_chain = DF_REF_CHAIN (reg_info);\n+  ref_chain = DF_REF_CHAIN (use);\n \n   for (ref_link = ref_chain; ref_link; ref_link = ref_link->next)\n     {"}, {"sha": "9621f94e8ea835f3c6f54665be18646fe0795d07", "filename": "gcc/regstat.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -124,6 +124,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  df_ref def, use;\n   int luid = 0;\n   bitmap_iterator bi;\n   unsigned int regno;\n@@ -158,7 +159,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       bitmap_iterator bi;\n       struct df_mw_hardreg **mws_rec;\n       rtx link;\n@@ -209,7 +210,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n       /* We only care about real sets for calls.  Clobbers cannot\n \t be depended on.\n \t Only do this if the value is totally dead.  */\n-      for (mws_rec = DF_INSN_UID_MWS (uid); *mws_rec; mws_rec++)\n+      for (mws_rec = DF_INSN_INFO_MWS (insn_info); *mws_rec; mws_rec++)\n \t{\n \t  struct df_mw_hardreg *mws = *mws_rec;\n \t  if (DF_MWS_REG_DEF_P (mws))\n@@ -235,9 +236,8 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \n       /* All of the defs except the return value are some sort of\n \t clobber.  This code is for the return.  */\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t{\n-\t  df_ref def = *def_rec;\n \t  if ((!CALL_P (insn))\n \t      || (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n \t    {\n@@ -301,9 +301,8 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t    }\n \t}\n \n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t{\n-\t  df_ref use = *use_rec;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n \t  if (uregno >= FIRST_PSEUDO_REGISTER)\n@@ -444,6 +443,7 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  df_ref def, use;\n \n   bitmap_copy (live, df_get_live_out (bb));\n \n@@ -465,7 +465,7 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       unsigned int regno;\n \n       if (!INSN_P (insn))\n@@ -486,9 +486,8 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n \n       /* All of the defs except the return value are some sort of\n \t clobber.  This code is for the return.  */\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t{\n-\t  df_ref def = *def_rec;\n \t  if ((!CALL_P (insn))\n \t      || (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n \t    {\n@@ -498,11 +497,8 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n \t    }\n \t}\n \n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t{\n-\t  df_ref use = *use_rec;\n-\t  bitmap_set_bit (live, DF_REF_REGNO (use));\n-\t}\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\tbitmap_set_bit (live, DF_REF_REGNO (use));\n     }\n }\n "}, {"sha": "7cafc8bb00bec932394ff3059ed9e378aab876f4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -4725,7 +4725,7 @@ find_inc (struct mem_inc_info *mii, bool backwards)\n       if (parse_add_or_inc (mii, inc_cand, backwards))\n \t{\n \t  struct dep_replacement *desc;\n-\t  df_ref *def_rec;\n+\t  df_ref def;\n \t  rtx newaddr, newmem;\n \n \t  if (sched_verbose >= 5)\n@@ -4734,18 +4734,15 @@ find_inc (struct mem_inc_info *mii, bool backwards)\n \n \t  /* Need to assure that none of the operands of the inc\n \t     instruction are assigned to by the mem insn.  */\n-\t  for (def_rec = DF_INSN_DEFS (mii->mem_insn); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\t      if (reg_overlap_mentioned_p (DF_REF_REG (def), mii->inc_input)\n-\t\t  || reg_overlap_mentioned_p (DF_REF_REG (def), mii->mem_reg0))\n-\t\t{\n-\t\t  if (sched_verbose >= 5)\n-\t\t    fprintf (sched_dump,\n-\t\t\t     \"inc conflicts with store failure.\\n\");\n-\t\t  goto next;\n-\t\t}\n-\t    }\n+\t  FOR_EACH_INSN_DEF (def, mii->mem_insn)\n+\t    if (reg_overlap_mentioned_p (DF_REF_REG (def), mii->inc_input)\n+\t\t|| reg_overlap_mentioned_p (DF_REF_REG (def), mii->mem_reg0))\n+\t      {\n+\t\tif (sched_verbose >= 5)\n+\t\t  fprintf (sched_dump,\n+\t\t\t   \"inc conflicts with store failure.\\n\");\n+\t\tgoto next;\n+\t      }\n \t  newaddr = mii->inc_input;\n \t  if (mii->mem_index != NULL_RTX)\n \t    newaddr = gen_rtx_PLUS (GET_MODE (newaddr), newaddr,\n@@ -4820,22 +4817,19 @@ find_mem (struct mem_inc_info *mii, rtx *address_of_x)\n \t}\n       if (REG_P (reg0))\n \t{\n-\t  df_ref *def_rec;\n+\t  df_ref use;\n \t  int occurrences = 0;\n \n \t  /* Make sure this reg appears only once in this insn.  Can't use\n \t     count_occurrences since that only works for pseudos.  */\n-\t  for (def_rec = DF_INSN_USES (mii->mem_insn); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\t      if (reg_overlap_mentioned_p (reg0, DF_REF_REG (def)))\n-\t\tif (++occurrences > 1)\n-\t\t  {\n-\t\t    if (sched_verbose >= 5)\n-\t\t      fprintf (sched_dump, \"mem count failure\\n\");\n-\t\t    return false;\n-\t\t  }\n-\t    }\n+\t  FOR_EACH_INSN_USE (use, mii->mem_insn)\n+\t    if (reg_overlap_mentioned_p (reg0, DF_REF_REG (use)))\n+\t      if (++occurrences > 1)\n+\t\t{\n+\t\t  if (sched_verbose >= 5)\n+\t\t    fprintf (sched_dump, \"mem count failure\\n\");\n+\t\t  return false;\n+\t\t}\n \n \t  mii->mem_reg0 = reg0;\n \t  return find_inc (mii, true) || find_inc (mii, false);"}, {"sha": "0399efa5c7cb5919396fc756eec3d43ebfa1fcd5", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -2613,8 +2613,7 @@ static void\n maybe_downgrade_id_to_use (idata_t id, insn_t insn)\n {\n   bool must_be_use = false;\n-  unsigned uid = INSN_UID (insn);\n-  df_ref *rec;\n+  df_ref def;\n   rtx lhs = IDATA_LHS (id);\n   rtx rhs = IDATA_RHS (id);\n \n@@ -2628,10 +2627,8 @@ maybe_downgrade_id_to_use (idata_t id, insn_t insn)\n       return;\n     }\n \n-  for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      df_ref def = *rec;\n-\n       if (DF_REF_INSN (def)\n           && DF_REF_FLAGS_IS_SET (def, DF_REF_PRE_POST_MODIFY)\n           && loc_mentioned_in_p (DF_REF_LOC (def), IDATA_RHS (id)))\n@@ -2659,13 +2656,12 @@ maybe_downgrade_id_to_use (idata_t id, insn_t insn)\n static void\n setup_id_reg_sets (idata_t id, insn_t insn)\n {\n-  unsigned uid = INSN_UID (insn);\n-  df_ref *rec;\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref def, use;\n   regset tmp = get_clear_regset_from_pool ();\n \n-  for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n+  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n     {\n-      df_ref def = *rec;\n       unsigned int regno = DF_REF_REGNO (def);\n \n       /* Post modifies are treated like clobbers by sched-deps.c.  */\n@@ -2689,9 +2685,8 @@ setup_id_reg_sets (idata_t id, insn_t insn)\n         bitmap_set_bit (tmp, regno);\n     }\n \n-  for (rec = DF_INSN_UID_USES (uid); *rec; rec++)\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n     {\n-      df_ref use = *rec;\n       unsigned int regno = DF_REF_REGNO (use);\n \n       /* When these refs are met for the first time, skip them, as"}, {"sha": "5c34fee39f95bb6df7943b17e8ab081570b98580", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -64,7 +64,7 @@ bool\n requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n \t\t\tHARD_REG_SET set_up_by_prologue)\n {\n-  df_ref *df_rec;\n+  df_ref def, use;\n   HARD_REG_SET hardregs;\n   unsigned regno;\n \n@@ -76,9 +76,9 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n     return true;\n \n   CLEAR_HARD_REG_SET (hardregs);\n-  for (df_rec = DF_INSN_DEFS (insn); *df_rec; df_rec++)\n+  FOR_EACH_INSN_DEF (def, insn)\n     {\n-      rtx dreg = DF_REF_REG (*df_rec);\n+      rtx dreg = DF_REF_REG (def);\n \n       if (!REG_P (dreg))\n \tcontinue;\n@@ -94,9 +94,9 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n \t&& df_regs_ever_live_p (regno))\n       return true;\n \n-  for (df_rec = DF_INSN_USES (insn); *df_rec; df_rec++)\n+  FOR_EACH_INSN_USE (use, insn)\n     {\n-      rtx reg = DF_REF_REG (*df_rec);\n+      rtx reg = DF_REF_REG (use);\n \n       if (!REG_P (reg))\n \tcontinue;\n@@ -333,7 +333,7 @@ prepare_shrink_wrap (basic_block entry_block)\n {\n   rtx insn, curr, x;\n   HARD_REG_SET uses, defs;\n-  df_ref *ref;\n+  df_ref def, use;\n   bool split_p = false;\n \n   if (JUMP_P (BB_END (entry_block)))\n@@ -353,17 +353,17 @@ prepare_shrink_wrap (basic_block entry_block)\n \t\t\t\t       &split_p))\n       {\n \t/* Add all defined registers to DEFs.  */\n-\tfor (ref = DF_INSN_DEFS (insn); *ref; ref++)\n+\tFOR_EACH_INSN_DEF (def, insn)\n \t  {\n-\t    x = DF_REF_REG (*ref);\n+\t    x = DF_REF_REG (def);\n \t    if (REG_P (x) && HARD_REGISTER_P (x))\n \t      SET_HARD_REG_BIT (defs, REGNO (x));\n \t  }\n \n \t/* Add all used registers to USESs.  */\n-\tfor (ref = DF_INSN_USES (insn); *ref; ref++)\n+\tFOR_EACH_INSN_USE (use, insn)\n \t  {\n-\t    x = DF_REF_REG (*ref);\n+\t    x = DF_REF_REG (use);\n \t    if (REG_P (x) && HARD_REGISTER_P (x))\n \t      SET_HARD_REG_BIT (uses, REGNO (x));\n \t  }"}, {"sha": "18ba518eb9ac3119a2292763e1061772ab3fc633", "filename": "gcc/store-motion.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -645,7 +645,7 @@ compute_store_table (void)\n   unsigned regno;\n #endif\n   rtx insn, tmp;\n-  df_ref *def_rec;\n+  df_ref def;\n   int *last_set_in, *already_set;\n   struct st_expr * ptr, **prev_next_ptr_ptr;\n   unsigned int max_gcse_regno = max_reg_num ();\n@@ -665,8 +665,8 @@ compute_store_table (void)\n \t  if (! NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    last_set_in[DF_REF_REGNO (*def_rec)] = INSN_UID (insn);\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    last_set_in[DF_REF_REGNO (def)] = INSN_UID (insn);\n \t}\n \n       /* Now find the stores.  */\n@@ -676,16 +676,16 @@ compute_store_table (void)\n \t  if (! NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    already_set[DF_REF_REGNO (*def_rec)] = INSN_UID (insn);\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    already_set[DF_REF_REGNO (def)] = INSN_UID (insn);\n \n \t  /* Now that we've marked regs, look for stores.  */\n \t  find_moveable_store (insn, already_set, last_set_in);\n \n \t  /* Unmark regs that are no longer set.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (last_set_in[DF_REF_REGNO (*def_rec)] == INSN_UID (insn))\n-\t      last_set_in[DF_REF_REGNO (*def_rec)] = 0;\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (last_set_in[DF_REF_REGNO (def)] == INSN_UID (insn))\n+\t      last_set_in[DF_REF_REGNO (def)] = 0;\n \t}\n \n #ifdef ENABLE_CHECKING\n@@ -1068,12 +1068,12 @@ build_store_vectors (void)\n       FOR_BB_INSNS (bb, insn)\n \tif (NONDEBUG_INSN_P (insn))\n \t  {\n-\t    df_ref *def_rec;\n-\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    df_ref def;\n+\t    FOR_EACH_INSN_DEF (def, insn)\n \t      {\n-\t\tunsigned int ref_regno = DF_REF_REGNO (*def_rec);\n+\t\tunsigned int ref_regno = DF_REF_REGNO (def);\n \t\tif (ref_regno < max_gcse_regno)\n-\t\t  regs_set_in_block[DF_REF_REGNO (*def_rec)] = 1;\n+\t\t  regs_set_in_block[DF_REF_REGNO (def)] = 1;\n \t      }\n \t  }\n "}, {"sha": "029919f8f001a39db578a2cfd56cc1d76e707153", "filename": "gcc/web.c", "status": "modified", "additions": 50, "deletions": 100, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfac633a90588e96050f8767052d59efd7307cb1/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=bfac633a90588e96050f8767052d59efd7307cb1", "patch": "@@ -173,51 +173,34 @@ union_defs (df_ref use, struct web_entry *def_entry,\n {\n   struct df_insn_info *insn_info = DF_REF_INSN_INFO (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n-  df_ref *eq_use_link;\n-  df_ref *def_link;\n   rtx set;\n \n   if (insn_info)\n     {\n-      rtx insn = insn_info->insn;\n-      eq_use_link = DF_INSN_INFO_EQ_USES (insn_info);\n-      def_link = DF_INSN_INFO_DEFS (insn_info);\n-      set = single_set (insn);\n+      df_ref eq_use;\n+\n+      set = single_set (insn_info->insn);\n+      FOR_EACH_INSN_INFO_EQ_USE (eq_use, insn_info)\n+\tif (use != eq_use\n+\t    && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (eq_use))\n+\t  (*fun) (use_entry + DF_REF_ID (use), use_entry + DF_REF_ID (eq_use));\n     }\n   else\n-    {\n-      /* An artificial use.  It links up with nothing.  */\n-      eq_use_link = NULL;\n-      def_link = NULL;\n-      set = NULL;\n-    }\n+    set = NULL;\n \n   /* Union all occurrences of the same register in reg notes.  */\n \n-  if (eq_use_link)\n-    while (*eq_use_link)\n-      {\n-\tif (use != *eq_use_link\n-\t    && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (*eq_use_link))\n-\t  (*fun) (use_entry + DF_REF_ID (use),\n-\t\t  use_entry + DF_REF_ID (*eq_use_link));\n-\teq_use_link++;\n-    }\n-\n   /* Recognize trivial noop moves and attempt to keep them as noop.  */\n \n   if (set\n       && SET_SRC (set) == DF_REF_REG (use)\n       && SET_SRC (set) == SET_DEST (set))\n     {\n-      if (def_link)\n-\twhile (*def_link)\n-\t  {\n-\t    if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (*def_link))\n-\t      (*fun) (use_entry + DF_REF_ID (use),\n-\t\t      def_entry + DF_REF_ID (*def_link));\n-\t    def_link++;\n-\t  }\n+      df_ref def;\n+\n+      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\tif (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def))\n+\t  (*fun) (use_entry + DF_REF_ID (use), def_entry + DF_REF_ID (def));\n     }\n \n   /* UD chains of uninitialized REGs are empty.  Keeping all uses of\n@@ -248,23 +231,14 @@ union_defs (df_ref use, struct web_entry *def_entry,\n   /* A READ_WRITE use requires the corresponding def to be in the same\n      register.  Find it and union.  */\n   if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n-    {\n-      df_ref *link;\n+    if (insn_info)\n+      {\n+\tdf_ref def;\n \n-      if (insn_info)\n-\tlink = DF_INSN_INFO_DEFS (insn_info);\n-      else\n-\tlink = NULL;\n-\n-      if (link)\n-\twhile (*link)\n-\t  {\n-\t    if (DF_REF_REAL_REG (*link) == DF_REF_REAL_REG (use))\n-\t      (*fun) (use_entry + DF_REF_ID (use),\n-\t\t      def_entry + DF_REF_ID (*link));\n-\t    link++;\n-\t  }\n-    }\n+\tFOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t  if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def))\n+\t    (*fun) (use_entry + DF_REF_ID (use), def_entry + DF_REF_ID (def));\n+      }\n }\n \n /* Find the corresponding register for the given entry.  */\n@@ -375,22 +349,16 @@ pass_web::execute (function *fun)\n   FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n     {\n-      unsigned int uid = INSN_UID (insn);\n       if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  df_ref *use_rec;\n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\tDF_REF_ID (use) = uses_num++;\n-\t    }\n-\t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\tDF_REF_ID (use) = uses_num++;\n-\t    }\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref use;\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      DF_REF_ID (use) = uses_num++;\n+\t  FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      DF_REF_ID (use) = uses_num++;\n \t}\n     }\n \n@@ -402,34 +370,23 @@ pass_web::execute (function *fun)\n   /* Produce the web.  */\n   FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n-    {\n-      unsigned int uid = INSN_UID (insn);\n       if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  df_ref *use_rec;\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref use;\n \t  union_match_dups (insn, def_entry, use_entry, unionfind_union);\n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\tunion_defs (use, def_entry, used, use_entry, unionfind_union);\n-\t    }\n-\t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\tunion_defs (use, def_entry, used, use_entry, unionfind_union);\n-\t    }\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      union_defs (use, def_entry, used, use_entry, unionfind_union);\n+\t  FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      union_defs (use, def_entry, used, use_entry, unionfind_union);\n \t}\n-    }\n \n   /* Update the instruction stream, allocating new registers for split pseudos\n      in progress.  */\n   FOR_ALL_BB_FN (bb, fun)\n     FOR_BB_INSNS (bb, insn)\n-    {\n-      unsigned int uid = INSN_UID (insn);\n-\n       if (NONDEBUG_INSN_P (insn)\n \t  /* Ignore naked clobber.  For example, reg 134 in the second insn\n \t     of the following sequence will not be replaced.\n@@ -441,28 +398,21 @@ pass_web::execute (function *fun)\n \t     Thus the later passes can optimize them away.  */\n \t  && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t{\n-\t  df_ref *use_rec;\n-\t  df_ref *def_rec;\n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\treplace_ref (use, entry_register (use_entry + DF_REF_ID (use), use, used));\n-\t    }\n-\t  for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n-\t\treplace_ref (use, entry_register (use_entry + DF_REF_ID (use), use, used));\n-\t    }\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\t      if (DF_REF_REGNO (def) >= FIRST_PSEUDO_REGISTER)\n-\t\treplace_ref (def, entry_register (def_entry + DF_REF_ID (def), def, used));\n-\t    }\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t  df_ref def, use;\n+\t  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      replace_ref (use, entry_register (use_entry + DF_REF_ID (use),\n+\t\t\t\t\t\tuse, used));\n+\t  FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+\t    if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER)\n+\t      replace_ref (use, entry_register (use_entry + DF_REF_ID (use),\n+\t\t\t\t\t\tuse, used));\n+\t  FOR_EACH_INSN_INFO_DEF (def, insn_info)\n+\t    if (DF_REF_REGNO (def) >= FIRST_PSEUDO_REGISTER)\n+\t      replace_ref (def, entry_register (def_entry + DF_REF_ID (def),\n+\t\t\t\t\t\tdef, used));\n \t}\n-    }\n \n   free (def_entry);\n   free (use_entry);"}]}