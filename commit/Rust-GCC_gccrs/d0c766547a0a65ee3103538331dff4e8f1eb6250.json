{"sha": "d0c766547a0a65ee3103538331dff4e8f1eb6250", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjNzY2NTQ3YTBhNjVlZTMxMDM1MzgzMzFkZmY0ZThmMWViNjI1MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-27T15:47:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-27T15:47:10Z"}, "message": "(emit_move_insn): Delete unused vars.\n\n(emit_move_insn_1): Don't set SUBMODE unless used.\n(expand_builtin, case BUILT_IN_SAVEREGS): Clean up uses of VALREG\nand SAVED_VALREG.\n\nFrom-SVN: r6642", "tree": {"sha": "8e2e61f96a8c27edb0ec3fd4266faa474d9531a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e2e61f96a8c27edb0ec3fd4266faa474d9531a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c766547a0a65ee3103538331dff4e8f1eb6250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c766547a0a65ee3103538331dff4e8f1eb6250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c766547a0a65ee3103538331dff4e8f1eb6250", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c766547a0a65ee3103538331dff4e8f1eb6250/comments", "author": null, "committer": null, "parents": [{"sha": "2af5e9e20d8021b239970bd72d78ec60efc38f2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af5e9e20d8021b239970bd72d78ec60efc38f2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2af5e9e20d8021b239970bd72d78ec60efc38f2b"}], "stats": {"total": 33, "additions": 14, "deletions": 19}, "files": [{"sha": "a492676ba1a7cf2ce9a18b2d4f03924f8a777a00", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c766547a0a65ee3103538331dff4e8f1eb6250/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c766547a0a65ee3103538331dff4e8f1eb6250/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d0c766547a0a65ee3103538331dff4e8f1eb6250", "patch": "@@ -1712,9 +1712,6 @@ emit_move_insn (x, y)\n      rtx x, y;\n {\n   enum machine_mode mode = GET_MODE (x);\n-  enum machine_mode submode;\n-  enum mode_class class = GET_MODE_CLASS (mode);\n-  int i;\n \n   x = protect_from_queue (x, 1);\n   y = protect_from_queue (y, 0);\n@@ -1759,19 +1756,17 @@ emit_move_insn_1 (x, y)\n   enum mode_class class = GET_MODE_CLASS (mode);\n   int i;\n \n-  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n-    submode = mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n-\t\t\t     (class == MODE_COMPLEX_INT\n-\t\t\t      ? MODE_INT : MODE_FLOAT),\n-\t\t\t     0);\n-\n   if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     return\n       emit_insn (GEN_FCN (mov_optab->handlers[(int) mode].insn_code) (x, y));\n \n   /* Expand complex moves by moving real part and imag part, if possible.  */\n   else if ((class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n-\t   && submode != BLKmode\n+\t   && BLKmode != (submode = mode_for_size ((GET_MODE_UNIT_SIZE (mode)\n+\t\t\t\t\t\t    * BITS_PER_UNIT),\n+\t\t\t\t\t\t   (class == MODE_COMPLEX_INT\n+\t\t\t\t\t\t    ? MODE_INT : MODE_FLOAT),\n+\t\t\t\t\t\t   0))\n \t   && (mov_optab->handlers[(int) submode].insn_code\n \t       != CODE_FOR_nothing))\n     {\n@@ -6849,7 +6844,6 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t   call to the first insn of this function.  */\n \trtx temp;\n \trtx seq;\n-\trtx valreg, saved_valreg;\n \n \t/* Now really call the function.  `expand_call' does not call\n \t   expand_builtin, so there is no danger of infinite recursion here.  */\n@@ -6862,18 +6856,19 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t/* The register where the function returns its value\n \t   is likely to have something else in it, such as an argument.\n \t   So preserve that register around the call.  */\n+\n \tif (value_mode != VOIDmode)\n \t  {\n-\t    valreg = hard_libcall_value (value_mode);\n-\t    saved_valreg = gen_reg_rtx (value_mode);\n+\t    rtx valreg = hard_libcall_value (value_mode);\n+\t    rtx saved_valreg = gen_reg_rtx (value_mode);\n+\n \t    emit_move_insn (saved_valreg, valreg);\n+\t    temp = expand_call (exp, target, ignore);\n+\t    emit_move_insn (valreg, saved_valreg);\n \t  }\n-\n-\t/* Generate the call, putting the value in a pseudo.  */\n-\ttemp = expand_call (exp, target, ignore);\n-\n-\tif (value_mode != VOIDmode)\n-\t  emit_move_insn (valreg, saved_valreg);\n+\telse\n+\t  /* Generate the call, putting the value in a pseudo.  */\n+\t  temp = expand_call (exp, target, ignore);\n #endif\n \n \tseq = get_insns ();"}]}