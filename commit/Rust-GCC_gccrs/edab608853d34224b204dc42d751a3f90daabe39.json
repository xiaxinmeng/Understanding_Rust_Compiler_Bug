{"sha": "edab608853d34224b204dc42d751a3f90daabe39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRhYjYwODg1M2QzNDIyNGIyMDRkYzQyZDc1MWEzZjkwZGFhYmUzOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-07-29T12:56:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T12:56:31Z"}, "message": "sem_aggr.adb (Resolve_Array_Aggregate): Change Is_Static_Range to Is_OK_Static_Range.\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate): Change Is_Static_Range\n\tto Is_OK_Static_Range.\n\t* sem_attr.adb (Eval_Attribute): Make sure we properly flag\n\tstatic attributes (Eval_Attribute, case Size): Handle size of\n\tzero properly (Eval_Attribute, case Value_Size): Handle size of\n\tzero properly.\n\t* sem_ch13.adb: Minor reformatting.\n\t* sem_ch3.adb (Process_Range_Expr_In_Decl): Change\n\tIs_Static_Range to Is_OK_Static_Range.\n\t* sem_eval.adb (Eval_Case_Expression): Total rewrite, was\n\twrong in several ways (Is_Static_Range): Moved here from spec\n\t(Is_Static_Subtype): Moved here from spec Change some incorrect\n\tIs_Static_Subtype calls to Is_OK_Static_Subtype.\n\t* sem_eval.ads: Add comments to section on\n\tIs_Static_Expression/Raises_Constraint_Error (Is_OK_Static_Range):\n\tAdd clarifying comments (Is_Static_Range): Moved to body\n\t(Is_Statically_Unevaluated): New function.\n\t* sem_util.ads, sem_util.adb (Is_Preelaborable_Expression): Change\n\tIs_Static_Range to Is_OK_Static_Range.\n\t* sinfo.ads: Additional commments for Is_Static_Expression noting\n\tthat clients should almost always use Is_OK_Static_Expression\n\tinstead. Many other changes throughout front end units to obey\n\tthis rule.\n\t* tbuild.ads, tbuild.adb (New_Occurrence_Of): Set Is_Static_Expression\n\tfor enumeration literal.\n\t* exp_ch5.adb, sem_intr.adb, sem_ch5.adb, exp_attr.adb, exp_ch9.adb,\n\tlib-writ.adb, sem_ch9.adb, einfo.ads, checks.adb, checks.ads,\n\tsem_prag.adb, sem_ch12.adb, freeze.adb, sem_res.adb, exp_ch4.adb,\n\texp_ch6.adb, sem_ch4.adb, sem_ch6.adb, exp_aggr.adb, sem_cat.adb:\n\tReplace all occurrences of Is_Static_Expression by\n\tIs_OK_Static_Expression.\n\nFrom-SVN: r213159", "tree": {"sha": "6cc8f3aef60cefb58f69e4a2c8d62232b4c13f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc8f3aef60cefb58f69e4a2c8d62232b4c13f10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edab608853d34224b204dc42d751a3f90daabe39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edab608853d34224b204dc42d751a3f90daabe39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edab608853d34224b204dc42d751a3f90daabe39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edab608853d34224b204dc42d751a3f90daabe39/comments", "author": null, "committer": null, "parents": [{"sha": "c5c780e6deb9cf337f4898db5716659698311d7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c780e6deb9cf337f4898db5716659698311d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c780e6deb9cf337f4898db5716659698311d7d"}], "stats": {"total": 2183, "additions": 1481, "deletions": 702}, "files": [{"sha": "40e3d1849e2c4057c8af7036a43da5d0d410038e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1,3 +1,37 @@\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): Change Is_Static_Range\n+\tto Is_OK_Static_Range.\n+\t* sem_attr.adb (Eval_Attribute): Make sure we properly flag\n+\tstatic attributes (Eval_Attribute, case Size): Handle size of\n+\tzero properly (Eval_Attribute, case Value_Size): Handle size of\n+\tzero properly.\n+\t* sem_ch13.adb: Minor reformatting.\n+\t* sem_ch3.adb (Process_Range_Expr_In_Decl): Change\n+\tIs_Static_Range to Is_OK_Static_Range.\n+\t* sem_eval.adb (Eval_Case_Expression): Total rewrite, was\n+\twrong in several ways (Is_Static_Range): Moved here from spec\n+\t(Is_Static_Subtype): Moved here from spec Change some incorrect\n+\tIs_Static_Subtype calls to Is_OK_Static_Subtype.\n+\t* sem_eval.ads: Add comments to section on\n+\tIs_Static_Expression/Raises_Constraint_Error (Is_OK_Static_Range):\n+\tAdd clarifying comments (Is_Static_Range): Moved to body\n+\t(Is_Statically_Unevaluated): New function.\n+\t* sem_util.ads, sem_util.adb (Is_Preelaborable_Expression): Change\n+\tIs_Static_Range to Is_OK_Static_Range.\n+\t* sinfo.ads: Additional commments for Is_Static_Expression noting\n+\tthat clients should almost always use Is_OK_Static_Expression\n+\tinstead. Many other changes throughout front end units to obey\n+\tthis rule.\n+\t* tbuild.ads, tbuild.adb (New_Occurrence_Of): Set Is_Static_Expression\n+\tfor enumeration literal.\n+\t* exp_ch5.adb, sem_intr.adb, sem_ch5.adb, exp_attr.adb, exp_ch9.adb,\n+\tlib-writ.adb, sem_ch9.adb, einfo.ads, checks.adb, checks.ads,\n+\tsem_prag.adb, sem_ch12.adb, freeze.adb, sem_res.adb, exp_ch4.adb,\n+\texp_ch6.adb, sem_ch4.adb, sem_ch6.adb, exp_aggr.adb, sem_cat.adb:\n+\tReplace all occurrences of Is_Static_Expression by\n+\tIs_OK_Static_Expression.\n+\n 2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch4.adb (Process_Transient_Object): Remove constant"}, {"sha": "d875cb5a6d85c5f35af406d683fd5cc237799849", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -5914,7 +5914,7 @@ package body Checks is\n       --  First special case, if the source type is already within the range\n       --  of the target type, then no check is needed (probably we should have\n       --  stopped Do_Range_Check from being set in the first place, but better\n-      --  late than never in preventing junk code.\n+      --  late than never in preventing junk code and junk flag settings.\n \n       if In_Subrange_Of (Source_Type, Target_Type)\n \n@@ -5933,13 +5933,30 @@ package body Checks is\n         and then not\n           (Is_Floating_Point_Type (Source_Type) and Check_Float_Overflow)\n       then\n+         Set_Do_Range_Check (N, False);\n          return;\n       end if;\n \n-      --  We need a check, so force evaluation of the node, so that it does\n-      --  not get evaluated twice (once for the check, once for the actual\n-      --  reference). Such a double evaluation is always a potential source\n-      --  of inefficiency, and is functionally incorrect in the volatile case.\n+      --  Here a check is needed. If the expander is not active, or if we are\n+      --  in GNATProve mode, then simply set the Do_Range_Check flag and we\n+      --  are done. In both these cases, we just want to see the range check\n+      --  flag set, we do not want to generate the explicit range check code.\n+\n+      if GNATprove_Mode or else not Expander_Active then\n+         Set_Do_Range_Check (N, True);\n+         return;\n+      end if;\n+\n+      --  Here we will generate an explicit range check, so we don't want to\n+      --  set the Do_Range check flag, since the range check is taken care of\n+      --  by the code we will generate.\n+\n+      Set_Do_Range_Check (N, False);\n+\n+      --  Force evaluation of the node, so that it does not get evaluated twice\n+      --  (once for the check, once for the actual reference). Such a double\n+      --  evaluation is always a potential source of inefficiency, and is\n+      --  functionally incorrect in the volatile case.\n \n       if not Is_Entity_Name (N) or else Treat_As_Volatile (Entity (N)) then\n          Force_Evaluation (N);\n@@ -6876,7 +6893,7 @@ package body Checks is\n    --------------------------\n \n    procedure Install_Static_Check (R_Cno : Node_Id; Loc : Source_Ptr) is\n-      Stat : constant Boolean   := Is_Static_Expression (R_Cno);\n+      Stat : constant Boolean   := Is_OK_Static_Expression (R_Cno);\n       Typ  : constant Entity_Id := Etype (R_Cno);\n \n    begin\n@@ -7148,7 +7165,7 @@ package body Checks is\n          if Lo = No_Uint or else Hi = No_Uint then\n             return False;\n \n-         elsif Is_Static_Subtype (Etype (N)) then\n+         elsif Is_OK_Static_Subtype (Etype (N)) then\n             return Lo >= Expr_Value (Type_Low_Bound  (Rtyp))\n                      and then\n                    Hi <= Expr_Value (Type_High_Bound (Rtyp));"}, {"sha": "7244e3c6a66f8a1a64f991fe11d095022511c263", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -660,12 +660,19 @@ package Checks is\n    --  The Reason parameter is the exception code to be used for the exception\n    --  if raised.\n    --\n-   --  Note on the relation of this routine to the Do_Range_Check flag. Mostly\n-   --  for historical reasons, we often set the Do_Range_Check flag and then\n-   --  later we call Generate_Range_Check if this flag is set. Most probably we\n-   --  could eliminate this intermediate setting of the flag (historically the\n-   --  back end dealt with range checks, using this flag to indicate if a check\n-   --  was required, then we moved checks into the front end).\n+   --  Note: if the expander is not active, or if we are in GNATprove mode,\n+   --  then we do not generate explicit range code. Instead we just turn the\n+   --  Do_Range_Check flag on, since in these cases that's what we want to see\n+   --  in the tree (GNATprove in particular depends on this flag being set). If\n+   --  we generate the actual range check, then we make sure the flag is off,\n+   --  since the code we generate takes complete care of the check.\n+   --\n+   --  Historical note: We used to just pass ono the Do_Range_Check flag to the\n+   --  back end to generate the check, but now in code generation mode we never\n+   --  have this flag set, since the front end takes care of the check. The\n+   --  normal processing flow now is that the analyzer typically turns on the\n+   --  Do_Range_Check flag, and if it is set, this routine is called, which\n+   --  turns the flag off in code generation mode.\n \n    procedure Generate_Index_Checks (N : Node_Id);\n    --  This procedure is called to generate index checks on the subscripts for"}, {"sha": "135de489abb31b8181469887d87d48e198b31809", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1878,13 +1878,13 @@ package Einfo is\n --       include only the components corresponding to these discriminants.\n \n --    Has_Static_Predicate (Flag269)\n---       Defined in all types and subtypes. Set if the type (which must be\n---       a discrete, real, or string subtype) has a static predicate, i.e. a\n---       predicate whose expression is predicate-static. This can result from\n---       use of a Predicate, Static_Predicate, or Dynamic_Predicate aspect. We\n---       can distinguish these cases by testing Has_Static_Predicate_Aspect\n---       and Has_Dynamic_Predicate_Aspect. See description of the latter flag\n---       for further information on dynamic predicates which are also static.\n+--       Defined in all types and subtypes. Set if the type (which must be a\n+--       scalar type) has a predicate whose expression is predicate-static.\n+--       This can result from use of any of a Predicate, Static_Predicate, or\n+--       Dynamic_Predicate aspect. We can distinguish these cases by testing\n+--       Has_Static_Predicate_Aspect and Has_Dynamic_Predicate_Aspect. See\n+--       description of the latter flag for further information on dynamic\n+--       predicates which are also static.\n \n --    Has_Static_Predicate_Aspect (Flag259)\n --       Defined in all types and subtypes. Set if a Static_Predicate aspect"}, {"sha": "5a1c2882d0fd82ed7a5265f6815e1a97495ad997", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -5003,7 +5003,7 @@ package body Exp_Aggr is\n          begin\n             Index := First_Index (Itype);\n             while Present (Index) loop\n-               if not Is_Static_Subtype (Etype (Index)) then\n+               if not Is_OK_Static_Subtype (Etype (Index)) then\n                   Needs_Type := True;\n                   exit;\n                else\n@@ -6634,10 +6634,10 @@ package body Exp_Aggr is\n          Get_Index_Bounds (First_Index (Typ), L1, H1);\n          Get_Index_Bounds (First_Index (Obj_Type), L2, H2);\n \n-         if not Is_Static_Expression (L1)\n-           or else not Is_Static_Expression (L2)\n-           or else not Is_Static_Expression (H1)\n-           or else not Is_Static_Expression (H2)\n+         if not Is_OK_Static_Expression (L1) or else\n+            not Is_OK_Static_Expression (L2) or else\n+            not Is_OK_Static_Expression (H1) or else\n+            not Is_OK_Static_Expression (H2)\n          then\n             return False;\n          else"}, {"sha": "e96f4320e28f4f36a0ad79d31b520b4f2c1b8f81", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -6010,7 +6010,6 @@ package body Exp_Attr is\n          --  it here.\n \n          elsif Do_Range_Check (First (Exprs)) then\n-            Set_Do_Range_Check (First (Exprs), False);\n             Generate_Range_Check (First (Exprs), Etyp, CE_Range_Check_Failed);\n          end if;\n       end Val;"}, {"sha": "38327e904e42cdf2be4c04bc1c61f6815c817849", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -5722,13 +5722,18 @@ package body Exp_Ch3 is\n                elsif Nkind (Expr) /= N_Error then\n                   Apply_Constraint_Check (Expr, Typ);\n \n-                  --  If the expression has been marked as requiring a range\n-                  --  check, generate it now and reset the flag.\n+                  --  Deal with possible range check\n \n                   if Do_Range_Check (Expr) then\n-                     Set_Do_Range_Check (Expr, False);\n \n-                     if not Suppress_Assignment_Checks (N) then\n+                     --  If assignment checks are suppressed, turn off flag\n+\n+                     if Suppress_Assignment_Checks (N) then\n+                        Set_Do_Range_Check (Expr, False);\n+\n+                     --  Otherwise generate the range check\n+\n+                     else\n                         Generate_Range_Check\n                           (Expr, Typ, CE_Range_Check_Failed);\n                      end if;"}, {"sha": "d8ce9611c42b04ab9df6e3a5ac296107b819a375", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1386,7 +1386,6 @@ package body Exp_Ch4 is\n          Apply_Constraint_Check (Exp, T, No_Sliding => True);\n \n          if Do_Range_Check (Exp) then\n-            Set_Do_Range_Check (Exp, False);\n             Generate_Range_Check (Exp, DesigT, CE_Range_Check_Failed);\n          end if;\n \n@@ -1402,7 +1401,6 @@ package body Exp_Ch4 is\n               (Exp, DesigT, No_Sliding => False);\n \n             if Do_Range_Check (Exp) then\n-               Set_Do_Range_Check (Exp, False);\n                Generate_Range_Check (Exp, DesigT, CE_Range_Check_Failed);\n             end if;\n          end if;\n@@ -9650,7 +9648,7 @@ package body Exp_Ch4 is\n                          Nkind (Parent (Entity (Dval))) = N_Object_Declaration\n                        and then Present (Expression (Parent (Entity (Dval))))\n                        and then not\n-                         Is_Static_Expression\n+                         Is_OK_Static_Expression\n                            (Expression (Parent (Entity (Dval))))\n                      then\n                         exit Discr_Loop;\n@@ -10946,6 +10944,7 @@ package body Exp_Ch4 is\n                --  integer type.\n \n                Set_Do_Overflow_Check (N, False);\n+\n                if not Is_Descendent_Of_Address (Etype (Expr))\n                  and then not Is_Descendent_Of_Address (Target_Type)\n                then"}, {"sha": "8c76981933c75afe7fda5b5e552d9168f3e7842c", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1734,7 +1734,6 @@ package body Exp_Ch5 is\n          --  First deal with generation of range check if required\n \n          if Do_Range_Check (Rhs) then\n-            Set_Do_Range_Check (Rhs, False);\n             Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n          end if;\n \n@@ -4061,7 +4060,7 @@ package body Exp_Ch5 is\n \n             function Hi_Val (N : Node_Id) return Node_Id is\n             begin\n-               if Is_Static_Expression (N) then\n+               if Is_OK_Static_Expression (N) then\n                   return New_Copy (N);\n                else\n                   pragma Assert (Nkind (N) = N_Range);\n@@ -4075,7 +4074,7 @@ package body Exp_Ch5 is\n \n             function Lo_Val (N : Node_Id) return Node_Id is\n             begin\n-               if Is_Static_Expression (N) then\n+               if Is_OK_Static_Expression (N) then\n                   return New_Copy (N);\n                else\n                   pragma Assert (Nkind (N) = N_Range);"}, {"sha": "a1d080abe58d9bdc5ff6e3a1b2b404c16d48869a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -2753,7 +2753,6 @@ package body Exp_Ch6 is\n          if Do_Range_Check (Actual)\n            and then Ekind (Formal) = E_In_Parameter\n          then\n-            Set_Do_Range_Check (Actual, False);\n             Generate_Range_Check\n               (Actual, Etype (Formal), CE_Range_Check_Failed);\n          end if;\n@@ -3676,7 +3675,6 @@ package body Exp_Ch6 is\n                      --  check, then generate it here.\n \n                      if Do_Range_Check (Actual) then\n-                        Set_Do_Range_Check (Actual, False);\n                         Generate_Range_Check\n                           (Actual, Etype (Formal), CE_Range_Check_Failed);\n                      end if;"}, {"sha": "29a6e854f01f1aaa96693c218eb3e4a4560d9765", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -11675,7 +11675,7 @@ package body Exp_Ch9 is\n       if Present (Taskdef)\n         and then Has_Storage_Size_Pragma (Taskdef)\n         and then\n-          Is_Static_Expression\n+          Is_OK_Static_Expression\n             (Expression\n                (First (Pragma_Argument_Associations\n                          (Get_Rep_Pragma (TaskId, Name_Storage_Size)))))"}, {"sha": "ddd162f9c5fa19fed6b835c72397fec5085d69b5", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -4241,12 +4241,12 @@ package body Freeze is\n                      if Has_Default_Initialization\n                        or else\n                          (Has_Init_Expression (Decl)\n-                            and then\n-                             (No (Expression (Decl))\n-                                or else not\n-                                  (Is_Static_Expression (Expression (Decl))\n-                                     or else\n-                                   Nkind (Expression (Decl)) = N_Null)))\n+                           and then\n+                            (No (Expression (Decl))\n+                              or else not\n+                                (Is_OK_Static_Expression (Expression (Decl))\n+                                  or else\n+                                    Nkind (Expression (Decl)) = N_Null)))\n                      then\n                         Error_Msg_NE\n                           (\"Thread_Local_Storage variable& is \"\n@@ -5398,7 +5398,7 @@ package body Freeze is\n                Analyze_And_Resolve (Exp, Typ);\n \n                if Etype (Exp) /= Any_Type then\n-                  if not Is_Static_Expression (Exp) then\n+                  if not Is_OK_Static_Expression (Exp) then\n                      Error_Msg_Name_1 := Nam;\n                      Flag_Non_Static_Expr\n                        (\"aspect% requires static expression\", Exp);\n@@ -5647,21 +5647,21 @@ package body Freeze is\n       --  expression, see section \"Handling of Default Expressions\" in the\n       --  spec of package Sem for further details. Note that we have to make\n       --  sure that we actually have a real expression (if we have a subtype\n-      --  indication, we can't test Is_Static_Expression). However, we exclude\n-      --  the case of the prefix of an attribute of a static scalar subtype\n-      --  from this early return, because static subtype attributes should\n-      --  always cause freezing, even in default expressions, but the attribute\n-      --  may not have been marked as static yet (because in Resolve_Attribute,\n-      --  the call to Eval_Attribute follows the call of Freeze_Expression on\n-      --  the prefix).\n+      --  indication, we can't test Is_OK_Static_Expression). However, we\n+      --  exclude the case of the prefix of an attribute of a static scalar\n+      --  subtype from this early return, because static subtype attributes\n+      --  should always cause freezing, even in default expressions, but\n+      --  the attribute may not have been marked as static yet (because in\n+      --  Resolve_Attribute, the call to Eval_Attribute follows the call of\n+      --  Freeze_Expression on the prefix).\n \n       if In_Spec_Exp\n         and then Nkind (N) in N_Subexpr\n-        and then not Is_Static_Expression (N)\n+        and then not Is_OK_Static_Expression (N)\n         and then (Nkind (Parent (N)) /= N_Attribute_Reference\n                    or else not (Is_Entity_Name (N)\n                                  and then Is_Type (Entity (N))\n-                                 and then Is_Static_Subtype (Entity (N))))\n+                                 and then Is_OK_Static_Subtype (Entity (N))))\n       then\n          return;\n       end if;\n@@ -6607,7 +6607,7 @@ package body Freeze is\n       begin\n          Ensure_Type_Is_SA (Etype (N));\n \n-         if Is_Static_Expression (N) then\n+         if Is_OK_Static_Expression (N) then\n             return;\n \n          elsif Nkind (N) = N_Identifier then"}, {"sha": "06cd956ab791f8aedee334de1b910231d59960a1", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -44,6 +44,7 @@ with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Scn;      use Scn;\n+with Sem_Eval; use Sem_Eval;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -697,12 +698,12 @@ package body Lib.Writ is\n                               Write_Info_Name (Chars (Expr));\n \n                            elsif Nkind (Expr) = N_Integer_Literal\n-                             and then Is_Static_Expression (Expr)\n+                             and then Is_OK_Static_Expression (Expr)\n                            then\n                               Write_Info_Uint (Intval (Expr));\n \n                            elsif Nkind (Expr) = N_String_Literal\n-                             and then Is_Static_Expression (Expr)\n+                             and then Is_OK_Static_Expression (Expr)\n                            then\n                               Write_Info_Slit (Strval (Expr));\n "}, {"sha": "517139805d92c076d3a12cc75fa6f347138936d5", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -993,7 +993,7 @@ package body Sem_Aggr is\n            and then not Is_Private_Composite (Typ)\n            and then not Is_Bit_Packed_Array (Typ)\n            and then Nkind (Original_Node (Parent (N))) /= N_String_Literal\n-           and then Is_Static_Subtype (Component_Type (Typ))\n+           and then Is_OK_Static_Subtype (Component_Type (Typ))\n          then\n             declare\n                Expr : Node_Id;\n@@ -1611,10 +1611,12 @@ package body Sem_Aggr is\n          end if;\n \n          --  If the expression has been marked as requiring a range check,\n-         --  then generate it here.\n+         --  then generate it here. It's a bit odd to be generating such\n+         --  checks in the analyzer, but harmless since Generate_Range_Check\n+         --  does nothing (other than making sure Do_Range_Check is set) if\n+         --  the expander is not active.\n \n          if Do_Range_Check (Expr) then\n-            Set_Do_Range_Check (Expr, False);\n             Generate_Range_Check (Expr, Component_Typ, CE_Range_Check_Failed);\n          end if;\n \n@@ -1899,9 +1901,9 @@ package body Sem_Aggr is\n \n                      --  In SPARK, the choice must be static\n \n-                     if not (Is_Static_Expression (Choice)\n+                     if not (Is_OK_Static_Expression (Choice)\n                               or else (Nkind (Choice) = N_Range\n-                                        and then Is_Static_Range (Choice)))\n+                                        and then Is_OK_Static_Range (Choice)))\n                      then\n                         Check_SPARK_Restriction\n                           (\"choice should be static\", Choice);\n@@ -3425,10 +3427,12 @@ package body Sem_Aggr is\n          end if;\n \n          --  If the expression has been marked as requiring a range check, then\n-         --  generate it here.\n+         --  generate it here. It's a bit odd to be generating such checks in\n+         --  the analyzer, but harmless since Generate_Range_Check does nothing\n+         --  (other than making sure Do_Range_Check is set) if the expander is\n+         --  not active.\n \n          if Do_Range_Check (Expr) then\n-            Set_Do_Range_Check (Expr, False);\n             Generate_Range_Check (Expr, Expr_Type, CE_Range_Check_Failed);\n          end if;\n "}, {"sha": "8502c421b1eb9d7656efd5c082918c3ec0c65b51", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 189, "deletions": 113, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -406,7 +406,8 @@ package body Sem_Attr is\n       procedure Standard_Attribute (Val : Int);\n       --  Used to process attributes whose prefix is package Standard which\n       --  yield values of type Universal_Integer. The attribute reference\n-      --  node is rewritten with an integer literal of the given value.\n+      --  node is rewritten with an integer literal of the given value which\n+      --  is marked as static.\n \n       procedure Unexpected_Argument (En : Node_Id);\n       --  Signal unexpected attribute argument (En is the argument)\n@@ -1241,7 +1242,7 @@ package body Sem_Attr is\n             Resolve (E1, Any_Integer);\n             Set_Etype (E1, Standard_Integer);\n \n-            if not Is_Static_Expression (E1)\n+            if not Is_OK_Static_Expression (E1)\n               or else Raises_Constraint_Error (E1)\n             then\n                Flag_Non_Static_Expr\n@@ -1499,7 +1500,7 @@ package body Sem_Attr is\n \n          --  Check non-static subtype\n \n-         if not Is_Static_Subtype (P_Type) then\n+         if not Is_OK_Static_Subtype (P_Type) then\n             Error_Attr_P (\"prefix of % attribute must be a static subtype\");\n          end if;\n \n@@ -2260,6 +2261,7 @@ package body Sem_Attr is\n          Check_Standard_Prefix;\n          Rewrite (N, Make_Integer_Literal (Loc, Val));\n          Analyze (N);\n+         Set_Is_Static_Expression (N, True);\n       end Standard_Attribute;\n \n       -------------------------\n@@ -2312,7 +2314,8 @@ package body Sem_Attr is\n          end if;\n       end if;\n \n-      --  Deal with Ada 2005 attributes that are\n+      --  Deal with Ada 2005 attributes that are implementation attributes\n+      --  because they appear in a version of Ada before Ada 2005.\n \n       if Attribute_05 (Attr_Id) and then Ada_Version < Ada_2005 then\n          Check_Restriction (No_Implementation_Attributes, N);\n@@ -2998,6 +3001,7 @@ package body Sem_Attr is\n          Check_Standard_Prefix;\n          Rewrite (N, Make_String_Literal (Loc, \"GNAT \" & Gnat_Version_String));\n          Analyze_And_Resolve (N, Standard_String);\n+         Set_Is_Static_Expression (N, True);\n \n       --------------------\n       -- Component_Size --\n@@ -3410,8 +3414,7 @@ package body Sem_Attr is\n          else\n             if not Is_Entity_Name (P)\n               or else (not Is_Object (Entity (P))\n-                         and then\n-                       Ekind (Entity (P)) /= E_Enumeration_Literal)\n+                        and then Ekind (Entity (P)) /= E_Enumeration_Literal)\n             then\n                Error_Attr_P\n                  (\"prefix of % attribute must be \" &\n@@ -4256,7 +4259,7 @@ package body Sem_Attr is\n             Resolve (E1, Any_Integer);\n             Set_Etype (E1, Standard_Integer);\n \n-            if not Is_Static_Expression (E1) then\n+            if not Is_OK_Static_Expression (E1) then\n                Flag_Non_Static_Expr\n                  (\"expression for parameter number must be static!\", E1);\n                Error_Attr;\n@@ -5870,6 +5873,7 @@ package body Sem_Attr is\n            Make_String_Literal (Loc,\n              Strval => TN (TN'First .. TL)));\n          Analyze_And_Resolve (N, Standard_String);\n+         Set_Is_Static_Expression (N, True);\n       end Target_Name;\n \n       ----------------\n@@ -5897,7 +5901,11 @@ package body Sem_Attr is\n          Analyze_And_Resolve (E1, Any_Integer);\n          Set_Etype (N, RTE (RE_Address));\n \n-         --  Static expression case, check range and set appropriate type\n+         if Is_Static_Expression (E1) then\n+            Set_Is_Static_Expression (N, True);\n+         end if;\n+\n+         --  OK static expression case, check range and set appropriate type\n \n          if Is_OK_Static_Expression (E1) then\n             Val := Expr_Value (E1);\n@@ -5927,6 +5935,8 @@ package body Sem_Attr is\n                Set_Etype (E1, Standard_Unsigned_64);\n             end if;\n          end if;\n+\n+         Set_Is_Static_Expression (N, True);\n       end To_Address;\n \n       ------------\n@@ -6047,6 +6057,7 @@ package body Sem_Attr is\n          Check_Type;\n          Check_Not_Incomplete_Type;\n          Set_Etype (N, Standard_Boolean);\n+         Set_Is_Static_Expression (N, True);\n \n       ------------------------------\n       -- Universal_Literal_String --\n@@ -6111,6 +6122,7 @@ package body Sem_Attr is\n                Rewrite (N,\n                  Make_String_Literal (Loc, End_String));\n                Analyze (N);\n+               Set_Is_Static_Expression (N, True);\n             end;\n          end if;\n       end Universal_Literal_String;\n@@ -6764,7 +6776,11 @@ package body Sem_Attr is\n       Static : Boolean;\n       --  True if the result is Static. This is set by the general processing\n       --  to true if the prefix is static, and all expressions are static. It\n-      --  can be reset as processing continues for particular attributes\n+      --  can be reset as processing continues for particular attributes. This\n+      --  flag can still be True if the reference raises a constraint error.\n+      --  Is_Static_Expression (N) is set to follow this value as it is set\n+      --  and we could always reference this, but it is convenient to have a\n+      --  simple short name to use, since it is frequently referenced.\n \n       Lo_Bound, Hi_Bound : Node_Id;\n       --  Expressions for low and high bounds of type or array index referenced\n@@ -7098,8 +7114,16 @@ package body Sem_Attr is\n          Lo_Bound := Type_Low_Bound (Ityp);\n          Hi_Bound := Type_High_Bound (Ityp);\n \n+         --  If subtype is non-static, result is definitely non-static\n+\n          if not Is_Static_Subtype (Ityp) then\n             Static := False;\n+            Set_Is_Static_Expression (N, False);\n+\n+         --  Subtype is static, does it raise CE?\n+\n+         elsif not Is_OK_Static_Subtype (Ityp) then\n+            Set_Raises_Constraint_Error (N);\n          end if;\n       end Set_Bounds;\n \n@@ -7125,6 +7149,11 @@ package body Sem_Attr is\n    --  Start of processing for Eval_Attribute\n \n    begin\n+      --  Initialize result as non-static, will be reset if appropriate\n+\n+      Set_Is_Static_Expression (N, False);\n+      Static := False;\n+\n       --  Acquire first two expressions (at the moment, no attributes take more\n       --  than two expressions in any case).\n \n@@ -7191,10 +7220,8 @@ package body Sem_Attr is\n          --  the attribute to the type of the array, but we need a constrained\n          --  type for this, so we use the actual subtype if available.\n \n-         elsif Id = Attribute_First\n-                 or else\n-               Id = Attribute_Last\n-                 or else\n+         elsif Id = Attribute_First or else\n+               Id = Attribute_Last  or else\n                Id = Attribute_Length\n          then\n             declare\n@@ -7234,7 +7261,7 @@ package body Sem_Attr is\n             if Is_Entity_Name (P)\n               and then Known_Alignment (Entity (P))\n             then\n-               Fold_Uint (N, Alignment (Entity (P)), False);\n+               Fold_Uint (N, Alignment (Entity (P)), Static);\n                return;\n \n             else\n@@ -7269,11 +7296,56 @@ package body Sem_Attr is\n          P_Entity := Entity (P);\n       end if;\n \n+      --  If we are asked to evaluate an attribute where the prefix is a\n+      --  non-frozen generic actual type whose RM_Size is still set to zero,\n+      --  then abandon the effort. It seems wrong that this can ever happen,\n+      --  but we see it happen, so this is a defense! ???\n+\n+      if Is_Type (P_Entity)\n+        and then (not Is_Frozen (P_Entity)\n+                   and then Is_Generic_Actual_Type (P_Entity)\n+                   and then RM_Size (P_Entity) = 0)\n+      then\n+         return;\n+      end if;\n+\n       --  At this stage P_Entity is the entity to which the attribute\n       --  is to be applied. This is usually simply the entity of the\n       --  prefix, except in some cases of attributes for objects, where\n       --  as described above, we apply the attribute to the object type.\n \n+      --  Here is where we make sure that static attributes are properly\n+      --  marked as such. These are attributes whose prefix is a static\n+      --  scalar subtype, whose result is scalar, and whose arguments, if\n+      --  present, are static scalar expressions. Note that such references\n+      --  are static expressions even if they raise Constraint_Error.\n+\n+      --  For example, Boolean'Pos (1/0 = 0) is a static expression, even\n+      --  though evaluating it raises constraint error. This means that a\n+      --  declaration like:\n+\n+      --    X : constant := (if True then 1 else Boolean'Pos (1/0 = 0));\n+\n+      --  is legal, since here this expression appears in a statically\n+      --  unevaluated position, so it does not actually raise an exception.\n+\n+      if Is_Scalar_Type (P_Entity)\n+        and then (not Is_Generic_Type (P_Entity))\n+        and then Is_Static_Subtype (P_Entity)\n+        and then Is_Scalar_Type (Etype (N))\n+        and then\n+          (No (E1)\n+            or else (Is_Static_Expression (E1)\n+                      and then Is_Scalar_Type (Etype (E1))))\n+        and then\n+          (No (E2)\n+            or else (Is_Static_Expression (E2)\n+                      and then Is_Scalar_Type (Etype (E1))))\n+      then\n+         Static := True;\n+         Set_Is_Static_Expression (N, True);\n+      end if;\n+\n       --  First foldable possibility is a scalar or array type (RM 4.9(7))\n       --  that is not generic (generic types are eliminated by RM 4.9(25)).\n       --  Note we allow non-static non-generic types at this stage as further\n@@ -7312,28 +7384,19 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n-      --  Definite must be folded if the prefix is not a generic type,\n-      --  that is to say if we are within an instantiation. Same processing\n-      --  applies to the GNAT attributes Atomic_Always_Lock_Free,\n-      --  Has_Discriminants, Lock_Free, Type_Class, Has_Tagged_Value, and\n-      --  Unconstrained_Array.\n+      --  Definite must be folded if the prefix is not a generic type, that\n+      --  is to say if we are within an instantiation. Same processing applies\n+      --  to the GNAT attributes Atomic_Always_Lock_Free, Has_Discriminants,\n+      --  Lock_Free, Type_Class, Has_Tagged_Value, and Unconstrained_Array.\n \n-      elsif (Id = Attribute_Atomic_Always_Lock_Free\n-               or else\n-             Id = Attribute_Definite\n-               or else\n-             Id = Attribute_Has_Access_Values\n-               or else\n-             Id = Attribute_Has_Discriminants\n-               or else\n-             Id = Attribute_Has_Tagged_Values\n-               or else\n-             Id = Attribute_Lock_Free\n-               or else\n-             Id = Attribute_Type_Class\n-               or else\n-             Id = Attribute_Unconstrained_Array\n-               or else\n+      elsif (Id = Attribute_Atomic_Always_Lock_Free or else\n+             Id = Attribute_Definite                or else\n+             Id = Attribute_Has_Access_Values       or else\n+             Id = Attribute_Has_Discriminants       or else\n+             Id = Attribute_Has_Tagged_Values       or else\n+             Id = Attribute_Lock_Free               or else\n+             Id = Attribute_Type_Class              or else\n+             Id = Attribute_Unconstrained_Array     or else\n              Id = Attribute_Max_Alignment_For_Allocation)\n         and then not Is_Generic_Type (P_Entity)\n       then\n@@ -7427,7 +7490,12 @@ package body Sem_Attr is\n       end if;\n \n       if Is_Scalar_Type (P_Type) then\n-         Static := Is_OK_Static_Subtype (P_Type);\n+         if not Is_Static_Subtype (P_Type) then\n+            Static := False;\n+            Set_Is_Static_Expression (N, False);\n+         elsif not Is_OK_Static_Subtype (P_Type) then\n+            Set_Raises_Constraint_Error (N);\n+         end if;\n \n       --  Array case. We enforce the constrained requirement of (RM 4.9(7-8))\n       --  since we can't do anything with unconstrained arrays. In addition,\n@@ -7443,25 +7511,18 @@ package body Sem_Attr is\n       --  unconstrained arrays. Furthermore, it is essential to fold this\n       --  in the packed case, since otherwise the value will be incorrect.\n \n-      elsif Id = Attribute_Atomic_Always_Lock_Free\n-              or else\n-            Id = Attribute_Definite\n-              or else\n-            Id = Attribute_Has_Access_Values\n-              or else\n-            Id = Attribute_Has_Discriminants\n-              or else\n-            Id = Attribute_Has_Tagged_Values\n-              or else\n-            Id = Attribute_Lock_Free\n-              or else\n-            Id = Attribute_Type_Class\n-              or else\n-            Id = Attribute_Unconstrained_Array\n-              or else\n+      elsif Id = Attribute_Atomic_Always_Lock_Free or else\n+            Id = Attribute_Definite                or else\n+            Id = Attribute_Has_Access_Values       or else\n+            Id = Attribute_Has_Discriminants       or else\n+            Id = Attribute_Has_Tagged_Values       or else\n+            Id = Attribute_Lock_Free               or else\n+            Id = Attribute_Type_Class              or else\n+            Id = Attribute_Unconstrained_Array     or else\n             Id = Attribute_Component_Size\n       then\n          Static := False;\n+         Set_Is_Static_Expression (N, False);\n \n       elsif Id /= Attribute_Max_Alignment_For_Allocation then\n          if not Is_Constrained (P_Type)\n@@ -7486,14 +7547,15 @@ package body Sem_Attr is\n          --  which might otherwise accept non-static constants in contexts\n          --  where they are not legal.\n \n-         Static := Ada_Version >= Ada_95\n-                     and then Statically_Denotes_Entity (P);\n+         Static :=\n+           Ada_Version >= Ada_95 and then Statically_Denotes_Entity (P);\n+         Set_Is_Static_Expression (N, Static);\n \n          declare\n-            N : Node_Id;\n+            Nod : Node_Id;\n \n          begin\n-            N := First_Index (P_Type);\n+            Nod := First_Index (P_Type);\n \n             --  The expression is static if the array type is constrained\n             --  by given bounds, and not by an initial expression. Constant\n@@ -7502,21 +7564,28 @@ package body Sem_Attr is\n             if Root_Type (P_Type) /= Standard_String then\n                Static :=\n                  Static and then not Is_Constr_Subt_For_U_Nominal (P_Type);\n+               Set_Is_Static_Expression (N, Static);\n+\n             end if;\n \n-            while Present (N) loop\n-               Static := Static and then Is_Static_Subtype (Etype (N));\n+            while Present (Nod) loop\n+               if not Is_Static_Subtype (Etype (Nod)) then\n+                  Static := False;\n+                  Set_Is_Static_Expression (N, False);\n+               elsif not Is_OK_Static_Subtype (Etype (Nod)) then\n+                  Set_Raises_Constraint_Error (N);\n+               end if;\n \n                --  If however the index type is generic, or derived from\n                --  one, attributes cannot be folded.\n \n-               if Is_Generic_Type (Root_Type (Etype (N)))\n+               if Is_Generic_Type (Root_Type (Etype (Nod)))\n                  and then Id /= Attribute_Component_Size\n                then\n                   return;\n                end if;\n \n-               Next_Index (N);\n+               Next_Index (Nod);\n             end loop;\n          end;\n       end if;\n@@ -7541,6 +7610,11 @@ package body Sem_Attr is\n \n             if not Is_Static_Expression (E) then\n                Static := False;\n+               Set_Is_Static_Expression (N, False);\n+            end if;\n+\n+            if Raises_Constraint_Error (E) then\n+               Set_Raises_Constraint_Error (N);\n             end if;\n \n             --  If the result is not known at compile time, or is not of\n@@ -7601,7 +7675,7 @@ package body Sem_Attr is\n          Set_Raises_Constraint_Error (CE_Node);\n          Check_Expressions;\n          Rewrite (N, Relocate_Node (CE_Node));\n-         Set_Is_Static_Expression (N, Static);\n+         Set_Raises_Constraint_Error (N, True);\n          return;\n       end if;\n \n@@ -7658,7 +7732,7 @@ package body Sem_Attr is\n       ---------\n \n       when Attribute_Aft =>\n-         Fold_Uint (N, Aft_Value (P_Type), True);\n+         Fold_Uint (N, Aft_Value (P_Type), Static);\n \n       ---------------\n       -- Alignment --\n@@ -7671,7 +7745,7 @@ package body Sem_Attr is\n          --  Fold if alignment is set and not otherwise\n \n          if Known_Alignment (P_TypeA) then\n-            Fold_Uint (N, Alignment (P_TypeA), Is_Discrete_Type (P_TypeA));\n+            Fold_Uint (N, Alignment (P_TypeA), Static);\n          end if;\n       end Alignment_Block;\n \n@@ -7710,7 +7784,8 @@ package body Sem_Attr is\n          --  static attribute in GNAT.\n \n          Analyze_And_Resolve (N, Standard_Boolean);\n-         Static := True;\n+            Static := True;\n+            Set_Is_Static_Expression (N, True);\n       end Atomic_Always_Lock_Free;\n \n       ---------\n@@ -7745,7 +7820,7 @@ package body Sem_Attr is\n \n       when Attribute_Component_Size =>\n          if Known_Static_Component_Size (P_Type) then\n-            Fold_Uint (N, Component_Size (P_Type), False);\n+            Fold_Uint (N, Component_Size (P_Type), Static);\n          end if;\n \n       -------------\n@@ -7801,7 +7876,7 @@ package body Sem_Attr is\n \n       when Attribute_Denorm =>\n          Fold_Uint\n-           (N, UI_From_Int (Boolean'Pos (Has_Denormals (P_Type))), True);\n+           (N, UI_From_Int (Boolean'Pos (Has_Denormals (P_Type))), Static);\n \n       ---------------------\n       -- Descriptor_Size --\n@@ -7815,7 +7890,7 @@ package body Sem_Attr is\n       ------------\n \n       when Attribute_Digits =>\n-         Fold_Uint (N, Digits_Value (P_Type), True);\n+         Fold_Uint (N, Digits_Value (P_Type), Static);\n \n       ----------\n       -- Emax --\n@@ -7827,7 +7902,7 @@ package body Sem_Attr is\n \n          --    T'Emax = 4 * T'Mantissa\n \n-         Fold_Uint (N, 4 * Mantissa, True);\n+         Fold_Uint (N, 4 * Mantissa, Static);\n \n       --------------\n       -- Enum_Rep --\n@@ -8153,7 +8228,8 @@ package body Sem_Attr is\n          --  static attribute in GNAT.\n \n          Analyze_And_Resolve (N, Standard_Boolean);\n-         Static := True;\n+            Static := True;\n+            Set_Is_Static_Expression (N, True);\n       end Lock_Free;\n \n       ----------\n@@ -8252,7 +8328,7 @@ package body Sem_Attr is\n          then\n             Fold_Uint (N,\n               UI_Max (0, 1 + (Expr_Value (Hi_Bound) - Expr_Value (Lo_Bound))),\n-              True);\n+              Static);\n          end if;\n \n          --  One more case is where Hi_Bound and Lo_Bound are compile-time\n@@ -8267,14 +8343,14 @@ package body Sem_Attr is\n                 (Lo_Bound, Hi_Bound, Diff'Access, Assume_Valid => False)\n             is\n                when EQ =>\n-                  Fold_Uint (N, Uint_1, False);\n+                  Fold_Uint (N, Uint_1, Static);\n \n                when GT =>\n-                  Fold_Uint (N, Uint_0, False);\n+                  Fold_Uint (N, Uint_0, Static);\n \n                when LT =>\n                   if Diff /= No_Uint then\n-                     Fold_Uint (N, Diff + 1, False);\n+                     Fold_Uint (N, Diff + 1, Static);\n                   end if;\n \n                when others =>\n@@ -8336,14 +8412,14 @@ package body Sem_Attr is\n          --  Always true for fixed-point\n \n          if Is_Fixed_Point_Type (P_Type) then\n-            Fold_Uint (N, True_Value, True);\n+            Fold_Uint (N, True_Value, Static);\n \n          --  Floating point case\n \n          else\n             Fold_Uint (N,\n               UI_From_Int (Boolean'Pos (Machine_Overflows_On_Target)),\n-              True);\n+              Static);\n          end if;\n \n       -------------------\n@@ -8355,15 +8431,15 @@ package body Sem_Attr is\n             if Is_Decimal_Fixed_Point_Type (P_Type)\n               and then Machine_Radix_10 (P_Type)\n             then\n-               Fold_Uint (N, Uint_10, True);\n+               Fold_Uint (N, Uint_10, Static);\n             else\n-               Fold_Uint (N, Uint_2, True);\n+               Fold_Uint (N, Uint_2, Static);\n             end if;\n \n          --  All floating-point type always have radix 2\n \n          else\n-            Fold_Uint (N, Uint_2, True);\n+            Fold_Uint (N, Uint_2, Static);\n          end if;\n \n       ----------------------\n@@ -8389,13 +8465,14 @@ package body Sem_Attr is\n          --  Always False for fixed-point\n \n          if Is_Fixed_Point_Type (P_Type) then\n-            Fold_Uint (N, False_Value, True);\n+            Fold_Uint (N, False_Value, Static);\n \n          --  Else yield proper floating-point result\n \n          else\n             Fold_Uint\n-              (N, UI_From_Int (Boolean'Pos (Machine_Rounds_On_Target)), True);\n+              (N, UI_From_Int (Boolean'Pos (Machine_Rounds_On_Target)),\n+               Static);\n          end if;\n \n       ------------------\n@@ -8409,7 +8486,7 @@ package body Sem_Attr is\n \n       begin\n          if Known_Esize (P_TypeA) then\n-            Fold_Uint (N, Esize (P_TypeA), True);\n+            Fold_Uint (N, Esize (P_TypeA), Static);\n          end if;\n       end Machine_Size;\n \n@@ -8482,7 +8559,7 @@ package body Sem_Attr is\n                      Siz := Siz + 1;\n                   end loop;\n \n-                  Fold_Uint (N, Siz, True);\n+                  Fold_Uint (N, Siz, Static);\n                end;\n \n             else\n@@ -8495,7 +8572,7 @@ package body Sem_Attr is\n          --  Floating-point Mantissa\n \n          else\n-            Fold_Uint (N, Mantissa, True);\n+            Fold_Uint (N, Mantissa, Static);\n          end if;\n \n       ---------\n@@ -8576,7 +8653,7 @@ package body Sem_Attr is\n             end if;\n \n             if Mech < 0 then\n-               Fold_Uint (N, UI_From_Int (Int (-Mech)), True);\n+               Fold_Uint (N, UI_From_Int (Int (-Mech)), Static);\n             end if;\n          end;\n \n@@ -8644,7 +8721,7 @@ package body Sem_Attr is\n       -------------\n \n       when Attribute_Modulus =>\n-         Fold_Uint (N, Modulus (P_Type), True);\n+         Fold_Uint (N, Modulus (P_Type), Static);\n \n       --------------------\n       -- Null_Parameter --\n@@ -8669,7 +8746,7 @@ package body Sem_Attr is\n \n       begin\n          if Known_Esize (P_TypeA) then\n-            Fold_Uint (N, Esize (P_TypeA), True);\n+            Fold_Uint (N, Esize (P_TypeA), Static);\n          end if;\n       end Object_Size;\n \n@@ -8687,14 +8764,14 @@ package body Sem_Attr is\n       --  Scalar types are never passed by reference\n \n       when Attribute_Passed_By_Reference =>\n-         Fold_Uint (N, False_Value, True);\n+         Fold_Uint (N, False_Value, Static);\n \n       ---------\n       -- Pos --\n       ---------\n \n       when Attribute_Pos =>\n-         Fold_Uint (N, Expr_Value (E1), True);\n+         Fold_Uint (N, Expr_Value (E1), Static);\n \n       ----------\n       -- Pred --\n@@ -8782,14 +8859,14 @@ package body Sem_Attr is\n                 (Lo_Bound, Hi_Bound, Diff'Access, Assume_Valid => False)\n             is\n                when EQ =>\n-                  Fold_Uint (N, Uint_1, False);\n+                  Fold_Uint (N, Uint_1, Static);\n \n                when GT =>\n-                  Fold_Uint (N, Uint_0, False);\n+                  Fold_Uint (N, Uint_0, Static);\n \n                when LT =>\n                   if Diff /= No_Uint then\n-                     Fold_Uint (N, Diff + 1, False);\n+                     Fold_Uint (N, Diff + 1, Static);\n                   end if;\n \n                when others =>\n@@ -8802,7 +8879,7 @@ package body Sem_Attr is\n       ---------\n \n       when Attribute_Ref =>\n-         Fold_Uint (N, Expr_Value (E1), True);\n+         Fold_Uint (N, Expr_Value (E1), Static);\n \n       ---------------\n       -- Remainder --\n@@ -8924,7 +9001,7 @@ package body Sem_Attr is\n       -----------\n \n       when Attribute_Scale =>\n-         Fold_Uint (N, Scale_Value (P_Type), True);\n+         Fold_Uint (N, Scale_Value (P_Type), Static);\n \n       -------------\n       -- Scaling --\n@@ -8951,13 +9028,15 @@ package body Sem_Attr is\n \n       --  Size attribute returns the RM size. All scalar types can be folded,\n       --  as well as any types for which the size is known by the front end,\n-      --  including any type for which a size attribute is specified.\n+      --  including any type for which a size attribute is specified. This is\n+      --  one of the places where it is annoying that a size of zero means two\n+      --  things (zero size for scalars, unspecified size for non-scalars).\n \n       when Attribute_Size | Attribute_VADS_Size => Size : declare\n          P_TypeA : constant Entity_Id := Underlying_Type (P_Type);\n \n       begin\n-         if RM_Size (P_TypeA) /= Uint_0 then\n+         if Is_Scalar_Type (P_TypeA) or else RM_Size (P_TypeA) /= Uint_0 then\n \n             --  VADS_Size case\n \n@@ -8982,23 +9061,21 @@ package body Sem_Attr is\n                   if Present (S)\n                     and then Is_OK_Static_Expression (Expression (S))\n                   then\n-                     Fold_Uint (N, Expr_Value (Expression (S)), True);\n+                     Fold_Uint (N, Expr_Value (Expression (S)), Static);\n \n                   --  If no size is specified, then we simply use the object\n                   --  size in the VADS_Size case (e.g. Natural'Size is equal\n                   --  to Integer'Size, not one less).\n \n                   else\n-                     Fold_Uint (N, Esize (P_TypeA), True);\n+                     Fold_Uint (N, Esize (P_TypeA), Static);\n                   end if;\n                end;\n \n             --  Normal case (Size) in which case we want the RM_Size\n \n             else\n-               Fold_Uint (N,\n-                 RM_Size (P_TypeA),\n-                 Static and then Is_Discrete_Type (P_TypeA));\n+               Fold_Uint (N, RM_Size (P_TypeA), Static);\n             end if;\n          end if;\n       end Size;\n@@ -9179,6 +9256,7 @@ package body Sem_Attr is\n \n          Analyze_And_Resolve (N, Standard_Boolean);\n          Static := True;\n+         Set_Is_Static_Expression (N, True);\n       end Unconstrained_Array;\n \n       --  Attribute Update is never static\n@@ -9219,15 +9297,16 @@ package body Sem_Attr is\n       -- Value_Size --\n       ----------------\n \n-      --  The Value_Size attribute for a type returns the RM size of the\n-      --  type. This an always be folded for scalar types, and can also\n-      --  be folded for non-scalar types if the size is set.\n+      --  The Value_Size attribute for a type returns the RM size of the type.\n+      --  This an always be folded for scalar types, and can also be folded for\n+      --  non-scalar types if the size is set. This is one of the places where\n+      --  it is annoying that a size of zero means two things!\n \n       when Attribute_Value_Size => Value_Size : declare\n          P_TypeA : constant Entity_Id := Underlying_Type (P_Type);\n       begin\n-         if RM_Size (P_TypeA) /= Uint_0 then\n-            Fold_Uint (N, RM_Size (P_TypeA), True);\n+         if Is_Scalar_Type (P_TypeA) or else RM_Size (P_TypeA) /= Uint_0 then\n+            Fold_Uint (N, RM_Size (P_TypeA), Static);\n          end if;\n       end Value_Size;\n \n@@ -9293,7 +9372,7 @@ package body Sem_Attr is\n                if Expr_Value_R (Type_High_Bound (P_Type)) <\n                   Expr_Value_R (Type_Low_Bound (P_Type))\n                then\n-                  Fold_Uint (N, Uint_0, True);\n+                  Fold_Uint (N, Uint_0, Static);\n \n                else\n                   --  For floating-point, we have +N.dddE+nnn where length\n@@ -9318,7 +9397,7 @@ package body Sem_Attr is\n                         Len := Len + 8;\n                      end if;\n \n-                     Fold_Uint (N, UI_From_Int (Len), True);\n+                     Fold_Uint (N, UI_From_Int (Len), Static);\n                   end;\n                end if;\n \n@@ -9331,7 +9410,7 @@ package body Sem_Attr is\n                if Expr_Value (Type_High_Bound (P_Type)) <\n                   Expr_Value (Type_Low_Bound  (P_Type))\n                then\n-                  Fold_Uint (N, Uint_0, True);\n+                  Fold_Uint (N, Uint_0, Static);\n \n                --  The non-null case depends on the specific real type\n \n@@ -9340,7 +9419,7 @@ package body Sem_Attr is\n \n                   Fold_Uint\n                     (N, UI_From_Int (Fore_Value + 1) + Aft_Value (P_Type),\n-                     True);\n+                     Static);\n                end if;\n \n             --  Discrete types\n@@ -9517,7 +9596,7 @@ package body Sem_Attr is\n                      end loop;\n                   end if;\n \n-                  Fold_Uint (N, UI_From_Int (W), True);\n+                  Fold_Uint (N, UI_From_Int (W), Static);\n                end;\n             end if;\n          end if;\n@@ -11034,15 +11113,12 @@ package body Sem_Attr is\n \n    procedure Set_Boolean_Result (N : Node_Id; B : Boolean) is\n       Loc : constant Source_Ptr := Sloc (N);\n-\n    begin\n       if B then\n          Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n       else\n          Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n       end if;\n-\n-      Set_Is_Static_Expression (N);\n    end Set_Boolean_Result;\n \n    --------------------------------"}, {"sha": "9a65a05bb4f65d36ae49196d2247540ece8b8b2b", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -355,7 +355,7 @@ package body Sem_Cat is\n       loop\n          if Present (Expression (Component_Decl))\n            and then Nkind (Expression (Component_Decl)) /= N_Null\n-           and then not Is_Static_Expression (Expression (Component_Decl))\n+           and then not Is_OK_Static_Expression (Expression (Component_Decl))\n          then\n             Error_Msg_Sloc := Sloc (Component_Decl);\n             Error_Msg_F\n@@ -815,7 +815,8 @@ package body Sem_Cat is\n       Discriminant_Spec := First (L);\n       while Present (Discriminant_Spec) loop\n          if Present (Expression (Discriminant_Spec))\n-           and then not Is_Static_Expression (Expression (Discriminant_Spec))\n+           and then\n+             not Is_OK_Static_Expression (Expression (Discriminant_Spec))\n          then\n             return False;\n          end if;"}, {"sha": "cd55b58c272bdf90d7098d8553382d9f4d1de436", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -5336,9 +5336,8 @@ package body Sem_Ch12 is\n                Expr2 := Expression (Parent (E2));\n             end if;\n \n-            if Is_Static_Expression (Expr1) then\n-\n-               if not Is_Static_Expression (Expr2) then\n+            if Is_OK_Static_Expression (Expr1) then\n+               if not Is_OK_Static_Expression (Expr2) then\n                   Check_Mismatch (True);\n \n                elsif Is_Discrete_Type (Etype (E1)) then"}, {"sha": "9c9c6dac92ec4275b39d5262ff8f5759cf2c5426", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1688,10 +1688,10 @@ package body Sem_Ch13 is\n                   --  illegal specification of this aspect for a subtype now,\n                   --  to prevent malformed rep_item chains.\n \n-                  if (A_Id = Aspect_Input\n-                       or else A_Id = Aspect_Output\n-                       or else A_Id = Aspect_Read\n-                       or else A_Id = Aspect_Write)\n+                  if (A_Id = Aspect_Input  or else\n+                      A_Id = Aspect_Output or else\n+                      A_Id = Aspect_Read   or else\n+                      A_Id = Aspect_Write)\n                     and not Is_First_Subtype (E)\n                   then\n                      Error_Msg_N\n@@ -1931,7 +1931,7 @@ package body Sem_Ch13 is\n \n                      --  The expression must be static\n \n-                     elsif not Is_Static_Expression (Expr) then\n+                     elsif not Is_OK_Static_Expression (Expr) then\n                         Flag_Non_Static_Expr\n                           (\"aspect requires static expression!\", Expr);\n \n@@ -4227,7 +4227,7 @@ package body Sem_Ch13 is\n                if Etype (Expr) = Any_Type then\n                   return;\n \n-               elsif not Is_Static_Expression (Expr) then\n+               elsif not Is_OK_Static_Expression (Expr) then\n                   Flag_Non_Static_Expr\n                     (\"Bit_Order requires static expression!\", Expr);\n \n@@ -4367,7 +4367,7 @@ package body Sem_Ch13 is\n                   Preanalyze_Spec_Expression (Expr, RTE (RE_CPU_Range));\n                   Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n \n-                  if not Is_Static_Expression (Expr) then\n+                  if not Is_OK_Static_Expression (Expr) then\n                      Check_Restriction (Static_Priorities, Expr);\n                   end if;\n                end if;\n@@ -4466,7 +4466,7 @@ package body Sem_Ch13 is\n             else\n                Analyze_And_Resolve (Expr, Standard_String);\n \n-               if not Is_Static_Expression (Expr) then\n+               if not Is_OK_Static_Expression (Expr) then\n                   Flag_Non_Static_Expr\n                     (\"static string required for tag name!\", Nam);\n                end if;\n@@ -4700,7 +4700,7 @@ package body Sem_Ch13 is\n                   Preanalyze_Spec_Expression (Expr, Standard_Integer);\n                   Uninstall_Discriminants_And_Pop_Scope (U_Ent);\n \n-                  if not Is_Static_Expression (Expr) then\n+                  if not Is_OK_Static_Expression (Expr) then\n                      Check_Restriction (Static_Priorities, Expr);\n                   end if;\n                end if;\n@@ -4741,7 +4741,7 @@ package body Sem_Ch13 is\n                if Etype (Expr) = Any_Type then\n                   return;\n \n-               elsif not Is_Static_Expression (Expr) then\n+               elsif not Is_OK_Static_Expression (Expr) then\n                   Flag_Non_Static_Expr\n                     (\"Scalar_Storage_Order requires static expression!\", Expr);\n \n@@ -4896,7 +4896,7 @@ package body Sem_Ch13 is\n             if Etype (Expr) = Any_Type then\n                return;\n \n-            elsif not Is_Static_Expression (Expr) then\n+            elsif not Is_OK_Static_Expression (Expr) then\n                Flag_Non_Static_Expr\n                  (\"small requires static expression!\", Expr);\n                return;\n@@ -5567,7 +5567,7 @@ package body Sem_Ch13 is\n                      --  ??? should allow static subtype with zero/one entry\n \n                   elsif Etype (Choice) = Base_Type (Enumtype) then\n-                     if not Is_Static_Expression (Choice) then\n+                     if not Is_OK_Static_Expression (Choice) then\n                         Flag_Non_Static_Expr\n                           (\"non-static expression used for choice!\", Choice);\n                         Err := True;\n@@ -6737,7 +6737,7 @@ package body Sem_Ch13 is\n                   while Present (Alt) loop\n                      Dep := Expression (Alt);\n \n-                     if not Is_Static_Expression (Dep) then\n+                     if not Is_OK_Static_Expression (Dep) then\n                         raise Non_Static;\n \n                      elsif Is_True (Expr_Value (Dep)) then\n@@ -6781,7 +6781,7 @@ package body Sem_Ch13 is\n \n       function Hi_Val (N : Node_Id) return Uint is\n       begin\n-         if Is_Static_Expression (N) then\n+         if Is_OK_Static_Expression (N) then\n             return Expr_Value (N);\n          else\n             pragma Assert (Nkind (N) = N_Range);\n@@ -6826,7 +6826,7 @@ package body Sem_Ch13 is\n \n       function Lo_Val (N : Node_Id) return Uint is\n       begin\n-         if Is_Static_Expression (N) then\n+         if Is_OK_Static_Expression (N) then\n             return Expr_Value (N);\n          else\n             pragma Assert (Nkind (N) = N_Range);\n@@ -6860,9 +6860,9 @@ package body Sem_Ch13 is\n          --  Range case\n \n          if Nkind (N) = N_Range then\n-            if not Is_Static_Expression (Low_Bound  (N))\n+            if not Is_OK_Static_Expression (Low_Bound  (N))\n                  or else\n-               not Is_Static_Expression (High_Bound (N))\n+               not Is_OK_Static_Expression (High_Bound (N))\n             then\n                raise Non_Static;\n             else\n@@ -6873,7 +6873,7 @@ package body Sem_Ch13 is\n \n          --  Static expression case\n \n-         elsif Is_Static_Expression (N) then\n+         elsif Is_OK_Static_Expression (N) then\n             Val := Expr_Value (N);\n             return RList'(1 => REnt'(Val, Val));\n \n@@ -6892,7 +6892,7 @@ package body Sem_Ch13 is\n \n                --  For static subtype without predicates, get range\n \n-               elsif Is_Static_Subtype (Entity (N)) then\n+               elsif Is_OK_Static_Subtype (Entity (N)) then\n                   SLo := Expr_Value (Type_Low_Bound  (Entity (N)));\n                   SHi := Expr_Value (Type_High_Bound (Entity (N)));\n                   return RList'(1 => REnt'(SLo, SHi));\n@@ -9606,7 +9606,7 @@ package body Sem_Ch13 is\n                --  issued elsewhere, since sizes of non-static array types\n                --  cannot be set implicitly or explicitly.\n \n-               if not Is_Static_Subtype (Ityp) then\n+               if not Is_OK_Static_Subtype (Ityp) then\n                   return;\n                end if;\n "}, {"sha": "e247e662f4ff824d73f2108a892a291e015c92f6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -3154,7 +3154,7 @@ package body Sem_Ch3 is\n             while Present (X) loop\n                C := Etype (X);\n \n-               if not Is_Static_Subtype (C) then\n+               if not Is_OK_Static_Subtype (C) then\n                   Check_Restriction (Max_Tasks, N);\n                   return Uint_0;\n                else\n@@ -17370,7 +17370,7 @@ package body Sem_Ch3 is\n          --  static, even if its bounds are static.\n \n          if Nkind (I) = N_Subtype_Indication\n-           and then not Is_Static_Subtype (Entity (Subtype_Mark (I)))\n+           and then not Is_OK_Static_Subtype (Entity (Subtype_Mark (I)))\n          then\n             Set_Is_Non_Static_Subtype (Def_Id);\n          end if;\n@@ -18984,7 +18984,7 @@ package body Sem_Ch3 is\n          --  discrete type definition of a loop parameter specification.\n \n          if not In_Iter_Schm\n-           and then not Is_Static_Range (R)\n+           and then not Is_OK_Static_Range (R)\n          then\n             Check_SPARK_Restriction (\"range should be static\", R);\n          end if;"}, {"sha": "81d3841c86a2683923957f715ca8813c7a84f010", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1467,7 +1467,7 @@ package body Sem_Ch4 is\n       --  case expression has not been fully analyzed yet because this may lead\n       --  to bogus errors.\n \n-      if Is_Static_Subtype (Exp_Type)\n+      if Is_OK_Static_Subtype (Exp_Type)\n         and then Has_Static_Predicate_Aspect (Exp_Type)\n         and then In_Spec_Expression\n       then"}, {"sha": "26acb3b0d995cb69b0eb4e02f8a2baecd8bcd82c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -2317,11 +2317,11 @@ package body Sem_Ch5 is\n          --  Propagate staticness to loop range itself, in case the\n          --  corresponding subtype is static.\n \n-         if New_Lo /= Lo and then Is_Static_Expression (New_Lo) then\n+         if New_Lo /= Lo and then Is_OK_Static_Expression (New_Lo) then\n             Rewrite (Low_Bound (R), New_Copy (New_Lo));\n          end if;\n \n-         if New_Hi /= Hi and then Is_Static_Expression (New_Hi) then\n+         if New_Hi /= Hi and then Is_OK_Static_Expression (New_Hi) then\n             Rewrite (High_Bound (R), New_Copy (New_Hi));\n          end if;\n       end Process_Bounds;"}, {"sha": "c29d5c549c169cfa08a58a3c81af48772dafd9b4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -5249,7 +5249,7 @@ package body Sem_Ch6 is\n \n                         elsif Is_Entity_Name (Orig_Expr)\n                           and then Ekind (Entity (Orig_Expr)) = E_Constant\n-                          and then Is_Static_Expression (Orig_Expr)\n+                          and then Is_OK_Static_Expression (Orig_Expr)\n                         then\n                            return OK;\n                         else"}, {"sha": "00f9abe5897624db680e5d0ab002c8a09b5ed64f", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -304,7 +304,8 @@ package body Sem_Ch9 is\n \n                            if Is_Scalar_Type (Etype (Attr))\n                              and then Is_Scalar_Type (Etype (Prefix (Attr)))\n-                             and then Is_Static_Subtype (Etype (Prefix (Attr)))\n+                             and then\n+                               Is_OK_Static_Subtype (Etype (Prefix (Attr)))\n                            then\n                               Para := First (Expressions (Attr));\n \n@@ -389,7 +390,7 @@ package body Sem_Ch9 is\n                      --  static function restricted.\n \n                      elsif Kind = N_Attribute_Reference\n-                       and then not Is_Static_Expression (N)\n+                       and then not Is_OK_Static_Expression (N)\n                        and then not Is_Static_Function (N)\n                      then\n                         if Lock_Free_Given then\n@@ -427,7 +428,7 @@ package body Sem_Ch9 is\n                      --  Non-static function calls restricted\n \n                      elsif Kind = N_Function_Call\n-                       and then not Is_Static_Expression (N)\n+                       and then not Is_OK_Static_Expression (N)\n                      then\n                         if Lock_Free_Given then\n                            Error_Msg_N\n@@ -1557,7 +1558,7 @@ package body Sem_Ch9 is\n                goto Skip_LB;\n             end if;\n \n-            if Is_Static_Expression (LBR)\n+            if Is_OK_Static_Expression (LBR)\n               and then Expr_Value (LBR) < LB\n             then\n                Error_Msg_Uint_1 := LB;\n@@ -1583,7 +1584,7 @@ package body Sem_Ch9 is\n                goto Skip_UB;\n             end if;\n \n-            if Is_Static_Expression (UBR)\n+            if Is_OK_Static_Expression (UBR)\n               and then Expr_Value (UBR) > UB\n             then\n                Error_Msg_Uint_1 := UB;"}, {"sha": "27e1d208585d3f886cdfcdd032d196de88d992b7", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 929, "deletions": 220, "changes": 1149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -123,6 +123,11 @@ package body Sem_Eval is\n       V : Uint;\n    end record;\n \n+   type Match_Result is (Match, No_Match, Non_Static);\n+   --  Result returned from functions that test for a matching result. If the\n+   --  operands are not OK_Static then Non_Static will be returned. Otherwise\n+   --  Match/No_Match is returned depending on whether the match succeeds.\n+\n    type CV_Cache_Array is array (CV_Range) of CV_Entry;\n \n    CV_Cache : CV_Cache_Array := (others => (Node_High_Bound, Uint_0));\n@@ -137,13 +142,70 @@ package body Sem_Eval is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Choice_Matches\n+     (Expr   : Node_Id;\n+      Choice : Node_Id) return Match_Result;\n+   --  Determines whether given value Expr matches the given Choice. The Expr\n+   --  can be of discrete, real, or string type and must be a compile time\n+   --  known value (it is an error to make the call if these conditions are\n+   --  not met). The choice can be a range, subtype name, subtype indication,\n+   --  or expression. The returned result is Non_Static if Choice is not\n+   --  OK_Static, otherwise either Match or No_Match is returned depending\n+   --  on whether Choice matches Expr. This is used for case expression\n+   --  alternatives, and also for membership tests. In each case, more\n+   --  possibilities are tested than the syntax allows (e.g. membership allows\n+   --  subtype indications and non-discrete types, and case allows an OTHERS\n+   --  choice), but it does not matter, since we have already done a full\n+   --  semantic and syntax check of the construct, so the extra possibilities\n+   --  just will not arise for correct expressions.\n+   --\n+   --  Note: if Choice_Matches finds that a choice raises Constraint_Error, e.g\n+   --  a reference to a type, one of whose bounds raises Constraint_Error, then\n+   --  it also sets the Raises_Constraint_Error flag on the Choice itself.\n+\n+   function Choices_Match\n+     (Expr    : Node_Id;\n+      Choices : List_Id) return Match_Result;\n+   --  This function applies Choice_Matches to each element of Choices. If the\n+   --  result is No_Match, then it continues and checks the next element. If\n+   --  the result is Match or Non_Static, this result is immediately given\n+   --  as the result without checking the rest of the list. Expr can be of\n+   --  discrete, real, or string type and must be a compile time known value\n+   --  (it is an error to make the call if these conditions are not met).\n+\n    function From_Bits (B : Bits; T : Entity_Id) return Uint;\n    --  Converts a bit string of length B'Length to a Uint value to be used for\n    --  a target of type T, which is a modular type. This procedure includes the\n    --  necessary reduction by the modulus in the case of a non-binary modulus\n    --  (for a binary modulus, the bit string is the right length any way so all\n    --  is well).\n \n+   function Is_Static_Choice (Choice : Node_Id) return Boolean;\n+   --  Given a choice (from a case expression or membership test), returns\n+   --  True if the choice is static. No test is made for raising of constraint\n+   --  error, so this function is used only for legality tests.\n+\n+   function Is_Static_Choice_List (Choices : List_Id) return Boolean;\n+   --  Given a choice list (from a case expression or membership test), return\n+   --  True if all choices are static in the sense of Is_Static_Choice.\n+\n+   function Is_OK_Static_Choice (Choice : Node_Id) return Boolean;\n+   --  Given a choice (from a case expression or membership test), returns\n+   --  True if the choice is static and does not raise a Constraint_Error.\n+\n+   function Is_OK_Static_Choice_List (Choices : List_Id) return Boolean;\n+   --  Given a choice list (from a case expression or membership test), return\n+   --  True if all choices are static in the sense of Is_OK_Static_Choice.\n+\n+   function Is_Static_Range (N : Node_Id) return Boolean;\n+   --  Determine if range is static, as defined in RM 4.9(26). The only allowed\n+   --  argument is an N_Range node (but note that the semantic analysis of\n+   --  equivalent range attribute references already turned them into the\n+   --  equivalent range). This differs from Is_OK_Static_Range (which is what\n+   --  must be used by clients) in that it does not care whether the bounds\n+   --  raise Constraint_Error or not. Used for checking whether expressions are\n+   --  static in the 4.9 sense (without worrying about exceptions).\n+\n    function Get_String_Val (N : Node_Id) return Node_Id;\n    --  Given a tree node for a folded string or character value, returns the\n    --  corresponding string literal or character literal (one of the two must\n@@ -254,6 +316,73 @@ package body Sem_Eval is\n    procedure To_Bits (U : Uint; B : out Bits);\n    --  Converts a Uint value to a bit string of length B'Length\n \n+   -----------------------------------------------\n+   -- Check_Expression_Against_Static_Predicate --\n+   -----------------------------------------------\n+\n+   procedure Check_Expression_Against_Static_Predicate\n+     (Expr : Node_Id;\n+      Typ  : Entity_Id)\n+   is\n+   begin\n+      --  Nothing to do if expression is not known at compile time, or the\n+      --  type has no static predicate set (will be the case for all non-scalar\n+      --  types, so no need to make a special test for that).\n+\n+      if not (Has_Static_Predicate (Typ)\n+              and then Compile_Time_Known_Value (Expr))\n+      then\n+         return;\n+      end if;\n+\n+      --  Here we have a static predicate (note that it could have arisen from\n+      --  an explicitly specified Dynamic_Predicate whose expression met the\n+      --  rules for being predicate-static).\n+\n+      --  If we are not generating code, nothing more to do (why???)\n+\n+      if Operating_Mode < Generate_Code then\n+         return;\n+      end if;\n+\n+      --  If we have the real case, then for now, not implemented\n+\n+      if not Is_Discrete_Type (Typ) then\n+         Error_Msg_N (\"??real predicate not applied\", Expr);\n+         return;\n+      end if;\n+\n+      --  If static predicate matches, nothing to do\n+\n+      if Choices_Match (Expr, Static_Predicate (Typ)) = Match then\n+         return;\n+      end if;\n+\n+      --  Here we know that the predicate will fail\n+\n+      --  Special case of static expression failing a predicate (other than one\n+      --  that was explicitly specified with a Dynamic_Predicate aspect). This\n+      --  is the case where the expression is no longer considered static.\n+\n+      if Is_Static_Expression (Expr)\n+        and then not Has_Dynamic_Predicate_Aspect (Typ)\n+      then\n+         Error_Msg_NE\n+           (\"??static expression fails static predicate check on &\",\n+            Expr, Typ);\n+         Error_Msg_N\n+           (\"\\??expression is no longer considered static\", Expr);\n+         Set_Is_Static_Expression (Expr, False);\n+\n+      --  In all other cases, this is just a warning that a test will fail.\n+      --  It does not matter if the expression is static or not, or if the\n+      --  predicate comes from a dynamic predicate aspect or not.\n+\n+      else\n+         Error_Msg_NE\n+           (\"??expression fails predicate check on &\", Expr, Typ);\n+      end if;\n+   end Check_Expression_Against_Static_Predicate;\n    ------------------------------\n    -- Check_Non_Static_Context --\n    ------------------------------\n@@ -421,6 +550,167 @@ package body Sem_Eval is\n       end if;\n    end Check_String_Literal_Length;\n \n+   --------------------\n+   -- Choice_Matches --\n+   --------------------\n+\n+   function Choice_Matches\n+     (Expr   : Node_Id;\n+      Choice : Node_Id) return Match_Result\n+   is\n+      Etyp : constant Entity_Id := Etype (Expr);\n+      Val  : Uint;\n+      ValR : Ureal;\n+      ValS : Node_Id;\n+\n+   begin\n+      pragma Assert (Compile_Time_Known_Value (Expr));\n+      pragma Assert (Is_Scalar_Type (Etyp) or else Is_String_Type (Etyp));\n+\n+      if not Is_OK_Static_Choice (Choice) then\n+         Set_Raises_Constraint_Error (Choice);\n+         return Non_Static;\n+\n+      --  Discrete type case\n+\n+      elsif Is_Discrete_Type (Etype (Expr)) then\n+         Val := Expr_Value (Expr);\n+\n+         if Nkind (Choice) = N_Range then\n+            if Val >= Expr_Value (Low_Bound (Choice))\n+                 and then\n+               Val <= Expr_Value (High_Bound (Choice))\n+            then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+\n+         elsif Nkind (Choice) = N_Subtype_Indication\n+           or else\n+             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+         then\n+            if Val >= Expr_Value (Type_Low_Bound  (Etype (Choice)))\n+                 and then\n+               Val <= Expr_Value (Type_High_Bound (Etype (Choice)))\n+            then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+\n+         elsif Nkind (Choice) = N_Others_Choice then\n+            return Match;\n+\n+         else\n+            if Val = Expr_Value (Choice) then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+         end if;\n+\n+         --  Real type case\n+\n+      elsif Is_Real_Type (Etype (Expr)) then\n+         ValR := Expr_Value_R (Expr);\n+\n+         if Nkind (Choice) = N_Range then\n+            if ValR >= Expr_Value_R (Low_Bound  (Choice))\n+                 and then\n+               ValR <= Expr_Value_R (High_Bound (Choice))\n+            then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+\n+         elsif Nkind (Choice) = N_Subtype_Indication\n+           or else\n+             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+         then\n+            if ValR >= Expr_Value_R (Type_Low_Bound  (Etype (Choice)))\n+                 and then\n+               ValR <= Expr_Value_R (Type_High_Bound (Etype (Choice)))\n+            then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+\n+         else\n+            if ValR = Expr_Value_R (Choice) then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+         end if;\n+\n+         --  String type cases\n+\n+      else\n+         pragma Assert (Is_String_Type (Etype (Expr)));\n+         ValS := Expr_Value_S (Expr);\n+\n+         if Nkind (Choice) = N_Subtype_Indication\n+           or else\n+             (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+         then\n+            if not Is_Constrained (Etype (Choice)) then\n+               return Match;\n+\n+            else\n+               declare\n+                  Typlen : constant Uint :=\n+                             String_Type_Len (Etype (Choice));\n+                  Strlen : constant Uint :=\n+                             UI_From_Int (String_Length (Strval (ValS)));\n+               begin\n+                  if Typlen = Strlen then\n+                     return Match;\n+                  else\n+                     return No_Match;\n+                  end if;\n+               end;\n+            end if;\n+\n+         else\n+            if String_Equal (Strval (ValS), Strval (Expr_Value_S (Choice)))\n+            then\n+               return Match;\n+            else\n+               return No_Match;\n+            end if;\n+         end if;\n+      end if;\n+   end Choice_Matches;\n+\n+   -------------------\n+   -- Choices_Match --\n+   -------------------\n+\n+   function Choices_Match\n+     (Expr    : Node_Id;\n+      Choices : List_Id) return Match_Result\n+   is\n+      Choice : Node_Id;\n+      Result : Match_Result;\n+\n+   begin\n+      Choice := First (Choices);\n+      while Present (Choice) loop\n+         Result := Choice_Matches (Expr, Choice);\n+\n+         if Result /= No_Match then\n+            return Result;\n+         end if;\n+\n+         Next (Choice);\n+      end loop;\n+\n+      return No_Match;\n+   end Choices_Match;\n+\n    --------------------------\n    -- Compile_Time_Compare --\n    --------------------------\n@@ -747,9 +1037,9 @@ package body Sem_Eval is\n       --  conditions when this is inappropriate.\n \n       if not (Full_Analysis\n-               or else (Is_Static_Expression (L)\n+               or else (Is_OK_Static_Expression (L)\n                           and then\n-                        Is_Static_Expression (R)))\n+                        Is_OK_Static_Expression (R)))\n       then\n          return Unknown;\n       end if;\n@@ -1565,8 +1855,11 @@ package body Sem_Eval is\n                      Apply_Compile_Time_Constraint_Error\n                        (N, \"division by zero\", CE_Divide_By_Zero,\n                         Warn => not Stat);\n+                     Set_Raises_Constraint_Error (N);\n                      return;\n \n+                  --  Otherwise we can do the division\n+\n                   else\n                      Result := Left_Int / Right_Int;\n                   end if;\n@@ -1744,60 +2037,101 @@ package body Sem_Eval is\n    --------------------------\n \n    --  A conditional expression is static if all its conditions and dependent\n-   --  expressions are static.\n+   --  expressions are static. Note that we do not care if the dependent\n+   --  expressions raise CE, except for the one that will be selected.\n \n    procedure Eval_Case_Expression (N : Node_Id) is\n-      Alt       : Node_Id;\n-      Choice    : Node_Id;\n-      Is_Static : Boolean;\n-      Result    : Node_Id;\n-      Val       : Uint;\n+      Alt    : Node_Id;\n+      Choice : Node_Id;\n \n    begin\n-      Result := Empty;\n-      Is_Static := True;\n+      Set_Is_Static_Expression (N, False);\n \n-      if Is_Static_Expression (Expression (N)) then\n-         Val := Expr_Value (Expression (N));\n-      else\n+      if not Is_Static_Expression (Expression (N)) then\n          Check_Non_Static_Context (Expression (N));\n-         Is_Static := False;\n+         return;\n       end if;\n \n+      --  First loop, make sure all the alternatives are static expressions\n+      --  none of which raise Constraint_Error. We make the constraint error\n+      --  check because part of the legality condition for a correct static\n+      --  case expression is that the cases are covered, like any other case\n+      --  expression. And we can't do that if any of the conditions raise an\n+      --  exception, so we don't even try to evaluate if that is the case.\n+\n       Alt := First (Alternatives (N));\n+      while Present (Alt) loop\n \n-      Search : while Present (Alt) loop\n-         if not Is_Static\n-           or else not Is_Static_Expression (Expression (Alt))\n-         then\n-            Check_Non_Static_Context (Expression (Alt));\n-            Is_Static := False;\n+         --  The expression must be static, but we don't care at this stage\n+         --  if it raises Constraint_Error (the alternative might not match,\n+         --  in which case the expression is statically unevaluated anyway).\n \n-         else\n-            Choice := First (Discrete_Choices (Alt));\n-            while Present (Choice) loop\n-               if Nkind (Choice) = N_Others_Choice then\n-                  Result := Expression (Alt);\n-                  exit Search;\n+         if not Is_Static_Expression (Expression (Alt)) then\n+            Check_Non_Static_Context (Expression (Alt));\n+            return;\n+         end if;\n \n-               elsif Expr_Value (Choice) = Val then\n-                  Result := Expression (Alt);\n-                  exit Search;\n+         --  The choices of a case always have to be static, and cannot raise\n+         --  an exception. If this condition is not met, then the expression\n+         --  is plain illegal, so just abandon evaluation attempts. No need\n+         --  to check non-static context when we have something illegal anyway.\n \n-               else\n-                  Next (Choice);\n-               end if;\n-            end loop;\n+         if not Is_OK_Static_Choice_List (Discrete_Choices (Alt)) then\n+            return;\n          end if;\n \n          Next (Alt);\n-      end loop Search;\n+      end loop;\n \n-      if Is_Static then\n-         Rewrite (N, Relocate_Node (Result));\n+      --  OK, if the above loop gets through it means that all choices are OK\n+      --  static (don't raise exceptions), so the whole case is static, and we\n+      --  can find the matching alternative.\n+\n+      Set_Is_Static_Expression (N);\n+\n+      --  Now to deal with propagating a possible constraint error\n+\n+      --  If the selecting expression raises CE, propagate and we are done\n+\n+      if Raises_Constraint_Error (Expression (N)) then\n+         Set_Raises_Constraint_Error (N);\n+\n+      --  Otherwise we need to check the alternatives to find the matching\n+      --  one. CE's in other than the matching one are not relevant. But we\n+      --  do need to check the matching one. Unlike the first loop, we do not\n+      --  have to go all the way through, when we find the matching one, quit.\n \n       else\n-         Set_Is_Static_Expression (N, False);\n+         Alt := First (Alternatives (N));\n+         Search : loop\n+\n+            --  We must find a match among the alternatives, If not this must\n+            --  be due to other errors, so just ignore, leaving as non-static.\n+\n+            if No (Alt) then\n+               Set_Is_Static_Expression (N, False);\n+               return;\n+            end if;\n+\n+            --  Otherwise loop through choices of this alternative\n+\n+            Choice := First (Discrete_Choices (Alt));\n+            while Present (Choice) loop\n+\n+               --  If we find a matching choice, then the Expression of this\n+               --  alternative replaces N (Raises_Constraint_Error flag is\n+               --  included, so we don't have to special case that).\n+\n+               if Choice_Matches (Expression (N), Choice) = Match then\n+                  Rewrite (N, Relocate_Node (Expression (Alt)));\n+                  return;\n+               end if;\n+\n+               Next (Choice);\n+            end loop;\n+\n+            Next (Alt);\n+         end loop Search;\n       end if;\n    end Eval_Case_Expression;\n \n@@ -2001,8 +2335,17 @@ package body Sem_Eval is\n                 Is_Static_Expression (Then_Expr)\n                   and then\n                 Is_Static_Expression (Else_Expr);\n+      --  True if result is static\n \n    begin\n+      --  If result not static, nothing to do, otherwise set static result\n+\n+      if not Rstat then\n+         return;\n+      else\n+         Set_Is_Static_Expression (N);\n+      end if;\n+\n       --  If any operand is Any_Type, just propagate to result and do not try\n       --  to fold, this prevents cascaded errors.\n \n@@ -2013,50 +2356,47 @@ package body Sem_Eval is\n          Set_Etype (N, Any_Type);\n          Set_Is_Static_Expression (N, False);\n          return;\n+      end if;\n+\n+      --  If condition raises constraint error then we have already signalled\n+      --  an error, and we just propagate to the result and do not fold.\n+\n+      if Raises_Constraint_Error (Condition) then\n+         Set_Raises_Constraint_Error (N);\n+         return;\n+      end if;\n \n       --  Static case where we can fold. Note that we don't try to fold cases\n       --  where the condition is known at compile time, but the result is\n       --  non-static. This avoids possible cases of infinite recursion where\n       --  the expander puts in a redundant test and we remove it. Instead we\n       --  deal with these cases in the expander.\n \n-      elsif Rstat then\n+      --  Select result operand\n \n-         --  Select result operand\n-\n-         if Is_True (Expr_Value (Condition)) then\n-            Result := Then_Expr;\n-            Non_Result := Else_Expr;\n-         else\n-            Result := Else_Expr;\n-            Non_Result := Then_Expr;\n-         end if;\n+      if Is_True (Expr_Value (Condition)) then\n+         Result     := Then_Expr;\n+         Non_Result := Else_Expr;\n+      else\n+         Result     := Else_Expr;\n+         Non_Result := Then_Expr;\n+      end if;\n \n-         --  Note that it does not matter if the non-result operand raises a\n-         --  Constraint_Error, but if the result raises constraint error then\n-         --  we replace the node with a raise constraint error. This will\n-         --  properly propagate Raises_Constraint_Error since this flag is\n-         --  set in Result.\n+      --  Note that it does not matter if the non-result operand raises a\n+      --  Constraint_Error, but if the result raises constraint error then we\n+      --  replace the node with a raise constraint error. This will properly\n+      --  propagate Raises_Constraint_Error since this flag is set in Result.\n \n-         if Raises_Constraint_Error (Result) then\n-            Rewrite_In_Raise_CE (N, Result);\n-            Check_Non_Static_Context (Non_Result);\n+      if Raises_Constraint_Error (Result) then\n+         Rewrite_In_Raise_CE (N, Result);\n+         Check_Non_Static_Context (Non_Result);\n \n-         --  Otherwise the result operand replaces the original node\n-\n-         else\n-            Rewrite (N, Relocate_Node (Result));\n-         end if;\n-\n-      --  Case of condition not known at compile time\n+      --  Otherwise the result operand replaces the original node\n \n       else\n-         Check_Non_Static_Context (Condition);\n-         Check_Non_Static_Context (Then_Expr);\n-         Check_Non_Static_Context (Else_Expr);\n+         Rewrite (N, Relocate_Node (Result));\n+         Set_Is_Static_Expression (N);\n       end if;\n-\n-      Set_Is_Static_Expression (N, Rstat);\n    end Eval_If_Expression;\n \n    ----------------------------\n@@ -2356,132 +2696,78 @@ package body Sem_Eval is\n    procedure Eval_Membership_Op (N : Node_Id) is\n       Left   : constant Node_Id := Left_Opnd (N);\n       Right  : constant Node_Id := Right_Opnd (N);\n-      Def_Id : Entity_Id;\n-      Lo     : Node_Id;\n-      Hi     : Node_Id;\n-      Result : Boolean;\n-      Stat   : Boolean;\n-      Fold   : Boolean;\n+      Alts   : constant List_Id := Alternatives (N);\n+      Result : Match_Result;\n \n    begin\n       --  Ignore if error in either operand, except to make sure that Any_Type\n       --  is properly propagated to avoid junk cascaded errors.\n \n-      if Etype (Left) = Any_Type or else Etype (Right) = Any_Type then\n+      if Etype (Left) = Any_Type\n+        or else (Present (Right) and then Etype (Right) = Any_Type)\n+      then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;\n \n       --  Ignore if types involved have predicates\n+      --  Is this right for static predicates ???\n+      --  And what about the alternatives ???\n \n       if Present (Predicate_Function (Etype (Left)))\n-           or else\n-         Present (Predicate_Function (Etype (Right)))\n+        or else (Present (Right)\n+                  and then Present (Predicate_Function (Etype (Right))))\n       then\n          return;\n       end if;\n \n-      --  Case of right operand is a subtype name\n-\n-      if Is_Entity_Name (Right) then\n-         Def_Id := Entity (Right);\n+      --  If left operand non-static, then nothing to do\n \n-         if (Is_Scalar_Type (Def_Id) or else Is_String_Type (Def_Id))\n-           and then Is_OK_Static_Subtype (Def_Id)\n-         then\n-            Test_Expression_Is_Foldable (N, Left, Stat, Fold);\n+      if not Is_Static_Expression (Left) then\n+         return;\n+      end if;\n \n-            if not Fold or else not Stat then\n-               return;\n-            end if;\n-         else\n-            Check_Non_Static_Context (Left);\n-            return;\n-         end if;\n+      --  If choice is non-static, left operand is in non-static context\n \n-         --  For string membership tests we will check the length further on\n+      if (Present (Right) and then not Is_Static_Choice (Right))\n+        or else (Present (Alts) and then not Is_Static_Choice_List (Alts))\n+      then\n+         Check_Non_Static_Context (Left);\n+         return;\n+      end if;\n \n-         if not Is_String_Type (Def_Id) then\n-            Lo := Type_Low_Bound (Def_Id);\n-            Hi := Type_High_Bound (Def_Id);\n-         else\n-            Lo := Empty;\n-            Hi := Empty;\n-         end if;\n+      --  Otherwise we definitely have a static expression\n \n-      --  Case of right operand is a range\n+      Set_Is_Static_Expression (N);\n \n-      else\n-         if Is_Static_Range (Right) then\n-            Test_Expression_Is_Foldable (N, Left, Stat, Fold);\n+      --  If left operand raises constraint error, propagate and we are done\n \n-            if not Fold or else not Stat then\n-               return;\n+      if Raises_Constraint_Error (Left) then\n+         Set_Raises_Constraint_Error (N, True);\n \n-            --  If one bound of range raises CE, then don't try to fold\n-\n-            elsif not Is_OK_Static_Range (Right) then\n-               Check_Non_Static_Context (Left);\n-               return;\n-            end if;\n+      --  See if we match\n \n+      else\n+         if Present (Right) then\n+            Result := Choice_Matches (Left, Right);\n          else\n-            Check_Non_Static_Context (Left);\n-            return;\n+            Result := Choices_Match (Left, Alts);\n          end if;\n \n-         --  Here we know range is an OK static range\n+         --  If result is Non_Static, it means that we raise Constraint_Error,\n+         --  since we already tested that the operands were themselves static.\n \n-         Lo := Low_Bound (Right);\n-         Hi := High_Bound (Right);\n-      end if;\n-\n-      --  For strings we check that the length of the string expression is\n-      --  compatible with the string subtype if the subtype is constrained,\n-      --  or if unconstrained then the test is always true.\n+         if Result = Non_Static then\n+            Set_Raises_Constraint_Error (N);\n \n-      if Is_String_Type (Etype (Right)) then\n-         if not Is_Constrained (Etype (Right)) then\n-            Result := True;\n+         --  Otherwise we have our result (flipped if NOT IN case)\n \n          else\n-            declare\n-               Typlen : constant Uint := String_Type_Len (Etype (Right));\n-               Strlen : constant Uint :=\n-                          UI_From_Int\n-                            (String_Length (Strval (Get_String_Val (Left))));\n-            begin\n-               Result := (Typlen = Strlen);\n-            end;\n+            Fold_Uint\n+              (N, Test ((Result = Match) xor (Nkind (N) = N_Not_In)), True);\n+            Warn_On_Known_Condition (N);\n          end if;\n-\n-      --  Fold the membership test. We know we have a static range and Lo and\n-      --  Hi are set to the expressions for the end points of this range.\n-\n-      elsif Is_Real_Type (Etype (Right)) then\n-         declare\n-            Leftval : constant Ureal := Expr_Value_R (Left);\n-         begin\n-            Result := Expr_Value_R (Lo) <= Leftval\n-                        and then Leftval <= Expr_Value_R (Hi);\n-         end;\n-\n-      else\n-         declare\n-            Leftval : constant Uint := Expr_Value (Left);\n-         begin\n-            Result := Expr_Value (Lo) <= Leftval\n-                        and then Leftval <= Expr_Value (Hi);\n-         end;\n-      end if;\n-\n-      if Nkind (N) = N_Not_In then\n-         Result := not Result;\n       end if;\n-\n-      Fold_Uint (N, Test (Result), True);\n-\n-      Warn_On_Known_Condition (N);\n    end Eval_Membership_Op;\n \n    ------------------------\n@@ -3297,53 +3583,6 @@ package body Sem_Eval is\n       end if;\n    end Eval_Slice;\n \n-   ---------------------------------\n-   -- Eval_Static_Predicate_Check --\n-   ---------------------------------\n-\n-   function Eval_Static_Predicate_Check\n-     (N   : Node_Id;\n-      Typ : Entity_Id) return Boolean\n-   is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-\n-   begin\n-      --  Discrete type case\n-\n-      if Is_Discrete_Type (Typ) then\n-         declare\n-            Pred : constant List_Id := Static_Predicate (Typ);\n-            Test : Node_Id;\n-\n-         begin\n-            pragma Assert (Present (Pred));\n-\n-            --  The static predicate is a list of alternatives in the proper\n-            --  format for an Ada 2012 membership test. If the argument is a\n-            --  literal, the membership test can be evaluated statically. This\n-            --  is easier than running a full intepretation of the predicate\n-            --  expression, and more efficient in some cases.\n-\n-            Test :=\n-              Make_In (Loc,\n-                Left_Opnd    => New_Copy_Tree (N),\n-                Right_Opnd   => Empty,\n-                Alternatives => Pred);\n-            Analyze_And_Resolve (Test, Standard_Boolean);\n-\n-            return Nkind (Test) = N_Identifier\n-              and then Entity (Test) = Standard_True;\n-         end;\n-\n-      --  Real type case\n-\n-      else\n-         pragma Assert (Is_Real_Type (Typ));\n-         Error_Msg_N (\"??real predicate not applied\", N);\n-         return True;\n-      end if;\n-   end Eval_Static_Predicate_Check;\n-\n    -------------------------\n    -- Eval_String_Literal --\n    -------------------------\n@@ -4092,6 +4331,11 @@ package body Sem_Eval is\n       Typ : constant Entity_Id  := Etype (N);\n \n    begin\n+      if Raises_Constraint_Error (N) then\n+         Set_Is_Static_Expression (N, Static);\n+         return;\n+      end if;\n+\n       Rewrite (N, Make_String_Literal (Loc, Strval => Val));\n \n       --  We now have the literal with the right value, both the actual type\n@@ -4120,6 +4364,11 @@ package body Sem_Eval is\n       Ent : Entity_Id;\n \n    begin\n+      if Raises_Constraint_Error (N) then\n+         Set_Is_Static_Expression (N, Static);\n+         return;\n+      end if;\n+\n       --  If we are folding a named number, retain the entity in the literal,\n       --  for ASIS use.\n \n@@ -4177,6 +4426,11 @@ package body Sem_Eval is\n       Ent : Entity_Id;\n \n    begin\n+      if Raises_Constraint_Error (N) then\n+         Set_Is_Static_Expression (N, Static);\n+         return;\n+      end if;\n+\n       --  If we are folding a named number, retain the entity in the literal,\n       --  for ASIS use.\n \n@@ -4400,6 +4654,60 @@ package body Sem_Eval is\n       end if;\n    end Is_Null_Range;\n \n+   -------------------------\n+   -- Is_OK_Static_Choice --\n+   -------------------------\n+\n+   function Is_OK_Static_Choice (Choice : Node_Id) return Boolean is\n+   begin\n+      --  Check various possibilities for choice\n+\n+      --  Note: for membership tests, we test more cases than are possible\n+      --  (in particular subtype indication), but it doesn't matter because\n+      --  it just won't occur (we have already done a syntax check).\n+\n+      if Nkind (Choice) = N_Others_Choice then\n+         return True;\n+\n+      elsif Nkind (Choice) = N_Range then\n+         return Is_OK_Static_Range (Choice);\n+\n+      elsif Nkind (Choice) = N_Subtype_Indication\n+        or else\n+          (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+      then\n+         return Is_OK_Static_Subtype (Etype (Choice));\n+\n+      else\n+         return Is_OK_Static_Expression (Choice);\n+      end if;\n+   end Is_OK_Static_Choice;\n+\n+   ------------------------------\n+   -- Is_OK_Static_Choice_List --\n+   ------------------------------\n+\n+   function Is_OK_Static_Choice_List (Choices : List_Id) return Boolean is\n+      Choice : Node_Id;\n+\n+   begin\n+      if not Is_Static_Choice_List (Choices) then\n+         return False;\n+      end if;\n+\n+      Choice := First (Choices);\n+      while Present (Choice) loop\n+         if not Is_OK_Static_Choice (Choice) then\n+            Set_Raises_Constraint_Error (Choice);\n+            return False;\n+         end if;\n+\n+         Next (Choice);\n+      end loop;\n+\n+      return True;\n+   end Is_OK_Static_Choice_List;\n+\n    -----------------------------\n    -- Is_OK_Static_Expression --\n    -----------------------------\n@@ -4502,7 +4810,56 @@ package body Sem_Eval is\n                                                                Out_Of_Range;\n    end Is_Out_Of_Range;\n \n-   ---------------------\n+   ----------------------\n+   -- Is_Static_Choice --\n+   ----------------------\n+\n+   function Is_Static_Choice (Choice : Node_Id) return Boolean is\n+   begin\n+      --  Check various possibilities for choice\n+\n+      --  Note: for membership tests, we test more cases than are possible\n+      --  (in particular subtype indication), but it doesn't matter because\n+      --  it just won't occur (we have already done a syntax check).\n+\n+      if Nkind (Choice) = N_Others_Choice then\n+         return True;\n+\n+      elsif Nkind (Choice) = N_Range then\n+         return Is_Static_Range (Choice);\n+\n+      elsif Nkind (Choice) = N_Subtype_Indication\n+        or else\n+          (Is_Entity_Name (Choice) and then Is_Type (Entity (Choice)))\n+      then\n+         return Is_Static_Subtype (Etype (Choice));\n+\n+      else\n+         return Is_Static_Expression (Choice);\n+      end if;\n+   end Is_Static_Choice;\n+\n+   ---------------------------\n+   -- Is_Static_Choice_List --\n+   ---------------------------\n+\n+   function Is_Static_Choice_List (Choices : List_Id) return Boolean is\n+      Choice : Node_Id;\n+\n+   begin\n+      Choice := First (Choices);\n+      while Present (Choice) loop\n+         if not Is_Static_Choice (Choice) then\n+            return False;\n+         end if;\n+\n+         Next (Choice);\n+      end loop;\n+\n+      return True;\n+   end Is_Static_Choice_List;\n+\n+---------------------\n    -- Is_Static_Range --\n    ---------------------\n \n@@ -4513,7 +4870,7 @@ package body Sem_Eval is\n \n    function Is_Static_Range (N : Node_Id) return Boolean is\n    begin\n-      return Is_Static_Expression (Low_Bound (N))\n+      return Is_Static_Expression (Low_Bound  (N))\n                and then\n              Is_Static_Expression (High_Bound (N));\n    end Is_Static_Range;\n@@ -4575,6 +4932,272 @@ package body Sem_Eval is\n       end if;\n    end Is_Static_Subtype;\n \n+   -------------------------------\n+   -- Is_Statically_Unevaluated --\n+   -------------------------------\n+\n+   function Is_Statically_Unevaluated (Expr : Node_Id) return Boolean is\n+      function Check_Case_Expr_Alternative\n+        (CEA : Node_Id) return Match_Result;\n+      --  We have a message emanating from the Expression of a case expression\n+      --  alternative. We examine this alternative, as follows:\n+      --\n+      --  If the selecting expression of the parent case is non-static, or\n+      --  if any of the discrete choices of the given case alternative are\n+      --  non-static or raise Constraint_Error, return Non_Static.\n+      --\n+      --  Otherwise check if the selecting expression matches any of the given\n+      --  discrete choices. If so the alternative is executed and we return\n+      --  Open, otherwise, the alternative can never be executed, and so we\n+      --  return Closed.\n+\n+      ---------------------------------\n+      -- Check_Case_Expr_Alternative --\n+      ---------------------------------\n+\n+      function Check_Case_Expr_Alternative\n+        (CEA : Node_Id) return Match_Result\n+      is\n+         Case_Exp : constant Node_Id := Parent (CEA);\n+         Choice   : Node_Id;\n+         Prev_CEA : Node_Id;\n+\n+      begin\n+         pragma Assert (Nkind (Case_Exp) = N_Case_Expression);\n+\n+         --  Check selecting expression is static\n+\n+         if not Is_OK_Static_Expression (Expression (Case_Exp)) then\n+            return Non_Static;\n+         end if;\n+\n+         if not Is_OK_Static_Choice_List (Discrete_Choices (CEA)) then\n+            return Non_Static;\n+         end if;\n+\n+         --  All choices are now known to be static. Now see if alternative\n+         --  matches one of the choices.\n+\n+         Choice := First (Discrete_Choices (CEA));\n+         while Present (Choice) loop\n+\n+            --  Check various possibilities for choice, returning Closed if we\n+            --  find the selecting value matches any of the choices. Note that\n+            --  we know we are the last choice, so we don't have to keep going.\n+\n+            if Nkind (Choice) = N_Others_Choice then\n+\n+               --  Others choice is a bit annoying, it matches if none of the\n+               --  previous alternatives matches (note that we know we are the\n+               --  last alternative in this case, so we can just go backwards\n+               --  from us to see if any previous one matches).\n+\n+               Prev_CEA := Prev (CEA);\n+               while Present (Prev_CEA) loop\n+                  if Check_Case_Expr_Alternative (Prev_CEA) = Match then\n+                     return No_Match;\n+                  end if;\n+\n+                  Prev (Prev_CEA);\n+               end loop;\n+\n+               return Match;\n+\n+            --  Else we have a normal static choice\n+\n+            elsif Choice_Matches (Expression (Case_Exp), Choice) = Match then\n+               return Match;\n+            end if;\n+\n+            --  If we fall through, it means that the discrete choice did not\n+            --  match the selecting expression, so continue.\n+\n+            Next (Choice);\n+         end loop;\n+\n+         --  If we get through that loop then all choices were static, and\n+         --  none of them matched the selecting expression. So return Closed.\n+\n+         return No_Match;\n+      end Check_Case_Expr_Alternative;\n+\n+      --  Local variables\n+\n+      P      : Node_Id;\n+      OldP   : Node_Id;\n+      Choice : Node_Id;\n+\n+   --  Start of processing for Is_Statically_Unevaluated\n+\n+   begin\n+      --  The (32.x) references here are from RM section 4.9\n+\n+      --  (32.1) An expression is statically unevaluated if it is part of ...\n+\n+      --  This means we have to climb the tree looking for one of the cases\n+\n+      P := Expr;\n+      loop\n+         OldP := P;\n+         P := Parent (P);\n+\n+         --  (32.2) The right operand of a static short-circuit control form\n+         --  whose value is determined by its left operand.\n+\n+         --  AND THEN with False as left operand\n+\n+         if Nkind (P) = N_And_Then\n+           and then Compile_Time_Known_Value (Left_Opnd (P))\n+           and then Is_False (Expr_Value (Left_Opnd (P)))\n+         then\n+            return True;\n+\n+         --  OR ELSE with True as left operand\n+\n+         elsif Nkind (P) = N_Or_Else\n+           and then Compile_Time_Known_Value (Left_Opnd (P))\n+           and then Is_True (Expr_Value (Left_Opnd (P)))\n+         then\n+            return True;\n+\n+         --  (32.3) A dependent_expression of an if_expression whose associated\n+         --  condition is static and equals False.\n+\n+         elsif Nkind (P) = N_If_Expression then\n+            declare\n+               Cond : constant Node_Id := First (Expressions (P));\n+               Texp : constant Node_Id := Next (Cond);\n+               Fexp : constant Node_Id := Next (Texp);\n+\n+            begin\n+               if Compile_Time_Known_Value (Cond) then\n+\n+                  --  Condition is True and we are in the right operand\n+\n+                  if Is_True (Expr_Value (Cond)) and then OldP = Fexp then\n+                     return True;\n+\n+                  --  Condition is False and we are in the left operand\n+\n+                  elsif Is_False (Expr_Value (Cond)) and then OldP = Texp then\n+                     return True;\n+                  end if;\n+               end if;\n+            end;\n+\n+         --  (32.4) A condition or dependent_expression of an if_expression\n+         --  where the condition corresponding to at least one preceding\n+         --  dependent_expression of the if_expression is static and equals\n+         --  True.\n+\n+         --  This refers to cases like\n+\n+         --    (if 1 then 1 elsif 1/0=2 then 2 else 3)\n+\n+         --  But we expand elsif's out anyway, so the above looks like:\n+\n+         --    (if 1 then 1 else (if 1/0=2 then 2 else 3))\n+\n+         --  So for us this is caught by the above check for the 32.3 case.\n+\n+         --  (32.5) A dependent_expression of a case_expression whose\n+         --  selecting_expression is static and whose value is not covered\n+         --  by the corresponding discrete_choice_list.\n+\n+         elsif Nkind (P) = N_Case_Expression_Alternative then\n+\n+            --  First, we have to be in the expression to suppress messages.\n+            --  If we are within one of the choices, we want the message.\n+\n+            if OldP = Expression (P) then\n+\n+               --  Statically unevaluated if alternative does not match\n+\n+               if Check_Case_Expr_Alternative (P) = No_Match then\n+                  return True;\n+               end if;\n+            end if;\n+\n+         --  (32.6) A choice_expression (or a simple_expression of a range\n+         --  that occurs as a membership_choice of a membership_choice_list)\n+         --  of a static membership test that is preceded in the enclosing\n+         --  membership_choice_list by another item whose individual\n+         --  membership test (see (RM 4.5.2)) statically yields True.\n+\n+         elsif Nkind (P) in N_Membership_Test then\n+\n+            --  Only possibly unevaluated if simple expression is static\n+\n+            if not Is_OK_Static_Expression (Left_Opnd (P)) then\n+               null;\n+\n+            --  All members of the choice list must be static\n+\n+            elsif (Present (Right_Opnd (P))\n+                    and then not Is_OK_Static_Choice (Right_Opnd (P)))\n+              or else (Present (Alternatives (P))\n+                        and then\n+                          not Is_OK_Static_Choice_List (Alternatives (P)))\n+            then\n+               null;\n+\n+            --  If expression is the one and only alternative, then it is\n+            --  definitely not statically unevaluated, so we only have to\n+            --  test the case where there are alternatives present.\n+\n+            elsif Present (Alternatives (P)) then\n+\n+               --  Look for previous matching Choice\n+\n+               Choice := First (Alternatives (P));\n+               while Present (Choice) loop\n+\n+                  --  If we reached us and no previous choices matched, this\n+                  --  is not the case where we are statically unevaluated.\n+\n+                  exit when OldP = Choice;\n+\n+                  --  If a previous choice matches, then that is the case where\n+                  --  we know our choice is statically unevaluated.\n+\n+                  if Choice_Matches (Left_Opnd (P), Choice) = Match then\n+                     return True;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               --  If we fall through the loop, we were not one of the choices,\n+               --  we must have been the expression, so that is not covered by\n+               --  this rule, and we keep going.\n+\n+               null;\n+            end if;\n+         end if;\n+\n+         --  OK, not statically unevaluated at this level, see if we should\n+         --  keep climbing to look for a higher level reason.\n+\n+         --  Special case for component association in aggregates, where\n+         --  we want to keep climbing up to the parent aggregate.\n+\n+         if Nkind (P) = N_Component_Association\n+           and then Nkind (Parent (P)) = N_Aggregate\n+         then\n+            null;\n+\n+         --  All done if not still within subexpression\n+\n+         else\n+            exit when Nkind (P) not in N_Subexpr;\n+         end if;\n+      end loop;\n+\n+      --  If we fall through the loop, not one of the cases covered!\n+\n+      return False;\n+   end Is_Statically_Unevaluated;\n+\n    --------------------\n    -- Not_Null_Range --\n    --------------------\n@@ -4703,14 +5326,19 @@ package body Sem_Eval is\n    -------------------------\n \n    procedure Rewrite_In_Raise_CE (N : Node_Id; Exp : Node_Id) is\n-      Typ : constant Entity_Id := Etype (N);\n+      Typ  : constant Entity_Id := Etype (N);\n+      Stat : constant Boolean   := Is_Static_Expression (N);\n \n    begin\n-      --  If we want to raise CE in the condition of a N_Raise_CE node\n-      --  we may as well get rid of the condition.\n+      --  If we want to raise CE in the condition of a N_Raise_CE node, we\n+      --  can just clear the condition if the reason is appropriate. We do\n+      --  not do this operation if the parent has a reason other than range\n+      --  check failed, because otherwise we would change the reason.\n \n       if Present (Parent (N))\n         and then Nkind (Parent (N)) = N_Raise_Constraint_Error\n+        and then Reason (Parent (N)) =\n+                   UI_From_Int (RT_Exception_Code'Pos (CE_Range_Check_Failed))\n       then\n          Set_Condition (Parent (N), Empty);\n \n@@ -4721,7 +5349,7 @@ package body Sem_Eval is\n          Rewrite (N, Exp);\n          Set_Etype (N, Typ);\n \n-      --  Else build an explcit N_Raise_CE\n+      --  Else build an explicit N_Raise_CE\n \n       else\n          Rewrite (N,\n@@ -4730,6 +5358,11 @@ package body Sem_Eval is\n          Set_Raises_Constraint_Error (N);\n          Set_Etype (N, Typ);\n       end if;\n+\n+      --  Set proper flags in result\n+\n+      Set_Raises_Constraint_Error (N, True);\n+      Set_Is_Static_Expression (N, Stat);\n    end Rewrite_In_Raise_CE;\n \n    ---------------------\n@@ -4772,9 +5405,9 @@ package body Sem_Eval is\n \n          --  If either subtype is nonstatic then they're not compatible\n \n-         elsif not Is_Static_Subtype (T1)\n+         elsif not Is_OK_Static_Subtype (T1)\n                  or else\n-               not Is_Static_Subtype (T2)\n+               not Is_OK_Static_Subtype (T2)\n          then\n             return False;\n \n@@ -4952,8 +5585,8 @@ package body Sem_Eval is\n             --  Otherwise bounds must be static and identical value\n \n             else\n-               if not Is_Static_Subtype (T1)\n-                 or else not Is_Static_Subtype (T2)\n+               if not Is_OK_Static_Subtype (T1)\n+                 or else not Is_OK_Static_Subtype (T2)\n                then\n                   return False;\n \n@@ -5041,8 +5674,8 @@ package body Sem_Eval is\n                      Expr2 : constant Node_Id := Node (DA2);\n \n                   begin\n-                     if not Is_Static_Expression (Expr1)\n-                       or else not Is_Static_Expression (Expr2)\n+                     if not Is_OK_Static_Expression (Expr1)\n+                       or else not Is_OK_Static_Expression (Expr2)\n                      then\n                         return False;\n \n@@ -5445,6 +6078,8 @@ package body Sem_Eval is\n       N   : constant Node_Id   := Original_Node (Expr);\n       Typ : Entity_Id;\n       E   : Entity_Id;\n+      Alt : Node_Id;\n+      Exp : Node_Id;\n \n       procedure Why_Not_Static_List (L : List_Id);\n       --  A version that can be called on a list of expressions. Finds all\n@@ -5488,6 +6123,76 @@ package body Sem_Eval is\n          --  Test for constraint error raised\n \n          if Raises_Constraint_Error (Expr) then\n+\n+            --  Special case membership to find out which piece to flag\n+\n+            if Nkind (N) in N_Membership_Test then\n+               if Raises_Constraint_Error (Left_Opnd (N)) then\n+                  Why_Not_Static (Left_Opnd (N));\n+                  return;\n+\n+               elsif Present (Right_Opnd (N))\n+                 and then Raises_Constraint_Error (Right_Opnd (N))\n+               then\n+                  Why_Not_Static (Right_Opnd (N));\n+                  return;\n+\n+               else\n+                  pragma Assert (Present (Alternatives (N)));\n+\n+                  Alt := First (Alternatives (N));\n+                  while Present (Alt) loop\n+                     if Raises_Constraint_Error (Alt) then\n+                        Why_Not_Static (Alt);\n+                        return;\n+                     else\n+                        Next (Alt);\n+                     end if;\n+                  end loop;\n+               end if;\n+\n+            --  Special case a range to find out which bound to flag\n+\n+            elsif Nkind (N) = N_Range then\n+               if Raises_Constraint_Error (Low_Bound (N)) then\n+                  Why_Not_Static (Low_Bound (N));\n+                  return;\n+\n+               elsif Raises_Constraint_Error (High_Bound (N)) then\n+                  Why_Not_Static (High_Bound (N));\n+                  return;\n+               end if;\n+\n+            --  Special case attribute to see which part to flag\n+\n+            elsif Nkind (N) = N_Attribute_Reference then\n+               if Raises_Constraint_Error (Prefix (N)) then\n+                  Why_Not_Static (Prefix (N));\n+                  return;\n+               end if;\n+\n+               if Present (Expressions (N)) then\n+                  Exp := First (Expressions (N));\n+                  while Present (Exp) loop\n+                     if Raises_Constraint_Error (Exp) then\n+                        Why_Not_Static (Exp);\n+                        return;\n+                     end if;\n+\n+                     Next (Exp);\n+                  end loop;\n+               end if;\n+\n+            --  Special case a subtype name\n+\n+            elsif Is_Entity_Name (Expr) and then Is_Type (Entity (Expr)) then\n+               Error_Msg_NE\n+                 (\"!& is not a static subtype (RM 4.9(26))\", N, Entity (Expr));\n+               return;\n+            end if;\n+\n+            --  End of special cases\n+\n             Error_Msg_N\n               (\"!expression raises exception, cannot be static (RM 4.9(34))\",\n                N);\n@@ -5584,6 +6289,10 @@ package body Sem_Eval is\n                   end if;\n                end Entity_Case;\n \n+            elsif Is_Type (E) then\n+               Error_Msg_NE\n+                 (\"!& is not a static subtype (RM 4.9(26))\", N, E);\n+\n             else\n                Error_Msg_NE\n                  (\"!& is not static constant or named number \"\n@@ -5653,7 +6362,7 @@ package body Sem_Eval is\n                  (\"!attribute of generic type is never static \"\n                   & \"(RM 4.9(7,8))\", N);\n \n-            elsif Is_Static_Subtype (E) then\n+            elsif Is_OK_Static_Subtype (E) then\n                null;\n \n             elsif Is_Scalar_Type (E) then\n@@ -5747,7 +6456,7 @@ package body Sem_Eval is\n             Why_Not_Static (Expression (N));\n \n             if not Is_Scalar_Type (Entity (Subtype_Mark (N)))\n-              or else not Is_Static_Subtype (Entity (Subtype_Mark (N)))\n+              or else not Is_OK_Static_Subtype (Entity (Subtype_Mark (N)))\n             then\n                Error_Msg_N\n                  (\"!static conversion requires static scalar subtype result \""}, {"sha": "b4dbec80a575fc16e34dadff5c5f76bf2659a498", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 74, "deletions": 32, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -63,17 +63,38 @@ package Sem_Eval is\n    --      (i.e. the flag is accurate for static expressions, and conservative\n    --      for non-static expressions.\n \n-   --  If a static expression does not raise constraint error, then the\n-   --  Raises_Constraint_Error flag is off, and the expression must be computed\n-   --  at compile time, which means that it has the form of either a literal,\n-   --  or a constant that is itself (recursively) either a literal or a\n-   --  constant.\n+   --  If a static expression does not raise constraint error, then it will\n+   --  have the flag Raises_Constraint_Error flag False, and the expression\n+   --  must be computed at compile time, which means that it has the form of\n+   --  either a literal, or a constant that is itself (recursively) either a\n+   --  literal or a constant.\n \n    --  The above rules must be followed exactly in order for legality checks to\n    --  be accurate. For subexpressions that are not static according to the RM\n    --  definition, they are sometimes folded anyway, but of course in this case\n    --  Is_Static_Expression is not set.\n \n+   --  When we are analyzing and evaluating static expressions, we proopagate\n+   --  both flags accurately. Usually if a subexpression raises a constraint\n+   --  error, then so will its parent expression, and Raise_Constraint_Error\n+   --  will be propagated to this parent. The exception is conditional cases\n+   --  like (True or else 1/0 = 0) which results in an expresion that has the\n+   --  Is_Static_Expression flag True, and Raises_Constraint_Error False. Even\n+   --  though 1/0 would raise an exception, the right operand is never actually\n+   --  executed, so the expression as a whole does not raise CE.\n+\n+   --  For constructs in the language where static expressions are part of the\n+   --  required semantics, we need an expression that meets the 4.9 rules and\n+   --  does not raise CE. So nearly everywhere, callers should call function\n+   --  Is_OK_Static_Expression rather than Is_Static_Expression.\n+\n+   --  Finally, the case of static predicates. These are applied only to entire\n+   --  expressions, not to subexpressions, so we do not have the case of having\n+   --  to propagate this information. We handle this case simply by resetting\n+   --  the Is_Static_Expression flag if a static predicate fails. Note that we\n+   --  can't use this simpler approach for the constraint error case because of\n+   --  the (True or else 1/0 = 0) example discussed above.\n+\n    -------------------------------\n    -- Compile-Time Known Values --\n    -------------------------------\n@@ -107,6 +128,17 @@ package Sem_Eval is\n    -- Subprograms --\n    -----------------\n \n+   procedure Check_Expression_Against_Static_Predicate\n+     (Expr : Node_Id;\n+      Typ  : Entity_Id);\n+   --  Determine whether an arbitrary expression satisfies the static predicate\n+   --  of a type. The routine does nothing if Expr is not known at compile time\n+   --  or Typ lacks a static predicate, otherwise it may emit a warning if the\n+   --  expression is prohibited by the predicate. If the expression is a static\n+   --  expression and it fails a predicate that was not explicitly stated to be\n+   --  a dynamic predicate, then an additional warning is given, and the flag\n+   --  Is_Static_Expression is reset on Expr.\n+\n    procedure Check_Non_Static_Context (N : Node_Id);\n    --  Deals with the special check required for a static expression that\n    --  appears in a non-static context, i.e. is not part of a larger static\n@@ -181,18 +213,14 @@ package Sem_Eval is\n    --  for compile time evaluation purposes. Use Compile_Time_Known_Value\n    --  instead (see section on \"Compile-Time Known Values\" above).\n \n-   function Is_Static_Range (N : Node_Id) return Boolean;\n-   --  Determine if range is static, as defined in RM 4.9(26). The only allowed\n-   --  argument is an N_Range node (but note that the semantic analysis of\n-   --  equivalent range attribute references already turned them into the\n-   --  equivalent range).\n-\n    function Is_OK_Static_Range (N : Node_Id) return Boolean;\n-   --  Like Is_Static_Range, but also makes sure that the bounds of the range\n-   --  are compile-time evaluable (i.e. do not raise constraint error). A\n-   --  result of true means that the bounds are compile time evaluable. A\n-   --  result of false means they are not (either because the range is not\n-   --  static, or because one or the other bound raises CE).\n+   --  Determines if range is static, as defined in RM 4.9(26), and also checks\n+   --  that neither bound of the range raises constraint error, thus ensuring\n+   --  that both bounds of the range are compile-time evaluable (i.e. do not\n+   --  raise constraint error). A result of true means that the bounds are\n+   --  compile time evaluable. A result of false means they are not (either\n+   --  because the range is not static, or because one or the other bound\n+   --  raises CE).\n \n    function Is_Static_Subtype (Typ : Entity_Id) return Boolean;\n    --  Determines whether a subtype fits the definition of an Ada static\n@@ -205,13 +233,27 @@ package Sem_Eval is\n    --  Implementation note: an attempt to include this Ada 2012 case failed,\n    --  since it appears that this routine is called in some cases before the\n    --  Static_Predicate field is set ???\n+   --\n+   --  This differs from Is_OK_Static_Subtype (which is what must be used by\n+   --  clients) in that it does not care whether the bounds raise a constraint\n+   --  error exception or not. Used for checking whether expressions are static\n+   --  in the 4.9 sense (without worrying about exceptions).\n \n    function Is_OK_Static_Subtype (Typ : Entity_Id) return Boolean;\n-   --  Like Is_Static_Subtype but also makes sure that the bounds of the\n-   --  subtype are compile-time evaluable (i.e. do not raise constraint error).\n-   --  A result of true means that the bounds are compile time evaluable. A\n-   --  result of false means they are not (either because the range is not\n-   --  static, or because one or the other bound raises CE).\n+   --  Determines whether a subtype fits the definition of an Ada static\n+   --  subtype as given in (RM 4.9(26)) with the additional check that neither\n+   --  bound raises constraint error (meaning that Expr_Value[_R|S] can be used\n+   --  on these bounds. Important note: This check does not include the Ada\n+   --  2012 case of a non-static predicate which results in an otherwise static\n+   --  subtype being non-static. Such a subtype will return True for this test,\n+   --  so if the distinction is important, the caller must deal with this.\n+   --\n+   --  Implementation note: an attempt to include this Ada 2012 case failed,\n+   --  since it appears that this routine is called in some cases before the\n+   --  Static_Predicate field is set ???\n+   --\n+   --  This differs from Is_Static_Subtype in that it includes the constraint\n+   --  error checks, which are missing from Is_Static_Subtype.\n \n    function Subtypes_Statically_Compatible\n      (T1                      : Entity_Id;\n@@ -364,14 +406,6 @@ package Sem_Eval is\n    procedure Eval_Unary_Op               (N : Node_Id);\n    procedure Eval_Unchecked_Conversion   (N : Node_Id);\n \n-   function Eval_Static_Predicate_Check\n-     (N   : Node_Id;\n-      Typ : Entity_Id) return Boolean;\n-   --  Evaluate a static predicate check applied expression which represents\n-   --  a value that is known at compile time (does not have to be static). The\n-   --  caller has checked that a static predicate does apply to Typ, and thus\n-   --  the type is known to be scalar.\n-\n    procedure Fold_Str (N : Node_Id; Val : String_Id; Static : Boolean);\n    --  Rewrite N with a new N_String_Literal node as the result of the compile\n    --  time evaluation of the node N. Val is the resulting string value from\n@@ -381,7 +415,8 @@ package Sem_Eval is\n    --  static). The point here is that normally all string literals are static,\n    --  but if this was the result of some sequence of evaluation where values\n    --  were known at compile time but not static, then the result is not\n-   --  static.\n+   --  static. The call has no effect if Raises_Constraint_Error (N) is True,\n+   --  since there is no point in folding if we have an error.\n \n    procedure Fold_Uint (N : Node_Id; Val : Uint; Static : Boolean);\n    --  Rewrite N with a (N_Integer_Literal, N_Identifier, N_Character_Literal)\n@@ -393,7 +428,8 @@ package Sem_Eval is\n    --  consider static). The point here is that normally all integer literals\n    --  are static, but if this was the result of some sequence of evaluation\n    --  where values were known at compile time but not static, then the result\n-   --  is not static.\n+   --  is not static. The call has no effect if Raises_Constraint_Error (N) is\n+   --  True, since there is no point in folding if we have an error.\n \n    procedure Fold_Ureal (N : Node_Id; Val : Ureal; Static : Boolean);\n    --  Rewrite N with a new N_Real_Literal node as the result of the compile\n@@ -404,6 +440,8 @@ package Sem_Eval is\n    --  The point here is that normally all string literals are static, but if\n    --  this was the result of some sequence of evaluation where values were\n    --  known at compile time but not static, then the result is not static.\n+   --  The call has no effect if Raises_Constraint_Error (N) is True, since\n+   --  there is no point in folding if we have an error.\n \n    function Is_In_Range\n      (N            : Node_Id;\n@@ -460,6 +498,10 @@ package Sem_Eval is\n    --  cannot (because the value of Lo or Hi is not known at compile time) then\n    --  it returns False.\n \n+   function Is_Statically_Unevaluated (Expr : Node_Id) return Boolean;\n+   --  This function returns True if the given expression Expr is statically\n+   --  unevaluated, as defined in (RM 4.9 (32.1-32.6)).\n+\n    function Not_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n    --  Returns True if it can guarantee that Lo .. Hi is not a null range. If\n    --  it cannot (because the value of Lo or Hi is not known at compile time)\n@@ -487,7 +529,7 @@ package Sem_Eval is\n    --\n    --  Note that these messages are not continuation messages, instead they are\n    --  separate unconditional messages, marked with '!'. The reason for this is\n-   --  that they can be posted at a different location from the maim message as\n+   --  that they can be posted at a different location from the main message as\n    --  documented above (\"appropriate offending component\"), and continuation\n    --  messages must always point to the same location as the parent message.\n "}, {"sha": "cfd6f04c7264a8b815d2a776ed22e268a55d20dc", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -137,7 +137,7 @@ package body Sem_Intr is\n             null;\n \n          elsif Nkind (Arg1) /= N_String_Literal\n-           and then not Is_Static_Expression (Arg1)\n+           and then not Is_OK_Static_Expression (Arg1)\n          then\n             Error_Msg_FE\n               (\"call to & requires static string argument!\", N, Nam);"}, {"sha": "b38d9a3fafc4431cd5a76c669cacc377f4deab96", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1852,7 +1852,7 @@ package body Sem_Prag is\n       if Present (Expr) then\n          Analyze_And_Resolve (Expr, Standard_Boolean);\n \n-         if Is_Static_Expression (Expr) then\n+         if Is_OK_Static_Expression (Expr) then\n             Expr_Val := Is_True (Expr_Value (Expr));\n          else\n             Error_Msg_Name_1 := Pragma_Name (N);\n@@ -2890,14 +2890,15 @@ package body Sem_Prag is\n       --  Check the specified argument Arg to make sure that it is a valid\n       --  queuing policy name. If not give error and raise Pragma_Exit.\n \n-      procedure Check_Arg_Is_Static_Expression\n+      procedure Check_Arg_Is_OK_Static_Expression\n         (Arg : Node_Id;\n          Typ : Entity_Id := Empty);\n       --  Check the specified argument Arg to make sure that it is a static\n       --  expression of the given type (i.e. it will be analyzed and resolved\n       --  using this type, which can be any valid argument to Resolve, e.g.\n       --  Any_Integer is OK). If not, given error and raise Pragma_Exit. If\n-      --  Typ is left Empty, then any static expression is allowed.\n+      --  Typ is left Empty, then any static expression is allowed. Includes\n+      --  checking that the argument does not raise Constraint_Error.\n \n       procedure Check_Arg_Is_Task_Dispatching_Policy (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is a valid task\n@@ -2941,14 +2942,15 @@ package body Sem_Prag is\n       --  This procedure checks for possible duplications if this is the export\n       --  case, and if found, issues an appropriate error message.\n \n-      procedure Check_Expr_Is_Static_Expression\n+      procedure Check_Expr_Is_OK_Static_Expression\n         (Expr : Node_Id;\n          Typ  : Entity_Id := Empty);\n       --  Check the specified expression Expr to make sure that it is a static\n       --  expression of the given type (i.e. it will be analyzed and resolved\n       --  using this type, which can be any valid argument to Resolve, e.g.\n       --  Any_Integer is OK). If not, given error and raise Pragma_Exit. If\n-      --  Typ is left Empty, then any static expression is allowed.\n+      --  Typ is left Empty, then any static expression is allowed. Includes\n+      --  checking that the expression does not raise Constraint_Error.\n \n       procedure Check_First_Subtype (Arg : Node_Id);\n       --  Checks that Arg, whose expression is an entity name, references a\n@@ -3702,7 +3704,7 @@ package body Sem_Prag is\n             --  Static expression that raises Constraint_Error. This has\n             --  already been flagged, so just exit from pragma processing.\n \n-            elsif Is_Static_Expression (Argx) then\n+            elsif Is_OK_Static_Expression (Argx) then\n                raise Pragma_Exit;\n \n             --  Here we have a real error (non-static expression)\n@@ -3987,17 +3989,17 @@ package body Sem_Prag is\n          end if;\n       end Check_Arg_Is_Queuing_Policy;\n \n-      ------------------------------------\n-      -- Check_Arg_Is_Static_Expression --\n-      ------------------------------------\n+      ---------------------------------------\n+      -- Check_Arg_Is_OK_Static_Expression --\n+      ---------------------------------------\n \n-      procedure Check_Arg_Is_Static_Expression\n+      procedure Check_Arg_Is_OK_Static_Expression\n         (Arg : Node_Id;\n          Typ : Entity_Id := Empty)\n       is\n       begin\n-         Check_Expr_Is_Static_Expression (Get_Pragma_Arg (Arg), Typ);\n-      end Check_Arg_Is_Static_Expression;\n+         Check_Expr_Is_OK_Static_Expression (Get_Pragma_Arg (Arg), Typ);\n+      end Check_Arg_Is_OK_Static_Expression;\n \n       ------------------------------------------\n       -- Check_Arg_Is_Task_Dispatching_Policy --\n@@ -4341,11 +4343,11 @@ package body Sem_Prag is\n          end if;\n       end Check_Duplicated_Export_Name;\n \n-      -------------------------------------\n-      -- Check_Expr_Is_Static_Expression --\n-      -------------------------------------\n+      ----------------------------------------\n+      -- Check_Expr_Is_OK_Static_Expression --\n+      ----------------------------------------\n \n-      procedure Check_Expr_Is_Static_Expression\n+      procedure Check_Expr_Is_OK_Static_Expression\n         (Expr : Node_Id;\n          Typ  : Entity_Id := Empty)\n       is\n@@ -4376,7 +4378,7 @@ package body Sem_Prag is\n          --  Static expression that raises Constraint_Error. This has already\n          --  been flagged, so just exit from pragma processing.\n \n-         elsif Is_Static_Expression (Expr) then\n+         elsif Is_OK_Static_Expression (Expr) then\n             raise Pragma_Exit;\n \n          --  Finally, we have a real error\n@@ -4388,7 +4390,7 @@ package body Sem_Prag is\n                Expr);\n             raise Pragma_Exit;\n          end if;\n-      end Check_Expr_Is_Static_Expression;\n+      end Check_Expr_Is_OK_Static_Expression;\n \n       -------------------------\n       -- Check_First_Subtype --\n@@ -5450,13 +5452,13 @@ package body Sem_Prag is\n            ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n \n          Check_Optional_Identifier (Arg1, Name_Name);\n-         Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+         Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n \n          --  In ASIS mode, for a pragma generated from a source aspect, also\n          --  analyze the original aspect expression.\n \n          if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n-            Check_Expr_Is_Static_Expression\n+            Check_Expr_Is_OK_Static_Expression\n               (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n          end if;\n \n@@ -6410,7 +6412,7 @@ package body Sem_Prag is\n       begin\n          Check_Arg_Count (2);\n          Check_No_Identifiers;\n-         Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+         Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n          Analyze_And_Resolve (Arg1x, Standard_Boolean);\n \n          if Compile_Time_Known_Value (Arg1x) then\n@@ -7214,7 +7216,7 @@ package body Sem_Prag is\n                   Arg_Code);\n             end if;\n \n-            Check_Arg_Is_Static_Expression (Arg_Code, Any_Integer);\n+            Check_Arg_Is_OK_Static_Expression (Arg_Code, Any_Integer);\n             Code_Val := Expr_Value (Arg_Code);\n \n             if not UI_Is_In_Int_Range (Code_Val) then\n@@ -8237,7 +8239,8 @@ package body Sem_Prag is\n             else\n                --  As only a string is allowed, Check_Arg_Is_External_Name\n                --  isn't called.\n-               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+\n+               Check_Arg_Is_OK_Static_Expression (Arg3, Standard_String);\n             end if;\n \n             if Present (Arg4) then\n@@ -8256,7 +8259,7 @@ package body Sem_Prag is\n          elsif Nkind (Parent (Def_Id)) = N_Incomplete_Type_Declaration then\n             Check_No_Link_Name;\n             Check_Arg_Count (3);\n-            Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg3, Standard_String);\n \n             Process_Import_Predefined_Type;\n \n@@ -8749,7 +8752,7 @@ package body Sem_Prag is\n          --  Check expressions for external name and link name are static\n \n          if Present (Ext_Nam) then\n-            Check_Arg_Is_Static_Expression (Ext_Nam, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Ext_Nam, Standard_String);\n             Check_Form_Of_Interface_Name (Ext_Nam, Ext_Name_Case => True);\n \n             --  Verify that external name is not the name of a local entity,\n@@ -8794,7 +8797,7 @@ package body Sem_Prag is\n          end if;\n \n          if Present (Link_Nam) then\n-            Check_Arg_Is_Static_Expression (Link_Nam, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Link_Nam, Standard_String);\n             Check_Form_Of_Interface_Name (Link_Nam, Ext_Name_Case => False);\n          end if;\n \n@@ -10373,7 +10376,7 @@ package body Sem_Prag is\n                   if Present (Expr) then\n                      Analyze_And_Resolve (Expr, Standard_Boolean);\n \n-                     if Is_Static_Expression (Expr) then\n+                     if Is_OK_Static_Expression (Expr) then\n                         Expr_Val := Is_True (Expr_Value (Expr));\n                      else\n                         SPARK_Msg_N\n@@ -11897,7 +11900,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, \"max_size\");\n \n             Arg := Get_Pragma_Arg (Arg1);\n-            Check_Arg_Is_Static_Expression (Arg, Any_Integer);\n+            Check_Arg_Is_OK_Static_Expression (Arg, Any_Integer);\n \n             Val := Expr_Value (Arg);\n \n@@ -12879,7 +12882,7 @@ package body Sem_Prag is\n \n                --  Must be static\n \n-               if not Is_Static_Expression (Arg) then\n+               if not Is_OK_Static_Expression (Arg) then\n                   Flag_Non_Static_Expr\n                     (\"main subprogram affinity is not static!\", Arg);\n                   raise Pragma_Exit;\n@@ -13991,10 +13994,10 @@ package body Sem_Prag is\n             Check_Arg_Count (2);\n \n             Check_Optional_Identifier (Arg1, Name_Value);\n-            Check_Arg_Is_Static_Expression (Arg1, Any_Integer);\n+            Check_Arg_Is_OK_Static_Expression (Arg1, Any_Integer);\n \n             Check_Optional_Identifier (Arg2, Name_Link_Name);\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n \n          -----------------------------\n          -- Export_Valued_Procedure --\n@@ -14478,7 +14481,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n-            Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n             Store_Note (N);\n \n             --  For pragma Ident, preserve DEC compatibility by requiring the\n@@ -15700,7 +15703,7 @@ package body Sem_Prag is\n             --  expression of type Ada.Interrupts.Interrupt_ID.\n \n             else\n-               Check_Arg_Is_Static_Expression (Arg1, Any_Integer);\n+               Check_Arg_Is_OK_Static_Expression (Arg1, Any_Integer);\n                Int_Val := Expr_Value (Arg1X);\n \n                if Int_Val < Expr_Value (Type_Low_Bound (Int_Id))\n@@ -15787,7 +15790,7 @@ package body Sem_Prag is\n \n             if Arg_Count = 3 then\n                Check_Optional_Identifier (Arg3, Name_Message);\n-               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+               Check_Arg_Is_OK_Static_Expression (Arg3, Standard_String);\n             end if;\n \n             Check_Arg_Is_Local_Name (Arg1);\n@@ -16256,12 +16259,12 @@ package body Sem_Prag is\n                Check_At_Least_N_Arguments (1);\n                Check_No_Identifiers;\n                Check_Is_In_Decl_Part_Or_Package_Spec;\n-               Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+               Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n                Start_String;\n \n                Arg := Arg1;\n                while Present (Arg) loop\n-                  Check_Arg_Is_Static_Expression (Arg, Standard_String);\n+                  Check_Arg_Is_OK_Static_Expression (Arg, Standard_String);\n \n                   --  Store argument, converting sequences of spaces to a\n                   --  single null character (this is one of the differences\n@@ -16336,7 +16339,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Optional_Identifier (Arg2, Name_Target);\n             Check_Arg_Is_Library_Level_Local_Name (Arg1);\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n \n             --  The only processing required is to link this item on to the\n             --  list of rep items for the given entity. This is accomplished\n@@ -16409,12 +16412,12 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Is_In_Decl_Part_Or_Package_Spec;\n-            Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n             Start_String (Strval (Expr_Value_S (Get_Pragma_Arg (Arg1))));\n \n             Arg := Arg2;\n             while Present (Arg) loop\n-               Check_Arg_Is_Static_Expression (Arg, Standard_String);\n+               Check_Arg_Is_OK_Static_Expression (Arg, Standard_String);\n                Store_String_Char (ASCII.NUL);\n                Store_String_Chars\n                  (Strval (Expr_Value_S (Get_Pragma_Arg (Arg))));\n@@ -16447,7 +16450,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Optional_Identifier (Arg2, Name_Section);\n             Check_Arg_Is_Library_Level_Local_Name (Arg1);\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n \n             --  Check kind of entity\n \n@@ -16743,15 +16746,15 @@ package body Sem_Prag is\n \n             if Arg_Count = 3 then\n                Check_Optional_Identifier (Arg3, Name_Info);\n-               Check_Arg_Is_Static_Expression (Arg3);\n+               Check_Arg_Is_OK_Static_Expression (Arg3);\n             else\n                Check_Arg_Count (2);\n             end if;\n \n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Optional_Identifier (Arg2, Name_Attribute_Name);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n             Def_Id := Entity (Get_Pragma_Arg (Arg1));\n \n             if Is_Access_Type (Def_Id) then\n@@ -16803,12 +16806,12 @@ package body Sem_Prag is\n \n             for J in 1 .. 2 loop\n                if Present (Args (J)) then\n-                  Check_Arg_Is_Static_Expression (Args (J), Any_Integer);\n+                  Check_Arg_Is_OK_Static_Expression (Args (J), Any_Integer);\n                end if;\n             end loop;\n \n             if Present (Args (3)) then\n-               Check_Arg_Is_Static_Expression (Args (3), Standard_Boolean);\n+               Check_Arg_Is_OK_Static_Expression (Args (3), Standard_Boolean);\n             end if;\n \n             Nod := Next (N);\n@@ -16849,7 +16852,7 @@ package body Sem_Prag is\n \n             for J in 1 .. 2 loop\n                if Present (Args (J)) then\n-                  Check_Arg_Is_Static_Expression (Args (J), Any_Integer);\n+                  Check_Arg_Is_OK_Static_Expression (Args (J), Any_Integer);\n                end if;\n             end loop;\n \n@@ -17143,7 +17146,7 @@ package body Sem_Prag is\n \n                   --  Deal with static string argument\n \n-                  Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+                  Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n                   S := Strval (Get_Pragma_Arg (Arg1));\n \n                   for J in 1 .. String_Length (S) loop\n@@ -18272,7 +18275,7 @@ package body Sem_Prag is\n \n                --  Must be static\n \n-               if not Is_Static_Expression (Arg) then\n+               if not Is_OK_Static_Expression (Arg) then\n                   Flag_Non_Static_Expr\n                     (\"main subprogram priority is not static!\", Arg);\n                   raise Pragma_Exit;\n@@ -18383,11 +18386,11 @@ package body Sem_Prag is\n             DP := Fold_Upper (Name_Buffer (1));\n \n             Lower_Bound := Get_Pragma_Arg (Arg2);\n-            Check_Arg_Is_Static_Expression (Lower_Bound, Standard_Integer);\n+            Check_Arg_Is_OK_Static_Expression (Lower_Bound, Standard_Integer);\n             Lower_Val := Expr_Value (Lower_Bound);\n \n             Upper_Bound := Get_Pragma_Arg (Arg3);\n-            Check_Arg_Is_Static_Expression (Upper_Bound, Standard_Integer);\n+            Check_Arg_Is_OK_Static_Expression (Upper_Bound, Standard_Integer);\n             Upper_Val := Expr_Value (Upper_Bound);\n \n             --  It is not allowed to use Task_Dispatching_Policy and\n@@ -20054,7 +20057,7 @@ package body Sem_Prag is\n             Arg := Get_Pragma_Arg (Arg1);\n             Preanalyze_Spec_Expression (Arg, Any_Integer);\n \n-            if not Is_Static_Expression (Arg) then\n+            if not Is_OK_Static_Expression (Arg) then\n                Check_Restriction (Static_Storage_Size, Arg);\n             end if;\n \n@@ -20330,7 +20333,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Subtitle);\n-            Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+            Check_Arg_Is_OK_Static_Expression (Arg1, Standard_String);\n             Store_Note (N);\n \n          --------------\n@@ -20622,7 +20625,7 @@ package body Sem_Prag is\n                Error_Pragma_Arg\n                  (\"pragma% takes two arguments\", Task_Type);\n             else\n-               Check_Arg_Is_Static_Expression (Top_Guard, Any_Integer);\n+               Check_Arg_Is_OK_Static_Expression (Top_Guard, Any_Integer);\n             end if;\n \n             Check_First_Subtype (Task_Type);\n@@ -20700,7 +20703,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_In_Main_Program;\n-            Check_Arg_Is_Static_Expression (Arg1, Standard_Duration);\n+            Check_Arg_Is_OK_Static_Expression (Arg1, Standard_Duration);\n \n             if not Error_Posted (Arg1) then\n                Nod := Next (N);\n@@ -20758,7 +20761,8 @@ package body Sem_Prag is\n \n             for J in 1 .. 2 loop\n                if Present (Args (J)) then\n-                  Check_Arg_Is_Static_Expression (Args (J), Standard_String);\n+                  Check_Arg_Is_OK_Static_Expression\n+                    (Args (J), Standard_String);\n                end if;\n             end loop;\n          end Title;"}, {"sha": "ca4cc59a6eebde2b76698bd93c08c62bc76a73e8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -3401,7 +3401,7 @@ package body Sem_Res is\n                      return Ekind (Ent) = E_Constant\n                               and then Present (Constant_Value (Ent))\n                               and then\n-                                Is_Static_Expression (Constant_Value (Ent));\n+                                Is_OK_Static_Expression (Constant_Value (Ent));\n                   end;\n \n                else\n@@ -8145,7 +8145,7 @@ package body Sem_Res is\n                Nalts := 0;\n                Alt := First (Alternatives (N));\n                while Present (Alt) loop\n-                  if Is_Static_Expression (Alt)\n+                  if Is_OK_Static_Expression (Alt)\n                     and then (Nkind_In (Alt, N_Integer_Literal,\n                                              N_Character_Literal)\n                                or else Nkind (Alt) in N_Has_Entity)\n@@ -8176,8 +8176,7 @@ package body Sem_Res is\n \n       if Present (Alternatives (N)) then\n          Resolve_Set_Membership;\n-         Check_Function_Writable_Actuals (N);\n-         return;\n+         goto SM_Exit;\n \n       elsif not Is_Overloaded (R)\n         and then\n@@ -8240,6 +8239,10 @@ package body Sem_Res is\n          Check_Unset_Reference (R);\n       end if;\n \n+      --  Here after resolving membership operation\n+\n+      <<SM_Exit>>\n+\n       Eval_Membership_Op (N);\n       Check_Function_Writable_Actuals (N);\n    end Resolve_Membership_Op;\n@@ -8502,15 +8505,15 @@ package body Sem_Res is\n       --  separately on each final operand, past concatenation operations.\n \n       if Is_Character_Type (Etype (Arg)) then\n-         if not Is_Static_Expression (Arg) then\n+         if not Is_OK_Static_Expression (Arg) then\n             Check_SPARK_Restriction\n               (\"character operand for concatenation should be static\", Arg);\n          end if;\n \n       elsif Is_String_Type (Etype (Arg)) then\n          if not (Nkind_In (Arg, N_Identifier, N_Expanded_Name)\n                   and then Is_Constant_Object (Entity (Arg)))\n-           and then not Is_Static_Expression (Arg)\n+           and then not Is_OK_Static_Expression (Arg)\n          then\n             Check_SPARK_Restriction\n               (\"string operand for concatenation should be static\", Arg);\n@@ -8966,11 +8969,11 @@ package body Sem_Res is\n \n       if Is_Discrete_Type (Typ) and then Expander_Active then\n          if Is_OK_Static_Expression (L) then\n-            Fold_Uint  (L, Expr_Value (L), Is_Static_Expression (L));\n+            Fold_Uint (L, Expr_Value (L), Is_OK_Static_Expression (L));\n          end if;\n \n          if Is_OK_Static_Expression (H) then\n-            Fold_Uint  (H, Expr_Value (H), Is_Static_Expression (H));\n+            Fold_Uint (H, Expr_Value (H), Is_OK_Static_Expression (H));\n          end if;\n       end if;\n    end Resolve_Range;\n@@ -9016,7 +9019,7 @@ package body Sem_Res is\n \n                --  Generate a warning if literal from source\n \n-               if Is_Static_Expression (N)\n+               if Is_OK_Static_Expression (N)\n                  and then Warn_On_Bad_Fixed_Value\n                then\n                   Error_Msg_N\n@@ -9029,7 +9032,7 @@ package body Sem_Res is\n                --  by truncation, since Machine_Rounds is false for all GNAT\n                --  fixed-point types (RM 4.9(38)).\n \n-               Stat := Is_Static_Expression (N);\n+               Stat := Is_OK_Static_Expression (N);\n                Rewrite (N,\n                  Make_Real_Literal (Sloc (N),\n                    Realval => Small_Value (Typ) * Cint));"}, {"sha": "76cc6670c4c6e72cd5cb3f058c97dd8cdad48681", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 31, "deletions": 147, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1684,55 +1684,6 @@ package body Sem_Util is\n       end if;\n    end Check_Dynamically_Tagged_Expression;\n \n-   -----------------------------------------------\n-   -- Check_Expression_Against_Static_Predicate --\n-   -----------------------------------------------\n-\n-   procedure Check_Expression_Against_Static_Predicate\n-     (Expr : Node_Id;\n-      Typ  : Entity_Id)\n-   is\n-   begin\n-      --  When the predicate is static and the value of the expression is known\n-      --  at compile time, evaluate the predicate check. A type is non-static\n-      --  when it has aspect Dynamic_Predicate, but if the dynamic predicate\n-      --  was predicate-static, we still check it statically. After all this\n-      --  is only a warning, not an error.\n-\n-      if Compile_Time_Known_Value (Expr)\n-        and then Has_Predicates (Typ)\n-        and then Has_Static_Predicate (Typ)\n-      then\n-         --  Either -gnatc is enabled or the expression is ok\n-\n-         if Operating_Mode < Generate_Code\n-           or else Eval_Static_Predicate_Check (Expr, Typ)\n-         then\n-            null;\n-\n-         --  The expression is prohibited by the static predicate. There has\n-         --  been some debate if this is an illegality (in the case where\n-         --  the static predicate was explicitly given as such), but that\n-         --  discussion decided this was not illegal, just a warning situation.\n-\n-         else\n-            Error_Msg_NE\n-              (\"??static expression fails predicate check on &\", Expr, Typ);\n-\n-            --  We now reset the static expression indication on the expression\n-            --  since it is no longer static if it fails a predicate test. We\n-            --  do not do this if the predicate was officially dynamic, since\n-            --  dynamic predicates don't affect legality in this manner.\n-\n-            if not Has_Dynamic_Predicate_Aspect (Typ) then\n-               Error_Msg_N\n-                 (\"\\??expression is no longer considered static\", Expr);\n-               Set_Is_Static_Expression (Expr, False);\n-            end if;\n-         end if;\n-      end if;\n-   end Check_Expression_Against_Static_Predicate;\n-\n    --------------------------\n    -- Check_Fully_Declared --\n    --------------------------\n@@ -1944,7 +1895,7 @@ package body Sem_Util is\n             return;\n          end if;\n \n-         if Nkind (N) in N_Subexpr and then Is_Static_Expression (N) then\n+         if Nkind (N) in N_Subexpr and then Is_OK_Static_Expression (N) then\n             return;\n          end if;\n \n@@ -2209,7 +2160,7 @@ package body Sem_Util is\n                            --  bounds.\n \n                            else\n-                              pragma Assert (Is_Static_Expression (Choice)\n+                              pragma Assert (Is_OK_Static_Expression (Choice)\n                                 or else Nkind (Choice) = N_Identifier\n                                 or else Nkind (Choice) = N_Integer_Literal);\n \n@@ -2280,7 +2231,7 @@ package body Sem_Util is\n                if Present (Expressions (N)) then\n                   Comp_Expr := First (Expressions (N));\n                   while Present (Comp_Expr) loop\n-                     if not Is_Static_Expression (Comp_Expr) then\n+                     if not Is_OK_Static_Expression (Comp_Expr) then\n                         Collect_Identifiers (Comp_Expr);\n                      end if;\n \n@@ -3602,11 +3553,10 @@ package body Sem_Util is\n \n       Msgl : Natural;\n       Wmsg : Boolean;\n-      P    : Node_Id;\n-      OldP : Node_Id;\n-      Msgs : Boolean;\n       Eloc : Source_Ptr;\n \n+   --  Start of processing for Compile_Time_Constraint_Error\n+\n    begin\n       --  If this is a warning, convert it into an error if we are in code\n       --  subject to SPARK_Mode being set ON.\n@@ -3677,82 +3627,12 @@ package body Sem_Util is\n             Msgc (Msgl) := '!';\n          end if;\n \n-         --  Should we generate a warning? The answer is not quite yes. The\n-         --  very annoying exception occurs in the case of a short circuit\n-         --  operator where the left operand is static and decisive. Climb\n-         --  parents to see if that is the case we have here. Conditional\n-         --  expressions with decisive conditions are a similar situation.\n-\n-         Msgs := True;\n-         P := N;\n-         loop\n-            OldP := P;\n-            P := Parent (P);\n-\n-            --  And then with False as left operand\n-\n-            if Nkind (P) = N_And_Then\n-              and then Compile_Time_Known_Value (Left_Opnd (P))\n-              and then Is_False (Expr_Value (Left_Opnd (P)))\n-            then\n-               Msgs := False;\n-               exit;\n+         --  One more test, skip the warning if the related expression is\n+         --  statically unevaluated, since we don't want to warn about what\n+         --  will happen when something is evaluated if it never will be\n+         --  evaluated.\n \n-            --  OR ELSE with True as left operand\n-\n-            elsif Nkind (P) = N_Or_Else\n-              and then Compile_Time_Known_Value (Left_Opnd (P))\n-              and then Is_True (Expr_Value (Left_Opnd (P)))\n-            then\n-               Msgs := False;\n-               exit;\n-\n-            --  If expression\n-\n-            elsif Nkind (P) = N_If_Expression then\n-               declare\n-                  Cond : constant Node_Id := First (Expressions (P));\n-                  Texp : constant Node_Id := Next (Cond);\n-                  Fexp : constant Node_Id := Next (Texp);\n-\n-               begin\n-                  if Compile_Time_Known_Value (Cond) then\n-\n-                     --  Condition is True and we are in the right operand\n-\n-                     if Is_True (Expr_Value (Cond))\n-                       and then OldP = Fexp\n-                     then\n-                        Msgs := False;\n-                        exit;\n-\n-                     --  Condition is False and we are in the left operand\n-\n-                     elsif Is_False (Expr_Value (Cond))\n-                       and then OldP = Texp\n-                     then\n-                        Msgs := False;\n-                        exit;\n-                     end if;\n-                  end if;\n-               end;\n-\n-            --  Special case for component association in aggregates, where\n-            --  we want to keep climbing up to the parent aggregate.\n-\n-            elsif Nkind (P) = N_Component_Association\n-              and then Nkind (Parent (P)) = N_Aggregate\n-            then\n-               null;\n-\n-            --  Keep going if within subexpression\n-\n-            else\n-               exit when Nkind (P) not in N_Subexpr;\n-            end if;\n-         end loop;\n-\n-         if Msgs then\n+         if not Is_Statically_Unevaluated (N) then\n             Error_Msg_Warn := SPARK_Mode /= On;\n \n             if Present (Ent) then\n@@ -8034,7 +7914,7 @@ package body Sem_Util is\n             Is_Array_Aggr : Boolean;\n \n          begin\n-            if Is_Static_Expression (N) then\n+            if Is_OK_Static_Expression (N) then\n                return True;\n \n             elsif Nkind (N) = N_Null then\n@@ -8124,11 +8004,11 @@ package body Sem_Util is\n                            null;\n \n                         elsif Nkind (Choice) = N_Range then\n-                           if not Is_Static_Range (Choice) then\n+                           if not Is_OK_Static_Range (Choice) then\n                               return False;\n                            end if;\n \n-                        elsif not Is_Static_Expression (Choice) then\n+                        elsif not Is_OK_Static_Expression (Choice) then\n                            return False;\n                         end if;\n \n@@ -12528,8 +12408,9 @@ package body Sem_Util is\n          L_Index := First_Index (L_Typ);\n          Get_Index_Bounds (L_Index, L_Low, L_High);\n \n-         if         Is_OK_Static_Expression (L_Low)\n-           and then Is_OK_Static_Expression (L_High)\n+         if Is_OK_Static_Expression (L_Low)\n+              and then\n+             Is_OK_Static_Expression (L_High)\n          then\n             if Expr_Value (L_High) < Expr_Value (L_Low) then\n                L_Len := Uint_0;\n@@ -12548,8 +12429,9 @@ package body Sem_Util is\n          R_Index := First_Index (R_Typ);\n          Get_Index_Bounds (R_Index, R_Low, R_High);\n \n-         if         Is_OK_Static_Expression (R_Low)\n-           and then Is_OK_Static_Expression (R_High)\n+         if Is_OK_Static_Expression (R_Low)\n+              and then\n+            Is_OK_Static_Expression (R_High)\n          then\n             if Expr_Value (R_High) < Expr_Value (R_Low) then\n                R_Len := Uint_0;\n@@ -12561,8 +12443,9 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      if         Is_OK_Static_Expression (L_Low)\n-        and then Is_OK_Static_Expression (R_Low)\n+      if (Is_OK_Static_Expression (L_Low)\n+            and then\n+          Is_OK_Static_Expression (R_Low))\n         and then Expr_Value (L_Low) = Expr_Value (R_Low)\n         and then L_Len = R_Len\n       then\n@@ -12580,12 +12463,13 @@ package body Sem_Util is\n          Get_Index_Bounds (L_Index, L_Low, L_High);\n          Get_Index_Bounds (R_Index, R_Low, R_High);\n \n-         if         Is_OK_Static_Expression (L_Low)\n-           and then Is_OK_Static_Expression (L_High)\n-           and then Is_OK_Static_Expression (R_Low)\n-           and then Is_OK_Static_Expression (R_High)\n-           and then Expr_Value (L_Low)  = Expr_Value (R_Low)\n-           and then Expr_Value (L_High) = Expr_Value (R_High)\n+         if (Is_OK_Static_Expression (L_Low)  and then\n+             Is_OK_Static_Expression (L_High) and then\n+             Is_OK_Static_Expression (R_Low)  and then\n+             Is_OK_Static_Expression (R_High))\n+           and then (Expr_Value (L_Low)  = Expr_Value (R_Low)\n+                       and then\n+                     Expr_Value (L_High) = Expr_Value (R_High))\n          then\n             null;\n          else\n@@ -16467,7 +16351,7 @@ package body Sem_Util is\n          return No_Uint;\n       end if;\n \n-      if Is_Static_Expression (N) then\n+      if Is_OK_Static_Expression (N) then\n          if not Raises_Constraint_Error (N) then\n             return Expr_Value (N);\n          else\n@@ -16499,7 +16383,7 @@ package body Sem_Util is\n          return No_Uint;\n       end if;\n \n-      if Is_Static_Expression (N) then\n+      if Is_OK_Static_Expression (N) then\n          if not Raises_Constraint_Error (N) then\n             return Expr_Value (N);\n          else"}, {"sha": "d6963416f72f373d45fbd101365090f32a533e14", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -250,14 +250,6 @@ package Sem_Util is\n       Related_Nod : Node_Id);\n    --  Check wrong use of dynamically tagged expression\n \n-   procedure Check_Expression_Against_Static_Predicate\n-     (Expr : Node_Id;\n-      Typ  : Entity_Id);\n-   --  Determine whether an arbitrary expression satisfies the static predicate\n-   --  of a type. The routine does nothing if Expr is not known at compile time\n-   --  or Typ lacks a static predicate, otherwise it may emit a warning if the\n-   --  expression is prohibited by the predicate.\n-\n    procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n    --  Verify that the full declaration of type T has been seen. If not, place\n    --  error message on node N. Used in object declarations, type conversions"}, {"sha": "1fb1acfb57c5275beda7f739fc6b7fa9ffed0a06", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -1612,8 +1612,13 @@ package Sinfo is\n    --    of an object allocated on the stack rather than the heap.\n \n    --  Is_Static_Expression (Flag6-Sem)\n-   --    Indicates that an expression is a static expression (RM 4.9). See spec\n-   --    of package Sem_Eval for full details on the use of this flag.\n+   --    Indicates that an expression is a static expression according to the\n+   --    rules in (RM 4.9). Note that it is possible for this flag to be set\n+   --    when Raises_Constraint_Error is also set. In practice almost all cases\n+   --    where a static expression is required do not allow an expression which\n+   --    raises Constraint_Error, so almost always, callers should call the\n+   --    Is_Ok_Static_Exprression routine instead of testing this flag. See\n+   --    spec of package Sem_Eval for full details on the use of this flag.\n \n    --  Is_Subprogram_Descriptor (Flag16-Sem)\n    --    Present in N_Object_Declaration, and set only for the object"}, {"sha": "3378dc72a7b8abe61554e8ef963484c16b22b0a6", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -438,8 +438,7 @@ package body Tbuild is\n       return\n         Make_Raise_Constraint_Error (Sloc,\n           Condition => Condition,\n-          Reason =>\n-            UI_From_Int (RT_Exception_Code'Pos (Reason)));\n+          Reason    => UI_From_Int (RT_Exception_Code'Pos (Reason)));\n    end Make_Raise_Constraint_Error;\n \n    ------------------------------\n@@ -456,8 +455,7 @@ package body Tbuild is\n       return\n         Make_Raise_Program_Error (Sloc,\n           Condition => Condition,\n-          Reason =>\n-            UI_From_Int (RT_Exception_Code'Pos (Reason)));\n+          Reason    => UI_From_Int (RT_Exception_Code'Pos (Reason)));\n    end Make_Raise_Program_Error;\n \n    ------------------------------\n@@ -474,8 +472,7 @@ package body Tbuild is\n       return\n         Make_Raise_Storage_Error (Sloc,\n           Condition => Condition,\n-          Reason =>\n-            UI_From_Int (RT_Exception_Code'Pos (Reason)));\n+          Reason    => UI_From_Int (RT_Exception_Code'Pos (Reason)));\n    end Make_Raise_Storage_Error;\n \n    -------------\n@@ -501,9 +498,7 @@ package body Tbuild is\n    begin\n       Start_String;\n       Store_String_Chars (Strval);\n-      return\n-        Make_String_Literal (Sloc,\n-          Strval => End_String);\n+      return Make_String_Literal (Sloc, Strval => End_String);\n    end Make_String_Literal;\n \n    --------------------\n@@ -516,8 +511,7 @@ package body Tbuild is\n       Related_Node : Node_Id := Empty) return Entity_Id\n    is\n       Temp : constant Entity_Id :=\n-               Make_Defining_Identifier (Loc,\n-                 Chars => New_Internal_Name (Id));\n+               Make_Defining_Identifier (Loc, Chars => New_Internal_Name (Id));\n    begin\n       Set_Related_Expression (Temp, Related_Node);\n       return Temp;\n@@ -694,6 +688,10 @@ package body Tbuild is\n          Set_Etype (Occurrence, Etype (Def_Id));\n       end if;\n \n+      if Ekind (Def_Id) = E_Enumeration_Literal then\n+         Set_Is_Static_Expression (Occurrence, True);\n+      end if;\n+\n       return Occurrence;\n    end New_Occurrence_Of;\n "}, {"sha": "47416616b694d1fb1f063866899e362f42074289", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edab608853d34224b204dc42d751a3f90daabe39/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=edab608853d34224b204dc42d751a3f90daabe39", "patch": "@@ -300,7 +300,9 @@ package Tbuild is\n    --  of the defining identifier which is passed as its argument. The Entity\n    --  and Etype of the result are set from the given defining identifier as\n    --  follows: Entity is simply a copy of Def_Id. Etype is a copy of Def_Id\n-   --  for types, and a copy of the Etype of Def_Id for other entities.\n+   --  for types, and a copy of the Etype of Def_Id for other entities. Note\n+   --  that Is_Static_Expression is set if this call creates an occurrence of\n+   --  an enumeration literal.\n \n    function New_Suffixed_Name\n      (Related_Id : Name_Id;"}]}