{"sha": "c566cc9f7847785bc709daaa3301649f2f03aef9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2NmNjOWY3ODQ3Nzg1YmM3MDlkYWFhMzMwMTY0OWYyZjAzYWVmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-18T08:27:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-18T08:27:58Z"}, "message": "Replace FMA_EXPR with one internal fn per optab\n\nThere are four optabs for various forms of fused multiply-add:\nfma, fms, fnma and fnms.  Of these, only fma had a direct gimple\nrepresentation.  For the other three we relied on special pattern-\nmatching during expand, although tree-ssa-math-opts.c did have\nsome code to try to second-guess what expand would do.\n\nThis patch removes the old FMA_EXPR representation of fma and\nintroduces four new internal functions, one for each optab.\nIFN_FMA is tied to BUILT_IN_FMA* while the other three are\nindependent directly-mapped internal functions.  It's then\npossible to do the pattern-matching in match.pd and\ntree-ssa-math-opts.c (via folding) can select the exact\nFMA-based operation.\n\nThe BRIG & HSA parts are a best guess, but seem relatively simple.\n\n2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/sourcebuild.texi (scalar_all_fma): Document.\n\t* tree.def (FMA_EXPR): Delete.\n\t* internal-fn.def (FMA, FMS, FNMA, FNMS): New internal functions.\n\t* internal-fn.c (ternary_direct): New macro.\n\t(expand_ternary_optab_fn): Likewise.\n\t(direct_ternary_optab_supported_p): Likewise.\n\t* Makefile.in (build/genmatch.o): Depend on case-fn-macros.h.\n\t* builtins.c (fold_builtin_fma): Delete.\n\t(fold_builtin_3): Don't call it.\n\t* cfgexpand.c (expand_debug_expr): Remove FMA_EXPR handling.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t* fold-const.c (operand_equal_p): Likewise.\n\t(fold_ternary_loc): Likewise.\n\t* gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n\t* gimple.c (DEFTREECODE): Likewise.\n\t* gimplify.c (gimplify_expr): Likewise.\n\t* optabs-tree.c (optab_for_tree_code): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Likewise.\n\t* tree-eh.c (operation_could_trap_p): Likewise.\n\t(stmt_could_throw_1_p): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t(op_code_prio): Likewise.\n\t* tree-ssa-loop-im.c (stmt_cost): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree.c (commutative_ternary_tree_code, add_expr): Likewise.\n\t* fold-const-call.h (fold_fma): Delete.\n\t* fold-const-call.c (fold_const_call_ssss): Handle CFN_FMS,\n\tCFN_FNMA and CFN_FNMS.\n\t(fold_fma): Delete.\n\t* genmatch.c (combined_fn): New enum.\n\t(commutative_ternary_tree_code): Remove FMA_EXPR handling.\n\t(commutative_op): New function.\n\t(commutate): Use it.  Handle more than 2 operands.\n\t(dt_operand::gen_gimple_expr): Use commutative_op.\n\t(parser::parse_expr): Allow :c to be used with non-binary\n\toperators if the commutative operand is known.\n\t* gimple-ssa-backprop.c (backprop::process_builtin_call_use): Handle\n\tCFN_FMS, CFN_FNMA and CFN_FNMS.\n\t(backprop::process_assign_use): Remove FMA_EXPR handling.\n\t* hsa-gen.c (gen_hsa_insns_for_operation_assignment): Likewise.\n\t(gen_hsa_fma): New function.\n\t(gen_hsa_insn_for_internal_fn_call): Use it for IFN_FMA, IFN_FMS,\n\tIFN_FNMA and IFN_FNMS.\n\t* match.pd: Add folds for IFN_FMS, IFN_FNMA and IFN_FNMS.\n\t* gimple-fold.h (follow_all_ssa_edges): Declare.\n\t* gimple-fold.c (follow_all_ssa_edges): New function.\n\t* tree-ssa-math-opts.c (convert_mult_to_fma_1): Use the\n\tgimple_build interface and use follow_all_ssa_edges to fold the result.\n\t(convert_mult_to_fma): Use direct_internal_fn_suppoerted_p\n\tinstead of checking for optabs directly.\n\t* config/i386/i386.c (ix86_add_stmt_cost): Recognize FMAs as calls\n\trather than FMA_EXPRs.\n\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Create a\n\tcall to IFN_FMA instead of an FMA_EXPR.\n\ngcc/brig/\n\t* brigfrontend/brig-function.cc\n\t(brig_function::get_builtin_for_hsa_opcode): Use BUILT_IN_FMA\n\tfor BRIG_OPCODE_FMA.\n\t(brig_function::get_tree_code_for_hsa_opcode): Treat BUILT_IN_FMA\n\tas a call.\n\ngcc/c/\n\t* gimple-parser.c (c_parser_gimple_postfix_expression): Remove\n\t__FMA_EXPR handlng.\n\ngcc/cp/\n\t* constexpr.c (cxx_eval_constant_expression): Remove FMA_EXPR handling.\n\t(potential_constant_expression_1): Likewise.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_scalar_all_fma):\n\tNew proc.\n\t* gcc.dg/fma-1.c: New test.\n\t* gcc.dg/fma-2.c: Likewise.\n\t* gcc.dg/fma-3.c: Likewise.\n\t* gcc.dg/fma-4.c: Likewise.\n\t* gcc.dg/fma-5.c: Likewise.\n\t* gcc.dg/fma-6.c: Likewise.\n\t* gcc.dg/fma-7.c: Likewise.\n\t* gcc.dg/gimplefe-26.c: Use .FMA instead of __FMA and require\n\tscalar_all_fma.\n\t* gfortran.dg/reassoc_7.f: Pass -ffp-contract=off.\n\t* gfortran.dg/reassoc_8.f: Likewise.\n\t* gfortran.dg/reassoc_9.f: Likewise.\n\t* gfortran.dg/reassoc_10.f: Likewise.\n\nFrom-SVN: r260348", "tree": {"sha": "1cc67fdd0c641bfd3114f12a85a259c154feac00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cc67fdd0c641bfd3114f12a85a259c154feac00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c566cc9f7847785bc709daaa3301649f2f03aef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c566cc9f7847785bc709daaa3301649f2f03aef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c566cc9f7847785bc709daaa3301649f2f03aef9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c566cc9f7847785bc709daaa3301649f2f03aef9/comments", "author": null, "committer": null, "parents": [{"sha": "a35f9ec2f83ccdf53fdcbe2b85a2de33cde46f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35f9ec2f83ccdf53fdcbe2b85a2de33cde46f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a35f9ec2f83ccdf53fdcbe2b85a2de33cde46f98"}], "stats": {"total": 959, "additions": 661, "deletions": 298}, "files": [{"sha": "9351896f6d3cc146835692ea3337e6283266c224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,3 +1,61 @@\n+2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/sourcebuild.texi (scalar_all_fma): Document.\n+\t* tree.def (FMA_EXPR): Delete.\n+\t* internal-fn.def (FMA, FMS, FNMA, FNMS): New internal functions.\n+\t* internal-fn.c (ternary_direct): New macro.\n+\t(expand_ternary_optab_fn): Likewise.\n+\t(direct_ternary_optab_supported_p): Likewise.\n+\t* Makefile.in (build/genmatch.o): Depend on case-fn-macros.h.\n+\t* builtins.c (fold_builtin_fma): Delete.\n+\t(fold_builtin_3): Don't call it.\n+\t* cfgexpand.c (expand_debug_expr): Remove FMA_EXPR handling.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t* fold-const.c (operand_equal_p): Likewise.\n+\t(fold_ternary_loc): Likewise.\n+\t* gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n+\t* gimple.c (DEFTREECODE): Likewise.\n+\t* gimplify.c (gimplify_expr): Likewise.\n+\t* optabs-tree.c (optab_for_tree_code): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_ternary): Likewise.\n+\t* tree-eh.c (operation_could_trap_p): Likewise.\n+\t(stmt_could_throw_1_p): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(op_code_prio): Likewise.\n+\t* tree-ssa-loop-im.c (stmt_cost): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree.c (commutative_ternary_tree_code, add_expr): Likewise.\n+\t* fold-const-call.h (fold_fma): Delete.\n+\t* fold-const-call.c (fold_const_call_ssss): Handle CFN_FMS,\n+\tCFN_FNMA and CFN_FNMS.\n+\t(fold_fma): Delete.\n+\t* genmatch.c (combined_fn): New enum.\n+\t(commutative_ternary_tree_code): Remove FMA_EXPR handling.\n+\t(commutative_op): New function.\n+\t(commutate): Use it.  Handle more than 2 operands.\n+\t(dt_operand::gen_gimple_expr): Use commutative_op.\n+\t(parser::parse_expr): Allow :c to be used with non-binary\n+\toperators if the commutative operand is known.\n+\t* gimple-ssa-backprop.c (backprop::process_builtin_call_use): Handle\n+\tCFN_FMS, CFN_FNMA and CFN_FNMS.\n+\t(backprop::process_assign_use): Remove FMA_EXPR handling.\n+\t* hsa-gen.c (gen_hsa_insns_for_operation_assignment): Likewise.\n+\t(gen_hsa_fma): New function.\n+\t(gen_hsa_insn_for_internal_fn_call): Use it for IFN_FMA, IFN_FMS,\n+\tIFN_FNMA and IFN_FNMS.\n+\t* match.pd: Add folds for IFN_FMS, IFN_FNMA and IFN_FNMS.\n+\t* gimple-fold.h (follow_all_ssa_edges): Declare.\n+\t* gimple-fold.c (follow_all_ssa_edges): New function.\n+\t* tree-ssa-math-opts.c (convert_mult_to_fma_1): Use the\n+\tgimple_build interface and use follow_all_ssa_edges to fold the result.\n+\t(convert_mult_to_fma): Use direct_internal_fn_suppoerted_p\n+\tinstead of checking for optabs directly.\n+\t* config/i386/i386.c (ix86_add_stmt_cost): Recognize FMAs as calls\n+\trather than FMA_EXPRs.\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Create a\n+\tcall to IFN_FMA instead of an FMA_EXPR.\n+\n 2018-05-17  Jim Wilson  <jimw@sifive.com>\n \n \t* expr.c (do_tablejump): When converting index to Pmode, if we have a"}, {"sha": "256a21546ee3a7e845dc435bb881b849f7e660f7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2787,7 +2787,7 @@ build/genmddump.o : genmddump.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   $(CORETYPES_H) $(GTM_H) errors.h $(READ_MD_H) $(GENSUPPORT_H)\n build/genmatch.o : genmatch.c $(BCONFIG_H) $(SYSTEM_H) \\\n   $(CORETYPES_H) errors.h $(HASH_TABLE_H) hash-map.h $(GGC_H) is-a.h \\\n-  tree.def builtins.def internal-fn.def\n+  tree.def builtins.def internal-fn.def case-cfn-macros.h\n build/gencfn-macros.o : gencfn-macros.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n   $(CORETYPES_H) errors.h $(HASH_TABLE_H) hash-set.h builtins.def\t\\\n   internal-fn.def"}, {"sha": "8b2e06551f2f2c92ed78a108a749b541fe85b57b", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,3 +1,11 @@\n+2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* brigfrontend/brig-function.cc\n+\t(brig_function::get_builtin_for_hsa_opcode): Use BUILT_IN_FMA\n+\tfor BRIG_OPCODE_FMA.\n+\t(brig_function::get_tree_code_for_hsa_opcode): Treat BUILT_IN_FMA\n+\tas a call.\n+\n 2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* brig/brigfrontend/brig-basic-inst-handler.cc:  Fix handling of NOPs."}, {"sha": "e019b8646347df23c7fbd0952dad98fc4c7bc038", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1218,6 +1218,7 @@ brig_function::get_builtin_for_hsa_opcode\n     case BRIG_OPCODE_NEXP2:\n       builtin = mathfn_built_in (builtin_type, BUILT_IN_EXP2);\n       break;\n+    case BRIG_OPCODE_FMA:\n     case BRIG_OPCODE_NFMA:\n       builtin = mathfn_built_in (builtin_type, BUILT_IN_FMA);\n       break;\n@@ -1460,8 +1461,6 @@ brig_function::get_tree_code_for_hsa_opcode\n \treturn CALL_EXPR;\n       else\n \treturn MAX_EXPR;\n-    case BRIG_OPCODE_FMA:\n-      return FMA_EXPR;\n     case BRIG_OPCODE_ABS:\n       return ABS_EXPR;\n     case BRIG_OPCODE_SHL:\n@@ -1496,6 +1495,7 @@ brig_function::get_tree_code_for_hsa_opcode\n       /* Implement as 1/f (x).  gcc should pattern detect that and\n \t use a native instruction, if available, for it.  */\n       return TREE_LIST;\n+    case BRIG_OPCODE_FMA:\n     case BRIG_OPCODE_FLOOR:\n     case BRIG_OPCODE_CEIL:\n     case BRIG_OPCODE_SQRT:"}, {"sha": "9a2bf8c7d3861387f55af171b5e9552e376c67c6", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -8340,21 +8340,6 @@ fold_builtin_abs (location_t loc, tree arg, tree type)\n   return fold_build1_loc (loc, ABS_EXPR, type, arg);\n }\n \n-/* Fold a call to fma, fmaf, or fmal with arguments ARG[012].  */\n-\n-static tree\n-fold_builtin_fma (location_t loc, tree arg0, tree arg1, tree arg2, tree type)\n-{\n-  /* ??? Only expand to FMA_EXPR if it's directly supported.  */\n-  if (validate_arg (arg0, REAL_TYPE)\n-      && validate_arg (arg1, REAL_TYPE)\n-      && validate_arg (arg2, REAL_TYPE)\n-      && optab_handler (fma_optab, TYPE_MODE (type)) != CODE_FOR_nothing)\n-    return fold_build3_loc (loc, FMA_EXPR, type, arg0, arg1, arg2);\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold a call to builtin carg(a+bi) -> atan2(b,a).  */\n \n static tree\n@@ -9260,10 +9245,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     CASE_FLT_FN (BUILT_IN_SINCOS):\n       return fold_builtin_sincos (loc, arg0, arg1, arg2);\n \n-    CASE_FLT_FN (BUILT_IN_FMA):\n-    CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMA):\n-      return fold_builtin_fma (loc, arg0, arg1, arg2, type);\n-\n     CASE_FLT_FN (BUILT_IN_REMQUO):\n       if (validate_arg (arg0, REAL_TYPE)\n \t  && validate_arg (arg1, REAL_TYPE)"}, {"sha": "f3a387de226a4236b4abe6d9f0b1ae165139725a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,3 +1,8 @@\n+2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gimple-parser.c (c_parser_gimple_postfix_expression): Remove\n+\t__FMA_EXPR handlng.\n+\n 2018-05-17  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gimple-parser.c: Include internal-fn.h."}, {"sha": "8f1c4425c091037153b5f388363a57f1e8b0811a", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -952,27 +952,6 @@ c_parser_gimple_postfix_expression (c_parser *parser)\n \t      expr.value = fold_convert (type, val);\n \t      return expr;\n \t    }\n-\t  else if (strcmp (IDENTIFIER_POINTER (id), \"__FMA\") == 0)\n-\t    {\n-\t      c_parser_consume_token (parser);\n-\t      auto_vec<tree> args;\n-\n-\t      if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t\t{\n-\t\t  c_parser_gimple_expr_list (parser, &args);\n-\t\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t\t     \"expected %<)%>\");\n-\t\t}\n-\t      if (args.length () != 3)\n-\t\t{\n-\t\t  error_at (loc, \"invalid number of operands to __FMA\");\n-\t\t  expr.value = error_mark_node;\n-\t\t  return expr;\n-\t\t}\n-\t      expr.value = build3_loc (loc, FMA_EXPR, TREE_TYPE (args[0]),\n-\t\t\t\t       args[0], args[1], args[2]);\n-\t      return expr;\n-\t    }\n \n \t  /* SSA name.  */\n \t  unsigned version, ver_offset;"}, {"sha": "5c323be9b33a9dee3eee18b4caf27279eb96a13b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -4202,7 +4202,6 @@ expand_debug_expr (tree exp)\n \tcase SAD_EXPR:\n \tcase WIDEN_MULT_PLUS_EXPR:\n \tcase WIDEN_MULT_MINUS_EXPR:\n-\tcase FMA_EXPR:\n \t  goto ternary;\n \n \tcase TRUTH_ANDIF_EXPR:\n@@ -5190,9 +5189,6 @@ expand_debug_expr (tree exp)\n \t}\n       return NULL;\n \n-    case FMA_EXPR:\n-      return simplify_gen_ternary (FMA, mode, inner_mode, op0, op1, op2);\n-\n     default:\n     flag_unsupported:\n       if (flag_checking)"}, {"sha": "184b721dbf32bf7e7e7d61d98f4f45caae7ebef2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -51133,19 +51133,20 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n   tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n   int stmt_cost = - 1;\n \n+  bool fp = false;\n+  machine_mode mode = TImode;\n+\n+  if (vectype != NULL)\n+    {\n+      fp = FLOAT_TYPE_P (vectype);\n+      mode = TYPE_MODE (vectype);\n+    }\n+\n   if ((kind == vector_stmt || kind == scalar_stmt)\n       && stmt_info\n       && stmt_info->stmt && gimple_code (stmt_info->stmt) == GIMPLE_ASSIGN)\n     {\n       tree_code subcode = gimple_assign_rhs_code (stmt_info->stmt);\n-      bool fp = false;\n-      machine_mode mode = TImode;\n-\n-      if (vectype != NULL)\n-\t{\n-\t  fp = FLOAT_TYPE_P (vectype);\n-\t  mode = TYPE_MODE (vectype);\n-\t}\n       /*machine_mode inner_mode = mode;\n       if (VECTOR_MODE_P (mode))\n \tinner_mode = GET_MODE_INNER (mode);*/\n@@ -51176,12 +51177,6 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \tcase MULT_HIGHPART_EXPR:\n \t  stmt_cost = ix86_multiplication_cost (ix86_cost, mode);\n \t  break;\n-\tcase FMA_EXPR:\n-          stmt_cost = ix86_vec_cost (mode,\n-\t\t\t\t     mode == SFmode ? ix86_cost->fmass\n-\t\t\t\t     : ix86_cost->fmasd,\n-\t\t\t\t     true);\n-\t  break;\n \tcase NEGATE_EXPR:\n \t  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t    stmt_cost = ix86_cost->sse_op;\n@@ -51244,6 +51239,24 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t  break;\n \t}\n     }\n+\n+  combined_fn cfn;\n+  if ((kind == vector_stmt || kind == scalar_stmt)\n+      && stmt_info\n+      && stmt_info->stmt\n+      && (cfn = gimple_call_combined_fn (stmt_info->stmt)) != CFN_LAST)\n+    switch (cfn)\n+      {\n+      case CFN_FMA:\n+\tstmt_cost = ix86_vec_cost (mode,\n+\t\t\t\t   mode == SFmode ? ix86_cost->fmass\n+\t\t\t\t   : ix86_cost->fmasd,\n+\t\t\t\t   true);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n   /* If we do elementwise loads into a vector then we are bound by\n      latency and execution resources for the many scalar loads\n      (AGU and load ports).  Try to account for this by scaling the"}, {"sha": "d62abdff7ee4ca9afbcabe290fef42feb86abb73", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -15880,7 +15880,9 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \targ1 = gimple_call_arg (stmt, 1);\n \ttree arg2 = gimple_call_arg (stmt, 2);\n \tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, FMA_EXPR, arg0, arg1, arg2);\n+\tgcall *g = gimple_build_call_internal (IFN_FMA, 3, arg0, arg1, arg2);\n+\tgimple_call_set_lhs (g, lhs);\n+\tgimple_call_set_nothrow (g, true);\n \tgimple_set_location (g, gimple_location (stmt));\n \tgsi_replace (gsi, g, true);\n \treturn true;"}, {"sha": "014662b16a52fe945d270f37183026fef6456c32", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,3 +1,8 @@\n+2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* constexpr.c (cxx_eval_constant_expression): Remove FMA_EXPR handling.\n+\t(potential_constant_expression_1): Likewise.\n+\n 2018-05-16  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/85363"}, {"sha": "fa1cfce3839afb66f1772d67ead4018663ee1c85", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -4574,7 +4574,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t     non_constant_p, overflow_p);\n       break;\n \n-    case FMA_EXPR:\n     case VEC_PERM_EXPR:\n       r = cxx_eval_trinary_expression (ctx, t, lval,\n \t\t\t\t       non_constant_p, overflow_p);\n@@ -5999,7 +5998,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  return false;\n       return true;\n \n-    case FMA_EXPR:\n     case VEC_PERM_EXPR:\n      for (i = 0; i < 3; ++i)\n       if (!RECUR (TREE_OPERAND (t, i), true))"}, {"sha": "dfb057805a6e58d4756b719afc10b0740c2f0a52", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2251,6 +2251,11 @@ Target supports @option{-pie}, @option{-fpie} and @option{-fPIE}.\n @item rdynamic\n Target supports @option{-rdynamic}.\n \n+@item scalar_all_fma\n+Target supports all four fused multiply-add optabs for both @code{float}\n+and @code{double}.  These optabs are: @code{fma_optab}, @code{fms_optab},\n+@code{fnma_optab} and @code{fnms_optab}.\n+\n @item section_anchors\n Target supports section anchors.\n "}, {"sha": "ecc52923a28a935bfc7f535ed60cbf4109836a83", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -8853,67 +8853,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n-    case FMA_EXPR:\n-      {\n-\toptab opt = fma_optab;\n-\tgimple *def0, *def2;\n-\n-\t/* If there is no insn for FMA, emit it as __builtin_fma{,f,l}\n-\t   call.  */\n-\tif (optab_handler (fma_optab, mode) == CODE_FOR_nothing)\n-\t  {\n-\t    tree fn = mathfn_built_in (TREE_TYPE (treeop0), BUILT_IN_FMA);\n-\t    tree call_expr;\n-\n-\t    gcc_assert (fn != NULL_TREE);\n-\t    call_expr = build_call_expr (fn, 3, treeop0, treeop1, treeop2);\n-\t    return expand_builtin (call_expr, target, subtarget, mode, false);\n-\t  }\n-\n-\tdef0 = get_def_for_expr (treeop0, NEGATE_EXPR);\n-\t/* The multiplication is commutative - look at its 2nd operand\n-\t   if the first isn't fed by a negate.  */\n-\tif (!def0)\n-\t  {\n-\t    def0 = get_def_for_expr (treeop1, NEGATE_EXPR);\n-\t    /* Swap operands if the 2nd operand is fed by a negate.  */\n-\t    if (def0)\n-\t      std::swap (treeop0, treeop1);\n-\t  }\n-\tdef2 = get_def_for_expr (treeop2, NEGATE_EXPR);\n-\n-\top0 = op2 = NULL;\n-\n-\tif (def0 && def2\n-\t    && optab_handler (fnms_optab, mode) != CODE_FOR_nothing)\n-\t  {\n-\t    opt = fnms_optab;\n-\t    op0 = expand_normal (gimple_assign_rhs1 (def0));\n-\t    op2 = expand_normal (gimple_assign_rhs1 (def2));\n-\t  }\n-\telse if (def0\n-\t\t && optab_handler (fnma_optab, mode) != CODE_FOR_nothing)\n-\t  {\n-\t    opt = fnma_optab;\n-\t    op0 = expand_normal (gimple_assign_rhs1 (def0));\n-\t  }\n-\telse if (def2\n-\t\t && optab_handler (fms_optab, mode) != CODE_FOR_nothing)\n-\t  {\n-\t    opt = fms_optab;\n-\t    op2 = expand_normal (gimple_assign_rhs1 (def2));\n-\t  }\n-\n-\tif (op0 == NULL)\n-\t  op0 = expand_expr (treeop0, subtarget, VOIDmode, EXPAND_NORMAL);\n-\tif (op2 == NULL)\n-\t  op2 = expand_normal (treeop2);\n-\top1 = expand_normal (treeop1);\n-\n-\treturn expand_ternary_op (TYPE_MODE (type), opt,\n-\t\t\t\t  op0, op1, op2, target, 0);\n-      }\n-\n     case MULT_EXPR:\n       /* If this is a fixed-point operation, then we cannot use the code\n \t below because \"expand_mult\" doesn't support sat/no-sat fixed-point"}, {"sha": "06a420601c000221fe4430c951b2093fe55fd59a", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1606,6 +1606,26 @@ fold_const_call_ssss (real_value *result, combined_fn fn,\n     CASE_CFN_FMA_FN:\n       return do_mpfr_arg3 (result, mpfr_fma, arg0, arg1, arg2, format);\n \n+    case CFN_FMS:\n+      {\n+\treal_value new_arg2 = real_value_negate (arg2);\n+\treturn do_mpfr_arg3 (result, mpfr_fma, arg0, arg1, &new_arg2, format);\n+      }\n+\n+    case CFN_FNMA:\n+      {\n+\treal_value new_arg0 = real_value_negate (arg0);\n+\treturn do_mpfr_arg3 (result, mpfr_fma, &new_arg0, arg1, arg2, format);\n+      }\n+\n+    case CFN_FNMS:\n+      {\n+\treal_value new_arg0 = real_value_negate (arg0);\n+\treal_value new_arg2 = real_value_negate (arg2);\n+\treturn do_mpfr_arg3 (result, mpfr_fma, &new_arg0, arg1,\n+\t\t\t     &new_arg2, format);\n+      }\n+\n     default:\n       return false;\n     }\n@@ -1719,20 +1739,3 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n       return fold_const_call_1 (fn, type, arg0, arg1, arg2);\n     }\n }\n-\n-/* Fold a fma operation with arguments ARG[012].  */\n-\n-tree\n-fold_fma (location_t, tree type, tree arg0, tree arg1, tree arg2)\n-{\n-  REAL_VALUE_TYPE result;\n-  if (real_cst_p (arg0)\n-      && real_cst_p (arg1)\n-      && real_cst_p (arg2)\n-      && do_mpfr_arg3 (&result, mpfr_fma, TREE_REAL_CST_PTR (arg0),\n-\t\t       TREE_REAL_CST_PTR (arg1), TREE_REAL_CST_PTR (arg2),\n-\t\t       REAL_MODE_FORMAT (TYPE_MODE (type))))\n-    return build_real (type, result);\n-\n-  return NULL_TREE;\n-}"}, {"sha": "7eeac9ac9cf520a49c3e4ca54380747360a368d9", "filename": "gcc/fold-const-call.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.h?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n tree fold_const_call (combined_fn, tree, tree);\n tree fold_const_call (combined_fn, tree, tree, tree);\n tree fold_const_call (combined_fn, tree, tree, tree, tree);\n-tree fold_fma (location_t, tree, tree, tree, tree);\n tree build_cmp_result (tree type, int res);\n \n #endif"}, {"sha": "dc277440aa9a5c354ea79b3a02e46a49c72ea4bd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -3297,7 +3297,6 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \tcase TRUTH_ORIF_EXPR:\n \t  return OP_SAME (0) && OP_SAME (1);\n \n-\tcase FMA_EXPR:\n \tcase WIDEN_MULT_PLUS_EXPR:\n \tcase WIDEN_MULT_MINUS_EXPR:\n \t  if (!OP_SAME (2))\n@@ -11708,17 +11707,6 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n       return NULL_TREE;\n \n-    case FMA_EXPR:\n-      /* For integers we can decompose the FMA if possible.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST\n-\t  && TREE_CODE (arg1) == INTEGER_CST)\n-\treturn fold_build2_loc (loc, PLUS_EXPR, type,\n-\t\t\t\tconst_binop (MULT_EXPR, arg0, arg1), arg2);\n-      if (integer_zerop (arg2))\n-\treturn fold_build2_loc (loc, MULT_EXPR, type, arg0, arg1);\n-\n-      return fold_fma (loc, type, arg0, arg1, arg2);\n-\n     case VEC_PERM_EXPR:\n       if (TREE_CODE (arg2) == VECTOR_CST)\n \t{"}, {"sha": "c794e4d30cf5f373b2be3a06146ffb29d5d1a939", "filename": "gcc/genmatch.c", "status": "modified", "additions": 77, "deletions": 24, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -241,6 +241,20 @@ enum internal_fn {\n   IFN_LAST\n };\n \n+enum combined_fn {\n+#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM, COND) \\\n+  CFN_##ENUM = int (ENUM),\n+#include \"builtins.def\"\n+\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) \\\n+  CFN_##CODE = int (END_BUILTINS) + int (IFN_##CODE),\n+#include \"internal-fn.def\"\n+\n+  CFN_LAST\n+};\n+\n+#include \"case-cfn-macros.h\"\n+\n /* Return true if CODE represents a commutative tree code.  Otherwise\n    return false.  */\n bool\n@@ -288,7 +302,6 @@ commutative_ternary_tree_code (enum tree_code code)\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n     case DOT_PROD_EXPR:\n-    case FMA_EXPR:\n       return true;\n \n     default:\n@@ -450,6 +463,44 @@ is_a_helper <user_id *>::test (id_base *id)\n   return id->kind == id_base::USER;\n }\n \n+/* If ID has a pair of consecutive, commutative operands, return the\n+   index of the first, otherwise return -1.  */\n+\n+static int\n+commutative_op (id_base *id)\n+{\n+  if (operator_id *code = dyn_cast <operator_id *> (id))\n+    {\n+      if (commutative_tree_code (code->code)\n+\t  || commutative_ternary_tree_code (code->code))\n+\treturn 0;\n+      return -1;\n+    }\n+  if (fn_id *fn = dyn_cast <fn_id *> (id))\n+    switch (fn->fn)\n+      {\n+      CASE_CFN_FMA:\n+      case CFN_FMS:\n+      case CFN_FNMA:\n+      case CFN_FNMS:\n+\treturn 0;\n+\n+      default:\n+\treturn -1;\n+      }\n+  if (user_id *uid = dyn_cast<user_id *> (id))\n+    {\n+      int res = commutative_op (uid->substitutes[0]);\n+      if (res < 0)\n+\treturn 0;\n+      for (unsigned i = 1; i < uid->substitutes.length (); ++i)\n+\tif (res != commutative_op (uid->substitutes[i]))\n+\t  return -1;\n+      return res;\n+    }\n+  return -1;\n+}\n+\n /* Add a predicate identifier to the hash.  */\n \n static predicate_id *\n@@ -946,6 +997,9 @@ commutate (operand *op, vec<vec<user_id *> > &for_vec)\n   if (!e->is_commutative)\n     return ret;\n \n+  /* The operation is always binary if it isn't inherently commutative.  */\n+  int natural_opno = commutative_op (e->operation);\n+  unsigned int opno = natural_opno >= 0 ? natural_opno : 0;\n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n       expr *ne = new expr (e);\n@@ -994,9 +1048,11 @@ commutate (operand *op, vec<vec<user_id *> > &for_vec)\n \t    }\n \t}\n       ne->is_commutative = false;\n-      // result[i].length () is 2 since e->operation is binary\n-      for (unsigned j = result[i].length (); j; --j)\n-\tne->append_op (result[i][j-1]);\n+      for (unsigned j = 0; j < result[i].length (); ++j)\n+\t{\n+\t  int old_j = (j == opno ? opno + 1 : j == opno + 1 ? opno : j);\n+\t  ne->append_op (result[i][old_j]);\n+\t}\n       ret.safe_push (ne);\n     }\n \n@@ -2759,24 +2815,18 @@ dt_operand::gen_gimple_expr (FILE *f, int indent)\n   /* While the toplevel operands are canonicalized by the caller\n      after valueizing operands of sub-expressions we have to\n      re-canonicalize operand order.  */\n-  if (operator_id *code = dyn_cast <operator_id *> (id))\n+  int opno = commutative_op (id);\n+  if (opno >= 0)\n     {\n-      /* ???  We can't canonicalize tcc_comparison operands here\n-         because that requires changing the comparison code which\n-\t we already matched...  */\n-      if (commutative_tree_code (code->code)\n-\t  || commutative_ternary_tree_code (code->code))\n-\t{\n-\t  char child_opname0[20], child_opname1[20];\n-\t  gen_opname (child_opname0, 0);\n-\t  gen_opname (child_opname1, 1);\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"if (tree_swap_operands_p (%s, %s))\\n\",\n-\t\t\t  child_opname0, child_opname1);\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"  std::swap (%s, %s);\\n\",\n-\t\t\t  child_opname0, child_opname1);\n-\t}\n+      char child_opname0[20], child_opname1[20];\n+      gen_opname (child_opname0, opno);\n+      gen_opname (child_opname1, opno + 1);\n+      fprintf_indent (f, indent,\n+\t\t      \"if (tree_swap_operands_p (%s, %s))\\n\",\n+\t\t      child_opname0, child_opname1);\n+      fprintf_indent (f, indent,\n+\t\t      \"  std::swap (%s, %s);\\n\",\n+\t\t      child_opname0, child_opname1);\n     }\n \n   return n_braces;\n@@ -4217,11 +4267,14 @@ parser::parse_expr ()\n \t\t      e->operation->id, e->operation->nargs, e->ops.length ());\n \t  if (is_commutative)\n \t    {\n-\t      if (e->ops.length () == 2)\n+\t      if (e->ops.length () == 2\n+\t\t  || commutative_op (e->operation) >= 0)\n \t\te->is_commutative = true;\n \t      else\n-\t\tfatal_at (token, \"only binary operators or function with \"\n-\t\t\t  \"two arguments can be marked commutative\");\n+\t\tfatal_at (token, \"only binary operators or functions with \"\n+\t\t\t  \"two arguments can be marked commutative, \"\n+\t\t\t  \"unless the operation is known to be inherently \"\n+\t\t\t  \"commutative\");\n \t    }\n \t  e->expr_type = expr_type;\n \t  return op;"}, {"sha": "b45798c36ea556c63c8e86ce3a92ee1028cacc49", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -4967,6 +4967,14 @@ follow_single_use_edges (tree val)\n   return val;\n }\n \n+/* Valueization callback that follows all SSA edges.  */\n+\n+tree\n+follow_all_ssa_edges (tree val)\n+{\n+  return val;\n+}\n+\n /* Fold the statement pointed to by GSI.  In some cases, this function may\n    replace the whole statement with a new one.  Returns true iff folding\n    makes any changes."}, {"sha": "0a28ec7c5a231c4c4204d2d764570ec0164a5eea", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -41,6 +41,7 @@ extern bool arith_overflowed_p (enum tree_code, const_tree, const_tree,\n \t\t\t\tconst_tree);\n extern tree no_follow_ssa_edges (tree);\n extern tree follow_single_use_edges (tree);\n+extern tree follow_all_ssa_edges (tree);\n extern tree gimple_fold_stmt_to_constant_1 (gimple *, tree (*) (tree),\n \t\t\t\t\t    tree (*) (tree) = no_follow_ssa_edges);\n extern tree gimple_fold_stmt_to_constant (gimple *, tree (*) (tree));"}, {"sha": "49e9e1276da03889dc25b53861bff241a0737c20", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -490,27 +490,6 @@ dump_ternary_rhs (pretty_printer *buffer, gassign *gs, int spc,\n       pp_greater (buffer);\n       break;\n \n-    case FMA_EXPR:\n-      if (flags & TDF_GIMPLE)\n-\t{\n-\t  pp_string (buffer, \"__FMA (\");\n-\t  dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n-\t  pp_comma (buffer);\n-\t  dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n-\t  pp_comma (buffer);\n-\t  dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n-\t  pp_right_paren (buffer);\n-\t}\n-      else\n-\t{\n-\t  dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n-\t  pp_string (buffer, \" * \");\n-\t  dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n-\t  pp_string (buffer, \" + \");\n-\t  dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n-\t}\n-      break;\n-\n     case DOT_PROD_EXPR:\n       pp_string (buffer, \"DOT_PROD_EXPR <\");\n       dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);"}, {"sha": "9ab655c43e8eb00653a22ce24a8682d513c6876e", "filename": "gcc/gimple-ssa-backprop.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-ssa-backprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple-ssa-backprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-backprop.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -375,6 +375,9 @@ backprop::process_builtin_call_use (gcall *call, tree rhs, usage_info *info)\n \n     CASE_CFN_FMA:\n     CASE_CFN_FMA_FN:\n+    case CFN_FMS:\n+    case CFN_FNMA:\n+    case CFN_FNMS:\n       /* In X * X + Y, where Y is distinct from X, the sign of X doesn't\n \t matter.  */\n       if (gimple_call_arg (call, 0) == rhs\n@@ -420,15 +423,6 @@ backprop::process_assign_use (gassign *assign, tree rhs, usage_info *info)\n \t}\n       break;\n \n-    case FMA_EXPR:\n-      /* In X * X + Y, where Y is distinct from X, the sign of X doesn't\n-\t matter.  */\n-      if (gimple_assign_rhs1 (assign) == rhs\n-\t  && gimple_assign_rhs2 (assign) == rhs\n-\t  && gimple_assign_rhs3 (assign) != rhs)\n-\tinfo->flags.ignore_sign = true;\n-      break;\n-\n     case MULT_EXPR:\n       /* In X * X, the sign of X doesn't matter.  */\n       if (gimple_assign_rhs1 (assign) == rhs"}, {"sha": "4b91151873cb578233a1f6f51358384144389f83", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2150,8 +2150,7 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == REALIGN_LOAD_EXPR\t\t\t\t\t    \\\n       || (SYM) == VEC_COND_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == VEC_PERM_EXPR                                             \\\n-      || (SYM) == BIT_INSERT_EXPR\t\t\t\t\t    \\\n-      || (SYM) == FMA_EXPR) ? GIMPLE_TERNARY_RHS\t\t\t    \\\n+      || (SYM) == BIT_INSERT_EXPR) ? GIMPLE_TERNARY_RHS\t\t\t    \\\n    : ((SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n       || (SYM) == OBJ_TYPE_REF\t\t\t\t\t\t    \\\n       || (SYM) == ASSERT_EXPR\t\t\t\t\t\t    \\"}, {"sha": "9771804f27e53aed6c723171f4a72db59347569d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -12086,7 +12086,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  }\n \t  break;\n \n-\tcase FMA_EXPR:\n \tcase VEC_PERM_EXPR:\n \t  /* Classified as tcc_expression.  */\n \t  goto expr_3;"}, {"sha": "74d5f07b3cb486d96d2dc567553ef33210e4c8aa", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -3178,23 +3178,6 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n     case NEGATE_EXPR:\n       opcode = BRIG_OPCODE_NEG;\n       break;\n-    case FMA_EXPR:\n-      /* There is a native HSA instruction for scalar FMAs but not for vector\n-\t ones.  */\n-      if (TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE)\n-\t{\n-\t  hsa_op_reg *dest\n-\t    = hsa_cfun->reg_for_gimple_ssa (gimple_assign_lhs (assign));\n-\t  hsa_op_with_type *op1 = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n-\t  hsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n-\t  hsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n-\t  hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n-\t  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp, op1, op2, hbb);\n-\t  gen_hsa_binary_operation (BRIG_OPCODE_ADD, dest, tmp, op3, hbb);\n-\t  return;\n-\t}\n-      opcode = BRIG_OPCODE_MAD;\n-      break;\n     case MIN_EXPR:\n       opcode = BRIG_OPCODE_MIN;\n       break;\n@@ -4490,6 +4473,57 @@ gen_hsa_divmod (gcall *call, hsa_bb *hbb)\n   insn->set_output_in_type (dest, 0, hbb);\n }\n \n+/* Emit instructions that implement FMA, FMS, FNMA or FNMS call STMT.\n+   Instructions are appended to basic block HBB.  NEGATE1 is true for\n+   FNMA and FNMS.  NEGATE3 is true for FMS and FNMS.  */\n+\n+static void\n+gen_hsa_fma (gcall *call, hsa_bb *hbb, bool negate1, bool negate3)\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  if (lhs == NULL_TREE)\n+    return;\n+\n+  tree rhs1 = gimple_call_arg (call, 0);\n+  tree rhs2 = gimple_call_arg (call, 1);\n+  tree rhs3 = gimple_call_arg (call, 2);\n+\n+  hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n+  hsa_op_with_type *op1 = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+  hsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n+  hsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n+\n+  if (negate1)\n+    {\n+      hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n+      gen_hsa_unary_operation (BRIG_OPCODE_NEG, tmp, op1, hbb);\n+      op1 = tmp;\n+    }\n+\n+  /* There is a native HSA instruction for scalar FMAs but not for vector\n+     ones.  */\n+  if (TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE)\n+    {\n+      hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n+      gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp, op1, op2, hbb);\n+      gen_hsa_binary_operation (negate3 ? BRIG_OPCODE_SUB : BRIG_OPCODE_ADD,\n+\t\t\t\tdest, tmp, op3, hbb);\n+    }\n+  else\n+    {\n+      if (negate3)\n+\t{\n+\t  hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n+\t  gen_hsa_unary_operation (BRIG_OPCODE_NEG, tmp, op3, hbb);\n+\t  op3 = tmp;\n+\t}\n+      hsa_insn_basic *insn = new hsa_insn_basic (4, BRIG_OPCODE_MAD,\n+\t\t\t\t\t\t dest->m_type, dest,\n+\t\t\t\t\t\t op1, op2, op3);\n+      hbb->append_insn (insn);\n+    }\n+}\n+\n /* Set VALUE to a shadow kernel debug argument and append a new instruction\n    to HBB basic block.  */\n \n@@ -5224,6 +5258,22 @@ gen_hsa_insn_for_internal_fn_call (gcall *stmt, hsa_bb *hbb)\n       gen_hsa_insns_for_call_of_internal_fn (stmt, hbb);\n       break;\n \n+    case IFN_FMA:\n+      gen_hsa_fma (stmt, hbb, false, false);\n+      break;\n+\n+    case IFN_FMS:\n+      gen_hsa_fma (stmt, hbb, false, true);\n+      break;\n+\n+    case IFN_FNMA:\n+      gen_hsa_fma (stmt, hbb, true, false);\n+      break;\n+\n+    case IFN_FNMS:\n+      gen_hsa_fma (stmt, hbb, true, true);\n+      break;\n+\n     default:\n       HSA_SORRY_ATV (gimple_location (stmt),\n \t\t     \"support for HSA does not implement internal function: %s\","}, {"sha": "b2c4a319a531e2b968494ca173bed143750e9538", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -110,6 +110,7 @@ init_internal_fns ()\n #define scatter_store_direct { 3, 3, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n+#define ternary_direct { 0, 0, true }\n #define cond_unary_direct { 1, 1, true }\n #define cond_binary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n@@ -2982,6 +2983,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n \n+#define expand_ternary_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n+\n #define expand_cond_unary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n \n@@ -3067,6 +3071,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n \n #define direct_unary_optab_supported_p direct_optab_supported_p\n #define direct_binary_optab_supported_p direct_optab_supported_p\n+#define direct_ternary_optab_supported_p direct_optab_supported_p\n #define direct_cond_unary_optab_supported_p direct_optab_supported_p\n #define direct_cond_binary_optab_supported_p direct_optab_supported_p\n #define direct_mask_load_optab_supported_p direct_optab_supported_p"}, {"sha": "a5f8504849054cfd0d6d0d2467ae4f3c05441f59", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    - unary: a normal unary optab, such as vec_reverse_<mode>\n    - binary: a normal binary optab, such as vec_interleave_lo_<mode>\n+   - ternary: a normal ternary optab, such as fma<mode>4\n \n    - cond_binary: a conditional binary optab, such as add<mode>cc\n \n@@ -138,6 +139,10 @@ DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n DEF_INTERNAL_OPTAB_FN (VEC_SHL_INSERT, ECF_CONST | ECF_NOTHROW,\n \t\t       vec_shl_insert, binary)\n \n+DEF_INTERNAL_OPTAB_FN (FMS, ECF_CONST, fms, ternary)\n+DEF_INTERNAL_OPTAB_FN (FNMA, ECF_CONST, fnma, ternary)\n+DEF_INTERNAL_OPTAB_FN (FNMS, ECF_CONST, fnms, ternary)\n+\n DEF_INTERNAL_OPTAB_FN (COND_ADD, ECF_CONST, cond_add, cond_binary)\n DEF_INTERNAL_OPTAB_FN (COND_SUB, ECF_CONST, cond_sub, cond_binary)\n DEF_INTERNAL_SIGNED_OPTAB_FN (COND_MIN, ECF_CONST, first,\n@@ -218,6 +223,9 @@ DEF_INTERNAL_OPTAB_FN (XORSIGN, ECF_CONST, xorsign, binary)\n /* FP scales.  */\n DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)\n \n+/* Ternary math functions.  */\n+DEF_INTERNAL_FLT_FN (FMA, ECF_CONST, fma, ternary)\n+\n /* Unary integer ops.  */\n DEF_INTERNAL_INT_FN (CLRSB, ECF_CONST | ECF_NOTHROW, clrsb, unary)\n DEF_INTERNAL_INT_FN (CLZ, ECF_CONST | ECF_NOTHROW, clz, unary)"}, {"sha": "2f4c5e6a14b219c286b6e1cedc2270235d1ec5be", "filename": "gcc/match.pd", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -4702,3 +4702,60 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t|| wi::geu_p (wi::to_wide (@rpos),\n \t\t      wi::to_wide (@ipos) + isize))\n     (BIT_FIELD_REF @0 @rsize @rpos)))))\n+\n+(for fmas (FMA)\n+ (simplify\n+  (fmas:c (negate @0) @1 @2)\n+  (IFN_FNMA @0 @1 @2))\n+ (simplify\n+  (fmas @0 @1 (negate @2))\n+  (IFN_FMS @0 @1 @2))\n+ (simplify\n+  (fmas:c (negate @0) @1 (negate @2))\n+  (IFN_FNMS @0 @1 @2))\n+ (simplify\n+  (negate (fmas@3 @0 @1 @2))\n+  (if (single_use (@3))\n+   (IFN_FNMS @0 @1 @2))))\n+\n+(simplify\n+ (IFN_FMS:c (negate @0) @1 @2)\n+ (IFN_FNMS @0 @1 @2))\n+(simplify\n+ (IFN_FMS @0 @1 (negate @2))\n+ (IFN_FMA @0 @1 @2))\n+(simplify\n+ (IFN_FMS:c (negate @0) @1 (negate @2))\n+ (IFN_FNMA @0 @1 @2))\n+(simplify\n+ (negate (IFN_FMS@3 @0 @1 @2))\n+  (if (single_use (@3))\n+   (IFN_FNMA @0 @1 @2)))\n+\n+(simplify\n+ (IFN_FNMA:c (negate @0) @1 @2)\n+ (IFN_FMA @0 @1 @2))\n+(simplify\n+ (IFN_FNMA @0 @1 (negate @2))\n+ (IFN_FNMS @0 @1 @2))\n+(simplify\n+ (IFN_FNMA:c (negate @0) @1 (negate @2))\n+ (IFN_FMS @0 @1 @2))\n+(simplify\n+ (negate (IFN_FNMA@3 @0 @1 @2))\n+ (if (single_use (@3))\n+  (IFN_FMS @0 @1 @2)))\n+\n+(simplify\n+ (IFN_FNMS:c (negate @0) @1 @2)\n+ (IFN_FMS @0 @1 @2))\n+(simplify\n+ (IFN_FNMS @0 @1 (negate @2))\n+ (IFN_FNMA @0 @1 @2))\n+(simplify\n+ (IFN_FNMS:c (negate @0) @1 (negate @2))\n+ (IFN_FMA @0 @1 @2))\n+(simplify\n+ (negate (IFN_FNMS@3 @0 @1 @2))\n+ (if (single_use (@3))\n+  (IFN_FMA @0 @1 @2)))"}, {"sha": "73e66544ef9fb359690f354b08060b02012a30f4", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -143,9 +143,6 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n \t      : (TYPE_SATURATING (type)\n \t\t ? ssmsub_widen_optab : smsub_widen_optab));\n \n-    case FMA_EXPR:\n-      return fma_optab;\n-\n     case VEC_WIDEN_MULT_HI_EXPR:\n       return TYPE_UNSIGNED (type) ?\n \tvec_widen_umult_hi_optab : vec_widen_smult_hi_optab;"}, {"sha": "ff49c88158b520410fd7865236536c3b70acf8d3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,3 +1,21 @@\n+2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lib/target-supports.exp (check_effective_target_scalar_all_fma):\n+\tNew proc.\n+\t* gcc.dg/fma-1.c: New test.\n+\t* gcc.dg/fma-2.c: Likewise.\n+\t* gcc.dg/fma-3.c: Likewise.\n+\t* gcc.dg/fma-4.c: Likewise.\n+\t* gcc.dg/fma-5.c: Likewise.\n+\t* gcc.dg/fma-6.c: Likewise.\n+\t* gcc.dg/fma-7.c: Likewise.\n+\t* gcc.dg/gimplefe-26.c: Use .FMA instead of __FMA and require\n+\tscalar_all_fma.\n+\t* gfortran.dg/reassoc_7.f: Pass -ffp-contract=off.\n+\t* gfortran.dg/reassoc_8.f: Likewise.\n+\t* gfortran.dg/reassoc_9.f: Likewise.\n+\t* gfortran.dg/reassoc_10.f: Likewise.\n+\n 2018-05-17  Jim Wilson  <jimw@sifive.com>\n \n \t* gcc.target/riscv/switch-qi.c: New."}, {"sha": "8c33cb2d64c9b5ead8432999b7a17fb9dc8031e3", "filename": "gcc/testsuite/gcc.dg/fma-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-1.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 -fdump-tree-widening_mul\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return a * b + c;\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return a * b + c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FMA \\(} 2 \"widening_mul\" { target scalar_all_fma } } } */"}, {"sha": "41d20a4296709d328e416c6feb6ed1f876cee641", "filename": "gcc/testsuite/gcc.dg/fma-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-2.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 -fdump-tree-widening_mul\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return a * b - c;\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return a * b - c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FMS \\(} 2 \"widening_mul\" { target scalar_all_fma } } } */"}, {"sha": "699aa2c95305a6a509566a81c49dbff6fe014a14", "filename": "gcc/testsuite/gcc.dg/fma-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-3.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 -fdump-tree-widening_mul\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return c - a * b;\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return c - a * b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FNMA \\(} 2 \"widening_mul\" { target scalar_all_fma } } } */"}, {"sha": "bff928f1facd08abf523c8022210632c36d9ae49", "filename": "gcc/testsuite/gcc.dg/fma-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-4.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 -fdump-tree-widening_mul\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return -(a * b) - c;\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return -(a * b) - c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FNMS \\(} 2 \"widening_mul\" { target scalar_all_fma } } } */"}, {"sha": "68d75979fd5dc7869147000480630b262e584046", "filename": "gcc/testsuite/gcc.dg/fma-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-5.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return __builtin_fmaf (a, b, -c);\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return __builtin_fma (a, b, -c);\n+}\n+\n+void\n+f3 (float a, float b, float c, float d, float e, float *res)\n+{\n+  res[0] = __builtin_fmaf (a, b, -e);\n+  res[1] = __builtin_fmaf (c, d, -e);\n+}\n+\n+void\n+f4 (double a, double b, double c, double d, double e, double *res)\n+{\n+  res[0] = __builtin_fma (a, b, -e);\n+  res[1] = __builtin_fma (c, d, -e);\n+}\n+\n+float\n+f5 (float a, float b, float c)\n+{\n+  return -__builtin_fmaf (-a, b, c);\n+}\n+\n+double\n+f6 (double a, double b, double c)\n+{\n+  return -__builtin_fma (-a, b, c);\n+}\n+\n+float\n+f7 (float a, float b, float c)\n+{\n+  return -__builtin_fmaf (a, -b, c);\n+}\n+\n+double\n+f8 (double a, double b, double c)\n+{\n+  return -__builtin_fma (a, -b, c);\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FMS \\(} 10 \"optimized\" { target scalar_all_fma } } } */"}, {"sha": "87258cec4a27e708392dc07bd1815a4d6b68946e", "filename": "gcc/testsuite/gcc.dg/fma-6.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-6.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return __builtin_fmaf (-a, b, c);\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return __builtin_fma (-a, b, c);\n+}\n+\n+float\n+f3 (float a, float b, float c)\n+{\n+  return __builtin_fmaf (a, -b, c);\n+}\n+\n+double\n+f4 (double a, double b, double c)\n+{\n+  return __builtin_fma (a, -b, c);\n+}\n+\n+void\n+f5 (float a, float b, float c, float d, float e, float *res)\n+{\n+  res[0] = __builtin_fmaf (-a, b, c);\n+  res[1] = __builtin_fmaf (-a, d, e);\n+}\n+\n+void\n+f6 (double a, double b, double c, double d, double e, double *res)\n+{\n+  res[0] = __builtin_fma (-a, b, c);\n+  res[1] = __builtin_fma (-a, d, e);\n+}\n+\n+void\n+f7 (float a, float b, float c, float d, float e, float *res)\n+{\n+  res[0] = __builtin_fmaf (a, -b, c);\n+  res[1] = __builtin_fmaf (d, -b, e);\n+}\n+\n+void\n+f8 (double a, double b, double c, double d, double e, double *res)\n+{\n+  res[0] = __builtin_fma (a, -b, c);\n+  res[1] = __builtin_fma (d, -b, e);\n+}\n+\n+float\n+f9 (float a, float b, float c)\n+{\n+  return -__builtin_fmaf (a, b, -c);\n+}\n+\n+double\n+f10 (double a, double b, double c)\n+{\n+  return -__builtin_fma (a, b, -c);\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FNMA \\(} 14 \"optimized\" { target scalar_all_fma } } } */"}, {"sha": "f409cc8ee3c2c40ef4c9f81a51643769d32c3edf", "filename": "gcc/testsuite/gcc.dg/fma-7.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffma-7.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return __builtin_fmaf (-a, b, -c);\n+}\n+\n+double\n+f2 (double a, double b, double c)\n+{\n+  return __builtin_fma (-a, b, -c);\n+}\n+\n+float\n+f3 (float a, float b, float c)\n+{\n+  return __builtin_fmaf (a, -b, -c);\n+}\n+\n+double\n+f4 (double a, double b, double c)\n+{\n+  return __builtin_fma (a, -b, -c);\n+}\n+\n+void\n+f5 (float a, float b, float c, float d, float *res)\n+{\n+  res[0] = __builtin_fmaf (-a, b, -c);\n+  res[1] = __builtin_fmaf (-a, d, -c);\n+}\n+\n+void\n+f6 (double a, double b, double c, double d, double *res)\n+{\n+  res[0] = __builtin_fma (-a, b, -c);\n+  res[1] = __builtin_fma (-a, d, -c);\n+}\n+\n+void\n+f7 (float a, float b, float c, float d, float *res)\n+{\n+  res[0] = __builtin_fmaf (a, -b, -c);\n+  res[1] = __builtin_fmaf (d, -b, -c);\n+}\n+\n+void\n+f8 (double a, double b, double c, double d, double *res)\n+{\n+  res[0] = __builtin_fma (a, -b, -c);\n+  res[1] = __builtin_fma (d, -b, -c);\n+}\n+\n+float\n+f9 (float a, float b, float c)\n+{\n+  return -__builtin_fmaf (a, b, c);\n+}\n+\n+double\n+f10 (double a, double b, double c)\n+{\n+  return -__builtin_fma (a, b, c);\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = \\.FNMS \\(} 14 \"optimized\" { target scalar_all_fma } } } */"}, {"sha": "f4dbdb18bb66ad52f0724070df3e7ae90e56d4be", "filename": "gcc/testsuite/gcc.dg/gimplefe-26.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-26.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,16 +1,15 @@\n-/* { dg-do compile { target c99_runtime } } */\n+/* { dg-do compile { target scalar_all_fma } } */\n /* { dg-options \"-O -fgimple -fdump-tree-ssa-gimple\" } */\n \n #define foo(type, num) \\\n type __GIMPLE () foo_##num (type a, type b, type c) \\\n { \\\n   type t0; \\\n-  t0_1 = __FMA (a, b, c); \\\n+  t0_1 = .FMA (a, b, c); \\\n   return t0_1; \\\n }\n \n foo(float, 1)\n foo(double, 2)\n-foo(long double, 3)\n \n-/* { dg-final { scan-tree-dump-times \"__FMA\" 3 \"ssa\" } } */\n+/* { dg-final { scan-tree-dump-times {\\.FMA} 2 \"ssa\" } } */"}, {"sha": "4a0a6c23f03daf70da696d0edb68b26e450807a7", "filename": "gcc/testsuite/gfortran.dg/reassoc_10.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+! { dg-options \"-O3 -ffast-math -ffp-contract=off -fdump-tree-optimized\" }\n \n       SUBROUTINE S55199(P,Q,Dvdph)\n       implicit none"}, {"sha": "fce93a8a8d0e4a6d4347d4feab26aaf3c9c04e73", "filename": "gcc/testsuite/gfortran.dg/reassoc_7.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+! { dg-options \"-O3 -ffast-math -ffp-contract=off -fdump-tree-optimized\" }\n \n       SUBROUTINE S55199(P,Dvdph)\n       implicit none"}, {"sha": "3a169010cdde1df55eb79a1d2b382cfcac066d52", "filename": "gcc/testsuite/gfortran.dg/reassoc_8.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+! { dg-options \"-O3 -ffast-math -ffp-contract=off -fdump-tree-optimized\" }\n \n       SUBROUTINE S55199(P,Dvdph)\n       implicit none"}, {"sha": "5ed53db1fdabd97805c086fa0ada00898b4c5cb6", "filename": "gcc/testsuite/gfortran.dg/reassoc_9.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+! { dg-options \"-O3 -ffast-math -ffp-contract=off -fdump-tree-optimized\" }\n \n       SUBROUTINE S55199(P,Dvdph)\n       implicit none"}, {"sha": "7ce727187266863f5c9ebc2ba147030f11022dde", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2879,6 +2879,13 @@ proc check_effective_target_base_quadfloat_support { } {\n     return 1\n }\n \n+# Return 1 if the target supports all four forms of fused multiply-add\n+# (fma, fms, fnma, and fnms) for both float and double.\n+\n+proc check_effective_target_scalar_all_fma { } {\n+    return [istarget aarch64*-*-*]\n+}\n+\n # Return 1 if the target supports compiling fixed-point,\n # 0 otherwise.\n "}, {"sha": "68f4fd3a7cc13ec2e87d5ae7db3126b46f1ac287", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -4109,20 +4109,6 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t}\n       break;\n \n-    case FMA_EXPR:\n-      if (!useless_type_conversion_p (lhs_type, rhs1_type)\n-\t  || !useless_type_conversion_p (lhs_type, rhs2_type)\n-\t  || !useless_type_conversion_p (lhs_type, rhs3_type))\n-\t{\n-\t  error (\"type mismatch in fused multiply-add expression\");\n-\t  debug_generic_expr (lhs_type);\n-\t  debug_generic_expr (rhs1_type);\n-\t  debug_generic_expr (rhs2_type);\n-\t  debug_generic_expr (rhs3_type);\n-\t  return true;\n-\t}\n-      break;\n-\n     case VEC_COND_EXPR:\n       if (!VECTOR_BOOLEAN_TYPE_P (rhs1_type)\n \t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs1_type),"}, {"sha": "30c6d9e3d02e4ee9d29120b9b0e6332673d90dd8", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2512,8 +2512,7 @@ operation_could_trap_p (enum tree_code op, bool fp_operation, bool honor_trapv,\n \n   if (TREE_CODE_CLASS (op) != tcc_comparison\n       && TREE_CODE_CLASS (op) != tcc_unary\n-      && TREE_CODE_CLASS (op) != tcc_binary\n-      && op != FMA_EXPR)\n+      && TREE_CODE_CLASS (op) != tcc_binary)\n     return false;\n \n   return operation_could_trap_helper_p (op, fp_operation, honor_trapv,\n@@ -2825,8 +2824,7 @@ stmt_could_throw_1_p (gassign *stmt)\n \n   if (TREE_CODE_CLASS (code) == tcc_comparison\n       || TREE_CODE_CLASS (code) == tcc_unary\n-      || TREE_CODE_CLASS (code) == tcc_binary\n-      || code == FMA_EXPR)\n+      || TREE_CODE_CLASS (code) == tcc_binary)\n     {\n       if (TREE_CODE_CLASS (code) == tcc_comparison)\n \tt = TREE_TYPE (gimple_assign_rhs1 (stmt));"}, {"sha": "78811317e26b27bc985c0063d8b0ce659617738a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -3855,7 +3855,6 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case MINUS_EXPR:\n     case MULT_EXPR:\n     case MULT_HIGHPART_EXPR:\n-    case FMA_EXPR:\n \n     case ADDR_SPACE_CONVERT_EXPR:\n     case FIXED_CONVERT_EXPR:"}, {"sha": "5a8c8eb79460785bb679aaa3cb634a6d6f2bce2d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2904,16 +2904,6 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       pp_string (pp, \" > \");\n       break;\n \n-    case FMA_EXPR:\n-      pp_string (pp, \" FMA_EXPR < \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (pp, \", \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 1), spc, flags, false);\n-      pp_string (pp, \", \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 2), spc, flags, false);\n-      pp_string (pp, \" > \");\n-      break;\n-\n     case OACC_PARALLEL:\n       pp_string (pp, \"#pragma acc parallel\");\n       goto dump_omp_clauses_body;\n@@ -3552,7 +3542,6 @@ op_code_prio (enum tree_code code)\n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-    case FMA_EXPR:\n       return 13;\n \n     case TRUTH_NOT_EXPR:"}, {"sha": "01a954eeb1e52fdc341c8e4c114607675ab1d2a2", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -493,7 +493,6 @@ stmt_cost (gimple *stmt)\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n     case DOT_PROD_EXPR:\n-    case FMA_EXPR:\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:"}, {"sha": "273396da073e0aaefa9058aab4f53cd5e4900fb3", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -2650,14 +2650,15 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n   tree type = TREE_TYPE (mul_result);\n   gimple *use_stmt;\n   imm_use_iterator imm_iter;\n-  gassign *fma_stmt;\n+  gcall *fma_stmt;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n       enum tree_code use_code;\n       tree addop, mulop1 = op1, result = mul_result;\n       bool negate_p = false;\n+      gimple_seq seq = NULL;\n \n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n@@ -2683,11 +2684,7 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n \t  addop = gimple_assign_rhs2 (use_stmt);\n \t  /* a * b - c -> a * b + (-c)  */\n \t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n-\t    addop = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t      build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t      type, addop),\n-\t\t\t\t\t      true, NULL_TREE, true,\n-\t\t\t\t\t      GSI_SAME_STMT);\n+\t    addop = gimple_build (&seq, NEGATE_EXPR, type, addop);\n \t}\n       else\n \t{\n@@ -2698,23 +2695,26 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n \t}\n \n       if (negate_p)\n-\tmulop1 = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t   build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t   type, mulop1),\n-\t\t\t\t\t   true, NULL_TREE, true,\n-\t\t\t\t\t   GSI_SAME_STMT);\n+\tmulop1 = gimple_build (&seq, NEGATE_EXPR, type, mulop1);\n \n-      fma_stmt = gimple_build_assign (gimple_assign_lhs (use_stmt),\n-\t\t\t\t      FMA_EXPR, mulop1, op2, addop);\n+      if (seq)\n+\tgsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+      fma_stmt = gimple_build_call_internal (IFN_FMA, 3, mulop1, op2, addop);\n+      gimple_call_set_lhs (fma_stmt, gimple_assign_lhs (use_stmt));\n+      gimple_call_set_nothrow (fma_stmt, !stmt_can_throw_internal (use_stmt));\n+      gsi_replace (&gsi, fma_stmt, true);\n+      /* Follow all SSA edges so that we generate FMS, FNMA and FNMS\n+\t regardless of where the negation occurs.  */\n+      if (fold_stmt (&gsi, follow_all_ssa_edges))\n+\tupdate_stmt (gsi_stmt (gsi));\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Generated FMA \");\n-\t  print_gimple_stmt (dump_file, fma_stmt, 0, 0);\n+\t  print_gimple_stmt (dump_file, gsi_stmt (gsi), 0, 0);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      gsi_replace (&gsi, fma_stmt, true);\n       widen_mul_stats.fmas_inserted++;\n     }\n }\n@@ -2862,7 +2862,8 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n \n   /* If the target doesn't support it, don't generate it.  We assume that\n      if fma isn't available then fms, fnma or fnms are not either.  */\n-  if (optab_handler (fma_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+  optimization_type opt_type = bb_optimization_type (gimple_bb (mul_stmt));\n+  if (!direct_internal_fn_supported_p (IFN_FMA, type, opt_type))\n     return false;\n \n   /* If the multiplication has zero uses, it is kept around probably because\n@@ -2958,8 +2959,8 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n \t that a mult / subtract pair.  */\n       if (use_code == MINUS_EXPR && !negate_p\n \t  && gimple_assign_rhs1 (use_stmt) == result\n-\t  && optab_handler (fms_optab, TYPE_MODE (type)) == CODE_FOR_nothing\n-\t  && optab_handler (fnma_optab, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\t  && !direct_internal_fn_supported_p (IFN_FMS, type, opt_type)\n+\t  && direct_internal_fn_supported_p (IFN_FNMA, type, opt_type))\n \t{\n \t  tree rhs2 = gimple_assign_rhs2 (use_stmt);\n "}, {"sha": "eefe270c32d3f8521e6056d9ad63aaee8bff9a60", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -849,7 +849,6 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     case REALIGN_LOAD_EXPR:\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n-    case FMA_EXPR:\n       {\n \tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n \tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), flags);"}, {"sha": "ff982fe43f865bc2e83c28c0be511df494cb5b6b", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -7171,7 +7171,6 @@ commutative_ternary_tree_code (enum tree_code code)\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n     case DOT_PROD_EXPR:\n-    case FMA_EXPR:\n       return true;\n \n     default:\n@@ -7457,7 +7456,6 @@ add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)\n \t      flags &= ~OEP_ADDRESS_OF;\n \t      break;\n \n-\t    case FMA_EXPR:\n \t    case WIDEN_MULT_PLUS_EXPR:\n \t    case WIDEN_MULT_MINUS_EXPR:\n \t      {"}, {"sha": "c660b2c3f650fcccd36593e4403a3160a2b427a1", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c566cc9f7847785bc709daaa3301649f2f03aef9/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=c566cc9f7847785bc709daaa3301649f2f03aef9", "patch": "@@ -1345,12 +1345,6 @@ DEFTREECODE (WIDEN_MULT_MINUS_EXPR, \"widen_mult_minus_expr\", tcc_expression, 3)\n    by the second argument.  */\n DEFTREECODE (WIDEN_LSHIFT_EXPR, \"widen_lshift_expr\", tcc_binary, 2)\n \n-/* Fused multiply-add.\n-   All operands and the result are of the same type.  No intermediate\n-   rounding is performed after multiplying operand one with operand two\n-   before adding operand three.  */\n-DEFTREECODE (FMA_EXPR, \"fma_expr\", tcc_expression, 3)\n-\n /* Widening vector multiplication.\n    The two operands are vectors with N elements of size S. Multiplying the\n    elements of the two vectors will result in N products of size 2*S."}]}