{"sha": "a2bec818635587d03fa02bd57c2bf0985510de56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiZWM4MTg2MzU1ODdkMDNmYTAyYmQ1N2MyYmYwOTg1NTEwZGU1Ng==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@debian.org", "date": "2004-07-19T14:48:09Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2004-07-19T14:48:09Z"}, "message": "Makefile.in (c-format.o): Depend on c-format.h.\n\ngcc/\n\t* Makefile.in (c-format.o): Depend on c-format.h.\n\t* c-format.h: New file.\n\t(struct format_char_info): Add CHAIN member.\n\t* c-format.c: Move some types and constants to c-format.h.\n\t(format_type_error): Set to -1.\n\t(struct function_format_info): Use an int for format_type.\n\t(decode_format_type): Return an int.  Return format_type_error\n\ton error.\n\t(print_char_table, asm_fprintf_char_table, gcc_diag_char_table)\n\t(gcc_diag_char_table, gcc_cdiag_char_table, gcc_cxxdiag_char_table)\n\t(scan_char_table, time_char_table, monetary_char_table): Initialize\n\tCHAIN to NULL.\n\t(n_format_types): New variable.\n\t(check_format_info_main): Handle CHAIN in format_char_info.\n\t(handle_format_attribute): Handle TARGET_FORMAT_TYPES and\n\tTARGET_N_FORMAT_TYPES.\n\t* config.gcc (i[34567]86-*-solaris2*, sparc64-*-solaris2*)\n\t(sparc-*-solaris2*): Include config/t-sol2 and config/sol2-c.c.\n\t* config/sol2-c.c: New file.\n\t* config/t-sol2: New file.\n\t* config/sol2.h (TARGET_N_FORMAT_TYPES, TARGET_FORMAT_TYPES): Define.\n\t* config/sparc/elf.h, config/sparc/sp64-elf.h: Undefine\n\tTARGET_N_FORMAT_TYPES and TARGET_FORMAT_TYPES.\n\n\t* doc/extend.texi (Target Format Checks): New section.\n\t(Function Attributes): Mention it.\n\t* doc/invoke.texi: Mention target format checks.\n\t* doc/sourcebuild.texi: Mention target format checks.\n\t* dc/tm.texi (Misc): Document TARGET_N_FORMAT_TYPES and\n\tTARGET_FORMAT_TYPES.\ntestsuite/\n\t* gcc.dg/format/cmn-err-1.c: New test.\n\nFrom-SVN: r84920", "tree": {"sha": "906e9f5e207c1fa3893321a14e270e2788011949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/906e9f5e207c1fa3893321a14e270e2788011949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2bec818635587d03fa02bd57c2bf0985510de56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2bec818635587d03fa02bd57c2bf0985510de56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2bec818635587d03fa02bd57c2bf0985510de56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2bec818635587d03fa02bd57c2bf0985510de56/comments", "author": null, "committer": null, "parents": [{"sha": "a38e09bc2137703767c8701ba05585b83c507919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38e09bc2137703767c8701ba05585b83c507919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38e09bc2137703767c8701ba05585b83c507919"}], "stats": {"total": 1113, "additions": 701, "deletions": 412}, "files": [{"sha": "ad0b3b7b525c517bcedfb3ba4959108e6dd6def5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -1,3 +1,36 @@\n+2004-07-19  Daniel Jacobowitz  <dan@debian.org>\n+\n+\t* Makefile.in (c-format.o): Depend on c-format.h.\n+\t* c-format.h: New file.\n+\t(struct format_char_info): Add CHAIN member.\n+\t* c-format.c: Move some types and constants to c-format.h.\n+\t(format_type_error): Set to -1.\n+\t(struct function_format_info): Use an int for format_type.\n+\t(decode_format_type): Return an int.  Return format_type_error\n+\ton error.\n+\t(print_char_table, asm_fprintf_char_table, gcc_diag_char_table)\n+\t(gcc_diag_char_table, gcc_cdiag_char_table, gcc_cxxdiag_char_table)\n+\t(scan_char_table, time_char_table, monetary_char_table): Initialize\n+\tCHAIN to NULL.\n+\t(n_format_types): New variable.\n+\t(check_format_info_main): Handle CHAIN in format_char_info.\n+\t(handle_format_attribute): Handle TARGET_FORMAT_TYPES and\n+\tTARGET_N_FORMAT_TYPES.\n+\t* config.gcc (i[34567]86-*-solaris2*, sparc64-*-solaris2*)\n+\t(sparc-*-solaris2*): Include config/t-sol2 and config/sol2-c.c.\n+\t* config/sol2-c.c: New file.\n+\t* config/t-sol2: New file.\n+\t* config/sol2.h (TARGET_N_FORMAT_TYPES, TARGET_FORMAT_TYPES): Define.\n+\t* config/sparc/elf.h, config/sparc/sp64-elf.h: Undefine\n+\tTARGET_N_FORMAT_TYPES and TARGET_FORMAT_TYPES.\n+\n+\t* doc/extend.texi (Target Format Checks): New section.\n+\t(Function Attributes): Mention it.\n+\t* doc/invoke.texi: Mention target format checks.\n+\t* doc/sourcebuild.texi: Mention target format checks.\n+\t* dc/tm.texi (Misc): Document TARGET_N_FORMAT_TYPES and\n+\tTARGET_FORMAT_TYPES.\n+\n 2004-07-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_return_address_offset): Prototype"}, {"sha": "f8acb48f5b209a1c0f97015bd736cdc56dc0fb8f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -1440,7 +1440,7 @@ attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FL\n \tbuiltin-types.def $(TARGET_H) langhooks.h\n \n c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) langhooks.h \\\n-\t$(C_COMMON_H) $(FLAGS_H) toplev.h intl.h $(DIAGNOSTIC_H)\n+\t$(C_COMMON_H) $(FLAGS_H) toplev.h intl.h $(DIAGNOSTIC_H) c-format.h\n \n c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(C_TREE_H) $(FLAGS_H) toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\"}, {"sha": "4aff5f2660b658496a894c7db23592de453f736c", "filename": "gcc/c-format.c", "status": "modified", "additions": 192, "deletions": 407, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n+#include \"c-format.h\"\n \f\n /* Set format warning options according to a -Wformat=n option.  */\n \n@@ -53,23 +54,24 @@ set_Wformat (int setting)\n \f\n /* Handle attributes associated with format checking.  */\n \n-/* This must be in the same order as format_types, with format_type_error\n-   last.  */\n+/* This must be in the same order as format_types, except for\n+   format_type_error.  Target-specific format types do not have\n+   matching enum values.  */\n enum format_type { printf_format_type, asm_fprintf_format_type,\n \t\t   gcc_diag_format_type, gcc_cdiag_format_type,\n \t\t   gcc_cxxdiag_format_type,\n \t\t   scanf_format_type, strftime_format_type,\n-\t\t   strfmon_format_type, format_type_error };\n+\t\t   strfmon_format_type, format_type_error = -1};\n \n typedef struct function_format_info\n {\n-  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n+  int format_type;\t\t\t/* type of format (printf, scanf, etc.) */\n   unsigned HOST_WIDE_INT format_num;\t/* number of format argument */\n   unsigned HOST_WIDE_INT first_arg_num;\t/* number of first arg (zero for varargs) */\n } function_format_info;\n \n static bool decode_format_attr (tree, function_format_info *, int);\n-static enum format_type decode_format_type (const char *);\n+static int decode_format_type (const char *);\n \n static bool check_format_string (tree argument,\n \t\t\t\t unsigned HOST_WIDE_INT format_num,\n@@ -230,33 +232,6 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \f\n /* Check a call to a format function against a parameter list.  */\n \n-/* The meaningfully distinct length modifiers for format checking recognized\n-   by GCC.  */\n-enum format_lengths\n-{\n-  FMT_LEN_none,\n-  FMT_LEN_hh,\n-  FMT_LEN_h,\n-  FMT_LEN_l,\n-  FMT_LEN_ll,\n-  FMT_LEN_L,\n-  FMT_LEN_z,\n-  FMT_LEN_t,\n-  FMT_LEN_j,\n-  FMT_LEN_MAX\n-};\n-\n-\n-/* The standard versions in which various format features appeared.  */\n-enum format_std_version\n-{\n-  STD_C89,\n-  STD_C94,\n-  STD_C9L, /* C99, but treat as C89 if -Wno-long-long.  */\n-  STD_C99,\n-  STD_EXT\n-};\n-\n /* The C standard version C++ is treated as equivalent to\n    or inheriting from, for the purpose of format features supported.  */\n #define CPLUSPLUS_STD_VER\tSTD_C94\n@@ -280,195 +255,6 @@ enum format_std_version\n \t\t\t\t       ? (warn_long_long ? STD_C99 : STD_C89) \\\n \t\t\t\t       : (VER)))\n \n-/* Flags that may apply to a particular kind of format checked by GCC.  */\n-enum\n-{\n-  /* This format converts arguments of types determined by the\n-     format string.  */\n-  FMT_FLAG_ARG_CONVERT = 1,\n-  /* The scanf allocation 'a' kludge applies to this format kind.  */\n-  FMT_FLAG_SCANF_A_KLUDGE = 2,\n-  /* A % during parsing a specifier is allowed to be a modified % rather\n-     that indicating the format is broken and we are out-of-sync.  */\n-  FMT_FLAG_FANCY_PERCENT_OK = 4,\n-  /* With $ operand numbers, it is OK to reference the same argument more\n-     than once.  */\n-  FMT_FLAG_DOLLAR_MULTIPLE = 8,\n-  /* This format type uses $ operand numbers (strfmon doesn't).  */\n-  FMT_FLAG_USE_DOLLAR = 16,\n-  /* Zero width is bad in this type of format (scanf).  */\n-  FMT_FLAG_ZERO_WIDTH_BAD = 32,\n-  /* Empty precision specification is OK in this type of format (printf).  */\n-  FMT_FLAG_EMPTY_PREC_OK = 64,\n-  /* Gaps are allowed in the arguments with $ operand numbers if all\n-     arguments are pointers (scanf).  */\n-  FMT_FLAG_DOLLAR_GAP_POINTER_OK = 128\n-  /* Not included here: details of whether width or precision may occur\n-     (controlled by width_char and precision_char); details of whether\n-     '*' can be used for these (width_type and precision_type); details\n-     of whether length modifiers can occur (length_char_specs).  */\n-};\n-\n-\n-/* Structure describing a length modifier supported in format checking, and\n-   possibly a doubled version such as \"hh\".  */\n-typedef struct\n-{\n-  /* Name of the single-character length modifier.  */\n-  const char *name;\n-  /* Index into a format_char_info.types array.  */\n-  enum format_lengths index;\n-  /* Standard version this length appears in.  */\n-  enum format_std_version std;\n-  /* Same, if the modifier can be repeated, or NULL if it can't.  */\n-  const char *double_name;\n-  enum format_lengths double_index;\n-  enum format_std_version double_std;\n-} format_length_info;\n-\n-\n-/* Structure describing the combination of a conversion specifier\n-   (or a set of specifiers which act identically) and a length modifier.  */\n-typedef struct\n-{\n-  /* The standard version this combination of length and type appeared in.\n-     This is only relevant if greater than those for length and type\n-     individually; otherwise it is ignored.  */\n-  enum format_std_version std;\n-  /* The name to use for the type, if different from that generated internally\n-     (e.g., \"signed size_t\").  */\n-  const char *name;\n-  /* The type itself.  */\n-  tree *type;\n-} format_type_detail;\n-\n-\n-/* Macros to fill out tables of these.  */\n-#define NOARGUMENTS\t{ T89_V, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n-#define BADLEN\t{ 0, NULL, NULL }\n-#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n-\n-\n-/* Structure describing a format conversion specifier (or a set of specifiers\n-   which act identically), and the length modifiers used with it.  */\n-typedef struct\n-{\n-  const char *format_chars;\n-  int pointer_count;\n-  enum format_std_version std;\n-  /* Types accepted for each length modifier.  */\n-  format_type_detail types[FMT_LEN_MAX];\n-  /* List of other modifier characters allowed with these specifiers.\n-     This lists flags, and additionally \"w\" for width, \"p\" for precision\n-     (right precision, for strfmon), \"#\" for left precision (strfmon),\n-     \"a\" for scanf \"a\" allocation extension (not applicable in C99 mode),\n-     \"*\" for scanf suppression, and \"E\" and \"O\" for those strftime\n-     modifiers.  */\n-  const char *flag_chars;\n-  /* List of additional flags describing these conversion specifiers.\n-     \"c\" for generic character pointers being allowed, \"2\" for strftime\n-     two digit year formats, \"3\" for strftime formats giving two digit\n-     years in some locales, \"4\" for \"2\" which becomes \"3\" with an \"E\" modifier,\n-     \"o\" if use of strftime \"O\" is a GNU extension beyond C99,\n-     \"W\" if the argument is a pointer which is dereferenced and written into,\n-     \"R\" if the argument is a pointer which is dereferenced and read from,\n-     \"i\" for printf integer formats where the '0' flag is ignored with\n-     precision, and \"[\" for the starting character of a scanf scanset.  */\n-  const char *flags2;\n-} format_char_info;\n-\n-\n-/* Structure describing a flag accepted by some kind of format.  */\n-typedef struct\n-{\n-  /* The flag character in question (0 for end of array).  */\n-  int flag_char;\n-  /* Zero if this entry describes the flag character in general, or a\n-     nonzero character that may be found in flags2 if it describes the\n-     flag when used with certain formats only.  If the latter, only\n-     the first such entry found that applies to the current conversion\n-     specifier is used; the values of `name' and `long_name' it supplies\n-     will be used, if non-NULL and the standard version is higher than\n-     the unpredicated one, for any pedantic warning.  For example, 'o'\n-     for strftime formats (meaning 'O' is an extension over C99).  */\n-  int predicate;\n-  /* Nonzero if the next character after this flag in the format should\n-     be skipped ('=' in strfmon), zero otherwise.  */\n-  int skip_next_char;\n-  /* The name to use for this flag in diagnostic messages.  For example,\n-     N_(\"`0' flag\"), N_(\"field width\").  */\n-  const char *name;\n-  /* Long name for this flag in diagnostic messages; currently only used for\n-     \"ISO C does not support ...\".  For example, N_(\"the `I' printf flag\").  */\n-  const char *long_name;\n-  /* The standard version in which it appeared.  */\n-  enum format_std_version std;\n-} format_flag_spec;\n-\n-\n-/* Structure describing a combination of flags that is bad for some kind\n-   of format.  */\n-typedef struct\n-{\n-  /* The first flag character in question (0 for end of array).  */\n-  int flag_char1;\n-  /* The second flag character.  */\n-  int flag_char2;\n-  /* Nonzero if the message should say that the first flag is ignored with\n-     the second, zero if the combination should simply be objected to.  */\n-  int ignored;\n-  /* Zero if this entry applies whenever this flag combination occurs,\n-     a nonzero character from flags2 if it only applies in some\n-     circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n-  int predicate;\n-} format_flag_pair;\n-\n-\n-/* Structure describing a particular kind of format processed by GCC.  */\n-typedef struct\n-{\n-  /* The name of this kind of format, for use in diagnostics.  Also\n-     the name of the attribute (without preceding and following __).  */\n-  const char *name;\n-  /* Specifications of the length modifiers accepted; possibly NULL.  */\n-  const format_length_info *length_char_specs;\n-  /* Details of the conversion specification characters accepted.  */\n-  const format_char_info *conversion_specs;\n-  /* String listing the flag characters that are accepted.  */\n-  const char *flag_chars;\n-  /* String listing modifier characters (strftime) accepted.  May be NULL.  */\n-  const char *modifier_chars;\n-  /* Details of the flag characters, including pseudo-flags.  */\n-  const format_flag_spec *flag_specs;\n-  /* Details of bad combinations of flags.  */\n-  const format_flag_pair *bad_flag_pairs;\n-  /* Flags applicable to this kind of format.  */\n-  int flags;\n-  /* Flag character to treat a width as, or 0 if width not used.  */\n-  int width_char;\n-  /* Flag character to treat a left precision (strfmon) as,\n-     or 0 if left precision not used.  */\n-  int left_precision_char;\n-  /* Flag character to treat a precision (for strfmon, right precision) as,\n-     or 0 if precision not used.  */\n-  int precision_char;\n-  /* If a flag character has the effect of suppressing the conversion of\n-     an argument ('*' in scanf), that flag character, otherwise 0.  */\n-  int suppression_char;\n-  /* Flag character to treat a length modifier as (ignored if length\n-     modifiers not used).  Need not be placed in flag_chars for conversion\n-     specifiers, but is used to check for bad combinations such as length\n-     modifier with assignment suppression in scanf.  */\n-  int length_code_char;\n-  /* Pointer to type of argument expected if '*' is used for a width,\n-     or NULL if '*' not used for widths.  */\n-  tree *width_type;\n-  /* Pointer to type of argument expected if '*' is used for a precision,\n-     or NULL if '*' not used for precisions.  */\n-  tree *precision_type;\n-} format_kind_info;\n-\n-\n /* Structure describing details of a type expected in format checking,\n    and the type to check against it.  */\n typedef struct format_wanted_type\n@@ -698,229 +484,174 @@ static const format_flag_pair strfmon_flag_pairs[] =\n };\n \n \n-#define T_I\t&integer_type_node\n-#define T89_I\t{ STD_C89, NULL, T_I }\n-#define T_L\t&long_integer_type_node\n-#define T89_L\t{ STD_C89, NULL, T_L }\n-#define T_LL\t&long_long_integer_type_node\n-#define T9L_LL\t{ STD_C9L, NULL, T_LL }\n-#define TEX_LL\t{ STD_EXT, NULL, T_LL }\n-#define T_S\t&short_integer_type_node\n-#define T89_S\t{ STD_C89, NULL, T_S }\n-#define T_UI\t&unsigned_type_node\n-#define T89_UI\t{ STD_C89, NULL, T_UI }\n-#define T_UL\t&long_unsigned_type_node\n-#define T89_UL\t{ STD_C89, NULL, T_UL }\n-#define T_ULL\t&long_long_unsigned_type_node\n-#define T9L_ULL\t{ STD_C9L, NULL, T_ULL }\n-#define TEX_ULL\t{ STD_EXT, NULL, T_ULL }\n-#define T_US\t&short_unsigned_type_node\n-#define T89_US\t{ STD_C89, NULL, T_US }\n-#define T_F\t&float_type_node\n-#define T89_F\t{ STD_C89, NULL, T_F }\n-#define T99_F\t{ STD_C99, NULL, T_F }\n-#define T_D\t&double_type_node\n-#define T89_D\t{ STD_C89, NULL, T_D }\n-#define T99_D\t{ STD_C99, NULL, T_D }\n-#define T_LD\t&long_double_type_node\n-#define T89_LD\t{ STD_C89, NULL, T_LD }\n-#define T99_LD\t{ STD_C99, NULL, T_LD }\n-#define T_C\t&char_type_node\n-#define T89_C\t{ STD_C89, NULL, T_C }\n-#define T_SC\t&signed_char_type_node\n-#define T99_SC\t{ STD_C99, NULL, T_SC }\n-#define T_UC\t&unsigned_char_type_node\n-#define T99_UC\t{ STD_C99, NULL, T_UC }\n-#define T_V\t&void_type_node\n-#define T89_V\t{ STD_C89, NULL, T_V }\n-#define T_W\t&wchar_type_node\n-#define T94_W\t{ STD_C94, \"wchar_t\", T_W }\n-#define TEX_W\t{ STD_EXT, \"wchar_t\", T_W }\n-#define T_WI\t&wint_type_node\n-#define T94_WI\t{ STD_C94, \"wint_t\", T_WI }\n-#define TEX_WI\t{ STD_EXT, \"wint_t\", T_WI }\n-#define T_ST    &size_type_node\n-#define T99_ST\t{ STD_C99, \"size_t\", T_ST }\n-#define T_SST   &signed_size_type_node\n-#define T99_SST\t{ STD_C99, \"signed size_t\", T_SST }\n-#define T_PD    &ptrdiff_type_node\n-#define T99_PD\t{ STD_C99, \"ptrdiff_t\", T_PD }\n-#define T_UPD   &unsigned_ptrdiff_type_node\n-#define T99_UPD\t{ STD_C99, \"unsigned ptrdiff_t\", T_UPD }\n-#define T_IM    &intmax_type_node\n-#define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n-#define T_UIM   &uintmax_type_node\n-#define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n-\n static const format_char_info print_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\",  \"i\"  },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\",     \"i\"  },\n-  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\",    \"i\"  },\n-  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\"   },\n-  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#I\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"c\"  },\n-  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",          \"W\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\",  \"i\",  NULL },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\",     \"i\",  NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\",    \"i\",  NULL },\n+  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#I\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"c\",  NULL },\n+  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",          \"W\",  NULL },\n   /* C99 conversion specifiers.  */\n-  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\"   },\n-  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",   \"\"   },\n+  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'I\", \"\",   NULL },\n+  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",   \"\",   NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\"   },\n-  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"R\"  },\n+  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",        \"\",   NULL },\n+  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"R\",  NULL },\n   /* GNU conversion specifiers.  */\n-  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",       \"\",   NULL },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info asm_fprintf_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +\",  \"i\" },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0#\",   \"i\" },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0\",    \"i\" },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\" },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",    \"cR\" },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +\",  \"i\", NULL },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0#\",   \"i\", NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0\",    \"i\", NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\", NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",    \"cR\", NULL },\n \n   /* asm_fprintf conversion specifiers.  */\n-  { \"O\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"I\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"L\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"U\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"r\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\" },\n-  { \"@\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+  { \"O\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"I\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"L\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"U\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"r\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\", NULL },\n+  { \"@\",   0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info gcc_diag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\"   },\n+  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\",   NULL },\n \n-  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info gcc_cdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\"   },\n+  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\",   NULL },\n \n-  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info gcc_cxxdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\"   },\n+  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n \n   /* These accept either an `int' or an `enum tree_code' (which is handled as an `int'.)  */\n-  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\",   NULL },\n \n-  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+  { \"<>'\", 0, STD_C89, NOARGUMENTS, \"\",      \"\",   NULL },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\",   NULL },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w'I\", \"W\"   },\n-  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w'I\", \"W\"   },\n-  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\",   \"W\"   },\n-  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n-  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"cW\"  },\n-  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW\"  },\n-  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW[\" },\n-  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n-  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",     \"W\"   },\n+  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w'I\", \"W\",   NULL },\n+  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w'I\", \"W\",   NULL },\n+  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\",   \"W\",   NULL },\n+  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\",   NULL },\n+  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"cW\",  NULL },\n+  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW\",  NULL },\n+  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW[\", NULL },\n+  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\",   NULL },\n+  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",     \"W\",   NULL },\n   /* C99 conversion specifiers.  */\n-  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n+  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\",   NULL },\n   /* X/Open conversion specifiers.  */\n-  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n-  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"W\"   },\n-  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n+  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\",   NULL },\n+  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"W\",   NULL },\n+  { NULL, 0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info time_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"ABZab\",\t\t0, STD_C89, NOLENGTHS, \"^#\",     \"\"   },\n-  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\"  },\n-  { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n-  { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\"   },\n-  { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\"   },\n-  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\"  },\n-  { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\"  },\n-  { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\"   },\n+  { \"ABZab\",\t\t0, STD_C89, NOLENGTHS, \"^#\",     \"\",   NULL },\n+  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\",  NULL },\n+  { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"\",   NULL },\n+  { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\",  NULL },\n+  { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\",   NULL },\n+  { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\",   NULL },\n+  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\",  NULL },\n+  { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\",  NULL },\n+  { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\",   NULL },\n   /* C99 conversion specifiers.  */\n-  { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOw\", \"o\"  },\n-  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"\",       \"2\"  },\n-  { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"\"   },\n-  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\" },\n-  { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n-  { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^#\",     \"\"   },\n-  { \"z\",\t\t0, STD_C99, NOLENGTHS, \"O\",      \"o\"  },\n+  { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOw\", \"o\",  NULL },\n+  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"\",       \"2\",  NULL },\n+  { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"\",   NULL },\n+  { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"\",   NULL },\n+  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\", NULL },\n+  { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"o\",  NULL },\n+  { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^#\",     \"\",   NULL },\n+  { \"z\",\t\t0, STD_C99, NOLENGTHS, \"O\",      \"o\",  NULL },\n   /* GNU conversion specifiers.  */\n-  { \"kls\",\t\t0, STD_EXT, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"P\",\t\t0, STD_EXT, NOLENGTHS, \"\",       \"\"   },\n-  { NULL,\t\t0, 0, NOLENGTHS, NULL, NULL }\n+  { \"kls\",\t\t0, STD_EXT, NOLENGTHS, \"-_0Ow\",  \"\",   NULL },\n+  { \"P\",\t\t0, STD_EXT, NOLENGTHS, \"\",       \"\",   NULL },\n+  { NULL,\t\t0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n static const format_char_info monetary_char_table[] =\n {\n-  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\" },\n-  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n+  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\", NULL },\n+  { NULL, 0, 0, NOLENGTHS, NULL, NULL, NULL }\n };\n \n-\n /* This must be in the same order as enum format_type.  */\n static const format_kind_info format_types_orig[] =\n {\n@@ -976,9 +707,12 @@ static const format_kind_info format_types_orig[] =\n    new data if necessary, while still allowing the original data to be\n    const.  */\n static const format_kind_info *format_types = format_types_orig;\n-/* We can modify this one.  */\n+/* We can modify this one.  We also add target-specific format types\n+   to the end of the array.  */\n static format_kind_info *dynamic_format_types;\n \n+static int n_format_types = ARRAY_SIZE (format_types_orig);\n+\n /* Structure detailing the results of checking a format function call\n    where the format expression may be a conditional expression with\n    many leaves resulting from nested conditional expressions.  */\n@@ -1036,24 +770,24 @@ static void format_type_warning (const char *, const char *, int, tree,\n /* Decode a format type from a string, returning the type, or\n    format_type_error if not valid, in which case the caller should print an\n    error message.  */\n-static enum format_type\n+static int\n decode_format_type (const char *s)\n {\n   int i;\n   int slen;\n   slen = strlen (s);\n-  for (i = 0; i < (int) format_type_error; i++)\n+  for (i = 0; i < n_format_types; i++)\n     {\n       int alen;\n       if (!strcmp (s, format_types[i].name))\n-\tbreak;\n+\treturn i;\n       alen = strlen (format_types[i].name);\n       if (slen == alen + 4 && s[0] == '_' && s[1] == '_'\n \t  && s[slen - 1] == '_' && s[slen - 2] == '_'\n \t  && !strncmp (s + 2, format_types[i].name, alen))\n-\tbreak;\n+\treturn i;\n     }\n-  return ((enum format_type) i);\n+  return format_type_error;\n }\n \n \f\n@@ -2188,6 +1922,8 @@ check_format_info_main (format_check_results *res,\n \t    }\n \t}\n \n+      main_wanted_type.next = NULL;\n+\n       /* Finally. . .check type of argument against desired type!  */\n       if (info->first_arg_num == 0)\n \tcontinue;\n@@ -2204,6 +1940,8 @@ check_format_info_main (format_check_results *res,\n \t}\n       else\n \t{\n+\t  format_wanted_type *wanted_type_ptr;\n+\n \t  if (main_arg_num != 0)\n \t    {\n \t      arg_num = main_arg_num;\n@@ -2219,46 +1957,72 @@ check_format_info_main (format_check_results *res,\n \t\t}\n \t      else\n \t\thas_operand_number = 0;\n+\t    }\n+\n+\t  wanted_type_ptr = &main_wanted_type;\n+\t  while (fci)\n+\t    {\n \t      if (params == 0)\n \t\t{\n \t\t  warning (\"too few arguments for format\");\n \t\t  return;\n \t\t}\n+\n+\t      cur_param = TREE_VALUE (params);\n+\t      params = TREE_CHAIN (params);\n+\n+\t      wanted_type_ptr->wanted_type = wanted_type;\n+\t      wanted_type_ptr->wanted_type_name = wanted_type_name;\n+\t      wanted_type_ptr->pointer_count = fci->pointer_count + aflag;\n+\t      wanted_type_ptr->char_lenient_flag = 0;\n+\t      if (strchr (fci->flags2, 'c') != 0)\n+\t\twanted_type_ptr->char_lenient_flag = 1;\n+\t      wanted_type_ptr->writing_in_flag = 0;\n+\t      wanted_type_ptr->reading_from_flag = 0;\n+\t      if (aflag)\n+\t\twanted_type_ptr->writing_in_flag = 1;\n+\t      else\n+\t\t{\n+\t\t  if (strchr (fci->flags2, 'W') != 0)\n+\t\t    wanted_type_ptr->writing_in_flag = 1;\n+\t\t  if (strchr (fci->flags2, 'R') != 0)\n+\t\t    wanted_type_ptr->reading_from_flag = 1;\n+\t\t}\n+\t      wanted_type_ptr->name = NULL;\n+\t      wanted_type_ptr->param = cur_param;\n+\t      wanted_type_ptr->arg_num = arg_num;\n+\t      wanted_type_ptr->next = NULL;\n+\t      if (last_wanted_type != 0)\n+\t\tlast_wanted_type->next = wanted_type_ptr;\n+\t      if (first_wanted_type == 0)\n+\t\tfirst_wanted_type = wanted_type_ptr;\n+\t      last_wanted_type = wanted_type_ptr;\n+\n+\t      fci = fci->chain;\n+\t      if (fci)\n+\t\t{\n+\t\t  wanted_type_ptr = ggc_alloc (sizeof (main_wanted_type));\n+\t\t  arg_num++;\n+\t\t  wanted_type = *fci->types[length_chars_val].type;\n+\t\t  wanted_type_name = fci->types[length_chars_val].name;\n+\t\t}\n \t    }\n-\t  cur_param = TREE_VALUE (params);\n-\t  params = TREE_CHAIN (params);\n-\t  main_wanted_type.wanted_type = wanted_type;\n-\t  main_wanted_type.wanted_type_name = wanted_type_name;\n-\t  main_wanted_type.pointer_count = fci->pointer_count + aflag;\n-\t  main_wanted_type.char_lenient_flag = 0;\n-\t  if (strchr (fci->flags2, 'c') != 0)\n-\t    main_wanted_type.char_lenient_flag = 1;\n-\t  main_wanted_type.writing_in_flag = 0;\n-\t  main_wanted_type.reading_from_flag = 0;\n-\t  if (aflag)\n-\t    main_wanted_type.writing_in_flag = 1;\n-\t  else\n-\t    {\n-\t      if (strchr (fci->flags2, 'W') != 0)\n-\t\tmain_wanted_type.writing_in_flag = 1;\n-\t      if (strchr (fci->flags2, 'R') != 0)\n-\t\tmain_wanted_type.reading_from_flag = 1;\n-\t    }\n-\t  main_wanted_type.name = NULL;\n-\t  main_wanted_type.param = cur_param;\n-\t  main_wanted_type.arg_num = arg_num;\n-\t  main_wanted_type.next = NULL;\n-\t  if (last_wanted_type != 0)\n-\t    last_wanted_type->next = &main_wanted_type;\n-\t  if (first_wanted_type == 0)\n-\t    first_wanted_type = &main_wanted_type;\n-\t  last_wanted_type = &main_wanted_type;\n \t}\n \n       if (first_wanted_type != 0)\n \tcheck_format_types (first_wanted_type, format_start,\n \t\t\t    format_chars - format_start);\n \n+      if (main_wanted_type.next != NULL)\n+\t{\n+\t  format_wanted_type *wanted_type_ptr = main_wanted_type.next;\n+\t  while (wanted_type_ptr)\n+\t    {\n+\t      format_wanted_type *next = wanted_type_ptr->next;\n+\t      ggc_free (wanted_type_ptr);\n+\t      wanted_type_ptr = next;\n+\t    }\n+\t}\n     }\n }\n \n@@ -2686,6 +2450,10 @@ init_dynamic_diag_info (void)\n     }\n }\n \n+#ifdef TARGET_FORMAT_TYPES\n+extern const format_kind_info TARGET_FORMAT_TYPES[];\n+#endif\n+\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n@@ -2696,6 +2464,23 @@ handle_format_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n   function_format_info info;\n   tree argument;\n \n+#ifdef TARGET_FORMAT_TYPES\n+  /* If the target provides additional format types, we need to\n+     add them to FORMAT_TYPES at first use.  */\n+  if (TARGET_FORMAT_TYPES != NULL && !dynamic_format_types)\n+    {\n+      dynamic_format_types = xmalloc ((n_format_types + TARGET_N_FORMAT_TYPES)\n+\t\t\t\t      * sizeof (dynamic_format_types[0]));\n+      memcpy (dynamic_format_types, format_types_orig,\n+\t      sizeof (format_types_orig));\n+      memcpy (&dynamic_format_types[n_format_types], TARGET_FORMAT_TYPES,\n+\t      TARGET_N_FORMAT_TYPES * sizeof (dynamic_format_types[0]));\n+\n+      format_types = dynamic_format_types;\n+      n_format_types += TARGET_N_FORMAT_TYPES;\n+    }\n+#endif\n+\n   if (!decode_format_attr (args, &info, 0))\n     {\n       *no_add_attrs = true;"}, {"sha": "a1861b544771c8934c9a933bd5ee5c0a5ed73f8c", "filename": "gcc/c-format.h", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.h?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -0,0 +1,299 @@\n+/* Check calls to formatted I/O functions (-Wformat).\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_C_FORMAT_H\n+#define GCC_C_FORMAT_H\n+\n+/* The meaningfully distinct length modifiers for format checking recognized\n+   by GCC.  */\n+enum format_lengths\n+{\n+  FMT_LEN_none,\n+  FMT_LEN_hh,\n+  FMT_LEN_h,\n+  FMT_LEN_l,\n+  FMT_LEN_ll,\n+  FMT_LEN_L,\n+  FMT_LEN_z,\n+  FMT_LEN_t,\n+  FMT_LEN_j,\n+  FMT_LEN_MAX\n+};\n+\n+\n+/* The standard versions in which various format features appeared.  */\n+enum format_std_version\n+{\n+  STD_C89,\n+  STD_C94,\n+  STD_C9L, /* C99, but treat as C89 if -Wno-long-long.  */\n+  STD_C99,\n+  STD_EXT\n+};\n+\n+/* Flags that may apply to a particular kind of format checked by GCC.  */\n+enum\n+{\n+  /* This format converts arguments of types determined by the\n+     format string.  */\n+  FMT_FLAG_ARG_CONVERT = 1,\n+  /* The scanf allocation 'a' kludge applies to this format kind.  */\n+  FMT_FLAG_SCANF_A_KLUDGE = 2,\n+  /* A % during parsing a specifier is allowed to be a modified % rather\n+     that indicating the format is broken and we are out-of-sync.  */\n+  FMT_FLAG_FANCY_PERCENT_OK = 4,\n+  /* With $ operand numbers, it is OK to reference the same argument more\n+     than once.  */\n+  FMT_FLAG_DOLLAR_MULTIPLE = 8,\n+  /* This format type uses $ operand numbers (strfmon doesn't).  */\n+  FMT_FLAG_USE_DOLLAR = 16,\n+  /* Zero width is bad in this type of format (scanf).  */\n+  FMT_FLAG_ZERO_WIDTH_BAD = 32,\n+  /* Empty precision specification is OK in this type of format (printf).  */\n+  FMT_FLAG_EMPTY_PREC_OK = 64,\n+  /* Gaps are allowed in the arguments with $ operand numbers if all\n+     arguments are pointers (scanf).  */\n+  FMT_FLAG_DOLLAR_GAP_POINTER_OK = 128\n+  /* Not included here: details of whether width or precision may occur\n+     (controlled by width_char and precision_char); details of whether\n+     '*' can be used for these (width_type and precision_type); details\n+     of whether length modifiers can occur (length_char_specs).  */\n+};\n+\n+\n+/* Structure describing a length modifier supported in format checking, and\n+   possibly a doubled version such as \"hh\".  */\n+typedef struct\n+{\n+  /* Name of the single-character length modifier.  */\n+  const char *name;\n+  /* Index into a format_char_info.types array.  */\n+  enum format_lengths index;\n+  /* Standard version this length appears in.  */\n+  enum format_std_version std;\n+  /* Same, if the modifier can be repeated, or NULL if it can't.  */\n+  const char *double_name;\n+  enum format_lengths double_index;\n+  enum format_std_version double_std;\n+} format_length_info;\n+\n+\n+/* Structure describing the combination of a conversion specifier\n+   (or a set of specifiers which act identically) and a length modifier.  */\n+typedef struct\n+{\n+  /* The standard version this combination of length and type appeared in.\n+     This is only relevant if greater than those for length and type\n+     individually; otherwise it is ignored.  */\n+  enum format_std_version std;\n+  /* The name to use for the type, if different from that generated internally\n+     (e.g., \"signed size_t\").  */\n+  const char *name;\n+  /* The type itself.  */\n+  tree *type;\n+} format_type_detail;\n+\n+\n+/* Macros to fill out tables of these.  */\n+#define NOARGUMENTS\t{ T89_V, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+#define BADLEN\t{ 0, NULL, NULL }\n+#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+\n+\n+/* Structure describing a format conversion specifier (or a set of specifiers\n+   which act identically), and the length modifiers used with it.  */\n+typedef struct format_char_info\n+{\n+  const char *format_chars;\n+  int pointer_count;\n+  enum format_std_version std;\n+  /* Types accepted for each length modifier.  */\n+  format_type_detail types[FMT_LEN_MAX];\n+  /* List of other modifier characters allowed with these specifiers.\n+     This lists flags, and additionally \"w\" for width, \"p\" for precision\n+     (right precision, for strfmon), \"#\" for left precision (strfmon),\n+     \"a\" for scanf \"a\" allocation extension (not applicable in C99 mode),\n+     \"*\" for scanf suppression, and \"E\" and \"O\" for those strftime\n+     modifiers.  */\n+  const char *flag_chars;\n+  /* List of additional flags describing these conversion specifiers.\n+     \"c\" for generic character pointers being allowed, \"2\" for strftime\n+     two digit year formats, \"3\" for strftime formats giving two digit\n+     years in some locales, \"4\" for \"2\" which becomes \"3\" with an \"E\" modifier,\n+     \"o\" if use of strftime \"O\" is a GNU extension beyond C99,\n+     \"W\" if the argument is a pointer which is dereferenced and written into,\n+     \"R\" if the argument is a pointer which is dereferenced and read from,\n+     \"i\" for printf integer formats where the '0' flag is ignored with\n+     precision, and \"[\" for the starting character of a scanf scanset.  */\n+  const char *flags2;\n+  /* If this format conversion character consumes more than one argument,\n+     CHAIN points to information about the next argument.  For later\n+     arguments, only POINTER_COUNT, TYPES, and the \"c\", \"R\", and \"W\" flags\n+     in FLAGS2 are used.  */\n+  const struct format_char_info *chain;\n+} format_char_info;\n+\n+\n+/* Structure describing a flag accepted by some kind of format.  */\n+typedef struct\n+{\n+  /* The flag character in question (0 for end of array).  */\n+  int flag_char;\n+  /* Zero if this entry describes the flag character in general, or a\n+     nonzero character that may be found in flags2 if it describes the\n+     flag when used with certain formats only.  If the latter, only\n+     the first such entry found that applies to the current conversion\n+     specifier is used; the values of `name' and `long_name' it supplies\n+     will be used, if non-NULL and the standard version is higher than\n+     the unpredicated one, for any pedantic warning.  For example, 'o'\n+     for strftime formats (meaning 'O' is an extension over C99).  */\n+  int predicate;\n+  /* Nonzero if the next character after this flag in the format should\n+     be skipped ('=' in strfmon), zero otherwise.  */\n+  int skip_next_char;\n+  /* The name to use for this flag in diagnostic messages.  For example,\n+     N_(\"`0' flag\"), N_(\"field width\").  */\n+  const char *name;\n+  /* Long name for this flag in diagnostic messages; currently only used for\n+     \"ISO C does not support ...\".  For example, N_(\"the `I' printf flag\").  */\n+  const char *long_name;\n+  /* The standard version in which it appeared.  */\n+  enum format_std_version std;\n+} format_flag_spec;\n+\n+\n+/* Structure describing a combination of flags that is bad for some kind\n+   of format.  */\n+typedef struct\n+{\n+  /* The first flag character in question (0 for end of array).  */\n+  int flag_char1;\n+  /* The second flag character.  */\n+  int flag_char2;\n+  /* Nonzero if the message should say that the first flag is ignored with\n+     the second, zero if the combination should simply be objected to.  */\n+  int ignored;\n+  /* Zero if this entry applies whenever this flag combination occurs,\n+     a nonzero character from flags2 if it only applies in some\n+     circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n+  int predicate;\n+} format_flag_pair;\n+\n+\n+/* Structure describing a particular kind of format processed by GCC.  */\n+typedef struct\n+{\n+  /* The name of this kind of format, for use in diagnostics.  Also\n+     the name of the attribute (without preceding and following __).  */\n+  const char *name;\n+  /* Specifications of the length modifiers accepted; possibly NULL.  */\n+  const format_length_info *length_char_specs;\n+  /* Details of the conversion specification characters accepted.  */\n+  const format_char_info *conversion_specs;\n+  /* String listing the flag characters that are accepted.  */\n+  const char *flag_chars;\n+  /* String listing modifier characters (strftime) accepted.  May be NULL.  */\n+  const char *modifier_chars;\n+  /* Details of the flag characters, including pseudo-flags.  */\n+  const format_flag_spec *flag_specs;\n+  /* Details of bad combinations of flags.  */\n+  const format_flag_pair *bad_flag_pairs;\n+  /* Flags applicable to this kind of format.  */\n+  int flags;\n+  /* Flag character to treat a width as, or 0 if width not used.  */\n+  int width_char;\n+  /* Flag character to treat a left precision (strfmon) as,\n+     or 0 if left precision not used.  */\n+  int left_precision_char;\n+  /* Flag character to treat a precision (for strfmon, right precision) as,\n+     or 0 if precision not used.  */\n+  int precision_char;\n+  /* If a flag character has the effect of suppressing the conversion of\n+     an argument ('*' in scanf), that flag character, otherwise 0.  */\n+  int suppression_char;\n+  /* Flag character to treat a length modifier as (ignored if length\n+     modifiers not used).  Need not be placed in flag_chars for conversion\n+     specifiers, but is used to check for bad combinations such as length\n+     modifier with assignment suppression in scanf.  */\n+  int length_code_char;\n+  /* Pointer to type of argument expected if '*' is used for a width,\n+     or NULL if '*' not used for widths.  */\n+  tree *width_type;\n+  /* Pointer to type of argument expected if '*' is used for a precision,\n+     or NULL if '*' not used for precisions.  */\n+  tree *precision_type;\n+} format_kind_info;\n+\n+#define T_I\t&integer_type_node\n+#define T89_I\t{ STD_C89, NULL, T_I }\n+#define T_L\t&long_integer_type_node\n+#define T89_L\t{ STD_C89, NULL, T_L }\n+#define T_LL\t&long_long_integer_type_node\n+#define T9L_LL\t{ STD_C9L, NULL, T_LL }\n+#define TEX_LL\t{ STD_EXT, NULL, T_LL }\n+#define T_S\t&short_integer_type_node\n+#define T89_S\t{ STD_C89, NULL, T_S }\n+#define T_UI\t&unsigned_type_node\n+#define T89_UI\t{ STD_C89, NULL, T_UI }\n+#define T_UL\t&long_unsigned_type_node\n+#define T89_UL\t{ STD_C89, NULL, T_UL }\n+#define T_ULL\t&long_long_unsigned_type_node\n+#define T9L_ULL\t{ STD_C9L, NULL, T_ULL }\n+#define TEX_ULL\t{ STD_EXT, NULL, T_ULL }\n+#define T_US\t&short_unsigned_type_node\n+#define T89_US\t{ STD_C89, NULL, T_US }\n+#define T_F\t&float_type_node\n+#define T89_F\t{ STD_C89, NULL, T_F }\n+#define T99_F\t{ STD_C99, NULL, T_F }\n+#define T_D\t&double_type_node\n+#define T89_D\t{ STD_C89, NULL, T_D }\n+#define T99_D\t{ STD_C99, NULL, T_D }\n+#define T_LD\t&long_double_type_node\n+#define T89_LD\t{ STD_C89, NULL, T_LD }\n+#define T99_LD\t{ STD_C99, NULL, T_LD }\n+#define T_C\t&char_type_node\n+#define T89_C\t{ STD_C89, NULL, T_C }\n+#define T_SC\t&signed_char_type_node\n+#define T99_SC\t{ STD_C99, NULL, T_SC }\n+#define T_UC\t&unsigned_char_type_node\n+#define T99_UC\t{ STD_C99, NULL, T_UC }\n+#define T_V\t&void_type_node\n+#define T89_V\t{ STD_C89, NULL, T_V }\n+#define T_W\t&wchar_type_node\n+#define T94_W\t{ STD_C94, \"wchar_t\", T_W }\n+#define TEX_W\t{ STD_EXT, \"wchar_t\", T_W }\n+#define T_WI\t&wint_type_node\n+#define T94_WI\t{ STD_C94, \"wint_t\", T_WI }\n+#define TEX_WI\t{ STD_EXT, \"wint_t\", T_WI }\n+#define T_ST    &size_type_node\n+#define T99_ST\t{ STD_C99, \"size_t\", T_ST }\n+#define T_SST   &signed_size_type_node\n+#define T99_SST\t{ STD_C99, \"signed size_t\", T_SST }\n+#define T_PD    &ptrdiff_type_node\n+#define T99_PD\t{ STD_C99, \"ptrdiff_t\", T_PD }\n+#define T_UPD   &unsigned_ptrdiff_type_node\n+#define T99_UPD\t{ STD_C99, \"unsigned ptrdiff_t\", T_UPD }\n+#define T_IM    &intmax_type_node\n+#define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n+#define T_UIM   &uintmax_type_node\n+#define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n+\n+#endif /* GCC_C_FORMAT_H */"}, {"sha": "9ce6d4eda1c41e392a72f9ad7cc9d31a49d73492", "filename": "gcc/config.gcc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -972,7 +972,9 @@ i[34567]86-*-sco3.2v5*)\t# 80386 running SCO Open Server 5\n i[34567]86-*-solaris2*)\n \txm_defines=\"SMALL_ARG_MAX\"\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h i386/sol2.h\"\n-\ttmake_file=\"i386/t-sol2 t-svr4\"\n+\ttmake_file=\"t-sol2 i386/t-sol2 t-svr4\"\n+\tc_target_objs=\"sol2-c.o\"\n+\tcxx_target_objs=\"sol2-c.o\"\n \tif test x$gnu_ld = xyes; then\n \t\ttmake_file=\"$tmake_file t-slibgcc-elf-ver\"\n \telse\n@@ -1851,12 +1853,14 @@ sparc64-*-solaris2* | sparcv9-*-solaris2*)\n \tif test x$gas = xyes; then\n \t\ttm_file=\"${tm_file} sparc/sol2-gas-bi.h\"\n \tfi\n-\ttmake_file=\"sparc/t-sol2 sparc/t-sol2-64 sparc/t-crtfm\"\n+\ttmake_file=\"t-sol2 sparc/t-sol2 sparc/t-sol2-64 sparc/t-crtfm\"\n \tif test x$gnu_ld = xyes; then\n \t\ttmake_file=\"$tmake_file t-slibgcc-elf-ver\"\n \telse\n \t\ttmake_file=\"$tmake_file t-slibgcc-sld\"\n \tfi\n+\tc_target_objs=\"sol2-c.o\"\n+\tcxx_target_objs=\"sol2-c.o\"\n \textra_parts=\"crt1.o crti.o crtn.o gcrt1.o crtbegin.o crtend.o\"\n \tcase ${enable_threads}:${have_pthread_h}:${have_thread_h} in\n \t  no:*:*) ;;\n@@ -1870,7 +1874,7 @@ sparc-*-solaris2*)\n \tif test x$gnu_ld = xyes; then\n \t\ttm_file=\"${tm_file} sparc/sol2-gld.h\"\n \tfi\n-\ttmake_file=\"sparc/t-sol2 sparc/t-crtfm\"\n+\ttmake_file=\"t-sol2 sparc/t-sol2 sparc/t-crtfm\"\n \tif test x$gnu_ld = xyes; then\n \t\ttmake_file=\"$tmake_file t-slibgcc-elf-ver\"\n \telse\n@@ -1894,6 +1898,8 @@ sparc-*-solaris2*)\n \t\tneed_64bit_hwint=yes\n \t\t;;\n \tesac\n+\tc_target_objs=\"sol2-c.o\"\n+\tcxx_target_objs=\"sol2-c.o\"\n \textra_parts=\"crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o\"\n \tcase ${enable_threads}:${have_pthread_h}:${have_thread_h} in\n \t  no:*:*) ;;"}, {"sha": "70fdb377a48ec84f5a6133a43fbd85139eb9d905", "filename": "gcc/config/sol2-c.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsol2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsol2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2-c.c?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -0,0 +1,72 @@\n+/* Solaris support needed only by C/C++ frontends.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+#include \"c-format.h\"\n+#include \"intl.h\"\n+\n+/* cmn_err only accepts \"l\" and \"ll\".  */\n+static const format_length_info cmn_err_length_specs[] =\n+{\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C89 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+static const format_flag_spec cmn_err_flag_specs[] =\n+{\n+  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair cmn_err_flag_pairs[] =\n+{\n+  { 0, 0, 0, 0 }\n+};\n+\n+static const format_char_info bitfield_string_type =\n+  { \"b\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"cR\", NULL };\n+\n+static const format_char_info cmn_err_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"dD\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"w\",  \"\",   NULL },\n+  { \"oOxX\",0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"w\",  \"\",   NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"w\",  \"\",   NULL },\n+  { \"c\",   0, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"w\",  \"\",   NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"w\",  \"cR\", NULL },\n+  { \"b\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\",   &bitfield_string_type },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }\n+};\n+\n+const format_kind_info solaris_format_types[] = {\n+  { \"cmn_err\",  cmn_err_length_specs,  cmn_err_char_table, \"\", NULL,\n+    cmn_err_flag_specs, cmn_err_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_EMPTY_PREC_OK,\n+    'w', 0, 0, 0, 'L',\n+    &integer_type_node, &integer_type_node\n+  }\n+};"}, {"sha": "f595395befbd270f5eafa1dcca229593eee8bd92", "filename": "gcc/config/sol2.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.h?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -205,3 +205,6 @@ __enable_execute_stack (void *addr)\t\t\t\t\t\\\n       perror (\"mprotect of trampoline code\");\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n }\n+\n+#define TARGET_N_FORMAT_TYPES 1\n+#define TARGET_FORMAT_TYPES solaris_format_types"}, {"sha": "150f0979375d6a0ddaf9bccba2365d52170d501e", "filename": "gcc/config/sparc/elf.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsparc%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsparc%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Felf.h?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -48,3 +48,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef SUN_INTEGER_MULTIPLY_64\n #define SUN_INTEGER_MULTIPLY_64 0\n+\n+/* Don't include Solaris-specific format checks.  */\n+#undef TARGET_N_FORMAT_TYPES\n+#undef TARGET_FORMAT_TYPES"}, {"sha": "16fa8e06a4e3d7312052c19d1f4b45c4f770f283", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -122,3 +122,7 @@ crtbegin.o%s \\\n \n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* Don't include Solaris-specific format checks.  */\n+#undef TARGET_N_FORMAT_TYPES\n+#undef TARGET_FORMAT_TYPES"}, {"sha": "022e4704511da5c9fbb6e26249f434ef0d7ab401", "filename": "gcc/config/t-sol2", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Ft-sol2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fconfig%2Ft-sol2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-sol2?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -0,0 +1,5 @@\n+# Solaris-specific format checking\n+sol2-c.o: $(srcdir)/config/sol2-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+  tree.h c-format.h intl.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/config/sol2-c.c"}, {"sha": "3374bab49a58b84588c201459349bebbde17164b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -472,6 +472,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Offsetof::            Special syntax for implementing @code{offsetof}.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n+* Target Format Checks:: Format checks specific to particular targets.\n * Pragmas::             Pragmas accepted by GCC.\n * Unnamed Fields::      Unnamed struct/union fields within structs/unions.\n * Thread-Local::        Per-thread variables.\n@@ -2173,6 +2174,10 @@ standard modes, the X/Open function @code{strfmon} is also checked as\n are @code{printf_unlocked} and @code{fprintf_unlocked}.\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n \n+The target may provide additional types of format checks.\n+@xref{Target Format Checks,,Format Checks Specific to Particular\n+Target Machines}.\n+\n @item format_arg (@var{string-index})\n @cindex @code{format_arg} function attribute\n @opindex Wformat-nonliteral\n@@ -7209,6 +7214,25 @@ vector signed int vec_any_numeric (vector float);\n vector signed int vec_any_out (vector float, vector float);\n @end smallexample\n \n+@node Target Format Checks\n+@section Format Checks Specific to Particular Target Machines\n+\n+For some target machines, GCC supports additional options to the\n+format attribute\n+(@pxref{Function Attributes,,Declaring Attributes of Functions}).\n+\n+@menu\n+* Solaris Format Checks::\n+@end menu\n+\n+@node Solaris Format Checks\n+@subsection Solaris Format Checks\n+\n+Solaris targets support the @code{cmn_err} (or @code{__cmn_err__}) format\n+check.  @code{cmn_err} accepts a subset of the standard @code{printf}\n+conversions, and the two-argument @code{%b} conversion for displaying\n+bit-fields.  See the Solaris man page for @code{cmn_err} for more information.\n+\n @node Pragmas\n @section Pragmas Accepted by GCC\n @cindex pragmas"}, {"sha": "43f2df66ddbf229d9725d9147ca5cf5308a0b6c7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -2113,7 +2113,7 @@ specified, and that the conversions specified in the format string make\n sense.  This includes standard functions, and others specified by format\n attributes (@pxref{Function Attributes}), in the @code{printf},\n @code{scanf}, @code{strftime} and @code{strfmon} (an X/Open extension,\n-not in the C standard) families.\n+not in the C standard) families (or other target-specific families).\n \n The formats are checked against the format features supported by GNU\n libc version 2.2.  These include all ISO C90 and C99 features, as well"}, {"sha": "f985e503a6ed373c1a81767afeaff9c01b85b8a8", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -766,6 +766,9 @@ pragmas supported.\n Documentation in @file{gcc/doc/extend.texi} of any target-specific\n built-in functions supported.\n @item\n+Documentation in @file{gcc/doc/extend.texi} of any target-specific\n+format checking styles supported.\n+@item\n Documentation in @file{gcc/doc/md.texi} of any target-specific\n constraint letters (@pxref{Machine Constraints, , Constraints for\n Particular Machines})."}, {"sha": "a8c410f8ec8326ea5c85ba30a8bfe08e5555b04c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -9278,3 +9278,14 @@ for a virtual function @var{fndecl} when constructing thunks,\n functions, if a target supports aliases (ie. defines\n @code{ASM_OUTPUT_DEF}), @code{false} otherwise,\n @end deftypefn\n+\n+@defmac TARGET_FORMAT_TYPES\n+If defined, this macro is the name of a global variable containing\n+target-specific format checking information for the @option{-Wformat}\n+option.  The default is to have no target-specific format checks.\n+@end defmac\n+\n+@defmac TARGET_N_FORMAT_TYPES\n+If defined, this macro is the number of entries in\n+@code{TARGET_FORMAT_TYPES}.\n+@end defmac"}, {"sha": "1ca5cb5d13c6322936a59e5ddb45547182f6bb57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -1,3 +1,7 @@\n+2004-07-19  Daniel Jacobowitz  <dan@debian.org>\n+\n+\t* gcc.dg/format/cmn-err-1.c: New test.\n+\n 2004-07-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* g++.dg/warn/Wparentheses-1.C, g++.dg/warn/Wparentheses-2.C,"}, {"sha": "ac4b1f0f442c0927b9854e27a9132c21e2dfd524", "filename": "gcc/testsuite/gcc.dg/format/cmn-err-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fcmn-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bec818635587d03fa02bd57c2bf0985510de56/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fcmn-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fcmn-err-1.c?ref=a2bec818635587d03fa02bd57c2bf0985510de56", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target *-*-solaris2.* } } */\n+/* { dg-options \"-Wformat\" } */\n+\n+#include \"format.h\"\n+\n+void cmn_err_func (int level, char * format, ...)\n+  __attribute__((format (cmn_err, 2, 3)));\n+\n+void cmn_err_func (int level, char * format, ...)\n+{\n+}\n+\n+const char *string = \"foo\";\n+\n+int main()\n+{\n+  int i = 1;\n+  long l = 2;\n+  llong ll = 3;\n+\n+  cmn_err_func (0, \"%s\", string);\n+  cmn_err_func (0, \"%d %D %o %O %x %X %u\", i, i, i, i, i, i, i);\n+  cmn_err_func (0, \"%ld %lD %lo %lO %lx %lX %lu\", l, l, l, l, l, l, l);\n+  cmn_err_func (0, \"%lld %llD %llo %llO %llx %llX %llu\",\n+\t\tll, ll, ll, ll, ll, ll, ll);\n+  cmn_err_func (0, \"%b %s\", i, \"\\01Foo\", string);\n+\n+  cmn_err_func (0, \"%i\", i);\t\t/* { dg-error \"unknown|too many\" } */\n+  cmn_err_func (0, \"%d\", l);\t\t/* { dg-error \"expects type\" } */\n+  cmn_err_func (0, \"%b\");\t\t/* { dg-error \"too few\" } */\n+  cmn_err_func (0, \"%b\", i);\t\t/* { dg-error \"too few\" } */\n+  cmn_err_func (0, \"%b\", i, i);\t\t/* { dg-error \"expects type\" } */\n+  cmn_err_func (0, \"%b\", string, i);\t/* { dg-error \"expects type\" } */\n+\n+  return 0;\n+}"}]}