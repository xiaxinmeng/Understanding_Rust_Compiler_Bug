{"sha": "274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc0OTY5ZWE4ZTM1NzM4MGMzYjhkODUxNmU5NGJmNGUyNmZmOWNiZQ==", "commit": {"author": {"name": "Michael Matz", "email": "matzmich@cs.tu-berlin.de", "date": "2000-07-21T00:07:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-21T00:07:33Z"}, "message": "gcse.c (record_one_set): Prepend instead of append onto reg_set_table, making it O(n) instead O(n^2).\n\n        * gcse.c (record_one_set): Prepend instead of append onto\n        reg_set_table, making it O(n) instead O(n^2).\n        * lcm.c (compute_antinout_edge,compute_laterin,compute_available):\n        Use a queue instead of a stack as worklist.\n\nFrom-SVN: r35158", "tree": {"sha": "f90d57c3d5e2996dc54ebe2a6fdefbf8714163ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f90d57c3d5e2996dc54ebe2a6fdefbf8714163ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/comments", "author": null, "committer": null, "parents": [{"sha": "7be50fd30fa08028f2ea7ac281cd0a310151d3b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be50fd30fa08028f2ea7ac281cd0a310151d3b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7be50fd30fa08028f2ea7ac281cd0a310151d3b9"}], "stats": {"total": 110, "additions": 71, "deletions": 39}, "files": [{"sha": "a0da767e7e4d617ff5195cf3789078df545bc12b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "patch": "@@ -1,3 +1,10 @@\n+Thu Jul 20 18:02:35 2000  Michael Matz <matzmich@cs.tu-berlin.de>\n+\n+\t* gcse.c (record_one_set): Prepend instead of append onto\n+\treg_set_table, making it O(n) instead O(n^2).\n+\t* lcm.c (compute_antinout_edge,compute_laterin,compute_available):\n+\tUse a queue instead of a stack as worklist.\n+\n 2000-07-20  Kazu Hirata  <kazu@hxi.com>\n \n \t* h8300.c (two_insn_adds_subs_operand): Fix a typo."}, {"sha": "224dd6bcfa187fb245e980504a1971a2a28ee415", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "patch": "@@ -1140,21 +1140,8 @@ record_one_set (regno, insn)\n \t\t\t\t\t\t   sizeof (struct reg_set));\n   bytes_used += sizeof (struct reg_set);\n   new_reg_info->insn = insn;\n-  new_reg_info->next = NULL;\n-  if (reg_set_table[regno] == NULL)\n-    reg_set_table[regno] = new_reg_info;\n-  else\n-    {\n-      reg_info_ptr1 = reg_info_ptr2 = reg_set_table[regno];\n-      /* ??? One could keep a \"last\" pointer to speed this up.  */\n-      while (reg_info_ptr1 != NULL)\n-\t{\n-\t  reg_info_ptr2 = reg_info_ptr1;\n-\t  reg_info_ptr1 = reg_info_ptr1->next;\n-\t}\n-\n-      reg_info_ptr2->next = new_reg_info;\n-    }\n+  new_reg_info->next = reg_set_table[regno];\n+  reg_set_table[regno] = new_reg_info;\n }\n \n /* Called from compute_sets via note_stores to handle one SET or CLOBBER in"}, {"sha": "472c8fe9e464d31d1c9b695e952e459818061a26", "filename": "gcc/lcm.c", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274969ea8e357380c3b8d8516e94bf4e26ff9cbe/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=274969ea8e357380c3b8d8516e94bf4e26ff9cbe", "patch": "@@ -108,12 +108,13 @@ compute_antinout_edge (antloc, transp, antin, antout)\n {\n   int bb;\n   edge e;\n-  basic_block *worklist, *tos;\n+  basic_block *worklist, *qin, *qout, *qend;\n+  unsigned int qlen;\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist\n+  qin = qout = worklist\n     = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution, so make an optimistic initialization of\n@@ -122,23 +123,31 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of ANTIN above.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n     {\n-      *tos++ = BASIC_BLOCK (bb);\n+      *qin++ = BASIC_BLOCK (bb);\n       BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n+  \n+  qin = worklist;\n+  qend = &worklist[n_basic_blocks];\n+  qlen = n_basic_blocks;\n \n   /* Mark blocks which are predecessors of the exit block so that we\n      can easily identify them below.  */\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     e->src->aux = EXIT_BLOCK_PTR;\n \n   /* Iterate until the worklist is empty.  */\n-  while (tos != worklist)\n+  while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *--tos;\n+      basic_block b = *qout++;\n       bb = b->index;\n+      qlen--;\n+\n+      if (qout >= qend)\n+        qout = worklist;\n \n       if (b->aux == EXIT_BLOCK_PTR)\n \t/* Do not clear the aux field for blocks which are predecessors of\n@@ -160,12 +169,15 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \tfor (e = b->pred; e; e = e->pred_next)\n \t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n \t    {\n-\t      *tos++ = e->src;\n+\t      *qin++ = e->src;\n \t      e->src->aux = e;\n+\t      qlen++;\n+\t      if (qin >= qend)\n+\t        qin = worklist;\n \t    }\n     }\n \n-  free (tos);\n+  free (worklist);\n }\n \n /* Compute the earliest vector for edge based lcm.  */\n@@ -246,14 +258,15 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n {\n   int bb, num_edges, i;\n   edge e;\n-  basic_block *worklist, *tos;\n+  basic_block *worklist, *qin, *qout, *qend;\n+  unsigned int qlen;\n \n   num_edges = NUM_EDGES (edge_list);\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist\n+  qin = qout = worklist\n     = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   /* Initialize a mapping from each edge to its index.  */\n@@ -281,19 +294,28 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n-  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n       basic_block b = BASIC_BLOCK (bb);\n-      *tos++ = b;\n+      *qin++ = b;\n       b->aux = b;\n     }\n+  qin = worklist;\n+  /* Note that we do not use the last allocated element for our queue,\n+     as EXIT_BLOCK is never inserted into it. In fact the above allocation\n+     of n_basic_blocks + 1 elements is not encessary. */\n+  qend = &worklist[n_basic_blocks];\n+  qlen = n_basic_blocks;\n \n   /* Iterate until the worklist is empty.  */\n-  while (tos != worklist)\n+  while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *--tos;\n+      basic_block b = *qout++;\n       b->aux = NULL;\n+      qlen--;\n+      if (qout >= qend)\n+        qout = worklist;\n \n       /* Compute the intersection of LATERIN for each incoming edge to B.  */\n       bb = b->index;\n@@ -311,8 +333,11 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n \t       to add the target of the outgoing edge to the worklist.  */\n \t    && e->dest != EXIT_BLOCK_PTR && e->dest->aux == 0)\n \t  {\n-\t    *tos++ = e->dest;\n+\t    *qin++ = e->dest;\n \t    e->dest->aux = e;\n+\t    qlen++;\n+\t    if (qin >= qend)\n+\t      qin = worklist;\n \t  }\n     }\n \n@@ -325,7 +350,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n \t\t     laterin[n_basic_blocks],\n \t\t     later[(size_t) e->aux]);\n \n-  free (tos);\n+  free (worklist);\n }\n \n /* Compute the insertion and deletion points for edge based LCM.  */\n@@ -465,36 +490,45 @@ compute_available (avloc, kill, avout, avin)\n {\n   int bb;\n   edge e;\n-  basic_block *worklist, *tos;\n+  basic_block *worklist, *qin, *qout, *qend;\n+  unsigned int qlen;\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist\n+  qin = qout = worklist\n     = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, n_basic_blocks);\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  */\n-  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n-      *tos++ = BASIC_BLOCK (bb);\n+      *qin++ = BASIC_BLOCK (bb);\n       BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n+  \n+  qin = worklist;\n+  qend = &worklist[n_basic_blocks];\n+  qlen = n_basic_blocks;\n \n   /* Mark blocks which are successors of the entry block so that we\n      can easily identify them below.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     e->dest->aux = ENTRY_BLOCK_PTR;\n \n   /* Iterate until the worklist is empty.  */\n-  while (tos != worklist)\n+  while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *--tos;\n+      basic_block b = *qout++;\n       bb = b->index;\n+      qlen--;\n+\n+      if (qout >= qend)\n+        qout = worklist;\n \n       /* If one of the predecessor blocks is the ENTRY block, then the\n \t intersection of avouts is the null set.  We can identify such blocks\n@@ -518,12 +552,16 @@ compute_available (avloc, kill, avout, avin)\n \tfor (e = b->succ; e; e = e->succ_next)\n \t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n \t    {\n-\t      *tos++ = e->dest;\n+\t      *qin++ = e->dest;\n \t      e->dest->aux = e;\n+\t      qlen++;\n+\n+\t      if (qin >= qend)\n+\t        qin = worklist;\n \t    }\n     }\n \n-  free (tos);\n+  free (worklist);\n }\n \n /* Compute the farthest vector for edge based lcm.  */"}]}