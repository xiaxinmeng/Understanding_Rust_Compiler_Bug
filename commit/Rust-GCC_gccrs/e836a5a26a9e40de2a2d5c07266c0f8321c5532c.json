{"sha": "e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgzNmE1YTI2YTllNDBkZTJhMmQ1YzA3MjY2YzBmODMyMWM1NTMyYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-19T14:43:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-19T14:43:56Z"}, "message": "expr.c (expand_assignment): Remove the last argument.\n\n\t* expr.c (expand_assignment): Remove the last argument.\n\tChange the return type to void.\n\t* expr.h: Update the prototype of expand_assignment.\n\t* function.c (assign_parm_setup_reg): Update a call to\n\texpand_assignment.\n\t* stmt.c (expand_asm_expr): Likewise.\n\nFrom-SVN: r89275", "tree": {"sha": "8970f72664157fabb5e8b9eb68f1275e2bd0dd35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8970f72664157fabb5e8b9eb68f1275e2bd0dd35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/comments", "author": null, "committer": null, "parents": [{"sha": "88e9994a469cdf817b269128cc5cb18046ed533d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9994a469cdf817b269128cc5cb18046ed533d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e9994a469cdf817b269128cc5cb18046ed533d"}], "stats": {"total": 62, "additions": 28, "deletions": 34}, "files": [{"sha": "13d0ae467c8abe515d475054fce4018dcbd2bcc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "patch": "@@ -1,3 +1,12 @@\n+2004-10-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expr.c (expand_assignment): Remove the last argument.\n+\tChange the return type to void.\n+\t* expr.h: Update the prototype of expand_assignment.\n+\t* function.c (assign_parm_setup_reg): Update a call to\n+\texpand_assignment.\n+\t* stmt.c (expand_asm_expr): Likewise.\n+\n 2004-10-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* expr.c (expand_expr_real_1) <MODIFY_EXPR>: Remove"}, {"sha": "1309868b1e3d4a7b9902d2e027a4704628694bbc", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "patch": "@@ -3405,13 +3405,10 @@ get_subtarget (rtx x)\n \t  ? 0 : x);\n }\n \n-/* Expand an assignment that stores the value of FROM into TO.\n-   If WANT_VALUE is nonzero, return an rtx for the value of TO.\n-   (If the value is constant, this rtx is a constant.)\n-   Otherwise, the returned value is NULL_RTX.  */\n+/* Expand an assignment that stores the value of FROM into TO.  */\n \n-rtx\n-expand_assignment (tree to, tree from, int want_value)\n+void\n+expand_assignment (tree to, tree from)\n {\n   rtx to_rtx = 0;\n   rtx result;\n@@ -3421,7 +3418,7 @@ expand_assignment (tree to, tree from, int want_value)\n   if (TREE_CODE (to) == ERROR_MARK)\n     {\n       result = expand_expr (from, NULL_RTX, VOIDmode, 0);\n-      return want_value ? result : NULL_RTX;\n+      return;\n     }\n \n   /* Assignment of a structure component needs special treatment\n@@ -3449,9 +3446,6 @@ expand_assignment (tree to, tree from, int want_value)\n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */\n \n-      if (mode1 == VOIDmode && want_value)\n-\ttem = stabilize_reference (tem);\n-\n       orig_to_rtx = to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n \n       if (offset != 0)\n@@ -3513,7 +3507,7 @@ expand_assignment (tree to, tree from, int want_value)\n \t}\n \n       /* Optimize bitfld op= val in certain cases.  */\n-      while (mode1 == VOIDmode && !want_value\n+      while (mode1 == VOIDmode\n \t     && bitsize > 0 && bitsize < BITS_PER_WORD\n \t     && GET_MODE_BITSIZE (GET_MODE (to_rtx)) <= BITS_PER_WORD\n \t     && !TREE_SIDE_EFFECTS (to)\n@@ -3616,7 +3610,7 @@ expand_assignment (tree to, tree from, int want_value)\n \t\temit_move_insn (str_rtx, result);\n \t      free_temp_slots ();\n \t      pop_temp_slots ();\n-\t      return NULL_RTX;\n+\t      return;\n \n \t    default:\n \t      break;\n@@ -3626,11 +3620,7 @@ expand_assignment (tree to, tree from, int want_value)\n \t}\n \n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n-\t\t\t    (want_value\n-\t\t\t     /* Spurious cast for HPUX compiler.  */\n-\t\t\t     ? ((enum machine_mode)\n-\t\t\t\tTYPE_MODE (TREE_TYPE (to)))\n-\t\t\t     : VOIDmode),\n+\t\t\t    VOIDmode,\n \t\t\t    unsignedp, TREE_TYPE (tem), get_alias_set (to));\n \n       preserve_temp_slots (result);\n@@ -3639,11 +3629,7 @@ expand_assignment (tree to, tree from, int want_value)\n \n       /* If the value is meaningful, convert RESULT to the proper mode.\n \t Otherwise, return nothing.  */\n-      return (want_value ? convert_modes (TYPE_MODE (TREE_TYPE (to)),\n-\t\t\t\t\t  TYPE_MODE (TREE_TYPE (from)),\n-\t\t\t\t\t  result,\n-\t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (to)))\n-\t      : NULL_RTX);\n+      return;\n     }\n \n   /* If the rhs is a function call and its value is not an aggregate,\n@@ -3684,7 +3670,7 @@ expand_assignment (tree to, tree from, int want_value)\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n       pop_temp_slots ();\n-      return want_value ? to_rtx : NULL_RTX;\n+      return;\n     }\n \n   /* Ordinary treatment.  Expand TO to get a REG or MEM rtx.\n@@ -3711,7 +3697,7 @@ expand_assignment (tree to, tree from, int want_value)\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n       pop_temp_slots ();\n-      return want_value ? to_rtx : NULL_RTX;\n+      return;\n     }\n \n   /* In case we are returning the contents of an object which overlaps\n@@ -3737,17 +3723,17 @@ expand_assignment (tree to, tree from, int want_value)\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n       pop_temp_slots ();\n-      return want_value ? to_rtx : NULL_RTX;\n+      return;\n     }\n \n   /* Compute FROM and store the value in the rtx we got.  */\n \n   push_temp_slots ();\n-  result = store_expr (from, to_rtx, want_value);\n+  result = store_expr (from, to_rtx, 0);\n   preserve_temp_slots (result);\n   free_temp_slots ();\n   pop_temp_slots ();\n-  return want_value ? result : NULL_RTX;\n+  return;\n }\n \n /* Generate code for computing expression EXP,\n@@ -4732,7 +4718,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t       the loop.  */\n \t\t    expand_assignment (index,\n \t\t\t\t       build2 (PLUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t\t       index, integer_one_node), 0);\n+\t\t\t\t\t       index, integer_one_node));\n \t\t    \n \t\t    emit_jump (loop_start);\n \t\t    \n@@ -8093,14 +8079,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    expand_assignment (lhs, convert (TREE_TYPE (rhs),\n \t\t\t\t\t     (TREE_CODE (rhs) == BIT_IOR_EXPR\n \t\t\t\t\t      ? integer_one_node\n-\t\t\t\t\t      : integer_zero_node)),\n-\t\t\t       0);\n+\t\t\t\t\t      : integer_zero_node)));\n \t    do_pending_stack_adjust ();\n \t    emit_label (label);\n \t    return const0_rtx;\n \t  }\n \n-\texpand_assignment (lhs, rhs, 0);\n+\texpand_assignment (lhs, rhs);\n \n \treturn const0_rtx;\n       }"}, {"sha": "54b04c2eb6085469ea0641a927fcd63ee6ac26c7", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "patch": "@@ -466,7 +466,7 @@ extern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,\n \t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n \n /* Expand an assignment that stores the value of FROM into TO.  */\n-extern rtx expand_assignment (tree, tree, int);\n+extern void expand_assignment (tree, tree);\n \n /* Generate code for computing expression EXP,\n    and storing the value into TARGET."}, {"sha": "d6fe2f5f4afdfc07e925fa77da60d7583f179a45", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "patch": "@@ -2730,7 +2730,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n       /* TREE_USED gets set erroneously during expand_assignment.  */\n       save_tree_used = TREE_USED (parm);\n-      expand_assignment (parm, make_tree (data->nominal_type, tempreg), 0);\n+      expand_assignment (parm, make_tree (data->nominal_type, tempreg));\n       TREE_USED (parm) = save_tree_used;\n       all->conversion_insns = get_insns ();\n       end_sequence ();"}, {"sha": "38646a354594d9bfd270c35401aa4a7bb9ae536b", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e836a5a26a9e40de2a2d5c07266c0f8321c5532c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "patch": "@@ -1108,7 +1108,7 @@ expand_asm_expr (tree exp)\n     {\n       if (o[i] != TREE_VALUE (tail))\n \t{\n-\t  expand_assignment (o[i], TREE_VALUE (tail), 0);\n+\t  expand_assignment (o[i], TREE_VALUE (tail));\n \t  free_temp_slots ();\n \n \t  /* Restore the original value so that it's correct the next"}]}