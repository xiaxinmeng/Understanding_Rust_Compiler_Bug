{"sha": "b0d065155dcf58badec4abea8652c1b06b66a2e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkMDY1MTU1ZGNmNThiYWRlYzRhYmVhODY1MmMxYjA2YjY2YTJlMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-16T22:08:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-16T22:08:42Z"}, "message": "cp-tree.h (CAN_HAVE_FULL_LANG_DECL_P): New macro.\n\n\t* cp-tree.h (CAN_HAVE_FULL_LANG_DECL_P): New macro.\n\t* class.c (build_vtable): Use build_lang_field_decl to build the\n\tVAR_DECLs for vtables.\n\t(prepare_fresh_vtable): Likewise.\n\t* decl.c (duplicate_decls): Only copy DECL_SAVED_TREE if\n\tCAN_HAVE_FULL_LANG_DECL_P.\n\t(push_using_decl): Use build_lang_decl to build USING_DECLs.\n\t(grokdeclarator): Use build_lang_decl to build TYPE_DECLs.\n\t* lex.c (retrofit_lang_decl): Check CAN_HAVE_FULL_LANG_DECL_P.\n\t(build_lang_field_decl): Likewise.\n\t(copy_lang_decl): Use CAN_HAVE_FULLLANG_DECL_P to decide how much\n\tto copy.\n\nFrom-SVN: r28731", "tree": {"sha": "fd0402d39944fba3227e3d96dfb3cd381a03ca61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd0402d39944fba3227e3d96dfb3cd381a03ca61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0d065155dcf58badec4abea8652c1b06b66a2e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d065155dcf58badec4abea8652c1b06b66a2e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d065155dcf58badec4abea8652c1b06b66a2e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d065155dcf58badec4abea8652c1b06b66a2e1/comments", "author": null, "committer": null, "parents": [{"sha": "58e787081dad89dd64099d2a039651a2bcd29df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e787081dad89dd64099d2a039651a2bcd29df6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e787081dad89dd64099d2a039651a2bcd29df6"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "cf9a35799da11604464106b4cdbcf2d1eeefafdc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0d065155dcf58badec4abea8652c1b06b66a2e1", "patch": "@@ -1,5 +1,18 @@\n 1999-08-16  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (CAN_HAVE_FULL_LANG_DECL_P): New macro.\n+\t* class.c (build_vtable): Use build_lang_field_decl to build the\n+\tVAR_DECLs for vtables.\n+\t(prepare_fresh_vtable): Likewise.\n+\t* decl.c (duplicate_decls): Only copy DECL_SAVED_TREE if\n+\tCAN_HAVE_FULL_LANG_DECL_P.\n+\t(push_using_decl): Use build_lang_decl to build USING_DECLs.\n+\t(grokdeclarator): Use build_lang_decl to build TYPE_DECLs.\n+\t* lex.c (retrofit_lang_decl): Check CAN_HAVE_FULL_LANG_DECL_P.\n+\t(build_lang_field_decl): Likewise.\n+\t(copy_lang_decl): Use CAN_HAVE_FULLLANG_DECL_P to decide how much\n+\tto copy.\n+\t\n \t* cp-tree.def (STMT_EXPR): New tree node.\n \t* cp-tree.h (STMT_EXPR_STMT): New macro.\n \t(store_return_init): Change prototype."}, {"sha": "45374e9ae2113a38a7be65cc88184c69df99c210", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b0d065155dcf58badec4abea8652c1b06b66a2e1", "patch": "@@ -737,7 +737,8 @@ build_vtable (binfo, type)\n       tree offset;\n \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n-      decl = build_lang_decl (VAR_DECL, name, TREE_TYPE (BINFO_VTABLE (binfo)));\n+      decl = build_lang_field_decl (VAR_DECL, name, \n+\t\t\t\t    TREE_TYPE (BINFO_VTABLE (binfo)));\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n@@ -747,7 +748,7 @@ build_vtable (binfo, type)\n   else\n     {\n       virtuals = NULL_TREE;\n-      decl = build_lang_decl (VAR_DECL, name, void_type_node);\n+      decl = build_lang_field_decl (VAR_DECL, name, void_type_node);\n     }\n \n #ifdef GATHER_STATISTICS\n@@ -897,7 +898,7 @@ prepare_fresh_vtable (binfo, for_type)\n       buf2 = new_buf2;\n     }\n \n-  new_decl = build_lang_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n+  new_decl = build_lang_field_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n   /* Remember which class this vtable is really for.  */\n   DECL_CONTEXT (new_decl) = for_type;\n "}, {"sha": "1de0e310c6206bf12436491ad58cc9afb95c1949", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b0d065155dcf58badec4abea8652c1b06b66a2e1", "patch": "@@ -1153,12 +1153,14 @@ struct lang_type\n \f\n \n /* If a DECL has DECL_LANG_SPECIFIC, it is either a lang_decl_flags or\n-   a lang_decl (which has lang_decl_flags as its initial prefix).  A\n-   FUNCTION_DECL, NAMESPACE_DECL, TYPE_DECL, or USING_DECL may have a\n-   full lang_decl.  A FIELD_DECL, or a static data member VAR_DECL,\n-   will have only lang_decl_flags.  Thus, one should only access the\n-   members of lang_decl that are not in lang_decl_flags for DECLs that\n-   are not FIELD_DECLs or VAR_DECLs.  */\n+   a lang_decl (which has lang_decl_flags as its initial prefix).\n+   This macro is nonzero for tree nodes whose DECL_LANG_SPECIFIC is\n+   the full lang_decl, and not just lang_decl_flags.  */\n+#define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\\\n+  (!(TREE_CODE ((NODE)) == VAR_DECL\t\t\\\n+     || TREE_CODE ((NODE)) == CONST_DECL\t\\\n+     || TREE_CODE ((NODE)) == FIELD_DECL \t\\\n+     || TREE_CODE ((NODE)) == USING_DECL))\n \n struct lang_decl_flags\n {"}, {"sha": "dee05d3cc1897407d8ae68cdc64436bd78dcb4a5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b0d065155dcf58badec4abea8652c1b06b66a2e1", "patch": "@@ -3523,7 +3523,8 @@ duplicate_decls (newdecl, olddecl)\n \t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);\n \t  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);\n-\t  if (DECL_LANG_SPECIFIC (newdecl)\n+\t  if (CAN_HAVE_FULL_LANG_DECL_P (newdecl)\n+\t      && DECL_LANG_SPECIFIC (newdecl)\n \t      && DECL_LANG_SPECIFIC (olddecl))\n \t    DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n \t}\n@@ -4474,7 +4475,7 @@ push_using_decl (scope, name)\n       break;\n   if (decl)\n     return NULL_TREE;\n-  decl = build_lang_decl (USING_DECL, name, void_type_node);\n+  decl = build_lang_field_decl (USING_DECL, name, void_type_node);\n   DECL_INITIAL (decl) = scope;\n   TREE_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n@@ -10553,7 +10554,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (type != error_mark_node)\n \t    push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n \t  if (processing_template_decl)\n-\t    decl = build_lang_field_decl (TYPE_DECL, declarator, type);\n+\t    decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t  else\n \t    decl = build_decl (TYPE_DECL, declarator, type);\n \t  if (type != error_mark_node)"}, {"sha": "f641dc60f905a4cbb04e3ca5fbf7d75926a36280", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d065155dcf58badec4abea8652c1b06b66a2e1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b0d065155dcf58badec4abea8652c1b06b66a2e1", "patch": "@@ -4742,6 +4742,8 @@ retrofit_lang_decl (t)\n   struct obstack *obstack = current_obstack;\n   struct lang_decl *ld;\n \n+  my_friendly_assert (CAN_HAVE_FULL_LANG_DECL_P (t), 19990816);\n+\n   if (! TREE_PERMANENT (t))\n     obstack = saveable_obstack;\n   else\n@@ -4795,6 +4797,8 @@ build_lang_field_decl (code, name, type)\n   else\n     my_friendly_assert (obstack == &permanent_obstack, 235);\n \n+  my_friendly_assert (!CAN_HAVE_FULL_LANG_DECL_P (t), 19990816);\n+\n   DECL_LANG_SPECIFIC (t) \n     = ((struct lang_decl *) \n        obstack_alloc (obstack, sizeof (struct lang_decl_flags)));\n@@ -4812,7 +4816,7 @@ copy_lang_decl (node)\n   if (! DECL_LANG_SPECIFIC (node))\n     return;\n \n-  if (TREE_CODE (node) == FIELD_DECL)\n+  if (!CAN_HAVE_FULL_LANG_DECL_P (node))\n     size = sizeof (struct lang_decl_flags);\n   else\n     size = sizeof (struct lang_decl);"}]}