{"sha": "7dfded9114ec3aad2f2eafe5ff606215c602620b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RmZGVkOTExNGVjM2FhZDJmMmVhZmU1ZmY2MDYyMTVjNjAyNjIwYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2005-02-22T00:10:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2005-02-22T00:10:22Z"}, "message": "memory: New file.\n\n\t* include/tr1/memory: New file.\n\t* include/Makefile.am, include/Makefile.in: Add new TR1 header.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tenable_shared_from_this/not_shared.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tenable_shared_from_this/not_shared2.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tenable_shared_from_this/not_shared3.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tenable_shared_from_this/shared.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tenable_shared_from_this/still_shared.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/assign.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/auto_ptr.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/auto_ptr_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/auto_ptr_rvalue_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/shared_ptr.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/assign/shared_ptr_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/comparison/cmp.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/auto_ptr.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/auto_ptr_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/copy.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/default.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/pointer.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/weak_ptr.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/cons/weak_ptr_expired.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/dest/dest.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/misc/io.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/misc/swap.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/modifiers/reset.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/modifiers/reset_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/modifiers/swap.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/modifiers/swap_neg.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/observers/bool_conv.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/observers/get.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/observers/unique.cc: New test.\n\t* testsuite/tr1/2_general_utilities/memory/\n\tshared_ptr/observers/use_count.cc: New test.\n\nFrom-SVN: r95361", "tree": {"sha": "6f90dfb69e7c10ef5b3f9e81389168eef9327e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f90dfb69e7c10ef5b3f9e81389168eef9327e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dfded9114ec3aad2f2eafe5ff606215c602620b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dfded9114ec3aad2f2eafe5ff606215c602620b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dfded9114ec3aad2f2eafe5ff606215c602620b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dfded9114ec3aad2f2eafe5ff606215c602620b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11996a3c452935418437898cc5131e41097736e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11996a3c452935418437898cc5131e41097736e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11996a3c452935418437898cc5131e41097736e4"}], "stats": {"total": 3063, "additions": 3061, "deletions": 2}, "files": [{"sha": "6f5294a31c42c85e904c7ef49721b1bc5ec4d6c1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -1,3 +1,68 @@\n+2005-02-21  Jonathan Wakely  <redi@gcc.gnu.org>\n+\n+\t* include/tr1/memory: New file.\n+\t* include/Makefile.am, include/Makefile.in: Add new TR1 header.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tenable_shared_from_this/not_shared.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tenable_shared_from_this/not_shared2.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tenable_shared_from_this/not_shared3.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tenable_shared_from_this/shared.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tenable_shared_from_this/still_shared.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/assign.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/auto_ptr.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/auto_ptr_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/auto_ptr_rvalue_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/shared_ptr.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/assign/shared_ptr_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/comparison/cmp.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/auto_ptr.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/auto_ptr_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/copy.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/default.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/pointer.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/weak_ptr.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/cons/weak_ptr_expired.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/dest/dest.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/misc/io.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/misc/swap.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/modifiers/reset.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/modifiers/reset_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/modifiers/swap.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/modifiers/swap_neg.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/observers/bool_conv.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/observers/get.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/observers/unique.cc: New test.\n+\t* testsuite/tr1/2_general_utilities/memory/\n+\tshared_ptr/observers/use_count.cc: New test.\n+\n 2005-02-21  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/type_traits (is_member_function_pointer):"}, {"sha": "20136b2c237fa575087749d8122b45b2e7949f88", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -229,6 +229,7 @@ tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n@@ -569,7 +570,7 @@ ${host_builddir}/gthr-default.h: ${toplevel_srcdir}/gcc/${glibcxx_thread_h} \\\n \n # Build a precompiled C++ include, stdc++.h.gch.\n ${pch_input}: ${allstamped} ${host_builddir}/c++config.h ${pch_source}\n-\ttouch ${pch_input}; \\\n+\tcp ${pch_source} ${pch_input}; \\\n \tif [ ! -d \"${pch_output_builddir}\" ]; then \\\n \t  mkdir -p ${pch_output_builddir}; \\\n \tfi; \\"}, {"sha": "7df1e28bd8519d0d7df5feca19420e493c8208fd", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -445,6 +445,7 @@ tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n@@ -944,7 +945,7 @@ ${host_builddir}/gthr-default.h: ${toplevel_srcdir}/gcc/${glibcxx_thread_h} \\\n \n # Build a precompiled C++ include, stdc++.h.gch.\n ${pch_input}: ${allstamped} ${host_builddir}/c++config.h ${pch_source}\n-\ttouch ${pch_input}; \\\n+\tcp ${pch_source} ${pch_input}; \\\n \tif [ ! -d \"${pch_output_builddir}\" ]; then \\\n \t  mkdir -p ${pch_output_builddir}; \\\n \tfi; \\"}, {"sha": "18ddc2b566ccd520be3d5c012f7f0f6778a97d01", "filename": "libstdc++-v3/include/tr1/memory", "status": "added", "additions": 996, "deletions": 0, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,996 @@\n+// <tr1/memory> -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  boost/checked_delete.hpp\n+//  Copyright (c) 2002, 2003 Peter Dimov\n+//  Copyright (c) 2003 Daniel Frey\n+//  Copyright (c) 2003 Howard Hinnant\n+\n+//  boost/shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (c) 2002 Peter Dimov\n+\n+#ifndef _TR1_MEMORY\n+#define _TR1_MEMORY 1\n+\n+#include \"../memory\"\n+#include <functional>       // std::less\n+#include <exception>        // std::exception\n+#include <new>              // std::bad_alloc\n+#include <typeinfo>         // std::type_info in get_deleter\n+#include <cstddef>          // std::size_t\n+#include <algorithm>        // for std::swap\n+#include <iosfwd>           // for std::basic_ostream\n+#include <cstdlib>          // for std::abort\n+\n+#include <bits/gthr.h>\n+#include <bits/atomicity.h>\n+#include <bits/functexcept.h>\n+#include <debug/debug.h>\n+\n+// namespace std::tr1\n+namespace std\n+{\n+namespace tr1\n+{\n+\n+class bad_weak_ptr : public std::exception\n+{\n+public:\n+\n+  virtual char const* what() const throw()\n+  {\n+    return \"tr1::bad_weak_ptr\";\n+  }\n+};\n+\n+// Helper for exception objects in <tr1/memory>\n+// TODO this should be defined in a different file.\n+void\n+__throw_bad_weak_ptr()\n+{\n+#if __EXCEPTIONS\n+  throw bad_weak_ptr();\n+#else\n+  std::abort();\n+#endif\n+}\n+\n+\n+// verify that types are complete for increased safety\n+\n+template <typename _Tp>\n+  inline void\n+  checked_delete(_Tp * __x)\n+  {\n+    // intentionally complex - simplification causes regressions\n+    typedef char type_must_be_complete[ sizeof(_Tp)? 1: -1 ];\n+    (void) sizeof(type_must_be_complete);\n+    delete __x;\n+  }\n+\n+template <typename _Tp>\n+  struct checked_deleter\n+  {\n+    typedef void result_type;\n+    typedef _Tp* argument_type;\n+\n+    void\n+    operator()(_Tp * x) const\n+    { std::tr1::checked_delete(x); }\n+  };\n+\n+\n+class _Sp_counted_base\n+{\n+public:\n+\n+  _Sp_counted_base()\n+  : _M_use_count(1), _M_weak_count(1)\n+  { }\n+\n+  virtual\n+  ~_Sp_counted_base() // nothrow\n+  { }\n+\n+  // dispose() is called when _M_use_count drops to zero, to release\n+  // the resources managed by *this.\n+  virtual void\n+  dispose() = 0; // nothrow\n+\n+  // destroy() is called when _M_weak_count drops to zero.\n+  virtual void\n+  destroy() // nothrow\n+  {\n+    delete this;\n+  }\n+\n+  virtual void*\n+  get_deleter(const std::type_info&) = 0;\n+\n+  void\n+  add_ref_copy()\n+  {\n+    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n+  }\n+\n+  void\n+  add_ref_lock()\n+  {\n+    if (_M_use_count <= 0) // TODO not yet MT safe XXX\n+    {\n+      __throw_bad_weak_ptr();\n+    }\n+    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n+  }\n+\n+  void\n+  release() // nothrow\n+  {\n+    if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) <= 1)\n+    {\n+      dispose();\n+      weak_release();\n+    }\n+  }\n+\n+  void\n+  weak_add_ref() // nothrow\n+  {\n+    __gnu_cxx::__atomic_add(&_M_weak_count, 1);\n+  }\n+\n+  void\n+  weak_release() // nothrow\n+  {\n+    if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) <= 1)\n+    {\n+      destroy();\n+    }\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  {\n+    return _M_use_count;  // XXX is this MT safe?\n+  }\n+\n+private:\n+\n+  _Sp_counted_base(_Sp_counted_base const&);\n+  _Sp_counted_base& operator= (_Sp_counted_base const&);\n+\n+  _Atomic_word _M_use_count;        // #shared\n+  _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n+};\n+\n+template <typename _Ptr, typename _Deleter>\n+class _Sp_counted_base_impl : public _Sp_counted_base\n+{\n+public:\n+\n+  /**\n+   *  @brief   \n+   *  @pre     d(p) must not throw.\n+   */\n+  _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+  : _M_ptr(__p), _M_del(__d)\n+  { }\n+\n+  virtual void\n+  dispose() // nothrow\n+  {\n+    _M_del(_M_ptr);\n+  }\n+\n+  virtual void*\n+  get_deleter(const std::type_info& __ti)\n+  {\n+    return __ti == typeid(_Deleter) ? &_M_del : 0;\n+  }\n+\n+private:\n+  _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+  _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+\n+  _Ptr     _M_ptr; // copy constructor must not throw\n+  _Deleter _M_del; // copy constructor must not throw\n+};\n+\n+class weak_count;\n+\n+class shared_count\n+{\n+private:\n+\n+  _Sp_counted_base* _M_pi;\n+\n+  friend class weak_count;\n+\n+public:\n+\n+  shared_count()\n+  : _M_pi(0) // nothrow\n+  { }\n+\n+  template <typename _Ptr, typename _Deleter>\n+    shared_count(_Ptr __p, _Deleter __d)\n+    : _M_pi(0)\n+    {\n+      try\n+      {\n+        _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n+      }\n+      catch(...)\n+      {\n+        __d(__p); // delete __p\n+        __throw_exception_again;\n+      }\n+    }\n+\n+  // auto_ptr<_Tp> is special cased to provide the strong guarantee\n+\n+  template <typename _Tp>\n+    explicit shared_count(std::auto_ptr<_Tp>& __r)\n+    : _M_pi(new _Sp_counted_base_impl<_Tp*,checked_deleter<_Tp> >(\n+            __r.get(), checked_deleter<_Tp>()\n+            ))\n+    { __r.release(); }\n+\n+  // throws bad_weak_ptr when __r.use_count() == 0\n+  explicit shared_count(const weak_count& __r);\n+\n+  ~shared_count() // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->release();\n+  }\n+\n+  shared_count(const shared_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->add_ref_copy();\n+  }\n+\n+  shared_count&\n+  operator=(const shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+\n+    if(__tmp != _M_pi)\n+    {\n+      if(__tmp != 0)\n+        __tmp->add_ref_copy();\n+      if(_M_pi != 0)\n+        _M_pi->release();\n+      _M_pi = __tmp;\n+    }\n+    return *this;\n+  }\n+\n+  void swap(shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+    __r._M_pi = _M_pi;\n+    _M_pi = __tmp;\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+\n+  bool\n+  unique() const // nothrow\n+  { return this->use_count() == 1; }\n+\n+  friend inline bool\n+  operator==(const shared_count& __a, const shared_count& __b)\n+  { return __a._M_pi == __b._M_pi; }\n+\n+  friend inline bool\n+  operator<(const shared_count& __a, const shared_count& __b)\n+  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n+\n+  void*\n+  get_deleter(const std::type_info& __ti) const\n+  { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n+};\n+\n+\n+class weak_count\n+{\n+private:\n+\n+  _Sp_counted_base * _M_pi;\n+\n+  friend class shared_count;\n+\n+public:\n+\n+  weak_count()\n+  : _M_pi(0) // nothrow\n+  { }\n+\n+  weak_count(const shared_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_add_ref();\n+  }\n+\n+  weak_count(const weak_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_add_ref();\n+  }\n+\n+  ~weak_count() // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+  }\n+\n+  weak_count&\n+  operator=(const shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+    if (__tmp != 0)\n+      __tmp->weak_add_ref();\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+    _M_pi = __tmp;\n+\n+    return *this;\n+  }\n+\n+  weak_count&\n+  operator=(const weak_count& __r) // nothrow\n+  {\n+    _Sp_counted_base * __tmp = __r._M_pi;\n+    if (__tmp != 0)\n+      __tmp->weak_add_ref();\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+    _M_pi = __tmp;\n+\n+    return *this;\n+  }\n+\n+  void\n+  swap(weak_count& __r) // nothrow\n+  {\n+    _Sp_counted_base * __tmp = __r._M_pi;\n+    __r._M_pi = _M_pi;\n+    _M_pi = __tmp;\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+\n+  friend inline bool\n+  operator==(const weak_count& __a, const weak_count& __b)\n+  { return __a._M_pi == __b._M_pi; }\n+\n+  friend inline bool\n+  operator<(const weak_count& __a, const weak_count& __b)\n+  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n+};\n+\n+inline\n+shared_count::shared_count(const weak_count& __r)\n+: _M_pi(__r._M_pi)\n+{\n+  if (_M_pi != 0)\n+  {\n+    _M_pi->add_ref_lock();\n+  }\n+  else\n+  {\n+    __throw_bad_weak_ptr();\n+  }\n+}\n+\n+// fwd decls\n+template <typename _Tp> class weak_ptr;\n+template <typename _Tp> class enable_shared_from_this;\n+\n+struct __static_cast_tag {};\n+struct __const_cast_tag {};\n+struct __dynamic_cast_tag {};\n+struct __polymorphic_cast_tag {};\n+\n+template<class _Tp> struct shared_ptr_traits\n+{\n+    typedef _Tp & reference;\n+};\n+\n+template<> struct shared_ptr_traits<void>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void const>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void volatile>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void const volatile>\n+{\n+    typedef void reference;\n+};\n+\n+\n+// enable_shared_from_this support\n+\n+// friend of enable_shared_from_this\n+template <typename _Tp1, typename _Tp2>\n+  void\n+  __enable_shared_from_this( const shared_count& __pn,\n+                             const enable_shared_from_this<_Tp1>* __pe,\n+                             const _Tp2* __px );\n+\n+inline void\n+__enable_shared_from_this(const shared_count&, ...)\n+{ }\n+\n+/**\n+ *  @class shared_ptr <tr1/memory>\n+ *\n+ *  A smart pointer with reference-counted copy semantics.\n+ *  The object pointed to is deleted when the last shared_ptr pointing to it\n+ *  is destroyed or reset.\n+ */\n+\n+template <typename _Tp>\n+  class shared_ptr\n+  {\n+    typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n+\n+  public:\n+\n+    typedef _Tp   element_type;\n+\n+    /** @brief  Construct an empty %shared_ptr.\n+     *  @post   use_count()==0 && get()==0\n+     */\n+    shared_ptr() : _M_ptr(0), _M_refcount() // never throws\n+    { }\n+\n+    /** @brief  Construct a %shared_ptr that owns the pointer @a p.\n+     *  @param  p  A pointer that is convertible to element_type*.\n+     *  @post   use_count()==1 && get()==p\n+     *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(_Tp1* __p)\n+      : _M_ptr(__p), _M_refcount(__p, checked_deleter<_Tp1>())\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n+\n+        __enable_shared_from_this( _M_refcount, __p, __p );\n+      }\n+\n+    //\n+    // Requirements: D's copy constructor and destructor must not throw\n+    //\n+    // shared_ptr will release p by calling d(p)\n+    //\n+    /** @brief  Construct a %shared_ptr that owns the pointer @a p\n+     *          and the deleter @a d.\n+     *  @param  p  A pointer.\n+     *  @param  d  A deleter.\n+     *  @post   use_count()==1 && get()==p\n+     *  @throw  std::bad_alloc, in which case @a d(p) is called.\n+     */\n+    template <typename _Tp1, typename _Deleter>\n+      shared_ptr(_Tp1* __p, _Deleter __d)\n+      : _M_ptr(__p), _M_refcount(__p, __d)\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // TODO requires D is CopyConstructible and d(p) well-formed\n+\n+        __enable_shared_from_this( _M_refcount, __p, __p );\n+      }\n+\n+    //  generated copy constructor, assignment, destructor are fine.\n+\n+    /** @brief  If @a r is empty, constructs an empty %shared_ptr; otherwise\n+     *          construct a %shared_ptr that shares ownership with @a r.\n+     *  @param  r  A %shared_ptr.\n+     *  @post   get()==r.get() && use_count()==r.use_count()\n+     *  @throw  std::bad_alloc, in which case \n+     */\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r)\n+      : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+      }\n+\n+    /** @brief  Constructs a %shared_ptr that shares ownership with @a r\n+     *          and stores a copy of the pointer stored in @a r.\n+     *  @param  r  A weak_ptr.\n+     *  @post   use_count()==r.use_count()\n+     *  @throw  bad_weak_ptr when r.expired(),\n+     *          in which case the constructor has no effect.\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+      : _M_refcount(__r._M_refcount) // may throw\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // it is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n+        // did not throw\n+        _M_ptr = __r._M_ptr;\n+      }\n+\n+    /**\n+     * @post use_count()==1 and r.get()==0\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n+      : _M_ptr(__r.get()), _M_refcount()\n+      {\n+        // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n+        // delete r.release() well-formed\n+        _Tp1 * __tmp = __r.get();\n+        _M_refcount = shared_count(__r);\n+\n+        __enable_shared_from_this( _M_refcount, __tmp, __tmp );\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n+      : _M_ptr(static_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      { }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n+      : _M_ptr(const_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      { }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      {\n+        if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n+        {\n+          _M_refcount = shared_count();\n+        }\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr&\n+      operator=(const shared_ptr<_Tp1>& __r) // never throws\n+      {\n+        _M_ptr = __r._M_ptr;\n+        _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n+        return *this;\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr&\n+      operator=(std::auto_ptr<_Tp1>& __r)\n+      {\n+        shared_ptr(__r).swap(*this);\n+        return *this;\n+      }\n+\n+    void\n+    reset() // never throws\n+    { shared_ptr().swap(*this); }\n+\n+    template <typename _Tp1>\n+      void\n+      reset(_Tp1* __p) // _Tp1 must be complete\n+      {\n+        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset errors\n+        shared_ptr(__p).swap(*this);\n+      }\n+\n+    template <typename _Tp1, typename _Deleter>\n+      void\n+      reset(_Tp1 * __p, _Deleter __d)\n+      { shared_ptr(__p, __d).swap(*this); }\n+\n+    // error to instantiate if _Tp is [cv-qual] void\n+    _Reference\n+    operator*() const // never throws\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+      return *_M_ptr;\n+    }\n+\n+    _Tp*\n+    operator->() const // never throws\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+      return _M_ptr;\n+    }\n+    \n+    _Tp*\n+    get() const // never throws\n+    { return _M_ptr; }\n+\n+    // implicit conversion to \"bool\"\n+  private:\n+    typedef _Tp* shared_ptr::*__unspecified_bool_type;\n+\n+  public:\n+    operator __unspecified_bool_type() const // never throws\n+    { return _M_ptr == 0 ? 0 : &shared_ptr::_M_ptr; }\n+\n+    bool\n+    unique() const // never throws\n+    { return _M_refcount.unique(); }\n+\n+    long\n+    use_count() const // never throws\n+    { return _M_refcount.use_count(); }\n+\n+    void\n+    swap(shared_ptr<_Tp>& __other) // never throws\n+    {\n+      std::swap(_M_ptr, __other._M_ptr);\n+      _M_refcount.swap(__other._M_refcount);\n+    }\n+\n+  private:\n+    template <typename _Tp1>\n+      bool\n+      _M_less(const shared_ptr<_Tp1>& __rhs) const\n+      { return _M_refcount < __rhs._M_refcount; }\n+\n+    void*\n+    _M_get_deleter(const std::type_info& __ti) const\n+    { return _M_refcount.get_deleter(__ti); }\n+\n+    template <typename _Tp1> friend class shared_ptr;\n+    template <typename _Tp1> friend class weak_ptr;\n+\n+    // friends injected into enclosing namespace and found by ADL:\n+\n+    // get_deleter (experimental)\n+    template <typename _Del>\n+      friend inline _Del*\n+      get_deleter(const shared_ptr& __p)\n+      { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator==(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a.get() == __b.get(); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator!=(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a.get() != __b.get(); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator<(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a._M_less(__b); }\n+\n+    _Tp*         _M_ptr;         // contained pointer\n+    shared_count _M_refcount;    // reference counter\n+  };  // shared_ptr\n+\n+// 2.2.3.9 shared_ptr casts\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  static_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __static_cast_tag());\n+  }\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  const_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __const_cast_tag());\n+  }\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n+  }\n+\n+// operator<<\n+template <typename _Ch, typename _Tr, typename _Tp>\n+  std::basic_ostream<_Ch,_Tr>&\n+  operator<<(std::basic_ostream<_Ch,_Tr>& __os, const shared_ptr<_Tp>& __p)\n+  {\n+    __os << __p.get();\n+    return __os;\n+  }\n+\n+\n+template <typename _Tp>\n+  class weak_ptr\n+  {\n+  public:\n+\n+    typedef _Tp element_type;\n+\n+    weak_ptr()\n+    : _M_ptr(0), _M_refcount() // never throws\n+    { }\n+\n+  //  generated copy constructor, assignment, destructor are fine\n+\n+  //\n+  //  The \"obvious\" converting constructor implementation:\n+  //\n+  //  template<class Y>\n+  //  weak_ptr(weak_ptr<Y> const & r): _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+  //  {\n+  //  }\n+  //\n+  //  has a serious problem.\n+  //\n+  //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n+  //  conversion may require access to *r._M_ptr (virtual inheritance).\n+  //\n+  //  It is not possible to avoid spurious access violations since\n+  //  in multithreaded programs r._M_ptr may be invalidated at any point.\n+  //\n+\n+    template <typename _Tp1>\n+      weak_ptr(const weak_ptr<_Tp1>& r)\n+      : _M_refcount(r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        _M_ptr = r.lock().get();\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr(const shared_ptr<_Tp1>& r)\n+      : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr&\n+      operator=(const weak_ptr<_Tp1>& r) // never throws\n+      {\n+        _M_ptr = r.lock().get();\n+        _M_refcount = r._M_refcount;\n+        return *this;\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr&\n+      operator=(const shared_ptr<_Tp1>& r) // never throws\n+      {\n+        _M_ptr = r._M_ptr;\n+        _M_refcount = r._M_refcount;\n+        return *this;\n+      }\n+\n+    shared_ptr<_Tp>\n+    lock() const // never throws\n+    {\n+#ifdef __GTHREADS\n+\n+      // optimization: avoid throw overhead\n+      if (expired())\n+      {\n+        return shared_ptr<element_type>();\n+      }\n+\n+      try\n+      {\n+        return shared_ptr<element_type>(*this);\n+      }\n+      catch (const bad_weak_ptr&)\n+      {\n+        // Q: how can we get here?\n+        // A: another thread may have invalidated r after the use_count test above.\n+        return shared_ptr<element_type>();\n+      }\n+\n+#else\n+\n+      // optimization: avoid try/catch overhead when single threaded\n+      return expired() ? shared_ptr<element_type>() : shared_ptr<element_type>(*this);\n+\n+#endif\n+    } // XXX MT\n+\n+\n+    long\n+    use_count() const // never throws\n+    { return _M_refcount.use_count(); }\n+\n+    bool\n+    expired() const // never throws\n+    { return _M_refcount.use_count() == 0; }\n+\n+    void\n+    reset() // never throws\n+    { weak_ptr().swap(*this); }\n+\n+    void\n+    swap(weak_ptr& __s) // never throws\n+    {\n+      std::swap(_M_ptr, __s._M_ptr);\n+      _M_refcount.swap(__s._M_refcount);\n+    }\n+\n+  private:\n+\n+    template <typename _Tp1>\n+      bool\n+      _M_less(const weak_ptr<_Tp1>& __rhs) const\n+      { return _M_refcount < __rhs._M_refcount; }\n+\n+    // used by __enable_shared_from_this\n+    void\n+    _M_assign(_Tp* __ptr, const shared_count& __refcount)\n+    {\n+      _M_ptr = __ptr;\n+      _M_refcount = __refcount;\n+    }\n+\n+    // friend injected into namespace and found by ADL\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator<(const weak_ptr& __lhs, const weak_ptr<_Tp1>& __rhs)\n+      { return __lhs._M_less(__rhs); }\n+\n+    template <typename _Tp1> friend class weak_ptr;\n+    template <typename _Tp1> friend class shared_ptr;\n+    friend class enable_shared_from_this<_Tp>;\n+\n+    _Tp*       _M_ptr;           // contained pointer\n+    weak_count _M_refcount;      // reference counter\n+\n+  };  // weak_ptr\n+\n+\n+\n+template <typename _Tp>\n+  class enable_shared_from_this\n+  {\n+  protected:\n+\n+    enable_shared_from_this()\n+    { }\n+\n+    enable_shared_from_this(const enable_shared_from_this&)\n+    { }\n+\n+    enable_shared_from_this&\n+    operator=(const enable_shared_from_this&)\n+    { return *this; }\n+\n+    ~enable_shared_from_this()\n+    { }\n+\n+  public:\n+\n+    shared_ptr<_Tp>\n+    shared_from_this()\n+    {\n+      shared_ptr<_Tp> p(this->_M_weak_this);\n+      return p;\n+    }\n+\n+    shared_ptr<const _Tp>\n+    shared_from_this() const\n+    {\n+      shared_ptr<const _Tp> p(this->_M_weak_this);\n+      return p;\n+    }\n+\n+  private:\n+    template <typename _Tp1>\n+      void\n+      _M_weak_assign(_Tp1* __p, const shared_count& __n) const\n+      { _M_weak_this._M_assign(__p, __n); }\n+\n+    template <typename _Tp1>\n+      friend void\n+      __enable_shared_from_this( const shared_count& __pn, const enable_shared_from_this* __pe, const _Tp1* __px)\n+      {\n+        if(__pe != 0)\n+          __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+      }\n+\n+    mutable weak_ptr<_Tp> _M_weak_this;\n+  };\n+\n+} // namespace tr1\n+\n+/**\n+ *  @brief   std::swap() specialisation for shared_ptr.\n+ *  @relates shared_ptr.\n+ */\n+template <typename _Tp>\n+  inline void\n+  swap(tr1::shared_ptr<_Tp>& __a, tr1::shared_ptr<_Tp>& __b)\n+  {\n+    __a.swap(__b);\n+  }\n+\n+/**\n+ *  @brief   std::swap() specialisation for weak_ptr.\n+ *  @relates weak_ptr.\n+ */\n+template <typename _Tp>\n+  void\n+  swap(tr1::weak_ptr<_Tp>& __a, tr1::weak_ptr<_Tp>& __b)\n+  {\n+    __a.swap(__b);\n+  }\n+\n+} // namespace std\n+\n+#endif"}, {"sha": "493bd84a77c81b2498728abe688f6f6d6d5331aa", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/not_shared.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do run { xfail *-*-* } }\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  X x;\n+\n+  try\n+  {\n+    std::tr1::shared_ptr<X> p = x.shared_from_this();\n+  }\n+  catch (const std::tr1::bad_weak_ptr&)\n+  {\n+    __throw_exception_again;\n+  }\n+  catch (...)\n+  {\n+  }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a6ca74da389b2ba5fd1aac15f283f63c8133ef18", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/not_shared2.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared2.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run { xfail *-*-* } }\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<X> p(new X);\n+\n+  X x(*p);  // copy of shared object should not be shared\n+\n+  try\n+  {\n+    std::tr1::shared_ptr<X> p = x.shared_from_this();\n+  }\n+  catch (const std::tr1::bad_weak_ptr&)\n+  {\n+    __throw_exception_again;\n+  }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3bca336bc2089db8e66c0b74526f64530882c760", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/not_shared3.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fnot_shared3.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do run { xfail *-*-* } }\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<X> p(new X);\n+\n+  X x;\n+  x = *p;  // copy of shared object should not be shared\n+\n+  try\n+  {\n+    std::tr1::shared_ptr<X> p = x.shared_from_this();\n+  }\n+  catch (const std::tr1::bad_weak_ptr&)\n+  {\n+    __throw_exception_again;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "aba0c5fb32f8fc8e856f05fbc12271669c83d741", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/shared.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fshared.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<X> p(new X);\n+  std::tr1::shared_ptr<X>  q = p->shared_from_this();\n+  VERIFY( p == q );\n+  VERIFY( !(p < q) && !(q < p) );  // p and q share ownership\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8c3c53fad510ddc0342d25d0b8abd4bab3dd8943", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/still_shared.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fstill_shared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fstill_shared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2Fstill_shared.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<X> p(new X);\n+\n+  *p = X();  // assigning to shared object doesn't stop it being shared\n+\n+  try\n+  {\n+    std::tr1::shared_ptr<X> p2 = p->shared_from_this();\n+  }\n+  catch (const std::tr1::bad_weak_ptr&)\n+  {\n+    test = false;\n+  }\n+  VERIFY( test );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a2c5dd4cf11a98e2a6ce479297f0699a4fbeeade", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/assign.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from shared_ptr<Y>\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+\n+  a = std::tr1::shared_ptr<A>(new A);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  a = std::tr1::shared_ptr<A>();\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 1 );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "85c5c899409bbb8649c93effc2327f6e3ffcca8e", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/auto_ptr.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from auto_ptr<Y>\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a(new A);\n+  std::auto_ptr<B> b(new B);\n+  a = b;\n+  VERIFY( a.get() != 0 );\n+  VERIFY( b.get() == 0 );\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dd186135cd04e99d920296692cc394e00bafd00e", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/auto_ptr_neg.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B { };\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from incompatible auto_ptr<Y>\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+  std::auto_ptr<B> b;\n+  a = b;                      // { dg-error \"here\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-error \"In constructor\" \"\" { target *-*-* } 0 }\n+// { dg-error \"cannot convert\" \"\" { target *-*-* } 0 }\n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 0 }"}, {"sha": "38a6efabce518298c95d7b29d743ce4e81bb1517", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/auto_ptr_rvalue_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+std::auto_ptr<A> source() { return std::auto_ptr<A>(); }\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from rvalue auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+  a = source(); // { dg-error \"no match\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-error \"auto_ptr\" \"\" { target *-*-* } 0 }\n+// { dg-error \"shared_ptr\" \"\" { target *-*-* } 0 }"}, {"sha": "a159156fa9d4c18b7bb2d80ba93f8f726b4e6e2c", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/shared_ptr.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from shared_ptr<Y>\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+\n+  a = std::tr1::shared_ptr<A>();\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::tr1::shared_ptr<A>(new A);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::tr1::shared_ptr<B>(new B);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 1 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "79776fc66f1127d0ca3c81df8e5c6d6bb580644f", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/shared_ptr_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B { };\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.assign]\n+\n+// Assignment from incompatible shared_ptr<Y>\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+  std::tr1::shared_ptr<B> b;\n+  a = b;                      // { dg-error \"here\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-error \"In member function\" \"\" { target *-*-* } 0 }\n+// { dg-error \"cannot convert\" \"\" { target *-*-* } 0 }"}, {"sha": "9201d4094d8b6a99c4fe14116e38f41650dd6d27", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/comparison/cmp.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcmp.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  virtual ~A() { }\n+};\n+\n+struct B : A\n+{\n+};\n+\n+// 2.2.3.6 shared_ptr comparison [tr.util.smartptr.shared.cmp]\n+\n+int\n+test01()\n+{\n+    // test empty shared_ptrs compare equivalent\n+    std::tr1::shared_ptr<A> p1;\n+    std::tr1::shared_ptr<B> p2;\n+    VERIFY( p1 == p2 );\n+    VERIFY( !(p1 != p2) );\n+    VERIFY( !(p1 < p2) && !(p2 < p1) );\n+    return 0;\n+}\n+\n+\n+// Construction from pointer\n+int\n+test02()\n+{\n+  std::tr1::shared_ptr<A> A_default;\n+\n+  std::tr1::shared_ptr<A> A_from_A(new A);\n+  VERIFY( A_default != A_from_A );\n+  VERIFY( !(A_default == A_from_A) );\n+  VERIFY( (A_default < A_from_A) || (A_from_A < A_default) );\n+\n+  std::tr1::shared_ptr<B> B_from_B(new B);\n+  VERIFY( B_from_B != A_from_A );\n+  VERIFY( !(B_from_B == A_from_A) );\n+  VERIFY( (B_from_B < A_from_A) || (A_from_A < B_from_B) );\n+\n+  A_from_A.reset();\n+  VERIFY( A_default == A_from_A );\n+  VERIFY( !(A_default != A_from_A) );\n+  VERIFY( !(A_default < A_from_A) && !(A_from_A < A_default) );\n+\n+  B_from_B.reset();\n+  VERIFY( B_from_B == A_from_A );\n+  VERIFY( !(B_from_B != A_from_A) );\n+  VERIFY( !(B_from_B < A_from_A) && !(A_from_A < B_from_B) );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "796ae08962135e96de987ba28a141b329b45eaa9", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/auto_ptr.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Construction from auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::auto_ptr<A> a(new A);\n+  std::tr1::shared_ptr<A> a2(a);\n+  VERIFY( a.get() == 0 );\n+  VERIFY( a2.get() != 0 );\n+  VERIFY( a2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a43e9122e44a06ca8d01c464a43b9ffaa806c007", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/auto_ptr_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.3 shared_ptr assignment [tr.util.smartptr.shared.const]\n+\n+// Construction from const auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::auto_ptr<A> a;\n+  std::tr1::shared_ptr<A> p(a); // { dg-error \"no match\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-error \"shared_ptr\" \"candidates are\" { target *-*-* } 499 }\n+\n+// { dg-error \"shared_ptr\" \"\" { target *-*-* } 489 }"}, {"sha": "aa0daa2e80c0e22cd6bc3cf82f568ac11a11faa6", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/copy.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,135 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+void deleter(A* p) { delete p; }\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Copy construction\n+int test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a1;\n+  std::tr1::shared_ptr<A> a2(a1);\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a1(new A);\n+  std::tr1::shared_ptr<A> a2(a1);\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<B> b(new B);\n+  std::tr1::shared_ptr<A> a(b);\n+  VERIFY( a.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test04()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<B> b(new B, &deleter);\n+  std::tr1::shared_ptr<A> a(b);\n+  VERIFY( a.use_count() == 2 );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "7258e2edb75607a7e6490af227abdab5d7ab7c99", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/default.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Default construction\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+  VERIFY( a.get() == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "676878234896c1ee9bcaa519d7c73f2beafb2c63", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/pointer.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Construction from pointer\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = 0;\n+  std::tr1::shared_ptr<A> p(a);\n+  VERIFY( p.get() == 0 );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::tr1::shared_ptr<A> p(a);\n+  VERIFY( p.get() == a );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  B * const b = new B;\n+  std::tr1::shared_ptr<A> p(b);\n+  VERIFY( p.get() == b );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test02();\n+  return 0;\n+}"}, {"sha": "02441623d052eb5d70be8fec8e7922d7445b0f6b", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/weak_ptr.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Construction from weak_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::tr1::shared_ptr<A> a1(a);\n+  std::tr1::weak_ptr<A> wa(a1);\n+  std::tr1::shared_ptr<A> a2(wa);\n+  VERIFY( a2.get() == a );\n+  VERIFY( a2.use_count() == wa.use_count() );\n+\n+  return 0;\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8b0213ec726ebff510329e35adcba04d919b966b", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/weak_ptr_expired.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_expired.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.1 shared_ptr constructors [tr.util.smartptr.shared.const]\n+\n+// Construction from expired weak_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a1(new A);\n+  std::tr1::weak_ptr<A> wa(a1);\n+  a1.reset();\n+  try\n+  {\n+    std::tr1::shared_ptr<A> a2(wa);\n+  }\n+  catch (const std::tr1::bad_weak_ptr&)\n+  {\n+    // Expected.\n+  }\n+  catch (...)\n+  {\n+    // Failed.\n+    __throw_exception_again;\n+  }\n+  VERIFY( wa.expired() );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "081d2dac6830e89a7f5c7976a068bbe6e9e735c9", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/dest/dest.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,133 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct D\n+{\n+  void operator()(const B* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+    D::delete_count = 0;\n+  }\n+};\n+\n+\n+// 2.2.3.2 shared_ptr destructor [tr.util.smartptr.shared.dest]\n+\n+// empty shared_ptr\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::tr1::shared_ptr<A> a;\n+  }\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+  VERIFY( D::delete_count == 0 );\n+\n+  return 0;\n+}\n+\n+// shared ownership\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> a;\n+  {\n+    a = std::tr1::shared_ptr<A>(new B, D());\n+  }\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+  VERIFY( D::delete_count == 0 );\n+\n+  return 0;\n+}\n+\n+// exclusive ownership\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::tr1::shared_ptr<A> a1(new B);\n+    std::tr1::shared_ptr<A> a2(new B, D());\n+  }\n+  VERIFY( A::ctor_count == 2 );\n+  VERIFY( A::dtor_count == 2 );\n+  VERIFY( B::ctor_count == 2 );\n+  VERIFY( B::dtor_count == 2 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "17e836feef2024ee078395525a281ad410ee5d8d", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/misc/io.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fio.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.7 shared_ptr I/O [tr.util.smartptr.shared.io]\n+\n+// operator<<\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p(new A);\n+  std::ostringstream buf;\n+  buf << p;\n+  const std::string s = buf.str();\n+  buf.str(\"\");\n+  buf << p.get();\n+  VERIFY( s == buf.str() );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "930c2b9a6be39213954e42bb4ef2c1091cf33c15", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/misc/swap.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmisc%2Fswap.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.8 shared_ptr specialized algorithms [tr.util.smartptr.shared.spec]\n+\n+// std::swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a1 = new A;\n+  A * const a2 = new A;\n+  std::tr1::shared_ptr<A> p1(a1);\n+  std::tr1::shared_ptr<A> p2(a2);\n+  std::swap(p1, p2);\n+  VERIFY( p1.get() == a2 );\n+  VERIFY( p2.get() == a1 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6976cc7d233103d62351b92a9041040dcc9a7183", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/modifiers/reset.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+struct D\n+{\n+  void operator()(B* p) { delete p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// 2.2.3.4 shared_ptr modifiers [tr.util.smartptr.shared.mod]\n+\n+// reset\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  std::tr1::shared_ptr<A> p1(a);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.get() == 0 );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  B * const b = new B;\n+  std::tr1::shared_ptr<A> p1(a);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p1.reset(b);\n+  VERIFY( p1.get() == b );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::tr1::shared_ptr<A> p1;\n+    p1.reset(new B, D());\n+  }\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}   \n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "623e07ab98d397e0a0b43478995e42e247e47f5e", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/modifiers/reset_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.4 shared_ptr modifiers [tr.util.smartptr.shared.mod]\n+\n+// reset\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::tr1::shared_ptr<A> p1(new A);\n+  p1.reset();     // { dg-error \"discards qualifiers\" }\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "15d17d4308cd119f3e21531135f71460fcdce69e", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/modifiers/swap.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.4 shared_ptr modifiers [tr.util.smartptr.shared.mod]\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a1 = new A;\n+  A * const a2 = new A;\n+  std::tr1::shared_ptr<A> p1(a1);\n+  std::tr1::shared_ptr<A> p2(a2);\n+  p1.swap(p2);\n+  VERIFY( p1.get() == a2 );\n+  VERIFY( p2.get() == a1 );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c16e226272472066962f9e9c154c3c63772ab715", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/modifiers/swap_neg.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap_neg.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.4 shared_ptr modifiers [tr.util.smartptr.shared.mod]\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::tr1::shared_ptr<A> p1(new A);\n+  std::tr1::shared_ptr<A> p2(new A);\n+  p1.swap(p2);   // { dg-error \"discards qualifiers\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f091e591c3905c1fe0bdc3f50c5c210f1623bd60", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/observers/bool_conv.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.5 shared_ptr observers [tr.util.smartptr.shared.obs]\n+\n+// conversion to bool\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::tr1::shared_ptr<A> p1;\n+  VERIFY( p1 == false );\n+  const std::tr1::shared_ptr<A> p2(p1);\n+  VERIFY( p2 == false );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  VERIFY( p1 );\n+  std::tr1::shared_ptr<A> p2(p1);\n+  VERIFY( p2 );\n+  p1.reset();\n+  VERIFY( !p1 );\n+  VERIFY( p2 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p2.reset(new A);\n+  VERIFY( p1 );\n+  VERIFY( p2 );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "7a0a6e521f69b0db3eceb72e27cf8a49a86e6cc9", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/observers/get.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fget.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fget.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fget.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() : i() {}\n+  int i;\n+};\n+\n+// 2.2.3.5 shared_ptr observers [tr.util.smartptr.shared.obs]\n+\n+// get\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::tr1::shared_ptr<A> p(a);\n+  VERIFY( p.get() == a );\n+\n+  return 0;\n+}\n+\n+// operator*\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::tr1::shared_ptr<A> p(a);\n+  VERIFY( &*p == a );\n+\n+  return 0;\n+}\n+\n+\n+// operator->\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A;\n+  const std::tr1::shared_ptr<A> p(a);\n+  VERIFY( &p->i == &a->i );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "f01121273dabdd97855a66bdc7be530858139a7a", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/observers/unique.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Funique.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Funique.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Funique.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 2.2.3.5 shared_ptr observers [tr.util.smartptr.shared.obs]\n+\n+// unique\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::tr1::shared_ptr<A> p1;\n+  VERIFY( !p1.unique() );\n+  const std::tr1::shared_ptr<A> p2(p1);\n+  VERIFY( !p1.unique() );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  VERIFY( p1.unique() );\n+  std::tr1::shared_ptr<A> p2(p1);\n+  VERIFY( !p1.unique() );\n+  p1.reset();\n+  VERIFY( !p1.unique() );\n+  VERIFY( p2.unique() );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p2.reset(new A);\n+  VERIFY( p1.unique() );\n+  VERIFY( p2.unique() );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "9338dec3acb26f155e870fc8f3ca88c3aaa2fb2c", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/observers/use_count.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dfded9114ec3aad2f2eafe5ff606215c602620b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc?ref=7dfded9114ec3aad2f2eafe5ff606215c602620b", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+#include <tr1/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+// 2.2.3.5 shared_ptr observers [tr.util.smartptr.shared.obs]\n+\n+// use_count\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::tr1::shared_ptr<A> p1;\n+  VERIFY( p1.use_count() == 0 );\n+  const std::tr1::shared_ptr<A> p2(p1);\n+  VERIFY( p1.use_count() == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.use_count() == 0 );\n+  VERIFY( p2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::shared_ptr<A> p1(new A);\n+  std::tr1::shared_ptr<A> p2(p1);\n+  p2.reset(new B);\n+  VERIFY( p1.use_count() == 1 );\n+  VERIFY( p2.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}]}