{"sha": "6807da97b7a1d22a82a48844ccacfbdfcb983ada", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgwN2RhOTdiN2ExZDIyYTgyYTQ4ODQ0Y2NhY2ZiZGZjYjk4M2FkYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-06-01T08:52:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-06-01T08:52:33Z"}, "message": "tree.c (free_lang_data): Do not reset boolean_type_node nor char_type_node.\n\n2011-06-01  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (free_lang_data): Do not reset boolean_type_node nor\n\tchar_type_node.\n\t* lto-streamer.c (lto_record_common_node): Take node pointer,\n\tdo not register types.\n\t(lto_preload_common_nodes): Explicitly skip preloading nodes\n\tthat differ between frontends.\n\n\tlto/\n\t* lto-lang.c (lto_register_canonical_types): New function.\n\t(lto_init): Register common nodes with the canonical type machinery.\n\tDo not play tricks with char_type_node.\n\nFrom-SVN: r174519", "tree": {"sha": "076077eb59e88f362654a8c0a17e201cef22c8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/076077eb59e88f362654a8c0a17e201cef22c8d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6807da97b7a1d22a82a48844ccacfbdfcb983ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6807da97b7a1d22a82a48844ccacfbdfcb983ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6807da97b7a1d22a82a48844ccacfbdfcb983ada", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6807da97b7a1d22a82a48844ccacfbdfcb983ada/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3dca2ab7a79ef2e96d06b61f7f5189b46910691b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dca2ab7a79ef2e96d06b61f7f5189b46910691b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dca2ab7a79ef2e96d06b61f7f5189b46910691b"}], "stats": {"total": 126, "additions": 62, "deletions": 64}, "files": [{"sha": "8bac87586d010a4967b97f8c9272985168c42878", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6807da97b7a1d22a82a48844ccacfbdfcb983ada", "patch": "@@ -1,3 +1,12 @@\n+2011-06-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (free_lang_data): Do not reset boolean_type_node nor\n+\tchar_type_node.\n+\t* lto-streamer.c (lto_record_common_node): Take node pointer,\n+\tdo not register types.\n+\t(lto_preload_common_nodes): Explicitly skip preloading nodes\n+\tthat differ between frontends.\n+\n 2011-05-31  Pat Haugen <pthaugen@us.ibm.com>\n \n \t* config/rs6000/rs6000.h (REG_CLASS_CONTENTS): Remove vr0..vr2 from"}, {"sha": "763ecc5e903e0f688e927618818af2059b934c00", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=6807da97b7a1d22a82a48844ccacfbdfcb983ada", "patch": "@@ -478,10 +478,8 @@ lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n /* Record NODE in CACHE.  */\n \n static void\n-lto_record_common_node (struct lto_streamer_cache_d *cache, tree *nodep)\n+lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n {\n-  tree node = *nodep;\n-\n   /* We have to make sure to fill exactly the same number of\n      elements for all frontends.  That can include NULL trees.\n      As our hash table can't deal with zero entries we'll simply stream\n@@ -491,25 +489,12 @@ lto_record_common_node (struct lto_streamer_cache_d *cache, tree *nodep)\n   if (!node)\n     node = error_mark_node;\n \n-  if (TYPE_P (node))\n-    {\n-      /* Type merging will get confused by the canonical types as they\n-\t are set by the middle-end.  */\n-      if (in_lto_p)\n-\tTYPE_CANONICAL (node) = NULL_TREE;\n-      node = gimple_register_type (node);\n-      TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n-      if (in_lto_p)\n-\tTYPE_CANONICAL (*nodep) = TYPE_CANONICAL (node);\n-      *nodep = node;\n-    }\n-\n   lto_streamer_cache_append (cache, node);\n \n   if (POINTER_TYPE_P (node)\n       || TREE_CODE (node) == COMPLEX_TYPE\n       || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_record_common_node (cache, &TREE_TYPE (node));\n+    lto_record_common_node (cache, TREE_TYPE (node));\n   else if (TREE_CODE (node) == RECORD_TYPE)\n     {\n       /* The FIELD_DECLs of structures should be shared, so that every\n@@ -519,7 +504,7 @@ lto_record_common_node (struct lto_streamer_cache_d *cache, tree *nodep)\n \t nonoverlapping_component_refs_p).  */\n       tree f;\n       for (f = TYPE_FIELDS (node); f; f = TREE_CHAIN (f))\n-\tlto_record_common_node (cache, &f);\n+\tlto_record_common_node (cache, f);\n     }\n }\n \n@@ -553,16 +538,20 @@ lto_preload_common_nodes (struct lto_streamer_cache_d *cache)\n   gcc_assert (fileptr_type_node == ptr_type_node);\n   gcc_assert (TYPE_MAIN_VARIANT (fileptr_type_node) == ptr_type_node);\n \n-  /* Skip itk_char.  char_type_node is shared with the appropriately\n-     signed variant.  */\n-  for (i = itk_signed_char; i < itk_none; i++)\n-    lto_record_common_node (cache, &integer_types[i]);\n+  for (i = 0; i < itk_none; i++)\n+    /* Skip itk_char.  char_type_node is dependent on -f[un]signed-char.  */\n+    if (i != itk_char)\n+      lto_record_common_node (cache, integer_types[i]);\n \n   for (i = 0; i < TYPE_KIND_LAST; i++)\n-    lto_record_common_node (cache, &sizetype_tab[i]);\n+    lto_record_common_node (cache, sizetype_tab[i]);\n \n   for (i = 0; i < TI_MAX; i++)\n-    lto_record_common_node (cache, &global_trees[i]);\n+    /* Skip boolean type and constants, they are frontend dependent.  */\n+    if (i != TI_BOOLEAN_TYPE\n+\t&& i != TI_BOOLEAN_FALSE\n+\t&& i != TI_BOOLEAN_TRUE)\n+      lto_record_common_node (cache, global_trees[i]);\n }\n \n /* Create a cache of pickled nodes.  */"}, {"sha": "b96371e7ed29db4cda3861f182be096a59d443a6", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6807da97b7a1d22a82a48844ccacfbdfcb983ada", "patch": "@@ -1,3 +1,9 @@\n+2011-06-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-lang.c (lto_register_canonical_types): New function.\n+\t(lto_init): Register common nodes with the canonical type machinery.\n+\tDo not play tricks with char_type_node.\n+\n 2011-05-26  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (uniquify_nodes): Fix bug in one of the previous changes."}, {"sha": "296a71976d1bbd4ac1c9ab2ac8eec45c4095cfb4", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=6807da97b7a1d22a82a48844ccacfbdfcb983ada", "patch": "@@ -1052,12 +1052,31 @@ lto_build_c_type_nodes (void)\n   pid_type_node = integer_type_node;\n }\n \n+/* Re-compute TYPE_CANONICAL for NODE and related types.  */\n+\n+static void\n+lto_register_canonical_types (tree node)\n+{\n+  if (!node\n+      || !TYPE_P (node))\n+    return;\n+\n+  TYPE_CANONICAL (node) = NULL_TREE;\n+  TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n+\n+  if (POINTER_TYPE_P (node)\n+      || TREE_CODE (node) == COMPLEX_TYPE\n+      || TREE_CODE (node) == ARRAY_TYPE)\n+    lto_register_canonical_types (TREE_TYPE (node));\n+}\n \n /* Perform LTO-specific initialization.  */\n \n static bool\n lto_init (void)\n {\n+  unsigned i;\n+\n   /* We need to generate LTO if running in WPA mode.  */\n   flag_generate_lto = flag_wpa;\n \n@@ -1068,33 +1087,16 @@ lto_init (void)\n   /* Create the basic integer types.  */\n   build_common_tree_nodes (flag_signed_char);\n \n-  /* Share char_type_node with whatever would be the default for the target.\n-     char_type_node will be used for internal types such as\n-     va_list_type_node but will not be present in the lto stream.  */\n-  /* ???  This breaks the more common case of consistent but non-standard\n-     setting of flag_signed_char, so share according to flag_signed_char.\n-     See PR42528.  */\n-  char_type_node\n-    = flag_signed_char ? signed_char_type_node : unsigned_char_type_node;\n-\n   /* Tell the middle end what type to use for the size of objects.  */\n   if (strcmp (SIZE_TYPE, \"unsigned int\") == 0)\n-    {\n-      set_sizetype (unsigned_type_node);\n-      size_type_node = unsigned_type_node;\n-    }\n+    size_type_node = unsigned_type_node;\n   else if (strcmp (SIZE_TYPE, \"long unsigned int\") == 0)\n-    {\n-      set_sizetype (long_unsigned_type_node);\n-      size_type_node = long_unsigned_type_node;\n-    }\n+    size_type_node = long_unsigned_type_node;\n   else if (strcmp (SIZE_TYPE, \"long long unsigned int\") == 0)\n-    {\n-      set_sizetype (long_long_unsigned_type_node);\n-      size_type_node = long_long_unsigned_type_node;\n-    }\n+    size_type_node = long_long_unsigned_type_node;\n   else\n     gcc_unreachable ();\n+  set_sizetype (size_type_node);\n \n   /* The global tree for the main identifier is filled in by\n      language-specific front-end initialization that is not run in the\n@@ -1158,6 +1160,17 @@ lto_init (void)\n   NAME_TYPE (boolean_type_node, \"bool\");\n #undef NAME_TYPE\n \n+  /* Register the common node types with the canonical type machinery so\n+     we properly share alias-sets across languages and TUs.  Do not\n+     expose the common nodes as type merge target - those that should be\n+     are already exposed so by pre-loading the LTO streamer caches.  */\n+  for (i = 0; i < itk_none; ++i)\n+    lto_register_canonical_types (integer_types[i]);\n+  /* The sizetypes are not used to access data so we do not need to\n+     do anything about them.  */\n+  for (i = 0; i < TI_MAX; ++i)\n+    lto_register_canonical_types (global_trees[i]);\n+\n   /* Initialize LTO-specific data structures.  */\n   lto_global_var_decls = VEC_alloc (tree, gc, 256);\n   in_lto_p = true;"}, {"sha": "764a0f422dfcd108e03c22318bc5ba5c916d9d18", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6807da97b7a1d22a82a48844ccacfbdfcb983ada/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6807da97b7a1d22a82a48844ccacfbdfcb983ada", "patch": "@@ -5176,25 +5176,6 @@ free_lang_data (void)\n   /* Create gimple variants for common types.  */\n   ptrdiff_type_node = integer_type_node;\n   fileptr_type_node = ptr_type_node;\n-  if (TREE_CODE (boolean_type_node) != BOOLEAN_TYPE\n-      || (TYPE_MODE (boolean_type_node)\n-\t  != mode_for_size (BOOL_TYPE_SIZE, MODE_INT, 0))\n-      || TYPE_PRECISION (boolean_type_node) != 1\n-      || !TYPE_UNSIGNED (boolean_type_node))\n-    {\n-      boolean_type_node = make_unsigned_type (BOOL_TYPE_SIZE);\n-      TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n-      TYPE_MAX_VALUE (boolean_type_node) = build_int_cst (boolean_type_node, 1);\n-      TYPE_PRECISION (boolean_type_node) = 1;\n-      boolean_false_node = TYPE_MIN_VALUE (boolean_type_node);\n-      boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n-    }\n-\n-  /* Unify char_type_node with its properly signed variant.  */\n-  if (TYPE_UNSIGNED (char_type_node))\n-    unsigned_char_type_node = char_type_node;\n-  else\n-    signed_char_type_node = char_type_node;\n \n   /* Reset some langhooks.  Do not reset types_compatible_p, it may\n      still be used indirectly via the get_alias_set langhook.  */"}]}