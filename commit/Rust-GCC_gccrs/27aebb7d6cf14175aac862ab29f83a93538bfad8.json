{"sha": "27aebb7d6cf14175aac862ab29f83a93538bfad8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhZWJiN2Q2Y2YxNDE3NWFhYzg2MmFiMjlmODNhOTM1MzhiZmFkOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-01T15:56:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-01T16:00:34Z"}, "message": "c++: Expose cloning form predicates\n\nA further adjustment of the function cloning.  Rather than have\ncopy_fndecl_with_name deduce whether a particular cdtor needs a\nvtt_parm and/or has inherited parms to drop, pass that information in\nfrom the caller.  In particular build_cdtor_clones knows when its\nbuilding the particular cdtors that might need these.  On the modules\nbranch I need to clone cdtors before the underlying class information\nis necessarily complete.  There build_cdtor_clones is externally\ncallable to facilitate that.\n\ngcc/cp/\n\t* class.c (copy_fndecl_with_name): Add additional predicate args, do\n\tnot deduce them locally.\n\t(copy_operator_fn): Adjust copy_fndecl_with_name call.\n\t(build_clone): Add vtt and inherited predicate args.  Pass through\n\tto copy_fndecl_with_name call.\n\t(build_cdtor_clones): Likewise, pass through to build_clone as\n\tneeded.\n\t(build_cdtor): Determine vtt and inherited here.\n\t* cp-tree.h (DECL_NEEDS_CTT_PARM_P): Delete.", "tree": {"sha": "369ba3a93d5c489442e58abb9a57a1a6b583c747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/369ba3a93d5c489442e58abb9a57a1a6b583c747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27aebb7d6cf14175aac862ab29f83a93538bfad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27aebb7d6cf14175aac862ab29f83a93538bfad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27aebb7d6cf14175aac862ab29f83a93538bfad8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27aebb7d6cf14175aac862ab29f83a93538bfad8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d7e5fa655e59c99035bf94a46c912e369bb9fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7e5fa655e59c99035bf94a46c912e369bb9fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7e5fa655e59c99035bf94a46c912e369bb9fa0"}], "stats": {"total": 75, "additions": 41, "deletions": 34}, "files": [{"sha": "7b5f1669d044c6fcf12d95a079c8ef0653e66c9a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27aebb7d6cf14175aac862ab29f83a93538bfad8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27aebb7d6cf14175aac862ab29f83a93538bfad8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=27aebb7d6cf14175aac862ab29f83a93538bfad8", "patch": "@@ -182,7 +182,6 @@ static void dfs_accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n static void build_vcall_and_vbase_vtbl_entries (tree, vtbl_init_data *);\n static void clone_constructors_and_destructors (tree);\n-static tree build_clone (tree, tree);\n static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n static void build_ctor_vtbl_group (tree, tree);\n static void build_vtt (tree);\n@@ -4697,7 +4696,8 @@ check_methods (tree t)\n }\n \n static tree\n-copy_fndecl_with_name (tree fn, tree name)\n+copy_fndecl_with_name (tree fn, tree name, tree_code code,\n+\t\t       bool need_vtt_parm_p, bool omit_inherited_parms_p)\n {\n   /* Copy the function.  */\n   tree clone = copy_decl (fn);\n@@ -4714,23 +4714,24 @@ copy_fndecl_with_name (tree fn, tree name)\n   DECL_PENDING_INLINE_INFO (clone) = NULL;\n   DECL_PENDING_INLINE_P (clone) = 0;\n \n-  /* The base-class destructor is not virtual.  */\n   if (name == base_dtor_identifier)\n     {\n+      /* The base-class destructor is not virtual.  */\n       DECL_VIRTUAL_P (clone) = 0;\n       DECL_VINDEX (clone) = NULL_TREE;\n     }\n-  else if (IDENTIFIER_OVL_OP_P (name))\n+  else if (code != ERROR_MARK)\n     {\n-      const ovl_op_info_t *ovl_op = IDENTIFIER_OVL_OP_INFO (name);\n+      /* Set the operator code.  */\n+      const ovl_op_info_t *ovl_op = OVL_OP_INFO (false, code);\n       DECL_OVERLOADED_OPERATOR_CODE_RAW (clone) = ovl_op->ovl_op_code;\n-    }\n \n-  if (DECL_VIRTUAL_P (clone))\n-    IDENTIFIER_VIRTUAL_P (name) = true;\n+      /* The operator could be virtual.  */\n+      if (DECL_VIRTUAL_P (clone))\n+\tIDENTIFIER_VIRTUAL_P (name) = true;\n+   }\n \n-  bool ctor_omit_inherited_parms_p = ctor_omit_inherited_parms (clone);\n-  if (ctor_omit_inherited_parms_p)\n+  if (omit_inherited_parms_p)\n     gcc_assert (DECL_HAS_IN_CHARGE_PARM_P (clone));\n \n   /* If there was an in-charge parameter, drop it from the function\n@@ -4744,13 +4745,12 @@ copy_fndecl_with_name (tree fn, tree name)\n       /* Skip the in-charge parameter.  */\n       parmtypes = TREE_CHAIN (parmtypes);\n       /* And the VTT parm, in a complete [cd]tor.  */\n-      if (DECL_HAS_VTT_PARM_P (fn)\n-\t  && ! DECL_NEEDS_VTT_PARM_P (clone))\n+      if (DECL_HAS_VTT_PARM_P (fn) && !need_vtt_parm_p)\n \tparmtypes = TREE_CHAIN (parmtypes);\n-      if (ctor_omit_inherited_parms_p)\n+      if (omit_inherited_parms_p)\n \t{\n \t  /* If we're omitting inherited parms, that just leaves the VTT.  */\n-\t  gcc_assert (DECL_NEEDS_VTT_PARM_P (clone));\n+\t  gcc_assert (need_vtt_parm_p);\n \t  parmtypes = tree_cons (NULL_TREE, vtt_parm_type, void_list_node);\n \t}\n       TREE_TYPE (clone)\n@@ -4766,17 +4766,19 @@ copy_fndecl_with_name (tree fn, tree name)\n \n   /* Copy the function parameters.  */\n   DECL_ARGUMENTS (clone) = copy_list (DECL_ARGUMENTS (clone));\n+\n   /* Remove the in-charge parameter.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n     {\n       DECL_CHAIN (DECL_ARGUMENTS (clone))\n \t= DECL_CHAIN (DECL_CHAIN (DECL_ARGUMENTS (clone)));\n       DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n     }\n+\n   /* And the VTT parm, in a complete [cd]tor.  */\n   if (DECL_HAS_VTT_PARM_P (fn))\n     {\n-      if (DECL_NEEDS_VTT_PARM_P (clone))\n+      if (need_vtt_parm_p)\n \tDECL_HAS_VTT_PARM_P (clone) = 1;\n       else\n \t{\n@@ -4788,7 +4790,7 @@ copy_fndecl_with_name (tree fn, tree name)\n \n   /* A base constructor inheriting from a virtual base doesn't get the\n      arguments.  */\n-  if (ctor_omit_inherited_parms_p)\n+  if (omit_inherited_parms_p)\n     DECL_CHAIN (DECL_CHAIN (DECL_ARGUMENTS (clone))) = NULL_TREE;\n \n   for (tree parms = DECL_ARGUMENTS (clone); parms; parms = DECL_CHAIN (parms))\n@@ -4809,15 +4811,17 @@ copy_fndecl_with_name (tree fn, tree name)\n tree\n copy_operator_fn (tree fn, tree_code code)\n {\n-  return copy_fndecl_with_name (fn, ovl_op_identifier (code));\n+  return copy_fndecl_with_name (fn, ovl_op_identifier (code),\n+\t\t\t\tcode, false, false);\n }\n \n /* FN is a constructor or destructor.  Clone the declaration to create\n    a specialized in-charge or not-in-charge version, as indicated by\n    NAME.  */\n \n static tree\n-build_clone (tree fn, tree name)\n+build_clone (tree fn, tree name, bool need_vtt_parm_p,\n+\t     bool omit_inherited_parms_p)\n {\n   tree clone;\n \n@@ -4827,7 +4831,8 @@ build_clone (tree fn, tree name)\n       clone = copy_decl (fn);\n       DECL_NAME (clone) = name;\n \n-      tree result = build_clone (DECL_TEMPLATE_RESULT (clone), name);\n+      tree result = build_clone (DECL_TEMPLATE_RESULT (clone), name,\n+\t\t\t\t need_vtt_parm_p, omit_inherited_parms_p);\n       DECL_TEMPLATE_RESULT (clone) = result;\n \n       DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n@@ -4837,7 +4842,8 @@ build_clone (tree fn, tree name)\n     }\n   else\n     {\n-      clone = copy_fndecl_with_name (fn, name);\n+      clone = copy_fndecl_with_name (fn, name, ERROR_MARK,\n+\t\t\t\t     need_vtt_parm_p, omit_inherited_parms_p);\n       DECL_CLONED_FUNCTION (clone) = fn;\n     }\n \n@@ -4856,16 +4862,17 @@ build_clone (tree fn, tree name)\n    will be inserted onto DECL_CHAIN of FN.  */\n \n static unsigned\n-build_cdtor_clones (tree fn)\n+build_cdtor_clones (tree fn, bool needs_vtt_parm_p, bool omit_inherited_parms_p)\n {\n   unsigned count = 0;\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn))\n     {\n       /* For each constructor, we need two variants: an in-charge version\n \t and a not-in-charge version.  */\n-      build_clone (fn, complete_ctor_identifier);\n-      build_clone (fn, base_ctor_identifier);\n+      build_clone (fn, complete_ctor_identifier, false, false);\n+      build_clone (fn, base_ctor_identifier, needs_vtt_parm_p,\n+\t\t   omit_inherited_parms_p);\n       count += 2;\n     }\n   else\n@@ -4883,11 +4890,11 @@ build_cdtor_clones (tree fn)\n \t destructor.  */\n       if (DECL_VIRTUAL_P (fn))\n \t{\n-\t  build_clone (fn, deleting_dtor_identifier);\n+\t  build_clone (fn, deleting_dtor_identifier, false, false);\n \t  count++;\n \t}\n-      build_clone (fn, complete_dtor_identifier);\n-      build_clone (fn, base_dtor_identifier);\n+      build_clone (fn, complete_dtor_identifier, false, false);\n+      build_clone (fn, base_dtor_identifier, needs_vtt_parm_p, false);\n       count += 2;\n     }\n \n@@ -4906,7 +4913,14 @@ clone_cdtor (tree fn, bool update_methods)\n       && DECL_CLONED_FUNCTION_P (DECL_CHAIN (fn)))\n     return;\n \n-  unsigned count = build_cdtor_clones (fn);\n+  /* Base cdtors need a vtt parm if there are virtual bases.  */\n+  bool vtt = CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn));\n+\n+  /* Base ctor omits inherited parms it needs a vttparm and inherited\n+     from a virtual nase ctor.  */\n+  bool omit_inherited = ctor_omit_inherited_parms (fn);\n+\n+  unsigned count = build_cdtor_clones (fn, vtt, omit_inherited);\n \n   /* Note that this is an abstract function that is never emitted.  */\n   DECL_ABSTRACT_P (fn) = true;"}, {"sha": "2aa8ebe64c09e6d980f69a372e74a66c72da1a95", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27aebb7d6cf14175aac862ab29f83a93538bfad8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27aebb7d6cf14175aac862ab29f83a93538bfad8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=27aebb7d6cf14175aac862ab29f83a93538bfad8", "patch": "@@ -2997,13 +2997,6 @@ struct GTY(()) lang_decl {\n #define DECL_HAS_VTT_PARM_P(NODE) \\\n   (LANG_DECL_FN_CHECK (NODE)->has_vtt_parm_p)\n \n-/* Nonzero if NODE is a FUNCTION_DECL for which a VTT parameter is\n-   required.  */\n-#define DECL_NEEDS_VTT_PARM_P(NODE)\t\t\t\\\n-  (CLASSTYPE_VBASECLASSES (DECL_CONTEXT (NODE))\t\t\\\n-   && (DECL_BASE_CONSTRUCTOR_P (NODE)\t\t\t\\\n-       || DECL_BASE_DESTRUCTOR_P (NODE)))\n-\n /* Nonzero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE) IDENTIFIER_CONV_OP_P (DECL_NAME (NODE))\n "}]}