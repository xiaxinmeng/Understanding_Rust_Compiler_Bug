{"sha": "8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5NzcxMWRjZTVjNDhlNDZhOWE2NGM1NTE3ZmE2YWUxMGRiNWUwNA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-07T07:03:07Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-07T07:03:07Z"}, "message": "General cleanup of AST and macro expansion-related things", "tree": {"sha": "c8592dd1ca2a15e5fd1f7c1665f126dbd6c7026c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8592dd1ca2a15e5fd1f7c1665f126dbd6c7026c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94be91d6159101caa7c560b188bd6c02d8d86d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94be91d6159101caa7c560b188bd6c02d8d86d17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94be91d6159101caa7c560b188bd6c02d8d86d17"}], "stats": {"total": 1319, "additions": 396, "deletions": 923}, "files": [{"sha": "e1308b70039e983adfbb6ac5f315b806222cb295", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 198, "deletions": 676, "changes": 874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -109,50 +109,56 @@ frag_spec_to_str (MacroFragSpec frag_spec)\n     }\n }\n \n-enum AttrMode \n+enum AttrMode\n {\n   OUTER,\n   INNER\n };\n \n-std::string get_mode_dump_desc (AttrMode mode) {\n-  switch (mode) {\n+std::string\n+get_mode_dump_desc (AttrMode mode)\n+{\n+  switch (mode)\n+    {\n     case OUTER:\n       return \"outer attributes\";\n     case INNER:\n       return \"inner attributes\";\n     default:\n       gcc_unreachable ();\n       return \"\";\n-  }\n+    }\n }\n \n // Adds lines below adding attributes\n-std::string append_attributes (std::vector<Attribute> attrs, AttrMode mode) {\n+std::string\n+append_attributes (std::vector<Attribute> attrs, AttrMode mode)\n+{\n   indent_spaces (enter);\n \n-  std::string str = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n-  //str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n+  std::string str\n+    = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n+  // str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n   if (attrs.empty ())\n     {\n       str += \"none\";\n     }\n   else\n     {\n-      /* note that this does not print them with outer or \"inner attribute\" \n+      /* note that this does not print them with outer or \"inner attribute\"\n        * syntax - just prints the body */\n       for (const auto &attr : attrs)\n \tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n \n   indent_spaces (out);\n-  \n+\n   return str;\n }\n \n-// Removes the beginning and end quotes of a quoted string. \n+// Removes the beginning and end quotes of a quoted string.\n std::string\n-unquote_string (std::string input) \n+unquote_string (std::string input)\n {\n   rust_assert (input.front () == '\"');\n   rust_assert (input.back () == '\"');\n@@ -167,24 +173,13 @@ Crate::as_string () const\n   std::string str (\"Crate: \");\n   // add utf8bom and shebang\n   if (has_utf8bom)\n-      str += \"\\n has utf8bom\";\n+    str += \"\\n has utf8bom\";\n \n   if (has_shebang)\n-      str += \"\\n has shebang\";\n+    str += \"\\n has shebang\";\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // items\n   str += \"\\n items: \";\n@@ -315,7 +310,7 @@ SimplePath::as_string () const\n {\n   std::string path;\n   if (has_opening_scope_resolution)\n-      path = \"::\";\n+    path = \"::\";\n \n   // crappy hack because doing proper for loop would be more code\n   bool first_time = true;\n@@ -379,28 +374,11 @@ VisItem::as_string () const\n     }\n \n   if (has_visibility ())\n-      str += visibility.as_string () + \" \";\n+    str += visibility.as_string () + \" \";\n \n   return str;\n }\n \n-// Creates a string that reflects the outer attributes stored.\n-/*std::string\n-Item::as_string () const\n-{\n-  std::string str;\n-\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += attr.as_string () + \"\\n\";\n-\t}\n-    }\n-\n-  return str;\n-}*/\n-\n std::string\n Module::as_string () const\n {\n@@ -416,18 +394,7 @@ ModuleBodied::as_string () const\n   std::string str = Module::as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // items\n   str += \"\\n items: \";\n@@ -472,7 +439,7 @@ StaticItem::as_string () const\n   str += indent_spaces (stay) + \"static\";\n \n   if (has_mut)\n-      str += \" mut\";\n+    str += \" mut\";\n \n   str += \" \" + name;\n \n@@ -505,7 +472,7 @@ ExternCrate::as_string () const\n   str += \"extern crate \" + referenced_crate;\n \n   if (has_as_clause ())\n-      str += \" as \" + as_clause_name;\n+    str += \" as \" + as_clause_name;\n \n   return str;\n }\n@@ -550,14 +517,14 @@ TupleStruct::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t  str += \"\\n  \" + field.as_string ();\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -625,25 +592,12 @@ InherentImpl::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // inherent impl items\n   str += \"\\n Inherent impl items: \";\n@@ -654,7 +608,7 @@ InherentImpl::as_string () const\n   else\n     {\n       for (const auto &item : impl_items)\n-\t  str += \"\\n  \" + item->as_string ();\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -757,9 +711,9 @@ StructStruct::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   // struct fields\n   str += \"\\n Struct fields: \";\n@@ -774,7 +728,7 @@ StructStruct::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t  str += \"\\n  \" + field.as_string ();\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   return str;\n@@ -926,9 +880,9 @@ Enum::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   // items\n   str += \"\\n Items: \";\n@@ -963,7 +917,7 @@ Trait::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-      str += \"unsafe \";\n+    str += \"unsafe \";\n \n   str += \"trait \" + name;\n \n@@ -1016,9 +970,9 @@ Trait::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n \n   str += \"\\n Trait items: \";\n   if (!has_trait_items ())\n@@ -1079,9 +1033,9 @@ Union::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   // struct fields\n   str += \"\\n Struct fields (variants): \";\n@@ -1092,7 +1046,7 @@ Union::as_string () const\n   else\n     {\n       for (const auto &field : variants)\n-\t  str += \"\\n  \" + field.as_string ();\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   return str;\n@@ -1213,34 +1167,12 @@ BlockExpr::as_string () const\n {\n   std::string istr = indent_spaces (enter);\n   std::string str = istr + \"BlockExpr:\\n\" + istr;\n-  \n+\n   // get outer attributes\n-  str += \"{\\n\" + indent_spaces (stay) + \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n+  str += append_attributes (outer_attrs, OUTER);\n \n   // inner attributes\n-  str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // statements\n   str += \"\\n\" + indent_spaces (stay) + \"statements: \";\n@@ -1273,7 +1205,7 @@ BlockExpr::as_string () const\n   else\n     str += \"\\n\" + expr->as_string ();\n \n-  str += \"\\n\" + indent_spaces (out) + \"}\";\n+  str += \"\\n\" + indent_spaces (out);\n   return str;\n }\n \n@@ -1316,18 +1248,7 @@ TraitImpl::as_string () const\n     str += where_clause.as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n trait impl items: \";\n   if (!has_impl_items ())\n@@ -1383,50 +1304,11 @@ TypeAlias::as_string () const\n std::string\n MacroInvocationSemi::as_string () const\n {\n-  std::string str;\n-\n-  // get outer attrs\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += attr.as_string () + \"\\n\";\n-    }\n-\n-  str += invoc_data.as_string ();\n-\n-#if 0\n-  str += \"\\n\" + path.as_string () + \"!\";\n-\n-  std::string tok_trees;\n-  if (token_trees.empty ())\n-    {\n-      tok_trees = \"none\";\n-    }\n-  else\n-    {\n-      auto i = token_trees.begin ();\n-      auto e = token_trees.end ();\n+  std::string str = \"MacroInvocationSemi: \";\n \n-      // DEBUG: null pointer check\n-      if (i == e)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"something really terrible has gone wrong - null pointer \"\n-\t\t   \"token tree in macro invocation semi.\");\n-\t  return \"NULL_POINTER_MARK\";\n-\t}\n-\n-      std::string s;\n-      for (; i != e; i++)\n-\t{\n-\t  s += (*i)->as_string ();\n-\t  if (e != i + 1)\n-\t    s += \", \";\n-\t}\n+  str += append_attributes (outer_attrs, OUTER);\n \n-      tok_trees += get_string_in_delims (s, delim_type);\n-    }\n-#endif\n+  str += \"\\n\" + invoc_data.as_string ();\n \n   return str;\n }\n@@ -1438,21 +1320,9 @@ ExternBlock::as_string () const\n \n   str += \"extern \";\n   if (has_abi ())\n-      str += \"\\\"\" + abi + \"\\\" \";\n+    str += \"\\\"\" + abi + \"\\\" \";\n \n-  // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n external items: \";\n   if (!has_extern_items ())\n@@ -1488,11 +1358,7 @@ MacroRulesDefinition::as_string () const\n   std::string str;\n \n   // get outer attrs\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += attr.as_string () + \"\\n\";\n-    }\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"macro_rules!\";\n \n@@ -1531,9 +1397,13 @@ MacroRulesDefinition::as_string () const\n std::string\n MacroInvocation::as_string () const\n {\n-  /*return \"MacroInvocation: \" + path.as_string () + \"!\"\n-\t + token_tree.as_string ();*/\n-  return \"MacroInvocation: \" + invoc_data.as_string ();\n+  std::string str = \"MacroInvocation: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n+\n+  str += \"\\n \" + invoc_data.as_string ();\n+\n+  return str;\n }\n \n std::string\n@@ -1591,22 +1461,6 @@ ClosureExpr::as_string () const\n \n   str += append_attributes (outer_attrs, OUTER);\n \n-#if 0\n-  // outer attributes\n-  str += \"\\n outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n-\n   str += \"\\n Has move: \";\n   if (has_move)\n     str += \"true\";\n@@ -1674,7 +1528,7 @@ QualifiedPathInExpression::as_string () const\n std::string\n BorrowExpr::as_string () const\n {\n-  /* TODO: find way to incorporate outer attrs - may have to represent in \n+  /* TODO: find way to incorporate outer attrs - may have to represent in\n    * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n \n   std::string str (\"&\");\n@@ -1693,7 +1547,7 @@ BorrowExpr::as_string () const\n std::string\n ReturnExpr::as_string () const\n {\n-  /* TODO: find way to incorporate outer attrs - may have to represent in \n+  /* TODO: find way to incorporate outer attrs - may have to represent in\n    * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n \n   std::string str (\"return \");\n@@ -1713,20 +1567,6 @@ GroupedExpr::as_string () const\n   str += append_attributes (outer_attrs, OUTER);\n \n   // inner attributes\n-#if 0\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n   str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n@@ -1821,7 +1661,7 @@ AsyncBlockExpr::as_string () const\n   std::string str = \"AsyncBlockExpr: \";\n \n   // get outer attributes\n-  //str += \"\\n \" + Expr::as_string ();\n+  // str += \"\\n \" + Expr::as_string ();\n   str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Has move: \";\n@@ -1871,7 +1711,7 @@ MethodCallExpr::as_string () const\n   std::string str = \"MethodCallExpr: \";\n \n   str += append_attributes (outer_attrs, OUTER);\n-  \n+\n   str += \"\\n Object (receiver) expr: \\n\";\n   str += receiver->as_string ();\n \n@@ -1958,15 +1798,14 @@ RangeToInclExpr::as_string () const\n std::string\n UnsafeBlockExpr::as_string () const\n {\n-  std::string istr = indent_spaces (enter);\n-  std::string str = istr + \"UnsafeBlockExpr:\";\n-  str += istr + \"{\";\n+  std::string str = \"UnsafeBlockExpr:\" + indent_spaces (enter);\n \n   // get outer attributes\n-  //str += \"\\n\" + indent_spaces (stay) + Expr::as_string ();\n   str += append_attributes (outer_attrs, OUTER);\n \n-  return str + \"\\n\" + indent_spaces (out) + \"}\\n\" + expr->as_string ();\n+  str += indent_spaces (stay) + expr->as_string () + \"\\n\" + indent_spaces (out);\n+\n+  return str;\n }\n \n std::string\n@@ -1982,9 +1821,9 @@ ClosureExprInner::as_string () const\n std::string\n IfExpr::as_string () const\n {\n-  /* TODO: can if exprs have outer attributes? i thought no, but can't find it\n-   * in docs */\n-  std::string str (\"IfExpr: \");\n+  std::string str = \"IfExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Condition expr: \" + condition->as_string ();\n \n@@ -2026,9 +1865,9 @@ IfExprConseqIfLet::as_string () const\n std::string\n IfLetExpr::as_string () const\n {\n-  /* TODO: can if let exprs have outer attributes? i thought no, but can't find \n-   * it in docs */\n-  std::string str (\"IfLetExpr: \");\n+  std::string str = \"IfLetExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Condition match arm patterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2218,7 +2057,7 @@ CallExpr::as_string () const\n   std::string str = \"CallExpr: \";\n \n   str += append_attributes (outer_attrs, OUTER);\n-  \n+\n   str += \"\\n Function expr: \";\n   str += function->as_string ();\n \n@@ -2319,20 +2158,6 @@ ArrayExpr::as_string () const\n \n   // inner attributes\n   str += append_attributes (inner_attrs, INNER);\n-  #if 0\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-  #endif\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n@@ -2376,20 +2201,6 @@ MatchArm::as_string () const\n {\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"Outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\nPatterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2422,26 +2233,6 @@ MatchCase::as_string () const\n   return str;\n }\n \n-/*std::string\n-MatchCaseBlockExpr::as_string () const\n-{\n-  std::string str = MatchCase::as_string ();\n-\n-  str += \"\\n Block expr: \" + block_expr->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-MatchCaseExpr::as_string () const\n-{\n-  std::string str = MatchCase::as_string ();\n-\n-  str += \"\\n Expr: \" + expr->as_string ();\n-\n-  return str;\n-}*/\n-\n std::string\n MatchExpr::as_string () const\n {\n@@ -2453,20 +2244,6 @@ MatchExpr::as_string () const\n \n   // inner attributes\n   str += append_attributes (inner_attrs, INNER);\n-#if 0\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   // match arms\n   str += \"\\n Match arms: \";\n@@ -2492,20 +2269,6 @@ TupleExpr::as_string () const\n \n   // inner attributes\n   str += append_attributes (inner_attrs, INNER);\n-#if 0\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\n Tuple elements: \";\n   if (tuple_elems.empty ())\n@@ -2515,7 +2278,7 @@ TupleExpr::as_string () const\n   else\n     {\n       for (const auto &elem : tuple_elems)\n-\t  str += \"\\n  \" + elem->as_string ();\n+\tstr += \"\\n  \" + elem->as_string ();\n     }\n \n   return str;\n@@ -2529,9 +2292,9 @@ ExprStmtWithoutBlock::as_string () const\n   str += indent_spaces (stay);\n \n   if (expr == nullptr)\n-      str += \"none (this shouldn't happen and is probably an error)\";\n+    str += \"none (this shouldn't happen and is probably an error)\";\n   else\n-      str += expr->as_string ();\n+    str += expr->as_string ();\n   indent_spaces (out);\n \n   return str;\n@@ -2565,13 +2328,13 @@ FunctionQualifiers::as_string () const\n     }\n \n   if (has_unsafe)\n-      str += \"unsafe \";\n+    str += \"unsafe \";\n \n   if (has_extern)\n     {\n       str += \"extern\";\n       if (extern_abi != \"\")\n-\t      str += \" \\\"\" + extern_abi + \"\\\"\";\n+\tstr += \" \\\"\" + extern_abi + \"\\\"\";\n     }\n \n   return str;\n@@ -2584,9 +2347,9 @@ TraitBound::as_string () const\n \n   str += \"\\n Has opening question mark: \";\n   if (opening_question_mark)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n For lifetimes: \";\n   if (!has_for_lifetimes ())\n@@ -2596,7 +2359,7 @@ TraitBound::as_string () const\n   else\n     {\n       for (const auto &lifetime : for_lifetimes)\n-\t  str += \"\\n  \" + lifetime.as_string ();\n+\tstr += \"\\n  \" + lifetime.as_string ();\n     }\n \n   str += \"\\n Type path: \" + type_path.as_string ();\n@@ -2635,7 +2398,7 @@ MacroMatcher::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t      str += \"\\n  \" + match->as_string ();\n+\tstr += \"\\n  \" + match->as_string ();\n     }\n \n   return str;\n@@ -2648,9 +2411,9 @@ LifetimeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += outer_attr.as_string ();\n+    str += outer_attr.as_string ();\n \n   str += \"\\n Lifetime: \" + lifetime.as_string ();\n \n@@ -2662,7 +2425,7 @@ LifetimeParam::as_string () const\n   else\n     {\n       for (const auto &bound : lifetime_bounds)\n-\t      str += \"\\n  \" + bound.as_string ();\n+\tstr += \"\\n  \" + bound.as_string ();\n     }\n \n   return str;\n@@ -2677,12 +2440,12 @@ MacroMatchFragment::as_string () const\n std::string\n QualifiedPathInType::as_string () const\n {\n-  /* TODO: this may need adjusting if segments (e.g. with functions) can't be \n+  /* TODO: this may need adjusting if segments (e.g. with functions) can't be\n    * literalised */\n   std::string str = path_type.as_string ();\n \n   for (const auto &segment : segments)\n-      str += \"::\" + segment->as_string ();\n+    str += \"::\" + segment->as_string ();\n \n   return str;\n }\n@@ -2700,14 +2463,14 @@ MacroMatchRepetition::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t  str += \"\\n  \" + match->as_string ();\n+\tstr += \"\\n  \" + match->as_string ();\n     }\n \n   str += \"\\n Sep: \";\n   if (!has_sep ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += sep->as_string ();\n+    str += sep->as_string ();\n \n   str += \"\\n Op: \";\n   switch (op)\n@@ -2735,7 +2498,7 @@ std::string\n Lifetime::as_string () const\n {\n   if (is_error ())\n-      return \"error lifetime\";\n+    return \"error lifetime\";\n \n   switch (lifetime_type)\n     {\n@@ -2753,15 +2516,15 @@ Lifetime::as_string () const\n std::string\n TypePath::as_string () const\n {\n-  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be \n+  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be\n    * literalised */\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-      str = \"::\";\n+    str = \"::\";\n \n   for (const auto &segment : segments)\n-      str += segment->as_string () + \"::\";\n+    str += segment->as_string () + \"::\";\n \n   // kinda hack - remove last 2 '::' characters\n   str.erase (str.length () - 2);\n@@ -2776,9 +2539,9 @@ TypeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += outer_attr.as_string ();\n+    str += outer_attr.as_string ();\n \n   str += \"\\n Identifier: \" + type_representation;\n \n@@ -2790,14 +2553,14 @@ TypeParam::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t  str += \"\\n  \" + bound->as_string ();\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   str += \"\\n Type: \";\n   if (!has_type ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += type->as_string ();\n+    str += type->as_string ();\n \n   return str;\n }\n@@ -2806,7 +2569,7 @@ SimplePath\n PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n {\n   if (!has_segments ())\n-      return SimplePath::create_empty ();\n+    return SimplePath::create_empty ();\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2817,7 +2580,7 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment.is_error () || segment.has_generic_args ()\n \t  || segment.as_string () == \"Self\")\n-\t  return SimplePath::create_empty ();\n+\treturn SimplePath::create_empty ();\n \n       // create segment and add to vector\n       std::string segment_str = segment.as_string ();\n@@ -2828,9 +2591,9 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n   // kind of a HACK to get locus depending on opening scope resolution\n   Location locus = Linemap::unknown_location ();\n   if (with_opening_scope_resolution)\n-      locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n+    locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n   else\n-      locus = simple_segments[0].get_locus ();\n+    locus = simple_segments[0].get_locus ();\n   // FIXME: this hack probably doesn't actually work\n \n   return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n@@ -2841,7 +2604,7 @@ SimplePath\n TypePath::as_simple_path () const\n {\n   if (segments.empty ())\n-      return SimplePath::create_empty ();\n+    return SimplePath::create_empty ();\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2852,7 +2615,7 @@ TypePath::as_simple_path () const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment == nullptr || segment->is_error ()\n \t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n-\t  return SimplePath::create_empty ();\n+\treturn SimplePath::create_empty ();\n \n       // create segment and add to vector\n       std::string segment_str = segment->as_string ();\n@@ -2870,7 +2633,7 @@ PathExprSegment::as_string () const\n   // TODO: rewrite dump to work with non-literalisable types\n   std::string ident_str = segment_name.as_string ();\n   if (has_generic_args ())\n-      ident_str += \"::<\" + generic_args.as_string () + \">\";\n+    ident_str += \"::<\" + generic_args.as_string () + \">\";\n \n   return ident_str;\n }\n@@ -2941,9 +2704,9 @@ ForLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += loop_label.as_string ();\n+    str += loop_label.as_string ();\n \n   str += \"\\n Pattern: \" + pattern->as_string ();\n \n@@ -2959,9 +2722,9 @@ RangePattern::as_string () const\n {\n   // TODO: maybe rewrite to work with non-linearisable bounds\n   if (has_ellipsis_syntax)\n-      return lower->as_string () + \"...\" + upper->as_string ();\n+    return lower->as_string () + \"...\" + upper->as_string ();\n   else\n-      return lower->as_string () + \"..=\" + upper->as_string ();\n+    return lower->as_string () + \"..=\" + upper->as_string ();\n }\n \n std::string\n@@ -2970,7 +2733,7 @@ RangePatternBoundLiteral::as_string () const\n   std::string str;\n \n   if (has_minus)\n-      str += \"-\";\n+    str += \"-\";\n \n   str += literal.as_string ();\n \n@@ -2983,7 +2746,7 @@ SlicePattern::as_string () const\n   std::string str (\"SlicePattern: \");\n \n   for (const auto &pattern : items)\n-      str += \"\\n \" + pattern->as_string ();\n+    str += \"\\n \" + pattern->as_string ();\n \n   return str;\n }\n@@ -2994,7 +2757,7 @@ TuplePatternItemsMultiple::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-      str += \"\\n \" + pattern->as_string ();\n+    str += \"\\n \" + pattern->as_string ();\n \n   return str;\n }\n@@ -3012,7 +2775,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t  str += \"\\n  \" + lower->as_string ();\n+\tstr += \"\\n  \" + lower->as_string ();\n     }\n \n   str += \"\\n Upper patterns: \";\n@@ -3023,7 +2786,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t  str += \"\\n  \" + upper->as_string ();\n+\tstr += \"\\n  \" + upper->as_string ();\n     }\n \n   return str;\n@@ -3040,20 +2803,6 @@ StructPatternField::as_string () const\n {\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str (\"Outer attributes: \");\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   return str;\n }\n@@ -3066,10 +2815,10 @@ StructPatternFieldIdent::as_string () const\n   str += \"\\n\";\n \n   if (has_ref)\n-      str += \"ref \";\n+    str += \"ref \";\n \n   if (has_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   str += ident;\n \n@@ -3114,14 +2863,14 @@ StructPatternElements::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t  str += \"\\n   \" + field->as_string ();\n+\tstr += \"\\n   \" + field->as_string ();\n     }\n \n   str += \"\\n  Etc: \";\n   if (has_struct_pattern_etc)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   return str;\n }\n@@ -3135,9 +2884,9 @@ StructPattern::as_string () const\n \n   str += \"\\n Struct pattern elems: \";\n   if (!has_struct_pattern_elems ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += elems.as_string ();\n+    str += elems.as_string ();\n \n   return str;\n }\n@@ -3148,7 +2897,7 @@ LiteralPattern::as_string () const\n   std::string str;\n \n   if (has_minus)\n-      str += \"-\";\n+    str += \"-\";\n \n   return str + lit.as_string ();\n }\n@@ -3160,10 +2909,10 @@ ReferencePattern::as_string () const\n   std::string str (\"&\");\n \n   if (has_two_amps)\n-      str += \"&\";\n+    str += \"&\";\n \n   if (is_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   str += pattern->as_string ();\n \n@@ -3177,15 +2926,15 @@ IdentifierPattern::as_string () const\n   std::string str;\n \n   if (is_ref)\n-      str += \"ref \";\n+    str += \"ref \";\n \n   if (is_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   str += variable_ident;\n \n   if (has_pattern_to_bind ())\n-      str += \" @ \" + to_bind->as_string ();\n+    str += \" @ \" + to_bind->as_string ();\n \n   return str;\n }\n@@ -3196,7 +2945,7 @@ TupleStructItemsNoRange::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-      str += \"\\n  \" + pattern->as_string ();\n+    str += \"\\n  \" + pattern->as_string ();\n \n   return str;\n }\n@@ -3213,7 +2962,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t  str += \"\\n   \" + lower->as_string ();\n+\tstr += \"\\n   \" + lower->as_string ();\n     }\n \n   str += \"\\n  Upper patterns: \";\n@@ -3224,7 +2973,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t  str += \"\\n   \" + upper->as_string ();\n+\tstr += \"\\n   \" + upper->as_string ();\n     }\n \n   return str;\n@@ -3251,37 +3000,14 @@ LetStmt::as_string () const\n   str += \"\\n\" + indent_spaces (stay) + \"let \" + variables_pattern->as_string ();\n \n   if (has_type ())\n-      str += \" : \" + type->as_string ();\n+    str += \" : \" + type->as_string ();\n \n   if (has_init_expr ())\n-      str += \" = \" + init_expr->as_string ();\n+    str += \" = \" + init_expr->as_string ();\n \n   return str;\n }\n \n-#if 0\n-// Used to get outer attributes for expressions.\n-std::string\n-Expr::as_string () const\n-{\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-\n-  return str;\n-}\n-#endif\n-\n // hopefully definition here will prevent circular dependency issue\n TraitBound *\n TypePath::to_trait_bound (bool in_parens) const\n@@ -3315,7 +3041,7 @@ ImplTraitType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t  str += \"\\n  \" + bound->as_string ();\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   return str;\n@@ -3328,10 +3054,10 @@ ReferenceType::as_string () const\n   std::string str (\"&\");\n \n   if (has_lifetime ())\n-      str += lifetime.as_string () + \" \";\n+    str += lifetime.as_string () + \" \";\n \n   if (has_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   str += type->as_string ();\n \n@@ -3367,9 +3093,9 @@ TraitObjectType::as_string () const\n   std::string str (\"TraitObjectType: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n TypeParamBounds: \";\n   if (type_param_bounds.empty ())\n@@ -3379,7 +3105,7 @@ TraitObjectType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t  str += \"\\n  \" + bound->as_string ();\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   return str;\n@@ -3397,7 +3123,7 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t  str += \"\\n  \" + for_lifetime.as_string ();\n+\tstr += \"\\n  \" + for_lifetime.as_string ();\n     }\n \n   str += \"\\n Qualifiers: \" + function_qualifiers.as_string ();\n@@ -3410,20 +3136,20 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t  str += \"\\n  \" + param.as_string ();\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   str += \"\\n Is variadic: \";\n   if (is_variadic)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n Return type: \";\n   if (!has_return_type ())\n-      str += \"none (void)\";\n+    str += \"none (void)\";\n   else\n-      str += return_type->as_string ();\n+    str += return_type->as_string ();\n \n   return str;\n }\n@@ -3449,9 +3175,9 @@ TraitObjectTypeOneBound::as_string () const\n   std::string str (\"TraitObjectTypeOneBound: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n TraitBound: \" + trait_bound.as_string ();\n \n@@ -3480,7 +3206,7 @@ TypePathFunction::as_string () const\n   str += \")\";\n \n   if (has_return_type ())\n-      str += \" -> \" + return_type->as_string ();\n+    str += \" -> \" + return_type->as_string ();\n \n   return str;\n }\n@@ -3560,7 +3286,7 @@ StructExprTuple::as_string () const\n \n       // debug - null pointer check\n       if (*i == nullptr)\n-\t  return \"ERROR_MARK_STRING - nullptr struct expr tuple field\";\n+\treturn \"ERROR_MARK_STRING - nullptr struct expr tuple field\";\n \n       str += '(';\n       for (; i != e; i++)\n@@ -3575,18 +3301,7 @@ StructExprTuple::as_string () const\n   indent_spaces (enter);\n   indent_spaces (enter);\n   // inner attributes\n-  str += \"\\n\" + indent_spaces (stay) + \"inner attributes:\";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n   indent_spaces (out);\n   indent_spaces (out);\n \n@@ -3603,20 +3318,6 @@ StructExprStruct::as_string () const\n \n   // inner attributes\n   str += append_attributes (inner_attrs, INNER);\n-#if 0\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   return str;\n }\n@@ -3723,20 +3424,6 @@ EnumItem::as_string () const\n {\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\n\" + variant_name;\n \n@@ -3778,23 +3465,9 @@ TupleField::as_string () const\n \n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   if (has_visibility ())\n-      str += \"\\n\" + visibility.as_string ();\n+    str += \"\\n\" + visibility.as_string ();\n \n   str += \" \" + field_type->as_string ();\n \n@@ -3835,23 +3508,9 @@ StructField::as_string () const\n   // TODO: rewrite to work with non-linearisable exprs\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   if (has_visibility ())\n-      str += \"\\n\" + visibility.as_string ();\n+    str += \"\\n\" + visibility.as_string ();\n \n   str += \" \" + field_name + \" : \" + field_type->as_string ();\n \n@@ -3870,50 +3529,11 @@ EnumItemDiscriminant::as_string () const\n   return str;\n }\n \n-#if 0\n-std::string\n-ExternalItem::as_string () const\n-{\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-\n-  // start visibility on new line and with a space\n-  str += \"\\n\" + visibility.as_string () + \" \";\n-\n-  return str;\n-}\n-#endif\n-\n std::string\n ExternalStaticItem::as_string () const\n {\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -3937,20 +3557,6 @@ ExternalFunctionItem::as_string () const\n {\n   // outer attributes\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -4028,19 +3634,6 @@ std::string\n NamedFunctionParam::as_string () const\n {\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-\n-  if (!has_outer_attrs ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\n\" + name;\n \n@@ -4049,47 +3642,18 @@ NamedFunctionParam::as_string () const\n   return str;\n }\n \n-/*std::string TraitItem::as_string() const {\n-    // outer attributes\n-    std::string str = \"outer attributes: \";\n-    if (outer_attrs.empty()) {\n-\tstr += \"none\";\n-    } else {\n-\t// note that this does not print them with \"outer attribute\" syntax -\n-just the body for (const auto& attr : outer_attrs) { str += \"\\n  \" +\n-attr.as_string();\n-\t}\n-    }\n-\n-    return str;\n-}*/\n-\n std::string\n TraitItemFunc::as_string () const\n {\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-      str += block_expr->as_string ();\n+    str += block_expr->as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -4127,7 +3691,7 @@ TraitFunctionDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t  str += \"\\n  \" + param.as_string ();\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n   else\n     {\n@@ -4136,15 +3700,15 @@ TraitFunctionDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-      str += return_type->as_string ();\n+    str += return_type->as_string ();\n   else\n-      str += \"none (void)\";\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -4153,28 +3717,14 @@ std::string\n TraitItemMethod::as_string () const\n {\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-      str += block_expr->as_string ();\n+    str += block_expr->as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -4214,7 +3764,7 @@ TraitMethodDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t  str += \"\\n  \" + param.as_string ();\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n   else\n     {\n@@ -4223,15 +3773,15 @@ TraitMethodDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-      str += return_type->as_string ();\n+    str += return_type->as_string ();\n   else\n-      str += \"none (void)\";\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -4241,25 +3791,11 @@ TraitItemConst::as_string () const\n {\n   // TODO: rewrite to work with non-linearisable exprs\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\nconst \" + name + \" : \" + type->as_string ();\n \n   if (has_expression ())\n-      str += \" = \" + expr->as_string ();\n+    str += \" = \" + expr->as_string ();\n \n   return str;\n }\n@@ -4268,20 +3804,6 @@ std::string\n TraitItemType::as_string () const\n {\n   std::string str = append_attributes (outer_attrs, OUTER);\n-#if 0\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-#endif\n \n   str += \"\\ntype \" + name;\n \n@@ -4327,7 +3849,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t      str += \"mut \";\n+\t    str += \"mut \";\n \n \t  str += \"self : \";\n \n@@ -4341,7 +3863,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\" + lifetime.as_string () + \" \";\n \n \t  if (is_mut)\n-\t      str += \"mut \";\n+\t    str += \"mut \";\n \n \t  str += \"self\";\n \n@@ -4353,7 +3875,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\";\n \n \t  if (is_mut)\n-\t      str += \" mut \";\n+\t    str += \" mut \";\n \n \t  str += \"self\";\n \n@@ -4365,7 +3887,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t      str += \"mut \";\n+\t    str += \"mut \";\n \n \t  str += \"self\";\n \n@@ -4391,7 +3913,7 @@ LifetimeWhereClauseItem::as_string () const\n   str += \"\\nLifetime bounds: \";\n \n   for (const auto &bound : lifetime_bounds)\n-      str += \"\\n \" + bound.as_string ();\n+    str += \"\\n \" + bound.as_string ();\n \n   return str;\n }\n@@ -4408,7 +3930,7 @@ TypeBoundWhereClauseItem::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t  str += \"\\n \" + for_lifetime.as_string ();\n+\tstr += \"\\n \" + for_lifetime.as_string ();\n     }\n \n   str += \"\\nType: \" + bound_type->as_string ();\n@@ -4419,7 +3941,7 @@ TypeBoundWhereClauseItem::as_string () const\n     {\n       // debug null pointer check\n       if (bound == nullptr)\n-\t  return \"NULL_POINTER_MARK - type param bounds\";\n+\treturn \"NULL_POINTER_MARK - type param bounds\";\n \n       str += \"\\n \" + bound->as_string ();\n     }\n@@ -4649,8 +4171,8 @@ MacroParser::parse_meta_item_inner ()\n \n \t  skip_token (2);\n \n-    // remove the quotes from the string value\n-    std::string raw_value = unquote_string (std::move (value));\n+\t  // remove the quotes from the string value\n+\t  std::string raw_value = unquote_string (std::move (value));\n \n \t  return std::unique_ptr<MetaNameValueStr> (\n \t    new MetaNameValueStr (std::move (ident), std::move (raw_value)));\n@@ -4829,7 +4351,7 @@ MacroParser::parse_meta_item_seq ()\n       meta_items.push_back (std::move (inner));\n \n       if (peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       skip_token ();\n     }\n@@ -5006,7 +4528,10 @@ AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n     return false;\n \n   // DEBUG\n-  fprintf (stderr, \"asked to check cfg of attrinputmetaitemcontainer - delegating to first item. container: '%s'\\n\", as_string ().c_str ());\n+  fprintf (stderr,\n+\t   \"asked to check cfg of attrinputmetaitemcontainer - delegating to \"\n+\t   \"first item. container: '%s'\\n\",\n+\t   as_string ().c_str ());\n \n   return items[0]->check_cfg_predicate (session);\n \n@@ -5208,7 +4733,12 @@ bool\n MetaNameValueStr::check_cfg_predicate (const Session &session) const\n {\n   // DEBUG\n-  fprintf (stderr, \"checked key-value pair for cfg: '%s', '%s' - is%s in target data\\n\", ident.c_str (), str.c_str (), session.options.target_data.has_key_value_pair (ident, str) ? \"\" : \" not\");\n+  fprintf (stderr,\n+\t   \"checked key-value pair for cfg: '%s', '%s' - is%s in target data\\n\",\n+\t   ident.c_str (), str.c_str (),\n+\t   session.options.target_data.has_key_value_pair (ident, str)\n+\t     ? \"\"\n+\t     : \" not\");\n \n   return session.options.target_data.has_key_value_pair (ident, str);\n }\n@@ -5340,11 +4870,15 @@ Attribute::check_cfg_predicate (const Session &session) const\n   /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n    * cfg_attr path */\n   if (!has_attr_input ()\n-      || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\")) {\n-        // DEBUG message\n-        fprintf (stderr, \"tried to check cfg predicate on attr that either has no input or invalid path. attr: '%s'\\n\", as_string ().c_str ());\n+      || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n+    {\n+      // DEBUG message\n+      fprintf (stderr,\n+\t       \"tried to check cfg predicate on attr that either has no input \"\n+\t       \"or invalid path. attr: '%s'\\n\",\n+\t       as_string ().c_str ());\n \n-    return false;\n+      return false;\n     }\n \n   // assume that it has already been parsed\n@@ -5833,18 +5367,6 @@ IfLetExprConseqIfLet::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-/*void\n-MatchCaseBlockExpr::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MatchCaseExpr::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}*/\n-\n void\n MatchExpr::accept_vis (ASTVisitor &vis)\n {"}, {"sha": "b80e7a3d3f692648dddd0f200ecd47bb6672381a", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -220,7 +220,10 @@ class Token : public TokenTree, public MacroMatch\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  Token *clone_token_tree_impl () const final override { return clone_token_impl (); }\n+  Token *clone_token_tree_impl () const final override\n+  {\n+    return clone_token_impl ();\n+  }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -823,8 +826,6 @@ class Item : public Stmt\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  std::string as_string () const = 0;\n-\n   /* Adds crate names to the vector passed by reference, if it can\n    * (polymorphism). TODO: remove, unused. */\n   virtual void\n@@ -885,8 +886,7 @@ class Expr\n \n protected:\n   // Constructor\n-  Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ())\n-  {}\n+  Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n@@ -941,8 +941,10 @@ class IdentifierExpr : public ExprWithoutBlock\n   Location locus;\n \n public:\n-  IdentifierExpr (Identifier ident, std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), ident (std::move (ident)), locus (locus)\n+  IdentifierExpr (Identifier ident, std::vector<Attribute> outer_attrs,\n+\t\t  Location locus)\n+    : outer_attrs (std::move (outer_attrs)), ident (std::move (ident)),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override { return ident; }\n@@ -967,7 +969,10 @@ class IdentifierExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   // Clone method implementation\n@@ -1670,7 +1675,8 @@ struct Crate\n \n // Base path expression AST node - abstract\n class PathExpr : public ExprWithoutBlock\n-{};\n+{\n+};\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "29a1cf1e8ef779a9ea6199ea0a75b80c5fddd743", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 44, "deletions": 132, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -316,7 +316,7 @@ class MacroRulesDefinition : public MacroItem\n \n   Location locus;\n \n-  /* NOTE: in rustc, macro definitions are considered (and parsed as) a type \n+  /* NOTE: in rustc, macro definitions are considered (and parsed as) a type\n    * of macro, whereas here they are considered part of the language itself.\n    * I am not aware of the implications of this decision. The rustc spec does\n    * mention that using the same parser for macro definitions and invocations\n@@ -395,7 +395,10 @@ class MacroInvocation : public TypeNoBounds,\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -545,7 +548,10 @@ class MetaNameValueStr : public MetaItem\n     : ident (std::move (ident)), str (std::move (str))\n   {}\n \n-  std::string as_string () const override { return ident + \" = \\\"\" + str + \"\\\"\"; }\n+  std::string as_string () const override\n+  {\n+    return ident + \" = \\\"\" + str + \"\\\"\";\n+  }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -626,146 +632,52 @@ class MetaListNameValueStr : public MetaItem\n   }\n };\n \n-/* A \"tagged union\" describing a single AST node. Due to technical difficulties\n- * with unions, this is actually a struct and so wastes space. FIXME */\n-/*\n+/* Should be a tagged union to save space but implemented as struct due to\n+ * technical difficulties. TODO: fix\n+ * Basically, a single AST node used inside an AST fragment. */\n struct SingleASTNode\n {\n-  public:\n-    enum tag_types {\n-      EXPR,\n-      STMT,\n-      ITEM,\n-      TYPE,\n-      PATTERN,\n-      TRAIT_ITEM,\n-      INHERENT_IMPL_ITEM,\n-      TRAIT_IMPL_ITEM,\n-      EXTERNAL_ITEM\n-      // TODO: other types like inside macro_rules? \n-    };\n-\n-    SingleASTNode (std::unique_ptr<Expr> expr) : tag (EXPR), expr (std::move (expr)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<Stmt> stmt) : tag (STMT), stmt (std::move (stmt)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<Item> item) : tag (ITEM), item (std::move (item)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<Type> type) : tag (TYPE), type (std::move (type)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<Pattern> pattern) : tag (PATTERN), pattern (std::move (pattern)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<TraitItem> trait_item) : tag (TRAIT_ITEM), trait_item (std::move (trait_item)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item) : tag (INHERENT_IMPL_ITEM), inherent_impl_item (std::move (inherent_impl_item)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item) : tag (TRAIT_IMPL_ITEM), trait_impl_item (std::move (trait_impl_item)) {\n-\n-    }\n-\n-    SingleASTNode (std::unique_ptr<ExternalItem> external_item) : tag (EXTERNAL_ITEM), external_item (std::move (external_item)) {\n-\n-    }\n-\n-    // destructor definition is required\n-    ~SingleASTNode () {\n-      switch (tag) {\n-        case EXPR:\n-          expr.~unique_ptr<Expr> ();\n-          break;\n-        case STMT:\n-          stmt.~unique_ptr<Stmt> ();\n-          break;\n-        case ITEM:\n-          item.~unique_ptr<Item> ();\n-          break;\n-        case TYPE:\n-          type.~unique_ptr<Type> ();\n-          break;\n-        case PATTERN:\n-          pattern.~unique_ptr<Pattern> ();\n-          break;\n-        case TRAIT_ITEM:\n-          trait_item.~unique_ptr<TraitItem> ();\n-          break;\n-        case INHERENT_IMPL_ITEM:\n-          inherent_impl_item.~unique_ptr<InherentImplItem> ();\n-          break;\n-        case TRAIT_IMPL_ITEM:\n-          trait_impl_item.~unique_ptr<TraitImplItem> ();\n-          break;\n-        case EXTERNAL_ITEM:\n-          external_item.~unique_ptr<ExternalItem> ();\n-          break;\n-        default:\n-          // should not happen\n-          gcc_unreachable ();\n-          break;\n-      }\n-    }\n-\n-  private:\n-    tag_types tag;\n-\n-    union {\n-      std::unique_ptr<Expr> expr;\n-      std::unique_ptr<Stmt> stmt;\n-      std::unique_ptr<Item> item;\n-      std::unique_ptr<Type> type;\n-      std::unique_ptr<Pattern> pattern;\n-      std::unique_ptr<TraitItem> trait_item;\n-      std::unique_ptr<InherentImplItem> inherent_impl_item;\n-      std::unique_ptr<TraitImplItem> trait_impl_item;\n-      std::unique_ptr<ExternalItem> external_item;\n-    };\n-};\n-*/\n-struct SingleASTNode {\n-      std::unique_ptr<Expr> expr;\n-      std::unique_ptr<Stmt> stmt;\n-      std::unique_ptr<Item> item;\n-      std::unique_ptr<Type> type;\n-      std::unique_ptr<Pattern> pattern;\n-      std::unique_ptr<TraitItem> trait_item;\n-      std::unique_ptr<InherentImplItem> inherent_impl_item;\n-      std::unique_ptr<TraitImplItem> trait_impl_item;\n-      std::unique_ptr<ExternalItem> external_item;\n-\n-    SingleASTNode (std::unique_ptr<Expr> expr) : expr (std::move (expr)) {}\n-    SingleASTNode (std::unique_ptr<Stmt> stmt) : stmt (std::move (stmt)) {}\n-    SingleASTNode (std::unique_ptr<Item> item) : item (std::move (item)) {}\n-    SingleASTNode (std::unique_ptr<Type> type) : type (std::move (type)) {}\n-    SingleASTNode (std::unique_ptr<Pattern> pattern) : pattern (std::move (pattern)) {}\n-    SingleASTNode (std::unique_ptr<TraitItem> trait_item) : trait_item (std::move (trait_item)) {}\n-    SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item) : inherent_impl_item (std::move (inherent_impl_item)) {}\n-    SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item) : trait_impl_item (std::move (trait_impl_item)) {}\n-    SingleASTNode (std::unique_ptr<ExternalItem> external_item) : external_item (std::move (external_item)) {}\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Stmt> stmt;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Type> type;\n+  std::unique_ptr<Pattern> pattern;\n+  std::unique_ptr<TraitItem> trait_item;\n+  std::unique_ptr<InherentImplItem> inherent_impl_item;\n+  std::unique_ptr<TraitImplItem> trait_impl_item;\n+  std::unique_ptr<ExternalItem> external_item;\n+\n+  SingleASTNode (std::unique_ptr<Expr> expr) : expr (std::move (expr)) {}\n+  SingleASTNode (std::unique_ptr<Stmt> stmt) : stmt (std::move (stmt)) {}\n+  SingleASTNode (std::unique_ptr<Item> item) : item (std::move (item)) {}\n+  SingleASTNode (std::unique_ptr<Type> type) : type (std::move (type)) {}\n+  SingleASTNode (std::unique_ptr<Pattern> pattern)\n+    : pattern (std::move (pattern))\n+  {}\n+  SingleASTNode (std::unique_ptr<TraitItem> trait_item)\n+    : trait_item (std::move (trait_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item)\n+    : inherent_impl_item (std::move (inherent_impl_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n+    : trait_impl_item (std::move (trait_impl_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<ExternalItem> external_item)\n+    : external_item (std::move (external_item))\n+  {}\n };\n \n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as \n- * a result of macro expansion. Really annoying to work with due to the fact \n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n  * that macros can really expand to anything. As such, horrible representation\n  * at the moment. */\n struct ASTFragment\n {\n private:\n   /* basic idea: essentially, a vector of tagged unions of different AST node\n    * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create \n+   * different AST node types had a unified parent, but that would create\n    * issues with the diamond problem or significant performance penalties. So\n    * a tagged union had to be used instead. A vector is used to represent the\n    * ability for a macro to expand to two statements, for instance. */"}, {"sha": "b2a0bb5b0081dd2fbf122b42423e07739d564fb2", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -18,7 +18,6 @@\n \n #include \"rust-macro-expand.h\"\n #include \"rust-ast-full.h\"\n-// is full really required?\n #include \"rust-ast-visitor.h\"\n #include \"rust-diagnostics.h\"\n \n@@ -1529,7 +1528,8 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExpr &expr) override\n   {\n-    // rust playground test shows that IfExpr does support outer attrs, at least when used as statement\n+    // rust playground test shows that IfExpr does support outer attrs, at least\n+    // when used as statement\n \n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n@@ -1667,7 +1667,7 @@ class AttrVisitor : public AST::ASTVisitor\n \texpr.mark_for_strip ();\n \treturn;\n       }\n-    \n+\n     for (auto &pattern : expr.get_patterns ())\n       {\n \tpattern->accept_vis (*this);\n@@ -3183,36 +3183,48 @@ MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n     return AST::Literal (\"false\", AST::Literal::BOOL, CORETYPE_BOOL);\n }\n \n-AST::ASTFragment \n-MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc, AST::MacroRulesDefinition &rules_def) {\n+AST::ASTFragment\n+MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n+\t\t\t\t  AST::MacroRulesDefinition &rules_def)\n+{\n   // ensure that both invocation and rules are in a valid state\n   rust_assert (!invoc.is_marked_for_strip ());\n   rust_assert (!rules_def.is_marked_for_strip ());\n   rust_assert (rules_def.get_macro_rules ().size () > 0);\n \n-  /* probably something here about parsing invoc and rules def token trees to token stream. if not, \n-   * how would parser handle the captures of exprs and stuff? on the other hand, token trees may be\n-   * kind of useful in rules def as creating a point where recursion can occur (like having \n-   * \"compare_macro_match\" and then it calling itself when it finds delimiters) */\n-\n-  /* find matching rule to invoc token tree, based on macro rule's matcher. if none exist, error. \n-   * - specifically, check each matcher in order. if one fails to match, move onto next. */\n-  /* TODO: does doing this require parsing expressions and whatever in the invoc? if so, might as \n-   * well save the results if referenced using $ or whatever. If not, do another pass saving them. \n-   * Except this is probably useless as different rules could have different starting points for exprs\n-   * or whatever. Decision trees could avoid this, but they have their own issues. */\n-  /* TODO: will need to modify the parser so that it can essentially \"catch\" errors - maybe \n-   * \"try_parse_expr\" or whatever methods. */\n-  // this technically creates a back-tracking parser - this will be the implementation style\n-\n-  /* then, after results are saved, generate the macro output from the transcriber token tree. if i\n-   * understand this correctly, the macro invocation gets replaced by the transcriber tokens, except\n-   * with substitutions made (e.g. for $i variables) */\n-\n-  /* TODO: it is probably better to modify AST::Token to store a pointer to a Lexer::Token (rather \n-   * than being converted) - i.e. not so much have AST::Token as a Token but rather a TokenContainer\n-   * (as it is another type of TokenTree). This will prevent re-conversion of Tokens between each type\n-   * all the time, while still allowing the heterogenous storage of token trees.  */\n+  /* probably something here about parsing invoc and rules def token trees to\n+   * token stream. if not, how would parser handle the captures of exprs and\n+   * stuff? on the other hand, token trees may be kind of useful in rules def as\n+   * creating a point where recursion can occur (like having\n+   * \"compare_macro_match\" and then it calling itself when it finds delimiters)\n+   */\n+\n+  /* find matching rule to invoc token tree, based on macro rule's matcher. if\n+   * none exist, error.\n+   * - specifically, check each matcher in order. if one fails to match, move\n+   * onto next. */\n+  /* TODO: does doing this require parsing expressions and whatever in the\n+   * invoc? if so, might as well save the results if referenced using $ or\n+   * whatever. If not, do another pass saving them. Except this is probably\n+   * useless as different rules could have different starting points for exprs\n+   * or whatever. Decision trees could avoid this, but they have their own\n+   * issues. */\n+  /* TODO: will need to modify the parser so that it can essentially \"catch\"\n+   * errors - maybe \"try_parse_expr\" or whatever methods. */\n+  // this technically creates a back-tracking parser - this will be the\n+  // implementation style\n+\n+  /* then, after results are saved, generate the macro output from the\n+   * transcriber token tree. if i understand this correctly, the macro\n+   * invocation gets replaced by the transcriber tokens, except with\n+   * substitutions made (e.g. for $i variables) */\n+\n+  /* TODO: it is probably better to modify AST::Token to store a pointer to a\n+   * Lexer::Token (rather than being converted) - i.e. not so much have\n+   * AST::Token as a Token but rather a TokenContainer (as it is another type of\n+   * TokenTree). This will prevent re-conversion of Tokens between each type\n+   * all the time, while still allowing the heterogenous storage of token trees.\n+   */\n }\n \n void\n@@ -3275,29 +3287,40 @@ MacroExpander::fails_cfg (const std::vector<AST::Attribute> &attrs) const\n bool\n MacroExpander::fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const\n {\n+  // TODO: maybe have something that strips cfg attributes that evaluate true?\n   for (auto &attr : attrs)\n     {\n       if (attr.get_path () == \"cfg\")\n \t{\n \t  if (!attr.is_parsed_to_meta_item ())\n \t    attr.parse_attr_to_meta_item ();\n \n-    // DEBUG\n-    if (!attr.is_parsed_to_meta_item ())\n-      fprintf (stderr, \"failed to parse attr to meta item, right before cfg predicate check\\n\");\n-    else\n-      fprintf(stderr, \"attr has been successfully parsed to meta item, right before cfg predicate check\\n\");\n+\t  // DEBUG\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    fprintf (stderr, \"failed to parse attr to meta item, right before \"\n+\t\t\t     \"cfg predicate check\\n\");\n+\t  else\n+\t    fprintf (stderr, \"attr has been successfully parsed to meta item, \"\n+\t\t\t     \"right before cfg predicate check\\n\");\n \n \t  if (!attr.check_cfg_predicate (session))\n-    {\n-      // DEBUG\n-      fprintf (stderr, \"cfg predicate failed for attribute: \\033[0;31m'%s'\\033[0m\\n\", attr.as_string ().c_str ());\n+\t    {\n+\t      // DEBUG\n+\t      fprintf (\n+\t\tstderr,\n+\t\t\"cfg predicate failed for attribute: \\033[0;31m'%s'\\033[0m\\n\",\n+\t\tattr.as_string ().c_str ());\n \n-\t    return true;\n-    } else {\n-      // DEBUG\n-      fprintf (stderr, \"cfg predicate succeeded for attribute: \\033[0;31m'%s'\\033[0m\\n\", attr.as_string ().c_str ());\n-    }\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      // DEBUG\n+\t      fprintf (stderr,\n+\t\t       \"cfg predicate succeeded for attribute: \"\n+\t\t       \"\\033[0;31m'%s'\\033[0m\\n\",\n+\t\t       attr.as_string ().c_str ());\n+\t    }\n \t}\n     }\n   return false;"}, {"sha": "2e9b88bde27412ee7a6f0ec0c88e93ab83073a4d", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -60,8 +60,9 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n-  // Expands a single declarative macro. \n-  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc, AST::MacroRulesDefinition &rules_def);\n+  // Expands a single declarative macro.\n+  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc,\n+\t\t\t\t      AST::MacroRulesDefinition &rules_def);\n \n   void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n   bool fails_cfg (const std::vector<AST::Attribute> &attr) const;"}, {"sha": "cc30f1bacb51f56ddb5c3fa62c4fa8bdb4d8b8c1", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -789,8 +789,8 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \t  }\n \n \t// create actual LiteralExpr\n-\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (), {},\n-\t\t\t\t   t->get_locus ());\n+\tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (),\n+\t\t\t\t   {}, t->get_locus ());\n \n \tstd::unique_ptr<AST::AttrInputLiteral> attr_input_lit (\n \t  new AST::AttrInputLiteral (std::move (lit_expr)));\n@@ -1554,8 +1554,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n       t = lexer.peek_token ();\n     }\n-  \n-  AST::DelimTokenTree delim_tok_tree (delim_type, std::move (token_trees), tok_tree_locus);\n+\n+  AST::DelimTokenTree delim_tok_tree (delim_type, std::move (token_trees),\n+\t\t\t\t      tok_tree_locus);\n   AST::MacroInvocData invoc_data (std::move (path), std::move (delim_tok_tree));\n \n   // parse end delimiters\n@@ -1572,7 +1573,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \t      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\t\tnew AST::MacroInvocationSemi (std::move (invoc_data), \n+\t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t      std::move (outer_attrs),\n \t\t\t\t\t      macro_locus));\n \t    }\n@@ -1585,7 +1586,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t       lexer.peek_token ()->get_token_description ());\n \n       return std::unique_ptr<AST::MacroInvocationSemi> (\n-\tnew AST::MacroInvocationSemi (std::move (invoc_data), \n+\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t      std::move (outer_attrs), macro_locus));\n     }\n   else\n@@ -1634,7 +1635,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation (\n \n   return std::unique_ptr<AST::MacroInvocation> (\n     new AST::MacroInvocation (AST::MacroInvocData (std::move (macro_path),\n-\t\t\t      std::move (delim_tok_tree)),\n+\t\t\t\t\t\t   std::move (delim_tok_tree)),\n \t\t\t      std::move (outer_attrs), macro_locus));\n }\n \n@@ -7373,7 +7374,8 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n   // create literal based on stuff in switch\n   return std::unique_ptr<AST::LiteralExpr> (\n     new AST::LiteralExpr (std::move (literal_value), std::move (type),\n-\t\t\t  t->get_type_hint (), std::move (outer_attrs), t->get_locus ()));\n+\t\t\t  t->get_type_hint (), std::move (outer_attrs),\n+\t\t\t  t->get_locus ()));\n }\n \n // Parses a return expression (including any expression to return).\n@@ -7401,8 +7403,8 @@ Parser<ManagedTokenSource>::parse_return_expr (\n   // FIXME: ensure this doesn't ruin the middle of any expressions or anything\n \n   return std::unique_ptr<AST::ReturnExpr> (\n-    new AST::ReturnExpr (std::move (returned_expr),\n-\t\t\t std::move (outer_attrs), locus));\n+    new AST::ReturnExpr (std::move (returned_expr), std::move (outer_attrs),\n+\t\t\t locus));\n }\n \n /* Parses a break expression (including any label to break to AND any return\n@@ -7522,8 +7524,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n    * parsed */\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n-  std::unique_ptr<AST::Expr> condition\n-    = parse_expr ({}, no_struct_expr);\n+  std::unique_ptr<AST::Expr> condition = parse_expr ({}, no_struct_expr);\n   if (condition == nullptr)\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n@@ -7548,7 +7549,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n     {\n       // single selection - end of if expression\n       return std::unique_ptr<AST::IfExpr> (\n-\tnew AST::IfExpr (std::move (condition), std::move (if_body), std::move (outer_attrs), locus));\n+\tnew AST::IfExpr (std::move (condition), std::move (if_body),\n+\t\t\t std::move (outer_attrs), locus));\n     }\n   else\n     {\n@@ -7577,7 +7579,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t    return std::unique_ptr<AST::IfExprConseqElse> (\n \t      new AST::IfExprConseqElse (std::move (condition),\n \t\t\t\t\t std::move (if_body),\n-\t\t\t\t\t std::move (else_body), std::move (outer_attrs), locus));\n+\t\t\t\t\t std::move (else_body),\n+\t\t\t\t\t std::move (outer_attrs), locus));\n \t  }\n \t  case IF: {\n \t    // multiple selection - else if or else if let\n@@ -7599,7 +7602,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t\treturn std::unique_ptr<AST::IfExprConseqIfLet> (\n \t\t  new AST::IfExprConseqIfLet (std::move (condition),\n \t\t\t\t\t      std::move (if_body),\n-\t\t\t\t\t      std::move (if_let_expr), std::move (outer_attrs), locus));\n+\t\t\t\t\t      std::move (if_let_expr),\n+\t\t\t\t\t      std::move (outer_attrs), locus));\n \t      }\n \t    else\n \t      {\n@@ -7617,7 +7621,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t\treturn std::unique_ptr<AST::IfExprConseqIf> (\n \t\t  new AST::IfExprConseqIf (std::move (condition),\n \t\t\t\t\t   std::move (if_body),\n-\t\t\t\t\t   std::move (if_expr), std::move (outer_attrs), locus));\n+\t\t\t\t\t   std::move (if_expr),\n+\t\t\t\t\t   std::move (outer_attrs), locus));\n \t      }\n \t  }\n \tdefault:\n@@ -7674,8 +7679,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n   // parse expression (required) - HACK to prevent struct expr being parsed\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n-  std::unique_ptr<AST::Expr> scrutinee_expr\n-    = parse_expr ({}, no_struct_expr);\n+  std::unique_ptr<AST::Expr> scrutinee_expr = parse_expr ({}, no_struct_expr);\n   if (scrutinee_expr == nullptr)\n     {\n       rust_error_at (\n@@ -7735,7 +7739,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t      new AST::IfLetExprConseqElse (std::move (match_arm_patterns),\n \t\t\t\t\t    std::move (scrutinee_expr),\n \t\t\t\t\t    std::move (if_let_body),\n-\t\t\t\t\t    std::move (else_body), std::move (outer_attrs), locus));\n+\t\t\t\t\t    std::move (else_body),\n+\t\t\t\t\t    std::move (outer_attrs), locus));\n \t  }\n \t  case IF: {\n \t    // multiple selection - else if or else if let\n@@ -7757,7 +7762,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t\treturn std::unique_ptr<AST::IfLetExprConseqIfLet> (\n \t\t  new AST::IfLetExprConseqIfLet (\n \t\t    std::move (match_arm_patterns), std::move (scrutinee_expr),\n-\t\t    std::move (if_let_body), std::move (if_let_expr), std::move (outer_attrs), locus));\n+\t\t    std::move (if_let_body), std::move (if_let_expr),\n+\t\t    std::move (outer_attrs), locus));\n \t      }\n \t    else\n \t      {\n@@ -7776,7 +7782,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t\t  new AST::IfLetExprConseqIf (std::move (match_arm_patterns),\n \t\t\t\t\t      std::move (scrutinee_expr),\n \t\t\t\t\t      std::move (if_let_body),\n-\t\t\t\t\t      std::move (if_expr), std::move (outer_attrs), locus));\n+\t\t\t\t\t      std::move (if_expr),\n+\t\t\t\t\t      std::move (outer_attrs), locus));\n \t      }\n \t  }\n \tdefault:\n@@ -8837,8 +8844,10 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n \t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (AST::MacroInvocData (std::move (macro_path),\n-\t\t\t\t\t  std::move (tok_tree)), {}, locus));\n+\t\tnew AST::MacroInvocation (\n+\t\t  AST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t       std::move (tok_tree)),\n+\t\t  {}, locus));\n \t    }\n \t    case PLUS: {\n \t      // type param bounds\n@@ -9638,8 +9647,10 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n \t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (AST::MacroInvocData (std::move (macro_path),\n-\t\t\t\t\t  std::move (tok_tree)), {}, locus));\n+\t\tnew AST::MacroInvocation (\n+\t\t  AST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t       std::move (tok_tree)),\n+\t\t  {}, locus));\n \t    }\n \t    case PLUS: {\n \t      // type param bounds - not allowed, here for error message\n@@ -11411,9 +11422,10 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t     * fixed up via HACKs in semantic analysis (by checking whether it\n \t     * is the last elem in the vector). */\n \n-      AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n+\t    AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n \t\t\t\t\t\ttok_tree_loc);\n-      AST::MacroInvocData invoc_data (std::move (macro_path), std::move (delim_tok_tree));\n+\t    AST::MacroInvocData invoc_data (std::move (macro_path),\n+\t\t\t\t\t    std::move (delim_tok_tree));\n \n \t    if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t      {\n@@ -11436,13 +11448,12 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \telse\n \t  {\n \t    // tokens don't match opening delimiters, so produce error\n-\t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unexpected token %qs - expecting closing delimiter %qs (for a \"\n-\t\t\t   \"macro invocation)\",\n-\t\t\t   t2->get_token_description (),\n-\t\t\t   (type == AST::PARENS\n-\t\t\t      ? \")\"\n-\t\t\t      : (type == AST::SQUARE ? \"]\" : \"}\")));\n+\t    rust_error_at (\n+\t      t2->get_locus (),\n+\t      \"unexpected token %qs - expecting closing delimiter %qs (for a \"\n+\t      \"macro invocation)\",\n+\t      t2->get_token_description (),\n+\t      (type == AST::PARENS ? \")\" : (type == AST::SQUARE ? \"]\" : \"}\")));\n \t    return ExprOrStmt::create_error ();\n \t  }\n       }\n@@ -11711,14 +11722,15 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \n       AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n \t\t\t\t\t  tok_tree_loc);\n-      AST::MacroInvocData invoc_data (std::move (macro_path), std::move (delim_tok_tree));\n+      AST::MacroInvocData invoc_data (std::move (macro_path),\n+\t\t\t\t      std::move (delim_tok_tree));\n \n       if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t{\n \t  lexer.skip_token ();\n \n \t  std::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t    new AST::MacroInvocationSemi (std::move (invoc_data), \n+\t    new AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t  std::move (outer_attrs),\n \t\t\t\t\t  macro_locus));\n \t  return ExprOrStmt (std::move (stmt));\n@@ -12078,7 +12090,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t/* HACK: may have to become permanent, but this is my current\n \t\t * identifier expression */\n \t\treturn std::unique_ptr<AST::IdentifierExpr> (\n-\t\t  new AST::IdentifierExpr (tok->get_str (), {}, tok->get_locus ()));\n+\t\t  new AST::IdentifierExpr (tok->get_str (), {},\n+\t\t\t\t\t   tok->get_locus ()));\n \t      }\n \t    // HACK: add outer attrs to path\n \t    path.set_outer_attrs (std::move (outer_attrs));\n@@ -12100,7 +12113,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \treturn std::unique_ptr<AST::QualifiedPathInExpression> (\n \t  new AST::QualifiedPathInExpression (std::move (path)));\n       }\n-    // FIXME: for literal exprs, should outer attrs be passed in or just ignored?\n+    // FIXME: for literal exprs, should outer attrs be passed in or just\n+    // ignored?\n     case INT_LITERAL:\n       // we should check the range, but ignore for now\n       // encode as int?\n@@ -12162,8 +12176,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_MINUS, {},\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_MINUS, {}, entered_from_unary);\n \n \tif (expr == nullptr)\n \t  return nullptr;\n@@ -12187,8 +12200,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_EXCLAM, {},\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_EXCLAM, {}, entered_from_unary);\n \n \tif (expr == nullptr)\n \t  return nullptr;\n@@ -12214,8 +12226,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tentered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_ASTERISK, {},\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_ASTERISK, {}, entered_from_unary);\n \t// FIXME: allow outer attributes on expression\n \treturn std::unique_ptr<AST::DereferenceExpr> (\n \t  new AST::DereferenceExpr (std::move (expr), std::move (outer_attrs),\n@@ -12235,15 +12246,12 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (lexer.peek_token ()->get_id () == MUT)\n \t  {\n \t    lexer.skip_token ();\n-\t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, {},\n-\t\t\t    entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP_MUT, {}, entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, {},\n-\t\t\t       entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP, {}, entered_from_unary);\n \t  }\n \n \t// FIXME: allow outer attributes on expression\n@@ -12262,15 +12270,12 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (lexer.peek_token ()->get_id () == MUT)\n \t  {\n \t    lexer.skip_token ();\n-\t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, {},\n-\t\t\t    entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP_MUT, {}, entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, {},\n-\t\t\t       entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP, {}, entered_from_unary);\n \t  }\n \n \t// FIXME: allow outer attributes on expression\n@@ -13939,7 +13944,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n   Location macro_locus = converted_path.get_locus ();\n \n   return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (AST::MacroInvocData (std::move (converted_path), std::move (tok_tree)),\n+    new AST::MacroInvocation (AST::MacroInvocData (std::move (converted_path),\n+\t\t\t\t\t\t   std::move (tok_tree)),\n \t\t\t      std::move (outer_attrs), macro_locus));\n }\n \n@@ -14106,7 +14112,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n       exprs.push_back (std::move (expr));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       lexer.skip_token ();\n \n@@ -14233,7 +14239,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n     \"current token (just about to return path to null denotation): '%s'\\n\",\n     lexer.peek_token ()->get_token_description ());\n \n-  return AST::PathInExpression (std::move (segments), {}, tok->get_locus (), false);\n+  return AST::PathInExpression (std::move (segments), {}, tok->get_locus (),\n+\t\t\t\tfalse);\n }\n \n // Parses a closure expression with pratt parsing (from null denotation)."}, {"sha": "2d15a597da151be9169a3050ecf404793585e12d", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f97711dce5c48e46a9a64c5517fa6ae10db5e04/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "patch": "@@ -365,7 +365,7 @@ Session::enable_dump (std::string arg)\n \tLocation (),\n \t\"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n \t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n-  \" %<target_options%>, or %<hir%>\");\n+\t\" %<target_options%>, or %<hir%>\");\n       return false;\n     }\n   else if (arg == \"lex\")\n@@ -407,18 +407,20 @@ Session::enable_dump (std::string arg)\n     }\n   else if (arg == \"\")\n     {\n-      rust_error_at (Location (), \"dump option was not given a name. choose \"\n-\t\t\t\t  \"%<lex%>, %<parse%>, %<register_plugins%>, %<injection%>, \"\n-          \"%<expansion%>, %<resolution%>, %<target_options%>, or %<hir%>\");\n+      rust_error_at (\n+\tLocation (),\n+\t\"dump option was not given a name. choose \"\n+\t\"%<lex%>, %<parse%>, %<register_plugins%>, %<injection%>, \"\n+\t\"%<expansion%>, %<resolution%>, %<target_options%>, or %<hir%>\");\n       return false;\n     }\n   else\n     {\n       rust_error_at (\n \tLocation (),\n \t\"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, \"\n-      \"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n-      \" %<target_options%>, or %<hir%>\",\n+\t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n+\t\" %<target_options%>, or %<hir%>\",\n \targ.c_str ());\n       return false;\n     }"}]}