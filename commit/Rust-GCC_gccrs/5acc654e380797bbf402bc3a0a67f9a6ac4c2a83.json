{"sha": "5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjYzY1NGUzODA3OTdiYmY0MDJiYzNhMGE2N2Y5YTZhYzRjMmE4Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-18T18:00:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-18T18:00:36Z"}, "message": "Avoid warning for memset writing over multiple members.\n\nResolves:\nPR middle-end/95667 - unintended warning for memset writing across multiple members\nPR middle-end/92814 - missing -Wstringop-overflow writing into a dynamically allocated flexible array member\n\ngcc/ChangeLog:\n\n\tPR middle-end/95667\n\tPR middle-end/92814\n\t* builtins.c (compute_objsize): Remove call to\n\tcompute_builtin_object_size and instead compute conservative sizes\n\tdirectly here.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/95667\n\tPR middle-end/92814\n\t* gcc.dg/Wstringop-overflow-25.c: Remove xfails.\n\t* gcc.dg/Wstringop-overflow-39.c: New test.", "tree": {"sha": "aa5840bf7987db25de59013cc4e64b6bfb701ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5840bf7987db25de59013cc4e64b6bfb701ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5421fae8b17c7401f3a4ac5b9f414a47f7bda379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5421fae8b17c7401f3a4ac5b9f414a47f7bda379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5421fae8b17c7401f3a4ac5b9f414a47f7bda379"}], "stats": {"total": 174, "additions": 140, "deletions": 34}, "files": [{"sha": "4754602e0ecda13a3a445fbd809921ddb698ccbd", "filename": "gcc/builtins.c", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "patch": "@@ -4009,31 +4009,6 @@ static bool\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t\t bitmap *visited, const vr_values *rvals /* = NULL */)\n {\n-  if (ostype == 0)\n-    {\n-      /* Use BOS only for raw memory functions like memcpy to get\n-\t the size of the largest enclosing object.  */\n-      tree off = NULL_TREE;\n-      unsigned HOST_WIDE_INT size;\n-      if (compute_builtin_object_size (ptr, ostype, &size, &pref->ref, &off))\n-\t{\n-\t  if (off)\n-\t    {\n-\t      offset_int offset = wi::to_offset (off);\n-\t      pref->offrng[0] += offset;\n-\t      pref->offrng[1] += offset;\n-\n-\t      /* compute_builtin_object_size() returns the remaining\n-\t\t size in PTR.  Add the offset to it to get the full\n-\t\t size.  */\n-\t      pref->sizrng[0] = pref->sizrng[1] = size + offset;\n-\t    }\n-\t  else\n-\t    pref->sizrng[0] = pref->sizrng[1] = size;\n-\t  return true;\n-\t}\n-    }\n-\n   const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n   if (addr)\n     ptr = TREE_OPERAND (ptr, 0);\n@@ -4058,18 +4033,28 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n   if (code == COMPONENT_REF)\n     {\n+      tree field = TREE_OPERAND (ptr, 1);\n+\n       if (ostype == 0)\n \t{\n \t  /* For raw memory functions like memcpy bail if the size\n \t     of the enclosing object cannot be determined.  */\n-\t  access_ref tmpref;\n \t  tree ref = TREE_OPERAND (ptr, 0);\n-\t  if (!compute_objsize (ref, ostype, &tmpref, visited, rvals)\n-\t      || !tmpref.ref)\n+\t  if (!compute_objsize (ref, ostype, pref, visited, rvals)\n+\t      || !pref->ref)\n \t    return false;\n+\n+\t  /* Otherwise, use the size of the enclosing object and add\n+\t     the offset of the member to the offset computed so far.  */\n+\t  tree offset = byte_position (field);\n+\t  if (TREE_CODE (offset) != INTEGER_CST)\n+\t    return false;\n+\t  offset_int off = wi::to_offset (offset);\n+\t  pref->offrng[0] += off;\n+\t  pref->offrng[1] += off;\n+\t  return true;\n \t}\n \n-      tree field = TREE_OPERAND (ptr, 1);\n       /* Bail if the reference is to the pointer itself (as opposed\n \t to what it points to).  */\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n@@ -4147,8 +4132,11 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t  orng[0] *= sz;\n \t  orng[1] *= sz;\n \n-\t  if (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t  if (ostype && TREE_CODE (eltype) == ARRAY_TYPE)\n \t    {\n+\t      /* Execpt for the permissive raw memory functions which\n+\t\t use the size of the whole object determined above,\n+\t\t use the size of the referenced array.  */\n \t      pref->sizrng[0] = pref->offrng[0] + orng[0] + sz;\n \t      pref->sizrng[1] = pref->offrng[1] + orng[1] + sz;\n \t    }"}, {"sha": "109a1dd91274f1da946ee374ed5416fe9acf0e1a", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-25.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c?ref=5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "patch": "@@ -370,14 +370,14 @@ NOIPA void test_strcpy_malloc_flexarray (void)\n   size_t r_2_3 = UR (2, 3);\n \n   T (char, S (0), r_0_1);\n-  T (char, S (1), r_0_1);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+  T (char, S (1), r_0_1);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" }\n \n   T (char, S (0), r_1_2);\n   T (char, S (1), r_1_2);\n-  T (char, S (2), r_1_2);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+  T (char, S (2), r_1_2);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" }\n \n   T (char, S (0), r_2_3);\n   T (char, S (2), r_2_3);\n-  T (char, S (3), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n-  T (char, S (9), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+  T (char, S (3), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" }\n+  T (char, S (9), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" }\n }"}, {"sha": "f83646a37217f2f4bc00593c4c6ca3e1e9003cfe", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-39.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acc654e380797bbf402bc3a0a67f9a6ac4c2a83/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-39.c?ref=5acc654e380797bbf402bc3a0a67f9a6ac4c2a83", "patch": "@@ -0,0 +1,118 @@\n+/* PR middle-end/95667 - unintended warning for memset writing across multiple\n+   members\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+extern void sink (void*);\n+\n+struct S1 { char a[3], b[5]; };\n+\n+void warn_strcpy_s1 (void)\n+{\n+  struct S1 *p = __builtin_malloc (sizeof *p);\n+  char s[] = \"1234567\";\n+  __builtin_strcpy (p->a, s);         // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (p);\n+}\n+\n+void nowarn_memset_s1 (void)\n+{\n+  struct S1 *p = __builtin_malloc (sizeof *p);\n+  __builtin_memset (p->a, 0, 8);      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  sink (p);\n+}\n+\n+struct S2 { char a[2], b[2][2], c[3]; };\n+\n+void nowarn_memset_s2 (void)\n+{\n+  struct S2 *p = __builtin_malloc (sizeof *p);\n+\n+  __builtin_memset (p->a, 0, sizeof *p);\n+  sink (p);\n+\n+  __builtin_memset (p->b, 0, 7);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0], 0, 7);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[1], 0, 5);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0][0], 0, 7);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0][1], 0, 6);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[1][0], 0, 5);\n+  sink (p);\n+\n+  __builtin_memset (&p->b[1][1], 0, 4);\n+  sink (p);\n+}\n+\n+void warn_memset_s2 (void)\n+{\n+  const unsigned n = sizeof (struct S2);\n+  struct S2 *p = __builtin_malloc (n);\n+\n+  /* These should trigger -Wstringop-overflow rather than -Warray-bounds\n+     but the main purpose of the test is to verify the absence of warnings\n+     above so the exact warning for these overflwing calls isn't important\n+     here.  */\n+\n+  __builtin_memset (p->a, 0, n + 1);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+\n+  __builtin_memset (p->b, 0, 8);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0], 0, 8);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0][0], 0, 8); // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+\n+  __builtin_memset (&p->b[1], 0, 6);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+\n+  __builtin_memset (&p->b[0][1], 0, 7); // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (p);\n+}\n+\n+void nowarn_vl_struct (unsigned n)\n+{\n+  if (n < 3 || 5 < n)\n+    n = 3;\n+\n+  struct V { char a[3], b[n], c[7]; } v;\n+\n+  __builtin_memset (v.a, 0, 15);\n+  sink (&v);\n+\n+  __builtin_memset (v.b, 0, 12);\n+  sink (&v);\n+\n+  __builtin_memset (v.c, 0, 7);\n+  sink (&v);\n+\n+  __builtin_memset (v.a, 0, 16);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (&v);\n+\n+  __builtin_memset (v.b, 0, 13);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  sink (&v);\n+\n+  /* The &V.C argument is represented as a variable offset from\n+     the beginning of the allocated object and there's no good\n+     way to figure out from its variable offset that it's base\n+     is the C member:\n+       s.1_12 = __builtin_alloca_with_align (prephitmp_24, 8);\n+       _9 = s.1_12 + prephitmp_27;\n+       __builtin_memset (_9, 0, 2);\n+  */\n+\n+  __builtin_memset (v.c, 0, 8);       // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+  sink (&v);\n+}"}]}