{"sha": "e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJiYzViNmMwNGRmODIwMDE3YzQ5N2EyNTc4YmQzYzRjN2I2Yzg5Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-07T18:44:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-07T18:47:48Z"}, "message": "Do not apply scalar storage order to pointer fields\n\nPointer fields (and vector fields originally) were not really considered\nwhen the scalar_storage_order attribute, so they are swapped as well.\nAs pointed out, this is problematic to describe in DWARF and probably\nnot very useful in any case, so this pulls them out.\n\ngcc/\n\t* doc/extend.texi (scalar_storage_order): Mention effect on pointer\n\tand vector fields.\n\t* tree.h (reverse_storage_order_for_component_p): Return false if\n\tthe type is a pointer.\ngcc/c/\n\t* c-typeck.c (build_unary_op) <ADDR_EXPR>: Do not issue an error\n\ton the address of a pointer field in a record with reverse SSO.\ngcc/testsuite/\n\t* gcc.dg/sso-12.c: New test.", "tree": {"sha": "73027313566ab3c2f1d9fb5e60bbce6177735b14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73027313566ab3c2f1d9fb5e60bbce6177735b14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/comments", "author": null, "committer": null, "parents": [{"sha": "7af392687952608b988bd5a476583106b3f51740", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7af392687952608b988bd5a476583106b3f51740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7af392687952608b988bd5a476583106b3f51740"}], "stats": {"total": 35, "additions": 34, "deletions": 1}, "files": [{"sha": "5bdc673d03a8eb2c4ead56a7100fc185915cea8e", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "patch": "@@ -4866,6 +4866,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t  if (TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (arg, 0))))\n \t    {\n \t      if (!AGGREGATE_TYPE_P (TREE_TYPE (arg))\n+\t\t  && !POINTER_TYPE_P (TREE_TYPE (arg))\n \t\t  && !VECTOR_TYPE_P (TREE_TYPE (arg)))\n \t\t{\n \t\t  error_at (location, \"cannot take address of scalar with \""}, {"sha": "fd9175d1b3bb2ab4987d2089cb289fddd4cad2ae", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "patch": "@@ -8551,6 +8551,9 @@ or an array whose component is a @code{union} or a @code{struct}, and it is\n possible for these fields to have a different scalar storage order than the\n enclosing type.\n \n+Note that neither pointer nor vector fields are considered scalar fields in\n+this context, so the attribute has no effects on these fields.\n+\n This attribute is supported only for targets that use a uniform default\n scalar storage order (fortunately, most of them), i.e.@: targets that store\n the scalars either all in big-endian or all in little-endian."}, {"sha": "3bed280e1734a0b83771adc16c58620f642d12ac", "filename": "gcc/testsuite/gcc.dg/sso-12.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-12.c?ref=e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "patch": "@@ -0,0 +1,27 @@\n+/* Test scalar_storage_order attribute and pointer fields */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-Wno-pedantic\" } */\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) Rec\n+{\n+  int *p;\n+};\n+#else\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) Rec\n+{\n+  int *p;\n+};\n+#endif\n+\n+int main (int argc)\n+{\n+  struct Rec r = { &argc };\n+  int *p = &argc;\n+\n+  if (__builtin_memcmp (&r.p, &p, sizeof (int *)) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "784452ca490e96cff0db9e94162952a736134214", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bc5b6c04df820017c497a2578bd3c4c7b6c89b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e2bc5b6c04df820017c497a2578bd3c4c7b6c89b", "patch": "@@ -4989,7 +4989,9 @@ static inline bool\n reverse_storage_order_for_component_p (tree t)\n {\n   /* The storage order only applies to scalar components.  */\n-  if (AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t)))\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n+      || POINTER_TYPE_P (TREE_TYPE (t))\n+      || VECTOR_TYPE_P (TREE_TYPE (t)))\n     return false;\n \n   if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)"}]}