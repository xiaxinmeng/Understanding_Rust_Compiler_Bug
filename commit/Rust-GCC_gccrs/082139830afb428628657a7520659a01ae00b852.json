{"sha": "082139830afb428628657a7520659a01ae00b852", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyMTM5ODMwYWZiNDI4NjI4NjU3YTc1MjA2NTlhMDFhZTAwYjg1Mg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-10-07T18:58:10Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-10-07T18:58:10Z"}, "message": "rs6000-c.c (rs6000_cpu_cpp_builtins): Split -mfloat128 into -mfloat128-type that enables the IEEE 128-bit floating...\n\n[gcc]\n2016-10-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Split\n\t-mfloat128 into -mfloat128-type that enables the IEEE 128-bit\n\tfloating point type infrastructre, and -mfloat128 that enables the\n\tkeyword.  Define __FLOAT128__ if -mfloat128, and __FLOAT128_TYPE__\n\tif -mfloat128-type.  Define __ibm128 to be long double by default.\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print whether\n\tthe IEEE 128-bit floating point type infrastructure should\n\tautomatically be enabled.\n\t(rs6000_init_hard_regno_mode_ok): Switch to use -mfloat128-type\n\tinstead of -mfloat128 to enable KFmode.\n\t(rs6000_option_override_internal): Split the option -mfloat128\n\tinto -mfloat128-type and -mfloat128.  On Linux PowerPC 64-bit\n\tsystems, automatically set -mfloat128-type, but don't enable it on\n\tother operating systems.  Move setting the long double size and\n\tIEEE quad support before the IEEE 128-bit floating point changes.\n\t(rs6000_init_builtins): Do not create a unique type for __ibm128\n\tif long double is IBM extended double, instead rely on __ibm128\n\tbeing defined as 'long double'.  If -mfloat128-type and not\n\t-mfloat128, create the KFmode type with an undocumented __ieee128\n\tkeyword.\n\t(rs6000_init_libfuncs): Use -mfloat128-type instead of\n\t-mfloat128 for tests about the types, but keep tests for\n\t-mfloat128 to enable the keyword support.\n\t(rs6000_complex_function_value): Likewise.\n\t(rs6000_scalar_mode_supported_p): Likewise.\n\t(rs6000_floatn_mode): Likewise.\n\t(rs6000_c_mode_for_suffix): Likewise.\n\t(rs6000_opt_masks): Add -mfloat128-type.\n\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add support for\n\t-mfloat128-type being split from -mfloat128.  Add\n\t-mfloat128-hardware, which was missing.\n\t* config/rs6000/rs6000.opt (-mfloat128): Split -mfloat128 into\n\t-mfloat128 and -mfloat128-type:\n\t(-mfloat128-type): Likewise.\n\t* config/rs6000/linux64.h (TARGET_FLOAT128_ENABLE_TYPE): Define so\n\tthat 64-bit Linux systems with enable -mfloat128-type by default\n\ton VSX systems.\n\t* config/rs6000/rs6000.h (TARGET_FLOAT128_ENABLE_TYPE): Likewise.\n\t(FLOAT128_VECTOR_P): Switch IEEE 128-bit floating points to use\n\t-mfloat128-type instead of -mfloat128.\n\t(FLOAT128_2REG_P): Likewise.\n\t(MASK_FLOAT128_TYPE): Likewise.\n\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n\t(RS6000_BTM_FLOAT128): Likewise.\n\t(TARGET_FLOAT128): Poison old identifiers.\n\t(OPTION_MASK_FLOAT128): Likewise.\n\t(MASK_FLOAT128): Likewise.\n\t* config/rs6000/rs6000.md (FP): Likewise.\n\t(FLOAT128): Likewise.\n\t(fix_trunc<mode>di2): Likewise.\n\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n\t(floatdi<mode>2): Likewise.\n\t(floatuns<SDI:mode><IEEE128:mode>2): Likewise.\n\t(neg<mode>2, FLOAT128 iterator): Likewise.\n\t(abs<mode>2, FLOAT128 iterator): Likewise.\n\t(ieee_128bit_negative_zero): Likewise.\n\t(ieee_128bit_vsx_neg<mode>2): Likewise.\n\t(ieee_128bit_vsx_neg<mode>2_internal): Likewise.\n\t(ieee_128bit_vsx_abs<mode>2): Likewise.\n\t(ieee_128bit_vsx_abs<mode>2_internal): Likewise.\n\t(ieee_128bit_vsx_nabs<mode>2): Likewise.\n\t(ieee_128bit_vsx_nabs<mode>2_internal): Likewise.\n\t(extendiftf2): Likewise.\n\t(extendifkf2): Likewise.\n\t(extendtfkf2): Likewise.\n\t(trunciftf2): Likewise.\n\t(truncifkf2): Likewise.\n\t(trunckftf2): Likewise.\n\t(trunctfif2): Likewise.\n\t(extendkftf2): Likewise.\n\t(trunctfkf2): Likewise.\n\n[gcc/testsuite]\n2016-10-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-type-1.c: New test to check that\n\tPowerPC 64-bit Linux enables -mfloat128-type by default.\n\t* gcc.target/powerpc/float128-type-2.c: Likewise.\n\t* gcc.target/powerpc/float128-mix.c: Change error message to\n\treflect that __ibm128 is now #define'ed to be long double.\n\nFrom-SVN: r240872", "tree": {"sha": "06618651cecee32e28ec0288e0bdba5a7c6527ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06618651cecee32e28ec0288e0bdba5a7c6527ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/082139830afb428628657a7520659a01ae00b852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082139830afb428628657a7520659a01ae00b852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/082139830afb428628657a7520659a01ae00b852", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082139830afb428628657a7520659a01ae00b852/comments", "author": null, "committer": null, "parents": [{"sha": "bd845c14b7aa666b5f7d453fa928551506df0ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd845c14b7aa666b5f7d453fa928551506df0ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd845c14b7aa666b5f7d453fa928551506df0ffa"}], "stats": {"total": 449, "additions": 355, "deletions": 94}, "files": [{"sha": "8c873c35d9688f4b66bbd90c11fc231045efe6f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -1,3 +1,77 @@\n+2016-10-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Split\n+\t-mfloat128 into -mfloat128-type that enables the IEEE 128-bit\n+\tfloating point type infrastructre, and -mfloat128 that enables the\n+\tkeyword.  Define __FLOAT128__ if -mfloat128, and __FLOAT128_TYPE__\n+\tif -mfloat128-type.  Define __ibm128 to be long double by default.\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print whether\n+\tthe IEEE 128-bit floating point type infrastructure should\n+\tautomatically be enabled.\n+\t(rs6000_init_hard_regno_mode_ok): Switch to use -mfloat128-type\n+\tinstead of -mfloat128 to enable KFmode.\n+\t(rs6000_option_override_internal): Split the option -mfloat128\n+\tinto -mfloat128-type and -mfloat128.  On Linux PowerPC 64-bit\n+\tsystems, automatically set -mfloat128-type, but don't enable it on\n+\tother operating systems.  Move setting the long double size and\n+\tIEEE quad support before the IEEE 128-bit floating point changes.\n+\t(rs6000_init_builtins): Do not create a unique type for __ibm128\n+\tif long double is IBM extended double, instead rely on __ibm128\n+\tbeing defined as 'long double'.  If -mfloat128-type and not\n+\t-mfloat128, create the KFmode type with an undocumented __ieee128\n+\tkeyword.\n+\t(rs6000_init_libfuncs): Use -mfloat128-type instead of\n+\t-mfloat128 for tests about the types, but keep tests for\n+\t-mfloat128 to enable the keyword support.\n+\t(rs6000_complex_function_value): Likewise.\n+\t(rs6000_scalar_mode_supported_p): Likewise.\n+\t(rs6000_floatn_mode): Likewise.\n+\t(rs6000_c_mode_for_suffix): Likewise.\n+\t(rs6000_opt_masks): Add -mfloat128-type.\n+\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add support for\n+\t-mfloat128-type being split from -mfloat128.  Add\n+\t-mfloat128-hardware, which was missing.\n+\t* config/rs6000/rs6000.opt (-mfloat128): Split -mfloat128 into\n+\t-mfloat128 and -mfloat128-type:\n+\t(-mfloat128-type): Likewise.\n+\t* config/rs6000/linux64.h (TARGET_FLOAT128_ENABLE_TYPE): Define so\n+\tthat 64-bit Linux systems with enable -mfloat128-type by default\n+\ton VSX systems.\n+\t* config/rs6000/rs6000.h (TARGET_FLOAT128_ENABLE_TYPE): Likewise.\n+\t(FLOAT128_VECTOR_P): Switch IEEE 128-bit floating points to use\n+\t-mfloat128-type instead of -mfloat128.\n+\t(FLOAT128_2REG_P): Likewise.\n+\t(MASK_FLOAT128_TYPE): Likewise.\n+\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n+\t(RS6000_BTM_FLOAT128): Likewise.\n+\t(TARGET_FLOAT128): Poison old identifiers.\n+\t(OPTION_MASK_FLOAT128): Likewise.\n+\t(MASK_FLOAT128): Likewise.\n+\t* config/rs6000/rs6000.md (FP): Likewise.\n+\t(FLOAT128): Likewise.\n+\t(fix_trunc<mode>di2): Likewise.\n+\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n+\t(floatdi<mode>2): Likewise.\n+\t(floatuns<SDI:mode><IEEE128:mode>2): Likewise.\n+\t(neg<mode>2, FLOAT128 iterator): Likewise.\n+\t(abs<mode>2, FLOAT128 iterator): Likewise.\n+\t(ieee_128bit_negative_zero): Likewise.\n+\t(ieee_128bit_vsx_neg<mode>2): Likewise.\n+\t(ieee_128bit_vsx_neg<mode>2_internal): Likewise.\n+\t(ieee_128bit_vsx_abs<mode>2): Likewise.\n+\t(ieee_128bit_vsx_abs<mode>2_internal): Likewise.\n+\t(ieee_128bit_vsx_nabs<mode>2): Likewise.\n+\t(ieee_128bit_vsx_nabs<mode>2_internal): Likewise.\n+\t(extendiftf2): Likewise.\n+\t(extendifkf2): Likewise.\n+\t(extendtfkf2): Likewise.\n+\t(trunciftf2): Likewise.\n+\t(truncifkf2): Likewise.\n+\t(trunckftf2): Likewise.\n+\t(trunctfif2): Likewise.\n+\t(extendkftf2): Likewise.\n+\t(trunctfkf2): Likewise.\n+\n 2016-10-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* simplify-rtx.c (simplify_immed_subreg): Zero-initialize tmp array"}, {"sha": "0101ec0ac698fad979b6d0c55abd763a7074c7ab", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -634,3 +634,9 @@ extern int dot_symbols;\n   || (TARGET_GLIBC_MAJOR == 2 && TARGET_GLIBC_MINOR >= 19)\n #define RS6000_GLIBC_ATOMIC_FENV 1\n #endif\n+\n+/* The IEEE 128-bit emulator is only built on Linux systems.  Flag that we\n+   should enable the type handling for KFmode on VSX systems even if we are not\n+   enabling the __float128 keyword.  */\n+#undef\tTARGET_FLOAT128_ENABLE_TYPE\n+#define TARGET_FLOAT128_ENABLE_TYPE 1"}, {"sha": "c98a54f995717920371cf8f0749b1acf3da12023", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -425,10 +425,20 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__RSQRTE__\");\n   if (TARGET_FRSQRTES)\n     builtin_define (\"__RSQRTEF__\");\n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_KEYWORD)\n     builtin_define (\"__FLOAT128__\");\n+  if (TARGET_FLOAT128_TYPE)\n+    builtin_define (\"__FLOAT128_TYPE__\");\n   if (TARGET_FLOAT128_HW)\n     builtin_define (\"__FLOAT128_HARDWARE__\");\n+  if (TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (TFmode))\n+    builtin_define (\"__ibm128=long double\");\n+\n+  /* We needed to create a keyword if -mfloat128-type was used but not -mfloat,\n+     so we used __ieee128.  If -mfloat128 was used, create a #define back to\n+     the real keyword in case somebody used it.  */\n+  if (TARGET_FLOAT128_KEYWORD)\n+    builtin_define (\"__ieee128=__float128\");\n \n   if (TARGET_EXTRA_BUILTINS && cpp_get_options (pfile)->lang != CLK_ASM)\n     {"}, {"sha": "e1786b24dab46411993e3af772d7836c00df1932", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -103,7 +103,9 @@\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n \t\t\t\t | OPTION_MASK_DLMZB\t\t\t\\\n \t\t\t\t | OPTION_MASK_EFFICIENT_UNALIGNED_VSX\t\\\n-\t\t\t\t | OPTION_MASK_FLOAT128\t\t\t\\\n+\t\t\t\t | OPTION_MASK_FLOAT128_HW\t\t\\\n+\t\t\t\t | OPTION_MASK_FLOAT128_KEYWORD\t\t\\\n+\t\t\t\t | OPTION_MASK_FLOAT128_TYPE\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\"}, {"sha": "49da4b629aeec04341e66877ab57921b8f82115d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 140, "deletions": 55, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -2718,6 +2718,9 @@ rs6000_debug_reg_global (void)\n   fprintf (stderr, DEBUG_FMT_D, \"Number of rs6000 builtins\",\n \t   (int)RS6000_BUILTIN_COUNT);\n \n+  fprintf (stderr, DEBUG_FMT_D, \"Enable float128 on VSX\",\n+\t   (int)TARGET_FLOAT128_ENABLE_TYPE);\n+\n   if (TARGET_VSX)\n     fprintf (stderr, DEBUG_FMT_D, \"VSX easy 64-bit scalar element\",\n \t     (int)VECTOR_ELEMENT_SCALAR_64BIT);\n@@ -2956,7 +2959,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n   /* KF mode (IEEE 128-bit in VSX registers).  We do not have arithmetic, so\n      only set the memory modes.  Include TFmode if -mabi=ieeelongdouble.  */\n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       rs6000_vector_mem[KFmode] = VECTOR_VSX;\n       rs6000_vector_align[KFmode] = 128;\n@@ -3162,7 +3165,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_LFIWZX)\n     rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\t/* DImode  */\n \n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       rs6000_constraints[RS6000_CONSTRAINT_wq] = VSX_REGS;\t/* KFmode  */\n       if (FLOAT128_IEEE_P (TFmode))\n@@ -3701,7 +3704,7 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((TARGET_DFP)\t\t    ? RS6000_BTM_DFP\t   : 0)\n \t  | ((TARGET_HARD_FLOAT)\t    ? RS6000_BTM_HARD_FLOAT : 0)\n \t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128   : 0)\n-\t  | ((TARGET_FLOAT128)\t\t    ? RS6000_BTM_FLOAT128  : 0));\n+\t  | ((TARGET_FLOAT128_TYPE)\t    ? RS6000_BTM_FLOAT128  : 0));\n }\n \n /* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered\n@@ -4405,28 +4408,96 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n-  /* __float128 requires VSX support.  */\n-  if (TARGET_FLOAT128 && !TARGET_VSX)\n+  /* Set long double size before the IEEE 128-bit tests.  */\n+  if (!global_options_set.x_rs6000_long_double_type_size)\n     {\n-      if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128) != 0)\n-\terror (\"-mfloat128 requires VSX support\");\n+      if (main_target_opt != NULL\n+\t  && (main_target_opt->x_rs6000_long_double_type_size\n+\t      != RS6000_DEFAULT_LONG_DOUBLE_SIZE))\n+\terror (\"target attribute or pragma changes long double size\");\n+      else\n+\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n+    }\n+\n+  /* Set -mabi=ieeelongdouble on some old targets.  Note, AIX and Darwin\n+     explicitly redefine TARGET_IEEEQUAD to 0, so those systems will not\n+     pick up this default.  */\n+#if !defined (POWERPC_LINUX) && !defined (POWERPC_FREEBSD)\n+  if (!global_options_set.x_rs6000_ieeequad)\n+    rs6000_ieeequad = 1;\n+#endif\n+\n+  /* Enable the default support for IEEE 128-bit floating point on Linux VSX\n+     sytems, but don't enable the __float128 keyword.  */\n+  if (TARGET_VSX && TARGET_LONG_DOUBLE_128\n+      && (TARGET_FLOAT128_ENABLE_TYPE || TARGET_IEEEQUAD)\n+      && ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_TYPE) == 0))\n+    rs6000_isa_flags |= OPTION_MASK_FLOAT128_TYPE;\n+\n+  /* IEEE 128-bit floating point requires VSX support.  */\n+  if (!TARGET_VSX)\n+    {\n+      if (TARGET_FLOAT128_KEYWORD)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n+\t    error (\"-mfloat128 requires VSX support\");\n+\n+\t  rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n+\t\t\t\t| OPTION_MASK_FLOAT128_KEYWORD\n+\t\t\t\t| OPTION_MASK_FLOAT128_HW);\n+\t}\n+\n+      else if (TARGET_FLOAT128_TYPE)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_TYPE) != 0)\n+\t    error (\"-mfloat128-type requires VSX support\");\n \n-      rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128 | OPTION_MASK_FLOAT128_HW);\n+\t  rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n+\t\t\t\t| OPTION_MASK_FLOAT128_KEYWORD\n+\t\t\t\t| OPTION_MASK_FLOAT128_HW);\n+\t}\n     }\n \n-  /* If we have -mfloat128 and full ISA 3.0 support, enable -mfloat128-hardware\n-     by default.  */\n-  if (TARGET_FLOAT128 && !TARGET_FLOAT128_HW\n-      && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) == ISA_3_0_MASKS_IEEE\n-      && !(rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW))\n+  /* -mfloat128 and -mfloat128-hardware internally require the underlying IEEE\n+      128-bit floating point support to be enabled.  */\n+  if (!TARGET_FLOAT128_TYPE)\n     {\n-      rs6000_isa_flags |= OPTION_MASK_FLOAT128_HW;\n-      if ((rs6000_isa_flags & OPTION_MASK_FLOAT128) != 0)\n-\trs6000_isa_flags_explicit |= OPTION_MASK_FLOAT128_HW;\n+      if (TARGET_FLOAT128_KEYWORD)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n+\t    {\n+\t      error (\"-mfloat128 requires -mfloat128-type\");\n+\t      rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n+\t\t\t\t    | OPTION_MASK_FLOAT128_KEYWORD\n+\t\t\t\t    | OPTION_MASK_FLOAT128_HW);\n+\t    }\n+\t  else\n+\t    rs6000_isa_flags |= OPTION_MASK_FLOAT128_TYPE;\n+\t}\n+\n+      if (TARGET_FLOAT128_HW)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) != 0)\n+\t    {\n+\t      error (\"-mfloat128-hardware requires -mfloat128-type\");\n+\t      rs6000_isa_flags &= ~OPTION_MASK_FLOAT128_HW;\n+\t    }\n+\t  else\n+\t    rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n+\t\t\t\t  | OPTION_MASK_FLOAT128_KEYWORD\n+\t\t\t\t  | OPTION_MASK_FLOAT128_HW);\n+\t}\n     }\n \n-  /* IEEE 128-bit floating point hardware instructions imply enabling\n-     __float128.  */\n+  /* If we have -mfloat128-type and full ISA 3.0 support, enable\n+     -mfloat128-hardware by default.  However, don't enable the __float128\n+     keyword.  If the user explicitly turned on -mfloat128-hardware, enable the\n+     -mfloat128 option as well if it was not already set.  */\n+  if (TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\n+      && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) == ISA_3_0_MASKS_IEEE\n+      && !(rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW))\n+    rs6000_isa_flags |= OPTION_MASK_FLOAT128_HW;\n+\n   if (TARGET_FLOAT128_HW\n       && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) != ISA_3_0_MASKS_IEEE)\n     {\n@@ -4436,9 +4507,10 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_FLOAT128_HW;\n     }\n \n-  if (TARGET_FLOAT128_HW\n-      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128) == 0)\n-    rs6000_isa_flags |= OPTION_MASK_FLOAT128;\n+  if (TARGET_FLOAT128_HW && !TARGET_FLOAT128_KEYWORD\n+      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) != 0\n+      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) == 0)\n+    rs6000_isa_flags |= OPTION_MASK_FLOAT128_KEYWORD;\n \n   /* Print the options after updating the defaults.  */\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n@@ -4501,28 +4573,14 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n-  if (!global_options_set.x_rs6000_long_double_type_size)\n-    {\n-      if (main_target_opt != NULL\n-\t  && (main_target_opt->x_rs6000_long_double_type_size\n-\t      != RS6000_DEFAULT_LONG_DOUBLE_SIZE))\n-\terror (\"target attribute or pragma changes long double size\");\n-      else\n-\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n-    }\n-\n-#if !defined (POWERPC_LINUX) && !defined (POWERPC_FREEBSD)\n-  if (!global_options_set.x_rs6000_ieeequad)\n-    rs6000_ieeequad = 1;\n-#endif\n-\n   /* Disable VSX and Altivec silently if the user switched cpus to power7 in a\n      target attribute or pragma which automatically enables both options,\n      unless the altivec ABI was set.  This is set by default for 64-bit, but\n      not for 32-bit.  */\n   if (main_target_opt != NULL && !main_target_opt->x_rs6000_altivec_abi)\n     rs6000_isa_flags &= ~((OPTION_MASK_VSX | OPTION_MASK_ALTIVEC\n-\t\t\t   | OPTION_MASK_FLOAT128)\n+\t\t\t   | OPTION_MASK_FLOAT128_TYPE\n+\t\t\t   | OPTION_MASK_FLOAT128_KEYWORD)\n \t\t\t  & ~rs6000_isa_flags_explicit);\n \n   /* Enable Altivec ABI for AIX -maltivec.  */\n@@ -16505,29 +16563,55 @@ rs6000_init_builtins (void)\n      IFmode is the IBM extended 128-bit format that is a pair of doubles.\n      TFmode will be either IEEE 128-bit floating point or the IBM double-double\n      format that uses a pair of doubles, depending on the switches and\n-     defaults.  */\n-  if (TARGET_FLOAT128)\n+     defaults.\n+\n+     We do not enable the actual __float128 keyword unless the user explicitly\n+     asks for it, because the library support is not yet complete.\n+\n+     If we don't support for either 128-bit IBM double double or IEEE 128-bit\n+     floating point, we need make sure the type is non-zero or else self-test\n+     fails during bootstrap.\n+\n+     We don't register a built-in type for __ibm128 or __float128 if the type\n+     is the same as long double.  Instead we add a #define for __ibm128 or\n+     __float128 in rs6000_cpu_cpp_builtins to long double.  */\n+  if (TARGET_IEEEQUAD || !TARGET_LONG_DOUBLE_128)\n     {\n       ibm128_float_type_node = make_node (REAL_TYPE);\n       TYPE_PRECISION (ibm128_float_type_node) = 128;\n       layout_type (ibm128_float_type_node);\n       SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n \n-      ieee128_float_type_node = float128_type_node;\n-\n-      lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n-\t\t\t\t\t      \"__float128\");\n-\n       lang_hooks.types.register_builtin_type (ibm128_float_type_node,\n \t\t\t\t\t      \"__ibm128\");\n     }\n   else\n+    ibm128_float_type_node = long_double_type_node;\n+\n+  if (TARGET_FLOAT128_KEYWORD)\n+    {\n+      ieee128_float_type_node = float128_type_node;\n+      lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n+\t\t\t\t\t      \"__float128\");\n+    }\n+\n+  else if (TARGET_FLOAT128_TYPE)\n     {\n-      /* All types must be nonzero, or self-test barfs during bootstrap.  */\n-      ieee128_float_type_node = long_double_type_node;\n-      ibm128_float_type_node = long_double_type_node;\n+      ieee128_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (ibm128_float_type_node) = 128;\n+      layout_type (ieee128_float_type_node);\n+      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n+\n+      /* If we are not exporting the __float128/_Float128 keywords, we need a\n+\t keyword to get the types created.  Use __ieee128 as the dummy\n+\t keyword.  */\n+      lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n+\t\t\t\t\t      \"__ieee128\");\n     }\n \n+  else\n+    ieee128_float_type_node = long_double_type_node;\n+\n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n      tree type node.  */\n   builtin_mode_to_type[QImode][0] = integer_type_node;\n@@ -18316,7 +18400,7 @@ static void\n rs6000_init_libfuncs (void)\n {\n   /* __float128 support.  */\n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       init_float128_ibm (IFmode);\n       init_float128_ieee (KFmode);\n@@ -33425,7 +33509,7 @@ rs6000_mangle_type (const_tree type)\n   /* Use a unique name for __float128 rather than trying to use \"e\" or \"g\". Use\n      \"g\" for IBM extended double, no matter whether it is long double (using\n      -mabi=ibmlongdouble) or the distinct __ibm128 type.  */\n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       if (type == ieee128_float_type_node)\n \treturn \"U10__float128\";\n@@ -36397,7 +36481,7 @@ rs6000_complex_function_value (machine_mode mode)\n   machine_mode inner = GET_MODE_INNER (mode);\n   unsigned int inner_bytes = GET_MODE_UNIT_SIZE (mode);\n \n-  if (TARGET_FLOAT128\n+  if (TARGET_FLOAT128_TYPE\n       && (mode == KCmode\n \t  || (mode == TCmode && TARGET_IEEEQUAD)))\n     regno = ALTIVEC_ARG_RETURN;\n@@ -36804,7 +36888,7 @@ rs6000_scalar_mode_supported_p (machine_mode mode)\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return default_decimal_float_supported_p ();\n-  else if (TARGET_FLOAT128 && (mode == KFmode || mode == IFmode))\n+  else if (TARGET_FLOAT128_TYPE && (mode == KFmode || mode == IFmode))\n     return true;\n   else\n     return default_scalar_mode_supported_p (mode);\n@@ -36843,7 +36927,7 @@ rs6000_floatn_mode (int n, bool extended)\n \t  return DFmode;\n \n \tcase 64:\n-\t  if (TARGET_FLOAT128)\n+\t  if (TARGET_FLOAT128_KEYWORD)\n \t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n \t  else\n \t    return VOIDmode;\n@@ -36867,7 +36951,7 @@ rs6000_floatn_mode (int n, bool extended)\n \t  return DFmode;\n \n \tcase 128:\n-\t  if (TARGET_FLOAT128)\n+\t  if (TARGET_FLOAT128_KEYWORD)\n \t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n \t  else\n \t    return VOIDmode;\n@@ -36883,7 +36967,7 @@ rs6000_floatn_mode (int n, bool extended)\n static machine_mode\n rs6000_c_mode_for_suffix (char suffix)\n {\n-  if (TARGET_FLOAT128)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       if (suffix == 'q' || suffix == 'Q')\n \treturn (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n@@ -36984,7 +37068,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"efficient-unaligned-vsx\",\tOPTION_MASK_EFFICIENT_UNALIGNED_VSX,\n \t\t\t\t\t\t\t\tfalse, true  },\n-  { \"float128\",\t\t\tOPTION_MASK_FLOAT128,\t\tfalse, false },\n+  { \"float128\",\t\t\tOPTION_MASK_FLOAT128_KEYWORD,\tfalse, false },\n+  { \"float128-type\",\t\tOPTION_MASK_FLOAT128_TYPE,\tfalse, false },\n   { \"float128-hardware\",\tOPTION_MASK_FLOAT128_HW,\tfalse, false },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },"}, {"sha": "ad5819385fe27b4d14c998440b9a35f5c4a40262", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -363,6 +363,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define SET_TARGET_LINK_STACK(X) do { } while (0)\n #endif\n \n+#ifndef TARGET_FLOAT128_ENABLE_TYPE\n+#define TARGET_FLOAT128_ENABLE_TYPE 0\n+#endif\n+\n /* Return 1 for a symbol ref for a thread-local storage symbol.  */\n #define RS6000_SYMBOL_REF_TLS_P(RTX) \\\n   (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n@@ -449,12 +453,12 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n /* Helper macros to say whether a 128-bit floating point type can go in a\n    single vector register, or whether it needs paired scalar values.  */\n-#define FLOAT128_VECTOR_P(MODE) (TARGET_FLOAT128 && FLOAT128_IEEE_P (MODE))\n+#define FLOAT128_VECTOR_P(MODE) (TARGET_FLOAT128_TYPE && FLOAT128_IEEE_P (MODE))\n \n #define FLOAT128_2REG_P(MODE)\t\t\t\t\t\t\\\n   (FLOAT128_IBM_P (MODE)\t\t\t\t\t\t\\\n    || ((MODE) == TDmode)\t\t\t\t\t\t\\\n-   || (!TARGET_FLOAT128 && FLOAT128_IEEE_P (MODE)))\n+   || (!TARGET_FLOAT128_TYPE && FLOAT128_IEEE_P (MODE)))\n \n /* Return true for floating point that does not use a vector register.  */\n #define SCALAR_FLOAT_MODE_NOT_VECTOR_P(MODE)\t\t\t\t\\\n@@ -637,7 +641,7 @@ extern int rs6000_vector_align[];\n #define MASK_DIRECT_MOVE\t\tOPTION_MASK_DIRECT_MOVE\n #define MASK_DLMZB\t\t\tOPTION_MASK_DLMZB\n #define MASK_EABI\t\t\tOPTION_MASK_EABI\n-#define MASK_FLOAT128\t\t\tOPTION_MASK_FLOAT128\n+#define MASK_FLOAT128_TYPE\t\tOPTION_MASK_FLOAT128_TYPE\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n #define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n@@ -1821,7 +1825,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n \t\t\t   : (FP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n #define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2\t\t\\\n \t\t\t\t? (ALTIVEC_ARG_RETURN\t\t\t\\\n-\t\t\t\t   + (TARGET_FLOAT128 ? 1 : 0))\t\t\\\n+\t\t\t\t   + (TARGET_FLOAT128_TYPE ? 1 : 0))\t\\\n \t\t\t        : (ALTIVEC_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n \n /* Flags for the call/call_value rtl operations set up by function_arg */\n@@ -2728,7 +2732,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_HARD_FLOAT\tMASK_SOFT_FLOAT\t/* Hardware floating point.  */\n #define RS6000_BTM_LDBL128\tMASK_MULTIPLE\t/* 128-bit long double.  */\n #define RS6000_BTM_64BIT\tMASK_64BIT\t/* 64-bit addressing.  */\n-#define RS6000_BTM_FLOAT128\tMASK_FLOAT128\t/* IEEE 128-bit float.  */\n+#define RS6000_BTM_FLOAT128\tMASK_FLOAT128_TYPE /* IEEE 128-bit float.  */\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n@@ -2914,3 +2918,7 @@ extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];\n extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n #define TARGET_SUPPORTS_WIDE_INT 1\n+\n+#if (GCC_VERSION >= 3000)\n+#pragma GCC poison TARGET_FLOAT128 OPTION_MASK_FLOAT128 MASK_FLOAT128\n+#endif"}, {"sha": "e432a5a5411f07b32bcaa48ba0235bfc9572b374", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -376,8 +376,8 @@\n   (TF \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\")\n-  (IF \"TARGET_FLOAT128\")\n-  (KF \"TARGET_FLOAT128\")\n+  (IF \"TARGET_LONG_DOUBLE_128\")\n+  (KF \"TARGET_FLOAT128_TYPE\")\n   (DD \"TARGET_DFP\")\n   (TD \"TARGET_DFP\")])\n \n@@ -506,8 +506,8 @@\n \t\t\t       (TF \"FLOAT128_IEEE_P (TFmode)\")])\n \n ; Iterator for 128-bit floating point\n-(define_mode_iterator FLOAT128 [(KF \"TARGET_FLOAT128\")\n-\t\t\t\t(IF \"TARGET_FLOAT128\")\n+(define_mode_iterator FLOAT128 [(KF \"TARGET_FLOAT128_TYPE\")\n+\t\t\t\t(IF \"TARGET_FLOAT128_TYPE\")\n \t\t\t\t(TF \"TARGET_LONG_DOUBLE_128\")])\n \n ; Iterator for signbit on 64-bit machines with direct move\n@@ -7298,7 +7298,7 @@\n (define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(fix:DI (match_operand:IEEE128 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7307,7 +7307,7 @@\n (define_expand \"fixuns_trunc<IEEE128:mode><SDI:mode>2\"\n   [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SDI (match_operand:IEEE128 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], true);\n   DONE;\n@@ -7316,7 +7316,7 @@\n (define_expand \"floatdi<mode>2\"\n   [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n \t(float:IEEE128 (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7325,7 +7325,7 @@\n (define_expand \"floatuns<SDI:mode><IEEE128:mode>2\"\n   [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_float:IEEE128 (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], true);\n   DONE;\n@@ -7351,7 +7351,7 @@\n \t  else\n \t    gcc_unreachable ();\n \t}\n-      else if (TARGET_FLOAT128)\n+      else if (TARGET_FLOAT128_TYPE)\n \t{\n \t  if (<MODE>mode == TFmode)\n \t    emit_insn (gen_ieee_128bit_vsx_negtf2 (operands[0], operands[1]));\n@@ -7411,7 +7411,7 @@\n \t    FAIL;\n \t  DONE;\n \t}\n-      else if (TARGET_FLOAT128)\n+      else if (TARGET_FLOAT128_TYPE)\n \t{\n \t  if (<MODE>mode == TFmode)\n \t    emit_insn (gen_ieee_128bit_vsx_abstf2 (operands[0], operands[1]));\n@@ -7471,7 +7471,7 @@\n \n (define_expand \"ieee_128bit_negative_zero\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"\") (match_dup 1))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rtvec v = rtvec_alloc (16);\n   int i, high;\n@@ -7498,7 +7498,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7518,7 +7518,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\"\n   \"xxlxor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"veclogical\")])\n \n@@ -7527,7 +7527,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7547,7 +7547,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\"\n   \"xxlandc %x0,%x1,%x2\"\n   [(set_attr \"type\" \"veclogical\")])\n \n@@ -7558,7 +7558,8 @@\n \t (abs:IEEE128\n \t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\n+   && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7580,7 +7581,7 @@\n \t (abs:IEEE128\n \t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (use (match_operand:V16QI 2 \"register_operand\" \"v\"))]\n-  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n+  \"TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\"\n   \"xxlor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"veclogical\")])\n \n@@ -7590,7 +7591,7 @@\n (define_expand \"extendiftf2\"\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:TF (match_operand:IF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7599,7 +7600,7 @@\n (define_expand \"extendifkf2\"\n   [(set (match_operand:KF 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:KF (match_operand:IF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7608,7 +7609,7 @@\n (define_expand \"extendtfkf2\"\n   [(set (match_operand:KF 0 \"gpc_reg_operand\" \"\")\n \t(float_extend:KF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7617,7 +7618,7 @@\n (define_expand \"trunciftf2\"\n   [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:IF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7626,7 +7627,7 @@\n (define_expand \"truncifkf2\"\n   [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:IF (match_operand:KF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7635,7 +7636,7 @@\n (define_expand \"trunckftf2\"\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:TF (match_operand:KF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -7644,7 +7645,7 @@\n (define_expand \"trunctfif2\"\n   [(set (match_operand:IF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:IF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n@@ -13724,7 +13725,7 @@\n (define_insn_and_split \"extendkftf2\"\n   [(set (match_operand:TF 0 \"vsx_register_operand\" \"=wa,?wa\")\n \t(float_extend:TF (match_operand:KF 1 \"vsx_register_operand\" \"0,wa\")))]\n-  \"TARGET_FLOAT128 && TARGET_IEEEQUAD\"\n+  \"TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD\"\n   \"@\n    #\n    xxlor %x0,%x1,%x1\"\n@@ -13740,7 +13741,7 @@\n (define_insn_and_split \"trunctfkf2\"\n   [(set (match_operand:KF 0 \"vsx_register_operand\" \"=wa,?wa\")\n \t(float_extend:KF (match_operand:TF 1 \"vsx_register_operand\" \"0,wa\")))]\n-  \"TARGET_FLOAT128 && TARGET_IEEEQUAD\"\n+  \"TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD\"\n   \"@\n    #\n    xxlor %x0,%x1,%x1\""}, {"sha": "3e0717d2b06804f94eb93c30ae90124ff1af1e24", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -645,8 +645,16 @@ mmodulo\n Target Undocumented Report Mask(MODULO) Var(rs6000_isa_flags)\n Generate the integer modulo instructions.\n \n+; We want to enable the internal support for the IEEE 128-bit floating point\n+; type without necessarily enabling the __float128 keyword.  This is to allow\n+; Boost and other libraries that know about __float128 to work until the\n+; official library support is finished.\n+mfloat128-type\n+Target Undocumented Mask(FLOAT128_TYPE) Var(rs6000_isa_flags)\n+Allow the IEEE 128-bit types without requiring the __float128 keyword.\n+\n mfloat128\n-Target Report Mask(FLOAT128) Var(rs6000_isa_flags)\n+Target Report Mask(FLOAT128_KEYWORD) Var(rs6000_isa_flags)\n Enable IEEE 128-bit floating point via the __float128 keyword.\n \n mfloat128-hardware"}, {"sha": "0aa90ee5d780b89dabf347ff533712ecc9a044c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -1,3 +1,11 @@\n+2016-10-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-type-1.c: New test to check that\n+\tPowerPC 64-bit Linux enables -mfloat128-type by default.\n+\t* gcc.target/powerpc/float128-type-2.c: Likewise.\n+\t* gcc.target/powerpc/float128-mix.c: Change error message to\n+\treflect that __ibm128 is now #define'ed to be long double.\n+\n 2016-10-07  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77406"}, {"sha": "d0cac20296308e72c8e5df172ac70e090a065c41", "filename": "gcc/testsuite/gcc.target/powerpc/float128-mix.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -4,13 +4,13 @@\n /* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n \n \n-/* Test to make sure that __float128 and __ibm128 cannot be combined together.  */\n-__float128 add (__float128 a, __ibm128 b)\n+/* Test to make sure that __float128 and long double cannot be combined together.  */\n+__float128 add (__float128 a, long double b)\n {\n-  return a+b;\t/* { dg-error \"__float128 and __ibm128 cannot be used in the same expression\" \"\" } */\n+  return a+b;\t/* { dg-error \"__float128 and long double cannot be used in the same expression\" \"\" } */\n }\n \n-__ibm128 sub (__ibm128 a, __float128 b)\n+__ibm128 sub (long double a, __float128 b)\n {\n-  return a-b;\t/* { dg-error \"__float128 and __ibm128 cannot be used in the same expression\" \"\" } */\n+  return a-b;\t/* { dg-error \"__float128 and long double cannot be used in the same expression\" \"\" } */\n }"}, {"sha": "a8326bd9630b0878454d8eefa45c28f6f9ef41d2", "filename": "gcc/testsuite/gcc.target/powerpc/float128-type-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile { target { powerpc64*-*-linux* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* This test tests whether -mfloat128-type (which enables the underlying IEEE\n+   128-bit floating point) is enabled by default on VSX Linux 64-bit systems,\n+   even if the keywords __float128 and _Float128 (-mfloat128) are not enabled\n+   via the -mfloat128 switch.  Test that power8 generates a call to the\n+   __addkf3 emulation function.  */\n+\n+typedef double          __attribute__((__mode__(__KF__))) f128_t;\n+typedef _Complex double __attribute__((__mode__(__KC__))) f128c_t;\n+\n+f128_t\n+add_scalar (f128_t a, f128_t b)\n+{\n+  return a+b;\n+}\n+\n+\n+f128c_t\n+add_complex (f128c_t a, f128c_t b)\n+{\n+  return a+b;\n+}\n+\n+/* { dg-final { scan-assembler \"bl __addkf3\" } } */"}, {"sha": "c5d6e35e5a8e3d04bddafc056d6113230cd22a55", "filename": "gcc/testsuite/gcc.target/powerpc/float128-type-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082139830afb428628657a7520659a01ae00b852/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c?ref=082139830afb428628657a7520659a01ae00b852", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { powerpc64-*-linux* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+/* This test tests whether -mfloat128-type (which enables the underlying IEEE\n+   128-bit floating point) is enabled by default on VSX Linux 64-bit systems,\n+   even if the keywords __float128 and _Float128 (-mfloat128) are not enabled\n+   via the -mfloat128 switch.  Test that power9 generates the xsaddqp\n+   instruction.  */\n+\n+/* The effective target powerpc_float128_hw_ok is not used, as that will pass\n+   -mfloat128.  */\n+\n+typedef double          __attribute__((__mode__(__KF__))) f128_t;\n+typedef _Complex double __attribute__((__mode__(__KC__))) f128c_t;\n+\n+f128_t\n+add_scalar (f128_t a, f128_t b)\n+{\n+  return a+b;\n+}\n+\n+\n+f128c_t\n+add_complex (f128c_t a, f128c_t b)\n+{\n+  return a+b;\n+}\n+\n+/* { dg-final { scan-assembler \"xsaddqp\" } } */"}]}