{"sha": "ec9ead44a40ee68de7fc39e32a47662c44281deb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM5ZWFkNDRhNDBlZTY4ZGU3ZmMzOWUzMmE0NzY2MmM0NDI4MWRlYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-25T15:21:34Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-01T10:35:07Z"}, "message": "Adds the same support from generic structs in #235 onto tuple structs\n\nType binding still not supported here but the same generic support is added\nto tuples.\n\nFixes #236", "tree": {"sha": "72af294bf6f54e4becebb22a860823f12aed062c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72af294bf6f54e4becebb22a860823f12aed062c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec9ead44a40ee68de7fc39e32a47662c44281deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9ead44a40ee68de7fc39e32a47662c44281deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec9ead44a40ee68de7fc39e32a47662c44281deb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9ead44a40ee68de7fc39e32a47662c44281deb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af2ae0ff91535da104db0d3828d863770439fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af2ae0ff91535da104db0d3828d863770439fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af2ae0ff91535da104db0d3828d863770439fad"}], "stats": {"total": 141, "additions": 89, "deletions": 52}, "files": [{"sha": "1a798eeb0cbbed919d9637bb9777d242a13a35ad", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -93,34 +93,5 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n     = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n }\n \n-void\n-ResolvePathType::visit (HIR::PathInExpression &expr)\n-{\n-  // need to look up the reference for this identifier\n-  NodeId ref_node_id;\n-  if (!ctx->get_resolver ()->lookup_resolved_type (\n-\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n-    {\n-      return;\n-    }\n-\n-  HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n-    {\n-      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *tyty = nullptr;\n-  if (!ctx->get_tyctx ()->lookup_type (ref, &tyty))\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  resolved = TyTyResolveCompile::compile (ctx, tyty);\n-}\n-\n } // namespace Compile\n } // namespace Rust"}, {"sha": "ae469e6d975963889bab630d6ccfa5cf48f3727d", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -35,32 +35,14 @@ class ResolvePathRef : public HIRCompileBase\n     return resolver.resolved;\n   }\n \n-  void visit (HIR::PathInExpression &expr);\n+  void visit (HIR::PathInExpression &expr) override;\n \n private:\n   ResolvePathRef (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n \n   Bexpression *resolved;\n };\n \n-class ResolvePathType : public HIRCompileBase\n-{\n-public:\n-  static Btype *Compile (HIR::Expr *expr, Context *ctx)\n-  {\n-    ResolvePathType resolver (ctx);\n-    expr->accept_vis (resolver);\n-    return resolver.resolved;\n-  }\n-\n-  void visit (HIR::PathInExpression &expr);\n-\n-private:\n-  ResolvePathType (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n-\n-  Btype *resolved;\n-};\n-\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "2c83527ceac752281f71875fa26d3147b57c6a2d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -53,11 +53,21 @@ CompileCrate::go ()\n void\n CompileExpr::visit (HIR::CallExpr &expr)\n {\n-  Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n-  if (type != nullptr)\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n     {\n-      // this assumes all fields are in order from type resolution and if a base\n-      // struct was specified those fields are filed via accesors\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // must be a tuple constructor\n+  if (tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n       expr.iterate_params ([&] (HIR::Expr *argument) mutable -> bool {\n \tBexpression *e = CompileExpr::Compile (argument, ctx);"}, {"sha": "3e279b52ce6ea36e3b0f6b51cfea3f5dbe1444a5", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -39,11 +39,25 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl)\n   {\n+    NodeId scope_node_id = struct_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic : struct_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (),\n+\t\t\t\t     struct_decl.get_node_id ());\n+\t  }\n+      }\n+\n     struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n       return true;\n     });\n+\n+    resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::StructStruct &struct_decl)"}, {"sha": "bcc85986db64ce3a12cab3130d14e5538dd9e0b3", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -755,6 +755,31 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t       \"failed to resolve PathInExpression type\");\n \treturn;\n       }\n+\n+    HIR::PathExprSegment seg = expr.get_final_segment ();\n+    if (!infered->supports_substitions () && seg.has_generic_args ())\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"path does not support substitutions\");\n+\treturn;\n+      }\n+\n+    if (infered->has_subsititions_defined ())\n+      {\n+\tif (infered->get_kind () != TyTy::TypeKind::ADT)\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"substitutions only support on ADT types so far\");\n+\t    return;\n+\t  }\n+\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n+\tinfered = seg.has_generic_args ()\n+\t\t    ? adt->handle_substitions (seg.get_generic_args ())\n+\t\t    : adt->infer_substitions ();\n+      }\n+\n+    context->insert_type (expr.get_mappings (), infered->clone ());\n   }\n \n   void visit (HIR::LoopExpr &expr)"}, {"sha": "ee759ddc01289fc08e32cf8d9fb027db6f8df3d3", "filename": "gcc/testsuite/rust.test/compilable/generics2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9ead44a40ee68de7fc39e32a47662c44281deb/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics2.rs?ref=ec9ead44a40ee68de7fc39e32a47662c44281deb", "patch": "@@ -0,0 +1,35 @@\n+struct Foo(f32, bool);\n+\n+struct GenericStruct<T>(T, usize);\n+\n+fn main() {\n+    let a1;\n+    a1 = Foo(1.0, false);\n+\n+    let b1: f32 = a1.0;\n+    let c1: bool = a1.1;\n+\n+    let a2: GenericStruct<i8>;\n+    a2 = GenericStruct::<i8>(1, 456);\n+\n+    let b2: i8 = a2.0;\n+    let c2: usize = a2.1;\n+\n+    let a3;\n+    a3 = GenericStruct::<i32>(123, 456);\n+\n+    let b3: i32 = a3.0;\n+    let c3: usize = a3.1;\n+\n+    let a4;\n+    a4 = GenericStruct(1.0, 456);\n+\n+    let b4: f32 = a4.0;\n+    let c4: usize = a4.1;\n+\n+    let a5;\n+    a5 = GenericStruct::<_>(true, 456);\n+\n+    let b5: bool = a5.0;\n+    let c5: usize = a5.1;\n+}"}]}