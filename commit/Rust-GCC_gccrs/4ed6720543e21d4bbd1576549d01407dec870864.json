{"sha": "4ed6720543e21d4bbd1576549d01407dec870864", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkNjcyMDU0M2UyMWQ0YmJkMTU3NjU0OWQwMTQwN2RlYzg3MDg2NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-27T12:57:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-27T12:57:21Z"}, "message": "Include hard-reg-set.h.\n\n(arg_pointer_save_area): New declaration.\n(expand_builtin, case BUILT_IN_{SET,LONG}JMP): New cases.\n\n(expand_expr, case COMPONENT_REF): Pass EXPAND_INITIALIZER to\nrecursive call.\n\nFrom-SVN: r11112", "tree": {"sha": "9ff9947d071610b334498e160d64193721b1480a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ff9947d071610b334498e160d64193721b1480a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed6720543e21d4bbd1576549d01407dec870864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed6720543e21d4bbd1576549d01407dec870864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed6720543e21d4bbd1576549d01407dec870864", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed6720543e21d4bbd1576549d01407dec870864/comments", "author": null, "committer": null, "parents": [{"sha": "33fb8b5fc13774cbe53587eb744bd63f5d9c0399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fb8b5fc13774cbe53587eb744bd63f5d9c0399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33fb8b5fc13774cbe53587eb744bd63f5d9c0399"}], "stats": {"total": 161, "additions": 159, "deletions": 2}, "files": [{"sha": "2fe100c73ec1571d42c9c507aaf1375d07368fe9", "filename": "gcc/expr.c", "status": "modified", "additions": 159, "deletions": 2, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed6720543e21d4bbd1576549d01407dec870864/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed6720543e21d4bbd1576549d01407dec870864/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4ed6720543e21d4bbd1576549d01407dec870864", "patch": "@@ -26,6 +26,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n+#include \"hard-reg-set.h\"\n #include \"function.h\"\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n@@ -153,7 +154,7 @@ extern int local_vars_size;\n extern int stack_depth;\n extern int max_stack_depth;\n extern struct obstack permanent_obstack;\n-\n+extern rtx arg_pointer_save_area;\n \n static rtx enqueue_insn\t\tPROTO((rtx, rtx));\n static int queued_subexp_p\tPROTO((rtx));\n@@ -5280,7 +5281,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t    && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n \t\t\t\t!= INTEGER_CST)\n \t\t\t    ? target : NULL_RTX),\n-\t\t\t   VOIDmode, 0);\n+\t\t\t   VOIDmode,\n+\t\t\t   modifier == EXPAND_INITIALIZER ? modifier : 0);\n \n \t/* If this is a constant, put it into a register if it is a\n \t   legitimate constant and memory if it isn't.  */\n@@ -8492,6 +8494,161 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n #endif\n \n+      /* __builtin_setjmp is passed a pointer to an array of five words\n+\t (not all will be used on all machines).  It operates similarly to\n+\t the C library function of the same name, but is more efficient.\n+\t Much of the code below (and for longjmp) is copied from the handling\n+\t of non-local gotos.\n+\n+\t NOTE: This is intended for use by GNAT and will only work in\n+\t the method used by it.  This code will likely NOT survive to \n+\t the GCC 2.8.0 release.  */\n+    case BUILT_IN_SETJMP:\n+      if (arglist == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+\tbreak;\n+\n+      {\n+\trtx buf_addr\n+\t  = force_reg (Pmode, expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t\t   VOIDmode, 0));\n+\trtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n+\tenum machine_mode sa_mode = Pmode;\n+\trtx stack_save;\n+\n+\tif (target == 0 || GET_CODE (target) != REG\n+\t    || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+\t  target = gen_reg_rtx (value_mode);\n+\n+\temit_queue ();\n+\n+\temit_note (NULL_PTR, NOTE_INSN_SETJMP);\n+\tcurrent_function_calls_setjmp = 1;\n+\n+\t/* We store the frame pointer and the address of lab1 in the buffer\n+\t   and use the rest of it for the stack save area, which is\n+\t   machine-dependent.  */\n+\temit_move_insn (gen_rtx (MEM, Pmode, buf_addr),\n+\t\t\tvirtual_stack_vars_rtx);\n+\temit_move_insn\n+\t  (validize_mem (gen_rtx (MEM, Pmode,\n+\t\t\t\t  plus_constant (buf_addr,\n+\t\t\t\t\t\t GET_MODE_SIZE (Pmode)))),\n+\t   gen_rtx (LABEL_REF, Pmode, lab1));\n+\n+#ifdef HAVE_save_stack_nonlocal\n+\tif (HAVE_save_stack_nonlocal)\n+\t  sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n+#endif\n+\n+\tstack_save = gen_rtx (MEM, sa_mode,\n+\t\t\t      plus_constant (buf_addr,\n+\t\t\t\t\t     2 * GET_MODE_SIZE (Pmode)));\n+\temit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n+\n+\t/* Set TARGET to zero and branch around the other case.  */\n+\temit_move_insn (target, const0_rtx);\n+\temit_jump_insn (gen_jump (lab2));\n+\temit_barrier ();\n+\temit_label (lab1);\n+\n+\t/* Now put in the code to restore the frame pointer, and argument\n+\t   pointer, if needed.  The code below is from expand_end_bindings\n+\t   in stmt.c; see detailed documentation there.  */\n+#ifdef HAVE_nonlocal_goto\n+\tif (! HAVE_nonlocal_goto)\n+#endif\n+\t  emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+\n+#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\tif (fixed_regs[ARG_POINTER_REGNUM])\n+\t  {\n+#ifdef ELIMINABLE_REGS\n+\t    static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+\t    int i;\n+\n+\t    for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n+\t      if (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t\t  && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n+\t\tbreak;\n+\n+\t    if (i == sizeof elim_regs / sizeof elim_regs [0])\n+#endif\n+\t      {\n+\t\t/* Now restore our arg pointer from the address at which it\n+\t\t   was saved in our stack frame.\n+\t\t   If there hasn't be space allocated for it yet, make\n+\t\t   some now.  */\n+\t\tif (arg_pointer_save_area == 0)\n+\t\t  arg_pointer_save_area\n+\t\t    = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\t\temit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t\tcopy_to_reg (arg_pointer_save_area));\n+\t      }\n+\t  }\n+#endif\n+\n+\t/* The result to return is in the static chain pointer.  */\n+\tif (GET_MODE (static_chain_rtx) == GET_MODE (target))\n+\t  emit_move_insn (target, static_chain_rtx);\n+\telse\n+\t  convert_move (target, static_chain_rtx, 0);\n+\n+\temit_label (lab2);\n+\treturn target;\n+      }\n+\n+      /* __builtin_longjmp is passed a pointer to an array of five words\n+\t and a value to return.  It's similar to the C library longjmp\n+\t function but works with __builtin_setjmp above.  */\n+    case BUILT_IN_LONGJMP:\n+      if (arglist == 0 || TREE_CHAIN (arglist) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+\tbreak;\n+\n+      {\n+\trtx buf_addr\n+\t  = force_reg (Pmode, expand_expr (TREE_VALUE (arglist), NULL_RTX,\n+\t\t\t\t\t   VOIDmode, 0));\n+\trtx fp = gen_rtx (MEM, Pmode, buf_addr);\n+\trtx lab = gen_rtx (MEM, Pmode,\n+\t\t\t   plus_constant (buf_addr, GET_MODE_SIZE (Pmode)));\n+\tenum machine_mode sa_mode\n+#ifdef HAVE_save_stack_nonlocal\n+\t  = (HAVE_save_stack_nonlocal\n+\t     ? insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0]\n+\t     : Pmode);\n+#else\n+\t= Pmode;\n+#endif\n+\trtx stack = gen_rtx (MEM, sa_mode,\n+\t\t\t     plus_constant (buf_addr,\n+\t\t\t\t\t    2 * GET_MODE_SIZE (Pmode)));\n+\trtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)), NULL_RTX,\n+\t\t\t\t VOIDmode, 0);\n+\n+\t/* Pick up FP, label, and SP from the block and jump.  This code is\n+\t   from expand_goto in stmt.c; see there for detailed comments.  */\n+#if HAVE_nonlocal_goto\n+\tif (HAVE_nonlocal_goto)\n+\t  emit_insn (gen_nonlocal_goto (fp, lab, stack, value));\n+      else\n+#endif\n+\t{\n+\t  emit_move_insn (hard_frame_pointer_rtx, fp);\n+\t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+\n+\t  /* Put in the static chain register the return value.  */\n+\t  emit_move_insn (static_chain_rtx, value);\n+\t  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n+\t  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+\t  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n+\t  emit_indirect_jump (copy_to_reg (lab));\n+\t}\n+\n+\treturn const0_rtx;\n+      }\n+\n     default:\t\t\t/* just do library call, if unknown builtin */\n       error (\"built-in function `%s' not currently supported\",\n \t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));"}]}