{"sha": "fad0afd7d72cb63e47e70795baac30cb2880314a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkMGFmZDdkNzJjYjYzZTQ3ZTcwNzk1YmFhYzMwY2IyODgwMzE0YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-12-09T17:08:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-12-09T17:08:06Z"}, "message": "re PR fortran/22244 (dimension information is lost for multi-dimension array)\n\n\tPR fortran/22244\n\t* langhooks-def.h (LANG_HOOKS_GET_ARRAY_DESCR_INFO): Define.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add it.\n\t* langhooks.h (struct array_descr_info): Forward declaration.\n\t(struct lang_hooks_for_types): Add get_array_descr_info field.\n\t* dwarf2.h (DW_AT_bit_stride, DW_AT_byte_stride): New.\n\t(DW_AT_stride_size, DW_AT_stride): Keep around for Dwarf2\n\tcompatibility.\n\t* dwarf2out.h (struct array_descr_info): New type.\n\t* dwarf2out.c (dwarf_attr_name): Rename DW_AT_stride to\n\tDW_AT_byte_stride and DW_AT_stride_size to DW_AT_bit_size.\n\t(descr_info_loc, add_descr_info_field, gen_descr_array_type_die):\n\tNew functions.\n\t(gen_type_die_with_usage): Call lang_hooks.types.get_array_descr_info\n\tand gen_descr_array_type_die.\n\n\t* trans.h (struct array_descr_info): Forward declaration.\n\t(gfc_get_array_descr_info): New prototype.\n\t(enum gfc_array_kind): New type.\n\t(struct lang_type): Add akind field.\n\t(GFC_TYPE_ARRAY_AKIND): Define.\n\t* trans-types.c: Include dwarf2out.h.\n\t(gfc_build_array_type): Add akind argument.  Adjust\n\tgfc_get_array_type_bounds call.\n\t(gfc_get_nodesc_array_type): Include proper debug info even for\n\tassumed-size arrays.\n\t(gfc_get_array_type_bounds): Add akind argument, set\n\tGFC_TYPE_ARRAY_AKIND to it.\n\t(gfc_sym_type, gfc_get_derived_type): Adjust gfc_build_array_type\n\tcallers.\n\t(gfc_get_array_descr_info): New function.\n\t* trans-array.c (gfc_trans_create_temp_array,\n\tgfc_conv_expr_descriptor): Adjust gfc_get_array_type_bounds\n\tcallers.\n\t* trans-stmt.c (gfc_trans_pointer_assign_need_temp): Likewise.\n\t* trans-types.h (gfc_get_array_type_bounds): Adjust prototype.\n\t* Make-lang.in (fortran/trans-types.o): Depend on dwarf2out.h.\n\t* f95-lang.c (LANG_HOOKS_GET_ARRAY_DESCR_INFO): Define.\n\nFrom-SVN: r130724", "tree": {"sha": "1bc6c1fd7fb20cdc492bba828c7b8463fdbc4d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bc6c1fd7fb20cdc492bba828c7b8463fdbc4d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fad0afd7d72cb63e47e70795baac30cb2880314a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad0afd7d72cb63e47e70795baac30cb2880314a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad0afd7d72cb63e47e70795baac30cb2880314a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad0afd7d72cb63e47e70795baac30cb2880314a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de80e4f820866d403b2bad4df3a59fc8b72f55f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de80e4f820866d403b2bad4df3a59fc8b72f55f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de80e4f820866d403b2bad4df3a59fc8b72f55f4"}], "stats": {"total": 436, "additions": 414, "deletions": 22}, "files": [{"sha": "1e480c3d350fa139915833bab26c60c8036e7dcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -1,3 +1,21 @@\n+2007-12-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/22244\n+\t* langhooks-def.h (LANG_HOOKS_GET_ARRAY_DESCR_INFO): Define.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add it.\n+\t* langhooks.h (struct array_descr_info): Forward declaration.\n+\t(struct lang_hooks_for_types): Add get_array_descr_info field.\n+\t* dwarf2.h (DW_AT_bit_stride, DW_AT_byte_stride): New.\n+\t(DW_AT_stride_size, DW_AT_stride): Keep around for Dwarf2\n+\tcompatibility.\n+\t* dwarf2out.h (struct array_descr_info): New type.\n+\t* dwarf2out.c (dwarf_attr_name): Rename DW_AT_stride to\n+\tDW_AT_byte_stride and DW_AT_stride_size to DW_AT_bit_size.\n+\t(descr_info_loc, add_descr_info_field, gen_descr_array_type_die):\n+\tNew functions.\n+\t(gen_type_die_with_usage): Call lang_hooks.types.get_array_descr_info\n+\tand gen_descr_array_type_die.\n+\n 2007-12-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/34391"}, {"sha": "89bc08a98e991423fe37a79d33348902ebe58960", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -274,7 +274,8 @@ enum dwarf_attribute\n     DW_AT_prototyped = 0x27,\n     DW_AT_return_addr = 0x2a,\n     DW_AT_start_scope = 0x2c,\n-    DW_AT_stride_size = 0x2e,\n+    DW_AT_bit_stride = 0x2e,\n+    DW_AT_stride_size = DW_AT_bit_stride,\n     DW_AT_upper_bound = 0x2f,\n     DW_AT_abstract_origin = 0x31,\n     DW_AT_accessibility = 0x32,\n@@ -309,7 +310,8 @@ enum dwarf_attribute\n     DW_AT_allocated     = 0x4e,\n     DW_AT_associated    = 0x4f,\n     DW_AT_data_location = 0x50,\n-    DW_AT_stride        = 0x51,\n+    DW_AT_byte_stride   = 0x51,\n+    DW_AT_stride        = DW_AT_byte_stride,\n     DW_AT_entry_pc      = 0x52,\n     DW_AT_use_UTF8      = 0x53,\n     DW_AT_extension     = 0x54,"}, {"sha": "d818f0d998958314def39671a81c205edac1fd99", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 173, "deletions": 4, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -4263,6 +4263,7 @@ static tree member_declared_type (const_tree);\n static const char *decl_start_label (tree);\n #endif\n static void gen_array_type_die (tree, dw_die_ref);\n+static void gen_descr_array_type_die (tree, struct array_descr_info *, dw_die_ref);\n #if 0\n static void gen_entry_point_die (tree, dw_die_ref);\n #endif\n@@ -4669,8 +4670,8 @@ dwarf_attr_name (unsigned int attr)\n       return \"DW_AT_return_addr\";\n     case DW_AT_start_scope:\n       return \"DW_AT_start_scope\";\n-    case DW_AT_stride_size:\n-      return \"DW_AT_stride_size\";\n+    case DW_AT_bit_stride:\n+      return \"DW_AT_bit_stride\";\n     case DW_AT_upper_bound:\n       return \"DW_AT_upper_bound\";\n     case DW_AT_abstract_origin:\n@@ -4738,8 +4739,8 @@ dwarf_attr_name (unsigned int attr)\n       return \"DW_AT_associated\";\n     case DW_AT_data_location:\n       return \"DW_AT_data_location\";\n-    case DW_AT_stride:\n-      return \"DW_AT_stride\";\n+    case DW_AT_byte_stride:\n+      return \"DW_AT_byte_stride\";\n     case DW_AT_entry_pc:\n       return \"DW_AT_entry_pc\";\n     case DW_AT_use_UTF8:\n@@ -11675,6 +11676,163 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     add_pubtype (type, array_die);\n }\n \n+static dw_loc_descr_ref\n+descr_info_loc (tree val, tree base_decl)\n+{\n+  HOST_WIDE_INT size;\n+  dw_loc_descr_ref loc, loc2;\n+  enum dwarf_location_atom op;\n+\n+  if (val == base_decl)\n+    return new_loc_descr (DW_OP_push_object_address, 0, 0);\n+\n+  switch (TREE_CODE (val))\n+    {\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      return descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n+    case INTEGER_CST:\n+      if (host_integerp (val, 0))\n+\treturn int_loc_descriptor (tree_low_cst (val, 0));\n+      break;\n+    case INDIRECT_REF:\n+      size = int_size_in_bytes (TREE_TYPE (val));\n+      if (size < 0)\n+\tbreak;\n+      loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n+      if (!loc)\n+\tbreak;\n+      if (size == DWARF2_ADDR_SIZE)\n+\tadd_loc_descr (&loc, new_loc_descr (DW_OP_deref, 0, 0));\n+      else\n+\tadd_loc_descr (&loc, new_loc_descr (DW_OP_deref_size, size, 0));\n+      return loc;\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+      if (host_integerp (TREE_OPERAND (val, 1), 1)\n+\t  && (unsigned HOST_WIDE_INT) tree_low_cst (TREE_OPERAND (val, 1), 1)\n+\t     < 16384)\n+\t{\n+\t  loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n+\t  if (!loc)\n+\t    break;\n+\t  add_loc_descr (&loc,\n+\t\t\t new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\ttree_low_cst (TREE_OPERAND (val, 1),\n+\t\t\t\t\t\t      1), 0));\n+\t}\n+      else\n+\t{\n+\t  op = DW_OP_plus;\n+\tdo_binop:\n+\t  loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n+\t  if (!loc)\n+\t    break;\n+\t  loc2 = descr_info_loc (TREE_OPERAND (val, 1), base_decl);\n+\t  if (!loc2)\n+\t    break;\n+\t  add_loc_descr (&loc, loc2);\n+\t  add_loc_descr (&loc2, new_loc_descr (op, 0, 0));\n+\t}\n+      return loc;\n+    case MINUS_EXPR:\n+      op = DW_OP_minus;\n+      goto do_binop;\n+    case MULT_EXPR:\n+      op = DW_OP_mul;\n+      goto do_binop;\n+    case EQ_EXPR:\n+      op = DW_OP_eq;\n+      goto do_binop;\n+    case NE_EXPR:\n+      op = DW_OP_ne;\n+      goto do_binop;\n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n+\n+static void\n+add_descr_info_field (dw_die_ref die, enum dwarf_attribute attr,\n+\t\t      tree val, tree base_decl)\n+{\n+  dw_loc_descr_ref loc;\n+\n+  if (host_integerp (val, 0))\n+    {\n+      add_AT_unsigned (die, attr, tree_low_cst (val, 0));\n+      return;\n+    }\n+\n+  loc = descr_info_loc (val, base_decl);\n+  if (!loc)\n+    return;\n+\n+  add_AT_loc (die, attr, loc);\n+}\n+\n+/* This routine generates DIE for array with hidden descriptor, details\n+   are filled into *info by a langhook.  */\n+\n+static void\n+gen_descr_array_type_die (tree type, struct array_descr_info *info,\n+\t\t\t  dw_die_ref context_die)\n+{\n+  dw_die_ref scope_die = scope_die_for (type, context_die);\n+  dw_die_ref array_die;\n+  int dim;\n+\n+  array_die = new_die (DW_TAG_array_type, scope_die, type);\n+  add_name_attribute (array_die, type_tag (type));\n+  equate_type_number_to_die (type, array_die);\n+\n+  if (info->data_location)\n+    add_descr_info_field (array_die, DW_AT_data_location, info->data_location,\n+\t\t\t  info->base_decl);\n+  if (info->associated)\n+    add_descr_info_field (array_die, DW_AT_associated, info->associated,\n+\t\t\t  info->base_decl);\n+  if (info->allocated)\n+    add_descr_info_field (array_die, DW_AT_allocated, info->allocated,\n+\t\t\t  info->base_decl);\n+\n+  for (dim = 0; dim < info->ndimensions; dim++)\n+    {\n+      dw_die_ref subrange_die\n+\t= new_die (DW_TAG_subrange_type, array_die, NULL);\n+\n+      if (info->dimen[dim].lower_bound)\n+\t{\n+\t  /* If it is the default value, omit it.  */\n+\t  if ((is_c_family () || is_java ())\n+\t      && integer_zerop (info->dimen[dim].lower_bound))\n+\t    ;\n+\t  else if (is_fortran ()\n+\t\t   && integer_onep (info->dimen[dim].lower_bound))\n+\t    ;\n+\t  else\n+\t    add_descr_info_field (subrange_die, DW_AT_lower_bound,\n+\t\t\t\t  info->dimen[dim].lower_bound,\n+\t\t\t\t  info->base_decl);\n+\t}\n+      if (info->dimen[dim].upper_bound)\n+\tadd_descr_info_field (subrange_die, DW_AT_upper_bound,\n+\t\t\t      info->dimen[dim].upper_bound,\n+\t\t\t      info->base_decl);\n+      if (info->dimen[dim].stride)\n+\tadd_descr_info_field (subrange_die, DW_AT_byte_stride,\n+\t\t\t      info->dimen[dim].stride,\n+\t\t\t      info->base_decl);\n+    }\n+\n+  gen_type_die (info->element_type, context_die);\n+  add_type_attribute (array_die, info->element_type, 0, 0, context_die);\n+\n+  if (get_AT (array_die, DW_AT_name))\n+    add_pubtype (type, array_die);\n+}\n+\n #if 0\n static void\n gen_entry_point_die (tree decl, dw_die_ref context_die)\n@@ -13051,6 +13209,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \t\t\t\tenum debug_info_usage usage)\n {\n   int need_pop;\n+  struct array_descr_info info;\n \n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n@@ -13069,6 +13228,16 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       return;\n     }\n \n+  /* If this is an array type with hidden descriptor, handle it first.  */\n+  if (!TREE_ASM_WRITTEN (type)\n+      && lang_hooks.types.get_array_descr_info\n+      && lang_hooks.types.get_array_descr_info (type, &info))\n+    {\n+      gen_descr_array_type_die (type, &info, context_die);\n+      TREE_ASM_WRITTEN (type) = 1;\n+      return;\n+    }\n+\n   /* We are going to output a DIE to represent the unqualified version\n      of this type (i.e. without any const or volatile qualifiers) so\n      get the main variant (i.e. the unqualified version) of this type"}, {"sha": "154bb143dbb4b28744ba3254e48f74d160c53d9e", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -25,3 +25,19 @@ extern void debug_dwarf (void);\n struct die_struct;\n extern void debug_dwarf_die (struct die_struct *);\n extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\n+\n+struct array_descr_info\n+{\n+  int ndimensions;\n+  tree element_type;\n+  tree base_decl;\n+  tree data_location;\n+  tree allocated;\n+  tree associated;\n+  struct array_descr_dimen\n+    {\n+      tree lower_bound;\n+      tree upper_bound;\n+      tree stride;\n+    } dimen[10];\n+};"}, {"sha": "4c184f85e7b39cc1c3d0447fafe3859f48bafb57", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -1,3 +1,29 @@\n+2007-12-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/22244\n+\t* trans.h (struct array_descr_info): Forward declaration.\n+\t(gfc_get_array_descr_info): New prototype.\n+\t(enum gfc_array_kind): New type.\n+\t(struct lang_type): Add akind field.\n+\t(GFC_TYPE_ARRAY_AKIND): Define.\n+\t* trans-types.c: Include dwarf2out.h.\n+\t(gfc_build_array_type): Add akind argument.  Adjust\n+\tgfc_get_array_type_bounds call.\n+\t(gfc_get_nodesc_array_type): Include proper debug info even for\n+\tassumed-size arrays.\n+\t(gfc_get_array_type_bounds): Add akind argument, set\n+\tGFC_TYPE_ARRAY_AKIND to it.\n+\t(gfc_sym_type, gfc_get_derived_type): Adjust gfc_build_array_type\n+\tcallers.\n+\t(gfc_get_array_descr_info): New function.\n+\t* trans-array.c (gfc_trans_create_temp_array,\n+\tgfc_conv_expr_descriptor): Adjust gfc_get_array_type_bounds\n+\tcallers.\n+\t* trans-stmt.c (gfc_trans_pointer_assign_need_temp): Likewise.\n+\t* trans-types.h (gfc_get_array_type_bounds): Adjust prototype.\n+\t* Make-lang.in (fortran/trans-types.o): Depend on dwarf2out.h.\n+\t* f95-lang.c (LANG_HOOKS_GET_ARRAY_DESCR_INFO): Define.\n+\n 2007-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/32129\n@@ -19,7 +45,6 @@\n \tPR fortran/34345\n \tPR fortran/18026\n \tPR fortran/29471\n-\n \t* gfortran.texi (BOZ literal constants): Improve documentation\n \tand adapt for BOZ changes.\n \t* Make-lang.ini (resolve.o): Add target-memory.h dependency."}, {"sha": "12bc91b1e56b3c9a978b4b714be6037bee93e4db", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -312,7 +312,7 @@ fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n   $(CGRAPH_H) $(TARGET_H) $(FUNCTION_H) $(FLAGS_H) $(RTL_H) $(TREE_GIMPLE_H) \\\n   $(TREE_DUMP_H)\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n-  $(REAL_H) toplev.h $(TARGET_H) $(FLAGS_H)\n+  $(REAL_H) toplev.h $(TARGET_H) $(FLAGS_H) dwarf2out.h\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h"}, {"sha": "a6523c90d30584f46e7ac95408744b5ba7990f18", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -120,6 +120,7 @@ static alias_set_type gfc_get_alias_set (tree);\n #undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n #undef LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GET_ARRAY_DESCR_INFO\n \n /* Define lang hooks.  */\n #define LANG_HOOKS_NAME                 \"GNU F95\"\n@@ -143,6 +144,7 @@ static alias_set_type gfc_get_alias_set (tree);\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   gfc_omp_firstprivatize_type_sizes\n #define LANG_HOOKS_BUILTIN_FUNCTION          gfc_builtin_function\n+#define LANG_HOOKS_GET_ARRAY_DESCR_INFO\t     gfc_get_array_descr_info\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "17a63d2e2f41a6beffe3ef2dadc0c83501d21d34", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -608,7 +608,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   /* Initialize the descriptor.  */\n   type =\n-    gfc_get_array_type_bounds (eltype, info->dimen, loop->from, loop->to, 1);\n+    gfc_get_array_type_bounds (eltype, info->dimen, loop->from, loop->to, 1,\n+\t\t\t       GFC_ARRAY_UNKNOWN);\n   desc = gfc_create_var (type, \"atmp\");\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n \n@@ -4783,7 +4784,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Otherwise make a new one.  */\n \t  parmtype = gfc_get_element_type (TREE_TYPE (desc));\n \t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n-\t\t\t\t\t\tloop.from, loop.to, 0);\n+\t\t\t\t\t\tloop.from, loop.to, 0,\n+\t\t\t\t\t\tGFC_ARRAY_UNKNOWN);\n \t  parm = gfc_create_var (parmtype, \"parm\");\n \t}\n "}, {"sha": "667866fdf055beab1bee5b86ed06f9b3dc834337", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -2525,7 +2525,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       /* Make a new descriptor.  */\n       parmtype = gfc_get_element_type (TREE_TYPE (desc));\n       parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n-                                            loop.from, loop.to, 1);\n+                                            loop.from, loop.to, 1,\n+\t\t\t\t\t    GFC_ARRAY_UNKNOWN);\n \n       /* Allocate temporary for nested forall construct.  */\n       tmp1 = allocate_temp_for_forall_nest (nested_forall_info, parmtype,"}, {"sha": "f0dbd3027e10b136049ac1a2d3ab27389d8f190e", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 145, "deletions": 9, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"real.h\"\n #include \"flags.h\"\n+#include \"dwarf2out.h\"\n \f\n \n #if (GFC_MAX_DIMENSIONS < 10)\n@@ -1047,7 +1048,8 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n /* Create an array descriptor type.  */\n \n static tree\n-gfc_build_array_type (tree type, gfc_array_spec * as)\n+gfc_build_array_type (tree type, gfc_array_spec * as,\n+\t\t      enum gfc_array_kind akind)\n {\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n@@ -1063,7 +1065,9 @@ gfc_build_array_type (tree type, gfc_array_spec * as)\n       ubound[n] = gfc_conv_array_bound (as->upper[n]);\n     }\n \n-  return gfc_get_array_type_bounds (type, as->rank, lbound, ubound, 0);\n+  if (as->type == AS_ASSUMED_SHAPE)\n+    akind = GFC_ARRAY_ASSUMED_SHAPE;\n+  return gfc_get_array_type_bounds (type, as->rank, lbound, ubound, 0, akind);\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n@@ -1246,7 +1250,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n       if (expr->expr_type == EXPR_CONSTANT)\n         {\n           tmp = gfc_conv_mpz_to_tree (expr->value.integer,\n-                                  gfc_index_integer_kind);\n+\t\t\t\t      gfc_index_integer_kind);\n         }\n       else\n         {\n@@ -1338,7 +1342,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n   /* In debug info represent packed arrays as multi-dimensional\n      if they have rank > 1 and with proper bounds, instead of flat\n      arrays.  */\n-  if (known_stride && write_symbols != NO_DEBUG)\n+  if (known_offset && write_symbols != NO_DEBUG)\n     {\n       tree gtype = etype, rtype, type_decl;\n \n@@ -1428,7 +1432,8 @@ gfc_get_array_descriptor_base (int dimen)\n \n tree\n gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n-\t\t\t   tree * ubound, int packed)\n+\t\t\t   tree * ubound, int packed,\n+\t\t\t   enum gfc_array_kind akind)\n {\n   char name[8 + GFC_RANK_DIGITS + GFC_MAX_SYMBOL_LEN];\n   tree fat_type, base_type, arraytype, lower, upper, stride, tmp;\n@@ -1455,6 +1460,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \n   GFC_TYPE_ARRAY_RANK (fat_type) = dimen;\n   GFC_TYPE_ARRAY_DTYPE (fat_type) = NULL_TREE;\n+  GFC_TYPE_ARRAY_AKIND (fat_type) = akind;\n \n   /* Build an array descriptor record type.  */\n   if (packed != 0)\n@@ -1573,9 +1579,14 @@ gfc_sym_type (gfc_symbol * sym)\n \t    }\n         }\n       else\n-      {\n-\ttype = gfc_build_array_type (type, sym->as);\n-    }\n+\t{\n+\t  enum gfc_array_kind akind = GFC_ARRAY_UNKNOWN;\n+\t  if (sym->attr.pointer)\n+\t    akind = GFC_ARRAY_POINTER;\n+\t  else if (sym->attr.allocatable)\n+\t    akind = GFC_ARRAY_ALLOCATABLE;\n+\t  type = gfc_build_array_type (type, sym->as, akind);\n+\t}\n     }\n   else\n     {\n@@ -1801,9 +1812,14 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t{\n \t  if (c->pointer || c->allocatable)\n \t    {\n+\t      enum gfc_array_kind akind;\n+\t      if (c->pointer)\n+\t\takind = GFC_ARRAY_POINTER;\n+\t      else\n+\t\takind = GFC_ARRAY_ALLOCATABLE;\n \t      /* Pointers to arrays aren't actually pointer types.  The\n \t         descriptors are separate, but the data is common.  */\n-\t      field_type = gfc_build_array_type (field_type, c->as);\n+\t      field_type = gfc_build_array_type (field_type, c->as, akind);\n \t    }\n \t  else\n \t    field_type = gfc_get_nodesc_array_type (field_type, c->as,\n@@ -2121,4 +2137,124 @@ gfc_type_for_mode (enum machine_mode mode, int unsignedp)\n   return NULL_TREE;\n }\n \n+/* Return TRUE if TYPE is a type with a hidden descriptor, fill in INFO\n+   in that case.  */\n+\n+bool\n+gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n+{\n+  int rank, dim;\n+  bool indirect = false;\n+  tree etype, ptype, field, t, base_decl;\n+  tree data_off, offset_off, dim_off, dim_size, elem_size;\n+  tree lower_suboff, upper_suboff, stride_suboff;\n+\n+  if (! GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      if (! POINTER_TYPE_P (type))\n+\treturn false;\n+      type = TREE_TYPE (type);\n+      if (! GFC_DESCRIPTOR_TYPE_P (type))\n+\treturn false;\n+      indirect = true;\n+    }\n+\n+  rank = GFC_TYPE_ARRAY_RANK (type);\n+  if (rank >= (int) (sizeof (info->dimen) / sizeof (info->dimen[0])))\n+    return false;\n+\n+  etype = GFC_TYPE_ARRAY_DATAPTR_TYPE (type);\n+  gcc_assert (POINTER_TYPE_P (etype));\n+  etype = TREE_TYPE (etype);\n+  gcc_assert (TREE_CODE (etype) == ARRAY_TYPE);\n+  etype = TREE_TYPE (etype);\n+  /* Can't handle variable sized elements yet.  */\n+  if (int_size_in_bytes (etype) <= 0)\n+    return false;\n+  /* Nor non-constant lower bounds in assumed shape arrays.  */\n+  if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE)\n+    {\n+      for (dim = 0; dim < rank; dim++)\n+\tif (GFC_TYPE_ARRAY_LBOUND (type, dim) == NULL_TREE\n+\t    || TREE_CODE (GFC_TYPE_ARRAY_LBOUND (type, dim)) != INTEGER_CST)\n+\t  return false;\n+    }\n+\n+  memset (info, '\\0', sizeof (*info));\n+  info->ndimensions = rank;\n+  info->element_type = etype;\n+  ptype = build_pointer_type (gfc_array_index_type);\n+  if (indirect)\n+    {\n+      info->base_decl = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t    build_pointer_type (ptype));\n+      base_decl = build1 (INDIRECT_REF, ptype, info->base_decl);\n+    }\n+  else\n+    info->base_decl = base_decl = build_decl (VAR_DECL, NULL_TREE, ptype);\n+\n+  elem_size = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (etype));\n+  field = TYPE_FIELDS (TYPE_MAIN_VARIANT (type));\n+  data_off = byte_position (field);\n+  field = TREE_CHAIN (field);\n+  offset_off = byte_position (field);\n+  field = TREE_CHAIN (field);\n+  field = TREE_CHAIN (field);\n+  dim_off = byte_position (field);\n+  dim_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (field)));\n+  field = TYPE_FIELDS (TREE_TYPE (TREE_TYPE (field)));\n+  stride_suboff = byte_position (field);\n+  field = TREE_CHAIN (field);\n+  lower_suboff = byte_position (field);\n+  field = TREE_CHAIN (field);\n+  upper_suboff = byte_position (field);\n+\n+  t = base_decl;\n+  if (!integer_zerop (data_off))\n+    t = build2 (POINTER_PLUS_EXPR, ptype, t, data_off);\n+  t = build1 (NOP_EXPR, build_pointer_type (ptr_type_node), t);\n+  info->data_location = build1 (INDIRECT_REF, ptr_type_node, t);\n+  if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n+    info->allocated = build2 (NE_EXPR, boolean_type_node,\n+\t\t\t      info->data_location, null_pointer_node);\n+  else if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER)\n+    info->associated = build2 (NE_EXPR, boolean_type_node,\n+\t\t\t       info->data_location, null_pointer_node);\n+\n+  for (dim = 0; dim < rank; dim++)\n+    {\n+      t = build2 (POINTER_PLUS_EXPR, ptype, base_decl,\n+\t\t  size_binop (PLUS_EXPR, dim_off, lower_suboff));\n+      t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n+      info->dimen[dim].lower_bound = t;\n+      t = build2 (POINTER_PLUS_EXPR, ptype, base_decl,\n+\t\t  size_binop (PLUS_EXPR, dim_off, upper_suboff));\n+      t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n+      info->dimen[dim].upper_bound = t;\n+      if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE)\n+\t{\n+\t  /* Assumed shape arrays have known lower bounds.  */\n+\t  info->dimen[dim].upper_bound\n+\t    = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t      info->dimen[dim].upper_bound,\n+\t\t      info->dimen[dim].lower_bound);\n+\t  info->dimen[dim].lower_bound\n+\t    = fold_convert (gfc_array_index_type,\n+\t\t\t    GFC_TYPE_ARRAY_LBOUND (type, dim));\n+\t  info->dimen[dim].upper_bound\n+\t    = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t      info->dimen[dim].lower_bound,\n+\t\t      info->dimen[dim].upper_bound);\n+\t}\n+      t = build2 (POINTER_PLUS_EXPR, ptype, base_decl,\n+\t\t  size_binop (PLUS_EXPR, dim_off, stride_suboff));\n+      t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n+      t = build2 (MULT_EXPR, gfc_array_index_type, t, elem_size);\n+      info->dimen[dim].stride = t;\n+      dim_off = size_binop (PLUS_EXPR, dim_off, dim_size);\n+    }\n+\n+  return true;\n+}\n+\n #include \"gt-fortran-trans-types.h\""}, {"sha": "87873060ac04ff08fdfc444849e622ef19b15aea", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -67,7 +67,8 @@ tree gfc_type_for_size (unsigned, int);\n tree gfc_type_for_mode (enum machine_mode, int);\n \n tree gfc_get_element_type (tree);\n-tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int);\n+tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int,\n+\t\t\t\tenum gfc_array_kind);\n tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed);\n \n /* Add a field of given name and type to a UNION_TYPE or RECORD_TYPE.  */"}, {"sha": "6d15fea9e9d9903bf264b99a92d9df68c5af3f76", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -483,6 +483,8 @@ tree poplevel (int, int, int);\n tree getdecls (void);\n tree gfc_truthvalue_conversion (tree);\n tree gfc_builtin_function (tree);\n+struct array_descr_info;\n+bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n \n /* In trans-openmp.c */\n bool gfc_omp_privatize_by_reference (const_tree);\n@@ -569,10 +571,19 @@ extern GTY(()) tree gfor_fndecl_sr_kind;\n \n /* G95-specific declaration information.  */\n \n+enum gfc_array_kind\n+{\n+  GFC_ARRAY_UNKNOWN,\n+  GFC_ARRAY_ASSUMED_SHAPE,\n+  GFC_ARRAY_ALLOCATABLE,\n+  GFC_ARRAY_POINTER\n+};\n+\n /* Array types only.  */\n struct lang_type\t\tGTY(())\n {\n   int rank;\n+  enum gfc_array_kind akind;\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n   tree stride[GFC_MAX_DIMENSIONS];\n@@ -626,7 +637,8 @@ struct lang_decl\t\tGTY(())\n #define GFC_TYPE_ARRAY_RANK(node) (TYPE_LANG_SPECIFIC(node)->rank)\n #define GFC_TYPE_ARRAY_SIZE(node) (TYPE_LANG_SPECIFIC(node)->size)\n #define GFC_TYPE_ARRAY_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->offset)\n-/* Code should use gfc_get_dtype instead of accesig this directly.  It may\n+#define GFC_TYPE_ARRAY_AKIND(node) (TYPE_LANG_SPECIFIC(node)->akind)\n+/* Code should use gfc_get_dtype instead of accesing this directly.  It may\n    not be known when the type is created.  */\n #define GFC_TYPE_ARRAY_DTYPE(node) (TYPE_LANG_SPECIFIC(node)->dtype)\n #define GFC_TYPE_ARRAY_DATAPTR_TYPE(node) \\"}, {"sha": "91357638622188ed62d8c24dba7b999715225539", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -180,6 +180,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   lhd_omp_firstprivatize_type_sizes\n #define LANG_HOOKS_TYPE_HASH_EQ\t\tNULL\n+#define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tNULL\n #define LANG_HOOKS_HASH_TYPES\t\ttrue\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n@@ -193,6 +194,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_TYPE_MAX_SIZE, \\\n   LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES, \\\n   LANG_HOOKS_TYPE_HASH_EQ, \\\n+  LANG_HOOKS_GET_ARRAY_DESCR_INFO, \\\n   LANG_HOOKS_HASH_TYPES \\\n }\n "}, {"sha": "0b97f26cabe42687fb52cb9211f44370d69a4a38", "filename": "gcc/langhooks.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad0afd7d72cb63e47e70795baac30cb2880314a/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=fad0afd7d72cb63e47e70795baac30cb2880314a", "patch": "@@ -28,6 +28,8 @@ struct diagnostic_info;\n \n struct gimplify_omp_ctx;\n \n+struct array_descr_info;\n+\n /* A print hook for print_tree ().  */\n typedef void (*lang_print_tree_hook) (FILE *, tree, int indent);\n \n@@ -136,6 +138,10 @@ struct lang_hooks_for_types\n      FUNCTION_TYPEs.  */\n   bool (*type_hash_eq) (const_tree, const_tree);\n \n+  /* Return TRUE if TYPE uses a hidden descriptor and fills in information\n+     for the debugger about the array bounds, strides, etc.  */\n+  bool (*get_array_descr_info) (const_tree, struct array_descr_info *);\n+\n   /* Nonzero if types that are identical are to be hashed so that only\n      one copy is kept.  If a language requires unique types for each\n      user-specified type, such as Ada, this should be set to TRUE.  */"}]}