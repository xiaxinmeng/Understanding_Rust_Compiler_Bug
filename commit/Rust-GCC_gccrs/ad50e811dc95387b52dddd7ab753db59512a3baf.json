{"sha": "ad50e811dc95387b52dddd7ab753db59512a3baf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ1MGU4MTFkYzk1Mzg3YjUyZGRkZDdhYjc1M2RiNTk1MTJhM2JhZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-31T01:30:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-31T01:30:59Z"}, "message": "cp-tree.h (DECL_EXTERNAL_LINKAGE_P): New macro.\n\n\t* cp-tree.h (DECL_EXTERNAL_LINKAGE_P): New macro.\n\t(linkage_kind): New enumeration.\n\t(decl_linkage): New function.\n\t* decl2.c (comdat_linkage): Extend comment.\n\t* error.c (dump_function_decl): Print the arguments used to\n\tinstantiate a template, even when not printing the type of the\n\tfunction.\n\t* pt.c (convert_nontype_argument): Use DECL_EXTERNAL_LINKAGE_P,\n\tnot TREE_PUBLIC, to test for external linkage.\n\t* tree.c (decl_linkage): New function.\n\nFrom-SVN: r37150", "tree": {"sha": "62873128afbebb3b4075750f0c2dbc4160b90b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62873128afbebb3b4075750f0c2dbc4160b90b4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad50e811dc95387b52dddd7ab753db59512a3baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad50e811dc95387b52dddd7ab753db59512a3baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad50e811dc95387b52dddd7ab753db59512a3baf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad50e811dc95387b52dddd7ab753db59512a3baf/comments", "author": null, "committer": null, "parents": [{"sha": "4bc950092b4a22757f6893f53c1d1ad8fd85381b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc950092b4a22757f6893f53c1d1ad8fd85381b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc950092b4a22757f6893f53c1d1ad8fd85381b"}], "stats": {"total": 153, "additions": 132, "deletions": 21}, "files": [{"sha": "9b560266f3384b9fbc04a966358a5f709e29d8b8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -1,3 +1,16 @@\n+2000-10-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (DECL_EXTERNAL_LINKAGE_P): New macro.\n+\t(linkage_kind): New enumeration.\n+\t(decl_linkage): New function.\n+\t* decl2.c (comdat_linkage): Extend comment.\n+\t* error.c (dump_function_decl): Print the arguments used to\n+\tinstantiate a template, even when not printing the type of the\n+\tfunction.\n+\t* pt.c (convert_nontype_argument): Use DECL_EXTERNAL_LINKAGE_P,\n+\tnot TREE_PUBLIC, to test for external linkage.\n+\t* tree.c (decl_linkage): New function.\n+\n 2000-10-28  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (instantiate_decl): Always instantiate static data members"}, {"sha": "fc3cd86934d89255c605723b7c5e7491fd8bf9d7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -2498,6 +2498,13 @@ extern int flag_new_for_scope;\n #define DECL_UNINLINABLE(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.uninlinable)\n \n+/* Returns non-zero if DECL has external linkage, as specified by the\n+   language standard.  (This predicate may hold even when the\n+   corresponding entity is not actually given external linkage in the\n+   object file; see decl_linkage for details.)  */\n+#define DECL_EXTERNAL_LINKAGE_P(DECL) \\\n+  (decl_linkage (DECL) == lk_external)\n+\n #define INTEGRAL_CODE_P(CODE) \\\n   (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n \n@@ -3145,6 +3152,29 @@ typedef enum special_function_kind {\n   sfk_conversion           /* A conversion operator.  */\n } special_function_kind;\n \n+/* The various kinds of linkage.  From [basic.link], \n+   \n+      A name is said to have linkage when it might denote the same\n+      object, reference, function, type, template, namespace or value\n+      as a name introduced in another scope:\n+\n+      -- When a name has external linkage, the entity it denotes can\n+         be referred to from scopes of other translation units or from\n+\t other scopes of the same translation unit.\n+\n+      -- When a name has internal linkage, the entity it denotes can\n+         be referred to by names from other scopes in the same\n+\t translation unit.\n+\n+      -- When a name has no linkage, the entity it denotes cannot be\n+         referred to by names from other scopes.  */\n+\n+typedef enum linkage_kind {\n+  lk_none,                 /* No linkage.  */\n+  lk_internal,             /* Internal linkage.  */\n+  lk_external              /* External linkage.  */\n+} linkage_kind;\n+\n /* Bitmask flags to pass to instantiate_type.  */\n typedef enum instantiate_type_flags {\n   itf_none = 0,               /* nothing special */\n@@ -4443,6 +4473,7 @@ extern int count_trees                          PARAMS ((tree));\n extern int char_type_p                          PARAMS ((tree));\n extern void verify_stmt_tree                    PARAMS ((tree));\n extern tree find_tree                           PARAMS ((tree, tree));\n+extern linkage_kind decl_linkage                PARAMS ((tree));\n \n /* in typeck.c */\n extern int string_conv_p\t\t\tPARAMS ((tree, tree, int));"}, {"sha": "0cfcc4dee586b84cc8c9599817d402499ca751bd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -2427,8 +2427,13 @@ comdat_linkage (decl)\n   if (flag_weak)\n     make_decl_one_only (decl);\n   else if (TREE_CODE (decl) == FUNCTION_DECL || DECL_VIRTUAL_P (decl))\n-    /* We can just emit functions and vtables statically; it doesn't really\n-       matter if we have multiple copies.  */\n+    /* We can just emit functions and vtables statically; having\n+       multiple copies is (for the most part) only a waste of space.\n+       There is at least one correctness issue, however: the address\n+       of a template instantiation with external linkage should be the\n+       same, independent of what translation unit asks for the\n+       address, and this will not hold when we emit multiple copies of\n+       the function.  However, there's little else we can do.  */\n     TREE_PUBLIC (decl) = 0;\n   else\n     {"}, {"sha": "6e7a4ae3245428ed2f1eaf2a686d99de667bed04", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -1284,27 +1284,28 @@ dump_function_decl (t, flags)\n \n   dump_function_name (t, flags);\n \n-  if (!(flags & TS_DECL_TYPE))\n-    return;\n-  if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n-    /* Skip \"this\" parameter.  */\n-    parmtypes = TREE_CHAIN (parmtypes);\n+  if (flags & TS_DECL_TYPE) \n+    {\n+      if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n+\t/* Skip \"this\" parameter.  */\n+\tparmtypes = TREE_CHAIN (parmtypes);\n \n-  /* Skip past the \"in_charge\" parameter.  */\n-  if (DECL_HAS_IN_CHARGE_PARM_P (t))\n-    parmtypes = TREE_CHAIN (parmtypes);\n+      /* Skip past the \"in_charge\" parameter.  */\n+      if (DECL_HAS_IN_CHARGE_PARM_P (t))\n+\tparmtypes = TREE_CHAIN (parmtypes);\n \n-  dump_parameters (parmtypes, flags);\n+      dump_parameters (parmtypes, flags);\n \n-  if (show_return)\n-    dump_type_suffix (TREE_TYPE (fntype), flags);\n+      if (show_return)\n+\tdump_type_suffix (TREE_TYPE (fntype), flags);\n \n-  if (TREE_CODE (fntype) == METHOD_TYPE)\n-    dump_qualifiers (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n-\t\t     before);\n+      if (TREE_CODE (fntype) == METHOD_TYPE)\n+\tdump_qualifiers (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n+\t\t\t before);\n \n-  if (flags & TS_FUNC_THROW)\n-    dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n+      if (flags & TS_FUNC_THROW)\n+\tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n+    }\n \n   /* If T is a template instantiation, dump the parameter binding.  */\n   if (template_parms != NULL_TREE && template_args != NULL_TREE)"}, {"sha": "303a3c65becbf0c9bc53ca8317eb63879982487b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -2808,7 +2808,7 @@ convert_nontype_argument (type, expr)\n \t;\n       else if (TREE_CODE (referent) != VAR_DECL)\n \tgoto bad_argument;\n-      else if (!TREE_PUBLIC (referent))\n+      else if (!DECL_EXTERNAL_LINKAGE_P (referent))\n \t{\n \t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n \t  return error_mark_node;\n@@ -2915,7 +2915,7 @@ convert_nontype_argument (type, expr)\n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n \n-\t    if (!TREE_PUBLIC (fn))\n+\t    if (!DECL_EXTERNAL_LINKAGE_P (fn))\n \t      {\n \t\tif (really_overloaded_fn (fns))\n \t\t  return error_mark_node;\n@@ -2980,7 +2980,7 @@ convert_nontype_argument (type, expr)\n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n \n-\t    if (!TREE_PUBLIC (fn))\n+\t    if (!DECL_EXTERNAL_LINKAGE_P (fn))\n \t      {\n \t\tif (really_overloaded_fn (expr))\n \t\t  /* Don't issue an error here; we might get a different"}, {"sha": "db5e33deee5f4cbcaed2e84687eff81b826b870c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -2597,3 +2597,46 @@ char_type_p (type)\n \t  || same_type_p (type, signed_char_type_node)\n \t  || same_type_p (type, wchar_type_node));\n }\n+\n+/* Returns the kind of linkage associated with the indicated DECL.  Th\n+   value returned is as specified by the language standard; it is\n+   independent of implementation details regarding template\n+   instantiation, etc.  For example, it is possible that a declaration\n+   to which this function assigns external linkage would not show up\n+   as a global symbol when you run `nm' on the resulting object file.  */\n+\n+linkage_kind\n+decl_linkage (decl)\n+     tree decl;\n+{\n+  /* This function doesn't attempt to calculate the linkage from first\n+     principles as given in [basic.link].  Instead, it makes use of\n+     the fact that we have already set TREE_PUBLIC appropriately, and\n+     then handles a few special cases.  Ideally, we would calculate\n+     linkage first, and then transform that into a concrete\n+     implementation.  */\n+\n+  /* Things that don't have names have no linkage.  */\n+  if (!DECL_NAME (decl))\n+    return lk_none;\n+\n+  /* Things that are TREE_PUBLIC have external linkage.  */\n+  if (TREE_PUBLIC (decl))\n+    return lk_external;\n+\n+  /* Some things that are not TREE_PUBLIC have external linkage, too.\n+     For example, on targets that don't have weak symbols, we make all\n+     template instantiations have internal linkage (in the object\n+     file), but the symbols should still be treated as having external\n+     linkage from the point of view of the language.  */\n+  if (DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n+    return lk_external;\n+\n+  /* Things in local scope do not have linkage, if they don't have\n+     TREE_PUBLIC set.  */\n+  if (decl_function_context (decl))\n+    return lk_none;\n+\n+  /* Everything else has internal linkage.  */\n+  return lk_internal;\n+}"}, {"sha": "65374ca6bd3663045775868ef0a49ba0cd604659", "filename": "gcc/testsuite/g++.old-deja/g++.other/linkage6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flinkage6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad50e811dc95387b52dddd7ab753db59512a3baf/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flinkage6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flinkage6.C?ref=ad50e811dc95387b52dddd7ab753db59512a3baf", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+// Special g++ Options: -fno-weak\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <typename T>\n+void f ();\n+\n+void h () { f<int> (); }\n+\n+template <void (*X)()>\n+void g () {}\n+\n+template <typename T>\n+void f ()\n+{\n+   g<&f<T> >();\n+}\n+"}]}