{"sha": "a7f875d76e7aabf635039360c0d49c00a93dac45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmODc1ZDc2ZTdhYWJmNjM1MDM5MzYwYzBkNDljMDBhOTNkYWM0NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T03:01:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T03:01:38Z"}, "message": "(expand_return): Correctly handle returning BLKmode structures in registers when...\n\n(expand_return): Correctly handle returning BLKmode structures in\nregisters when the size of the structure is not a multiple of\nword_size.\n\nFrom-SVN: r10052", "tree": {"sha": "eccc4d1255b23a4960414dcbc8fa4432bdc5cabe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eccc4d1255b23a4960414dcbc8fa4432bdc5cabe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f875d76e7aabf635039360c0d49c00a93dac45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f875d76e7aabf635039360c0d49c00a93dac45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f875d76e7aabf635039360c0d49c00a93dac45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f875d76e7aabf635039360c0d49c00a93dac45/comments", "author": null, "committer": null, "parents": [{"sha": "1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5c58730b1fa9c5ce060cf798bdebd9a501d73a"}], "stats": {"total": 79, "additions": 44, "deletions": 35}, "files": [{"sha": "02ac0e655d390633723815d42c6d426cf965f9de", "filename": "gcc/stmt.c", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f875d76e7aabf635039360c0d49c00a93dac45/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f875d76e7aabf635039360c0d49c00a93dac45/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a7f875d76e7aabf635039360c0d49c00a93dac45", "patch": "@@ -2722,51 +2722,60 @@ expand_return (retval)\n       && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n       && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)\n     {\n-      int i;\n+      int i, bitpos, xbitpos;\n       int big_endian_correction = 0;\n       int bytes = int_size_in_bytes (TREE_TYPE (retval_rhs));\n       int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)),BITS_PER_WORD);\n       rtx *result_pseudos = (rtx *) alloca (sizeof (rtx) * n_regs);\n-      rtx result_reg;\n+      rtx result_reg, src, dst;\n       rtx result_val = expand_expr (retval_rhs, NULL_RTX, VOIDmode, 0);\n       enum machine_mode tmpmode, result_reg_mode;\n \n-      /* Structures smaller than a word are aligned to the least significant\n-\t byte (to the right).  On a BYTES_BIG_ENDIAN machine, this means we\n-\t must skip the empty high order bytes when calculating the bit\n-\t offset.  */\n-      if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n-\tbig_endian_correction = (BITS_PER_WORD - (bytes * BITS_PER_UNIT));\n-\n-      for (i = 0; i < n_regs; i++)\n+      /* Structures whose size is not a multiple of a word are aligned\n+\t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n+\t machine, this means we must skip the empty high order bytes when\n+\t calculating the bit offset.  */\n+      if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n+\tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n+\t\t\t\t\t\t  * BITS_PER_UNIT));\n+\n+      /* Copy the structure BITSIZE bits at a time.  */ \n+      for (bitpos = 0, xbitpos = big_endian_correction;\n+\t   bitpos < bytes * BITS_PER_UNIT;\n+\t   bitpos += bitsize, xbitpos += bitsize)\n \t{\n-\t  rtx reg = gen_reg_rtx (word_mode);\n-\t  rtx word = operand_subword_force (result_val, i, BLKmode);\n-\t  int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)),BITS_PER_WORD);\n-\t  int bitpos;\n-\n-\t  result_pseudos[i] = reg;\n-\n-\t  /* Clobber REG and move each partword into it.  Ensure we don't\n-\t     go past the end of the structure.  Note that the loop below\n-\t     works because we've already verified that padding and\n-\t     endianness are compatible.  */\n-\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n-\n-\t  for (bitpos = 0;\n-\t       bitpos < BITS_PER_WORD && bytes > 0;\n-\t       bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n+\t  /* We need a new destination pseudo each time xbitpos is\n+\t     on a word boundary and when xbitpos == big_endian_corrction\n+\t     (the first time through).  */\n+\t  if (xbitpos % BITS_PER_WORD == 0\n+\t      || xbitpos == big_endian_correction)\n \t    {\n-\t      int xbitpos = bitpos + big_endian_correction;\n-\n-\t      store_bit_field (reg, bitsize, xbitpos, word_mode,\n-\t\t\t       extract_bit_field (word, bitsize, bitpos, 1,\n-\t\t\t\t\t\t  NULL_RTX, word_mode,\n-\t\t\t\t\t\t  word_mode,\n-\t\t\t\t\t\t  bitsize / BITS_PER_UNIT,\n-\t\t\t\t\t\t  BITS_PER_WORD),\n-\t\t\t       bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t      /* Generate an appropriate register.  */\n+\t      dst = gen_reg_rtx (word_mode);\n+\t      result_pseudos[xbitpos / BITS_PER_WORD] = dst;\n+\n+\t      /* Clobber the destination before we move anything into it.  */\n+\t      emit_insn (gen_rtx (CLOBBER, VOIDmode, dst));\n \t    }\n+\n+\t  /* We need a new source operand each time bitpos is on a word\n+\t     boundary.  */\n+\t  if (bitpos % BITS_PER_WORD == 0)\n+\t    src = operand_subword_force (result_val,\n+\t\t\t\t\t bitpos / BITS_PER_WORD,\n+\t\t\t\t\t BLKmode);\n+\n+\t  /* Use bitpos for the source extraction (left justified) and\n+\t     xbitpos for the destination store (right justified).  */\n+\t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, word_mode,\n+\t\t\t   extract_bit_field (src, bitsize,\n+\t\t\t\t\t      bitpos % BITS_PER_WORD, 1,\n+\t\t\t\t\t      NULL_RTX, word_mode,\n+\t\t\t\t\t      word_mode,\n+\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t      BITS_PER_WORD),\n+\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n \t}\n \n       /* Find the smallest integer mode large enough to hold the"}]}