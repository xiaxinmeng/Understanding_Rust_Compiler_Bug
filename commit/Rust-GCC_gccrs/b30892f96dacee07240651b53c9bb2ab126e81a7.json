{"sha": "b30892f96dacee07240651b53c9bb2ab126e81a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMwODkyZjk2ZGFjZWUwNzI0MDY1MWI1M2M5YmIyYWIxMjZlODFhNw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-13T21:49:33Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-13T21:49:33Z"}, "message": "cpphash.c (struct macro_info): Add new members.\n\n\t* cpphash.c (struct macro_info): Add new members.\n\t(_cpp_free_definition): Delete the macro directly.\n\t(count_params): Return void, with first token of\n\texpansion in struct macro_info on success.\n\t(parse_define): Return int.  Hoist syntax checking from\n\tsave_macro_expansion.  Leave call to save_expansion to\n\t_cpp_create_definition.\n\t(alloc_macro): Needs just 2 arguments.\n\t(free_macro): Delete.\n\t(save_expansion): Don't perform syntax check.\n\t(_cpp_create_definition): Call save_expansion.\n\nFrom-SVN: r35025", "tree": {"sha": "f9acfb6d447aca81bbc3a71865c143d49aede31d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9acfb6d447aca81bbc3a71865c143d49aede31d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b30892f96dacee07240651b53c9bb2ab126e81a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30892f96dacee07240651b53c9bb2ab126e81a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b30892f96dacee07240651b53c9bb2ab126e81a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30892f96dacee07240651b53c9bb2ab126e81a7/comments", "author": null, "committer": null, "parents": [{"sha": "3f6790bf93e3fd2ef4b6c8c076dd5e5defc56cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6790bf93e3fd2ef4b6c8c076dd5e5defc56cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6790bf93e3fd2ef4b6c8c076dd5e5defc56cf9"}], "stats": {"total": 313, "additions": 160, "deletions": 153}, "files": [{"sha": "5eb9f2b8df42a17ffa0227ce6a981254920781f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30892f96dacee07240651b53c9bb2ab126e81a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30892f96dacee07240651b53c9bb2ab126e81a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b30892f96dacee07240651b53c9bb2ab126e81a7", "patch": "@@ -1,3 +1,17 @@\n+2000-07-14  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.c (struct macro_info): Add new members.\n+\t(_cpp_free_definition): Delete the macro directly.\n+\t(count_params): Return void, with first token of\n+\texpansion in struct macro_info on success.\n+\t(parse_define): Return int.  Hoist syntax checking from\n+\tsave_macro_expansion.  Leave call to save_expansion to\n+\t_cpp_create_definition.\n+\t(alloc_macro): Needs just 2 arguments.\n+\t(free_macro): Delete.\n+\t(save_expansion): Don't perform syntax check.\n+\t(_cpp_create_definition): Call save_expansion.\n+\n 2000-07-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* genrecog.c (write_header): Split long string."}, {"sha": "8c4be523e4b7dac3cf8e60c53909c1b9acc9565c", "filename": "gcc/cpphash.c", "status": "modified", "additions": 146, "deletions": 153, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30892f96dacee07240651b53c9bb2ab126e81a7/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30892f96dacee07240651b53c9bb2ab126e81a7/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=b30892f96dacee07240651b53c9bb2ab126e81a7", "patch": "@@ -44,8 +44,12 @@ struct hashdummy\n /* Stores basic information about a macro, before it is allocated.  */\n struct macro_info\n {\n-  unsigned int paramlen;\n-  short paramc;\n+  const cpp_token *first_param;\t/* First parameter token.  */\n+  const cpp_token *first;\t/* First expansion token.  */\n+  unsigned int paramlen;\t/* Length of parameter names. */\n+  unsigned int len;\t\t/* Length of token strings.  */\n+  unsigned int ntokens;\t\t/* Number of tokens in expansion.  */\n+  short paramc;\t\t\t/* Number of parameters.  */\n   unsigned char flags;\n };\n \n@@ -55,26 +59,18 @@ struct macro_info\n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n-\n static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-\n-static const cpp_token *count_params PARAMS ((cpp_reader *,\n-\t\t\t\t\t      const cpp_token *,\n-\t\t\t\t\t      struct macro_info *));\n+static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n-static const cpp_toklist * parse_define PARAMS((cpp_reader *));\n+\n+static int parse_define PARAMS((cpp_reader *, struct macro_info *));\n static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n-\t\t\t\t\t     const cpp_toklist *));\n+\t\t\t\t\t    const cpp_toklist *));\n static const cpp_toklist * save_expansion PARAMS((cpp_reader *,\n-\t\t\t\t\t\t  const cpp_token *,\n-\t\t\t\t\t\t  const cpp_token *,\n-\t\t\t\t\t\t  struct macro_info *));\n+ \t\t\t\t\t\t  struct macro_info *));\n static unsigned int find_param PARAMS ((const cpp_token *,\n-\t\t\t\t\tconst cpp_token *));\n-static cpp_toklist * alloc_macro PARAMS ((cpp_reader *,\n-\t\t\t\t\t  struct macro_info *,\n-\t\t\t\t\t  unsigned int, unsigned int));\n-static void free_macro PARAMS((const cpp_toklist *));\n+ \t\t\t\t\tconst cpp_token *));\n+static cpp_toklist * alloc_macro PARAMS ((cpp_reader *, struct macro_info *));\n \n /* Calculate hash of a string of length LEN.  */\n unsigned int\n@@ -186,7 +182,7 @@ _cpp_free_definition (h)\n      cpp_hashnode *h;\n {\n   if (h->type == T_MACRO)\n-    free_macro (h->value.expansion);\n+    free ((PTR) h->value.expansion);\n   h->value.expansion = NULL;\n }\n \n@@ -231,29 +227,38 @@ is__va_args__ (pfile, token)\n /* Counts the parameters to a function-like macro, the length of their\n    null-terminated names, and whether the macro is a variable-argument\n    one.  FIRST is the token immediately after the open parenthesis,\n-   INFO stores the data, and should have paramlen and flags zero.\n+   INFO stores the data.\n \n-   Returns the token that we stopped scanning at; if it's type isn't\n-   CPP_CLOSE_PAREN there was an error, which has been reported.  */\n-static const cpp_token *\n-count_params (pfile, first, info)\n+   On success, info->first is updated to the token after the closing\n+   parenthesis, i.e. the first token of the expansion.  Otherwise\n+   there was an error, which has been reported.  */\n+static void\n+count_params (pfile, info)\n      cpp_reader *pfile;\n-     const cpp_token *first;\n      struct macro_info *info;\n {\n   unsigned int prev_ident = 0;\n   const cpp_token *token;\n \n   info->paramc = 0;\n-  for (token = first;; token++)\n+  info->paramlen = 0;\n+  info->flags = 0;\n+  info->first = info->first_param; /* Not a ')' indicating success.  */\n+\n+  for (token = info->first_param;; token++)\n     {\n       switch (token->type)\n \t{\n+\tdefault:\n+\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"illegal token in macro parameter list\");\n+\t  return;\n+\n \tcase CPP_EOF:\n \tmissing_paren:\n \t  cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t       \"missing ')' in macro parameter list\");\n-\t  goto out;\n+\t  return;\n \n \tcase CPP_COMMENT:\n \t  continue;\t\t/* Ignore -C comments.  */\n@@ -263,49 +268,41 @@ count_params (pfile, first, info)\n \t    {\n \t      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t   \"macro parameters must be comma-separated\");\n-\t      goto out;\n+\t      return;\n \t    }\n \n \t  /* Constraint 6.10.3.5  */\n \t  if (is__va_args__ (pfile, token))\n-\t    goto out;\n+\t    return;\n \n \t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n-\t  if (find_param (first, token))\n+\t  if (find_param (info->first, token))\n \t    {\n \t      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t\t   \"duplicate macro parameter \\\"%s\\\"\",\n \t\t\t\t   token->val.node->name);\n-\t      goto out;\n+\t      return;\n \t    }\n \n \t  prev_ident = 1;\n \t  info->paramc++;\n-\t  if (pfile->save_parameter_spellings)\n-\t    info->paramlen += token->val.node->length + 1;\n-\t  break;\n-\n-\tdefault:\n-\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"illegal token in macro parameter list\");\n-\t  goto out;\n+\t  info->paramlen += token->val.node->length + 1;\n+\t  continue;\n \n \tcase CPP_CLOSE_PAREN:\n \t  if (prev_ident || info->paramc == 0)\n-\t    goto out;\n+\t    break;\n \n \t  /* Fall through to pick up the error.  */\n \tcase CPP_COMMA:\n \t  if (!prev_ident)\n \t    {\n \t      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t\t   \"parameter name expected\");\n-\t      if (token->type == CPP_CLOSE_PAREN)\n-\t\ttoken--;\t\t/* Return the ',' not ')'.  */\n-\t      goto out;\n+\t      return;\n \t    }\n \t  prev_ident = 0;\n-\t  break;\n+\t  continue;\n \n \tcase CPP_ELLIPSIS:\n \t  /* Convert ISO-style var_args to named varargs by changing\n@@ -319,8 +316,7 @@ count_params (pfile, first, info)\n \t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n \n \t      info->paramc++;\n-\t      if (pfile->save_parameter_spellings)\n-\t\tinfo->paramlen += tok->val.node->length + 1;\n+\t      info->paramlen += tok->val.node->length + 1;\n \n \t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n \t\tcpp_pedwarn (pfile,\n@@ -337,57 +333,112 @@ count_params (pfile, first, info)\n \t  info->flags |= VAR_ARGS;\n \t  token++;\n \t  if (token->type == CPP_CLOSE_PAREN)\n-\t    goto out;\n+\t    break;\n \t  goto missing_paren;\n \t}\n-    }\n \n- out:\n-  return token;\n+      /* Success.  */\n+      info->first = token + 1;\n+      if (!pfile->save_parameter_spellings)\n+\tinfo->paramlen = 0;\n+      return;\n+    }\n }\n \n-/* Parses a #define directive.  Returns null pointer on error.  */\n-static const cpp_toklist *\n-parse_define (pfile)\n+/* Parses a #define directive.  On success, returns zero, and INFO is\n+   filled in appropriately.  */\n+static int\n+parse_define (pfile, info)\n      cpp_reader *pfile;\n+     struct macro_info *info;\n {\n-  const cpp_token *token, *first_param;\n-  struct macro_info info;\n+  const cpp_token *token;\n   int prev_white = 0;\n \n   /* The first token after the macro's name.  */\n   token = _cpp_get_token (pfile);\n \n   /* Constraint 6.10.3.5  */\n   if (is__va_args__ (pfile, token - 1))\n-    return 0;\n+    return 1;\n \n   while (token->type == CPP_COMMENT)\n     token++, prev_white = 1;\n-  first_param = token + 1;\n+  prev_white |= token->flags & PREV_WHITE;\n \n-  /* Assume object-like macro.  */\n-  info.paramc = -1;\n-  info.paramlen = 0;\n-  info.flags = 0;\n+  if (token->type == CPP_OPEN_PAREN && !prev_white)\n+    {\n+      /* A function-like macro.  */\n+      info->first_param = token + 1;\n+      count_params (pfile, info);\n+      if (info->first[-1].type != CPP_CLOSE_PAREN)\n+\treturn 1;\n+    }\n+  else\n+    {\n+      /* An object-like macro.  */\n+      info->paramc = -1;\n+      info->paramlen = 0;\n+      info->flags = 0;\n+      info->first = token;\n+      if (!prev_white && token->type != CPP_EOF)\n+\tcpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n+    }\n \n-  if (!prev_white && !(token->flags & PREV_WHITE))\n+  /* Count tokens in expansion.  We drop paste tokens, and stringize\n+     tokens, so don't count them.  */\n+  info->ntokens = info->len = 0;\n+  for (token = info->first; token->type != CPP_EOF; token++)\n     {\n-      if (token->type == CPP_OPEN_PAREN)\n+      if (token->type == CPP_PASTE)\n \t{\n-\t  token = count_params (pfile, first_param, &info);\n-\t  if (token->type != CPP_CLOSE_PAREN)\n-\t    return 0;\n-\t  token++;\n+\t  /* Token-paste ##, can appear in both object-like and\n+\t     function-like macros, but not at the ends.  Constraint\n+\t     6.10.3.3.1 */\n+\t  if (token == info->first || token[1].type == CPP_EOF)\n+\t    {\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\"'##' cannot appear at either end of a macro expansion\");\n+\t      return 1;\n+\t    }\n+\t  continue;\n+\t}\n+      else if (token->type == CPP_HASH)\n+\t{\n+\t  /* Stringifying #, but a normal character in object-like\n+             macros.  Must come before a parameter name.  Constraint\n+             6.10.3.2.1.  */\n+\t  if (info->paramc >= 0)\n+\t    {\n+\t      if (token[1].type == CPP_NAME\n+\t\t  && find_param (info->first_param, token + 1))\n+\t\tcontinue;\n+\t      if (! CPP_OPTION (pfile, lang_asm))\n+\t\t{\n+\t\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"'#' is not followed by a macro parameter\");\n+\t\t  return 1;\n+\t\t}\n+\t    }\n \t}\n-      else if (token->type != CPP_EOF)\n-\tcpp_pedwarn (pfile,\n-\t\t     \"ISO C requires whitespace after the macro name\");\n+      else if (token->type == CPP_NAME)\n+\t{\n+\t  /* Constraint 6.10.3.5  */\n+\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n+\t    return 1;\n+\t  /* It might be worth doing a check here that we aren't a\n+\t     macro argument, since we don't store the text of macro\n+\t     arguments.  This would reduce \"len\" and save space.  */\n+\t}\n+      info->ntokens++;\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n+\tinfo->len += token->val.str.len;\n     }\n-\n-  return save_expansion (pfile, token, first_param, &info);\n+  \n+  return 0;\n }\n \n+/* Returns non-zero if a macro redefinition is trivial.  */\n static int\n check_macro_redefinition (pfile, hp, list2)\n      cpp_reader *pfile;\n@@ -434,28 +485,31 @@ struct toklist_dummy\n    reasons.  Therefore, this token list cannot be expanded like a\n    normal token list.  Try to do so, and you lose.  */\n static cpp_toklist *\n-alloc_macro (pfile, info, ntokens, len)\n+alloc_macro (pfile, info)\n      cpp_reader *pfile;\n      struct macro_info *info;\n-     unsigned int ntokens, len;\n {\n   unsigned int size;\n   struct toklist_dummy *dummy;\n   cpp_toklist *list;\n \n+  /* Empty macros become a single placemarker token.  */\n+  if (info->ntokens == 0)\n+    info->ntokens = 1;\n+\n   size = sizeof (struct toklist_dummy);\n-  size += (ntokens - 1) * sizeof(cpp_token);\n-  size += len + info->paramlen;\n+  size += (info->ntokens - 1) * sizeof(cpp_token);\n+  size += info->len + info->paramlen;\n \n   dummy = (struct toklist_dummy *) xmalloc (size);\n   list = (cpp_toklist *) dummy;\n   \n   /* Initialize the monster.  */\n   list->tokens = &dummy->first_token;\n-  list->tokens_used = list->tokens_cap = ntokens;\n+  list->tokens_used = list->tokens_cap = info->ntokens;\n \n-  list->namebuf = (unsigned char *) &list->tokens[ntokens];\n-  list->name_used = list->name_cap = len + info->paramlen;\n+  list->namebuf = (unsigned char *) &list->tokens[info->ntokens];\n+  list->name_used = list->name_cap = info->len + info->paramlen;\n \n   list->directive = 0;\n   list->line = pfile->token_list.line;\n@@ -467,96 +521,32 @@ alloc_macro (pfile, info, ntokens, len)\n   return list;\n }\n \n-/* Free a macro allocated by allocate_macro.  */\n-static void\n-free_macro (list)\n-     const cpp_toklist *list;\n-{\n-  free ((PTR) list);\n-}\n-\n-/* Copy the tokens of the expansion, beginning with FIRST until\n-   CPP_EOF.  For a function-like macro, FIRST_PARAM points to the\n-   first parameter.  INFO contains information about the macro.\n+/* Copy the tokens of the expansion, beginning with info->first until\n+   CPP_EOF.  INFO contains information about the macro.\n \n    Change the type of macro arguments in the expansion from CPP_NAME\n    to CPP_MACRO_ARG.  Remove #'s that represent stringification,\n    flagging the CPP_MACRO_ARG it operates on STRINGIFY.  Remove ##'s,\n    flagging the token on its immediate left PASTE_LEFT.  Returns the\n-   token list for the macro expansion, or 0 on error.  */\n+   token list for the macro expansion.  */\n static const cpp_toklist *\n-save_expansion (pfile, first, first_param, info)\n+save_expansion (pfile, info)\n      cpp_reader *pfile;\n-     const cpp_token *first;\n-     const cpp_token *first_param;\n      struct macro_info *info;\n {\n   const cpp_token *token;\n   cpp_toklist *list;\n   cpp_token *dest;\n-  unsigned int len, ntokens;\n   unsigned char *buf;\n       \n-  /* Count tokens in expansion.  We drop paste tokens, and stringize\n-     tokens, so don't count them.  */\n-  ntokens = len = 0;\n-  for (token = first; token->type != CPP_EOF; token++)\n-    {\n-      if (token->type == CPP_PASTE)\n-\t{\n-\t  /* Token-paste ##, can appear in both object-like and\n-\t     function-like macros, but not at the ends.  Constraint\n-\t     6.10.3.3.1 */\n-\t  if (token == first || token[1].type == CPP_EOF)\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\"'##' cannot appear at either end of a macro expansion\");\n-\t      return 0;\n-\t    }\n-\t  continue;\n-\t}\n-      else if (token->type == CPP_HASH)\n-\t{\n-\t  /* Stringifying #, but a normal character in object-like\n-             macros.  Must come before a parameter name.  Constraint\n-             6.10.3.2.1.  */\n-\t  if (info->paramc >= 0)\n-\t    {\n-\t      if (token[1].type == CPP_NAME\n-\t\t  && find_param (first_param, token + 1))\n-\t\tcontinue;\n-\t      if (! CPP_OPTION (pfile, lang_asm))\n-\t\t{\n-\t\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"'#' is not followed by a macro parameter\");\n-\t\t  return 0;\n-\t\t}\n-\t    }\n-\t}\n-      else if (token->type == CPP_NAME)\n-\t{\n-\t  /* Constraint 6.10.3.5  */\n-\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n-\t    return 0;\n-\t  /* It might be worth doing a check here that we aren't a\n-\t     macro argument, since we don't store the text of macro\n-\t     arguments.  This would reduce \"len\" and save space.  */\n-\t}\n-      ntokens++;\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\tlen += token->val.str.len;\n-    }\n-\n-  if (ntokens == 0)\n-    ntokens++;\n-  list = alloc_macro (pfile, info, ntokens, len);\n+  list = alloc_macro (pfile, info);\n   buf = list->namebuf;\n \n   /* Store the null-terminated parameter spellings of a macro, to\n      provide pedantic warnings to satisfy 6.10.3.2, or for use when\n      dumping macro definitions.  They must go first.  */\n   if (list->params_len)\n-    for (token = first_param; token < first; token++)\n+    for (token = info->first_param; token < info->first; token++)\n       if (token->type == CPP_NAME)\n \t{\n \t  /* Copy null too.  */\n@@ -565,7 +555,7 @@ save_expansion (pfile, first, first_param, info)\n \t}\n \n   dest = list->tokens;\n-  for (token = first; token->type != CPP_EOF; token++)\n+  for (token = info->first; token->type != CPP_EOF; token++)\n     {\n       unsigned int param_no;\n \n@@ -576,7 +566,7 @@ save_expansion (pfile, first, first_param, info)\n \t    break;\n \n \t  /* Check if the name is a macro parameter.  */\n-\t  param_no = find_param (first_param, token);\n+\t  param_no = find_param (info->first_param, token);\n \t  if (param_no == 0)\n \t    break;\n \t  dest->val.aux = param_no - 1;\n@@ -596,7 +586,7 @@ save_expansion (pfile, first, first_param, info)\n \tcase CPP_HASH:\n \t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n \t  if (list->paramc >= 0 && token[1].type == CPP_NAME\n-\t      && find_param (first_param, token + 1))\n+\t      && find_param (info->first_param, token + 1))\n \t    continue;\n \t  break;\n \n@@ -615,6 +605,7 @@ save_expansion (pfile, first, first_param, info)\n       dest++;\n     }\n \n+  /* Empty macros become a single placemarker token.  */\n   if (dest == list->tokens)\n     {\n       dest->type = CPP_PLACEMARKER;\n@@ -624,16 +615,18 @@ save_expansion (pfile, first, first_param, info)\n   return list;\n }\n \n+/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n int\n _cpp_create_definition (pfile, hp)\n      cpp_reader *pfile;\n      cpp_hashnode *hp;\n {\n+  struct macro_info info;\n   const cpp_toklist *list;\n \n-  list = parse_define (pfile);\n-  if (!list)\n+  if (parse_define (pfile, &info))\n     return 0;\n+  list = save_expansion (pfile, &info);\n \n   /* Check for a redefinition.  Redefinition of a macro is allowed if\n      and only if the old and new definitions are the same."}]}