{"sha": "8ace67ddb97698709a622b2f8ba2718524aa5eeb", "node_id": "C_kwDOANBUbNoAKDhhY2U2N2RkYjk3Njk4NzA5YTYyMmIyZjhiYTI3MTg1MjRhYTVlZWI", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-27T17:39:59Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-29T13:53:27Z"}, "message": "OpenACC: whole struct vs. component mappings (PR107028)\n\nThis patch fixes an ICE when both a complete struct variable and\ncomponents of that struct are mapped on the same directive for OpenACC,\nusing a modified version of the scheme used for OpenMP in the following\npatch:\n\n  https://gcc.gnu.org/pipermail/gcc-patches/2022-September/601558.html\n\nA new function has been added to make sure that the mapping kinds of\nthe whole struct and the member access are compatible -- conservatively,\nso as not to copy more to/from the device than the user expects.\n\nThis version of the patch uses a different method to detect duplicate\nclauses for OpenACC in oacc_resolve_clause_dependencies, and removes\nthe now-redundant check in omp_accumulate_sibling_lists.  (The latter\ncheck would no longer trigger when we map the whole struct on the same\ndirective because the component-mapping clauses are now deleted before\nthe check is executed.)\n\n2022-09-28  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\tPR middle-end/107028\n\t* gimplify.cc (omp_check_mapping_compatibility,\n\toacc_resolve_clause_dependencies): New functions.\n\t(omp_accumulate_sibling_list): Remove redundant duplicate clause\n\tdetection for OpenACC.\n\t(build_struct_sibling_lists): Skip deleted groups.  Don't build sibling\n\tlist for struct variables that are fully mapped on the same directive\n\tfor OpenACC.\n\t(gimplify_scan_omp_clauses): Call oacc_resolve_clause_dependencies.\n\ngcc/testsuite/\n\tPR middle-end/107028\n\t* c-c++-common/goacc/struct-component-kind-1.c: New test.\n\t* g++.dg/goacc/pr107028-1.C: New test.\n\t* g++.dg/goacc/pr107028-2.C: New test.\n\t* gfortran.dg/goacc/mapping-tests-5.f90: New test.", "tree": {"sha": "863dc9626b2e252a660f1d00a0256aa1ca0bac0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/863dc9626b2e252a660f1d00a0256aa1ca0bac0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ace67ddb97698709a622b2f8ba2718524aa5eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ace67ddb97698709a622b2f8ba2718524aa5eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ace67ddb97698709a622b2f8ba2718524aa5eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ace67ddb97698709a622b2f8ba2718524aa5eeb/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca147154074a0de548138b4e73477e94903a855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca147154074a0de548138b4e73477e94903a855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca147154074a0de548138b4e73477e94903a855"}], "stats": {"total": 305, "additions": 268, "deletions": 37}, "files": [{"sha": "90606088128985e4469ec1c22a157d299e1ff260", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 140, "deletions": 37, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=8ace67ddb97698709a622b2f8ba2718524aa5eeb", "patch": "@@ -9861,6 +9861,134 @@ omp_lastprivate_for_combined_outer_constructs (struct gimplify_omp_ctx *octx,\n     omp_notice_variable (octx, decl, true);\n }\n \n+/* If we have mappings INNER and OUTER, where INNER is a component access and\n+   OUTER is a mapping of the whole containing struct, check that the mappings\n+   are compatible.  We'll be deleting the inner mapping, so we need to make\n+   sure the outer mapping does (at least) the same transfers to/from the device\n+   as the inner mapping.  */\n+\n+bool\n+omp_check_mapping_compatibility (location_t loc,\n+\t\t\t\t omp_mapping_group *outer,\n+\t\t\t\t omp_mapping_group *inner)\n+{\n+  tree first_outer = *outer->grp_start, first_inner = *inner->grp_start;\n+\n+  gcc_assert (OMP_CLAUSE_CODE (first_outer) == OMP_CLAUSE_MAP);\n+  gcc_assert (OMP_CLAUSE_CODE (first_inner) == OMP_CLAUSE_MAP);\n+\n+  enum gomp_map_kind outer_kind = OMP_CLAUSE_MAP_KIND (first_outer);\n+  enum gomp_map_kind inner_kind = OMP_CLAUSE_MAP_KIND (first_inner);\n+\n+  if (outer_kind == inner_kind)\n+    return true;\n+\n+  switch (outer_kind)\n+    {\n+    case GOMP_MAP_ALWAYS_TO:\n+      if (inner_kind == GOMP_MAP_FORCE_PRESENT\n+\t  || inner_kind == GOMP_MAP_ALLOC\n+\t  || inner_kind == GOMP_MAP_TO)\n+\treturn true;\n+      break;\n+\n+    case GOMP_MAP_ALWAYS_FROM:\n+      if (inner_kind == GOMP_MAP_FORCE_PRESENT\n+\t  || inner_kind == GOMP_MAP_ALLOC\n+\t  || inner_kind == GOMP_MAP_FROM)\n+\treturn true;\n+      break;\n+\n+    case GOMP_MAP_TO:\n+    case GOMP_MAP_FROM:\n+      if (inner_kind == GOMP_MAP_FORCE_PRESENT\n+\t  || inner_kind == GOMP_MAP_ALLOC)\n+\treturn true;\n+      break;\n+\n+    case GOMP_MAP_ALWAYS_TOFROM:\n+    case GOMP_MAP_TOFROM:\n+      if (inner_kind == GOMP_MAP_FORCE_PRESENT\n+\t  || inner_kind == GOMP_MAP_ALLOC\n+\t  || inner_kind == GOMP_MAP_TO\n+\t  || inner_kind == GOMP_MAP_FROM\n+\t  || inner_kind == GOMP_MAP_TOFROM)\n+\treturn true;\n+      break;\n+\n+    default:\n+      ;\n+    }\n+\n+  error_at (loc, \"data movement for component %qE is not compatible with \"\n+\t    \"movement for struct %qE\", OMP_CLAUSE_DECL (first_inner),\n+\t    OMP_CLAUSE_DECL (first_outer));\n+\n+  return false;\n+}\n+\n+/* Similar to omp_resolve_clause_dependencies, but for OpenACC.  The only\n+   clause dependencies we handle for now are struct element mappings and\n+   whole-struct mappings on the same directive, and duplicate clause\n+   detection.  */\n+\n+void\n+oacc_resolve_clause_dependencies (vec<omp_mapping_group> *groups,\n+\t\t\t\t  hash_map<tree_operand_hash,\n+\t\t\t\t\t   omp_mapping_group *> *grpmap)\n+{\n+  int i;\n+  omp_mapping_group *grp;\n+  hash_set<tree_operand_hash> *seen_components = NULL;\n+  hash_set<tree_operand_hash> *shown_error = NULL;\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      tree grp_end = grp->grp_end;\n+      tree decl = OMP_CLAUSE_DECL (grp_end);\n+\n+      gcc_assert (OMP_CLAUSE_CODE (grp_end) == OMP_CLAUSE_MAP);\n+\n+      if (DECL_P (grp_end))\n+\tcontinue;\n+\n+      tree c = OMP_CLAUSE_DECL (*grp->grp_start);\n+      while (TREE_CODE (c) == ARRAY_REF)\n+\tc = TREE_OPERAND (c, 0);\n+      if (TREE_CODE (c) != COMPONENT_REF)\n+\tcontinue;\n+      if (!seen_components)\n+\tseen_components = new hash_set<tree_operand_hash> ();\n+      if (!shown_error)\n+\tshown_error = new hash_set<tree_operand_hash> ();\n+      if (seen_components->contains (c)\n+\t  && !shown_error->contains (c))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t    \"%qE appears more than once in map clauses\",\n+\t\t    OMP_CLAUSE_DECL (grp_end));\n+\t  shown_error->add (c);\n+\t}\n+      else\n+\tseen_components->add (c);\n+\n+      omp_mapping_group *struct_group;\n+      if (omp_mapped_by_containing_struct (grpmap, decl, &struct_group)\n+\t  && *grp->grp_start == grp_end)\n+\t{\n+\t  omp_check_mapping_compatibility (OMP_CLAUSE_LOCATION (grp_end),\n+\t\t\t\t\t   struct_group, grp);\n+\t  /* Remove the whole of this mapping -- redundant.  */\n+\t  grp->deleted = true;\n+\t}\n+    }\n+\n+  if (seen_components)\n+    delete seen_components;\n+  if (shown_error)\n+    delete shown_error;\n+}\n+\n /* Link node NEWNODE so it is pointed to by chain INSERT_AT.  NEWNODE's chain\n    is linked to the previous node pointed to by INSERT_AT.  */\n \n@@ -10238,37 +10366,6 @@ omp_accumulate_sibling_list (enum omp_region_type region_type,\n \t      break;\n \t    if (scp)\n \t      continue;\n-\t    if ((region_type & ORT_ACC) != 0)\n-\t      {\n-\t\t/* This duplicate checking code is currently only enabled for\n-\t\t   OpenACC.  */\n-\t\ttree d1 = OMP_CLAUSE_DECL (*sc);\n-\t\ttree d2 = OMP_CLAUSE_DECL (grp_end);\n-\t\twhile (TREE_CODE (d1) == ARRAY_REF)\n-\t\t  d1 = TREE_OPERAND (d1, 0);\n-\t\twhile (TREE_CODE (d2) == ARRAY_REF)\n-\t\t  d2 = TREE_OPERAND (d2, 0);\n-\t\tif (TREE_CODE (d1) == INDIRECT_REF)\n-\t\t  d1 = TREE_OPERAND (d1, 0);\n-\t\tif (TREE_CODE (d2) == INDIRECT_REF)\n-\t\t  d2 = TREE_OPERAND (d2, 0);\n-\t\twhile (TREE_CODE (d1) == COMPONENT_REF)\n-\t\t  if (TREE_CODE (d2) == COMPONENT_REF\n-\t\t      && TREE_OPERAND (d1, 1) == TREE_OPERAND (d2, 1))\n-\t\t    {\n-\t\t      d1 = TREE_OPERAND (d1, 0);\n-\t\t      d2 = TREE_OPERAND (d2, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\tif (d1 == d2)\n-\t\t  {\n-\t\t    error_at (OMP_CLAUSE_LOCATION (grp_end),\n-\t\t\t      \"%qE appears more than once in map clauses\",\n-\t\t\t      OMP_CLAUSE_DECL (grp_end));\n-\t\t    return NULL;\n-\t\t  }\n-\t      }\n \t    if (maybe_lt (coffset, offset)\n \t\t|| (known_eq (coffset, offset)\n \t\t    && maybe_lt (cbitpos, bitpos)))\n@@ -10400,6 +10497,11 @@ omp_build_struct_sibling_lists (enum tree_code code,\n       if (DECL_P (decl))\n \tcontinue;\n \n+      /* Skip groups we marked for deletion in\n+\t oacc_resolve_clause_dependencies.  */\n+      if (grp->deleted)\n+\tcontinue;\n+\n       if (OMP_CLAUSE_CHAIN (*grp_start_p)\n \t  && OMP_CLAUSE_CHAIN (*grp_start_p) != grp_end)\n \t{\n@@ -10436,14 +10538,14 @@ omp_build_struct_sibling_lists (enum tree_code code,\n       if (TREE_CODE (decl) != COMPONENT_REF)\n \tcontinue;\n \n-      /* If we're mapping the whole struct in another node, skip creation of\n-\t sibling lists.  */\n+      /* If we're mapping the whole struct in another node, skip adding this\n+\t node to a sibling list.  */\n       omp_mapping_group *wholestruct;\n-      if (!(region_type & ORT_ACC)\n-\t  && omp_mapped_by_containing_struct (*grpmap, OMP_CLAUSE_DECL (c),\n-\t\t\t\t\t      &wholestruct))\n+      if (omp_mapped_by_containing_struct (*grpmap, OMP_CLAUSE_DECL (c),\n+\t\t\t\t\t   &wholestruct))\n \t{\n-\t  if (*grp_start_p == grp_end)\n+\t  if (!(region_type & ORT_ACC)\n+\t      && *grp_start_p == grp_end)\n \t    /* Remove the whole of this mapping -- redundant.  */\n \t    grp->deleted = true;\n \n@@ -10632,6 +10734,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n \n+\t  oacc_resolve_clause_dependencies (groups, grpmap);\n \t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap,\n \t\t\t\t\t  list_p);\n "}, {"sha": "8d2f5ea64973c6cf2bd63c78027f4e4bc2b30e9b", "filename": "gcc/testsuite/c-c++-common/goacc/struct-component-kind-1.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fstruct-component-kind-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fstruct-component-kind-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fstruct-component-kind-1.c?ref=8ace67ddb97698709a622b2f8ba2718524aa5eeb", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+\n+#include <stdlib.h>\n+\n+#define N 20\n+\n+struct s {\n+  int base[N];\n+};\n+\n+int main (void)\n+{\n+  struct s v;\n+\n+#pragma acc parallel copy(v, v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copyin(v, v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copyout(v, v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copy(v) copyin(v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copy(v) copyout(v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copy(v) present(v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copyin(v) present(v.base[0:N])\n+{ }\n+\n+#pragma acc parallel copyout(v) present(v.base[0:N])\n+{ }\n+\n+#pragma acc enter data copyin(v, v.base[0:N])\n+#pragma acc update device(v, v.base[0:N])\n+#pragma acc exit data delete(v, v.base[0:N])\n+\n+#pragma acc parallel copyin(v) copy(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel copyout(v) copy(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel present(v) copy(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel present(v) copyin(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel present(v) copyout(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel present(v) no_create(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+#pragma acc parallel no_create(v) present(v.base[0:N])\n+/* { dg-error \"data movement for component 'v\\\\.(s::)?base\\\\\\[0\\\\\\]' is not compatible with movement for struct 'v'\" \"\" { target *-*-* } .-1 } */\n+{ }\n+\n+  return 0;\n+}"}, {"sha": "93b87439b4f34fc126c06cb2f95cc9c6a9493b5a", "filename": "gcc/testsuite/g++.dg/goacc/pr107028-1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-1.C?ref=8ace67ddb97698709a622b2f8ba2718524aa5eeb", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+class data_container {\n+ public:\n+  int data;\n+};\n+\n+void test2() {\n+  data_container a;\n+#pragma acc data copyin(a, a.data)\n+// { dg-final { scan-tree-dump {map\\(to:a \\[len: [0-9]+\\]\\)} \"gimple\" } }\n+{ }\n+}"}, {"sha": "cf741bd78c7a905e139a71d106df49ca8cf3a4b9", "filename": "gcc/testsuite/g++.dg/goacc/pr107028-2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fpr107028-2.C?ref=8ace67ddb97698709a622b2f8ba2718524aa5eeb", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+#include <cstdlib>\n+\n+typedef float real_t;\n+\n+struct foo {\n+  real_t *data;\n+};\n+\n+#define n 1024\n+\n+int test3() {\n+    real_t *a = (real_t *)malloc(n * sizeof(real_t));\n+    struct foo b;\n+    b.data = (real_t *)malloc(n * sizeof(real_t));\n+\n+    #pragma acc data copyin(a[0:n], b, b.data[0:n])\n+// { dg-final { scan-tree-dump {map\\(to:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(attach:b.data \\[bias: 0\\]\\) map\\(to:b \\[len: [0-9]+\\]\\) map\\(to:\\*a \\[len: [0-9]+\\]\\)} \"gimple\" } }\n+    { }\n+\n+    free (b.data);\n+    free (a);\n+\n+    return 0;\n+}"}, {"sha": "8df8c5885ad2f72e66c176b0455d5b643da64353", "filename": "gcc/testsuite/gfortran.dg/goacc/mapping-tests-5.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fmapping-tests-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ace67ddb97698709a622b2f8ba2718524aa5eeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fmapping-tests-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fmapping-tests-5.f90?ref=8ace67ddb97698709a622b2f8ba2718524aa5eeb", "patch": "@@ -0,0 +1,15 @@\n+subroutine foo\n+  type one\n+    integer, dimension(10) :: i, j\n+  end type\n+  type two\n+    type(one) A, B\n+  end type\n+\n+  type(two) x\n+\n+  !$acc enter data copyin(x%A%i(5), x%A%i(4), x%A)\n+! { dg-error \".x.a.i. appears more than once in map clauses\" \"\" { target *-*-* } .-1 }\n+  !$acc enter data copyin(x%A, x%A%i(5), x%A%i(4))\n+! { dg-error \".x.a.i. appears more than once in map clauses\" \"\" { target *-*-* } .-1 }\n+end"}]}