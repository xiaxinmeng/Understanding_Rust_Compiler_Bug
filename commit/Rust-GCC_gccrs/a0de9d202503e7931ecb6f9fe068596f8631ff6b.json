{"sha": "a0de9d202503e7931ecb6f9fe068596f8631ff6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkZTlkMjAyNTAzZTc5MzFlY2I2ZjlmZTA2ODU5NmY4NjMxZmY2Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-12-13T01:37:52Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-12-13T01:37:52Z"}, "message": "decl.c (store_parm_decls): Remove parms_have_cleanups cruft.\n\n        * decl.c (store_parm_decls): Remove parms_have_cleanups cruft.\n        * semantics.c (genrtl_start_function): Don't pass\n        parms_have_cleanups or push an extra binding level.\n        (genrtl_finish_function): Lose cleanup_label cruft.\n\n        * cp-tree.h (struct cp_language_function): Remove x_ctor_label.\n        (ctor_label): Remove.\n        * semantics.c (finish_return_stmt): Lose ctor_label support.\n        * decl.c (finish_constructor_body, mark_lang_function): Likewise.\n        * typeck.c (check_return_expr): Check DECL_DESTRUCTOR_P, not\n        dtor_label.\n\n        * call.c (build_new_method_call): Let resolves_to_fixed_type_p\n        check for [cd]tors.\n        * class.c (fixed_type_or_null, case INDIRECT_REF): Fix.\n\n        * decl.c (finish_function): Check VMS_TARGET, not VMS.\n\n        * decl.c (start_cleanup_fn): Remove redundant pushlevel.\n        (end_cleanup_fn): And poplevel.\n\n        * semantics.c (setup_vtbl_ptr): Always build a CTOR_INITIALIZER\n        if we're in a template.\n\nFrom-SVN: r47962", "tree": {"sha": "4280f3d0abd19266afffae466528ebbb6dca66f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4280f3d0abd19266afffae466528ebbb6dca66f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0de9d202503e7931ecb6f9fe068596f8631ff6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0de9d202503e7931ecb6f9fe068596f8631ff6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0de9d202503e7931ecb6f9fe068596f8631ff6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0de9d202503e7931ecb6f9fe068596f8631ff6b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aff8a8d52b650e3ba60cb8b864f244bf23b67acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff8a8d52b650e3ba60cb8b864f244bf23b67acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff8a8d52b650e3ba60cb8b864f244bf23b67acd"}], "stats": {"total": 204, "additions": 67, "deletions": 137}, "files": [{"sha": "3a06bacf698f33ae7ab85102ca1fff87321e75a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -1,3 +1,29 @@\n+2001-12-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* decl.c (store_parm_decls): Remove parms_have_cleanups cruft.\n+\t* semantics.c (genrtl_start_function): Don't pass\n+\tparms_have_cleanups or push an extra binding level.\n+\t(genrtl_finish_function): Lose cleanup_label cruft.\n+\n+\t* cp-tree.h (struct cp_language_function): Remove x_ctor_label.\n+\t(ctor_label): Remove.\n+\t* semantics.c (finish_return_stmt): Lose ctor_label support.\n+\t* decl.c (finish_constructor_body, mark_lang_function): Likewise.\n+\t* typeck.c (check_return_expr): Check DECL_DESTRUCTOR_P, not \n+\tdtor_label.\n+\n+\t* call.c (build_new_method_call): Let resolves_to_fixed_type_p\n+\tcheck for [cd]tors.\n+\t* class.c (fixed_type_or_null, case INDIRECT_REF): Fix.\n+\n+\t* decl.c (finish_function): Check VMS_TARGET, not VMS.\n+\n+\t* decl.c (start_cleanup_fn): Remove redundant pushlevel.\n+\t(end_cleanup_fn): And poplevel.\n+\n+\t* semantics.c (setup_vtbl_ptr): Always build a CTOR_INITIALIZER\n+\tif we're in a template.\n+\n 2001-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cp-tree.h (DESTRUCTOR_DECL_PREFIX, DESTRUCTOR_NAME_P,"}, {"sha": "8b1e2bb081440ad9dc10bded9f65f054fe39831c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -4660,8 +4660,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     }\n \n   if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n-      && ((instance == current_class_ref && (dtor_label || ctor_label))\n-\t  || resolves_to_fixed_type_p (instance, 0)))\n+      && resolves_to_fixed_type_p (instance, 0))\n     flags |= LOOKUP_NONVIRTUAL;\n \n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE)"}, {"sha": "0b0d33f60313571ab5189ea5c125e10f64a3b245", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -5287,11 +5287,12 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n   switch (TREE_CODE (instance))\n     {\n     case INDIRECT_REF:\n-      /* Check that we are not going through a cast of some sort.  */\n-      if (TREE_TYPE (instance)\n-\t  == TREE_TYPE (TREE_TYPE (TREE_OPERAND (instance, 0))))\n-\tinstance = TREE_OPERAND (instance, 0);\n-      /* fall through...  */\n+      if (POINTER_TYPE_P (instance))\n+\treturn NULL_TREE;\n+      else\n+\treturn fixed_type_or_null (TREE_OPERAND (instance, 0),\n+\t\t\t\t   nonnull, cdtorp);\n+\n     case CALL_EXPR:\n       /* This is a call to a constructor, hence it's never zero.  */\n       if (TREE_HAS_CONSTRUCTOR (instance))"}, {"sha": "b68e0badb21a5f1e8e3478d411e26799e416d597", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -801,7 +801,6 @@ struct cp_language_function\n {\n   struct language_function base;\n \n-  tree x_ctor_label;\n   tree x_dtor_label;\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n@@ -836,11 +835,6 @@ struct cp_language_function\n \n #define dtor_label cp_function_chain->x_dtor_label\n \n-/* In a constructor, the point at which we are ready to return\n-   the pointer to the initialized object.  */\n-\n-#define ctor_label cp_function_chain->x_ctor_label\n-\n /* When we're processing a member function, current_class_ptr is the\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */"}, {"sha": "7e9692dbf8b9da56a595cce9690a5017429a602e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -8418,7 +8418,6 @@ start_cleanup_fn ()\n \n   pushdecl (fndecl);\n   start_function (/*specs=*/NULL_TREE, fndecl, NULL_TREE, SF_PRE_PARSED);\n-  do_pushlevel ();\n \n   interface_unknown = old_interface_unknown;\n \n@@ -8432,8 +8431,6 @@ start_cleanup_fn ()\n static void\n end_cleanup_fn ()\n {\n-  do_poplevel ();\n-\n   expand_body (finish_function (0));\n \n   pop_from_top_level ();\n@@ -13794,7 +13791,6 @@ store_parm_decls (current_function_parms)\n {\n   register tree fndecl = current_function_decl;\n   register tree parm;\n-  int parms_have_cleanups = 0;\n   tree cleanups = NULL_TREE;\n \n   /* This is a chain of any other decls that came in among the parm\n@@ -13875,11 +13871,6 @@ store_parm_decls (current_function_parms)\n       cleanups = TREE_CHAIN (cleanups);\n     }\n \n-  /* Create a binding contour which can be used to catch\n-     cleanup-generated temporaries.  */\n-  if (parms_have_cleanups)\n-    pushlevel (0);\n-\n   /* Do the starting of the exception specifications, if we have any.  */\n   if (flag_exceptions && !processing_template_decl\n       && flag_enforce_eh_specs\n@@ -13935,16 +13926,6 @@ save_function_data (decl)\n static void\n finish_constructor_body ()\n {\n-  /* Any return from a constructor will end up here.  */\n-  if (ctor_label)\n-    add_stmt (build_stmt (LABEL_STMT, ctor_label));\n-\n-  /* Clear CTOR_LABEL so that finish_return_stmt knows to really\n-     generate the return, rather than a goto to CTOR_LABEL.  */\n-  ctor_label = NULL_TREE;\n-  /* In check_return_expr we translate an empty return from a\n-     constructor to a return of `this'.  */\n-  finish_return_stmt (NULL_TREE);\n   /* Mark the end of the constructor.  */\n   add_stmt (build_stmt (CTOR_STMT));\n }\n@@ -14124,7 +14105,7 @@ finish_function (flags)\n       else if (DECL_MAIN_P (fndecl))\n \t{\n \t  /* Make it so that `main' always returns 0 by default.  */\n-#ifdef VMS\n+#ifdef VMS_TARGET\n \t  finish_return_stmt (integer_one_node);\n #else\n \t  finish_return_stmt (integer_zero_node);\n@@ -14575,7 +14556,6 @@ mark_lang_function (p)\n \n   mark_c_language_function (&p->base);\n \n-  ggc_mark_tree (p->x_ctor_label);\n   ggc_mark_tree (p->x_dtor_label);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);"}, {"sha": "0cef1e3d5e1b8ddcfde1d58addb1b8d13c97c742", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -462,6 +462,7 @@ use_thunk (thunk_fndecl, emit_p)\n     DECL_RESULT (thunk_fndecl) = NULL_TREE;\n \n     start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n+    /* We don't bother with a body block for thunks.  */\n \n     /* Adjust the this pointer by the constant.  */\n     t = ssize_int (delta);"}, {"sha": "8dc792adb3127ba7531b9d54185a2fd2116a462e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 31, "deletions": 102, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -390,17 +390,7 @@ finish_return_stmt (expr)\n     expr = check_return_expr (expr);\n   if (!processing_template_decl)\n     {\n-      if (DECL_CONSTRUCTOR_P (current_function_decl) && ctor_label)\n-\t{\n-\t  /* Even returns without a value in a constructor must return\n-\t     `this'.  We accomplish this by sending all returns in a\n-\t     constructor to the CTOR_LABEL; finish_function emits code to\n-\t     return a value there.  When we finally generate the real\n-\t     return statement, CTOR_LABEL is no longer set, and we fall\n-\t     through into the normal return-processing code below.  */\n-\t  return finish_goto_stmt (ctor_label);\n-\t}\n-      else if (DECL_DESTRUCTOR_P (current_function_decl))\n+      if (DECL_DESTRUCTOR_P (current_function_decl))\n \t{\n \t  /* Similarly, all destructors must run destructors for\n \t     base-classes before returning.  So, all returns in a\n@@ -678,7 +668,7 @@ finish_cleanup (cleanup, try_block)\n \n void\n finish_function_try_block (try_block)\n-     tree try_block; \n+     tree try_block;\n {\n   if (TREE_CHAIN (try_block) \n       && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n@@ -1155,9 +1145,12 @@ finish_mem_initializers (init_list)\n   setup_vtbl_ptr (member_init_list, base_init_list);\n }\n \n-/* Cache the value of this class's main virtual function table pointer\n-   in a register variable.  This will save one indirection if a\n-   more than one virtual function call is made this function.  */\n+/* Do the initialization work necessary at the beginning of a constructor\n+   or destructor.  This means processing member initializers and setting\n+   vtable pointers.\n+\n+   ??? The call to keep_next_level at the end applies to all functions, but\n+   should probably go somewhere else.  */\n \n void\n setup_vtbl_ptr (member_init_list, base_init_list)\n@@ -1166,31 +1159,26 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n {\n   my_friendly_assert (doing_semantic_analysis_p (), 19990919);\n \n-  /* If we've already done this, there's no need to do it again.  */\n+  /* If we've already done this, break.  */\n   if (vtbls_set_up_p)\n-    return;\n+    abort ();\n \n-  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+  if (processing_template_decl)\n+    add_stmt (build_min_nt (CTOR_INITIALIZER,\n+\t\t\t    member_init_list, base_init_list));\n+  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n-      if (processing_template_decl)\n-\tadd_stmt (build_min_nt\n-\t\t  (CTOR_INITIALIZER,\n-\t\t   member_init_list, base_init_list));\n-      else\n-\t{\n-\t  tree ctor_stmt;\n+      tree ctor_stmt;\n \n-\t  /* Mark the beginning of the constructor.  */\n-\t  ctor_stmt = build_stmt (CTOR_STMT);\n-\t  CTOR_BEGIN_P (ctor_stmt) = 1;\n-\t  add_stmt (ctor_stmt);\n+      /* Mark the beginning of the constructor.  */\n+      ctor_stmt = build_stmt (CTOR_STMT);\n+      CTOR_BEGIN_P (ctor_stmt) = 1;\n+      add_stmt (ctor_stmt);\n \t  \n-\t  /* And actually initialize the base-classes and members.  */\n-\t  emit_base_init (member_init_list, base_init_list);\n-\t}\n+      /* And actually initialize the base-classes and members.  */\n+      emit_base_init (member_init_list, base_init_list);\n     }\n-  else if (DECL_DESTRUCTOR_P (current_function_decl)\n-\t   && !processing_template_decl)\n+  else if (DECL_DESTRUCTOR_P (current_function_decl))\n     {\n       tree if_stmt;\n       tree compound_stmt;\n@@ -1203,7 +1191,11 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n \t virtual dispatch to an overridden function that would need to\n \t have a non-related vtable set up, we cannot avoid setting up\n \t vtables in that case.  We could change this to see if there\n-\t is just one vtable.  */\n+\t is just one vtable.\n+\n+         ??? In the destructor for a class, the vtables are set\n+         appropriately for that class.  There will be no non-related\n+         vtables.  jason 2001-12-11.  */\n       if_stmt = begin_if_stmt ();\n \n       /* If it is not safe to avoid setting up the vtables, then\n@@ -2618,23 +2610,10 @@ genrtl_start_function (fn)\n \n   /* Create a binding level for the parameters.  */\n   expand_start_bindings (2);\n-  /* Go through the PARM_DECLs for this function to see if any need\n-     cleanups.  */\n-  for (parm = DECL_ARGUMENTS (fn); parm; parm = TREE_CHAIN (parm))\n-    if (TREE_TYPE (parm) != error_mark_node\n-\t&& TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (parm)))\n-      {\n-\texpand_function_start (fn, /*parms_have_cleanups=*/1);\n-\tbreak;\n-      }\n-  if (!parm)\n-    expand_function_start (fn, /*parms_have_cleanups=*/0);\n+  expand_function_start (fn, /*parms_have_cleanups=*/0);\n   /* If this function is `main'.  */\n   if (DECL_MAIN_P (fn))\n     expand_main_function ();\n-  /* Create a binding contour which can be used to catch\n-     cleanup-generated temporaries.  */\n-  expand_start_bindings (2);\n \n   /* Give our named return value the same RTL as our RESULT_DECL.  */\n   if (current_function_return_value)\n@@ -2647,7 +2626,6 @@ static void\n genrtl_finish_function (fn)\n      tree fn;\n {\n-  tree no_return_label = NULL_TREE;\n   tree t;\n \n #if 0\n@@ -2676,59 +2654,10 @@ genrtl_finish_function (fn)\n   /* Clean house because we will need to reorder insns here.  */\n   do_pending_stack_adjust ();\n \n-  if (!dtor_label && !DECL_CONSTRUCTOR_P (fn)\n-      && return_label != NULL_RTX\n-      && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n-    no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-  /* If this function is supposed to return a value, ensure that\n-     we do not fall into the cleanups by mistake.  The end of our\n-     function will look like this:\n-\n-     user code (may have return stmt somewhere)\n-     goto no_return_label\n-     cleanup_label:\n-     cleanups\n-     goto return_label\n-     no_return_label:\n-     NOTE_INSN_FUNCTION_END\n-     return_label:\n-     things for return\n-\n-     If the user omits a return stmt in the USER CODE section, we\n-     will have a control path which reaches NOTE_INSN_FUNCTION_END.\n-     Otherwise, we won't.  */\n-  if (no_return_label)\n-    {\n-      DECL_CONTEXT (no_return_label) = fn;\n-      DECL_INITIAL (no_return_label) = error_mark_node;\n-      DECL_SOURCE_FILE (no_return_label) = input_filename;\n-      DECL_SOURCE_LINE (no_return_label) = lineno;\n-      expand_goto (no_return_label);\n-    }\n-\n-  if (cleanup_label)\n-    {\n-      /* Remove the binding contour which is used to catch\n-\t cleanup-generated temporaries.  */\n-      expand_end_bindings (0, 0, 0);\n-      poplevel (0, 0, 0);\n-\n-      /* Emit label at beginning of cleanup code for parameters.  */\n-      emit_label (cleanup_label);\n-    }\n-\n-  /* Finish building code that will trigger warnings if users forget\n-     to make their functions return values.  */\n-  if (return_label)\n+  /* If we have a named return value, we need to force a return so that\n+     the return register is USEd.  */\n+  if (DECL_NAME (DECL_RESULT (fn)))\n     emit_jump (return_label);\n-  if (no_return_label)\n-    {\n-      /* We don't need to call `expand_*_return' here because we don't\n-\t need any cleanups here--this path of code is only for error\n-\t checking purposes.  */\n-      expand_label (no_return_label);\n-    }\n \n   /* We hard-wired immediate_size_expand to zero in start_function.\n      Expand_function_end will decrement this variable.  So, we set the"}, {"sha": "04a70304dbd0967c552cb98d9a67a0cb5a1a826c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0de9d202503e7931ecb6f9fe068596f8631ff6b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a0de9d202503e7931ecb6f9fe068596f8631ff6b", "patch": "@@ -6585,7 +6585,7 @@ check_return_expr (retval)\n     warning (\"function declared `noreturn' has a `return' statement\");\n \n   /* Check for various simple errors.  */\n-  if (dtor_label)\n+  if (DECL_DESTRUCTOR_P (current_function_decl))\n     {\n       if (retval)\n \terror (\"returning a value from a destructor\");"}]}