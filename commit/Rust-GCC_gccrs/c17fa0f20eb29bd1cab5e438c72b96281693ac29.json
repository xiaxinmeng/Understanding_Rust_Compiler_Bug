{"sha": "c17fa0f20eb29bd1cab5e438c72b96281693ac29", "node_id": "C_kwDOANBUbNoAKGMxN2ZhMGYyMGViMjliZDFjYWI1ZTQzOGM3MmI5NjI4MTY5M2FjMjk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-12T21:55:53Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-12T21:55:53Z"}, "message": "c++: remove '_sfinae' suffix from functions\n\nThe functions\n\n  abstract_virtuals_error\n  cxx_constant_value\n  get_target_expr\n  instantiate_non_dependent_expr\n  require_complete_type\n\nare each just a non-SFINAE-enabled wrapper for the corresponding\nSFINAE-enabled version that's suffixed by '_sfinae'.  But this suffix is\nat best redundant since a 'complain' parameter already broadly conveys\nthat a function is SFINAE-enabled, and having two such versions of a\nfunction is less concise than just using a default argument for 'complain'\n(and arguably no less mistake prone).\n\nSo this patch squashes the two versions of each of the above functions\nby adding a default 'complain' argument to the SFINAE-enabled version\nwhose '_sfinae' suffix we then remove.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (build_conditional_expr): Adjust calls to\n\t'_sfinae'-suffixed functions.\n\t(build_temp): Likewise.\n\t(convert_like_internal): Likewise.\n\t(convert_arg_to_ellipsis): Likewise.\n\t(build_over_call): Likewise.\n\t(build_cxx_call): Likewise.\n\t(build_new_method_call): Likewise.\n\t* constexpr.cc (cxx_eval_outermost_constant_expr): Likewise.\n\t(cxx_constant_value_sfinae): Rename to ...\n\t(cxx_constant_value): ... this.  Document its default arguments.\n\t(fold_non_dependent_expr): Adjust function comment.\n\t* cp-tree.h (instantiate_non_dependent_expr_sfinae): Rename to ...\n\t(instantiate_non_dependent_expr): ... this.  Give its 'complain'\n\tparameter a default argument.\n\t(get_target_expr_sfinae, get_target_expr): Likewise.\n\t(require_complete_type_sfinae, require_complete_type): Likewise.\n\t(abstract_virtuals_error_sfinae, abstract_virtuals_error):\n\tLikewise.\n\t(cxx_constant_value_sfinae, cxx_constant_value): Likewise.\n\t* cvt.cc (build_up_reference): Adjust calls to '_sfinae'-suffixed\n\tfunctions.\n\t(ocp_convert): Likewise.\n\t* decl.cc (build_explicit_specifier): Likewise.\n\t* except.cc (build_noexcept_spec): Likewise.\n\t* init.cc (build_new_1): Likewise.\n\t* pt.cc (expand_integer_pack): Likewise.\n\t(instantiate_non_dependent_expr_internal): Adjust function\n\tcomment.\n\t(instantiate_non_dependent_expr): Rename to ...\n\t(instantiate_non_dependent_expr_sfinae): ... this.  Document its\n\tdefault argument.\n\t(tsubst_init): Adjust calls to '_sfinae'-suffixed functions.\n\t(fold_targs_r): Likewise.\n\t* semantics.cc (finish_compound_literal): Likewise.\n\t(finish_decltype_type): Likewise.\n\t(cp_build_bit_cast): Likewise.\n\t* tree.cc (build_cplus_new): Likewise.\n\t(get_target_expr): Rename to ...\n\t(get_target_expr_sfinae): ... this.  Document its default\n\targument.\n\t* typeck.cc (require_complete_type): Rename to ...\n\t(require_complete_type_sfinae): ... this.  Document its default\n\targument.\n\t(cp_build_array_ref): Adjust calls to '_sfinae'-suffixed\n\tfunctions.\n\t(convert_arguments): Likewise.\n\t(cp_build_binary_op): Likewise.\n\t(build_static_cast_1): Likewise.\n\t(cp_build_modify_expr): Likewise.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.cc (abstract_virtuals_error): Rename to ...\n\t(abstract_virtuals_error_sfinae): ... this. Document its default\n\targument.\n\t(build_functional_cast_1): Adjust calls to '_sfinae'-suffixed\n\tfunctions.", "tree": {"sha": "24f21093bcdd544216dd99f5ba76ee06043d15b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24f21093bcdd544216dd99f5ba76ee06043d15b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c17fa0f20eb29bd1cab5e438c72b96281693ac29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17fa0f20eb29bd1cab5e438c72b96281693ac29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c17fa0f20eb29bd1cab5e438c72b96281693ac29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17fa0f20eb29bd1cab5e438c72b96281693ac29/comments", "author": null, "committer": null, "parents": [{"sha": "c3ba0eaaa223f7b8208d279e3f39ff134912f9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ba0eaaa223f7b8208d279e3f39ff134912f9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ba0eaaa223f7b8208d279e3f39ff134912f9e9"}], "stats": {"total": 162, "additions": 62, "deletions": 100}, "files": [{"sha": "7e9289fc2d02c9f3b09a7be844f2d552321766cf", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -5976,7 +5976,7 @@ build_conditional_expr (const op_location_t &loc,\n \t but now we sometimes wrap them in NOP_EXPRs so the test would\n \t fail.  */\n       if (CLASS_TYPE_P (TREE_TYPE (result)))\n-\tresult = get_target_expr_sfinae (result, complain);\n+\tresult = get_target_expr (result, complain);\n       /* If this expression is an rvalue, but might be mistaken for an\n \t lvalue, we must add a NON_LVALUE_EXPR.  */\n       result = rvalue (result);\n@@ -7672,7 +7672,7 @@ build_temp (tree expr, tree type, int flags,\n   if ((lvalue_kind (expr) & clk_packed)\n       && CLASS_TYPE_P (TREE_TYPE (expr))\n       && !type_has_nontrivial_copy_init (TREE_TYPE (expr)))\n-    return get_target_expr_sfinae (expr, complain);\n+    return get_target_expr (expr, complain);\n \n   /* In decltype, we might have decided not to wrap this call in a TARGET_EXPR.\n      But it turns out to be a subexpression, so perform temporary\n@@ -8008,10 +8008,10 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t    && !processing_template_decl)\n \t  {\n \t    bool direct = CONSTRUCTOR_IS_DIRECT_INIT (expr);\n-\t    if (abstract_virtuals_error_sfinae (NULL_TREE, totype, complain))\n+\t    if (abstract_virtuals_error (NULL_TREE, totype, complain))\n \t      return error_mark_node;\n \t    expr = build_value_init (totype, complain);\n-\t    expr = get_target_expr_sfinae (expr, complain);\n+\t    expr = get_target_expr (expr, complain);\n \t    if (expr != error_mark_node)\n \t      {\n \t\tTARGET_EXPR_LIST_INIT_P (expr) = true;\n@@ -8137,7 +8137,7 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \tfield = next_aggregate_field (DECL_CHAIN (field));\n \tCONSTRUCTOR_APPEND_ELT (vec, field, size_int (len));\n \ttree new_ctor = build_constructor (totype, vec);\n-\treturn get_target_expr_sfinae (new_ctor, complain);\n+\treturn get_target_expr (new_ctor, complain);\n       }\n \n     case ck_aggr:\n@@ -8153,7 +8153,7 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t  return expr;\n \t}\n       expr = reshape_init (totype, expr, complain);\n-      expr = get_target_expr_sfinae (digest_init (totype, expr, complain),\n+      expr = get_target_expr (digest_init (totype, expr, complain),\n \t\t\t\t     complain);\n       if (expr != error_mark_node)\n \tTARGET_EXPR_LIST_INIT_P (expr) = true;\n@@ -8580,12 +8580,12 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n        standard conversions are performed.  */\n     arg = decay_conversion (arg, complain);\n \n-  arg = require_complete_type_sfinae (arg, complain);\n+  arg = require_complete_type (arg, complain);\n   arg_type = TREE_TYPE (arg);\n \n   if (arg != error_mark_node\n       /* In a template (or ill-formed code), we can have an incomplete type\n-\t even after require_complete_type_sfinae, in which case we don't know\n+\t even after require_complete_type, in which case we don't know\n \t whether it has trivial copy or not.  */\n       && COMPLETE_TYPE_P (arg_type)\n       && !cp_unevaluated_operand)\n@@ -10000,7 +10000,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t    obj_arg = TREE_OPERAND (addr, 0);\n \t\t}\n \t    }\n-\t  call = cxx_constant_value_sfinae (call, obj_arg, complain);\n+\t  call = cxx_constant_value (call, obj_arg, complain);\n \t  if (obj_arg && !error_operand_p (call))\n \t    call = build2 (INIT_EXPR, void_type_node, obj_arg, call);\n \t  call = convert_from_reference (call);\n@@ -10505,7 +10505,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n      prvalue. The type of the prvalue may be incomplete.  */\n   if (!(complain & tf_decltype))\n     {\n-      fn = require_complete_type_sfinae (fn, complain);\n+      fn = require_complete_type (fn, complain);\n       if (fn == error_mark_node)\n \treturn error_mark_node;\n \n@@ -11084,7 +11084,7 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n       if (init)\n \t{\n \t  if (is_dummy_object (instance))\n-\t    return get_target_expr_sfinae (init, complain);\n+\t    return get_target_expr (init, complain);\n \t  init = build2 (INIT_EXPR, TREE_TYPE (instance), instance, init);\n \t  TREE_SIDE_EFFECTS (init) = true;\n \t  return init;"}, {"sha": "57283eabf3c5a159eb36041a47062dae7d499692", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -8068,7 +8068,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \tr = get_target_expr (r);\n       else\n \t{\n-\t  r = get_target_expr_sfinae (r, tf_warning_or_error | tf_no_cleanup);\n+\t  r = get_target_expr (r, tf_warning_or_error | tf_no_cleanup);\n \t  TREE_CONSTANT (r) = true;\n \t}\n     }\n@@ -8081,19 +8081,11 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n }\n \n /* If T represents a constant expression returns its reduced value.\n-   Otherwise return error_mark_node.  If T is dependent, then\n-   return NULL.  */\n+   Otherwise return error_mark_node.  */\n \n tree\n-cxx_constant_value (tree t, tree decl)\n-{\n-  return cxx_eval_outermost_constant_expr (t, false, true, true, false, decl);\n-}\n-\n-/* As above, but respect SFINAE.  */\n-\n-tree\n-cxx_constant_value_sfinae (tree t, tree decl, tsubst_flags_t complain)\n+cxx_constant_value (tree t, tree decl /* = NULL_TREE */,\n+\t\t    tsubst_flags_t complain /* = tf_error */)\n {\n   bool sfinae = !(complain & tf_error);\n   tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, true, false, decl);\n@@ -8316,8 +8308,8 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n \n /* Like maybe_constant_value but first fully instantiate the argument.\n \n-   Note: this is equivalent to instantiate_non_dependent_expr_sfinae\n-   (t, complain) followed by maybe_constant_value but is more efficient,\n+   Note: this is equivalent to instantiate_non_dependent_expr (t, complain)\n+   followed by maybe_constant_value but is more efficient,\n    because it calls instantiation_dependent_expression_p and\n    potential_constant_expression at most once.\n    The manifestly_const_eval argument is passed to maybe_constant_value."}, {"sha": "2ba44e80e20cffdaa33337fe5e25f21fa032967b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -7391,8 +7391,7 @@ extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);\n extern void make_args_non_dependent\t\t(vec<tree, va_gc> *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n-extern tree instantiate_non_dependent_expr\t(tree);\n-extern tree instantiate_non_dependent_expr_sfinae (tree, tsubst_flags_t);\n+extern tree instantiate_non_dependent_expr\t(tree, tsubst_flags_t = tf_error);\n extern tree instantiate_non_dependent_expr_internal (tree, tsubst_flags_t);\n extern tree instantiate_non_dependent_or_null   (tree);\n extern bool variable_template_specialization_p  (tree);\n@@ -7824,8 +7823,8 @@ extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_local_temp\t\t\t(tree);\n extern bool is_local_temp\t\t\t(tree);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n-extern tree get_target_expr\t\t\t(tree);\n-extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);\n+extern tree get_target_expr\t\t\t(tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n extern tree build_cplus_array_type\t\t(tree, tree, int is_dep = -1);\n extern tree build_array_of_n_type\t\t(tree, int);\n extern bool array_of_runtime_bound_p\t\t(tree);\n@@ -7938,8 +7937,8 @@ extern int string_conv_p\t\t\t(const_tree, const_tree, int);\n extern tree cp_truthvalue_conversion\t\t(tree, tsubst_flags_t);\n extern tree contextual_conv_bool\t\t(tree, tsubst_flags_t);\n extern tree condition_conversion\t\t(tree);\n-extern tree require_complete_type\t\t(tree);\n-extern tree require_complete_type_sfinae\t(tree, tsubst_flags_t);\n+extern tree require_complete_type\t\t(tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern tree complete_type_or_maybe_complain\t(tree, tree, tsubst_flags_t);\n@@ -8153,10 +8152,10 @@ extern tree binfo_or_else\t\t\t(tree, tree);\n extern void cxx_readonly_error\t\t\t(location_t, tree,\n \t\t\t\t\t\t enum lvalue_use);\n extern void complete_type_check_abstract\t(tree);\n-extern int abstract_virtuals_error\t\t(tree, tree);\n-extern int abstract_virtuals_error\t\t(abstract_class_use, tree);\n-extern int abstract_virtuals_error_sfinae\t(tree, tree, tsubst_flags_t);\n-extern int abstract_virtuals_error_sfinae\t(abstract_class_use, tree, tsubst_flags_t);\n+extern int abstract_virtuals_error\t\t(tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n+extern int abstract_virtuals_error\t\t(abstract_class_use, tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n \n extern tree store_init_value\t\t\t(tree, tree, vec<tree, va_gc>**, int);\n extern tree split_nonconstant_init\t\t(tree, tree);\n@@ -8413,8 +8412,8 @@ extern bool require_potential_constant_expression (tree);\n extern bool require_constant_expression (tree);\n extern bool require_rvalue_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n-extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n-extern tree cxx_constant_value_sfinae\t\t(tree, tree, tsubst_flags_t);\n+extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE,\n+\t\t\t\t\t\t tsubst_flags_t = tf_error);\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);"}, {"sha": "434d306961f877a67cca92af00c3be94b7a81284", "filename": "gcc/cp/cvt.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -339,7 +339,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl,\n \t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n     }\n   else if (!(flags & DIRECT_BIND) && ! obvalue_p (arg))\n-    return get_target_expr_sfinae (arg, complain);\n+    return get_target_expr (arg, complain);\n \n   /* If we had a way to wrap this up, and say, if we ever needed its\n      address, transform all occurrences of the register, into a memory\n@@ -939,7 +939,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \n       ctor = e;\n \n-      if (abstract_virtuals_error_sfinae (NULL_TREE, type, complain))\n+      if (abstract_virtuals_error (NULL_TREE, type, complain))\n \treturn error_mark_node;\n \n       if (BRACE_ENCLOSED_INITIALIZER_P (ctor))"}, {"sha": "936f1cf0197aa315f50ecdf32f5d66d253539b0e", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -18556,7 +18556,7 @@ build_explicit_specifier (tree expr, tsubst_flags_t complain)\n     return expr;\n \n   expr = build_converted_constant_bool_expr (expr, complain);\n-  expr = instantiate_non_dependent_expr_sfinae (expr, complain);\n+  expr = instantiate_non_dependent_expr (expr, complain);\n   expr = cxx_constant_value (expr);\n   return expr;\n }"}, {"sha": "7fdbc747c228d071c96d7d48d2b83f34d5ca6368", "filename": "gcc/cp/except.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -1256,7 +1256,7 @@ build_noexcept_spec (tree expr, tsubst_flags_t complain)\n       && !instantiation_dependent_expression_p (expr))\n     {\n       expr = build_converted_constant_bool_expr (expr, complain);\n-      expr = instantiate_non_dependent_expr_sfinae (expr, complain);\n+      expr = instantiate_non_dependent_expr (expr, complain);\n       expr = cxx_constant_value (expr);\n     }\n   if (TREE_CODE (expr) == INTEGER_CST)"}, {"sha": "a85c30321308f4d84c4077636d89004bfca6f4b0", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -3158,7 +3158,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t     \"%<new%> of %<initializer_list%> does not \"\n \t     \"extend the lifetime of the underlying array\");\n \n-  if (abstract_virtuals_error_sfinae (ACU_NEW, elt_type, complain))\n+  if (abstract_virtuals_error (ACU_NEW, elt_type, complain))\n     return error_mark_node;\n \n   is_initialized = (type_build_ctor_call (elt_type) || *init != NULL);"}, {"sha": "1c6f4b84612b8f5597b3730ecf9625b07a751794", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -3868,7 +3868,7 @@ expand_integer_pack (tree call, tree args, tsubst_flags_t complain,\n     }\n   else\n     {\n-      hi = instantiate_non_dependent_expr_sfinae (hi, complain);\n+      hi = instantiate_non_dependent_expr (hi, complain);\n       hi = cxx_constant_value (hi);\n       int len = valid_constant_size_p (hi) ? tree_to_shwi (hi) : -1;\n \n@@ -6428,7 +6428,7 @@ redeclare_class_template (tree type, tree parms, tree cons)\n     return true;\n }\n \n-/* The actual substitution part of instantiate_non_dependent_expr_sfinae,\n+/* The actual substitution part of instantiate_non_dependent_expr,\n    to be used when the caller has already checked\n     !instantiation_dependent_uneval_expression_p (expr)\n    and cleared processing_template_decl.  */\n@@ -6447,7 +6447,8 @@ instantiate_non_dependent_expr_internal (tree expr, tsubst_flags_t complain)\n /* Instantiate the non-dependent expression EXPR.  */\n \n tree\n-instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n+instantiate_non_dependent_expr (tree expr,\n+\t\t\t\ttsubst_flags_t complain /* = tf_error */)\n {\n   if (expr == NULL_TREE)\n     return NULL_TREE;\n@@ -6462,12 +6463,6 @@ instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n   return expr;\n }\n \n-tree\n-instantiate_non_dependent_expr (tree expr)\n-{\n-  return instantiate_non_dependent_expr_sfinae (expr, tf_error);\n-}\n-\n /* Like instantiate_non_dependent_expr, but return NULL_TREE if the\n    expression is dependent or non-constant.  */\n \n@@ -16970,7 +16965,7 @@ tsubst_init (tree init, tree decl, tree args,\n \t     zero.  */\n \t  init = build_value_init (type, complain);\n \t  if (TREE_CODE (init) == AGGR_INIT_EXPR)\n-\t    init = get_target_expr_sfinae (init, complain);\n+\t    init = get_target_expr (init, complain);\n \t  if (TREE_CODE (init) == TARGET_EXPR)\n \t    TARGET_EXPR_DIRECT_INIT_P (init) = true;\n \t}\n@@ -20124,7 +20119,7 @@ fold_targs_r (tree targs, tsubst_flags_t complain)\n \t       && !glvalue_p (elt)\n \t       && !TREE_CONSTANT (elt))\n \t{\n-\t  elt = cxx_constant_value_sfinae (elt, NULL_TREE, complain);\n+\t  elt = cxx_constant_value (elt, NULL_TREE, complain);\n \t  if (elt == error_mark_node)\n \t    return false;\n \t}"}, {"sha": "3edefb2fca2ab64f4ff1cb0ad7e1788b9f132b51", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -3318,7 +3318,7 @@ finish_compound_literal (tree type, tree compound_literal,\n       /* The CONSTRUCTOR is now an initializer, not a compound literal.  */\n       if (TREE_CODE (compound_literal) == CONSTRUCTOR)\n \tTREE_HAS_CONSTRUCTOR (compound_literal) = false;\n-      compound_literal = get_target_expr_sfinae (compound_literal, complain);\n+      compound_literal = get_target_expr (compound_literal, complain);\n     }\n   else\n     /* For e.g. int{42} just make sure it's a prvalue.  */\n@@ -11329,7 +11329,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n     }\n   else if (processing_template_decl)\n     {\n-      expr = instantiate_non_dependent_expr_sfinae (expr, complain|tf_decltype);\n+      expr = instantiate_non_dependent_expr (expr, complain|tf_decltype);\n       if (expr == error_mark_node)\n \treturn error_mark_node;\n       /* Keep processing_template_decl cleared for the rest of the function\n@@ -12500,7 +12500,7 @@ cp_build_bit_cast (location_t loc, tree type, tree arg,\n   SET_EXPR_LOCATION (ret, loc);\n \n   if (!processing_template_decl && CLASS_TYPE_P (type))\n-    ret = get_target_expr_sfinae (ret, complain);\n+    ret = get_target_expr (ret, complain);\n \n   return ret;\n }"}, {"sha": "d0bd41ae5a004dbd315e19e0ed52a733b656a184", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -713,7 +713,7 @@ build_cplus_new (tree type, tree init, tsubst_flags_t complain)\n \n   /* Make sure that we're not trying to create an instance of an\n      abstract class.  */\n-  if (abstract_virtuals_error_sfinae (NULL_TREE, type, complain))\n+  if (abstract_virtuals_error (NULL_TREE, type, complain))\n     return error_mark_node;\n \n   if (TREE_CODE (rval) == AGGR_INIT_EXPR)\n@@ -922,7 +922,7 @@ force_target_expr (tree type, tree init, tsubst_flags_t complain)\n /* Like build_target_expr_with_type, but use the type of INIT.  */\n \n tree\n-get_target_expr_sfinae (tree init, tsubst_flags_t complain)\n+get_target_expr (tree init, tsubst_flags_t complain /* = tf_warning_or_error */)\n {\n   if (TREE_CODE (init) == AGGR_INIT_EXPR)\n     return build_target_expr (AGGR_INIT_EXPR_SLOT (init), init, complain);\n@@ -935,12 +935,6 @@ get_target_expr_sfinae (tree init, tsubst_flags_t complain)\n     }\n }\n \n-tree\n-get_target_expr (tree init)\n-{\n-  return get_target_expr_sfinae (init, tf_warning_or_error);\n-}\n-\n /* If EXPR is a bitfield reference, convert it to the declared type of\n    the bitfield, and return the resulting expression.  Otherwise,\n    return EXPR itself.  */"}, {"sha": "3e461d5cdcbc953b64988a12a8e22a8973a1257e", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -71,7 +71,8 @@ static bool is_std_forward_p (tree);\n    complete type when this function returns.  */\n \n tree\n-require_complete_type_sfinae (tree value, tsubst_flags_t complain)\n+require_complete_type (tree value,\n+\t\t       tsubst_flags_t complain /* = tf_warning_or_error */)\n {\n   tree type;\n \n@@ -96,12 +97,6 @@ require_complete_type_sfinae (tree value, tsubst_flags_t complain)\n     return error_mark_node;\n }\n \n-tree\n-require_complete_type (tree value)\n-{\n-  return require_complete_type_sfinae (value, tf_warning_or_error);\n-}\n-\n /* Try to complete TYPE, if it is incomplete.  For example, if TYPE is\n    a template instantiation, do the instantiation.  Returns TYPE,\n    whether or not it could be completed, unless something goes\n@@ -3899,7 +3894,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_SIDE_EFFECTS (array));\n       TREE_THIS_VOLATILE (rval)\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_THIS_VOLATILE (array));\n-      ret = require_complete_type_sfinae (rval, complain);\n+      ret = require_complete_type (rval, complain);\n       protected_set_expr_location (ret, loc);\n       if (non_lvalue)\n \tret = non_lvalue_loc (loc, ret);\n@@ -4464,7 +4459,7 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n \t    /* Don't do ellipsis conversion for __built_in_constant_p\n \t       as this will result in spurious errors for non-trivial\n \t       types.  */\n-\t    val = require_complete_type_sfinae (val, complain);\n+\t    val = require_complete_type (val, complain);\n \t  else\n \t    val = convert_arg_to_ellipsis (val, complain);\n \n@@ -6264,7 +6259,7 @@ cp_build_binary_op (const op_location_t &location,\n \t\t     instrument_expr, result);\n \n   if (resultcode == SPACESHIP_EXPR && !processing_template_decl)\n-    result = get_target_expr_sfinae (result, complain);\n+    result = get_target_expr (result, complain);\n \n   if (!c_inhibit_evaluation_warnings)\n     {\n@@ -8016,7 +8011,7 @@ build_static_cast_1 (location_t loc, tree type, tree expr, bool c_cast_p,\n   /* [class.abstract]\n      An abstract class shall not be used ... as the type of an explicit\n      conversion.  */\n-  if (abstract_virtuals_error_sfinae (ACU_CAST, type, complain))\n+  if (abstract_virtuals_error (ACU_CAST, type, complain))\n     return error_mark_node;\n \n   /* [expr.static.cast]\n@@ -9144,7 +9139,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n     }\n   else\n     {\n-      lhs = require_complete_type_sfinae (lhs, complain);\n+      lhs = require_complete_type (lhs, complain);\n       if (lhs == error_mark_node)\n \treturn error_mark_node;\n \n@@ -10123,7 +10118,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n     }\n \n   if (exp != 0)\n-    exp = require_complete_type_sfinae (exp, complain);\n+    exp = require_complete_type (exp, complain);\n   if (exp == error_mark_node)\n     return error_mark_node;\n "}, {"sha": "688e9c15326ad4c136595e59bc7bc16babad3b89", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17fa0f20eb29bd1cab5e438c72b96281693ac29/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=c17fa0f20eb29bd1cab5e438c72b96281693ac29", "patch": "@@ -130,8 +130,8 @@ cxx_readonly_error (location_t loc, tree arg, enum lvalue_use errstring)\n    all was well.  */\n \n static int\n-abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n-\t\t\t\ttsubst_flags_t complain)\n+abstract_virtuals_error (tree decl, tree type, abstract_class_use use,\n+\t\t\t tsubst_flags_t complain)\n {\n   vec<tree, va_gc> *pure;\n \n@@ -251,32 +251,19 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n }\n \n int\n-abstract_virtuals_error_sfinae (tree decl, tree type, tsubst_flags_t complain)\n-{\n-  return abstract_virtuals_error_sfinae (decl, type, ACU_UNKNOWN, complain);\n-}\n-\n-int\n-abstract_virtuals_error_sfinae (abstract_class_use use, tree type,\n-\t\t\t\ttsubst_flags_t complain)\n+abstract_virtuals_error (tree decl, tree type,\n+\t\t\t tsubst_flags_t complain /* = tf_warning_or_error */)\n {\n-  return abstract_virtuals_error_sfinae (NULL_TREE, type, use, complain);\n+  return abstract_virtuals_error (decl, type, ACU_UNKNOWN, complain);\n }\n \n-\n-/* Wrapper for the above function in the common case of wanting errors.  */\n-\n int\n-abstract_virtuals_error (tree decl, tree type)\n+abstract_virtuals_error (abstract_class_use use, tree type,\n+\t\t\t tsubst_flags_t complain /* = tf_warning_or_error */)\n {\n-  return abstract_virtuals_error_sfinae (decl, type, tf_warning_or_error);\n+  return abstract_virtuals_error (NULL_TREE, type, use, complain);\n }\n \n-int\n-abstract_virtuals_error (abstract_class_use use, tree type)\n-{\n-  return abstract_virtuals_error_sfinae (use, type, tf_warning_or_error);\n-}\n \n /* Print an inform about the declaration of the incomplete type TYPE.  */\n \n@@ -2502,7 +2489,7 @@ build_functional_cast_1 (location_t loc, tree exp, tree parms,\n \n   if (!complete_type_or_maybe_complain (type, NULL_TREE, complain))\n     return error_mark_node;\n-  if (abstract_virtuals_error_sfinae (ACU_CAST, type, complain))\n+  if (abstract_virtuals_error (ACU_CAST, type, complain))\n     return error_mark_node;\n \n   /* [expr.type.conv]\n@@ -2523,7 +2510,7 @@ build_functional_cast_1 (location_t loc, tree exp, tree parms,\n   if (parms == NULL_TREE)\n     {\n       exp = build_value_init (type, complain);\n-      exp = get_target_expr_sfinae (exp, complain);\n+      exp = get_target_expr (exp, complain);\n       return exp;\n     }\n "}]}