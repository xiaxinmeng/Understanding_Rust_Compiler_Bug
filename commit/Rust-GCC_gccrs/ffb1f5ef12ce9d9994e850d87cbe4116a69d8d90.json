{"sha": "ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiMWY1ZWYxMmNlOWQ5OTk0ZTg1MGQ4N2NiZTQxMTZhNjlkOGQ5MA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-06-04T18:23:30Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-06-04T18:23:30Z"}, "message": "lto-wrapper.c (fatal, [...]): Remove functions.\n\n\t* lto-wrapper.c (fatal, fatal_perror): Remove functions.  All callers\n\tchanged to use fatal_error.\n\t(main): Ensure lto_wrapper_cleanup is run atexit.\n\nFrom-SVN: r211243", "tree": {"sha": "c28a1757c60e8cdb4f92988842244b6d2a905ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c28a1757c60e8cdb4f92988842244b6d2a905ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90/comments", "author": null, "committer": null, "parents": [{"sha": "a953491ef217b3f5a360e40a809e6b5530fde4fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a953491ef217b3f5a360e40a809e6b5530fde4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a953491ef217b3f5a360e40a809e6b5530fde4fd"}], "stats": {"total": 78, "additions": 25, "deletions": 53}, "files": [{"sha": "7486ec072d692c9d50984a2470fca67299aa5110", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "patch": "@@ -1,3 +1,9 @@\n+2014-06-04  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* lto-wrapper.c (fatal, fatal_perror): Remove functions.  All callers\n+\tchanged to use fatal_error.\n+\t(main): Ensure lto_wrapper_cleanup is run atexit.\n+\n 2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* lra-constraints.c (valid_address_p): Move earlier in file."}, {"sha": "f42b14efd5dd491ec74adfb4649745052f192605", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=ffb1f5ef12ce9d9994e850d87cbe4116a69d8d90", "patch": "@@ -111,43 +111,6 @@ fatal_signal (int signum)\n   kill (getpid (), signum);\n }\n \n-/* Just die. CMSGID is the error message. */\n-\n-static void __attribute__ ((format (printf, 1, 2)))\n-fatal (const char * cmsgid, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, cmsgid);\n-  fprintf (stderr, \"lto-wrapper: \");\n-  vfprintf (stderr, _(cmsgid), ap);\n-  fprintf (stderr, \"\\n\");\n-  va_end (ap);\n-\n-  lto_wrapper_cleanup ();\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n-\n-/* Die when sys call fails. CMSGID is the error message.  */\n-\n-static void __attribute__ ((format (printf, 1, 2)))\n-fatal_perror (const char *cmsgid, ...)\n-{\n-  int e = errno;\n-  va_list ap;\n-\n-  va_start (ap, cmsgid);\n-  fprintf (stderr, \"lto-wrapper: \");\n-  vfprintf (stderr, _(cmsgid), ap);\n-  fprintf (stderr, \": %s\\n\", xstrerror (e));\n-  va_end (ap);\n-\n-  lto_wrapper_cleanup ();\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n-\n /* Execute a program, and wait for the reply. ARGV are the arguments. The\n    last one must be NULL. */\n \n@@ -174,7 +137,7 @@ collect_execute (char **argv)\n \n   pex = pex_init (0, \"lto-wrapper\", NULL);\n   if (pex == NULL)\n-    fatal_perror (\"pex_init failed\");\n+    fatal_error (\"pex_init failed: %m\");\n \n   /* Do not use PEX_LAST here, we use our stdout for communicating with\n      collect2 or the linker-plugin.  Any output from the sub-process\n@@ -186,10 +149,10 @@ collect_execute (char **argv)\n       if (err != 0)\n \t{\n \t  errno = err;\n-\t  fatal_perror (errmsg);\n+\t  fatal_error (\"%s: %m\", _(errmsg));\n \t}\n       else\n-\tfatal (errmsg);\n+\tfatal_error (errmsg);\n     }\n \n   return pex;\n@@ -205,7 +168,7 @@ collect_wait (const char *prog, struct pex_obj *pex)\n   int status;\n \n   if (!pex_get_status (pex, 1, &status))\n-    fatal_perror (\"can't get program status\");\n+    fatal_error (\"can't get program status: %m\");\n   pex_free (pex);\n \n   if (status)\n@@ -214,15 +177,15 @@ collect_wait (const char *prog, struct pex_obj *pex)\n \t{\n \t  int sig = WTERMSIG (status);\n \t  if (WCOREDUMP (status))\n-\t    fatal (\"%s terminated with signal %d [%s], core dumped\",\n+\t    fatal_error (\"%s terminated with signal %d [%s], core dumped\",\n \t\t   prog, sig, strsignal (sig));\n \t  else\n-\t    fatal (\"%s terminated with signal %d [%s]\",\n+\t    fatal_error (\"%s terminated with signal %d [%s]\",\n \t\t   prog, sig, strsignal (sig));\n \t}\n \n       if (WIFEXITED (status))\n-\tfatal (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n+\tfatal_error (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n     }\n \n   return 0;\n@@ -238,7 +201,7 @@ maybe_unlink_file (const char *file)\n     {\n       if (unlink_if_ordinary (file)\n \t  && errno != ENOENT)\n-\tfatal_perror (\"deleting LTRANS file %s\", file);\n+\tfatal_error (\"deleting LTRANS file %s: %m\", file);\n     }\n   else if (verbose)\n     fprintf (stderr, \"[Leaving LTRANS %s]\\n\", file);\n@@ -260,12 +223,12 @@ fork_execute (char **argv)\n   at_args = concat (\"@\", args_name, NULL);\n   args = fopen (args_name, \"w\");\n   if (args == NULL)\n-    fatal (\"failed to open %s\", args_name);\n+    fatal_error (\"failed to open %s\", args_name);\n \n   status = writeargv (&argv[1], args);\n \n   if (status)\n-    fatal (\"could not write to temporary file %s\",  args_name);\n+    fatal_error (\"could not write to temporary file %s\",  args_name);\n \n   fclose (args);\n \n@@ -312,7 +275,7 @@ get_options_from_collect_gcc_options (const char *collect_gcc,\n \t  do\n \t    {\n \t      if (argv_storage[j] == '\\0')\n-\t\tfatal (\"malformed COLLECT_GCC_OPTIONS\");\n+\t\tfatal_error (\"malformed COLLECT_GCC_OPTIONS\");\n \t      else if (strncmp (&argv_storage[j], \"'\\\\''\", 4) == 0)\n \t\t{\n \t\t  argv_storage[k++] = '\\'';\n@@ -452,8 +415,8 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n \t      break;\n \t  if (j == *decoded_options_count)\n-\t    fatal (\"Option %s not used consistently in all LTO input files\",\n-\t\t   foption->orig_option_with_args_text);\n+\t    fatal_error (\"Option %s not used consistently in all LTO input\"\n+\t\t\t \" files\", foption->orig_option_with_args_text);\n \t  break;\n \n \tcase OPT_O:\n@@ -554,10 +517,10 @@ run_gcc (unsigned argc, char *argv[])\n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n   if (!collect_gcc)\n-    fatal (\"environment variable COLLECT_GCC must be set\");\n+    fatal_error (\"environment variable COLLECT_GCC must be set\");\n   collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n   if (!collect_gcc_options)\n-    fatal (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+    fatal_error (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,\n \t\t\t\t\tCL_LANG_ALL,\n \t\t\t\t\t&decoded_options,\n@@ -871,7 +834,7 @@ run_gcc (unsigned argc, char *argv[])\n       struct obstack env_obstack;\n \n       if (!stream)\n-\tfatal_perror (\"fopen: %s\", ltrans_output_file);\n+\tfatal_error (\"fopen: %s: %m\", ltrans_output_file);\n \n       /* Parse the list of LTRANS inputs from the WPA stage.  */\n       obstack_init (&env_obstack);\n@@ -1040,6 +1003,9 @@ main (int argc, char *argv[])\n \n   xmalloc_set_program_name (progname);\n \n+  if (atexit (lto_wrapper_cleanup) != 0)\n+    fatal_error (\"atexit failed\");\n+\n   gcc_init_libintl ();\n \n   diagnostic_initialize (global_dc, 0);"}]}