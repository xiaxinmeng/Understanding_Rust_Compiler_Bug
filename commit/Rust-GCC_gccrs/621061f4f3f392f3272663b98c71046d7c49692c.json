{"sha": "621061f4f3f392f3272663b98c71046d7c49692c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIxMDYxZjRmM2YzOTJmMzI3MjY2M2I5OGM3MTA0NmQ3YzQ5NjkyYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T17:13:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T17:13:53Z"}, "message": "(assign_parms): Handle promotions of both passed and nominal modes separately and insert needed conversions.\n\n(assign_parms): Handle promotions of both passed and nominal modes separately\nand insert needed conversions.\n(promoted_input_arg): Return 0 if nominal and passed modes differ.\n\nFrom-SVN: r9922", "tree": {"sha": "1a8eeed680e8b357f1b2659b654e1ba3e7a30c8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a8eeed680e8b357f1b2659b654e1ba3e7a30c8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/621061f4f3f392f3272663b98c71046d7c49692c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621061f4f3f392f3272663b98c71046d7c49692c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621061f4f3f392f3272663b98c71046d7c49692c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621061f4f3f392f3272663b98c71046d7c49692c/comments", "author": null, "committer": null, "parents": [{"sha": "c02aebe2e88e8fe4d341c6e7d15599c1853315f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02aebe2e88e8fe4d341c6e7d15599c1853315f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02aebe2e88e8fe4d341c6e7d15599c1853315f2"}], "stats": {"total": 84, "additions": 51, "deletions": 33}, "files": [{"sha": "c5576cdc1f361ef204155b03d9ffe9b6be7f58b8", "filename": "gcc/function.c", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621061f4f3f392f3272663b98c71046d7c49692c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621061f4f3f392f3272663b98c71046d7c49692c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=621061f4f3f392f3272663b98c71046d7c49692c", "patch": "@@ -3129,7 +3129,8 @@ assign_parms (fndecl, second_time)\n   register rtx entry_parm = 0;\n   register rtx stack_parm = 0;\n   CUMULATIVE_ARGS args_so_far;\n-  enum machine_mode promoted_mode, passed_mode, nominal_mode;\n+  enum machine_mode promoted_mode, passed_mode;\n+  enum machine_mode nominal_mode, promoted_nominal_mode;\n   int unsignedp;\n   /* Total space needed so far for args on the stack,\n      given as a constant and a tree-expression.  */\n@@ -3219,7 +3220,9 @@ assign_parms (fndecl, second_time)\n       struct args_size stack_offset;\n       struct args_size arg_size;\n       int passed_pointer = 0;\n+      int did_conversion = 0;\n       tree passed_type = DECL_ARG_TYPE (parm);\n+      tree nominal_type = TREE_TYPE (parm);\n \n       /* Set LAST_NAMED if this is last named arg before some\n \t anonymous args.  We treat it as if it were anonymous too.  */\n@@ -3247,7 +3250,7 @@ assign_parms (fndecl, second_time)\n       /* Find mode of arg as it is passed, and mode of arg\n \t as it should be during execution of this function.  */\n       passed_mode = TYPE_MODE (passed_type);\n-      nominal_mode = TYPE_MODE (TREE_TYPE (parm));\n+      nominal_mode = TYPE_MODE (nominal_type);\n \n       /* If the parm's mode is VOID, its value doesn't matter,\n \t and avoid the usual things like emit_move_insn that could crash.  */\n@@ -3278,7 +3281,7 @@ assign_parms (fndecl, second_time)\n #endif\n \t  )\n \t{\n-\t  passed_type = build_pointer_type (passed_type);\n+\t  passed_type = nominal_type = build_pointer_type (passed_type);\n \t  passed_pointer = 1;\n \t  passed_mode = nominal_mode = Pmode;\n \t}\n@@ -3300,8 +3303,8 @@ assign_parms (fndecl, second_time)\n \t\t\t\t passed_type, ! last_named);\n #endif\n \n-      if (entry_parm)\n-\tpassed_mode = promoted_mode;\n+      if (entry_parm == 0)\n+\tpromoted_mode = passed_mode;\n \n #ifdef SETUP_INCOMING_VARARGS\n       /* If this is the last named parameter, do any required setup for\n@@ -3316,7 +3319,7 @@ assign_parms (fndecl, second_time)\n \t Also, indicate when RTL generation is to be suppressed.  */\n       if (last_named && !varargs_setup)\n \t{\n-\t  SETUP_INCOMING_VARARGS (args_so_far, passed_mode, passed_type,\n+\t  SETUP_INCOMING_VARARGS (args_so_far, promoted_mode, passed_type,\n \t\t\t\t  current_function_pretend_args_size,\n \t\t\t\t  second_time);\n \t  varargs_setup = 1;\n@@ -3336,17 +3339,17 @@ assign_parms (fndecl, second_time)\n \t In this case, we call FUNCTION_ARG with NAMED set to 1 instead of\n \t 0 as it was the previous time.  */\n \n-      locate_and_pad_parm (passed_mode, passed_type,\n+      locate_and_pad_parm (promoted_mode, passed_type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t   1,\n #else\n #ifdef FUNCTION_INCOMING_ARG\n-\t\t\t   FUNCTION_INCOMING_ARG (args_so_far, passed_mode,\n+\t\t\t   FUNCTION_INCOMING_ARG (args_so_far, promoted_mode,\n \t\t\t\t\t\t  passed_type,\n \t\t\t\t\t\t  (! last_named\n \t\t\t\t\t\t   || varargs_setup)) != 0,\n #else\n-\t\t\t   FUNCTION_ARG (args_so_far, passed_mode,\n+\t\t\t   FUNCTION_ARG (args_so_far, promoted_mode,\n \t\t\t\t\t passed_type,\n \t\t\t\t\t ! last_named || varargs_setup) != 0,\n #endif\n@@ -3358,9 +3361,9 @@ assign_parms (fndecl, second_time)\n \t  rtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n \n \t  if (offset_rtx == const0_rtx)\n-\t    stack_parm = gen_rtx (MEM, passed_mode, internal_arg_pointer);\n+\t    stack_parm = gen_rtx (MEM, promoted_mode, internal_arg_pointer);\n \t  else\n-\t    stack_parm = gen_rtx (MEM, passed_mode,\n+\t    stack_parm = gen_rtx (MEM, promoted_mode,\n \t\t\t\t  gen_rtx (PLUS, Pmode,\n \t\t\t\t\t   internal_arg_pointer, offset_rtx));\n \n@@ -3371,7 +3374,7 @@ assign_parms (fndecl, second_time)\n \n       /* If this parameter was passed both in registers and in the stack,\n \t use the copy on the stack.  */\n-      if (MUST_PASS_IN_STACK (passed_mode, passed_type))\n+      if (MUST_PASS_IN_STACK (promoted_mode, passed_type))\n \tentry_parm = 0;\n \n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n@@ -3385,7 +3388,7 @@ assign_parms (fndecl, second_time)\n \n       if (entry_parm)\n \t{\n-\t  int nregs = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, passed_mode,\n+\t  int nregs = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, promoted_mode,\n \t\t\t\t\t\t  passed_type, ! last_named);\n \n \t  if (nregs > 0)\n@@ -3442,7 +3445,7 @@ assign_parms (fndecl, second_time)\n \n       /* Update info on where next arg arrives in registers.  */\n \n-      FUNCTION_ARG_ADVANCE (args_so_far, passed_mode,\n+      FUNCTION_ARG_ADVANCE (args_so_far, promoted_mode,\n \t\t\t    passed_type, ! last_named);\n \n       /* If this is our second time through, we are done with this parm. */\n@@ -3454,7 +3457,7 @@ assign_parms (fndecl, second_time)\n \t We'll make another stack slot, if we need one.  */\n       {\n \tint thisparm_boundary\n-\t  = FUNCTION_ARG_BOUNDARY (passed_mode, passed_type);\n+\t  = FUNCTION_ARG_BOUNDARY (promoted_mode, passed_type);\n \n \tif (GET_MODE_ALIGNMENT (nominal_mode) > thisparm_boundary)\n \t  stack_parm = 0;\n@@ -3527,8 +3530,9 @@ assign_parms (fndecl, second_time)\n \t  /* If a BLKmode arrives in registers, copy it to a stack slot.  */\n \t  if (GET_CODE (entry_parm) == REG)\n \t    {\n-\t      int size_stored = CEIL_ROUND (int_size_in_bytes (TREE_TYPE (parm)),\n-\t\t\t\t\t    UNITS_PER_WORD);\n+\t      int size_stored\n+\t\t= CEIL_ROUND (int_size_in_bytes (TREE_TYPE (parm)),\n+\t\t\t      UNITS_PER_WORD);\n \n \t      /* Note that we will be storing an integral number of words.\n \t\t So we have to be careful to ensure that we allocate an\n@@ -3541,9 +3545,11 @@ assign_parms (fndecl, second_time)\n \t      if (stack_parm == 0)\n \t\t{\n \t\t  stack_parm\n-\t\t    = assign_stack_local (GET_MODE (entry_parm), size_stored, 0);\n-\t\t  /* If this is a memory ref that contains aggregate components,\n-\t\t     mark it as such for cse and loop optimize.  */\n+\t\t    = assign_stack_local (GET_MODE (entry_parm),\n+\t\t\t\t\t  size_stored, 0);\n+\n+\t\t  /* If this is a memory ref that contains aggregate\n+\t\t     components, mark it as such for cse and loop optimize.  */\n \t\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n \t\t}\n \n@@ -3581,28 +3587,34 @@ assign_parms (fndecl, second_time)\n \n \t  unsignedp = TREE_UNSIGNED (TREE_TYPE (parm));\n \n-#ifdef PROMOTE_FUNCTION_ARGS\n-\t  nominal_mode = promote_mode (TREE_TYPE (parm), nominal_mode,\n-\t\t\t\t       &unsignedp, 1);\n-#endif\n+\t  promoted_nominal_mode\n+\t    = promote_mode (TREE_TYPE (parm), nominal_mode, &unsignedp, 0);\n \n-\t  parmreg = gen_reg_rtx (nominal_mode);\n+\t  parmreg = gen_reg_rtx (promoted_nominal_mode);\n \t  REG_USERVAR_P (parmreg) = 1;\n \n \t  /* If this was an item that we received a pointer to, set DECL_RTL\n \t     appropriately.  */\n \t  if (passed_pointer)\n \t    {\n-\t      DECL_RTL (parm) = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n+\t      DECL_RTL (parm)\n+\t\t= gen_rtx (MEM, TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n \t      MEM_IN_STRUCT_P (DECL_RTL (parm)) = aggregate;\n \t    }\n \t  else\n \t    DECL_RTL (parm) = parmreg;\n \n \t  /* Copy the value into the register.  */\n-\t  if (GET_MODE (parmreg) != GET_MODE (entry_parm))\n+\t  if (nominal_mode != passed_mode\n+\t      || promoted_nominal_mode != promoted_mode)\n \t    {\n-\t      /* If ENTRY_PARM is a hard register, it might be in a register\n+\t      /* ENTRY_PARM has been converted to PROMOTED_MODE, its\n+\t\t mode, by the caller.  We now have to convert it to \n+\t\t NOMINAL_MODE, if different.  However, PARMREG may be in\n+\t\t a diffent mode than NOMINAL_MODE if it is being stored\n+\t\t promoted.\n+\n+\t\t If ENTRY_PARM is a hard register, it might be in a register\n \t\t not valid for operating in its mode (e.g., an odd-numbered\n \t\t register for a DFmode).  In that case, moves are the only\n \t\t thing valid, so we can't do a convert from there.  This\n@@ -3618,10 +3630,13 @@ assign_parms (fndecl, second_time)\n \t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n \n \t      emit_move_insn (tempreg, validize_mem (entry_parm));\n+\t      tempreg = gen_lowpart (nominal_mode, tempreg);\n \n \t      push_to_sequence (conversion_insns);\n-\t      convert_move (parmreg, tempreg, unsignedp);\n+\t      expand_assignment (parm,\n+\t\t\t\t make_tree (nominal_type, tempreg), 0, 0);\n \t      conversion_insns = get_insns ();\n+\t      did_conversion = 1;\n \t      end_sequence ();\n \t    }\n \t  else\n@@ -3688,6 +3703,7 @@ assign_parms (fndecl, second_time)\n \t      store_expr (parm, copy, 0);\n \t      emit_move_insn (parmreg, XEXP (copy, 0));\n \t      conversion_insns = get_insns ();\n+\t      did_conversion = 1;\n \t      end_sequence ();\n \t    }\n #endif /* FUNCTION_ARG_CALLEE_COPIES */\n@@ -3747,7 +3763,7 @@ assign_parms (fndecl, second_time)\n \t     an invalid address, such memory-equivalences\n \t     as we make here would screw up life analysis for it.  */\n \t  if (nominal_mode == passed_mode\n-\t      && ! conversion_insns\n+\t      && ! did_conversion\n \t      && GET_CODE (entry_parm) == MEM\n \t      && entry_parm == stack_parm\n \t      && stack_offset.var == 0\n@@ -3789,7 +3805,7 @@ assign_parms (fndecl, second_time)\n \t  /* Value must be stored in the stack slot STACK_PARM\n \t     during function execution.  */\n \n-\t  if (passed_mode != nominal_mode)\n+\t  if (promoted_mode != nominal_mode)\n \t    {\n \t      /* Conversion is required.   */\n \t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n@@ -3800,6 +3816,7 @@ assign_parms (fndecl, second_time)\n \t      entry_parm = convert_to_mode (nominal_mode, tempreg,\n \t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (parm)));\n \t      conversion_insns = get_insns ();\n+\t      did_conversion = 1;\n \t      end_sequence ();\n \t    }\n \n@@ -3815,7 +3832,7 @@ assign_parms (fndecl, second_time)\n \t\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n \t\t}\n \n-\t      if (passed_mode != nominal_mode)\n+\t      if (promoted_mode != nominal_mode)\n \t\t{\n \t\t  push_to_sequence (conversion_insns);\n \t\t  emit_move_insn (validize_mem (stack_parm),\n@@ -3926,7 +3943,8 @@ promoted_input_arg (regno, pmode, punsignedp)\n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n     if (GET_CODE (DECL_INCOMING_RTL (arg)) == REG\n-\t&& REGNO (DECL_INCOMING_RTL (arg)) == regno)\n+\t&& REGNO (DECL_INCOMING_RTL (arg)) == regno\n+\t&& TYPE_MODE (DECL_ARG_TYPE (arg)) == TYPE_MODE (TREE_TYPE (arg)))\n       {\n \tenum machine_mode mode = TYPE_MODE (TREE_TYPE (arg));\n \tint unsignedp = TREE_UNSIGNED (TREE_TYPE (arg));"}]}