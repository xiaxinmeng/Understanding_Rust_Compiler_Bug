{"sha": "4a8d0c9c68d8ce12453255695bfab8b2111dd772", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4ZDBjOWM2OGQ4Y2UxMjQ1MzI1NTY5NWJmYWI4YjIxMTFkZDc3Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-10-11T18:48:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-10-11T18:48:42Z"}, "message": "rtl.h (REG_VTABLE_REF): New.\n\n        * rtl.h (REG_VTABLE_REF): New.\n        * rtl.c (reg_note_name): Add it.\n        * combine.c (distribute_notes): Handle it.\n        * final.c (final_scan_insn): Handle it.\n        * tree.def (VTABLE_REF): New.\n        * expr.c (expand_expr): Handle it.\n        * varasm.c (assemble_vtable_entry, assemble_vtable_inherit): New.\n        * output.h: Declare them.\ncp/\n        * class.c (build_vtable_entry_ref): Create a VTABLE_REF instead\n        of an asm statement.\n        (build_vtbl_ref_1): Split out from build_vtbl_ref.\n        (build_vfn_ref): Use it to handle vtable descriptors before\n        calling build_vtable_entry_ref.\n        * decl2.c (output_vtable_inherit): Use assemble_vtable_inherit.\ntestsuite/\n        * g++.old-deja/g++.other/crash18.C: Add -S to options.\n\nFrom-SVN: r46195", "tree": {"sha": "36b169e5937e71fb76f555ec055b161e29728e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b169e5937e71fb76f555ec055b161e29728e84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8d0c9c68d8ce12453255695bfab8b2111dd772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8d0c9c68d8ce12453255695bfab8b2111dd772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8d0c9c68d8ce12453255695bfab8b2111dd772", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8d0c9c68d8ce12453255695bfab8b2111dd772/comments", "author": null, "committer": null, "parents": [{"sha": "94e091c8336b9ec8ed70f5e0b9b5b31b189f10a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e091c8336b9ec8ed70f5e0b9b5b31b189f10a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e091c8336b9ec8ed70f5e0b9b5b31b189f10a4"}], "stats": {"total": 214, "additions": 168, "deletions": 46}, "files": [{"sha": "7c751673c35682153602373c5f726ff7184da001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -1,3 +1,14 @@\n+2001-10-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (REG_VTABLE_REF): New.\n+\t* rtl.c (reg_note_name): Add it.\n+\t* combine.c (distribute_notes): Handle it.\n+\t* final.c (final_scan_insn): Handle it.\n+\t* tree.def (VTABLE_REF): New.\n+\t* expr.c (expand_expr): Handle it.\n+\t* varasm.c (assemble_vtable_entry, assemble_vtable_inherit): New.\n+\t* output.h: Declare them.\n+\n 2001-10-11  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2out.c (rtl_for_decl_location): If no DECL_RTL, look"}, {"sha": "e16cb4d7d03fbcd9798388863a811553462ecdf4", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -11952,6 +11952,12 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t  place = i3;\n \t  break;\n \n+\tcase REG_VTABLE_REF:\n+\t  /* ??? Should remain with *a particular* memory load.  Given the\n+\t     nature of vtable data, the last insn seems relatively safe.  */\n+\t  place = i3;\n+\t  break;\n+\n \tcase REG_NON_LOCAL_GOTO:\n \t  if (GET_CODE (i3) == JUMP_INSN)\n \t    place = i3;"}, {"sha": "06806fc40f237cc17ebd0ff2b64b0075a9db7f31", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -1,3 +1,12 @@\n+2001-10-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (build_vtable_entry_ref): Create a VTABLE_REF instead\n+\tof an asm statement.\n+\t(build_vtbl_ref_1): Split out from build_vtbl_ref.\n+\t(build_vfn_ref): Use it to handle vtable descriptors before\n+\tcalling build_vtable_entry_ref.\n+\t* decl2.c (output_vtable_inherit): Use assemble_vtable_inherit.\n+\n 2001-10-10  Richard Henderson  <rth@redhat.com>\n \n         * parse.y (asm_operand): Allow named operands."}, {"sha": "305bde1d7fbde103d4630d2902779daf064301e2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -134,7 +134,8 @@ static tree add_implicitly_declared_members PARAMS ((tree, int, int, int));\n static tree fixed_type_or_null PARAMS ((tree, int *, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, int, tree));\n-static void build_vtable_entry_ref PARAMS ((tree, tree));\n+static tree build_vtable_entry_ref PARAMS ((tree, tree, tree));\n+static tree build_vtbl_ref_1 PARAMS ((tree, tree));\n static tree build_vtbl_initializer PARAMS ((tree, tree, tree, tree, int *));\n static int count_fields PARAMS ((tree));\n static int add_fields_to_vec PARAMS ((tree, tree, int));\n@@ -424,47 +425,40 @@ build_vbase_path (code, type, expr, path, nonnull)\n \f\n /* Virtual function things.  */\n \n-/* We want to give the assembler the vtable identifier as well as\n-   the offset to the function pointer.  So we generate\n+static tree\n+build_vtable_entry_ref (array_ref, instance, idx)\n+     tree array_ref, instance, idx;\n+{\n+  tree i, i2, vtable, first_fn, basetype;\n \n-   __asm__ __volatile__ (\".vtable_entry %c0, %c1\"\n-      : : \"s\"(&class_vtable),\n-          \"i\"((long)&vtbl[idx].pfn - (long)&vtbl[0])); */\n+  basetype = TREE_TYPE (instance);\n+  if (TREE_CODE (basetype) == REFERENCE_TYPE)\n+    basetype = TREE_TYPE (basetype);\n \n-static void\n-build_vtable_entry_ref (basetype, idx)\n-     tree basetype, idx;\n-{\n-  static const char asm_stmt[] = \".vtable_entry %c0, %c1\";\n-  tree s, i, i2;\n-  tree vtable = get_vtbl_decl_for_binfo (TYPE_BINFO (basetype));\n-  tree first_fn = TYPE_BINFO_VTABLE (basetype);\n+  vtable = get_vtbl_decl_for_binfo (TYPE_BINFO (basetype));\n+  first_fn = TYPE_BINFO_VTABLE (basetype);\n \n-  s = build_unary_op (ADDR_EXPR, vtable, 0);\n-  s = build_tree_list (build_string (1, \"s\"), s);\n+  i = fold (build_array_ref (first_fn, idx));\n+  i = fold (build_c_cast (ptrdiff_type_node,\n+\t\t\t  build_unary_op (ADDR_EXPR, i, 0)));\n+  i2 = fold (build_array_ref (vtable, build_int_2 (0,0)));\n+  i2 = fold (build_c_cast (ptrdiff_type_node,\n+\t\t\t   build_unary_op (ADDR_EXPR, i2, 0)));\n+  i = fold (cp_build_binary_op (MINUS_EXPR, i, i2));\n \n-  i = build_array_ref (first_fn, idx);\n-  /* We must not convert to ptrdiff_type node here, since this could widen\n-     from a partial to an integral node, which would create a\n-     convert_expression that would be in the way of any simplifications.  */\n-  i = build_c_cast (string_type_node, build_unary_op (ADDR_EXPR, i, 0));\n-  i2 = build_array_ref (vtable, build_int_2 (0,0));\n-  i2 = build_c_cast (string_type_node, build_unary_op (ADDR_EXPR, i2, 0));\n-  i = cp_build_binary_op (MINUS_EXPR, i, i2);\n-  i = build_tree_list (build_string (1, \"i\"), i);\n+  if (TREE_CODE (i) != INTEGER_CST)\n+    abort ();\n \n-  finish_asm_stmt (ridpointers[RID_VOLATILE],\n-\t\t   build_string (sizeof(asm_stmt)-1, asm_stmt),\n-\t\t   NULL_TREE, chainon (s, i), NULL_TREE);\n+  return build (VTABLE_REF, TREE_TYPE (array_ref), array_ref, vtable, i);\n }\n \n /* Given an object INSTANCE, return an expression which yields the\n    vtable element corresponding to INDEX.  There are many special\n    cases for INSTANCE which we take care of here, mainly to avoid\n    creating extra tree nodes when we don't have to.  */\n \n-tree\n-build_vtbl_ref (instance, idx)\n+static tree\n+build_vtbl_ref_1 (instance, idx)\n      tree instance, idx;\n {\n   tree vtbl, aref;\n@@ -535,29 +529,41 @@ build_vtbl_ref (instance, idx)\n \n   assemble_external (vtbl);\n \n-  if (flag_vtable_gc)\n-    build_vtable_entry_ref (basetype, idx);\n-\n   aref = build_array_ref (vtbl, idx);\n \n   return aref;\n }\n \n+tree\n+build_vtbl_ref (instance, idx)\n+     tree instance, idx;\n+{\n+  tree aref = build_vtbl_ref_1 (instance, idx);\n+\n+  if (flag_vtable_gc)\n+    aref = build_vtable_entry_ref (aref, instance, idx);\n+\n+  return aref;\n+}\n+\n /* Given an object INSTANCE, return an expression which yields a\n    function pointer corresponding to vtable element INDEX.  */\n \n tree\n build_vfn_ref (instance, idx)\n      tree instance, idx;\n {\n-  tree aref = build_vtbl_ref (instance, idx);\n+  tree aref = build_vtbl_ref_1 (instance, idx);\n \n   /* When using function descriptors, the address of the\n      vtable entry is treated as a function pointer.  */\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n-    return build1 (NOP_EXPR, TREE_TYPE (aref),\n+    aref = build1 (NOP_EXPR, TREE_TYPE (aref),\n \t\t   build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1));\n \n+  if (flag_vtable_gc)\n+    aref = build_vtable_entry_ref (aref, instance, idx);\n+\n   return aref;\n }\n "}, {"sha": "8c5dba175073d340c08c063c882631c4b2e63dcc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -2406,23 +2406,23 @@ output_vtable_inherit (vars)\n      tree vars;\n {\n   tree parent;\n-  rtx op[2];\n+  rtx child_rtx, parent_rtx;\n \n-  op[0] = XEXP (DECL_RTL (vars), 0);\t  /* strip the mem ref  */\n+  child_rtx = XEXP (DECL_RTL (vars), 0);\t  /* strip the mem ref  */\n \n   parent = binfo_for_vtable (vars);\n \n   if (parent == TYPE_BINFO (DECL_CONTEXT (vars)))\n-    op[1] = const0_rtx;\n+    parent_rtx = const0_rtx;\n   else if (parent)\n     {\n       parent = get_vtbl_decl_for_binfo (TYPE_BINFO (BINFO_TYPE (parent)));\n-      op[1] = XEXP (DECL_RTL (parent), 0);  /* strip the mem ref  */\n+      parent_rtx = XEXP (DECL_RTL (parent), 0);  /* strip the mem ref  */\n     }\n   else\n     my_friendly_abort (980826);\n \n-  output_asm_insn (\".vtable_inherit %c0, %c1\", op);\n+  assemble_vtable_inherit (child_rtx, parent_rtx);\n }\n \n static int"}, {"sha": "1c81f73670e084d6111a43ee19ab4cc3a3307a41", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -7211,6 +7211,43 @@ expand_expr (exp, target, tmode, modifier)\n \treturn target;\n       }\n \n+    case VTABLE_REF:\n+      {\n+\trtx insn, before = get_last_insn (), vtbl_ref;\n+\n+\t/* Evaluate the interior expression.  */\n+\tsubtarget = expand_expr (TREE_OPERAND (exp, 0), target,\n+\t\t\t\t tmode, modifier);\n+\n+\t/* Get or create an instruction off which to hang a note.  */\n+\tif (REG_P (subtarget))\n+\t  {\n+\t    target = subtarget;\n+\t    insn = get_last_insn ();\n+\t    if (insn == before)\n+\t      abort ();\n+\t    if (! INSN_P (insn))\n+\t      insn = prev_nonnote_insn (insn);\n+\t  }\n+\telse\n+\t  {\n+\t    target = gen_reg_rtx (GET_MODE (subtarget));\n+\t    insn = emit_move_insn (target, subtarget);\n+\t  }\n+\n+\t/* Collect the data for the note.  */\n+\tvtbl_ref = XEXP (DECL_RTL (TREE_OPERAND (exp, 1)), 0);\n+\tvtbl_ref = plus_constant (vtbl_ref,\n+\t\t\t\t  tree_low_cst (TREE_OPERAND (exp, 2), 0));\n+\t/* Discard the initial CONST that was added.  */\n+\tvtbl_ref = XEXP (vtbl_ref, 0);\n+\n+\tREG_NOTES (insn)\n+\t  = gen_rtx_EXPR_LIST (REG_VTABLE_REF, vtbl_ref, REG_NOTES (insn));\n+\n+\treturn target;\n+      }\n+\n       /* Intended for a reference to a buffer of a file-object in Pascal.\n \t But it's not certain that a special tree code will really be\n \t necessary for these.  INDIRECT_REF might work for them.  */"}, {"sha": "5884382b239172cd231960d6ce6e9e2cf7b18ea3", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -2375,9 +2375,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \trtx body = PATTERN (insn);\n \tint insn_code_number;\n \tconst char *template;\n-#ifdef HAVE_cc0\n \trtx note;\n-#endif\n \n \t/* An INSN, JUMP_INSN or CALL_INSN.\n \t   First check for special kinds that recog doesn't recognize.  */\n@@ -2799,7 +2797,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    if (next != 0 && next != NEXT_INSN (insn))\n \t      {\n \t\trtx prev = PREV_INSN (insn);\n-\t\trtx note;\n \n \t\tfor (note = NEXT_INSN (insn); note != next;\n \t\t     note = NEXT_INSN (note))\n@@ -2953,6 +2950,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tINSN_DELETED_P (insn) = 1;\n #endif\n \n+\t/* Emit information for vtable gc.  */\n+\tnote = find_reg_note (insn, REG_VTABLE_REF, NULL_RTX);\n+\tif (note)\n+\t  assemble_vtable_entry (XEXP (XEXP (note, 0), 0),\n+\t\t\t\t INTVAL (XEXP (XEXP (note, 0), 1)));\n+\n \tcurrent_output_insn = debug_insn = 0;\n       }\n     }"}, {"sha": "1e97c21253633f7649db37a31f95ef3d2df3ad8a", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -497,3 +497,8 @@ extern void default_named_section_asm_out_constructor PARAMS ((struct rtx_def *,\n \t\t\t\t\t\t\t       int));\n extern void default_ctor_section_asm_out_constructor PARAMS ((struct rtx_def *,\n \t\t\t\t\t\t\t      int));\n+\n+/* Emit data for vtable gc for GNU binutils.  */\n+extern void assemble_vtable_entry PARAMS ((struct rtx_def *, HOST_WIDE_INT));\n+extern void assemble_vtable_inherit PARAMS ((struct rtx_def *,\n+\t\t\t\t\t     struct rtx_def *));"}, {"sha": "7a07b7279c022d84bfd9f970d21ef7803880f29b", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -281,7 +281,8 @@ const char * const reg_note_name[] =\n   \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\",\n   \"REG_FRAME_RELATED_EXPR\", \"REG_EH_CONTEXT\", \"REG_EH_REGION\",\n   \"REG_SAVE_NOTE\", \"REG_MAYBE_DEAD\", \"REG_NORETURN\",\n-  \"REG_NON_LOCAL_GOTO\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\"\n+  \"REG_NON_LOCAL_GOTO\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\",\n+  \"REG_VTABLE_REF\"\n };\n \n \f"}, {"sha": "4c0eb2c4e83995647635436ab1f54fe7d602e372", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -579,7 +579,11 @@ enum reg_note\n   REG_SETJMP,\n \n   /* Indicate calls that always returns.  */\n-  REG_ALWAYS_RETURN\n+  REG_ALWAYS_RETURN,\n+\n+  /* Indicate that the memory load references a vtable.  The expression\n+     is of the form (plus (symbol_ref vtable_sym) (const_int offset)).  */\n+  REG_VTABLE_REF\n };\n \n /* The base value for branch probability notes.  */"}, {"sha": "d7fd68e6291f65e39f22b4ed13989c300ce086f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -1,3 +1,7 @@\n+2001-10-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.old-deja/g++.other/crash18.C: Add -S to options.\n+\n 2001-10-10  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* gcc.c-torture/compile/20011010-1.c: New."}, {"sha": "335d8b91d192dcca61cdf2373b7962aaa1adee0e", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash18.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash18.C?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -1,5 +1,5 @@\n // Build don't link:\n-// Special g++ Options: -fvtable-gc\n+// Special g++ Options: -fvtable-gc -S\n // Origin: Mark Mitchell <mitchell@codesourcery.com>\n \n struct S {"}, {"sha": "8a02e5b2f601ca47cfe4b34ddd374ba9e8d9a510", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -374,6 +374,13 @@ DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n    of the range is taken from the type of the expression.  */\n DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 2)\n \n+/* Vtable indexing.  Carries data useful for emitting information\n+   for vtable garbage collection.\n+   Operand 0: an array_ref (or equivalent expression)\n+   Operand 1: the vtable base (must be a var_decl)\n+   Operand 2: index into vtable (must be an integer_cst).  */\n+DEFTREECODE (VTABLE_REF, \"vtable_ref\", 'r', 3)\n+\n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n    Also used for SET_TYPE in Chill (and potentially Pascal)."}, {"sha": "0d6dc76c3a355a31a7eabcf451ca8533a95e007d", "filename": "gcc/varasm.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8d0c9c68d8ce12453255695bfab8b2111dd772/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4a8d0c9c68d8ce12453255695bfab8b2111dd772", "patch": "@@ -5297,3 +5297,32 @@ default_pe_asm_named_section (name, flags)\n \t       (flags & SECTION_CODE ? \"discard\" : \"same_size\"));\n     }\n }\n+\f\n+/* Used for vtable gc in GNU binutils.  Record that the pointer at OFFSET\n+   from SYMBOL is used in all classes derived from SYMBOL.  */\n+\n+void\n+assemble_vtable_entry (symbol, offset)\n+     rtx symbol;\n+     HOST_WIDE_INT offset;\n+{\n+  fputs (\"\\t.vtable_entry \", asm_out_file);\n+  output_addr_const (asm_out_file, symbol);\n+  fputs (\", \", asm_out_file);\n+  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, offset);\n+  fputc ('\\n', asm_out_file);\n+}\n+\n+/* Used for vtable gc in GNU binutils.  Record the class heirarchy by noting\n+   that the vtable symbol CHILD is derived from the vtable symbol PARENT.  */\n+\n+void\n+assemble_vtable_inherit (child, parent)\n+     rtx child, parent;\n+{\n+  fputs (\"\\t.vtable_inherit \", asm_out_file);\n+  output_addr_const (asm_out_file, child);\n+  fputs (\", \", asm_out_file);\n+  output_addr_const (asm_out_file, parent);\n+  fputc ('\\n', asm_out_file);\n+}"}]}