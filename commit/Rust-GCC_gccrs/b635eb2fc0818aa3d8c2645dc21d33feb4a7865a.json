{"sha": "b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzNWViMmZjMDgxOGFhM2Q4YzI2NDVkYzIxZDMzZmViNGE3ODY1YQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-27T16:05:24Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-27T16:05:24Z"}, "message": "parse.y (complete_loop_body): Rename to finish_loop_body.\n\nd\n\t* parse.y (complete_loop_body):  Rename to finish_loop_body.\n \t(complete_labeled_statement):  Rename to finish_labeled_statement.\n\t(complete_for_loop):  Rename to finish_for_loop.\n\t(complete_method_declaration):  Rename to finish_method_declaration.\n\t* java-tree.h (continue_identifier_node):  New global node.\n\t* decl.c:  Define and initialize continue_identifier_node.\n\t* parse.y (generate_labeled_block):  Remove - no longer needed.\n\t(build_loop_body):  Use continue_identifier_node for continue block.\n\t(finish_labeled_statement):  Also do pop_labeled_block actions.\n\t(java_complete_lhs):  POP_LOOP even if error.\n\t(build_labeled_block):  Special handling for continue_identifier_node.\n\t(patch_loop_statement):  Re-organize.\n\t(patch_bc_statement):  Re-write.\n\nFrom-SVN: r26015", "tree": {"sha": "81874e829f7c20e61a6ce7f04bcfff3a606ee62c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81874e829f7c20e61a6ce7f04bcfff3a606ee62c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a/comments", "author": null, "committer": null, "parents": [{"sha": "40b5a77c50dbc2531211bf1c4fa295ad2fc44aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b5a77c50dbc2531211bf1c4fa295ad2fc44aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b5a77c50dbc2531211bf1c4fa295ad2fc44aa8"}], "stats": {"total": 259, "additions": 104, "deletions": 155}, "files": [{"sha": "2925c043aa93f9c7082b3bb5d8a28d96603daeb9", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "patch": "@@ -221,6 +221,7 @@ extern tree void_signature_node;       /* \"()V\" */\n extern tree length_identifier_node;  /* \"length\" */\n extern tree this_identifier_node;  /* \"this\" */\n extern tree super_identifier_node;  /* \"super\" */\n+extern tree continue_identifier_node;  /* \"continue\" */\n extern tree one_elt_array_domain_type;\n extern tree void_type_node;\n extern tree ptr_type_node;"}, {"sha": "d05126ddbed04ffa00338c98f51588f2b81d4e6f", "filename": "gcc/java/parse.y", "status": "modified", "additions": 103, "deletions": 155, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b635eb2fc0818aa3d8c2645dc21d33feb4a7865a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=b635eb2fc0818aa3d8c2645dc21d33feb4a7865a", "patch": "@@ -186,16 +186,15 @@ static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n static tree add_stmt_to_block PROTO ((tree, tree, tree));\n static tree patch_exit_expr PROTO ((tree));\n static tree build_labeled_block PROTO ((int, tree));\n-static tree generate_labeled_block PROTO (());\n-static tree complete_labeled_statement PROTO ((tree, tree));\n+static tree finish_labeled_statement PROTO ((tree, tree));\n static tree build_bc_statement PROTO ((int, int, tree));\n static tree patch_bc_statement PROTO ((tree));\n static tree patch_loop_statement PROTO ((tree));\n static tree build_new_loop PROTO ((tree));\n static tree build_loop_body PROTO ((int, tree, int));\n-static tree complete_loop_body PROTO ((int, tree, tree, int));\n+static tree finish_loop_body PROTO ((int, tree, tree, int));\n static tree build_debugable_stmt PROTO ((int, tree));\n-static tree complete_for_loop PROTO ((int, tree, tree, tree));\n+static tree finish_for_loop PROTO ((int, tree, tree, tree));\n static tree patch_switch_statement PROTO ((tree));\n static tree string_constant_concatenation PROTO ((tree, tree));\n static tree build_string_concatenation PROTO ((tree, tree));\n@@ -210,7 +209,7 @@ static void check_thrown_exceptions PROTO ((int, tree));\n static int check_thrown_exceptions_do PROTO ((tree));\n static void purge_unchecked_exceptions PROTO ((tree));\n static void check_throws_clauses PROTO ((tree, tree, tree));\n-static void complete_method_declaration PROTO ((tree));\n+static void finish_method_declaration PROTO ((tree));\n static tree build_super_invocation PROTO (());\n static int verify_constructor_circularity PROTO ((tree, tree));\n static char *constructor_circularity_msg PROTO ((tree, tree));\n@@ -825,7 +824,7 @@ method_declaration:\n \t\t  source_start_java_method (current_function_decl);\n \t\t}\n \tmethod_body\n-\t\t{ complete_method_declaration ($3); }\n+\t\t{ finish_method_declaration ($3); }\n |\tmethod_header error\n \t\t{YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;}\n ;\n@@ -955,7 +954,7 @@ constructor_declaration:\n \t\t  source_start_java_method (current_function_decl);\n \t\t}\n \tconstructor_body\n-\t\t{ complete_method_declaration ($3); }\n+\t\t{ finish_method_declaration ($3); }\n ;\n \n constructor_header:\n@@ -1236,22 +1235,14 @@ label_decl:\n \n labeled_statement:\n \tlabel_decl statement\n-\t\t{ \n-\t\t  $$ = complete_labeled_statement ($1, $2);\n-\t\t  pop_labeled_block ();\n-\t\t  POP_LABELED_BLOCK ();\n-\t\t}\n+\t\t{ $$ = finish_labeled_statement ($1, $2); }\n |\tidentifier error\n \t\t{yyerror (\"':' expected\"); RECOVER;}\n ;\n \n labeled_statement_nsi:\n \tlabel_decl statement_nsi\n-\t\t{ \n-\t\t  $$ = complete_labeled_statement ($1, $2);\n-\t\t  pop_labeled_block ();\n-\t\t  POP_LABELED_BLOCK ();\n-\t\t}\n+\t\t{ $$ = finish_labeled_statement ($1, $2); }\n ;\n \n /* We concentrate here a bunch of error handling rules that we couldn't write\n@@ -1435,7 +1426,7 @@ while_expression:\n \n while_statement:\n \twhile_expression statement\n-\t\t{ $$ = complete_loop_body (0, NULL_TREE, $2, 0); }\n+\t\t{ $$ = finish_loop_body (0, NULL_TREE, $2, 0); }\n |\tWHILE_TK error\n \t\t{YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;}\n |\tWHILE_TK OP_TK error\n@@ -1446,7 +1437,7 @@ while_statement:\n \n while_statement_nsi:\n \twhile_expression statement_nsi\n-\t\t{ $$ = complete_loop_body (0, NULL_TREE, $2, 0); }\n+\t\t{ $$ = finish_loop_body (0, NULL_TREE, $2, 0); }\n ;\n \n do_statement_begin:\n@@ -1460,15 +1451,15 @@ do_statement_begin:\n \n do_statement: \n \tdo_statement_begin statement WHILE_TK OP_TK expression CP_TK SC_TK\n-\t\t{ $$ = complete_loop_body ($4.location, $5, $2, 1); }\n+\t\t{ $$ = finish_loop_body ($4.location, $5, $2, 1); }\n ;\n \n for_statement:\n \tfor_begin SC_TK expression SC_TK for_update CP_TK statement\n-\t\t{ $$ = complete_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7); }\n+\t\t{ $$ = finish_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7); }\n |\tfor_begin SC_TK SC_TK for_update CP_TK statement\n \t\t{ \n-\t\t  $$ = complete_for_loop (0, NULL_TREE, $4, $6);\n+\t\t  $$ = finish_for_loop (0, NULL_TREE, $4, $6);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY ($$), 0) = \n \t\t    empty_stmt_node;\n@@ -1483,10 +1474,10 @@ for_statement:\n \n for_statement_nsi:\n \tfor_begin SC_TK expression SC_TK for_update CP_TK statement_nsi\n-\t\t{ $$ = complete_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7);}\n+\t\t{ $$ = finish_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7);}\n |\tfor_begin SC_TK SC_TK for_update CP_TK statement_nsi\n \t\t{ \n-\t\t  $$ = complete_for_loop (0, NULL_TREE, $4, $6);\n+\t\t  $$ = finish_for_loop (0, NULL_TREE, $4, $6);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY ($$), 0) = \n \t\t    empty_stmt_node;\n@@ -3469,7 +3460,7 @@ fix_method_argument_names (orig_arg, meth)\n /* Complete the method declaration with METHOD_BODY.  */\n \n static void\n-complete_method_declaration (method_body)\n+finish_method_declaration (method_body)\n      tree method_body;\n {\n   BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (current_function_decl)) = method_body;\n@@ -7817,15 +7808,18 @@ java_complete_lhs (node)\n \tnode = patch_switch_statement (node);\n \n       if (TREE_OPERAND (node, 0) == error_mark_node)\n-\treturn error_mark_node;\n-      TREE_TYPE (nn) = TREE_TYPE (node) = void_type_node;\n-      /* If we returned something different, that's because we\n-         inserted a label. Pop the label too. */\n-      if (nn != node)\n+\tnn = error_mark_node;\n+      else\n \t{\n-\t  if (CAN_COMPLETE_NORMALLY (node))\n-\t    CAN_COMPLETE_NORMALLY (nn) = 1;\n-\t  POP_LABELED_BLOCK ();\n+\t  TREE_TYPE (nn) = TREE_TYPE (node) = void_type_node;\n+\t  /* If we returned something different, that's because we\n+\t     inserted a label. Pop the label too. */\n+\t  if (nn != node)\n+\t    {\n+\t      if (CAN_COMPLETE_NORMALLY (node))\n+\t\tCAN_COMPLETE_NORMALLY (nn) = 1;\n+\t      POP_LABELED_BLOCK ();\n+\t    }\n \t}\n       POP_LOOP ();\n       return nn;\n@@ -10390,30 +10384,35 @@ patch_if_else_statement (node)\n \n /* Action taken when a lableled statement is parsed. a new\n    LABELED_BLOCK_EXPR is created. No statement is attached to the\n-   label, yet.  */\n+   label, yet.  LABEL can be NULL_TREE for artificially-generated blocks. */\n \n static tree\n build_labeled_block (location, label)\n      int location;\n      tree label;\n {\n-  tree label_name = merge_qualified_name (label_id, label);\n+  tree label_name ;\n   tree label_decl, node;\n-\n-  /* Issue an error if we try to reuse a label that was previously\n-     declared */\n-  if (IDENTIFIER_LOCAL_VALUE (label_name))\n+  if (label == NULL_TREE || label == continue_identifier_node)\n+    label_name = label;\n+  else\n     {\n-      EXPR_WFL_LINECOL (wfl_operator) = location;\n-      parse_error_context (wfl_operator, \"Declaration of `%s' shadows \"\n-\t\t\t     \"a previous label declaration\",\n-\t\t\t     IDENTIFIER_POINTER (label));\n-      EXPR_WFL_LINECOL (wfl_operator) = \n-        EXPR_WFL_LINECOL (IDENTIFIER_LOCAL_VALUE (label_name));\n-      parse_error_context (wfl_operator, \"This is the location of the \"\n-\t\t\t   \"previous declaration of label `%s'\",\n-\t\t\t   IDENTIFIER_POINTER (label));\n-      java_error_count--;\n+      label_name = merge_qualified_name (label_id, label);\n+      /* Issue an error if we try to reuse a label that was previously\n+\t declared */\n+      if (IDENTIFIER_LOCAL_VALUE (label_name))\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = location;\n+\t  parse_error_context (wfl_operator, \"Declaration of `%s' shadows \"\n+\t\t\t       \"a previous label declaration\",\n+\t\t\t       IDENTIFIER_POINTER (label));\n+\t  EXPR_WFL_LINECOL (wfl_operator) = \n+\t    EXPR_WFL_LINECOL (IDENTIFIER_LOCAL_VALUE (label_name));\n+\t  parse_error_context (wfl_operator, \"This is the location of the \"\n+\t\t\t       \"previous declaration of label `%s'\",\n+\t\t\t       IDENTIFIER_POINTER (label));\n+\t  java_error_count--;\n+\t}\n     }\n \n   label_decl = create_label_decl (label_name);\n@@ -10423,20 +10422,10 @@ build_labeled_block (location, label)\n   return node;\n }\n \n-/* Generate a label crafting a unique name for it. This is used to\n-   implicitely label loops that aren't the body part of labeled\n-   statement.  */\n-\n-static tree\n-generate_labeled_block ()\n-{\n-  return build_labeled_block (0, generate_name ());\n-}\n-\n /* A labeled statement LBE is attached a statement.  */\n \n static tree\n-complete_labeled_statement (lbe, statement)\n+finish_labeled_statement (lbe, statement)\n      tree lbe;\t\t\t/* Labeled block expr */\n      tree statement;\n {\n@@ -10449,9 +10438,10 @@ complete_labeled_statement (lbe, statement)\n   if (TREE_CODE (statement) == LOOP_EXPR && IS_FOR_LOOP_P (statement))\n     {\n       java_method_add_stmt (current_function_decl, lbe);\n-      return exit_block ();\n+      lbe = exit_block ();\n     }\n-\n+  pop_labeled_block ();\n+  POP_LABELED_BLOCK ();\n   return lbe;\n }\n \n@@ -10503,7 +10493,7 @@ build_loop_body (location, condition, reversed)\n   condition = build_debugable_stmt (location, condition);\n   TREE_SIDE_EFFECTS (condition) = 1;\n \n-  body = generate_labeled_block ();\n+  body = build_labeled_block (0, continue_identifier_node);\n   first = (reversed ? body : condition);\n   second = (reversed ? condition : body);\n   return \n@@ -10516,7 +10506,7 @@ build_loop_body (location, condition, reversed)\n    loop list.  */\n \n static tree\n-complete_loop_body (location, condition, body, reversed)\n+finish_loop_body (location, condition, body, reversed)\n      int location;\n      tree condition, body;\n      int reversed;\n@@ -10538,45 +10528,38 @@ complete_loop_body (location, condition, body, reversed)\n   return to_return;\n }\n \n-/* Tailored version of complete_loop_body for FOR loops, when FOR\n+/* Tailored version of finish_loop_body for FOR loops, when FOR\n    loops feature the condition part */\n \n static tree\n-complete_for_loop (location, condition, update, body)\n+finish_for_loop (location, condition, update, body)\n     int location;\n     tree condition, update, body;\n {\n   /* Put the condition and the loop body in place */\n-  tree loop = complete_loop_body (location, condition, body, 0);\n+  tree loop = finish_loop_body (location, condition, body, 0);\n   /* LOOP is the current loop which has been now popped of the loop\n      stack. Install the update block */\n   LOOP_EXPR_BODY_UPDATE_BLOCK (LOOP_EXPR_BODY (loop)) = update;\n   return loop;\n }\n \n /* If the loop isn't surrounded by a labeled statement, create one and\n-   insert LOOP as it's body.  */\n+   insert LOOP as its body.  */\n \n static tree\n patch_loop_statement (loop)\n      tree loop;\n {\n-  tree loop_label, to_return_as_loop;\n-\n-  if (LOOP_HAS_LABEL_P (loop))\n-    {\n-      loop_label = ctxp->current_labeled_block;\n-      to_return_as_loop = loop;\n-    }\n-  else\n+  if (! LOOP_HAS_LABEL_P (loop))\n     {\n-      loop_label = generate_labeled_block ();\n+      tree loop_label = build_labeled_block (0, NULL_TREE);\n       LABELED_BLOCK_BODY (loop_label) = loop;\n       PUSH_LABELED_BLOCK (loop_label);\n-      to_return_as_loop = loop_label;\n+      loop = loop_label;\n     }\n-  TREE_TYPE (to_return_as_loop) = void_type_node;\n-  return to_return_as_loop;\n+  TREE_TYPE (loop) = void_type_node;\n+  return loop;\n }\n \n /* 14.13, 14.14: break and continue Statements */\n@@ -10620,98 +10603,63 @@ patch_bc_statement (node)\n      tree node;\n {\n   tree bc_label = EXIT_BLOCK_LABELED_BLOCK (node), target_stmt;\n-  int is_unlabeled = 0;\n+  tree labeled_block = ctxp->current_labeled_block;\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n  \n-  /* Not having a target means that the break/continue statement is\n-     unlabeled. We try to find a decent label for it */\n-  if (!bc_label)\n-    {\n-      is_unlabeled = 1;\n-      /* There should be a loop/switch to branch to */\n-      if (ctxp->current_loop)\n-\t{\n-\t  if (TREE_CODE (ctxp->current_loop) == LOOP_EXPR)\n-\t    {\n-\t      /* At that stage, we're in the loop body, which is\n-\t\t encapsulated around a LABELED_BLOCK_EXPR. So searching\n-\t\t the current loop label requires us to consider the\n-\t\t labeled block before the current one. */\n-\t      if (!LOOP_HAS_LABEL_SKIP_P (ctxp->current_loop))\n-\t\tfatal (\"unlabeled loop has no installed label -- \"\n-\t\t       \"patch_bc_statement\");\n-\t      bc_label = TREE_CHAIN (ctxp->current_labeled_block);\n-\t    }\n-\t  /* For a SWITCH statement, this is the current one */\n-\t  else\n-\t    bc_label = ctxp->current_labeled_block;\n-\t}\n-      /* Not having a loop to break/continue to is an error */\n-      else\n-\t{\n-\t  parse_error_context (wfl_operator, \"`%s' must be in loop%s\",\n-\t\t\t       (IS_BREAK_STMT_P (node) ? \"break\" : \"continue\"),\n-\t\t\t       (IS_BREAK_STMT_P (node) ? \" or switch\" : \"\"));\n-\t  return error_mark_node;\n-\t}\n-    }\n   /* Having an identifier here means that the target is unknown. */\n-  else if (TREE_CODE (bc_label) == IDENTIFIER_NODE)\n+  if (bc_label != NULL_TREE && TREE_CODE (bc_label) == IDENTIFIER_NODE)\n     {\n       parse_error_context (wfl_operator, \"No label definition found for `%s'\",\n \t\t\t   IDENTIFIER_POINTER (bc_label));\n       return error_mark_node;\n     }\n-\n-  /* Find the statement we're targeting. */\n-  target_stmt = LABELED_BLOCK_BODY (bc_label);\n-\n-  /* Target loop is slightly burrowed in the case of a for loop, it\n-     appears at the first sight to be a block. */\n-  if (TREE_CODE (target_stmt) == BLOCK)\n-    {\n-      tree sub = BLOCK_SUBBLOCKS (target_stmt);\n-      if (sub && TREE_CODE (sub) == COMPOUND_EXPR && TREE_OPERAND (sub, 1)\n-\t  && TREE_CODE (TREE_OPERAND (sub, 1)) == LOOP_EXPR)\n-\ttarget_stmt = TREE_OPERAND (sub, 1);\n-    }\n-\n-  /* 14.13 The break Statement */\n-  if (IS_BREAK_STMT_P (node))\n+  if (! IS_BREAK_STMT_P (node))\n     {\n-      /* Named break are always fine, as far as they have a target\n-         (already verified). Anonymous break need to target\n-         while/do/for/switch */\n-      if (is_unlabeled &&\n-\t  !(TREE_CODE (target_stmt) == LOOP_EXPR        /* do/while/for */\n-\t    || TREE_CODE (target_stmt) == SWITCH_EXPR)) /* switch */\n+      /* It's a continue statement. */\n+      for (;; labeled_block = TREE_CHAIN (labeled_block))\n \t{\n-\t  parse_error_context (wfl_operator, \n-\t\t\t       \"`break' must be in loop or switch\");\n-\t  return error_mark_node;\n+\t  if (labeled_block == NULL_TREE)\n+\t    {\n+\t      if (bc_label == NULL_TREE)\n+\t\tparse_error_context (wfl_operator,\n+\t\t\t\t     \"`continue' must be in loop\");\n+\t      else\n+\t\tparse_error_context (wfl_operator,\n+\t\t\t\t     \"continue label `%d' does not name a loop\",\n+\t\t\t\t     IDENTIFIER_POINTER (bc_label));\n+\t      return error_mark_node;\n+\t    }\n+\t  if ((DECL_NAME (LABELED_BLOCK_LABEL (labeled_block))\n+\t       == continue_identifier_node)\n+\t      && (bc_label == NULL_TREE\n+\t\t  || TREE_CHAIN (labeled_block) == bc_label))\n+\t    {\n+\t      bc_label = labeled_block;\n+\t      break;\n+\t    }\n \t}\n-      /* If previously unlabeled, install the new found label */\n-      if (is_unlabeled)\n-\tEXIT_BLOCK_LABELED_BLOCK (node) = bc_label;\n     }\n-  /* 14.14 The continue Statement */\n-  /* The continue statement must always target a loop, unnamed or not. */\n-  else \n+  else if (!bc_label)\n     { \n-      if (TREE_CODE (target_stmt) != LOOP_EXPR) /* do/while/for */\n+      for (;; labeled_block = TREE_CHAIN (labeled_block))\n \t{\n-\t  parse_error_context (wfl_operator, \"`continue' must be in loop\");\n-\t  return error_mark_node;\n+\t  if (labeled_block == NULL_TREE)\n+\t    {\n+\t      parse_error_context (wfl_operator,\n+\t\t\t\t     \"`break' must be in loop or switch\");\n+\t      return error_mark_node;\n+\t    }\n+\t  target_stmt = LABELED_BLOCK_BODY (labeled_block);\n+\t  if (TREE_CODE (target_stmt) == SWITCH_EXPR\n+\t      || TREE_CODE (target_stmt) == LOOP_EXPR)\n+\t    {\n+\t      bc_label = labeled_block;\n+\t      break;\n+\t    }\n \t}\n-      /* Everything looks good. We can fix the `continue' jump to go\n-\t at the place in the loop were the continue is.  For unlabeled\n-\t continue, the continuation point is the current labeled\n-\t block, by construction. */\n-      if (is_unlabeled)\n-\tEXIT_BLOCK_LABELED_BLOCK (node) = \n-\t  bc_label = ctxp->current_labeled_block;\n     }\n \n+  EXIT_BLOCK_LABELED_BLOCK (node) = bc_label;\n   CAN_COMPLETE_NORMALLY (bc_label) = 1;\n \n   /* Our break/continue don't return values. */"}]}