{"sha": "820055a0ac3fcd19230eedacd223d5970d359023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwMDU1YTBhYzNmY2QxOTIzMGVlZGFjZDIyM2Q1OTcwZDM1OTAyMw==", "commit": {"author": {"name": "Dehao Chen", "email": "dehao@google.com", "date": "2012-09-15T00:41:53Z"}, "committer": {"name": "Dehao Chen", "email": "dehao@gcc.gnu.org", "date": "2012-09-15T00:41:53Z"}, "message": "tree-eh.c (goto_queue_node): New field.\n\ngcc:\n\t* tree-eh.c (goto_queue_node): New field.\n\t(record_in_goto_queue): New parameter.\n\t(record_in_goto_queue_label): New parameter.\n\t(lower_try_finally_dup_block): New parameter.\n\t(maybe_record_in_goto_queue): Update source location.\n\t(lower_try_finally_copy): Likewise.\n\t(honor_protect_cleanup_actions): Likewise.\n\t* gimplify.c (gimplify_expr): Reset the location to unknown.\n\ntestsuite:\n\t* g++.dg/debug/dwarf2/deallocator.C: New test.\n\nlibjava:\n\t* testsuite/libjava.lang/sourcelocation.java: New cases.\n\t* testsuite/libjava.lang/sourcelocation.out: New cases.\n\nFrom-SVN: r191338", "tree": {"sha": "115ae76940c014469cce56102bf49986451e09d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/115ae76940c014469cce56102bf49986451e09d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/820055a0ac3fcd19230eedacd223d5970d359023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820055a0ac3fcd19230eedacd223d5970d359023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820055a0ac3fcd19230eedacd223d5970d359023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820055a0ac3fcd19230eedacd223d5970d359023/comments", "author": {"login": "danielcdh", "id": 694263, "node_id": "MDQ6VXNlcjY5NDI2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/694263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielcdh", "html_url": "https://github.com/danielcdh", "followers_url": "https://api.github.com/users/danielcdh/followers", "following_url": "https://api.github.com/users/danielcdh/following{/other_user}", "gists_url": "https://api.github.com/users/danielcdh/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielcdh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielcdh/subscriptions", "organizations_url": "https://api.github.com/users/danielcdh/orgs", "repos_url": "https://api.github.com/users/danielcdh/repos", "events_url": "https://api.github.com/users/danielcdh/events{/privacy}", "received_events_url": "https://api.github.com/users/danielcdh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71452ccd312778e267d76951267d37957c421aa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71452ccd312778e267d76951267d37957c421aa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71452ccd312778e267d76951267d37957c421aa1"}], "stats": {"total": 121, "additions": 109, "deletions": 12}, "files": [{"sha": "cc1ff1921d79c1b46474ea59d6507353a70526e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -1,3 +1,14 @@\n+2012-09-14  Dehao Chen  <dehao@google.com>\n+\n+\t * tree-eh.c (goto_queue_node): New field.\n+\t(record_in_goto_queue): New parameter.\n+\t(record_in_goto_queue_label): New parameter.\n+\t(lower_try_finally_dup_block): New parameter.\n+\t(maybe_record_in_goto_queue): Update source location.\n+\t(lower_try_finally_copy): Likewise.\n+\t(honor_protect_cleanup_actions): Likewise.\n+\t* gimplify.c (gimplify_expr): Reset the location to unknown.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated."}, {"sha": "31883162e66ee9d857d30fb872a89c07bce9ea6a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -7453,6 +7453,15 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    gimple_seq eval, cleanup;\n \t    gimple try_;\n \n+\t    /* Calls to destructors are generated automatically in FINALLY/CATCH\n+\t       block. They should have location as UNKNOWN_LOCATION. However,\n+\t       gimplify_call_expr will reset these call stmts to input_location\n+\t       if it finds stmt's location is unknown. To prevent resetting for\n+\t       destructors, we set the input_location to unknown.\n+\t       Note that this only affects the destructor calls in FINALLY/CATCH\n+\t       block, and will automatically reset to its original value by the\n+\t       end of gimplify_expr.  */\n+\t    input_location = UNKNOWN_LOCATION;\n \t    eval = cleanup = NULL;\n \t    gimplify_and_add (TREE_OPERAND (*expr_p, 0), &eval);\n \t    gimplify_and_add (TREE_OPERAND (*expr_p, 1), &cleanup);"}, {"sha": "9a2ef739c884d3cc6a8e10d9514e33f3211c52cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -1,3 +1,7 @@\n+2012-09-14  Dehao Chen  <dehao@google.com>\n+\n+\t* g++.dg/debug/dwarf2/deallocator.C: New test.\n+\n 2012-09-14  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/54552"}, {"sha": "eab38a3ade29cdfab90089f4e3c5e675dadb702c", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/deallocator.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdeallocator.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdeallocator.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdeallocator.C?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -0,0 +1,33 @@\n+// Test that debug info generated for auto-inserted deallocator is\n+// correctly attributed.\n+// This patch scans for the lineno directly from assembly, which may\n+// differ between different architectures. Because it mainly tests\n+// FE generated debug info, without losing generality, only x86\n+// assembly is scanned in this test.\n+// { dg-do compile { target { i?86-*-* x86_64-*-* } } }\n+// { dg-options \"-O2 -fno-exceptions -g -dA\" }\n+\n+struct t {\n+  t ();\n+  ~t ();\n+  void foo();\n+  void bar();\n+};\n+\n+int bar();\n+\n+void foo(int i)\n+{\n+  for (int j = 0; j < 10; j++)\n+    {\n+      t test;\n+      test.foo();\n+      if (i + j)\n+\t{\n+\t  test.bar();\n+\t  return;\n+\t}\n+    }\n+  return;\n+}\n+// { dg-final { scan-assembler \"deallocator.C:28\" } }"}, {"sha": "65f85c94605b71460bc4bebd149fbc2f7a0e73a7", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -321,6 +321,7 @@ static bitmap eh_region_may_contain_throw_map;\n struct goto_queue_node\n {\n   treemple stmt;\n+  location_t location;\n   gimple_seq repl_stmt;\n   gimple cont_stmt;\n   int index;\n@@ -560,7 +561,8 @@ static void\n record_in_goto_queue (struct leh_tf_state *tf,\n                       treemple new_stmt,\n                       int index,\n-                      bool is_label)\n+                      bool is_label,\n+\t\t      location_t location)\n {\n   size_t active, size;\n   struct goto_queue_node *q;\n@@ -583,14 +585,16 @@ record_in_goto_queue (struct leh_tf_state *tf,\n   memset (q, 0, sizeof (*q));\n   q->stmt = new_stmt;\n   q->index = index;\n+  q->location = location;\n   q->is_label = is_label;\n }\n \n /* Record the LABEL label in the goto queue contained in TF.\n    TF is not null.  */\n \n static void\n-record_in_goto_queue_label (struct leh_tf_state *tf, treemple stmt, tree label)\n+record_in_goto_queue_label (struct leh_tf_state *tf, treemple stmt, tree label,\n+\t\t\t    location_t location)\n {\n   int index;\n   treemple temp, new_stmt;\n@@ -629,7 +633,7 @@ record_in_goto_queue_label (struct leh_tf_state *tf, treemple stmt, tree label)\n      since with a GIMPLE_COND we have an easy access to the then/else\n      labels. */\n   new_stmt = stmt;\n-  record_in_goto_queue (tf, new_stmt, index, true);\n+  record_in_goto_queue (tf, new_stmt, index, true, location);\n }\n \n /* For any GIMPLE_GOTO or GIMPLE_RETURN, decide whether it leaves a try_finally\n@@ -649,19 +653,22 @@ maybe_record_in_goto_queue (struct leh_state *state, gimple stmt)\n     {\n     case GIMPLE_COND:\n       new_stmt.tp = gimple_op_ptr (stmt, 2);\n-      record_in_goto_queue_label (tf, new_stmt, gimple_cond_true_label (stmt));\n+      record_in_goto_queue_label (tf, new_stmt, gimple_cond_true_label (stmt),\n+\t\t\t\t  EXPR_LOCATION (*new_stmt.tp));\n       new_stmt.tp = gimple_op_ptr (stmt, 3);\n-      record_in_goto_queue_label (tf, new_stmt, gimple_cond_false_label (stmt));\n+      record_in_goto_queue_label (tf, new_stmt, gimple_cond_false_label (stmt),\n+\t\t\t\t  EXPR_LOCATION (*new_stmt.tp));\n       break;\n     case GIMPLE_GOTO:\n       new_stmt.g = stmt;\n-      record_in_goto_queue_label (tf, new_stmt, gimple_goto_dest (stmt));\n+      record_in_goto_queue_label (tf, new_stmt, gimple_goto_dest (stmt),\n+\t\t\t\t  gimple_location (stmt));\n       break;\n \n     case GIMPLE_RETURN:\n       tf->may_return = true;\n       new_stmt.g = stmt;\n-      record_in_goto_queue (tf, new_stmt, -1, false);\n+      record_in_goto_queue (tf, new_stmt, -1, false, gimple_location (stmt));\n       break;\n \n     default:\n@@ -866,13 +873,19 @@ frob_into_branch_around (gimple tp, eh_region region, tree over)\n    Make sure to record all new labels found.  */\n \n static gimple_seq\n-lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state)\n+lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state,\n+\t\t\t     location_t loc)\n {\n   gimple region = NULL;\n   gimple_seq new_seq;\n+  gimple_stmt_iterator gsi;\n \n   new_seq = copy_gimple_seq_and_replace_locals (seq);\n \n+  for (gsi = gsi_start (new_seq); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (gimple_location (gsi_stmt (gsi)) == UNKNOWN_LOCATION)\n+      gimple_set_location (gsi_stmt (gsi), loc);\n+\n   if (outer_state->tf)\n     region = outer_state->tf->try_finally_expr;\n   collect_finally_tree_1 (new_seq, region);\n@@ -967,7 +980,8 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n       gimple_try_set_cleanup (tf->top_p, gimple_eh_else_n_body (eh_else));\n     }\n   else if (this_state)\n-    finally = lower_try_finally_dup_block (finally, outer_state);\n+    finally = lower_try_finally_dup_block (finally, outer_state,\n+\t\t\t\t\t   UNKNOWN_LOCATION);\n   finally_may_fallthru = gimple_seq_may_fallthru (finally);\n \n   /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP\n@@ -1184,7 +1198,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \n   if (tf->may_fallthru)\n     {\n-      seq = lower_try_finally_dup_block (finally, state);\n+      seq = lower_try_finally_dup_block (finally, state, tf_loc);\n       lower_eh_constructs_1 (state, &seq);\n       gimple_seq_add_seq (&new_stmt, seq);\n \n@@ -1200,7 +1214,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n       if (eh_else)\n \tseq = gimple_eh_else_e_body (eh_else);\n       else\n-\tseq = lower_try_finally_dup_block (finally, state);\n+\tseq = lower_try_finally_dup_block (finally, state, tf_loc);\n       lower_eh_constructs_1 (state, &seq);\n \n       emit_post_landing_pad (&eh_seq, tf->region);\n@@ -1250,7 +1264,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \t  x = gimple_build_label (lab);\n           gimple_seq_add_stmt (&new_stmt, x);\n \n-\t  seq = lower_try_finally_dup_block (finally, state);\n+\t  seq = lower_try_finally_dup_block (finally, state, q->location);\n \t  lower_eh_constructs_1 (state, &seq);\n           gimple_seq_add_seq (&new_stmt, seq);\n "}, {"sha": "69b13d7222cd4b3cd7ec3f65dd1d3b8fd1bc662f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -1,3 +1,8 @@\n+2012-09-14  Dehao Chen  <dehao@google.com>\n+\n+\t* testsuite/libjava.lang/sourcelocation.java: New cases.\n+\t* testsuite/libjava.lang/sourcelocation.out: New cases.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated."}, {"sha": "90f38f4b8bb93df367277ebcb530c98aaf37d1ff", "filename": "libjava/testsuite/libjava.lang/sourcelocation.jar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.jar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.jar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.jar?ref=820055a0ac3fcd19230eedacd223d5970d359023"}, {"sha": "6cf1e40ef4a8c8706e4763e398749f722f978bce", "filename": "libjava/testsuite/libjava.lang/sourcelocation.java", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.java?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -0,0 +1,18 @@\n+/* This test should test the source location attribution.\n+   We print the line number of different parts of the program to make sure\n+   that the source code attribution is correct.\n+   To make this test pass, one need to have up-to-date addr2line installed\n+   to parse the dwarf4 data format.\n+*/\n+public class sourcelocation {\n+  public static void main(String args[]) {\n+    try {\n+      System.out.println(new Exception().getStackTrace()[0].getLineNumber());\n+      throw new Exception();\n+    } catch (Exception e) {\n+      System.out.println(new Exception().getStackTrace()[0].getLineNumber());\n+    } finally {\n+      System.out.println(new Exception().getStackTrace()[0].getLineNumber());\n+    }\n+  }\n+}"}, {"sha": "781c91b5c39a5120e81da825f02438ed5d0c57a3", "filename": "libjava/testsuite/libjava.lang/sourcelocation.out", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820055a0ac3fcd19230eedacd223d5970d359023/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fsourcelocation.out?ref=820055a0ac3fcd19230eedacd223d5970d359023", "patch": "@@ -0,0 +1,3 @@\n+10\n+13\n+15"}]}