{"sha": "893bc853685bc2cb3c3b3394c0abf78c695c8df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzYmM4NTM2ODViYzJjYjNjM2IzMzk0YzBhYmY3OGM2OTVjOGRmMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:37:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:37:25Z"}, "message": "(reload): Process and accumulate needs for RELOAD_FOR_OPADDR_ADDR reloads.\n\nWhen determining if needs are nongroup needs, ignore inactive or optional\nreloads.\n(reload_reg_used_in_op_addr_reload): New variable to indicate when reloads of\nclass RELOAD_FOR_OPADDR_ADDR are in use.\n(mark_reload_reg_in_use, clear_reload_reg_in_use): Process reloads of class\nRELOAD_FOR_OPADDR_ADDR.\n(reload_reg_free_p, reload_reg_free_before_p, reloads_conflict): Likewise.\n(choose_reload_regs): Support RELOAD_FOR_OPADDR_ADDR reloads.\n(emit_reload_insns): Output RELOAD_FOR_OPADDR_ADDR reloads.\n\nFrom-SVN: r7462", "tree": {"sha": "3bb519f4206cba3494434fff400b0421e30ad30d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bb519f4206cba3494434fff400b0421e30ad30d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893bc853685bc2cb3c3b3394c0abf78c695c8df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893bc853685bc2cb3c3b3394c0abf78c695c8df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893bc853685bc2cb3c3b3394c0abf78c695c8df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893bc853685bc2cb3c3b3394c0abf78c695c8df1/comments", "author": null, "committer": null, "parents": [{"sha": "f98bb7d33fd1b44f3101f008d925ff4de5bc389c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98bb7d33fd1b44f3101f008d925ff4de5bc389c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98bb7d33fd1b44f3101f008d925ff4de5bc389c"}], "stats": {"total": 102, "additions": 89, "deletions": 13}, "files": [{"sha": "d32e91fc3135d5811d5d5b07baed3eaadbd139e8", "filename": "gcc/reload1.c", "status": "modified", "additions": 89, "deletions": 13, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893bc853685bc2cb3c3b3394c0abf78c695c8df1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893bc853685bc2cb3c3b3394c0abf78c695c8df1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=893bc853685bc2cb3c3b3394c0abf78c695c8df1", "patch": "@@ -945,6 +945,7 @@ reload (first, global, dumpfile)\n \t\tstruct needs insn;\n \t\tstruct needs other_addr;\n \t\tstruct needs op_addr;\n+\t\tstruct needs op_addr_reload;\n \t\tstruct needs in_addr[MAX_RECOG_OPERANDS];\n \t\tstruct needs out_addr[MAX_RECOG_OPERANDS];\n \t      } insn_needs;\n@@ -1073,6 +1074,9 @@ reload (first, global, dumpfile)\n \t\t\t\t\t    ? reload_outmode[j]\n \t\t\t\t\t    : reload_inmode[j])\n \t\t\t   > 1)\n+\t\t\t  && (!reload_optional[j])\n+\t\t\t  && (reload_in[j] != 0 || reload_out[j] != 0\n+\t\t\t      || reload_secondary_p[j])\n \t\t\t  && reloads_conflict (i, j)\n \t\t\t  && reg_classes_intersect_p (class,\n \t\t\t\t\t\t      reload_reg_class[j]))\n@@ -1108,6 +1112,9 @@ reload (first, global, dumpfile)\n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t\t      this_needs = &insn_needs.op_addr;\n \t\t      break;\n+\t\t    case RELOAD_FOR_OPADDR_ADDR:\n+\t\t      this_needs = &insn_needs.op_addr_reload;\n+\t\t      break;\n \t\t    }\n \n \t\t  if (size > 1)\n@@ -1184,7 +1191,10 @@ reload (first, global, dumpfile)\n \t\t\t don't conflict with things needed to reload inputs or\n \t\t\t outputs. */\n \n-\t\t      in_max = MAX (in_max, insn_needs.op_addr.regs[j][i]);\n+\t\t      in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n+\t\t\t\t\t insn_needs.op_addr_reload.regs[j][i]),\n+\t\t\t\t    in_max);\n+\n \t\t      out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n \n \t\t      insn_needs.input.regs[j][i]\n@@ -1210,7 +1220,9 @@ reload (first, global, dumpfile)\n \t\t\t= MAX (out_max, insn_needs.out_addr[j].groups[i]);\n \t\t    }\n \n-\t\t  in_max = MAX (in_max, insn_needs.op_addr.groups[i]);\n+\t\t  in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n+\t\t\t\t     insn_needs.op_addr_reload.groups[i]),\n+\t\t\t\tin_max);\n \t\t  out_max = MAX (out_max, insn_needs.insn.groups[i]);\n \n \t\t  insn_needs.input.groups[i]\n@@ -3106,6 +3118,8 @@ eliminate_regs_in_insn (insn, replace)\n {\n   rtx old_body = PATTERN (insn);\n   rtx new_body;\n+  rtx old_set;\n+  rtx new_set;\n   int val = 0;\n   struct elim_table *ep;\n \n@@ -3176,6 +3190,12 @@ eliminate_regs_in_insn (insn, replace)\n   new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n   if (new_body != old_body)\n     {\n+      old_set = (GET_CODE (old_body) == PARALLEL) ? single_set (insn) :\n+\told_body;\n+\n+      new_set = (GET_CODE (new_body) == PARALLEL) ? XVECEXP(new_body,0,0) :\n+\tnew_body;\n+\n       /* If we aren't replacing things permanently and we changed something,\n \t make another copy to ensure that all the RTL is new.  Otherwise\n \t things can go wrong if find_reload swaps commutative operands\n@@ -3187,22 +3207,25 @@ eliminate_regs_in_insn (insn, replace)\n \tnew_body = copy_rtx (new_body);\n \n       /* If we had a move insn but now we don't, rerecognize it.  */\n-      if ((GET_CODE (old_body) == SET && GET_CODE (SET_SRC (old_body)) == REG\n-\t   && (GET_CODE (new_body) != SET\n-\t       || GET_CODE (SET_SRC (new_body)) != REG))\n+      if ((GET_CODE (old_set) == SET && GET_CODE (SET_SRC (old_set)) == REG\n+\t   && (GET_CODE (new_set) != SET\n+\t       || GET_CODE (SET_SRC (new_set)) != REG))\n \t  /* If this was a load from or store to memory, compare\n \t     the MEM in recog_operand to the one in the insn.  If they\n \t     are not equal, then rerecognize the insn.  */\n-\t  || (GET_CODE (old_body) == SET\n-\t      && ((GET_CODE (SET_SRC (old_body)) == MEM\n-\t\t   && SET_SRC (old_body) != recog_operand[1])\n-\t\t  || (GET_CODE (SET_DEST (old_body)) == MEM\n-\t\t      && SET_DEST (old_body) != recog_operand[0])))\n+\t  || (GET_CODE (old_set) == SET\n+\t      && ((GET_CODE (SET_SRC (old_set)) == MEM\n+\t\t   && SET_SRC (old_set) != recog_operand[1])\n+\t\t  || (GET_CODE (SET_DEST (old_set)) == MEM\n+\t\t      && SET_DEST (old_set) != recog_operand[0])))\n \t  /* If this was an add insn before, rerecognize.  */\n \t  ||\n-\t  (GET_CODE (old_body) == SET\n-\t   && GET_CODE (SET_SRC (old_body)) == PLUS))\n+\t  (GET_CODE (old_set) == SET\n+\t   && GET_CODE (SET_SRC (old_set)) == PLUS))\n \t{\n+\t  if (!replace)\n+\t    PATTERN (insn) = copy_rtx (PATTERN (insn));\n+\n \t  if (! validate_change (insn, &PATTERN (insn), new_body, 0))\n \t    /* If recognition fails, store the new body anyway.\n \t       It's normal to have recognition failures here\n@@ -3993,6 +4016,8 @@ static HARD_REG_SET reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n static HARD_REG_SET reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n /* If reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */\n static HARD_REG_SET reload_reg_used_in_op_addr;\n+/* If reg is in use for a RELOAD_FOR_OPADDR_ADDR reload.  */\n+static HARD_REG_SET reload_reg_used_in_op_addr_reload;\n /* If reg is in use for a RELOAD_FOR_INSN reload.  */\n static HARD_REG_SET reload_reg_used_in_insn;\n /* If reg is in use for a RELOAD_FOR_OTHER_ADDRESS reload.  */\n@@ -4039,6 +4064,10 @@ mark_reload_reg_in_use (regno, opnum, type, mode)\n \t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n \t  break;\n \n+\tcase RELOAD_FOR_OPADDR_ADDR:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OTHER_ADDRESS:\n \t  SET_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n \t  break;\n@@ -4092,6 +4121,10 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n \t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n \t  break;\n \n+\tcase RELOAD_FOR_OPADDR_ADDR:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OTHER_ADDRESS:\n \t  CLEAR_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n \t  break;\n@@ -4142,6 +4175,9 @@ reload_reg_free_p (regno, opnum, type)\n \t  || TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n \treturn 0;\n \n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno))\n+\treturn 0;\n+\n       /* If it is used for some other input, can't use it.  */\n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n@@ -4186,6 +4222,13 @@ reload_reg_free_p (regno, opnum, type)\n       return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n \t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n \n+    case RELOAD_FOR_OPADDR_ADDR:\n+      for (i = 0; i < reload_n_operands; i++)\n+        if (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+          return 0;\n+\n+      return (!TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno));\n+\n     case RELOAD_FOR_OUTPUT:\n       /* This cannot share a register with RELOAD_FOR_INSN reloads, other\n \t outputs, or an operand address for this or an earlier output.  */\n@@ -4294,6 +4337,7 @@ reload_reg_free_before_p (regno, opnum, type)\n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n+    case RELOAD_FOR_OPADDR_ADDR:\n     case RELOAD_FOR_INSN:\n       /* These can't conflict with inputs, or each other, so all we have to\n \t test is input addresses and the addresses of OTHER items.  */\n@@ -4389,6 +4433,9 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno))\n+\treturn 0;\n+\n       return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n \t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n \n@@ -4415,8 +4462,17 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n       return 1;\n \n+    case RELOAD_FOR_OPADDR_ADDR:\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n+\t      && !TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n+\n     case RELOAD_FOR_INSN:\n-      /* These conflict with other outputs with with RELOAD_OTHER.  So\n+      /* These conflict with other outputs with RELOAD_OTHER.  So\n \t we need only check for output addresses.  */\n \n       opnum = -1;\n@@ -4465,6 +4521,7 @@ reloads_conflict (r1, r2)\n     case RELOAD_FOR_INPUT:\n       return (r2_type == RELOAD_FOR_INSN \n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t      || r2_type == RELOAD_FOR_OPADDR_ADDR\n \t      || r2_type == RELOAD_FOR_INPUT\n \t      || (r2_type == RELOAD_FOR_INPUT_ADDRESS && r2_opnum > r1_opnum));\n \n@@ -4480,6 +4537,10 @@ reloads_conflict (r1, r2)\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n \n+    case RELOAD_FOR_OPADDR_ADDR:\n+      return (r2_type == RELOAD_FOR_INPUT \n+\t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n+\n     case RELOAD_FOR_OUTPUT:\n       return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT\n \t      || (r2_type == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -4750,6 +4811,7 @@ choose_reload_regs (insn, avoid_return_reg)\n   HARD_REG_SET save_reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_op_addr;\n+  HARD_REG_SET save_reload_reg_used_in_op_addr_reload;\n   HARD_REG_SET save_reload_reg_used_in_insn;\n   HARD_REG_SET save_reload_reg_used_in_other_addr;\n   HARD_REG_SET save_reload_reg_used_at_all;\n@@ -4761,6 +4823,7 @@ choose_reload_regs (insn, avoid_return_reg)\n   CLEAR_HARD_REG_SET (reload_reg_used);\n   CLEAR_HARD_REG_SET (reload_reg_used_at_all);\n   CLEAR_HARD_REG_SET (reload_reg_used_in_op_addr);\n+  CLEAR_HARD_REG_SET (reload_reg_used_in_op_addr_reload);\n   CLEAR_HARD_REG_SET (reload_reg_used_in_insn);\n   CLEAR_HARD_REG_SET (reload_reg_used_in_other_addr);\n \n@@ -4888,6 +4951,10 @@ choose_reload_regs (insn, avoid_return_reg)\n   COPY_HARD_REG_SET (save_reload_reg_used_at_all, reload_reg_used_at_all);\n   COPY_HARD_REG_SET (save_reload_reg_used_in_op_addr,\n \t\t     reload_reg_used_in_op_addr);\n+\n+  COPY_HARD_REG_SET (save_reload_reg_used_in_op_addr_reload,\n+\t\t     reload_reg_used_in_op_addr_reload);\n+\n   COPY_HARD_REG_SET (save_reload_reg_used_in_insn,\n \t\t     reload_reg_used_in_insn);\n   COPY_HARD_REG_SET (save_reload_reg_used_in_other_addr,\n@@ -5257,6 +5324,8 @@ choose_reload_regs (insn, avoid_return_reg)\n       COPY_HARD_REG_SET (reload_reg_used_at_all, save_reload_reg_used_at_all);\n       COPY_HARD_REG_SET (reload_reg_used_in_op_addr,\n \t\t\t save_reload_reg_used_in_op_addr);\n+      COPY_HARD_REG_SET (reload_reg_used_in_op_addr_reload,\n+\t\t\t save_reload_reg_used_in_op_addr_reload);\n       COPY_HARD_REG_SET (reload_reg_used_in_insn,\n \t\t\t save_reload_reg_used_in_insn);\n       COPY_HARD_REG_SET (reload_reg_used_in_other_addr,\n@@ -5466,6 +5535,7 @@ emit_reload_insns (insn)\n   rtx output_reload_insns[MAX_RECOG_OPERANDS];\n   rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n   rtx operand_reload_insns = 0;\n+  rtx other_operand_reload_insns = 0;\n   rtx following_insn = NEXT_INSN (insn);\n   rtx before_insn = insn;\n   int special;\n@@ -5671,6 +5741,9 @@ emit_reload_insns (insn)\n \t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t      where = &operand_reload_insns;\n \t      break;\n+\t    case RELOAD_FOR_OPADDR_ADDR:\n+\t      where = &other_operand_reload_insns;\n+\t      break;\n \t    case RELOAD_FOR_OTHER_ADDRESS:\n \t      where = &other_input_address_reload_insns;\n \t      break;\n@@ -6286,6 +6359,8 @@ emit_reload_insns (insn)\n      For each operand, any RELOAD_FOR_INPUT_ADDRESS reloads followed by\n      the RELOAD_FOR_INPUT reload for the operand.\n \n+     RELOAD_FOR_OPADDR_ADDRS reloads.\n+\n      RELOAD_FOR_OPERAND_ADDRESS reloads.\n \n      After the insn being reloaded, we write the following:\n@@ -6302,6 +6377,7 @@ emit_reload_insns (insn)\n       emit_insns_before (input_reload_insns[j], before_insn);\n     }\n \n+  emit_insns_before (other_operand_reload_insns, before_insn);\n   emit_insns_before (operand_reload_insns, before_insn);\n \n   for (j = 0; j < reload_n_operands; j++)"}]}