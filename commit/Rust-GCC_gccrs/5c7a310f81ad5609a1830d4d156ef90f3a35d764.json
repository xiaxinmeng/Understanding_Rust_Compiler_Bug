{"sha": "5c7a310f81ad5609a1830d4d156ef90f3a35d764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM3YTMxMGY4MWFkNTYwOWExODMwZDRkMTU2ZWY5MGYzYTM1ZDc2NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-29T23:01:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-29T23:01:29Z"}, "message": "emit-rtl.c (start_sequence): Expand comments.\n\n\t* emit-rtl.c (start_sequence): Expand comments.\n\t(start_sequence_for_rtl_expr): Likewise.\n\t(push_to_sequence): Likewise.\n\t(end_sequence): Likewise.\n\t* expr.c (inhibit_defer_pop): Likewise.\n\t* expr.h (inhibit_defer_pop): Likewise.\n\t(NO_DEFER_POP): Likewise.\n\t(OK_DEFER_POP): Likewise.\n\nFrom-SVN: r26704", "tree": {"sha": "556b4266f6a4292a1085b6bcb6c75790cd0cf08f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/556b4266f6a4292a1085b6bcb6c75790cd0cf08f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c7a310f81ad5609a1830d4d156ef90f3a35d764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c7a310f81ad5609a1830d4d156ef90f3a35d764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c7a310f81ad5609a1830d4d156ef90f3a35d764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c7a310f81ad5609a1830d4d156ef90f3a35d764/comments", "author": null, "committer": null, "parents": [{"sha": "1a6580ec80d9c0dba5970a7541162faffb48a613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6580ec80d9c0dba5970a7541162faffb48a613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6580ec80d9c0dba5970a7541162faffb48a613"}], "stats": {"total": 90, "additions": 72, "deletions": 18}, "files": [{"sha": "c924547537705796b32e6870eb1d9b05e00f0c12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c7a310f81ad5609a1830d4d156ef90f3a35d764", "patch": "@@ -1,3 +1,14 @@\n+Thu Apr 29 23:02:22 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* emit-rtl.c (start_sequence): Expand comments.\n+\t(start_sequence_for_rtl_expr): Likewise.\n+\t(push_to_sequence): Likewise.\n+\t(end_sequence): Likewise.\n+\t* expr.c (inhibit_defer_pop): Likewise.\n+\t* expr.h (inhibit_defer_pop): Likewise.\n+\t(NO_DEFER_POP): Likewise.\n+\t(OK_DEFER_POP): Likewise.\n+\n Thu Apr 29 22:13:46 1999  Robert Lipe  <robertlipe@usa.net>\n \n \t* configure.in (i?86-UnixWare7*-sysv): Set thread_file to 'posix'"}, {"sha": "2aa51aca4da14ded0d31da3632e0b8e6058733ba", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5c7a310f81ad5609a1830d4d156ef90f3a35d764", "patch": "@@ -3284,7 +3284,13 @@ emit (x)\n     abort ();\n }\n \f\n-/* Begin emitting insns to a sequence which can be packaged in an RTL_EXPR.  */\n+/* Begin emitting insns to a sequence which can be packaged in an\n+   RTL_EXPR.  If this sequence will contain something that might cause\n+   the compiler to pop arguments to function calls (because those\n+   pops have previously been deferred; see INHIBIT_DEFER_POP for more\n+   details), use do_pending_stack_adjust before calling this function.\n+   That will ensure that the deferred pops are not accidentally\n+   emitted in the middel of this sequence.  */\n \n void\n start_sequence ()\n@@ -3311,8 +3317,9 @@ start_sequence ()\n   last_insn = 0;\n }\n \n-/* Similarly, but indicate that this sequence will be placed in \n-   T, an RTL_EXPR.  */\n+/* Similarly, but indicate that this sequence will be placed in T, an\n+   RTL_EXPR.  See the documentation for start_sequence for more\n+   information about how to use this function.  */\n \n void\n start_sequence_for_rtl_expr (t)\n@@ -3323,8 +3330,9 @@ start_sequence_for_rtl_expr (t)\n   sequence_rtl_expr = t;\n }\n \n-/* Set up the insn chain starting with FIRST\n-   as the current sequence, saving the previously current one.  */\n+/* Set up the insn chain starting with FIRST as the current sequence,\n+   saving the previously current one.  See the documentation for\n+   start_sequence for more information about how to use this function.  */\n \n void\n push_to_sequence (first)\n@@ -3378,8 +3386,16 @@ pop_topmost_sequence ()\n \n /* After emitting to a sequence, restore previous saved state.\n \n-   To get the contents of the sequence just made,\n-   you must call `gen_sequence' *before* calling here.  */\n+   To get the contents of the sequence just made, you must call\n+   `gen_sequence' *before* calling here.  \n+\n+   If the compiler might have deferred popping arguments while\n+   generating this sequence, and this sequence will not be immediately\n+   inserted into the instruction stream, use do_pending_stack_adjust\n+   before calling gen_sequence.  That will ensure that the deferred\n+   pops are inserted into this sequence, and not into some random\n+   location in the instruction stream.  See INHIBIT_DEFER_POP for more\n+   information about deferred popping of arguments.  */\n \n void\n end_sequence ()"}, {"sha": "828462fe3accfec1f24de950d97ae6389ebbb5b5", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5c7a310f81ad5609a1830d4d156ef90f3a35d764", "patch": "@@ -87,10 +87,21 @@ int do_preexpand_calls = 1;\n    These are the arguments to function calls that have already returned.  */\n int pending_stack_adjust;\n \n-/* Nonzero means stack pops must not be deferred, and deferred stack\n-   pops must not be output.  It is nonzero inside a function call,\n-   inside a conditional expression, inside a statement expression,\n-   and in other cases as well.  */\n+/* Under some ABIs, it is the caller's responsibility to pop arguments\n+   pushed for function calls.  A naive implementation would simply pop\n+   the arguments immediately after each call.  However, if several\n+   function calls are made in a row, it is typically cheaper to pop\n+   all the arguments after all of the calls are complete since a\n+   single pop instruction can be used.  Therefore, GCC attempts to\n+   defer popping the arguments until absolutely necessary.  (For\n+   example, at the end of a conditional, the arguments must be popped,\n+   since code outside the conditional won't know whether or not the\n+   arguments need to be popped.)\n+\n+   When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n+   attempt to defer pops.  Instead, the stack is popped immediately\n+   after each call.  Rather then setting this variable directly, use\n+   NO_DEFER_POP and OK_DEFER_POP.  */\n int inhibit_defer_pop;\n \n /* Nonzero means __builtin_saveregs has already been done in this function."}, {"sha": "1a6008a8f019067f4c3d2444e78dc6dc839e3f02", "filename": "gcc/expr.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7a310f81ad5609a1830d4d156ef90f3a35d764/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=5c7a310f81ad5609a1830d4d156ef90f3a35d764", "patch": "@@ -95,12 +95,31 @@ extern rtx current_function_internal_arg_pointer;\n    function.  */\n extern int current_function_check_memory_usage;\n \n-/* Nonzero means stack pops must not be deferred, and deferred stack\n-   pops must not be output.  It is nonzero inside a function call,\n-   inside a conditional expression, inside a statement expression,\n-   and in other cases as well.  */\n+/* Under some ABIs, it is the caller's responsibility to pop arguments\n+   pushed for function calls.  A naive implementation would simply pop\n+   the arguments immediately after each call.  However, if several\n+   function calls are made in a row, it is typically cheaper to pop\n+   all the arguments after all of the calls are complete since a\n+   single pop instruction can be used.  Therefore, GCC attempts to\n+   defer popping the arguments until absolutely necessary.  (For\n+   example, at the end of a conditional, the arguments must be popped,\n+   since code outside the conditional won't know whether or not the\n+   arguments need to be popped.)\n+\n+   When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n+   attempt to defer pops.  Instead, the stack is popped immediately\n+   after each call.  Rather then setting this variable directly, use\n+   NO_DEFER_POP and OK_DEFER_POP.  */\n extern int inhibit_defer_pop;\n \n+/* Prevent the compiler from deferring stack pops.  See\n+   inhibit_defer_pop for more information.  */\n+#define NO_DEFER_POP (inhibit_defer_pop += 1)\n+\n+/* Allow the compiler to defer stack pops.  See inhibit_defer_pop for\n+   more information.  */\n+#define OK_DEFER_POP (inhibit_defer_pop -= 1)\n+\n /* Number of function calls seen so far in current function.  */\n \n extern int function_call_count;\n@@ -126,9 +145,6 @@ extern rtx nonlocal_goto_stack_level;\n extern tree nonlocal_labels;\n #endif\n \n-#define NO_DEFER_POP (inhibit_defer_pop += 1)\n-#define OK_DEFER_POP (inhibit_defer_pop -= 1)\n-\n /* Number of units that we should eventually pop off the stack.\n    These are the arguments to function calls that have already returned.  */\n extern int pending_stack_adjust;"}]}