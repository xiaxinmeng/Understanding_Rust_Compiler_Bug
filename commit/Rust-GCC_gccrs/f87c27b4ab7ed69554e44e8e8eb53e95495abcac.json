{"sha": "f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg3YzI3YjRhYjdlZDY5NTU0ZTQ0ZThlOGViNTNlOTU0OTVhYmNhYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-22T01:27:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-22T01:27:34Z"}, "message": "cfgbuild.c: Fix formatting.\n\n\t* cfgbuild.c: Fix formatting.\n\t* cfg.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\nFrom-SVN: r53717", "tree": {"sha": "6aeac98ecb459edaa196adae23fb66b70e3d6346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aeac98ecb459edaa196adae23fb66b70e3d6346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/comments", "author": null, "committer": null, "parents": [{"sha": "ec221d715c730de2214d2bf4cab8b37633787ff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec221d715c730de2214d2bf4cab8b37633787ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec221d715c730de2214d2bf4cab8b37633787ff7"}], "stats": {"total": 285, "additions": 147, "deletions": 138}, "files": [{"sha": "dbdb2f4670c6b9464d07523b65f95617eb9e855b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -1,3 +1,12 @@\n+2002-05-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfgbuild.c: Fix formatting.\n+\t* cfg.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\n 2002-05-21  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.h (enum rid): Add RID_THREAD."}, {"sha": "4b066011b0c3d4952309727beeed7500e732913e", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -234,7 +234,7 @@ link_block (b, after)\n   after->next_bb = b;\n   b->next_bb->prev_bb = b;\n }\n-  \n+\n /* Unlink block B from chain.  */\n void\n unlink_block (b)\n@@ -243,7 +243,7 @@ unlink_block (b)\n   b->next_bb->prev_bb = b->prev_bb;\n   b->prev_bb->next_bb = b->next_bb;\n }\n-  \n+\n \n /* Remove block B from the basic block array and compact behind it.  */\n "}, {"sha": "0451a3475fd45266f24727e976e6d0d820409574", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -104,35 +104,35 @@ control_flow_insn_p (insn)\n \n   switch (GET_CODE (insn))\n     {\n-      case NOTE:\n-      case CODE_LABEL:\n-\treturn false;\n-\n-      case JUMP_INSN:\n-\t/* Jump insn always causes control transfer except for tablejumps.  */\n-\treturn (GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t\t&& GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n-\n-      case CALL_INSN:\n-\t/* Call insn may return to the nonlocal goto handler.  */\n-\treturn ((nonlocal_goto_handler_labels\n-\t\t && (0 == (note = find_reg_note (insn, REG_EH_REGION,\n-\t\t\t\t\t\t NULL_RTX))\n-\t\t     || INTVAL (XEXP (note, 0)) >= 0))\n-\t\t/* Or may trap.  */\n-\t\t|| can_throw_internal (insn));\n-\n-      case INSN:\n-\treturn (flag_non_call_exceptions && can_throw_internal (insn));\n-\n-      case BARRIER:\n-\t/* It is nonsence to reach barrier when looking for the\n-\t   end of basic block, but before dead code is eliminated\n-\t   this may happen.  */\n-\treturn false;\n-\n-      default:\n-\tabort ();\n+    case NOTE:\n+    case CODE_LABEL:\n+      return false;\n+\n+    case JUMP_INSN:\n+      /* Jump insn always causes control transfer except for tablejumps.  */\n+      return (GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n+\n+    case CALL_INSN:\n+      /* Call insn may return to the nonlocal goto handler.  */\n+      return ((nonlocal_goto_handler_labels\n+\t       && (0 == (note = find_reg_note (insn, REG_EH_REGION,\n+\t\t\t\t\t       NULL_RTX))\n+\t\t   || INTVAL (XEXP (note, 0)) >= 0))\n+\t      /* Or may trap.  */\n+\t      || can_throw_internal (insn));\n+\n+    case INSN:\n+      return (flag_non_call_exceptions && can_throw_internal (insn));\n+\n+    case BARRIER:\n+      /* It is nonsence to reach barrier when looking for the\n+         end of basic block, but before dead code is eliminated\n+         this may happen.  */\n+      return false;\n+\n+    default:\n+      abort ();\n     }\n }\n \n@@ -207,9 +207,9 @@ find_label_refs (f, lvl)\n \t      rtx lab = XEXP (note, 0), next;\n \n \t      if ((next = next_nonnote_insn (lab)) != NULL\n-\t\t       && GET_CODE (next) == JUMP_INSN\n-\t\t       && (GET_CODE (PATTERN (next)) == ADDR_VEC\n-\t\t\t   || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t\t  && GET_CODE (next) == JUMP_INSN\n+\t\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n \t\t;\n \t      else if (GET_CODE (lab) == NOTE)\n \t\t;\n@@ -305,7 +305,7 @@ make_edges (label_value_list, min, max, update_p)\n \n \t    for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n \t      if (e->dest != EXIT_BLOCK_PTR)\n-\t        SET_BIT (edge_cache[i], e->dest->index);\n+\t\tSET_BIT (edge_cache[i], e->dest->index);\n \t  }\n     }\n \n@@ -849,7 +849,7 @@ find_many_sub_basic_blocks (blocks)\n \n void\n find_sub_basic_blocks (bb)\n-    basic_block bb;\n+     basic_block bb;\n {\n   int i;\n   int min, max;"}, {"sha": "d5f6de1855528fb07e853b50574fd2ccc1b80b49", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -190,50 +190,50 @@ try_simplify_condjump (cbranch_block)\n \n static bool\n mark_effect (exp, nonequal)\n-  rtx exp;\n-  regset nonequal;\n+     rtx exp;\n+     regset nonequal;\n {\n   int regno;\n   rtx dest;\n   switch (GET_CODE (exp))\n     {\n       /* In case we do clobber the register, mark it as equal, as we know the\n          value is dead so it don't have to match.  */\n-      case CLOBBER:\n-\tif (REG_P (XEXP (exp, 0)))\n-\t  {\n-\t    dest = XEXP (exp, 0);\n-\t    regno = REGNO (dest);\n-\t    CLEAR_REGNO_REG_SET (nonequal, regno);\n-\t    if (regno < FIRST_PSEUDO_REGISTER)\n-\t      {\n-\t\tint n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n-\t\twhile (--n > 0)\n-\t\t  CLEAR_REGNO_REG_SET (nonequal, regno + n);\n-\t      }\n-\t  }\n-\treturn false;\n+    case CLOBBER:\n+      if (REG_P (XEXP (exp, 0)))\n+\t{\n+\t  dest = XEXP (exp, 0);\n+\t  regno = REGNO (dest);\n+\t  CLEAR_REGNO_REG_SET (nonequal, regno);\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t      while (--n > 0)\n+\t\tCLEAR_REGNO_REG_SET (nonequal, regno + n);\n+\t    }\n+\t}\n+      return false;\n \n-      case SET:\n-\tif (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))\n-\t  return false;\n-\tdest = SET_DEST (exp);\n-\tif (dest == pc_rtx)\n-\t  return false;\n-\tif (!REG_P (dest))\n-\t  return true;\n-\tregno = REGNO (dest);\n-\tSET_REGNO_REG_SET (nonequal, regno);\n-\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    int n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n-\t    while (--n > 0)\n-\t      SET_REGNO_REG_SET (nonequal, regno + n);\n-\t  }\n+    case SET:\n+      if (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))\n \treturn false;\n-\n-      default:\n+      dest = SET_DEST (exp);\n+      if (dest == pc_rtx)\n \treturn false;\n+      if (!REG_P (dest))\n+\treturn true;\n+      regno = REGNO (dest);\n+      SET_REGNO_REG_SET (nonequal, regno);\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int n = HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t  while (--n > 0)\n+\t    SET_REGNO_REG_SET (nonequal, regno + n);\n+\t}\n+      return false;\n+\n+    default:\n+      return false;\n     }\n }\n \n@@ -295,7 +295,7 @@ thread_jump (mode, e, b)\n   /* Second branch must end with onlyjump, as we will eliminate the jump.  */\n   if (!any_condjump_p (e->src->end))\n     return NULL;\n-  \n+\n   if (!any_condjump_p (b->end) || !onlyjump_p (b->end))\n     {\n       BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n@@ -357,22 +357,22 @@ thread_jump (mode, e, b)\n \n   for (insn = NEXT_INSN (b->head); insn != NEXT_INSN (b->end) && !failed;\n        insn = NEXT_INSN (insn))\n-  {\n-    if (INSN_P (insn))\n-      {\n-        rtx pat = PATTERN (insn);\n-\n-        if (GET_CODE (pat) == PARALLEL)\n-\t  {\n-\t    for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t      failed |= mark_effect (XVECEXP (pat, 0, i), nonequal);\n-\t  }\n-\telse\n-\t  failed |= mark_effect (pat, nonequal);\n-      }\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t\tfailed |= mark_effect (XVECEXP (pat, 0, i), nonequal);\n+\t    }\n+\t  else\n+\t    failed |= mark_effect (pat, nonequal);\n+\t}\n \n-    cselib_process_insn (insn);\n-  }\n+      cselib_process_insn (insn);\n+    }\n \n   /* Later we should clear nonequal of dead registers.  So far we don't\n      have life information in cfg_cleanup.  */\n@@ -504,7 +504,7 @@ try_forward_edges (mode, b)\n \t  if (mode & CLEANUP_PRE_LOOP)\n \t    {\n \t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n-\t\t          ? target->head : prev_nonnote_insn (target->end));\n+\t\t\t  ? target->head : prev_nonnote_insn (target->end));\n \n \t      if (GET_CODE (insn) != NOTE)\n \t\tinsn = NEXT_INSN (insn);\n@@ -522,7 +522,7 @@ try_forward_edges (mode, b)\n \t  counter++;\n \t  target = new_target;\n \t  threaded |= new_target_threaded;\n-  \t}\n+\t}\n \n       if (counter >= n_basic_blocks)\n \t{\n@@ -545,7 +545,7 @@ try_forward_edges (mode, b)\n \t    {\n \t      notice_new_block (redirect_edge_and_branch_force (e, target));\n \t      if (rtl_dump_file)\n-\t        fprintf (rtl_dump_file, \"Conditionals threaded.\\n\");\n+\t\tfprintf (rtl_dump_file, \"Conditionals threaded.\\n\");\n \t    }\n \t  else if (!redirect_edge_and_branch (e, target))\n \t    {\n@@ -614,7 +614,7 @@ try_forward_edges (mode, b)\n \t\t      && first == threaded_edges [n]->src)\n \t\t    n++;\n \t\t  t = first->succ;\n-\t\t }\n+\t\t}\n \n \t      t->count -= edge_count;\n \t      if (t->count < 0)\n@@ -812,7 +812,7 @@ merge_blocks (e, b, c, mode)\n \n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n-                 b_index, c_index);\n+\t\t b_index, c_index);\n \n       return true;\n     }\n@@ -886,8 +886,8 @@ merge_blocks (e, b, c, mode)\n \n static bool\n insns_match_p (mode, i1, i2)\n-\tint mode ATTRIBUTE_UNUSED;\n-\trtx i1, i2;\n+     int mode ATTRIBUTE_UNUSED;\n+     rtx i1, i2;\n {\n   rtx p1, p2;\n \n@@ -1057,10 +1057,10 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n \t      remove_note (i1, equiv1);\n \t      remove_note (i2, equiv2);\n \t    }\n-\t     \n+\n \t  afterlast1 = last1, afterlast2 = last2;\n \t  last1 = i1, last2 = i2;\n-          ninsns++;\n+\t  ninsns++;\n \t}\n \n       i1 = PREV_INSN (i1);\n@@ -1135,7 +1135,7 @@ outgoing_edges_match (mode, bb1, bb2)\n       enum rtx_code code1, code2;\n \n       if (!bb2->succ\n-          || !bb2->succ->succ_next\n+\t  || !bb2->succ->succ_next\n \t  || bb2->succ->succ_next->succ_next\n \t  || !any_condjump_p (bb2->end)\n \t  || !onlyjump_p (bb2->end))\n@@ -1284,9 +1284,9 @@ outgoing_edges_match (mode, bb1, bb2)\n   if (fallthru1)\n     {\n       basic_block d1 = (forwarder_block_p (fallthru1->dest)\n-\t                ? fallthru1->dest->succ->dest: fallthru1->dest);\n+\t\t\t? fallthru1->dest->succ->dest: fallthru1->dest);\n       basic_block d2 = (forwarder_block_p (fallthru2->dest)\n-\t                ? fallthru2->dest->succ->dest: fallthru2->dest);\n+\t\t\t? fallthru2->dest->succ->dest: fallthru2->dest);\n \n       if (d1 != d2)\n \treturn false;\n@@ -1759,7 +1759,7 @@ delete_unreachable_blocks ()\n   find_unreachable_blocks ();\n \n   /* Delete all unreachable basic blocks.  Do compaction concurrently,\n-     as otherwise we can wind up with O(N^2) behaviour here when we \n+     as otherwise we can wind up with O(N^2) behaviour here when we\n      have oodles of dead code.  */\n \n   for (i = j = 0; i < n_basic_blocks; ++i)"}, {"sha": "6f624426eb7512fa7ee7de9c335c1f7307f1e254", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -127,7 +127,7 @@ skip_insns_after_block (bb)\n \t      last_insn = insn;\n \t      continue;\n \t    }\n-          break;\n+\t  break;\n \n \tdefault:\n \t  break;\n@@ -137,7 +137,7 @@ skip_insns_after_block (bb)\n     }\n \n   /* It is possible to hit contradictory sequence.  For instance:\n-    \n+\n      jump_insn\n      NOTE_INSN_LOOP_BEG\n      barrier\n@@ -152,14 +152,14 @@ skip_insns_after_block (bb)\n       if (GET_CODE (insn) == NOTE)\n \tswitch (NOTE_LINE_NUMBER (insn))\n \t  {\n-          case NOTE_INSN_LOOP_END:\n-          case NOTE_INSN_BLOCK_END:\n-          case NOTE_INSN_DELETED:\n-          case NOTE_INSN_DELETED_LABEL:\n+\t  case NOTE_INSN_LOOP_END:\n+\t  case NOTE_INSN_BLOCK_END:\n+\t  case NOTE_INSN_DELETED:\n+\t  case NOTE_INSN_DELETED_LABEL:\n \t    continue;\n-          default:\n+\t  default:\n \t    reorder_insns (insn, insn, last_insn);\n-        }\n+\t  }\n     }\n \n   return last_insn;\n@@ -192,7 +192,7 @@ record_effective_endpoints ()\n {\n   rtx next_insn = get_insns ();\n   int i;\n-  \n+\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n@@ -203,7 +203,7 @@ record_effective_endpoints ()\n \t\t\t\t\t      PREV_INSN (bb->head));\n       end = skip_insns_after_block (bb);\n       if (NEXT_INSN (bb->end) && bb->end != end)\n-        RBI (bb)->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n+\tRBI (bb)->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n       next_insn = NEXT_INSN (bb->end);\n     }\n \n@@ -461,7 +461,7 @@ fixup_reorder_chain ()\n \t\t    }\n \t\t}\n \n-\t      /* Otherwise we can try to invert the jump.  This will \n+\t      /* Otherwise we can try to invert the jump.  This will\n \t\t basically never fail, however, keep up the pretense.  */\n \t      else if (invert_jump (bb_end_insn,\n \t\t\t\t    label_for_bb (e_fall->dest), 0))\n@@ -883,7 +883,7 @@ cfg_layout_duplicate_bb (bb, e)\n \n   insn = duplicate_insn_chain (bb->head, bb->end);\n   new_bb = create_basic_block (insn,\n-\t\t \t       insn ? get_last_insn () : NULL,\n+\t\t\t       insn ? get_last_insn () : NULL,\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n   alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n \n@@ -933,12 +933,12 @@ cfg_layout_duplicate_bb (bb, e)\n   bb->count -= new_count;\n \n   if (e)\n-   {\n-     new_bb->frequency = EDGE_FREQUENCY (e);\n-     bb->frequency -= EDGE_FREQUENCY (e);\n+    {\n+      new_bb->frequency = EDGE_FREQUENCY (e);\n+      bb->frequency -= EDGE_FREQUENCY (e);\n \n-     cfg_layout_redirect_edge (e, new_bb);\n-   }\n+      cfg_layout_redirect_edge (e, new_bb);\n+    }\n \n   if (bb->count < 0)\n     bb->count = 0;"}, {"sha": "ff89ef27c537a2f8043103a669493216a51ad420", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -110,9 +110,9 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n \n   if (loop->first->head && loop->last->end)\n     fprintf (file, \";;\\n;; Loop %d (%d to %d):%s%s\\n\",\n-\t    loop->num, INSN_UID (loop->first->head),\n-\t    INSN_UID (loop->last->end),\n-\t    loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n+\t     loop->num, INSN_UID (loop->first->head),\n+\t     INSN_UID (loop->last->end),\n+\t     loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n   else\n     fprintf (file, \";;\\n;; Loop %d:%s%s\\n\", loop->num,\n \t     loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");"}, {"sha": "781b26adf33a638dd14bb1da517e2e7c75ccfb5f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f87c27b4ab7ed69554e44e8e8eb53e95495abcac/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f87c27b4ab7ed69554e44e8e8eb53e95495abcac", "patch": "@@ -90,7 +90,7 @@ can_delete_note_p (note)\n {\n   return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n \t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK\n-          || NOTE_LINE_NUMBER (note) == NOTE_INSN_PREDICTION);\n+\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_PREDICTION);\n }\n \n /* True if a given label can be deleted.  */\n@@ -119,7 +119,7 @@ delete_insn (insn)\n   if (GET_CODE (insn) == CODE_LABEL)\n     {\n       /* Some labels can't be directly removed from the INSN chain, as they\n-         might be references via variables, constant pool etc. \n+         might be references via variables, constant pool etc.\n          Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n       if (! can_delete_label_p (insn))\n \t{\n@@ -381,13 +381,13 @@ flow_delete_block_noexpunge (b)\n      NOTE_INSN_EH_REGION_END notes.  */\n \n   /* Get rid of all NOTE_INSN_PREDICTIONs hanging before the block.  */\n-  \n+\n   for (insn = PREV_INSN (b->head); insn; insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) != NOTE)\n-        break;\n+\tbreak;\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n-        NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n     }\n \n   insn = b->head;\n@@ -434,7 +434,7 @@ flow_delete_block (b)\n      basic_block b;\n {\n   int deleted_handler = flow_delete_block_noexpunge (b);\n-  \n+\n   /* Remove the basic block from the array, and compact behind it.  */\n   expunge_block (b);\n \n@@ -1371,8 +1371,8 @@ commit_one_edge_insertion (e, watch_calls)\n       /* The first insn after the call may be a stack pop, skip it.  */\n       while (next\n \t     && keep_with_call_p (next))\n-        {\n-          after = next;\n+\t{\n+\t  after = next;\n \t  next = next_nonnote_insn (next);\n \t}\n       bb = e->dest;\n@@ -1833,17 +1833,17 @@ verify_flow_info ()\n \t    }\n \t}\n       if (bb->count < 0)\n-        {\n-          error (\"verify_flow_info: Wrong count of block %i %i\",\n+\t{\n+\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n \t         bb->index, (int)bb->count);\n-          err = 1;\n-        }\n+\t  err = 1;\n+\t}\n       if (bb->frequency < 0)\n-        {\n-          error (\"verify_flow_info: Wrong frequency of block %i %i\",\n+\t{\n+\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n \t         bb->index, bb->frequency);\n-          err = 1;\n-        }\n+\t  err = 1;\n+\t}\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  if (last_visited [e->dest->index + 2] == bb)\n@@ -1971,7 +1971,7 @@ verify_flow_info ()\n \t  error (\"Abnormal edges for no purpose in bb %i\", bb->index);\n \t  err = 1;\n \t}\n-\t\n+\n       if (!n_fallthru)\n \t{\n \t  rtx insn;\n@@ -2223,7 +2223,7 @@ purge_dead_edges (bb)\n \n \t  /* Avoid abnormal flags to leak from computed jumps turned\n \t     into simplejumps.  */\n- \n+\n \t  e->flags &= ~EDGE_ABNORMAL;\n \n \t  /* See if this edge is one we should keep.  */\n@@ -2265,7 +2265,7 @@ purge_dead_edges (bb)\n \t{\n \t  bb->succ->probability = REG_BR_PROB_BASE;\n \t  bb->succ->count = bb->count;\n-        }\n+\t}\n       else\n \t{\n \t  note = find_reg_note (insn, REG_BR_PROB, NULL);"}]}