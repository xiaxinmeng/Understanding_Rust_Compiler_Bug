{"sha": "30ae600f1fb18945d44e94a70c8818dcd63dbe07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBhZTYwMGYxZmIxODk0NWQ0NGU5NGE3MGM4ODE4ZGNkNjNkYmUwNw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:41:28Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:41:28Z"}, "message": "trans-array.c (gfc_add_loop_ss_code): Skip non-nestedmost ss.\n\n\t* trans-array.c (gfc_add_loop_ss_code): Skip non-nestedmost ss.\n\tCall recursively gfc_add_loop_ss_code for all the nested loops.\n\t(gfc_conv_ss_startstride): Only get the descriptor for the outermost\n\tss. Call recursively gfc_conv_ss_startstride for all the nested loops.\n\t(set_loop_bounds): Call recursively for all the nested loops.\n\t(set_delta): Ditto.\n\nFrom-SVN: r180898", "tree": {"sha": "e9e9faf30eb67c9060fa27b78daeb2ce4e9bf739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e9faf30eb67c9060fa27b78daeb2ce4e9bf739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30ae600f1fb18945d44e94a70c8818dcd63dbe07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ae600f1fb18945d44e94a70c8818dcd63dbe07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ae600f1fb18945d44e94a70c8818dcd63dbe07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ae600f1fb18945d44e94a70c8818dcd63dbe07/comments", "author": null, "committer": null, "parents": [{"sha": "9d75804367cd7c3aac109d33a98f3a038cbe8020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d75804367cd7c3aac109d33a98f3a038cbe8020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d75804367cd7c3aac109d33a98f3a038cbe8020"}], "stats": {"total": 42, "additions": 39, "deletions": 3}, "files": [{"sha": "653b262b81d5c8b7a1c399c1e5c3015e6984f663", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ae600f1fb18945d44e94a70c8818dcd63dbe07/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ae600f1fb18945d44e94a70c8818dcd63dbe07/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=30ae600f1fb18945d44e94a70c8818dcd63dbe07", "patch": "@@ -1,3 +1,12 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_add_loop_ss_code): Skip non-nestedmost ss.\n+\tCall recursively gfc_add_loop_ss_code for all the nested loops.\n+\t(gfc_conv_ss_startstride): Only get the descriptor for the outermost\n+\tss. Call recursively gfc_conv_ss_startstride for all the nested loops.\n+\t(set_loop_bounds): Call recursively for all the nested loops.\n+\t(set_delta): Ditto.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_loopinfo): New fields nested and next."}, {"sha": "27356a1a1d33afed8dc8f0339beb8a4f1ab4824d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ae600f1fb18945d44e94a70c8818dcd63dbe07/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ae600f1fb18945d44e94a70c8818dcd63dbe07/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=30ae600f1fb18945d44e94a70c8818dcd63dbe07", "patch": "@@ -2295,10 +2295,12 @@ static void\n gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t\t      locus * where)\n {\n+  gfc_loopinfo *nested_loop;\n   gfc_se se;\n   gfc_ss_info *ss_info;\n   gfc_array_info *info;\n   gfc_expr *expr;\n+  bool skip_nested = false;\n   int n;\n \n   /* TODO: This can generate bad code if there are ordering dependencies,\n@@ -2309,6 +2311,10 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n     {\n       gcc_assert (ss);\n \n+      /* Cross loop arrays are handled from within the most nested loop.  */\n+      if (ss->nested_ss != NULL)\n+\tcontinue;\n+\n       ss_info = ss->info;\n       expr = ss_info->expr;\n       info = &ss_info->data.array;\n@@ -2355,7 +2361,12 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  /* Add the expressions for scalar and vector subscripts.  */\n \t  for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n \t    if (info->subscript[n])\n-\t      gfc_add_loop_ss_code (loop, info->subscript[n], true, where);\n+\t      {\n+\t\tgfc_add_loop_ss_code (loop, info->subscript[n], true, where);\n+\t\t/* The recursive call will have taken care of the nested loops.\n+\t\t   No need to do it twice.  */\n+\t\tskip_nested = true;\n+\t      }\n \n \t  set_vector_loop_bounds (ss);\n \t  break;\n@@ -2410,6 +2421,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gcc_unreachable ();\n \t}\n     }\n+\n+  if (!skip_nested)\n+    for (nested_loop = loop->nested; nested_loop;\n+\t nested_loop = nested_loop->next)\n+      gfc_add_loop_ss_code (nested_loop, nested_loop->ss, subscript, where);\n }\n \n \n@@ -3495,8 +3511,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n       switch (ss_info->type)\n \t{\n \tcase GFC_SS_SECTION:\n-\t  /* Get the descriptor for the array.  */\n-\t  gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n+\t  /* Get the descriptor for the array.  If it is a cross loops array,\n+\t     we got the descriptor already in the outermost loop.  */\n+\t  if (ss->parent == NULL)\n+\t    gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n \n \t  for (n = 0; n < ss->dimen; n++)\n \t    gfc_conv_section_startstride (loop, ss, ss->dim[n]);\n@@ -3785,6 +3803,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n       tmp = gfc_finish_block (&block);\n       gfc_add_expr_to_block (&loop->pre, tmp);\n     }\n+\n+  for (loop = loop->nested; loop; loop = loop->next)\n+    gfc_conv_ss_startstride (loop);\n }\n \n /* Return true if both symbols could refer to the same data object.  Does\n@@ -4246,6 +4267,9 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t}\n     }\n   mpz_clear (i);\n+\n+  for (loop = loop->nested; loop; loop = loop->next)\n+    set_loop_bounds (loop);\n }\n \n \n@@ -4356,6 +4380,9 @@ set_delta (gfc_loopinfo *loop)\n \t    }\n \t}\n     }\n+\n+  for (loop = loop->nested; loop; loop = loop->next)\n+    set_delta (loop);\n }\n \n "}]}