{"sha": "aeb4926a2d295bbe089f74a7881d13d3afae2671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViNDkyNmEyZDI5NWJiZTA4OWY3NGE3ODgxZDEzZDNhZmFlMjY3MQ==", "commit": {"author": {"name": "Yufeng Zhang", "email": "yufeng.zhang@arm.com", "date": "2011-07-15T22:29:53Z"}, "committer": {"name": "Yufeng Zhang", "email": "yufeng@gcc.gnu.org", "date": "2011-07-15T22:29:53Z"}, "message": "ctype_members.cc: New file.\n\n2011-07-15  Yufeng Zhang  <yufeng.zhang@arm.com>\n\n\t* config/locale/newlib/ctype_members.cc: New file.\n\t* acinclude.m4 (GLIBCXX_ENABLE_CLOCALE): Add a new C locale\n\tkind: newlib.  Configure to use the newlib specific\n\tctype_members.cc when with_newlib is enabled.\n\t* configure: Regenerate.\n\nFrom-SVN: r176339", "tree": {"sha": "ca0040e6f5809dab43b687170a45ded7474dded2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca0040e6f5809dab43b687170a45ded7474dded2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeb4926a2d295bbe089f74a7881d13d3afae2671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb4926a2d295bbe089f74a7881d13d3afae2671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb4926a2d295bbe089f74a7881d13d3afae2671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb4926a2d295bbe089f74a7881d13d3afae2671/comments", "author": null, "committer": null, "parents": [{"sha": "42ea89ae1c7c3122703cf3e15a3d42dd3ad9b3f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ea89ae1c7c3122703cf3e15a3d42dd3ad9b3f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ea89ae1c7c3122703cf3e15a3d42dd3ad9b3f9"}], "stats": {"total": 341, "additions": 335, "deletions": 6}, "files": [{"sha": "4a46f39877f56f459bd2fe41f1e2579e850a5cf5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=aeb4926a2d295bbe089f74a7881d13d3afae2671", "patch": "@@ -1,3 +1,11 @@\n+2011-07-15  Yufeng Zhang  <yufeng.zhang@arm.com>\n+\n+\t* config/locale/newlib/ctype_members.cc: New file.\n+\t* acinclude.m4 (GLIBCXX_ENABLE_CLOCALE): Add a new C locale\n+\tkind: newlib.  Configure to use the newlib specific\n+\tctype_members.cc when with_newlib is enabled.\n+\t* configure: Regenerate.\n+\n 2011-07-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "6f6810de23545df145fef22dd246ccfe0b169203", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=aeb4926a2d295bbe089f74a7881d13d3afae2671", "patch": "@@ -1756,7 +1756,7 @@ dnl\n AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [\n   GLIBCXX_ENABLE(clocale,auto,[[[=MODEL]]],\n     [use MODEL for target locale package],\n-    [permit generic|gnu|ieee_1003.1-2001|yes|no|auto])\n+    [permit generic|gnu|ieee_1003.1-2001|newlib|yes|no|auto])\n \n   # Deal with gettext issues.  Default to not using it (=no) until we detect\n   # support for it later.  Let the user turn it off via --e/d, but let that\n@@ -1767,7 +1767,7 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [\n     [],\n     [enable_nls=yes])\n \n-  # Either a known packaage, or \"auto\"\n+  # Either a known package, or \"auto\"\n   if test $enable_clocale = no || test $enable_clocale = yes; then\n      enable_clocale=auto\n   fi\n@@ -1784,7 +1784,11 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [\n \tenable_clocale_flag=darwin\n \t;;\n       *)\n-\tenable_clocale_flag=generic\n+\tif test x\"$with_newlib\" = x\"yes\"; then\n+\t  enable_clocale_flag=newlib\n+\telse\n+\t  enable_clocale_flag=generic\n+\tfi\n \t;;\n     esac\n   fi\n@@ -1918,6 +1922,22 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [\n       CTIME_CC=config/locale/generic/time_members.cc\n       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n       ;;\n+    newlib)\n+      AC_MSG_RESULT(newlib)\n+\n+      CLOCALE_H=config/locale/generic/c_locale.h\n+      CLOCALE_CC=config/locale/generic/c_locale.cc\n+      CCODECVT_CC=config/locale/generic/codecvt_members.cc\n+      CCOLLATE_CC=config/locale/generic/collate_members.cc\n+      CCTYPE_CC=config/locale/newlib/ctype_members.cc\n+      CMESSAGES_H=config/locale/generic/messages_members.h\n+      CMESSAGES_CC=config/locale/generic/messages_members.cc\n+      CMONEY_CC=config/locale/generic/monetary_members.cc\n+      CNUMERIC_CC=config/locale/generic/numeric_members.cc\n+      CTIME_H=config/locale/generic/time_members.h\n+      CTIME_CC=config/locale/generic/time_members.cc\n+      CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n+      ;;\n   esac\n \n   # This is where the testsuite looks for locale catalogs, using the"}, {"sha": "53afe6423bb7f823766cfd59003b7f9fa413bb4e", "filename": "libstdc++-v3/config/locale/newlib/ctype_members.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fnewlib%2Fctype_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fnewlib%2Fctype_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fnewlib%2Fctype_members.cc?ref=aeb4926a2d295bbe089f74a7881d13d3afae2671", "patch": "@@ -0,0 +1,280 @@\n+// std::ctype implementation details, newlib version -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882: 22.2.1.1.2  ctype virtual functions.\n+//\n+\n+#include <locale>\n+#include <cstdlib>\n+#include <cstring>\n+#include <cstdio>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // NB: The other ctype<char> specializations are in src/locale.cc and\n+  // various /config/os/* files.\n+  ctype_byname<char>::ctype_byname(const char* __s, size_t __refs)\n+  : ctype<char>(0, false, __refs)\n+  {\n+    if (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n+      {\n+\tthis->_S_destroy_c_locale(this->_M_c_locale_ctype);\n+\tthis->_S_create_c_locale(this->_M_c_locale_ctype, __s);\n+      }\n+  }\n+\n+  ctype_byname<char>::~ctype_byname()\n+  { }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  ctype<wchar_t>::__wmask_type\n+  ctype<wchar_t>::_M_convert_to_wmask(const mask __m) const throw()\n+  {\n+    __wmask_type __ret;\n+    switch (__m)\n+      {\n+      case space:\n+\t__ret = wctype(\"space\");\n+\tbreak;\n+      case print:\n+\t__ret = wctype(\"print\");\n+\tbreak;\n+      case cntrl:\n+\t__ret = wctype(\"cntrl\");\n+\tbreak;\n+      case upper:\n+\t__ret = wctype(\"upper\");\n+\tbreak;\n+      case lower:\n+\t__ret = wctype(\"lower\");\n+\tbreak;\n+      case alpha:\n+\t__ret = wctype(\"alpha\");\n+\tbreak;\n+      case digit:\n+\t__ret = wctype(\"digit\");\n+\tbreak;\n+      case punct:\n+\t__ret = wctype(\"punct\");\n+\tbreak;\n+      case xdigit:\n+\t__ret = wctype(\"xdigit\");\n+\tbreak;\n+      case alnum:\n+\t__ret = wctype(\"alnum\");\n+\tbreak;\n+      case graph:\n+\t__ret = wctype(\"graph\");\n+\tbreak;\n+      default:\n+\t// Different from the generic version, xdigit and print in\n+\t// newlib are defined as bitwise-OR result of bitmasks:\n+\t//   xdigit = _X | _N;\n+\t//   print  = _P | _U | _L | _N | _B;\n+\t// in which _X and _B don't correspond to any ctype mask.\n+\t// In order to get the wmask correctly converted when __m is\n+\t// equal to _X or _B, the two cases are specifically handled\n+\t// here.\n+\tif (__m & xdigit)\n+\t  __ret = wctype(\"xdigit\");\n+\telse if (__m & print)\n+\t  __ret = wctype(\"print\");\n+\telse\n+\t  __ret = __wmask_type();\n+      }\n+    return __ret;\n+  };\n+\n+  wchar_t\n+  ctype<wchar_t>::do_toupper(wchar_t __c) const\n+  { return towupper(__c); }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::do_toupper(wchar_t* __lo, const wchar_t* __hi) const\n+  {\n+    while (__lo < __hi)\n+      {\n+        *__lo = towupper(*__lo);\n+        ++__lo;\n+      }\n+    return __hi;\n+  }\n+\n+  wchar_t\n+  ctype<wchar_t>::do_tolower(wchar_t __c) const\n+  { return towlower(__c); }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::do_tolower(wchar_t* __lo, const wchar_t* __hi) const\n+  {\n+    while (__lo < __hi)\n+      {\n+        *__lo = towlower(*__lo);\n+        ++__lo;\n+      }\n+    return __hi;\n+  }\n+\n+  bool\n+  ctype<wchar_t>::\n+  do_is(mask __m, wchar_t __c) const\n+  {\n+    bool __ret = false;\n+    // Newlib C library has a compact encoding that uses 8 bits only.\n+    const size_t __bitmasksize = 7;\n+    for (size_t __bitcur = 0; __bitcur <= __bitmasksize; ++__bitcur)\n+      if (__m & _M_bit[__bitcur]\n+\t  && iswctype(__c, _M_wmask[__bitcur]))\n+\t{\n+\t  __ret = true;\n+\t  break;\n+\t}\n+    return __ret;\n+  }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::\n+  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const\n+  {\n+    for (; __lo < __hi; ++__vec, ++__lo)\n+      {\n+\t// Newlib C library has a compact encoding that uses 8 bits only.\n+\tconst size_t __bitmasksize = 7;\n+\tmask __m = 0;\n+\tfor (size_t __bitcur = 0; __bitcur <= __bitmasksize; ++__bitcur)\n+\t  if (iswctype(*__lo, _M_wmask[__bitcur]))\n+\t    __m |= _M_bit[__bitcur];\n+\t*__vec = __m;\n+      }\n+    return __hi;\n+  }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::\n+  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const\n+  {\n+    while (__lo < __hi && !this->do_is(__m, *__lo))\n+      ++__lo;\n+    return __lo;\n+  }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::\n+  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n+  {\n+    while (__lo < __hi && this->do_is(__m, *__lo) != 0)\n+      ++__lo;\n+    return __lo;\n+  }\n+\n+  wchar_t\n+  ctype<wchar_t>::\n+  do_widen(char __c) const\n+  { return _M_widen[static_cast<unsigned char>(__c)]; }\n+\n+  const char*\n+  ctype<wchar_t>::\n+  do_widen(const char* __lo, const char* __hi, wchar_t* __dest) const\n+  {\n+    while (__lo < __hi)\n+      {\n+\t*__dest = _M_widen[static_cast<unsigned char>(*__lo)];\n+\t++__lo;\n+\t++__dest;\n+      }\n+    return __hi;\n+  }\n+\n+  char\n+  ctype<wchar_t>::\n+  do_narrow(wchar_t __wc, char __dfault) const\n+  {\n+    if (__wc >= 0 && __wc < 128 && _M_narrow_ok)\n+      return _M_narrow[__wc];\n+    const int __c = wctob(__wc);\n+    return (__c == EOF ? __dfault : static_cast<char>(__c));\n+  }\n+\n+  const wchar_t*\n+  ctype<wchar_t>::\n+  do_narrow(const wchar_t* __lo, const wchar_t* __hi, char __dfault,\n+\t    char* __dest) const\n+  {\n+    if (_M_narrow_ok)\n+      while (__lo < __hi)\n+\t{\n+\t  if (*__lo >= 0 && *__lo < 128)\n+\t    *__dest = _M_narrow[*__lo];\n+\t  else\n+\t    {\n+\t      const int __c = wctob(*__lo);\n+\t      *__dest = (__c == EOF ? __dfault : static_cast<char>(__c));\n+\t    }\n+\t  ++__lo;\n+\t  ++__dest;\n+\t}\n+    else\n+      while (__lo < __hi)\n+\t{\n+\t  const int __c = wctob(*__lo);\n+\t  *__dest = (__c == EOF ? __dfault : static_cast<char>(__c));\n+\t  ++__lo;\n+\t  ++__dest;\n+\t}\n+    return __hi;\n+  }\n+\n+  void\n+  ctype<wchar_t>::_M_initialize_ctype() throw()\n+  {\n+    wint_t __i;\n+    for (__i = 0; __i < 128; ++__i)\n+      {\n+\tconst int __c = wctob(__i);\n+\tif (__c == EOF)\n+\t  break;\n+\telse\n+\t  _M_narrow[__i] = static_cast<char>(__c);\n+      }\n+    if (__i == 128)\n+      _M_narrow_ok = true;\n+    else\n+      _M_narrow_ok = false;\n+    for (size_t __i = 0;\n+\t __i < sizeof(_M_widen) / sizeof(wint_t); ++__i)\n+      _M_widen[__i] = btowc(__i);\n+\n+    for (size_t __i = 0; __i <= 7; ++__i)\n+      {\n+\t_M_bit[__i] = static_cast<mask>(1 << __i);\n+\t_M_wmask[__i] = _M_convert_to_wmask(_M_bit[__i]);\n+      }\n+  }\n+#endif //  _GLIBCXX_USE_WCHAR_T\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "39e6b0814bffc71eb6b638f33d605548d7aaad35", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4926a2d295bbe089f74a7881d13d3afae2671/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=aeb4926a2d295bbe089f74a7881d13d3afae2671", "patch": "@@ -15643,7 +15643,7 @@ $as_echo \"stdio\" >&6; }\n if test \"${enable_clocale+set}\" = set; then :\n   enableval=$enable_clocale;\n       case \"$enableval\" in\n-       generic|gnu|ieee_1003.1-2001|yes|no|auto) ;;\n+       generic|gnu|ieee_1003.1-2001|newlib|yes|no|auto) ;;\n        *) as_fn_error \"Unknown argument to enable/disable clocale\" \"$LINENO\" 5 ;;\n \t  \t        esac\n \n@@ -15665,7 +15665,7 @@ else\n fi\n \n \n-  # Either a known packaage, or \"auto\"\n+  # Either a known package, or \"auto\"\n   if test $enable_clocale = no || test $enable_clocale = yes; then\n      enable_clocale=auto\n   fi\n@@ -15682,7 +15682,11 @@ fi\n \tenable_clocale_flag=darwin\n \t;;\n       *)\n-\tenable_clocale_flag=generic\n+\tif test x\"$with_newlib\" = x\"yes\"; then\n+\t  enable_clocale_flag=newlib\n+\telse\n+\t  enable_clocale_flag=generic\n+\tfi\n \t;;\n     esac\n   fi\n@@ -15908,6 +15912,23 @@ $as_echo \"IEEE 1003.1\" >&6; }\n       CTIME_CC=config/locale/generic/time_members.cc\n       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n       ;;\n+    newlib)\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: newlib\" >&5\n+$as_echo \"newlib\" >&6; }\n+\n+      CLOCALE_H=config/locale/generic/c_locale.h\n+      CLOCALE_CC=config/locale/generic/c_locale.cc\n+      CCODECVT_CC=config/locale/generic/codecvt_members.cc\n+      CCOLLATE_CC=config/locale/generic/collate_members.cc\n+      CCTYPE_CC=config/locale/newlib/ctype_members.cc\n+      CMESSAGES_H=config/locale/generic/messages_members.h\n+      CMESSAGES_CC=config/locale/generic/messages_members.cc\n+      CMONEY_CC=config/locale/generic/monetary_members.cc\n+      CNUMERIC_CC=config/locale/generic/numeric_members.cc\n+      CTIME_H=config/locale/generic/time_members.h\n+      CTIME_CC=config/locale/generic/time_members.cc\n+      CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h\n+      ;;\n   esac\n \n   # This is where the testsuite looks for locale catalogs, using the"}]}