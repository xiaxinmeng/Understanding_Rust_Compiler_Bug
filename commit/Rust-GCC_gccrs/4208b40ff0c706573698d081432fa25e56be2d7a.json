{"sha": "4208b40ff0c706573698d081432fa25e56be2d7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIwOGI0MGZmMGM3MDY1NzM2OThkMDgxNDMyZmEyNWU1NmJlMmQ3YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-02-01T01:14:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-02-01T01:14:40Z"}, "message": "alpha.c (alpha_expand_unaligned_load): Use expand_binop properly.\n\n        * alpha.c (alpha_expand_unaligned_load): Use expand_binop properly.\n        Make sure result winds up in TGT.\n        (alpha_expand_unaligned_store): Use expand_binop properly.  Allow\n        src to be other than DImode.\n        (alpha_expand_unaligned_load_words): Tidy.  Take an offset argument.\n        (alpha_expand_unaligned_store_words): Likewise.\n        (alpha_expand_block_move): Use REGNO_POINTER_ALIGN.  Restructure so\n        that source and destination are separately optimized for alignment.\n        (alpha_expand_block_clear): Use REGNO_POINTER_ALIGN.\n\nFrom-SVN: r17565", "tree": {"sha": "f58081120aeda5a44132a8071e433b8d2be86419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f58081120aeda5a44132a8071e433b8d2be86419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4208b40ff0c706573698d081432fa25e56be2d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4208b40ff0c706573698d081432fa25e56be2d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4208b40ff0c706573698d081432fa25e56be2d7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4208b40ff0c706573698d081432fa25e56be2d7a/comments", "author": null, "committer": null, "parents": [{"sha": "82301b881cd5406a5795016a255bb3d7c75b8d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82301b881cd5406a5795016a255bb3d7c75b8d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82301b881cd5406a5795016a255bb3d7c75b8d61"}], "stats": {"total": 490, "additions": 364, "deletions": 126}, "files": [{"sha": "92a72da8373a68f297813ec0c959b6f5caf1487f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4208b40ff0c706573698d081432fa25e56be2d7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4208b40ff0c706573698d081432fa25e56be2d7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4208b40ff0c706573698d081432fa25e56be2d7a", "patch": "@@ -1,3 +1,15 @@\n+Sun Feb  1 01:06:53 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_expand_unaligned_load): Use expand_binop properly.\n+\tMake sure result winds up in TGT.\n+\t(alpha_expand_unaligned_store): Use expand_binop properly.  Allow\n+\tsrc to be other than DImode.\n+\t(alpha_expand_unaligned_load_words): Tidy.  Take an offset argument.\n+\t(alpha_expand_unaligned_store_words): Likewise.\n+\t(alpha_expand_block_move): Use REGNO_POINTER_ALIGN.  Restructure so\n+\tthat source and destination are separately optimized for alignment.\n+\t(alpha_expand_block_clear): Use REGNO_POINTER_ALIGN.\n+\n Sun Feb  1 01:55:09 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mips.md (adddi3_internal_2): Be consistent with adddi3 expander"}, {"sha": "99ba8c86942bed611d456e86af788b176a32fcb0", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 352, "deletions": 126, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4208b40ff0c706573698d081432fa25e56be2d7a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4208b40ff0c706573698d081432fa25e56be2d7a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4208b40ff0c706573698d081432fa25e56be2d7a", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on the DEC Alpha.\n-   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -1304,6 +1304,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n      int sign;\n {\n   rtx meml, memh, addr, extl, exth;\n+  enum machine_mode mode;\n \n   meml = gen_reg_rtx (DImode);\n   memh = gen_reg_rtx (DImode);\n@@ -1332,31 +1333,39 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n       emit_insn (gen_extxl (extl, meml, GEN_INT (64), addr));\n       emit_insn (gen_extqh (exth, memh, addr));\n \n-      expand_binop (DImode, ior_optab, extl, exth, addr, 1, OPTAB_WIDEN);\n-      expand_binop (DImode, ashr_optab, addr, GEN_INT (48), addr,\n-\t\t    1, OPTAB_WIDEN);\n-      emit_move_insn (tgt, addr);\n-      return;\n+      addr = expand_binop (DImode, ior_optab, extl, exth, addr, 1, OPTAB_WIDEN);\n+      addr = expand_binop (DImode, ashr_optab, addr, GEN_INT (48), \n+\t\t\t   addr, 1, OPTAB_WIDEN);\n     }\n-\n-  emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs));\n-  emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n-  switch (size)\n+  else\n     {\n-    case 2:\n-      emit_insn (gen_extwh (exth, memh, addr));\n-      break;\n+      emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs));\n+      emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n+      switch (size)\n+\t{\n+\tcase 2:\n+\t  emit_insn (gen_extwh (exth, memh, addr));\n+\t  mode = HImode;\n+\t  break;\n \n-    case 4:\n-      emit_insn (gen_extlh (exth, memh, addr));\n-      break;\n+\tcase 4:\n+\t  emit_insn (gen_extlh (exth, memh, addr));\n+\t  mode = SImode;\n+\t  break;\n \n-    case 8:\n-      emit_insn (gen_extqh (exth, memh, addr));\n-      break;\n+\tcase 8:\n+\t  emit_insn (gen_extqh (exth, memh, addr));\n+\t  mode = DImode;\n+\t  break;\n+\t}\n+\n+      addr = expand_binop (mode, ior_optab, gen_lowpart (mode, extl),\n+\t\t\t   gen_lowpart (mode, exth), gen_lowpart (mode, tgt),\n+\t\t\t   sign, OPTAB_WIDEN);\n     }\n \n-  expand_binop (DImode, ior_optab, extl, exth, tgt, sign, OPTAB_WIDEN);\n+  if (addr != tgt)\n+    emit_move_insn (tgt, gen_lowpart(GET_MODE (tgt), addr));\n }\n \n /* Similarly, use ins and msk instructions to perform unaligned stores.  */\n@@ -1389,7 +1398,8 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n \n   if (src != const0_rtx)\n     {\n-      emit_insn (gen_insxh (insh, src, GEN_INT (size*8), addr));\n+      emit_insn (gen_insxh (insh, gen_lowpart (DImode, src),\n+\t\t\t    GEN_INT (size*8), addr));\n \n       switch (size)\n \t{\n@@ -1429,86 +1439,101 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n \n   if (src != const0_rtx)\n     {\n-      expand_binop (DImode, ior_optab, insh, dsth, dsth, 0, OPTAB_WIDEN);\n-      expand_binop (DImode, ior_optab, insl, dstl, dstl, 0, OPTAB_WIDEN);\n+      dsth = expand_binop (DImode, ior_optab, insh, dsth, dsth, 0, OPTAB_WIDEN);\n+      dstl = expand_binop (DImode, ior_optab, insl, dstl, dstl, 0, OPTAB_WIDEN);\n     }\n   \n   /* Must store high before low for degenerate case of aligned.  */\n   emit_move_insn (memh, dsth);\n   emit_move_insn (meml, dstl);\n }\n \n-/* Load an integral number of consecutive unaligned quadwords.  */\n+/* The block move code tries to maximize speed by separating loads and\n+   stores at the expense of register pressure: we load all of the data\n+   before we store it back out.  There are two secondary effects worth\n+   mentioning, that this speeds copying to/from aligned and unaligned\n+   buffers, and that it makes the code significantly easier to write.  */\n+\n+#define MAX_MOVE_WORDS\t8\n \n-#define MAX_MOVE_WORDS\t4\n+/* Load an integral number of consecutive unaligned quadwords.  */\n \n static void\n-alpha_expand_unaligned_load_words (data_regs, src_addr, words)\n-     rtx data_regs[MAX_MOVE_WORDS+1];\n-     rtx src_addr;\n-     HOST_WIDE_INT words;\n+alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n+     rtx *out_regs;\n+     rtx smem;\n+     HOST_WIDE_INT words, ofs;\n {\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n-  rtx ext_tmps[MAX_MOVE_WORDS];\n-  rtx src_reg, and_reg;\n+  rtx ext_tmps[MAX_MOVE_WORDS], data_regs[MAX_MOVE_WORDS+1];\n+  rtx sreg, areg;\n   HOST_WIDE_INT i;\n \n   /* Generate all the tmp registers we need.  */\n   for (i = 0; i < words; ++i)\n-    ext_tmps[i] = gen_reg_rtx(DImode);\n+    {\n+      data_regs[i] = out_regs[i];\n+      ext_tmps[i] = gen_reg_rtx (DImode);\n+    }\n+  data_regs[words] = gen_reg_rtx (DImode);\n+\n+  if (ofs != 0)\n+    smem = change_address (smem, GET_MODE (smem),\n+\t\t\t   plus_constant (XEXP (smem, 0), ofs));\n   \n   /* Load up all of the source data.  */\n   for (i = 0; i < words; ++i)\n     {\n       emit_move_insn (data_regs[i],\n-\t\t      change_address (src_addr, DImode,\n+\t\t      change_address (smem, DImode,\n \t\t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t\t   plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t\t   plus_constant (XEXP(smem,0),\n \t\t\t\t\t\t\t\t  8*i),\n \t\t\t\t\t\t   im8)));\n     }\n   emit_move_insn (data_regs[words],\n-\t\t  change_address (src_addr, DImode,\n+\t\t  change_address (smem, DImode,\n \t\t\t\t  gen_rtx_AND (DImode,\n-\t\t\t\t\t       plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t       plus_constant (XEXP(smem,0),\n \t\t\t\t\t\t\t      8*words - 1),\n \t\t\t\t\t       im8)));\n \n   /* Extract the half-word fragments.  Unfortunately DEC decided to make\n      extxh with offset zero a noop instead of zeroing the register, so \n      we must take care of that edge condition ourselves with cmov.  */\n \n-  src_reg = copy_addr_to_reg (XEXP (src_addr, 0));\n-  and_reg = expand_binop (DImode, and_optab, src_reg, GEN_INT (7), NULL, \n-\t\t\t  1, OPTAB_WIDEN);\n+  sreg = copy_addr_to_reg (XEXP (smem, 0));\n+  areg = expand_binop (DImode, and_optab, sreg, GEN_INT (7), NULL, \n+\t\t       1, OPTAB_WIDEN);\n   for (i = 0; i < words; ++i)\n     {\n-      emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, src_reg));\n+      emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, sreg));\n \n-      emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], src_reg));\n+      emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], sreg));\n       emit_insn (gen_rtx_SET (VOIDmode, ext_tmps[i],\n \t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n-\t\t\t\t\t\t    gen_rtx_EQ (DImode, and_reg, const0_rtx),\n+\t\t\t\t\t\t    gen_rtx_EQ (DImode, areg,\n+\t\t\t\t\t\t\t\tconst0_rtx),\n \t\t\t\t\t\t    const0_rtx, ext_tmps[i])));\n     }\n \n   /* Merge the half-words into whole words.  */\n   for (i = 0; i < words; ++i)\n     {\n-      expand_binop (DImode, ior_optab, data_regs[i], ext_tmps[i],\n-\t\t    data_regs[i], 1, OPTAB_WIDEN);\n+      out_regs[i] = expand_binop (DImode, ior_optab, data_regs[i],\n+\t\t\t\t  ext_tmps[i], data_regs[i], 1, OPTAB_WIDEN);\n     }\n }\n \n /* Store an integral number of consecutive unaligned quadwords.  DATA_REGS\n    may be NULL to store zeros.  */\n \n static void\n-alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n+alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n      rtx *data_regs;\n-     rtx dst_addr;\n-     HOST_WIDE_INT words;\n+     rtx dmem;\n+     HOST_WIDE_INT words, ofs;\n {\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n@@ -1518,7 +1543,7 @@ alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n   rtx const im1 = immed_double_const (0xffffffffffffffff, 0, DImode);\n #endif\n   rtx ins_tmps[MAX_MOVE_WORDS];\n-  rtx st_tmp_1, st_tmp_2, dst_reg;\n+  rtx st_tmp_1, st_tmp_2, dreg;\n   rtx st_addr_1, st_addr_2;\n   HOST_WIDE_INT i;\n \n@@ -1529,57 +1554,61 @@ alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n   st_tmp_1 = gen_reg_rtx(DImode);\n   st_tmp_2 = gen_reg_rtx(DImode);\n   \n-  st_addr_2 = change_address (dst_addr, DImode,\n+  if (ofs != 0)\n+    dmem = change_address (dmem, GET_MODE (dmem),\n+\t\t\t   plus_constant (XEXP (dmem, 0), ofs));\n+  \n+\n+  st_addr_2 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t   plus_constant (XEXP(dst_addr,0),\n+\t\t\t\t\t   plus_constant (XEXP(dmem,0),\n \t\t\t\t\t\t\t  words*8 - 1),\n \t\t\t\t       im8));\n-  st_addr_1 = change_address (dst_addr, DImode,\n+  st_addr_1 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode, \n-\t\t\t\t\t   XEXP (dst_addr, 0),\n+\t\t\t\t\t   XEXP (dmem, 0),\n \t\t\t\t\t   im8));\n \n   /* Load up the destination end bits.  */\n   emit_move_insn (st_tmp_2, st_addr_2);\n   emit_move_insn (st_tmp_1, st_addr_1);\n \n   /* Shift the input data into place.  */\n-  dst_reg = copy_addr_to_reg (XEXP (dst_addr, 0));\n-\n+  dreg = copy_addr_to_reg (XEXP (dmem, 0));\n   if (data_regs != NULL)\n     {\n       for (i = words-1; i >= 0; --i)\n \t{\n-\t  emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dst_reg));\n-\t  emit_insn (gen_insql (data_regs[i], data_regs[i], dst_reg));\n+\t  emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dreg));\n+\t  emit_insn (gen_insql (data_regs[i], data_regs[i], dreg));\n \t}\n-\n       for (i = words-1; i > 0; --i)\n \t{\n-\t  expand_binop (DImode, ior_optab, data_regs[i], ins_tmps[i-1],\n-\t\t\tins_tmps[i-1], 1, OPTAB_WIDEN);\n+\t  ins_tmps[i-1] = expand_binop (DImode, ior_optab, data_regs[i],\n+\t\t\t\t\tins_tmps[i-1], ins_tmps[i-1], 1,\n+\t\t\t\t\tOPTAB_WIDEN);\n \t}\n     }\n \n   /* Split and merge the ends with the destination data.  */\n-  emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dst_reg));\n-  emit_insn (gen_mskxl (st_tmp_1, st_tmp_1, im1, dst_reg));\n+  emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dreg));\n+  emit_insn (gen_mskxl (st_tmp_1, st_tmp_1, im1, dreg));\n \n   if (data_regs != NULL)\n     {\n-      expand_binop (DImode, ior_optab, st_tmp_2, ins_tmps[words-1],\n-\t\t    st_tmp_2, 1, OPTAB_WIDEN);\n-      expand_binop (DImode, ior_optab, st_tmp_1, data_regs[0],\n-\t\t    st_tmp_1, 1, OPTAB_WIDEN);\n+      st_tmp_2 = expand_binop (DImode, ior_optab, st_tmp_2, ins_tmps[words-1],\n+\t\t\t       st_tmp_2, 1, OPTAB_WIDEN);\n+      st_tmp_1 = expand_binop (DImode, ior_optab, st_tmp_1, data_regs[0],\n+\t\t\t       st_tmp_1, 1, OPTAB_WIDEN);\n     }\n \n   /* Store it all.  */\n   emit_move_insn (st_addr_2, st_tmp_2);\n   for (i = words-1; i > 0; --i)\n     {\n-      emit_move_insn (change_address (dst_addr, DImode,\n+      emit_move_insn (change_address (dmem, DImode,\n \t\t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t\t   plus_constant(XEXP (dst_addr,0),\n+\t\t\t\t\t\t   plus_constant(XEXP (dmem,0),\n \t\t\t\t\t\t\t\t i*8),\n \t\t\t\t\t       im8)),\n \t\t      data_regs ? ins_tmps[i-1] : const0_rtx);\n@@ -1602,127 +1631,167 @@ alpha_expand_block_move (operands)\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n   HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n-  HOST_WIDE_INT align = INTVAL (align_rtx);\n+  HOST_WIDE_INT src_align = INTVAL (align_rtx);\n+  HOST_WIDE_INT dst_align = src_align;\n   rtx orig_src\t= operands[1];\n   rtx orig_dst\t= operands[0];\n-  rtx tmp = NULL_RTX;\n-  rtx data_regs[2*MAX_MOVE_WORDS];\n-  HOST_WIDE_INT i, words, ofs = 0;\n+  rtx data_regs[2*MAX_MOVE_WORDS+16];\n+  rtx tmp;\n+  int i, words, ofs, nregs = 0;\n   \n   if (bytes <= 0)\n     return 1;\n   if (bytes > MAX_MOVE_WORDS*8)\n     return 0;\n \n-  /* Ideally we would do nice things when noticing the addressof.  */\n+  /* Look for additional alignment information from recorded register info.  */\n+\n+  tmp = XEXP (orig_src, 0);\n+  if (GET_CODE (tmp) == REG)\n+    {\n+      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > src_align)\n+\tsrc_align = REGNO_POINTER_ALIGN (REGNO (tmp));\n+    }\n+  else if (GET_CODE (tmp) == PLUS\n+\t   && GET_CODE (XEXP (tmp, 0)) == REG\n+\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+\n+      if (a > src_align)\n+\t{\n+          if (a >= 8 && c % 8 == 0)\n+\t    src_align = 8;\n+          else if (a >= 4 && c % 4 == 0)\n+\t    src_align = 4;\n+          else if (a >= 2 && c % 2 == 0)\n+\t    src_align = 2;\n+\t}\n+    }\n+\t\n+  tmp = XEXP (orig_dst, 0);\n+  if (GET_CODE (tmp) == REG)\n+    {\n+      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > dst_align)\n+\tdst_align = REGNO_POINTER_ALIGN (REGNO (tmp));\n+    }\n+  else if (GET_CODE (tmp) == PLUS\n+\t   && GET_CODE (XEXP (tmp, 0)) == REG\n+\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+\n+      if (a > dst_align)\n+\t{\n+          if (a >= 8 && c % 8 == 0)\n+\t    dst_align = 8;\n+          else if (a >= 4 && c % 4 == 0)\n+\t    dst_align = 4;\n+          else if (a >= 2 && c % 2 == 0)\n+\t    dst_align = 2;\n+\t}\n+    }\n+\n+  /*\n+   * Load the entire block into registers.\n+   */\n+\n   if (GET_CODE (XEXP (orig_src, 0)) == ADDRESSOF)\n-    orig_src = change_address (orig_src, GET_MODE (orig_src),\n-\t\t\t       copy_addr_to_reg (XEXP (orig_src, 0)));\n-  if (GET_CODE (XEXP (orig_dst, 0)) == ADDRESSOF)\n-    orig_dst = change_address (orig_dst, GET_MODE (orig_dst),\n-\t\t\t       copy_addr_to_reg (XEXP (orig_dst, 0)));\n+    {\n+      enum machine_mode mode;\n+      tmp = XEXP (XEXP (orig_src, 0), 0);\n \n-  /* Handle a block of contiguous words first.  */\n+      mode = mode_for_size (bytes, MODE_INT, 1);\n+      if (mode != BLKmode\n+\t  && GET_MODE_SIZE (GET_MODE (tmp)) <= bytes)\n+\t{\n+\t  /* Whee!  Optimize the load to use the existing register.  */\n+\t  data_regs[nregs++] = gen_lowpart (mode, tmp);\n+\t  goto src_done;\n+\t}\n \n-  if (align >= 8 && bytes >= 8)\n+      /* ??? We could potentially be copying 3 bytes or whatnot from\n+\t a wider reg.  Probably not worth worrying about.  */\n+      /* No appropriate mode; fall back on memory.  */\n+      orig_src = change_address (orig_src, GET_MODE (orig_src),\n+\t\t\t\t copy_addr_to_reg (XEXP (orig_src, 0)));\n+    }\n+\n+  ofs = 0;\n+  if (src_align >= 8 && bytes >= 8)\n     {\n       words = bytes / 8;\n \n-      /* Make some data registers. */\n       for (i = 0; i < words; ++i)\n-\tdata_regs[i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs+i] = gen_reg_rtx(DImode);\n \n-      /* Move in aligned hunks.  */\n       for (i = 0; i < words; ++i)\n \t{\n-\t  emit_move_insn (data_regs[i],\n+\t  emit_move_insn (data_regs[nregs+i],\n \t\t\t  change_address(orig_src, DImode,\n \t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n \t\t\t\t\t\t\ti*8)));\n \t}\n-      for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (change_address(orig_dst, DImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\ti*8)),\n-\t\t\t  data_regs[i]);\n-\t}\n \n+      nregs += words;\n       bytes -= words * 8;\n       ofs = words * 8;\n     }\n-  if (align >= 4 && bytes >= 4)\n+  if (src_align >= 4 && bytes >= 4)\n     {\n       words = bytes / 4;\n \n-      /* Make some data registers. */\n       for (i = 0; i < words; ++i)\n-\tdata_regs[i] = gen_reg_rtx(SImode);\n+\tdata_regs[nregs+i] = gen_reg_rtx(SImode);\n \n-      /* Move in aligned hunks.  */\n       for (i = 0; i < words; ++i)\n \t{\n-\t  emit_move_insn (data_regs[i],\n+\t  emit_move_insn (data_regs[nregs+i],\n \t\t\t  change_address(orig_src, SImode,\n \t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n \t\t\t\t\t\t\ti*4)));\n \t}\n-      for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (change_address(orig_dst, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\ti*4)),\n-\t\t\t  data_regs[i]);\n-\t}\n \n+      nregs += words;\n       bytes -= words * 4;\n       ofs = words * 4;\n     }\n   if (bytes >= 16)\n     {\n       words = bytes / 8;\n \n-      /* Make some data registers. */\n       for (i = 0; i < words+1; ++i)\n-\tdata_regs[i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs+i] = gen_reg_rtx(DImode);\n \n-      /* Move in unaligned hunks.  */\n-      alpha_expand_unaligned_load_words (data_regs, orig_src, words);\n-      alpha_expand_unaligned_store_words (data_regs, orig_dst, words);\n+      alpha_expand_unaligned_load_words(data_regs+nregs, orig_src, words, ofs);\n \n+      nregs += words;\n       bytes -= words * 8;\n       ofs = words * 8;\n     }\n-\n-  /* Next clean up any trailing pieces.  We know from the contiguous\n-     block move that there are no aligned SImode or DImode hunks left.  */\n-\n   if (!TARGET_BWX && bytes >= 8)\n     {\n-      tmp = gen_reg_rtx (DImode);\n+      data_regs[nregs++] = tmp = gen_reg_rtx (DImode);\n       alpha_expand_unaligned_load (tmp, orig_src, 8, ofs, 0);\n-      alpha_expand_unaligned_store (orig_dst, tmp, 8, ofs);\n-\n       bytes -= 8;\n       ofs += 8;\n     }\n   if (!TARGET_BWX && bytes >= 4)\n     {\n-      tmp = gen_reg_rtx (DImode);\n+      data_regs[nregs++] = tmp = gen_reg_rtx (SImode);\n       alpha_expand_unaligned_load (tmp, orig_src, 4, ofs, 0);\n-      alpha_expand_unaligned_store (orig_dst, tmp, 4, ofs);\n-\n       bytes -= 4;\n       ofs += 4;\n     }\n   if (bytes >= 2)\n     {\n-      if (align >= 2)\n+      if (src_align >= 2)\n \t{\n \t  do {\n-\t    emit_move_insn (change_address (orig_dst, HImode,\n-\t\t\t\t\t    plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t   ofs)),\n+\t    data_regs[nregs++] = tmp = gen_reg_rtx (HImode);\n+\t    emit_move_insn (tmp,\n \t\t\t    change_address (orig_src, HImode,\n \t\t\t\t\t    plus_constant (XEXP (orig_src, 0),\n \t\t\t\t\t\t\t   ofs)));\n@@ -1732,24 +1801,154 @@ alpha_expand_block_move (operands)\n \t}\n       else if (!TARGET_BWX)\n \t{\n-\t  tmp = gen_reg_rtx (DImode);\n+\t  data_regs[nregs++] = tmp = gen_reg_rtx (HImode);\n \t  alpha_expand_unaligned_load (tmp, orig_src, 2, ofs, 0);\n-\t  alpha_expand_unaligned_store (orig_dst, tmp, 2, ofs);\n \t  bytes -= 2;\n \t  ofs += 2;\n \t}\n     }\n   while (bytes > 0)\n     {\n-      emit_move_insn (change_address (orig_dst, QImode,\n-\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t     ofs)),\n+      data_regs[nregs++] = tmp = gen_reg_rtx (QImode);\n+      emit_move_insn (tmp,\n \t\t      change_address (orig_src, QImode,\n \t\t\t\t      plus_constant (XEXP (orig_src, 0),\n \t\t\t\t\t\t     ofs)));\n       bytes -= 1;\n       ofs += 1;\n     }\n+ src_done:\n+\n+  if (nregs > sizeof(data_regs)/sizeof(*data_regs))\n+    abort();\n+\n+  /*\n+   * Now save it back out again.\n+   */\n+\n+  i = 0, ofs = 0;\n+\n+  if (GET_CODE (XEXP (orig_dst, 0)) == ADDRESSOF)\n+    {\n+      enum machine_mode mode;\n+      tmp = XEXP (XEXP (orig_dst, 0), 0);\n+\n+      mode = mode_for_size (bytes, MODE_INT, 1);\n+      if (GET_MODE (tmp) == mode && nregs == 1)\n+\t{\n+\t  emit_move_insn (tmp, data_regs[0]);\n+\t  i = 1;\n+\t  goto dst_done;\n+\t}\n+\n+      /* ??? If nregs > 1, consider reconstructing the word in regs.  */\n+      /* ??? Optimize mode < dst_mode with strict_low_part.  */\n+      /* No appropriate mode; fall back on memory.  */\n+      orig_dst = change_address (orig_dst, GET_MODE (orig_dst),\n+\t\t\t\t copy_addr_to_reg (XEXP (orig_dst, 0)));\n+    }\n+\n+  /* Write out the data in whatever chunks reading the source allowed.  */\n+  if (dst_align >= 8)\n+    {\n+      while (i < nregs && GET_MODE (data_regs[i]) == DImode)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, DImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\tofs)),\n+\t\t\t  data_regs[i]);\n+\t  ofs += 8;\n+\t  i++;\n+\t}\n+    }\n+  if (dst_align >= 4)\n+    {\n+      /* If the source has remaining DImode regs, write them out in\n+\t two pieces.  */\n+      while (i < nregs && GET_MODE (data_regs[i]) == DImode)\n+\t{\n+\t  tmp = expand_binop (DImode, lshr_optab, data_regs[i], GEN_INT (32),\n+\t\t\t      NULL_RTX, 1, OPTAB_WIDEN);\n+\n+\t  emit_move_insn (change_address(orig_dst, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\tofs)),\n+\t\t\t  gen_lowpart (SImode, data_regs[i]));\n+\t  emit_move_insn (change_address(orig_dst, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\tofs+4)),\n+\t\t\t  gen_lowpart (SImode, tmp));\n+\t  ofs += 8;\n+\t  i++;\n+\t}\n+\n+      while (i < nregs && GET_MODE (data_regs[i]) == SImode)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\tofs)),\n+\t\t\t  data_regs[i]);\n+\t  ofs += 4;\n+\t  i++;\n+\t}\n+    }\n+  if (i < nregs && GET_MODE (data_regs[i]) == DImode)\n+    {\n+      /* Write out a remaining block of words using unaligned methods.  */\n+\n+      for (words = 1; i+words < nregs ; ++words)\n+\tif (GET_MODE (data_regs[i+words]) != DImode)\n+\t  break;\n+\n+      if (words == 1)\n+\talpha_expand_unaligned_store (orig_dst, data_regs[i], 8, ofs);\n+      else\n+        alpha_expand_unaligned_store_words (data_regs+i, orig_dst, words, ofs);\n+     \n+      i += words;\n+      ofs += words * 8;\n+    }\n+\n+  /* Due to the above, this won't be aligned.  */\n+  /* ??? If we have more than one of these, consider constructing full\n+     words in registers and using alpha_expand_unaligned_store_words.  */\n+  while (i < nregs && GET_MODE (data_regs[i]) == SImode)\n+    {\n+      alpha_expand_unaligned_store (orig_dst, data_regs[i], 4, ofs);\n+      ofs += 4;\n+      i++;\n+    }\n+\n+  if (dst_align >= 2)\n+    while (i < nregs && GET_MODE (data_regs[i]) == HImode)\n+      {\n+\temit_move_insn (change_address (orig_dst, HImode,\n+\t\t\t\t\tplus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t       ofs)),\n+\t\t\tdata_regs[i]);\n+\ti++;\n+\tofs += 2;\n+      }\n+  else\n+    while (i < nregs && GET_MODE (data_regs[i]) == HImode)\n+      {\n+\talpha_expand_unaligned_store (orig_dst, data_regs[i], 2, ofs);\n+\ti++;\n+\tofs += 2;\n+      }\n+  while (i < nregs && GET_MODE (data_regs[i]) == QImode)\n+    {\n+      emit_move_insn (change_address (orig_dst, QImode,\n+\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t     ofs)),\n+\t\t      data_regs[i]);\n+      i++;\n+      ofs += 1;\n+    }\n+ dst_done:\n+\n+  if (i != nregs)\n+    abort();\n \n   return 1;\n }\n@@ -1763,13 +1962,40 @@ alpha_expand_block_clear (operands)\n   HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n   HOST_WIDE_INT align = INTVAL (align_rtx);\n   rtx orig_dst\t= operands[0];\n+  rtx tmp;\n   HOST_WIDE_INT i, words, ofs = 0;\n   \n   if (bytes <= 0)\n     return 1;\n   if (bytes > MAX_MOVE_WORDS*8)\n     return 0;\n \n+  /* Look for stricter alignment.  */\n+\n+  tmp = XEXP (orig_dst, 0);\n+  if (GET_CODE (tmp) == REG)\n+    {\n+      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > align)\n+\talign = REGNO_POINTER_ALIGN (REGNO (tmp));\n+    }\n+  else if (GET_CODE (tmp) == PLUS\n+\t   && GET_CODE (XEXP (tmp, 0)) == REG\n+\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+\n+      if (a > align)\n+\t{\n+          if (a >= 8 && c % 8 == 0)\n+\t    align = 8;\n+          else if (a >= 4 && c % 4 == 0)\n+\t    align = 4;\n+          else if (a >= 2 && c % 2 == 0)\n+\t    align = 2;\n+\t}\n+    }\n+\n   /* Handle a block of contiguous words first.  */\n \n   if (align >= 8 && bytes >= 8)"}]}