{"sha": "1058a2262b9dc15c164dec5261a9b3daad84e6d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1OGEyMjYyYjlkYzE1YzE2NGRlYzUyNjFhOWIzZGFhZDg0ZTZkNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-03T10:23:06Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-12-03T10:23:06Z"}, "message": "utils.c (potential_alignment_gap): Delete.\n\n\t* gcc-interface/utils.c (potential_alignment_gap): Delete.\n\t(rest_of_record_type_compilation): Do not call above function.  Use\n\tthe alignment of the field instead of that of its type, if need be.\n\tWhen the original field has variable size, always lower the alignment\n\tof the pointer type.  Reset the bit-field status of the new field if\n\tit does not encode a bit-field.\n\nFrom-SVN: r278930", "tree": {"sha": "4e548af7116a715f54fd37f75038a179dd97c414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e548af7116a715f54fd37f75038a179dd97c414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1058a2262b9dc15c164dec5261a9b3daad84e6d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1058a2262b9dc15c164dec5261a9b3daad84e6d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1058a2262b9dc15c164dec5261a9b3daad84e6d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1058a2262b9dc15c164dec5261a9b3daad84e6d6/comments", "author": null, "committer": null, "parents": [{"sha": "cbcf36686e215a8a4bb5e824f8d8e40226b79757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbcf36686e215a8a4bb5e824f8d8e40226b79757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbcf36686e215a8a4bb5e824f8d8e40226b79757"}], "stats": {"total": 99, "additions": 37, "deletions": 62}, "files": [{"sha": "e454613bd289bfa6cb05bf2d80d85a54adea8844", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1058a2262b9dc15c164dec5261a9b3daad84e6d6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1058a2262b9dc15c164dec5261a9b3daad84e6d6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1058a2262b9dc15c164dec5261a9b3daad84e6d6", "patch": "@@ -1,3 +1,12 @@\n+2019-12-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (potential_alignment_gap): Delete.\n+\t(rest_of_record_type_compilation): Do not call above function.  Use\n+\tthe alignment of the field instead of that of its type, if need be.\n+\tWhen the original field has variable size, always lower the alignment\n+\tof the pointer type.  Reset the bit-field status of the new field if\n+\tit does not encode a bit-field.\n+\n 2019-12-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (fold_convert_size): New function."}, {"sha": "7217eeaf350814c2f55c9cb5c8b129e1e0033d44", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1058a2262b9dc15c164dec5261a9b3daad84e6d6/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1058a2262b9dc15c164dec5261a9b3daad84e6d6/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1058a2262b9dc15c164dec5261a9b3daad84e6d6", "patch": "@@ -288,7 +288,6 @@ static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static unsigned int scale_by_factor_of (tree, unsigned int);\n-static bool potential_alignment_gap (tree, tree, tree);\n \n /* Linked list used as a queue to defer the initialization of the DECL_CONTEXT\n    of ..._DECL nodes and of the TYPE_CONTEXT of ..._TYPE nodes.  */\n@@ -2171,7 +2170,6 @@ rest_of_record_type_compilation (tree record_type)\n \t\t     ? UNION_TYPE : TREE_CODE (record_type));\n       tree orig_name = TYPE_IDENTIFIER (record_type), new_name;\n       tree last_pos = bitsize_zero_node;\n-      tree old_field, prev_old_field = NULL_TREE;\n \n       new_name\n \t= concat_name (orig_name, TREE_CODE (record_type) == QUAL_UNION_TYPE\n@@ -2189,7 +2187,8 @@ rest_of_record_type_compilation (tree record_type)\n \n       /* Now scan all the fields, replacing each field with a new field\n \t corresponding to the new encoding.  */\n-      for (old_field = TYPE_FIELDS (record_type); old_field;\n+      for (tree old_field = TYPE_FIELDS (record_type);\n+\t   old_field;\n \t   old_field = DECL_CHAIN (old_field))\n \t{\n \t  tree field_type = TREE_TYPE (old_field);\n@@ -2213,18 +2212,18 @@ rest_of_record_type_compilation (tree record_type)\n \t  else\n \t    pos = compute_related_constant (curpos, last_pos);\n \n-\t  if (!pos\n-\t      && TREE_CODE (curpos) == MULT_EXPR\n-\t      && tree_fits_uhwi_p (TREE_OPERAND (curpos, 1)))\n+\t  if (pos)\n+\t    ;\n+\t  else if (TREE_CODE (curpos) == MULT_EXPR\n+\t\t   && tree_fits_uhwi_p (TREE_OPERAND (curpos, 1)))\n \t    {\n \t      tree offset = TREE_OPERAND (curpos, 0);\n \t      align = tree_to_uhwi (TREE_OPERAND (curpos, 1));\n \t      align = scale_by_factor_of (offset, align);\n \t      last_pos = round_up (last_pos, align);\n \t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n-\t  else if (!pos\n-\t\t   && TREE_CODE (curpos) == PLUS_EXPR\n+\t  else if (TREE_CODE (curpos) == PLUS_EXPR\n \t\t   && tree_fits_uhwi_p (TREE_OPERAND (curpos, 1))\n \t\t   && TREE_CODE (TREE_OPERAND (curpos, 0)) == MULT_EXPR\n \t\t   && tree_fits_uhwi_p\n@@ -2240,9 +2239,9 @@ rest_of_record_type_compilation (tree record_type)\n \t      last_pos = round_up (last_pos, align);\n \t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n-\t  else if (potential_alignment_gap (prev_old_field, old_field, pos))\n+\t  else\n \t    {\n-\t      align = TYPE_ALIGN (field_type);\n+\t      align = DECL_ALIGN (old_field);\n \t      last_pos = round_up (last_pos, align);\n \t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n@@ -2261,13 +2260,17 @@ rest_of_record_type_compilation (tree record_type)\n \t     in this case, if we don't preventively counter that.  */\n \t  if (TREE_CODE (DECL_SIZE (old_field)) != INTEGER_CST)\n \t    {\n-\t      field_type = build_pointer_type (field_type);\n-\t      if (align != 0 && TYPE_ALIGN (field_type) > align)\n+\t      field_type = copy_type (build_pointer_type (field_type));\n+\t      SET_TYPE_ALIGN (field_type, BITS_PER_UNIT);\n+\t      var = true;\n+\n+\t      /* ??? Kludge to work around a bug in Workbench's debugger.  */\n+\t      if (align == 0)\n \t\t{\n-\t\t  field_type = copy_type (field_type);\n-\t\t  SET_TYPE_ALIGN (field_type, align);\n+\t\t  align = DECL_ALIGN (old_field);\n+\t\t  last_pos = round_up (last_pos, align);\n+\t\t  pos = compute_related_constant (curpos, last_pos);\n \t\t}\n-\t      var = true;\n \t    }\n \n \t  /* Make a new field name, if necessary.  */\n@@ -2287,6 +2290,16 @@ rest_of_record_type_compilation (tree record_type)\n \t  new_field\n \t    = create_field_decl (field_name, field_type, new_record_type,\n \t\t\t\t DECL_SIZE (old_field), pos, 0, 0);\n+\t  /* The specified position is not the actual position of the field\n+\t     but the gap with the previous field, so the computation of the\n+\t     bit-field status may be incorrect.  We adjust it manually to\n+\t     avoid generating useless attributes for the field in DWARF.  */\n+\t  if (DECL_SIZE (old_field) == TYPE_SIZE (field_type)\n+\t      && value_factor_p (pos, BITS_PER_UNIT))\n+\t    {\n+\t      DECL_BIT_FIELD (new_field) = 0;\n+\t      DECL_BIT_FIELD_TYPE (new_field) = NULL_TREE;\n+\t    }\n \t  DECL_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n \t  TYPE_FIELDS (new_record_type) = new_field;\n \n@@ -2300,7 +2313,6 @@ rest_of_record_type_compilation (tree record_type)\n \t\t\t\t  == QUAL_UNION_TYPE)\n \t\t\t\t ? bitsize_zero_node\n \t\t\t\t : DECL_SIZE (old_field));\n-\t  prev_old_field = old_field;\n \t}\n \n       TYPE_FIELDS (new_record_type) = nreverse (TYPE_FIELDS (new_record_type));\n@@ -3260,52 +3272,6 @@ scale_by_factor_of (tree expr, unsigned int value)\n   return factor * value;\n }\n \n-/* Given two consecutive field decls PREV_FIELD and CURR_FIELD, return true\n-   unless we can prove these 2 fields are laid out in such a way that no gap\n-   exist between the end of PREV_FIELD and the beginning of CURR_FIELD.  OFFSET\n-   is the distance in bits between the end of PREV_FIELD and the starting\n-   position of CURR_FIELD. It is ignored if null. */\n-\n-static bool\n-potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n-{\n-  /* If this is the first field of the record, there cannot be any gap */\n-  if (!prev_field)\n-    return false;\n-\n-  /* If the previous field is a union type, then return false: The only\n-     time when such a field is not the last field of the record is when\n-     there are other components at fixed positions after it (meaning there\n-     was a rep clause for every field), in which case we don't want the\n-     alignment constraint to override them. */\n-  if (TREE_CODE (TREE_TYPE (prev_field)) == QUAL_UNION_TYPE)\n-    return false;\n-\n-  /* If the distance between the end of prev_field and the beginning of\n-     curr_field is constant, then there is a gap if the value of this\n-     constant is not null. */\n-  if (offset && tree_fits_uhwi_p (offset))\n-    return !integer_zerop (offset);\n-\n-  /* If the size and position of the previous field are constant,\n-     then check the sum of this size and position. There will be a gap\n-     iff it is not multiple of the current field alignment. */\n-  if (tree_fits_uhwi_p (DECL_SIZE (prev_field))\n-      && tree_fits_uhwi_p (bit_position (prev_field)))\n-    return ((tree_to_uhwi (bit_position (prev_field))\n-\t     + tree_to_uhwi (DECL_SIZE (prev_field)))\n-\t    % DECL_ALIGN (curr_field) != 0);\n-\n-  /* If both the position and size of the previous field are multiples\n-     of the current field alignment, there cannot be any gap. */\n-  if (value_factor_p (bit_position (prev_field), DECL_ALIGN (curr_field))\n-      && value_factor_p (DECL_SIZE (prev_field), DECL_ALIGN (curr_field)))\n-    return false;\n-\n-  /* Fallback, return that there may be a potential gap */\n-  return true;\n-}\n-\n /* Return a LABEL_DECL with NAME.  GNAT_NODE is used for the position of\n    the decl.  */\n "}]}