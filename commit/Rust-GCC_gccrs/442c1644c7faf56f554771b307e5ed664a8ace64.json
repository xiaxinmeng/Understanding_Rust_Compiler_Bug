{"sha": "442c1644c7faf56f554771b307e5ed664a8ace64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyYzE2NDRjN2ZhZjU2ZjU1NDc3MWIzMDdlNWVkNjY0YThhY2U2NA==", "commit": {"author": {"name": "Canqun Yang", "email": "canqun@nudt.edu.cn", "date": "2005-08-14T02:06:06Z"}, "committer": {"name": "Canqun Yang", "email": "canqun@gcc.gnu.org", "date": "2005-08-14T02:06:06Z"}, "message": "trans-stmt.c (gfc_trans_arithmetic_if): Optimized in case of equal labels.\n\n\t* trans-stmt.c (gfc_trans_arithmetic_if): Optimized in case of equal\n\tlabels.\n\nFrom-SVN: r103074", "tree": {"sha": "a144773c1a7d9d4662fa3c15aa3094a5e8083cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a144773c1a7d9d4662fa3c15aa3094a5e8083cd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/442c1644c7faf56f554771b307e5ed664a8ace64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442c1644c7faf56f554771b307e5ed664a8ace64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442c1644c7faf56f554771b307e5ed664a8ace64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442c1644c7faf56f554771b307e5ed664a8ace64/comments", "author": null, "committer": null, "parents": [{"sha": "ee1658f34360cd994f12c0bc525b714b2efe7bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee1658f34360cd994f12c0bc525b714b2efe7bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee1658f34360cd994f12c0bc525b714b2efe7bb8"}], "stats": {"total": 46, "additions": 36, "deletions": 10}, "files": [{"sha": "158123a2143ec348b549d2c25f0a974fe471b82c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442c1644c7faf56f554771b307e5ed664a8ace64/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442c1644c7faf56f554771b307e5ed664a8ace64/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=442c1644c7faf56f554771b307e5ed664a8ace64", "patch": "@@ -1,3 +1,8 @@\n+2005-08-14  Canqun Yang  <canqun@nudt.edu.cn>\n+\n+\t* trans-stmt.c (gfc_trans_arithmetic_if): Optimized in case of equal\n+\tlabels.\n+\n 2005-09-11  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \t    Steven Bosscher  <stevenb@suse.de>\n "}, {"sha": "040214ed27f4c8cba9d310b9b5e123af12b80b19", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442c1644c7faf56f554771b307e5ed664a8ace64/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442c1644c7faf56f554771b307e5ed664a8ace64/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=442c1644c7faf56f554771b307e5ed664a8ace64", "patch": "@@ -461,6 +461,14 @@ gfc_trans_if (gfc_code * code)\n       }\n     else // cond > 0\n       goto label3;\n+\n+   An optimized version can be generated in case of equal labels.\n+   E.g., if label1 is equal to label2, we can translate it to\n+\n+    if (cond <= 0)\n+      goto label1;\n+    else\n+      goto label3;\n */\n \n tree\n@@ -482,18 +490,31 @@ gfc_trans_arithmetic_if (gfc_code * code)\n   /* Build something to compare with.  */\n   zero = gfc_build_const (TREE_TYPE (se.expr), integer_zero_node);\n \n-  /* If (cond < 0) take branch1 else take branch2.\n-     First build jumps to the COND .LT. 0 and the COND .EQ. 0 cases.  */\n-  branch1 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label));\n-  branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label2));\n+  if (code->label->value != code->label2->value)\n+    {\n+      /* If (cond < 0) take branch1 else take branch2.\n+         First build jumps to the COND .LT. 0 and the COND .EQ. 0 cases.  */\n+      branch1 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label));\n+      branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label2));\n \n-  tmp = build2 (LT_EXPR, boolean_type_node, se.expr, zero);\n-  branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n+      if (code->label->value != code->label3->value)\n+        tmp = build2 (LT_EXPR, boolean_type_node, se.expr, zero);\n+      else\n+        tmp = build2 (NE_EXPR, boolean_type_node, se.expr, zero);\n \n-  /* if (cond <= 0) take branch1 else take branch2.  */\n-  branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label3));\n-  tmp = build2 (LE_EXPR, boolean_type_node, se.expr, zero);\n-  branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n+      branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n+    }\n+  else\n+    branch1 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label));\n+\n+  if (code->label->value != code->label3->value\n+      && code->label2->value != code->label3->value)\n+    {\n+      /* if (cond <= 0) take branch1 else take branch2.  */\n+      branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label3));\n+      tmp = build2 (LE_EXPR, boolean_type_node, se.expr, zero);\n+      branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n+    }\n \n   /* Append the COND_EXPR to the evaluation of COND, and return.  */\n   gfc_add_expr_to_block (&se.pre, branch1);"}]}