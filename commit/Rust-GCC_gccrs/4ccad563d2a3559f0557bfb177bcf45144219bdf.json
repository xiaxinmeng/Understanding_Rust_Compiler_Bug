{"sha": "4ccad563d2a3559f0557bfb177bcf45144219bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjYWQ1NjNkMmEzNTU5ZjA1NTdiZmIxNzdiY2Y0NTE0NDIxOWJkZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-23T04:31:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-23T04:31:11Z"}, "message": "libgo: Update to current sources.\n\nFrom-SVN: r192704", "tree": {"sha": "46bb86f514fbf6bad82da48e69a18fb09d878834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46bb86f514fbf6bad82da48e69a18fb09d878834"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ccad563d2a3559f0557bfb177bcf45144219bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ccad563d2a3559f0557bfb177bcf45144219bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ccad563d2a3559f0557bfb177bcf45144219bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ccad563d2a3559f0557bfb177bcf45144219bdf/comments", "author": null, "committer": null, "parents": [{"sha": "0b7463235f0e23c624d1911c9b15f531108cc5a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7463235f0e23c624d1911c9b15f531108cc5a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b7463235f0e23c624d1911c9b15f531108cc5a6"}], "stats": {"total": 69430, "additions": 56868, "deletions": 12562}, "files": [{"sha": "defa208a582930c4dcc5ccab49b2c640a1d8cbaf", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -1251,6 +1251,7 @@ Gogo::clear_file_scope()\n   this->package_->bindings()->clear_file_scope();\n \n   // Warn about packages which were imported but not used.\n+  bool quiet = saw_errors();\n   for (Packages::iterator p = this->packages_.begin();\n        p != this->packages_.end();\n        ++p)\n@@ -1260,7 +1261,7 @@ Gogo::clear_file_scope()\n \t  && package->is_imported()\n \t  && !package->used()\n \t  && !package->uses_sink_alias()\n-\t  && !saw_errors())\n+\t  && !quiet)\n \terror_at(package->location(), \"imported and not used: %s\",\n \t\t Gogo::message_name(package->package_name()).c_str());\n       package->clear_is_imported();"}, {"sha": "3da2f3dae264abb32253995de772d39c34ecc91b", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -32,6 +32,8 @@ enum Runtime_function_type\n   RFT_BOOLPTR,\n   // Go type int, C type int.\n   RFT_INT,\n+  // Go type int32, C type int32_t.\n+  RFT_INT32,\n   // Go type int64, C type int64_t.\n   RFT_INT64,\n   // Go type uint64, C type uint64_t.\n@@ -102,6 +104,10 @@ runtime_function_type(Runtime_function_type bft)\n \t  t = Type::lookup_integer_type(\"int\");\n \t  break;\n \n+\tcase RFT_INT32:\n+\t  t = Type::lookup_integer_type(\"int32\");\n+\t  break;\n+\n \tcase RFT_INT64:\n \t  t = Type::lookup_integer_type(\"int64\");\n \t  break;\n@@ -206,6 +212,7 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_BOOL:\n     case RFT_BOOLPTR:\n     case RFT_INT:\n+    case RFT_INT32:\n     case RFT_INT64:\n     case RFT_UINT64:\n     case RFT_UINTPTR:"}, {"sha": "b9492dc8af2a18531b7a6efb34545529e6a82530", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -148,27 +148,28 @@ DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P3(TYPE, CHAN, POINTER),\n \n \n // Start building a select statement.\n-DEF_GO_RUNTIME(NEWSELECT, \"runtime.newselect\", P1(INT), R1(POINTER))\n+DEF_GO_RUNTIME(NEWSELECT, \"runtime.newselect\", P1(INT32), R1(POINTER))\n \n // Add a default clause to a select statement.\n-DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\", P2(POINTER, INT), R0())\n+DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\",\n+\t       P2(POINTER, INT32), R0())\n \n // Add a send clause to a select statement.\n DEF_GO_RUNTIME(SELECTSEND, \"runtime.selectsend\",\n-\t       P4(POINTER, CHAN, POINTER, INT), R0())\n+\t       P4(POINTER, CHAN, POINTER, INT32), R0())\n \n // Add a receive clause to a select statement, for a clause which does\n // not check whether the channel is closed.\n DEF_GO_RUNTIME(SELECTRECV, \"runtime.selectrecv\",\n-\t       P4(POINTER, CHAN, POINTER, INT), R0())\n+\t       P4(POINTER, CHAN, POINTER, INT32), R0())\n \n // Add a receive clause to a select statement, for a clause which does\n // check whether the channel is closed.\n DEF_GO_RUNTIME(SELECTRECV2, \"runtime.selectrecv2\",\n-\t       P5(POINTER, CHAN, POINTER, BOOLPTR, INT), R0())\n+\t       P5(POINTER, CHAN, POINTER, BOOLPTR, INT32), R0())\n \n // Run a select, returning the index of the selected clause.\n-DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT))\n+DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT32))\n \n \n // Panic."}, {"sha": "ad249f6ac57f34879ca06771caf6460fe3f9b4ee", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -4841,6 +4841,8 @@ Select_clauses::get_backend(Translate_context* context,\n   std::vector<std::vector<Bexpression*> > cases(count);\n   std::vector<Bstatement*> clauses(count);\n \n+  Type* int32_type = Type::lookup_integer_type(\"int32\");\n+\n   int i = 0;\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n@@ -4849,7 +4851,8 @@ Select_clauses::get_backend(Translate_context* context,\n       int index = p->index();\n       mpz_t ival;\n       mpz_init_set_ui(ival, index);\n-      Expression* index_expr = Expression::make_integer(&ival, NULL, location);\n+      Expression* index_expr = Expression::make_integer(&ival, int32_type,\n+\t\t\t\t\t\t\tlocation);\n       mpz_clear(ival);\n       cases[i].push_back(tree_to_expr(index_expr->get_tree(context)));\n "}, {"sha": "063c2e0bf8d916f5866803a49414074cbc90a35b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug358.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug358.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug358.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug358.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -12,7 +12,7 @@ package main\n import (\n \t\"io/ioutil\"\t// GCCGO_ERROR \"imported and not used\"\n \t\"net/http\"\n-\t\"os\"\n+\t\"os\"\t\t// GCCGO_ERROR \"imported and not used\"\n )\n \n func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {"}, {"sha": "6d526228b8a62f7c6a130b2d10f3e2f07ba486da", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug369.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -38,9 +38,9 @@ func BenchmarkSlowNonASCII(b *testing.B) {\n }\n \n func main() {\n-\tos.Args = []string{os.Args[0], \"-test.benchtime=0.1\"}\n+\tos.Args = []string{os.Args[0], \"-test.benchtime=100ms\"}\n \tflag.Parse()\n-\t\n+\n \trslow := testing.Benchmark(BenchmarkSlowNonASCII)\n \trfast := testing.Benchmark(BenchmarkFastNonASCII)\n \ttslow := rslow.NsPerOp()"}, {"sha": "640cfb866f31fed8a098bc3f0f4efdb200064805", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -1,4 +1,4 @@\n-2d8bc3c94ecb\n+291d9f1baf75\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "a0565b80b3a174bc14e13a6734b7257255db5ead", "filename": "libgo/Makefile.am", "status": "modified", "additions": 136, "deletions": 15, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -230,6 +230,21 @@ toolexeclibgoexp_DATA = \\\n \texp/types.gox \\\n \texp/utf8string.gox\n \n+toolexeclibgoexphtmldir = $(toolexeclibgoexpdir)/html\n+\n+toolexeclibgoexphtml_DATA = \\\n+\texp/html/atom.gox\n+\n+toolexeclibgoexplocaledir = $(toolexeclibgoexpdir)/locale\n+\n+toolexeclibgoexplocale_DATA = \\\n+\texp/locale/collate.gox\n+\n+toolexeclibgoexplocalecollatedir = $(toolexeclibgoexplocaledir)/collate\n+\n+toolexeclibgoexplocalecollate_DATA = \\\n+\texp/locale/collate/build.gox\n+\n toolexeclibgogodir = $(toolexeclibgodir)/go\n \n toolexeclibgogo_DATA = \\\n@@ -483,6 +498,7 @@ runtime_files = \\\n \truntime/go-unwind.c \\\n \truntime/chan.c \\\n \truntime/cpuprof.c \\\n+\truntime/lfstack.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n@@ -492,6 +508,8 @@ runtime_files = \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n \truntime/msize.c \\\n+\truntime/panic.c \\\n+\truntime/parfor.c \\\n \truntime/print.c \\\n \truntime/proc.c \\\n \truntime/runtime.c \\\n@@ -656,16 +674,16 @@ go_net_newpollserver_file = go/net/newpollserver_rtems.go\n else # !LIBGO_IS_RTEMS\n if LIBGO_IS_LINUX\n go_net_fd_os_file = go/net/fd_linux.go\n-go_net_newpollserver_file = go/net/newpollserver.go\n+go_net_newpollserver_file = go/net/newpollserver_unix.go\n else # !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n if LIBGO_IS_NETBSD\n go_net_fd_os_file = go/net/fd_netbsd.go\n-go_net_newpollserver_file = go/net/newpollserver.go\n+go_net_newpollserver_file = go/net/newpollserver_unix.go\n else # !LIBGO_IS_NETBSD && !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n # By default use select with pipes.  Most systems should have\n # something better.\n go_net_fd_os_file = go/net/fd_select.go\n-go_net_newpollserver_file = go/net/newpollserver.go\n+go_net_newpollserver_file = go/net/newpollserver_unix.go\n endif # !LIBGO_IS_NETBSD\n endif # !LIBGO_IS_LINUX\n endif # !LIBGO_IS_RTEMS\n@@ -674,13 +692,13 @@ if LIBGO_IS_LINUX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n go_net_sockopt_file = go/net/sockopt_linux.go\n-go_net_sockoptip_file = go/net/sockoptip_linux.go\n+go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n else\n if LIBGO_IS_IRIX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n go_net_sockopt_file = go/net/sockopt_linux.go\n-go_net_sockoptip_file = go/net/sockoptip_linux.go\n+go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n else\n if LIBGO_IS_SOLARIS\n go_net_cgo_file = go/net/cgo_linux.go\n@@ -692,12 +710,19 @@ if LIBGO_IS_FREEBSD\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n-go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_freebsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+else\n+if LIBGO_IS_NETBSD\n+go_net_cgo_file = go/net/cgo_netbsd.go\n+go_net_sock_file = go/net/sock_bsd.go\n+go_net_sockopt_file = go/net/sockopt_bsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n else\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n-go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_netbsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+endif\n endif\n endif\n endif\n@@ -706,8 +731,12 @@ endif\n if LIBGO_IS_LINUX\n go_net_sendfile_file = go/net/sendfile_linux.go\n else\n+if LIBGO_IS_FREEBSD\n+go_net_sendfile_file = go/net/sendfile_freebsd.go\n+else\n go_net_sendfile_file = go/net/sendfile_stub.go\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_net_interface_file = go/net/interface_linux.go\n@@ -725,13 +754,12 @@ go_net_files = \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n-\tgo/net/dnsconfig.go \\\n+\tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n-\tgo/net/doc.go \\\n \t$(go_net_newpollserver_file) \\\n-\tgo/net/fd.go \\\n+\tgo/net/fd_unix.go \\\n \t$(go_net_fd_os_file) \\\n-\tgo/net/file.go \\\n+\tgo/net/file_unix.go \\\n \tgo/net/hosts.go \\\n \tgo/net/interface.go \\\n \t$(go_net_interface_file) \\\n@@ -740,19 +768,20 @@ go_net_files = \\\n \tgo/net/iprawsock_posix.go \\\n \tgo/net/ipsock.go \\\n \tgo/net/ipsock_posix.go \\\n+\tgo/net/lookup.go \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n \tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n+\tgo/net/port_unix.go \\\n \t$(go_net_sendfile_file) \\\n-\tgo/net/sock.go \\\n+\tgo/net/sock_posix.go \\\n \t$(go_net_sock_file) \\\n-\tgo/net/sockopt.go \\\n+\tgo/net/sockopt_posix.go \\\n \t$(go_net_sockopt_file) \\\n-\tgo/net/sockoptip.go \\\n \t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n@@ -831,6 +860,7 @@ go_path_files = \\\n \n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n+\tgo/reflect/makefunc.go \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n@@ -882,12 +912,14 @@ go_strconv_files = \\\n go_strings_files = \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n+\tgo/strings/search.go \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n \tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n+\tgo/sync/race0.go \\\n \tgo/sync/runtime.go \\\n \tgo/sync/rwmutex.go \\\n \tgo/sync/waitgroup.go\n@@ -930,11 +962,28 @@ go_unicode_files = \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n+if LIBGO_IS_LINUX\n+archive_tar_atim_file = go/archive/tar/stat_atim.go\n+endif\n+if LIBGO_IS_OPENBSD\n+archive_tar_atim_file = go/archive/tar/stat_atim.go\n+endif\n+if LIBGO_IS_DARWIN\n+archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+endif\n+if LIBGO_IS_FREEBSD\n+archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+endif\n+if LIBGO_IS_NETBSD\n+archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+endif\n \n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n \tgo/archive/tar/reader.go \\\n-\tgo/archive/tar/writer.go\n+\tgo/archive/tar/stat_unix.go \\\n+\tgo/archive/tar/writer.go \\\n+\t$(archive_tar_atim_file)\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n@@ -948,6 +997,7 @@ go_compress_bzip2_files = \\\n \tgo/compress/bzip2/move_to_front.go\n \n go_compress_flate_files = \\\n+\tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n@@ -979,6 +1029,7 @@ go_container_ring_files = \\\n go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n+\tgo/crypto/aes/cipher_generic.go \\\n \tgo/crypto/aes/const.go\n go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cbc.go \\\n@@ -1033,9 +1084,11 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n+\tgo/crypto/tls/ticket.go \\\n \tgo/crypto/tls/tls.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/pem_decrypt.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n@@ -1130,8 +1183,26 @@ go_exp_html_files = \\\n \tgo/exp/html/parse.go \\\n \tgo/exp/html/render.go \\\n \tgo/exp/html/token.go\n+go_exp_html_atom_files = \\\n+\tgo/exp/html/atom/atom.go \\\n+\tgo/exp/html/atom/table.go\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n+go_exp_locale_collate_files = \\\n+\tgo/exp/locale/collate/colelem.go \\\n+\tgo/exp/locale/collate/collate.go \\\n+\tgo/exp/locale/collate/contract.go \\\n+\tgo/exp/locale/collate/export.go \\\n+\tgo/exp/locale/collate/table.go \\\n+\tgo/exp/locale/collate/tables.go \\\n+\tgo/exp/locale/collate/trie.go\n+go_exp_locale_collate_build_files = \\\n+\tgo/exp/locale/collate/build/builder.go \\\n+\tgo/exp/locale/collate/build/colelem.go \\\n+\tgo/exp/locale/collate/build/contract.go \\\n+\tgo/exp/locale/collate/build/order.go \\\n+\tgo/exp/locale/collate/build/table.go \\\n+\tgo/exp/locale/collate/build/trie.go\n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n@@ -1161,6 +1232,7 @@ go_exp_utf8string_files = \\\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n+\tgo/go/ast/commentmap.go \\\n \tgo/go/ast/filter.go \\\n \tgo/go/ast/import.go \\\n \tgo/go/ast/print.go \\\n@@ -1170,6 +1242,7 @@ go_go_ast_files = \\\n go_go_build_files = \\\n \tgo/go/build/build.go \\\n \tgo/go/build/doc.go \\\n+\tgo/go/build/read.go \\\n \tsyslist.go\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n@@ -1235,6 +1308,7 @@ go_image_jpeg_files = \\\n \tgo/image/jpeg/writer.go\n \n go_image_png_files = \\\n+\tgo/image/png/paeth.go \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n@@ -1243,6 +1317,7 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/suffixarray.go\n \n go_io_ioutil_files = \\\n+\tgo/io/ioutil/blackhole.go \\\n \tgo/io/ioutil/ioutil.go \\\n \tgo/io/ioutil/tempfile.go\n \n@@ -1358,6 +1433,7 @@ go_path_filepath_files = \\\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\\n+\tgo/regexp/syntax/doc.go \\\n \tgo/regexp/syntax/parse.go \\\n \tgo/regexp/syntax/perl_groups.go \\\n \tgo/regexp/syntax/prog.go \\\n@@ -1544,6 +1620,7 @@ go_base_syscall_files = \\\n \tgo/syscall/syscall_errno.go \\\n \tgo/syscall/libcall_support.go \\\n \tgo/syscall/libcall_posix.go \\\n+\tgo/syscall/race0.go \\\n \tgo/syscall/socket.go \\\n \tgo/syscall/sockcmsg_unix.go \\\n \tgo/syscall/str.go \\\n@@ -1714,6 +1791,9 @@ libgo_go_objs = \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n \texp/html.lo \\\n+\texp/html/atom.lo \\\n+\texp/locale/collate.lo \\\n+\texp/locale/collate/build.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n \texp/terminal.lo \\\n@@ -2562,6 +2642,33 @@ exp/html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/html/check\n \n+@go_include@ exp/html/atom.lo.dep\n+exp/html/atom.lo.dep: $(go_exp_html_atom_files)\n+\t$(BUILDDEPS)\n+exp/html/atom.lo: $(go_exp_html_atom_files)\n+\t$(BUILDPACKAGE)\n+exp/html/atom/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/html/atom/check\n+\n+@go_include@ exp/locale/collate.lo.dep\n+exp/locale/collate.lo.dep: $(go_exp_locale_collate_files)\n+\t$(BUILDDEPS)\n+exp/locale/collate.lo: $(go_exp_locale_collate_files)\n+\t$(BUILDPACKAGE)\n+exp/locale/collate/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/locale/collate/check\n+\n+@go_include@ exp/locale/collate/build.lo.dep\n+exp/locale/collate/build.lo.dep: $(go_exp_locale_collate_build_files)\n+\t$(BUILDDEPS)\n+exp/locale/collate/build.lo: $(go_exp_locale_collate_build_files)\n+\t$(BUILDPACKAGE)\n+exp/locale/collate/build/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/locale/collate/build/check\n+\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -3142,6 +3249,9 @@ syscall/signame.lo: go/syscall/signame.c\n syscall/wait.lo: go/syscall/wait.c\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $<\n+syscall/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: syscall/check\n \n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n@@ -3310,8 +3420,14 @@ exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/html.gox: exp/html.lo\n \t$(BUILDGOX)\n+exp/html/atom.gox: exp/html/atom.lo\n+\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n+exp/locale/collate.gox: exp/locale/collate.lo\n+\t$(BUILDGOX)\n+exp/locale/collate/build.gox: exp/locale/collate/build.lo\n+\t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n@@ -3484,6 +3600,7 @@ TEST_PACKAGES = \\\n \tstrconv/check \\\n \tstrings/check \\\n \tsync/check \\\n+\tsyscall/check \\\n \ttime/check \\\n \tunicode/check \\\n \tarchive/tar/check \\\n@@ -3532,10 +3649,14 @@ TEST_PACKAGES = \\\n \tencoding/xml/check \\\n \texp/ebnf/check \\\n \texp/html/check \\\n+\texp/html/atom/check \\\n \t$(exp_inotify_check) \\\n+\texp/locale/collate/check \\\n+\texp/locale/collate/build/check \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/terminal/check \\\n+\texp/types/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\"}, {"sha": "482282319720e3b701001aeb368f506b8737901f", "filename": "libgo/Makefile.in", "status": "modified", "additions": 256, "deletions": 49, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -101,6 +101,9 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexphtmldir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexplocaledir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexplocalecollatedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohtmldir)\" \\\n@@ -151,24 +154,25 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n \tencoding/csv.lo encoding/gob.lo encoding/hex.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/html.lo exp/norm.lo exp/proxy.lo exp/terminal.lo \\\n-\texp/types.lo exp/utf8string.lo html/template.lo go/ast.lo \\\n-\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n-\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n-\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n-\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n-\timage/color.lo image/draw.lo image/gif.lo image/jpeg.lo \\\n-\timage/png.lo index/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n-\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n-\tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n-\tnet/smtp.lo net/textproto.lo net/url.lo old/netchan.lo \\\n-\told/regexp.lo old/template.lo os/exec.lo $(am__DEPENDENCIES_1) \\\n-\tos/signal.lo os/user.lo path/filepath.lo regexp/syntax.lo \\\n-\tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n-\tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n-\ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n-\ttesting/iotest.lo testing/quick.lo unicode/utf16.lo \\\n-\tunicode/utf8.lo\n+\texp/html.lo exp/html/atom.lo exp/locale/collate.lo \\\n+\texp/locale/collate/build.lo exp/norm.lo exp/proxy.lo \\\n+\texp/terminal.lo exp/types.lo exp/utf8string.lo \\\n+\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n+\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n+\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n+\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n+\tnet/http/pprof.lo image/color.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n+\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n+\tmath/rand.lo mime/multipart.lo net/http.lo net/mail.lo \\\n+\tnet/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\told/netchan.lo old/regexp.lo old/template.lo os/exec.lo \\\n+\t$(am__DEPENDENCIES_1) os/signal.lo os/user.lo path/filepath.lo \\\n+\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n+\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n+\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n+\ttext/template/parse.lo testing/iotest.lo testing/quick.lo \\\n+\tunicode/utf16.lo unicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n@@ -207,12 +211,12 @@ am__objects_5 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n \tgo-typedesc-equal.lo go-typestring.lo go-unsafe-new.lo \\\n \tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unwind.lo \\\n-\tchan.lo cpuprof.lo $(am__objects_1) mcache.lo mcentral.lo \\\n-\t$(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo mheap.lo \\\n-\tmsize.lo print.lo proc.lo runtime.lo signal_unix.lo thread.lo \\\n-\tyield.lo $(am__objects_3) iface.lo malloc.lo map.lo mprof.lo \\\n-\treflect.lo runtime1.lo sema.lo sigqueue.lo string.lo time.lo \\\n-\t$(am__objects_4)\n+\tchan.lo cpuprof.lo lfstack.lo $(am__objects_1) mcache.lo \\\n+\tmcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo \\\n+\tmheap.lo msize.lo panic.lo parfor.lo print.lo proc.lo \\\n+\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_3) \\\n+\tiface.lo malloc.lo map.lo mprof.lo reflect.lo runtime1.lo \\\n+\tsema.lo sigqueue.lo string.lo time.lo $(am__objects_4)\n am_libgo_la_OBJECTS = $(am__objects_5)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -250,7 +254,9 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptox509_DATA) \\\n \t$(toolexeclibgodatabase_DATA) $(toolexeclibgodatabasesql_DATA) \\\n \t$(toolexeclibgodebug_DATA) $(toolexeclibgoencoding_DATA) \\\n-\t$(toolexeclibgoexp_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgoexp_DATA) $(toolexeclibgoexphtml_DATA) \\\n+\t$(toolexeclibgoexplocale_DATA) \\\n+\t$(toolexeclibgoexplocalecollate_DATA) $(toolexeclibgogo_DATA) \\\n \t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n \t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n@@ -611,6 +617,18 @@ toolexeclibgoexp_DATA = \\\n \texp/types.gox \\\n \texp/utf8string.gox\n \n+toolexeclibgoexphtmldir = $(toolexeclibgoexpdir)/html\n+toolexeclibgoexphtml_DATA = \\\n+\texp/html/atom.gox\n+\n+toolexeclibgoexplocaledir = $(toolexeclibgoexpdir)/locale\n+toolexeclibgoexplocale_DATA = \\\n+\texp/locale/collate.gox\n+\n+toolexeclibgoexplocalecollatedir = $(toolexeclibgoexplocaledir)/collate\n+toolexeclibgoexplocalecollate_DATA = \\\n+\texp/locale/collate/build.gox\n+\n toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n@@ -811,6 +829,7 @@ runtime_files = \\\n \truntime/go-unwind.c \\\n \truntime/chan.c \\\n \truntime/cpuprof.c \\\n+\truntime/lfstack.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n@@ -820,6 +839,8 @@ runtime_files = \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n \truntime/msize.c \\\n+\truntime/panic.c \\\n+\truntime/parfor.c \\\n \truntime/print.c \\\n \truntime/proc.c \\\n \truntime/runtime.c \\\n@@ -947,31 +968,36 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_netbsd.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_linux.go\n @LIBGO_IS_RTEMS_TRUE@go_net_fd_os_file = go/net/fd_select.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n-@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver_unix.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver_unix.go\n+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver_unix.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n-@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_netbsd.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n-@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_solaris.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n-@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockopt_file = go/net/sockopt_bsd.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockopt_file = go/net/sockopt_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sockopt_file = go/net/sockopt_linux.go\n-@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_netbsd.go\n-@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_freebsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_solaris.go\n-@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n-@LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n-@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n+@LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_freebsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_netbsd.go\n@@ -982,13 +1008,12 @@ go_net_files = \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n-\tgo/net/dnsconfig.go \\\n+\tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n-\tgo/net/doc.go \\\n \t$(go_net_newpollserver_file) \\\n-\tgo/net/fd.go \\\n+\tgo/net/fd_unix.go \\\n \t$(go_net_fd_os_file) \\\n-\tgo/net/file.go \\\n+\tgo/net/file_unix.go \\\n \tgo/net/hosts.go \\\n \tgo/net/interface.go \\\n \t$(go_net_interface_file) \\\n@@ -997,19 +1022,20 @@ go_net_files = \\\n \tgo/net/iprawsock_posix.go \\\n \tgo/net/ipsock.go \\\n \tgo/net/ipsock_posix.go \\\n+\tgo/net/lookup.go \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n \tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n+\tgo/net/port_unix.go \\\n \t$(go_net_sendfile_file) \\\n-\tgo/net/sock.go \\\n+\tgo/net/sock_posix.go \\\n \t$(go_net_sock_file) \\\n-\tgo/net/sockopt.go \\\n+\tgo/net/sockopt_posix.go \\\n \t$(go_net_sockopt_file) \\\n-\tgo/net/sockoptip.go \\\n \t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n@@ -1058,6 +1084,7 @@ go_path_files = \\\n \n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n+\tgo/reflect/makefunc.go \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n@@ -1098,12 +1125,14 @@ go_strconv_files = \\\n go_strings_files = \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n+\tgo/strings/search.go \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n \tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n+\tgo/sync/race0.go \\\n \tgo/sync/runtime.go \\\n \tgo/sync/rwmutex.go \\\n \tgo/sync/waitgroup.go\n@@ -1140,10 +1169,17 @@ go_unicode_files = \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n+@LIBGO_IS_DARWIN_TRUE@archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+@LIBGO_IS_FREEBSD_TRUE@archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+@LIBGO_IS_LINUX_TRUE@archive_tar_atim_file = go/archive/tar/stat_atim.go\n+@LIBGO_IS_NETBSD_TRUE@archive_tar_atim_file = go/archive/tar/stat_atimespec.go\n+@LIBGO_IS_OPENBSD_TRUE@archive_tar_atim_file = go/archive/tar/stat_atim.go\n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n \tgo/archive/tar/reader.go \\\n-\tgo/archive/tar/writer.go\n+\tgo/archive/tar/stat_unix.go \\\n+\tgo/archive/tar/writer.go \\\n+\t$(archive_tar_atim_file)\n \n go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n@@ -1157,6 +1193,7 @@ go_compress_bzip2_files = \\\n \tgo/compress/bzip2/move_to_front.go\n \n go_compress_flate_files = \\\n+\tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n@@ -1188,6 +1225,7 @@ go_container_ring_files = \\\n go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n+\tgo/crypto/aes/cipher_generic.go \\\n \tgo/crypto/aes/const.go\n \n go_crypto_cipher_files = \\\n@@ -1257,10 +1295,12 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n+\tgo/crypto/tls/ticket.go \\\n \tgo/crypto/tls/tls.go\n \n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/pem_decrypt.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n@@ -1371,9 +1411,30 @@ go_exp_html_files = \\\n \tgo/exp/html/render.go \\\n \tgo/exp/html/token.go\n \n+go_exp_html_atom_files = \\\n+\tgo/exp/html/atom/atom.go \\\n+\tgo/exp/html/atom/table.go\n+\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n \n+go_exp_locale_collate_files = \\\n+\tgo/exp/locale/collate/colelem.go \\\n+\tgo/exp/locale/collate/collate.go \\\n+\tgo/exp/locale/collate/contract.go \\\n+\tgo/exp/locale/collate/export.go \\\n+\tgo/exp/locale/collate/table.go \\\n+\tgo/exp/locale/collate/tables.go \\\n+\tgo/exp/locale/collate/trie.go\n+\n+go_exp_locale_collate_build_files = \\\n+\tgo/exp/locale/collate/build/builder.go \\\n+\tgo/exp/locale/collate/build/colelem.go \\\n+\tgo/exp/locale/collate/build/contract.go \\\n+\tgo/exp/locale/collate/build/order.go \\\n+\tgo/exp/locale/collate/build/table.go \\\n+\tgo/exp/locale/collate/build/trie.go\n+\n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n@@ -1407,6 +1468,7 @@ go_exp_utf8string_files = \\\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n+\tgo/go/ast/commentmap.go \\\n \tgo/go/ast/filter.go \\\n \tgo/go/ast/import.go \\\n \tgo/go/ast/print.go \\\n@@ -1417,6 +1479,7 @@ go_go_ast_files = \\\n go_go_build_files = \\\n \tgo/go/build/build.go \\\n \tgo/go/build/doc.go \\\n+\tgo/go/build/read.go \\\n \tsyslist.go\n \n go_go_doc_files = \\\n@@ -1490,6 +1553,7 @@ go_image_jpeg_files = \\\n \tgo/image/jpeg/writer.go\n \n go_image_png_files = \\\n+\tgo/image/png/paeth.go \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n@@ -1498,6 +1562,7 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/suffixarray.go\n \n go_io_ioutil_files = \\\n+\tgo/io/ioutil/blackhole.go \\\n \tgo/io/ioutil/ioutil.go \\\n \tgo/io/ioutil/tempfile.go\n \n@@ -1624,6 +1689,7 @@ go_path_filepath_files = \\\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\\n+\tgo/regexp/syntax/doc.go \\\n \tgo/regexp/syntax/parse.go \\\n \tgo/regexp/syntax/perl_groups.go \\\n \tgo/regexp/syntax/prog.go \\\n@@ -1750,6 +1816,7 @@ go_base_syscall_files = \\\n \tgo/syscall/syscall_errno.go \\\n \tgo/syscall/libcall_support.go \\\n \tgo/syscall/libcall_posix.go \\\n+\tgo/syscall/race0.go \\\n \tgo/syscall/socket.go \\\n \tgo/syscall/sockcmsg_unix.go \\\n \tgo/syscall/str.go \\\n@@ -1867,6 +1934,9 @@ libgo_go_objs = \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n \texp/html.lo \\\n+\texp/html/atom.lo \\\n+\texp/locale/collate.lo \\\n+\texp/locale/collate/build.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n \texp/terminal.lo \\\n@@ -2065,6 +2135,7 @@ TEST_PACKAGES = \\\n \tstrconv/check \\\n \tstrings/check \\\n \tsync/check \\\n+\tsyscall/check \\\n \ttime/check \\\n \tunicode/check \\\n \tarchive/tar/check \\\n@@ -2113,10 +2184,14 @@ TEST_PACKAGES = \\\n \tencoding/xml/check \\\n \texp/ebnf/check \\\n \texp/html/check \\\n+\texp/html/atom/check \\\n \t$(exp_inotify_check) \\\n+\texp/locale/collate/check \\\n+\texp/locale/collate/build/check \\\n \texp/norm/check \\\n \texp/proxy/check \\\n \texp/terminal/check \\\n+\texp/types/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n@@ -2377,6 +2452,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-pointer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unwind.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iface.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lfstack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_futex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n@@ -2391,6 +2467,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mheap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mprof.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/msize.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/panic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parfor.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/print.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reflect.Plo@am__quote@\n@@ -2897,6 +2975,13 @@ cpuprof.lo: runtime/cpuprof.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n \n+lfstack.lo: runtime/lfstack.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lfstack.lo -MD -MP -MF $(DEPDIR)/lfstack.Tpo -c -o lfstack.lo `test -f 'runtime/lfstack.c' || echo '$(srcdir)/'`runtime/lfstack.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lfstack.Tpo $(DEPDIR)/lfstack.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/lfstack.c' object='lfstack.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lfstack.lo `test -f 'runtime/lfstack.c' || echo '$(srcdir)/'`runtime/lfstack.c\n+\n lock_sema.lo: runtime/lock_sema.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lock_sema.lo -MD -MP -MF $(DEPDIR)/lock_sema.Tpo -c -o lock_sema.lo `test -f 'runtime/lock_sema.c' || echo '$(srcdir)/'`runtime/lock_sema.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lock_sema.Tpo $(DEPDIR)/lock_sema.Plo\n@@ -2988,6 +3073,20 @@ msize.lo: runtime/msize.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o msize.lo `test -f 'runtime/msize.c' || echo '$(srcdir)/'`runtime/msize.c\n \n+panic.lo: runtime/panic.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT panic.lo -MD -MP -MF $(DEPDIR)/panic.Tpo -c -o panic.lo `test -f 'runtime/panic.c' || echo '$(srcdir)/'`runtime/panic.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/panic.Tpo $(DEPDIR)/panic.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/panic.c' object='panic.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o panic.lo `test -f 'runtime/panic.c' || echo '$(srcdir)/'`runtime/panic.c\n+\n+parfor.lo: runtime/parfor.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT parfor.lo -MD -MP -MF $(DEPDIR)/parfor.Tpo -c -o parfor.lo `test -f 'runtime/parfor.c' || echo '$(srcdir)/'`runtime/parfor.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/parfor.Tpo $(DEPDIR)/parfor.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/parfor.c' object='parfor.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o parfor.lo `test -f 'runtime/parfor.c' || echo '$(srcdir)/'`runtime/parfor.c\n+\n print.lo: runtime/print.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT print.lo -MD -MP -MF $(DEPDIR)/print.Tpo -c -o print.lo `test -f 'runtime/print.c' || echo '$(srcdir)/'`runtime/print.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/print.Tpo $(DEPDIR)/print.Plo\n@@ -3317,6 +3416,66 @@ uninstall-toolexeclibgoexpDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoexpdir)\" && rm -f $$files\n+install-toolexeclibgoexphtmlDATA: $(toolexeclibgoexphtml_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexphtmldir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexphtmldir)\"\n+\t@list='$(toolexeclibgoexphtml_DATA)'; test -n \"$(toolexeclibgoexphtmldir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexphtmldir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexphtmldir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexphtmlDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexphtml_DATA)'; test -n \"$(toolexeclibgoexphtmldir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexphtmldir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexphtmldir)\" && rm -f $$files\n+install-toolexeclibgoexplocaleDATA: $(toolexeclibgoexplocale_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexplocaledir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexplocaledir)\"\n+\t@list='$(toolexeclibgoexplocale_DATA)'; test -n \"$(toolexeclibgoexplocaledir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexplocaledir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexplocaledir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexplocaleDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexplocale_DATA)'; test -n \"$(toolexeclibgoexplocaledir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexplocaledir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexplocaledir)\" && rm -f $$files\n+install-toolexeclibgoexplocalecollateDATA: $(toolexeclibgoexplocalecollate_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoexplocalecollatedir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexplocalecollatedir)\"\n+\t@list='$(toolexeclibgoexplocalecollate_DATA)'; test -n \"$(toolexeclibgoexplocalecollatedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexplocalecollatedir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexplocalecollatedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoexplocalecollateDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoexplocalecollate_DATA)'; test -n \"$(toolexeclibgoexplocalecollatedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexplocalecollatedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexplocalecollatedir)\" && rm -f $$files\n install-toolexeclibgogoDATA: $(toolexeclibgogo_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgogodir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgogodir)\"\n@@ -3898,7 +4057,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexphtmldir)\" \"$(DESTDIR)$(toolexeclibgoexplocaledir)\" \"$(DESTDIR)$(toolexeclibgoexplocalecollatedir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -3969,6 +4128,9 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n+\tinstall-toolexeclibgoexphtmlDATA \\\n+\tinstall-toolexeclibgoexplocaleDATA \\\n+\tinstall-toolexeclibgoexplocalecollateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n@@ -4034,8 +4196,11 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA \\\n+\tuninstall-toolexeclibgoexphtmlDATA \\\n+\tuninstall-toolexeclibgoexplocaleDATA \\\n+\tuninstall-toolexeclibgoexplocalecollateDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n@@ -4080,6 +4245,9 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n+\tinstall-toolexeclibgoexphtmlDATA \\\n+\tinstall-toolexeclibgoexplocaleDATA \\\n+\tinstall-toolexeclibgoexplocalecollateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohtmlDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n@@ -4109,8 +4277,11 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n-\tuninstall-toolexeclibgoexpDATA uninstall-toolexeclibgogoDATA \\\n-\tuninstall-toolexeclibgohashDATA \\\n+\tuninstall-toolexeclibgoexpDATA \\\n+\tuninstall-toolexeclibgoexphtmlDATA \\\n+\tuninstall-toolexeclibgoexplocaleDATA \\\n+\tuninstall-toolexeclibgoexplocalecollateDATA \\\n+\tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n@@ -4909,6 +5080,33 @@ exp/html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/html/check\n \n+@go_include@ exp/html/atom.lo.dep\n+exp/html/atom.lo.dep: $(go_exp_html_atom_files)\n+\t$(BUILDDEPS)\n+exp/html/atom.lo: $(go_exp_html_atom_files)\n+\t$(BUILDPACKAGE)\n+exp/html/atom/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/html/atom/check\n+\n+@go_include@ exp/locale/collate.lo.dep\n+exp/locale/collate.lo.dep: $(go_exp_locale_collate_files)\n+\t$(BUILDDEPS)\n+exp/locale/collate.lo: $(go_exp_locale_collate_files)\n+\t$(BUILDPACKAGE)\n+exp/locale/collate/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/locale/collate/check\n+\n+@go_include@ exp/locale/collate/build.lo.dep\n+exp/locale/collate/build.lo.dep: $(go_exp_locale_collate_build_files)\n+\t$(BUILDDEPS)\n+exp/locale/collate/build.lo: $(go_exp_locale_collate_build_files)\n+\t$(BUILDPACKAGE)\n+exp/locale/collate/build/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: exp/locale/collate/build/check\n+\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -5486,6 +5684,9 @@ syscall/signame.lo: go/syscall/signame.c\n syscall/wait.lo: go/syscall/wait.c\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $<\n+syscall/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: syscall/check\n \n bufio.gox: bufio.lo\n \t$(BUILDGOX)\n@@ -5649,8 +5850,14 @@ exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n exp/html.gox: exp/html.lo\n \t$(BUILDGOX)\n+exp/html/atom.gox: exp/html/atom.lo\n+\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n+exp/locale/collate.gox: exp/locale/collate.lo\n+\t$(BUILDGOX)\n+exp/locale/collate/build.gox: exp/locale/collate/build.lo\n+\t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo"}, {"sha": "e20fa71f6a0cb3a5cc9c21b04290f1e96f525e8f", "filename": "libgo/configure", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -658,6 +658,8 @@ LIBGO_IS_SOLARIS_FALSE\n LIBGO_IS_SOLARIS_TRUE\n LIBGO_IS_RTEMS_FALSE\n LIBGO_IS_RTEMS_TRUE\n+LIBGO_IS_OPENBSD_FALSE\n+LIBGO_IS_OPENBSD_TRUE\n LIBGO_IS_NETBSD_FALSE\n LIBGO_IS_NETBSD_TRUE\n LIBGO_IS_LINUX_FALSE\n@@ -11100,7 +11102,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11103 \"configure\"\n+#line 11105 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11206,7 +11208,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11209 \"configure\"\n+#line 11211 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13471,6 +13473,7 @@ is_freebsd=no\n is_irix=no\n is_linux=no\n is_netbsd=no\n+is_openbsd=no\n is_rtems=no\n is_solaris=no\n GOOS=unknown\n@@ -13480,6 +13483,7 @@ case ${host} in\n   *-*-irix6*)    is_irix=yes;    GOOS=irix ;;\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n   *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n+  *-*-openbsd*)  is_openbsd=yes; GOOS=openbsd ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n@@ -13523,6 +13527,14 @@ else\n   LIBGO_IS_NETBSD_FALSE=\n fi\n \n+ if test $is_openbsd = yes; then\n+  LIBGO_IS_OPENBSD_TRUE=\n+  LIBGO_IS_OPENBSD_FALSE='#'\n+else\n+  LIBGO_IS_OPENBSD_TRUE='#'\n+  LIBGO_IS_OPENBSD_FALSE=\n+fi\n+\n  if test $is_rtems = yes; then\n   LIBGO_IS_RTEMS_TRUE=\n   LIBGO_IS_RTEMS_FALSE='#'\n@@ -15311,6 +15323,10 @@ if test -z \"${LIBGO_IS_NETBSD_TRUE}\" && test -z \"${LIBGO_IS_NETBSD_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_NETBSD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${LIBGO_IS_OPENBSD_TRUE}\" && test -z \"${LIBGO_IS_OPENBSD_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_OPENBSD\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_RTEMS_TRUE}\" && test -z \"${LIBGO_IS_RTEMS_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_RTEMS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "217763d19b23658288e2df59543d23788361ecde", "filename": "libgo/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -129,6 +129,7 @@ is_freebsd=no\n is_irix=no\n is_linux=no\n is_netbsd=no\n+is_openbsd=no\n is_rtems=no\n is_solaris=no\n GOOS=unknown\n@@ -138,6 +139,7 @@ case ${host} in\n   *-*-irix6*)    is_irix=yes;    GOOS=irix ;;\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n   *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n+  *-*-openbsd*)  is_openbsd=yes; GOOS=openbsd ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n@@ -146,6 +148,7 @@ AM_CONDITIONAL(LIBGO_IS_FREEBSD, test $is_freebsd = yes)\n AM_CONDITIONAL(LIBGO_IS_IRIX, test $is_irix = yes)\n AM_CONDITIONAL(LIBGO_IS_LINUX, test $is_linux = yes)\n AM_CONDITIONAL(LIBGO_IS_NETBSD, test $is_netbsd = yes)\n+AM_CONDITIONAL(LIBGO_IS_OPENBSD, test $is_openbsd = yes)\n AM_CONDITIONAL(LIBGO_IS_RTEMS, test $is_rtems = yes)\n AM_CONDITIONAL(LIBGO_IS_SOLARIS, test $is_solaris = yes)\n AC_SUBST(GOOS)"}, {"sha": "921b9fe9bdd1420186959d82e5383c578c860ec2", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -11,7 +11,12 @@\n //   http://www.gnu.org/software/tar/manual/html_node/Standard.html\n package tar\n \n-import \"time\"\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+)\n \n const (\n \tblockSize = 512\n@@ -49,6 +54,62 @@ type Header struct {\n \tChangeTime time.Time // status change time\n }\n \n+// sysStat, if non-nil, populates h from system-dependent fields of fi.\n+var sysStat func(fi os.FileInfo, h *Header) error\n+\n+// Mode constants from the tar spec.\n+const (\n+\tc_ISDIR  = 040000\n+\tc_ISFIFO = 010000\n+\tc_ISREG  = 0100000\n+\tc_ISLNK  = 0120000\n+\tc_ISBLK  = 060000\n+\tc_ISCHR  = 020000\n+\tc_ISSOCK = 0140000\n+)\n+\n+// FileInfoHeader creates a partially-populated Header from fi.\n+// If fi describes a symlink, FileInfoHeader records link as the link target.\n+func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n+\tif fi == nil {\n+\t\treturn nil, errors.New(\"tar: FileInfo is nil\")\n+\t}\n+\th := &Header{\n+\t\tName:    fi.Name(),\n+\t\tModTime: fi.ModTime(),\n+\t\tMode:    int64(fi.Mode().Perm()), // or'd with c_IS* constants later\n+\t}\n+\tswitch {\n+\tcase fi.Mode()&os.ModeType == 0:\n+\t\th.Mode |= c_ISREG\n+\t\th.Typeflag = TypeReg\n+\t\th.Size = fi.Size()\n+\tcase fi.IsDir():\n+\t\th.Typeflag = TypeDir\n+\t\th.Mode |= c_ISDIR\n+\tcase fi.Mode()&os.ModeSymlink != 0:\n+\t\th.Typeflag = TypeSymlink\n+\t\th.Mode |= c_ISLNK\n+\t\th.Linkname = link\n+\tcase fi.Mode()&os.ModeDevice != 0:\n+\t\tif fi.Mode()&os.ModeCharDevice != 0 {\n+\t\t\th.Mode |= c_ISCHR\n+\t\t\th.Typeflag = TypeChar\n+\t\t} else {\n+\t\t\th.Mode |= c_ISBLK\n+\t\t\th.Typeflag = TypeBlock\n+\t\t}\n+\tcase fi.Mode()&os.ModeSocket != 0:\n+\t\th.Mode |= c_ISSOCK\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"archive/tar: unknown file mode %v\", fi.Mode())\n+\t}\n+\tif sysStat != nil {\n+\t\treturn h, sysStat(fi, h)\n+\t}\n+\treturn h, nil\n+}\n+\n var zeroBlock = make([]byte, blockSize)\n \n // POSIX specifies a sum of the unsigned byte values, but the Sun tar uses signed byte values."}, {"sha": "6029b0871231316aad7e4667658c04ba969fc8ce", "filename": "libgo/go/archive/tar/stat_atim.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atim.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atim.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atim.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux openbsd\n+\n+package tar\n+\n+import (\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+func statAtime(st *syscall.Stat_t) time.Time {\n+\treturn time.Unix(st.Atim.Unix())\n+}\n+\n+func statCtime(st *syscall.Stat_t) time.Time {\n+\treturn time.Unix(st.Ctim.Unix())\n+}"}, {"sha": "6f17dbe30725c120218885cc662587b8c7dcb4d2", "filename": "libgo/go/archive/tar/stat_atimespec.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atimespec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atimespec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_atimespec.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd netbsd\n+\n+package tar\n+\n+import (\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+func statAtime(st *syscall.Stat_t) time.Time {\n+\treturn time.Unix(st.Atimespec.Unix())\n+}\n+\n+func statCtime(st *syscall.Stat_t) time.Time {\n+\treturn time.Unix(st.Ctimespec.Unix())\n+}"}, {"sha": "92bc92424293aa8c76b549d030a6559e7f4844df", "filename": "libgo/go/archive/tar/stat_unix.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux darwin freebsd openbsd netbsd\n+\n+package tar\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func init() {\n+\tsysStat = statUnix\n+}\n+\n+func statUnix(fi os.FileInfo, h *Header) error {\n+\tsys, ok := fi.Sys().(*syscall.Stat_t)\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\th.Uid = int(sys.Uid)\n+\th.Gid = int(sys.Gid)\n+\t// TODO(bradfitz): populate username & group.  os/user\n+\t// doesn't cache LookupId lookups, and lacks group\n+\t// lookup functions.\n+\th.AccessTime = statAtime(sys)\n+\th.ChangeTime = statCtime(sys)\n+\t// TODO(bradfitz): major/minor device numbers?\n+\treturn nil\n+}"}, {"sha": "0adc17900339c90fddadb865c3c89f5fc832bad3", "filename": "libgo/go/archive/tar/tar_test.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tar\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestFileInfoHeader(t *testing.T) {\n+\tfi, err := os.Lstat(\"testdata/small.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\th, err := FileInfoHeader(fi, \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"on small.txt: %v\", err)\n+\t}\n+\tif g, e := h.Name, \"small.txt\"; g != e {\n+\t\tt.Errorf(\"Name = %q; want %q\", g, e)\n+\t}\n+\tif g, e := h.Mode, int64(fi.Mode().Perm())|c_ISREG; g != e {\n+\t\tt.Errorf(\"Mode = %#o; want %#o\", g, e)\n+\t}\n+\tif g, e := h.Size, int64(5); g != e {\n+\t\tt.Errorf(\"Size = %v; want %v\", g, e)\n+\t}\n+\tif g, e := h.ModTime, fi.ModTime(); !g.Equal(e) {\n+\t\tt.Errorf(\"ModTime = %v; want %v\", g, e)\n+\t}\n+}\n+\n+func TestFileInfoHeaderSymlink(t *testing.T) {\n+\th, err := FileInfoHeader(symlink{}, \"some-target\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, e := h.Name, \"some-symlink\"; g != e {\n+\t\tt.Errorf(\"Name = %q; want %q\", g, e)\n+\t}\n+\tif g, e := h.Linkname, \"some-target\"; g != e {\n+\t\tt.Errorf(\"Linkname = %q; want %q\", g, e)\n+\t}\n+}\n+\n+type symlink struct{}\n+\n+func (symlink) Name() string       { return \"some-symlink\" }\n+func (symlink) Size() int64        { return 0 }\n+func (symlink) Mode() os.FileMode  { return os.ModeSymlink }\n+func (symlink) ModTime() time.Time { return time.Time{} }\n+func (symlink) IsDir() bool        { return false }\n+func (symlink) Sys() interface{}   { return nil }"}, {"sha": "a9c8fdbbc9ae26f2ac5ba6adf5af822ff287b544", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -27,7 +27,7 @@ var (\n //\n // Example:\n //\ttw := tar.NewWriter(w)\n-//\thdr := new(Header)\n+//\thdr := new(tar.Header)\n //\thdr.Size = length of data in bytes\n //\t// populate other hdr fields as desired\n //\tif err := tw.WriteHeader(hdr); err != nil {"}, {"sha": "a6b049ec32bf29698658cf57562715f868af3fa3", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 103, "deletions": 11, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -103,7 +103,7 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \t\t}\n \t\tz.File = append(z.File, f)\n \t}\n-\tif uint16(len(z.File)) != end.directoryRecords {\n+\tif uint16(len(z.File)) != uint16(end.directoryRecords) { // only compare 16 bits here\n \t\t// Return the readDirectoryHeader error if we read\n \t\t// the wrong number of directory entries.\n \t\treturn err\n@@ -123,7 +123,7 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\tsize := int64(f.CompressedSize)\n+\tsize := int64(f.CompressedSize64)\n \tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, size)\n \tswitch f.Method {\n \tcase Store: // (no compression)\n@@ -220,6 +220,8 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \tf.CRC32 = b.uint32()\n \tf.CompressedSize = b.uint32()\n \tf.UncompressedSize = b.uint32()\n+\tf.CompressedSize64 = uint64(f.CompressedSize)\n+\tf.UncompressedSize64 = uint64(f.UncompressedSize)\n \tfilenameLen := int(b.uint16())\n \textraLen := int(b.uint16())\n \tcommentLen := int(b.uint16())\n@@ -233,6 +235,28 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \tf.Name = string(d[:filenameLen])\n \tf.Extra = d[filenameLen : filenameLen+extraLen]\n \tf.Comment = string(d[filenameLen+extraLen:])\n+\n+\tif len(f.Extra) > 0 {\n+\t\tb := readBuf(f.Extra)\n+\t\tfor len(b) > 0 {\n+\t\t\ttag := b.uint16()\n+\t\t\tsize := b.uint16()\n+\t\t\tif tag == zip64ExtraId {\n+\t\t\t\t// update directory values from the zip64 extra block\n+\t\t\t\teb := readBuf(b)\n+\t\t\t\tif len(eb) >= 8 {\n+\t\t\t\t\tf.UncompressedSize64 = eb.uint64()\n+\t\t\t\t}\n+\t\t\t\tif len(eb) >= 8 {\n+\t\t\t\t\tf.CompressedSize64 = eb.uint64()\n+\t\t\t\t}\n+\t\t\t\tif len(eb) >= 8 {\n+\t\t\t\t\tf.headerOffset = int64(eb.uint64())\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tb = b[size:]\n+\t\t}\n+\t}\n \treturn nil\n }\n \n@@ -263,15 +287,23 @@ func readDataDescriptor(r io.Reader, f *File) error {\n \t\treturn err\n \t}\n \tb := readBuf(buf[:12])\n-\tf.CRC32 = b.uint32()\n-\tf.CompressedSize = b.uint32()\n-\tf.UncompressedSize = b.uint32()\n+\tif b.uint32() != f.CRC32 {\n+\t\treturn ErrChecksum\n+\t}\n+\n+\t// The two sizes that follow here can be either 32 bits or 64 bits\n+\t// but the spec is not very clear on this and different\n+\t// interpretations has been made causing incompatibilities. We\n+\t// already have the sizes from the central directory so we can\n+\t// just ignore these.\n+\n \treturn nil\n }\n \n func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error) {\n \t// look for directoryEndSignature in the last 1k, then in the last 65k\n \tvar buf []byte\n+\tvar directoryEndOffset int64\n \tfor i, bLen := range []int64{1024, 65 * 1024} {\n \t\tif bLen > size {\n \t\t\tbLen = size\n@@ -282,6 +314,7 @@ func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error)\n \t\t}\n \t\tif p := findSignatureInBlock(buf); p >= 0 {\n \t\t\tbuf = buf[p:]\n+\t\t\tdirectoryEndOffset = size - bLen + int64(p)\n \t\t\tbreak\n \t\t}\n \t\tif i == 1 || bLen == size {\n@@ -292,22 +325,75 @@ func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error)\n \t// read header into struct\n \tb := readBuf(buf[4:]) // skip signature\n \td := &directoryEnd{\n-\t\tdiskNbr:            b.uint16(),\n-\t\tdirDiskNbr:         b.uint16(),\n-\t\tdirRecordsThisDisk: b.uint16(),\n-\t\tdirectoryRecords:   b.uint16(),\n-\t\tdirectorySize:      b.uint32(),\n-\t\tdirectoryOffset:    b.uint32(),\n+\t\tdiskNbr:            uint32(b.uint16()),\n+\t\tdirDiskNbr:         uint32(b.uint16()),\n+\t\tdirRecordsThisDisk: uint64(b.uint16()),\n+\t\tdirectoryRecords:   uint64(b.uint16()),\n+\t\tdirectorySize:      uint64(b.uint32()),\n+\t\tdirectoryOffset:    uint64(b.uint32()),\n \t\tcommentLen:         b.uint16(),\n \t}\n \tl := int(d.commentLen)\n \tif l > len(b) {\n \t\treturn nil, errors.New(\"zip: invalid comment length\")\n \t}\n \td.comment = string(b[:l])\n+\n+\tp, err := findDirectory64End(r, directoryEndOffset)\n+\tif err == nil && p >= 0 {\n+\t\terr = readDirectory64End(r, p, d)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \treturn d, nil\n }\n \n+// findDirectory64End tries to read the zip64 locator just before the\n+// directory end and returns the offset of the zip64 directory end if\n+// found.\n+func findDirectory64End(r io.ReaderAt, directoryEndOffset int64) (int64, error) {\n+\tlocOffset := directoryEndOffset - directory64LocLen\n+\tif locOffset < 0 {\n+\t\treturn -1, nil // no need to look for a header outside the file\n+\t}\n+\tbuf := make([]byte, directory64LocLen)\n+\tif _, err := r.ReadAt(buf, locOffset); err != nil {\n+\t\treturn -1, err\n+\t}\n+\tb := readBuf(buf)\n+\tif sig := b.uint32(); sig != directory64LocSignature {\n+\t\treturn -1, nil\n+\t}\n+\tb = b[4:]       // skip number of the disk with the start of the zip64 end of central directory\n+\tp := b.uint64() // relative offset of the zip64 end of central directory record\n+\treturn int64(p), nil\n+}\n+\n+// readDirectory64End reads the zip64 directory end and updates the\n+// directory end with the zip64 directory end values.\n+func readDirectory64End(r io.ReaderAt, offset int64, d *directoryEnd) (err error) {\n+\tbuf := make([]byte, directory64EndLen)\n+\tif _, err := r.ReadAt(buf, offset); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tb := readBuf(buf)\n+\tif sig := b.uint32(); sig != directory64EndSignature {\n+\t\treturn ErrFormat\n+\t}\n+\n+\tb = b[12:]                        // skip dir size, version and version needed (uint64 + 2x uint16)\n+\td.diskNbr = b.uint32()            // number of this disk\n+\td.dirDiskNbr = b.uint32()         // number of the disk with the start of the central directory\n+\td.dirRecordsThisDisk = b.uint64() // total number of entries in the central directory on this disk\n+\td.directoryRecords = b.uint64()   // total number of entries in the central directory\n+\td.directorySize = b.uint64()      // size of the central directory\n+\td.directoryOffset = b.uint64()    // offset of start of central directory with respect to the starting disk number\n+\n+\treturn nil\n+}\n+\n func findSignatureInBlock(b []byte) int {\n \tfor i := len(b) - directoryEndLen; i >= 0; i-- {\n \t\t// defined from directoryEndSignature in struct.go\n@@ -335,3 +421,9 @@ func (b *readBuf) uint32() uint32 {\n \t*b = (*b)[4:]\n \treturn v\n }\n+\n+func (b *readBuf) uint64() uint64 {\n+\tv := binary.LittleEndian.Uint64(*b)\n+\t*b = (*b)[8:]\n+\treturn v\n+}"}, {"sha": "cf9c59c4b9231b4e7efc82b86dcb768efa35fd52", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -206,6 +206,17 @@ var tests = []ZipTest{\n \t\t\t},\n \t\t},\n \t},\n+\t{\n+\t\tName: \"zip64.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"README\",\n+\t\t\t\tContent: []byte(\"This small file is in ZIP64 format.\\n\"),\n+\t\t\t\tMtime:   \"08-10-12 14:33:32\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n var crossPlatform = []ZipTestFile{"}, {"sha": "ea067f3554fafdcecdc023807b2675238b5157a8", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -7,12 +7,19 @@ Package zip provides support for reading and writing ZIP archives.\n \n See: http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n \n-This package does not support ZIP64 or disk spanning.\n+This package does not support disk spanning.\n+\n+A note about ZIP64:\n+\n+To be backwards compatible the FileHeader has both 32 and 64 bit Size\n+fields. The 64 bit fields will always contain the correct value and\n+for normal archives both fields will be the same. For files requiring\n+the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit\n+fields must be used instead.\n */\n package zip\n \n import (\n-\t\"errors\"\n \t\"os\"\n \t\"time\"\n )\n@@ -27,34 +34,52 @@ const (\n \tfileHeaderSignature      = 0x04034b50\n \tdirectoryHeaderSignature = 0x02014b50\n \tdirectoryEndSignature    = 0x06054b50\n+\tdirectory64LocSignature  = 0x07064b50\n+\tdirectory64EndSignature  = 0x06064b50\n \tdataDescriptorSignature  = 0x08074b50 // de-facto standard; required by OS X Finder\n \tfileHeaderLen            = 30         // + filename + extra\n \tdirectoryHeaderLen       = 46         // + filename + extra + comment\n \tdirectoryEndLen          = 22         // + comment\n \tdataDescriptorLen        = 16         // four uint32: descriptor signature, crc32, compressed size, size\n+\tdataDescriptor64Len      = 24         // descriptor with 8 byte sizes\n+\tdirectory64LocLen        = 20         //\n+\tdirectory64EndLen        = 56         // + extra\n \n \t// Constants for the first byte in CreatorVersion\n \tcreatorFAT    = 0\n \tcreatorUnix   = 3\n \tcreatorNTFS   = 11\n \tcreatorVFAT   = 14\n \tcreatorMacOSX = 19\n+\n+\t// version numbers\n+\tzipVersion20 = 20 // 2.0\n+\tzipVersion45 = 45 // 4.5 (reads and writes zip64 archives)\n+\n+\t// limits for non zip64 files\n+\tuint16max = (1 << 16) - 1\n+\tuint32max = (1 << 32) - 1\n+\n+\t// extra header id's\n+\tzip64ExtraId = 0x0001 // zip64 Extended Information Extra Field\n )\n \n type FileHeader struct {\n-\tName             string\n-\tCreatorVersion   uint16\n-\tReaderVersion    uint16\n-\tFlags            uint16\n-\tMethod           uint16\n-\tModifiedTime     uint16 // MS-DOS time\n-\tModifiedDate     uint16 // MS-DOS date\n-\tCRC32            uint32\n-\tCompressedSize   uint32\n-\tUncompressedSize uint32\n-\tExtra            []byte\n-\tExternalAttrs    uint32 // Meaning depends on CreatorVersion\n-\tComment          string\n+\tName               string\n+\tCreatorVersion     uint16\n+\tReaderVersion      uint16\n+\tFlags              uint16\n+\tMethod             uint16\n+\tModifiedTime       uint16 // MS-DOS time\n+\tModifiedDate       uint16 // MS-DOS date\n+\tCRC32              uint32\n+\tCompressedSize     uint32 // deprecated; use CompressedSize64\n+\tUncompressedSize   uint32 // deprecated; use UncompressedSize64\n+\tCompressedSize64   uint64\n+\tUncompressedSize64 uint64\n+\tExtra              []byte\n+\tExternalAttrs      uint32 // Meaning depends on CreatorVersion\n+\tComment            string\n }\n \n // FileInfo returns an os.FileInfo for the FileHeader.\n@@ -67,8 +92,13 @@ type headerFileInfo struct {\n \tfh *FileHeader\n }\n \n-func (fi headerFileInfo) Name() string       { return fi.fh.Name }\n-func (fi headerFileInfo) Size() int64        { return int64(fi.fh.UncompressedSize) }\n+func (fi headerFileInfo) Name() string { return fi.fh.Name }\n+func (fi headerFileInfo) Size() int64 {\n+\tif fi.fh.UncompressedSize64 > 0 {\n+\t\treturn int64(fi.fh.UncompressedSize64)\n+\t}\n+\treturn int64(fi.fh.UncompressedSize)\n+}\n func (fi headerFileInfo) IsDir() bool        { return fi.Mode().IsDir() }\n func (fi headerFileInfo) ModTime() time.Time { return fi.fh.ModTime() }\n func (fi headerFileInfo) Mode() os.FileMode  { return fi.fh.Mode() }\n@@ -78,25 +108,27 @@ func (fi headerFileInfo) Sys() interface{}   { return fi.fh }\n // os.FileInfo.\n func FileInfoHeader(fi os.FileInfo) (*FileHeader, error) {\n \tsize := fi.Size()\n-\tif size > (1<<32 - 1) {\n-\t\treturn nil, errors.New(\"zip: file over 4GB\")\n-\t}\n \tfh := &FileHeader{\n-\t\tName:             fi.Name(),\n-\t\tUncompressedSize: uint32(size),\n+\t\tName:               fi.Name(),\n+\t\tUncompressedSize64: uint64(size),\n \t}\n \tfh.SetModTime(fi.ModTime())\n \tfh.SetMode(fi.Mode())\n+\tif fh.UncompressedSize64 > uint32max {\n+\t\tfh.UncompressedSize = uint32max\n+\t} else {\n+\t\tfh.UncompressedSize = uint32(fh.UncompressedSize64)\n+\t}\n \treturn fh, nil\n }\n \n type directoryEnd struct {\n-\tdiskNbr            uint16 // unused\n-\tdirDiskNbr         uint16 // unused\n-\tdirRecordsThisDisk uint16 // unused\n-\tdirectoryRecords   uint16\n-\tdirectorySize      uint32\n-\tdirectoryOffset    uint32 // relative to file\n+\tdiskNbr            uint32 // unused\n+\tdirDiskNbr         uint32 // unused\n+\tdirRecordsThisDisk uint64 // unused\n+\tdirectoryRecords   uint64\n+\tdirectorySize      uint64\n+\tdirectoryOffset    uint64 // relative to file\n \tcommentLen         uint16\n \tcomment            string\n }\n@@ -190,6 +222,11 @@ func (h *FileHeader) SetMode(mode os.FileMode) {\n \t}\n }\n \n+// isZip64 returns true if the file size exceeds the 32 bit limit\n+func (fh *FileHeader) isZip64() bool {\n+\treturn fh.CompressedSize64 > uint32max || fh.UncompressedSize64 > uint32max\n+}\n+\n func msdosModeToFileMode(m uint32) (mode os.FileMode) {\n \tif m&msdosDir != 0 {\n \t\tmode = os.ModeDir | 0777"}, {"sha": "a2ee1fa33dca48e1ec8dfc7507640bfa09bddeb6", "filename": "libgo/go/archive/zip/testdata/zip64.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fzip64.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fzip64.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fzip64.zip?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "50d83946d2cd264d79767a8f951ac789727fbf90", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 111, "deletions": 23, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -27,7 +27,7 @@ type Writer struct {\n \n type header struct {\n \t*FileHeader\n-\toffset uint32\n+\toffset uint64\n }\n \n // NewWriter returns a new Writer writing a zip file to w.\n@@ -62,14 +62,36 @@ func (w *Writer) Close() error {\n \t\tb.uint16(h.ModifiedTime)\n \t\tb.uint16(h.ModifiedDate)\n \t\tb.uint32(h.CRC32)\n-\t\tb.uint32(h.CompressedSize)\n-\t\tb.uint32(h.UncompressedSize)\n+\t\tif h.isZip64() || h.offset > uint32max {\n+\t\t\t// the file needs a zip64 header. store maxint in both\n+\t\t\t// 32 bit size fields (and offset later) to signal that the\n+\t\t\t// zip64 extra header should be used.\n+\t\t\tb.uint32(uint32max) // compressed size\n+\t\t\tb.uint32(uint32max) // uncompressed size\n+\n+\t\t\t// append a zip64 extra block to Extra\n+\t\t\tvar buf [28]byte // 2x uint16 + 3x uint64\n+\t\t\teb := writeBuf(buf[:])\n+\t\t\teb.uint16(zip64ExtraId)\n+\t\t\teb.uint16(24) // size = 3x uint64\n+\t\t\teb.uint64(h.UncompressedSize64)\n+\t\t\teb.uint64(h.CompressedSize64)\n+\t\t\teb.uint64(h.offset)\n+\t\t\th.Extra = append(h.Extra, buf[:]...)\n+\t\t} else {\n+\t\t\tb.uint32(h.CompressedSize)\n+\t\t\tb.uint32(h.UncompressedSize)\n+\t\t}\n \t\tb.uint16(uint16(len(h.Name)))\n \t\tb.uint16(uint16(len(h.Extra)))\n \t\tb.uint16(uint16(len(h.Comment)))\n \t\tb = b[4:] // skip disk number start and internal file attr (2x uint16)\n \t\tb.uint32(h.ExternalAttrs)\n-\t\tb.uint32(h.offset)\n+\t\tif h.offset > uint32max {\n+\t\t\tb.uint32(uint32max)\n+\t\t} else {\n+\t\t\tb.uint32(uint32(h.offset))\n+\t\t}\n \t\tif _, err := w.cw.Write(buf[:]); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -85,15 +107,52 @@ func (w *Writer) Close() error {\n \t}\n \tend := w.cw.count\n \n+\trecords := uint64(len(w.dir))\n+\tsize := uint64(end - start)\n+\toffset := uint64(start)\n+\n+\tif records > uint16max || size > uint32max || offset > uint32max {\n+\t\tvar buf [directory64EndLen + directory64LocLen]byte\n+\t\tb := writeBuf(buf[:])\n+\n+\t\t// zip64 end of central directory record\n+\t\tb.uint32(directory64EndSignature)\n+\t\tb.uint64(directory64EndLen)\n+\t\tb.uint16(zipVersion45) // version made by\n+\t\tb.uint16(zipVersion45) // version needed to extract\n+\t\tb.uint32(0)            // number of this disk\n+\t\tb.uint32(0)            // number of the disk with the start of the central directory\n+\t\tb.uint64(records)      // total number of entries in the central directory on this disk\n+\t\tb.uint64(records)      // total number of entries in the central directory\n+\t\tb.uint64(size)         // size of the central directory\n+\t\tb.uint64(offset)       // offset of start of central directory with respect to the starting disk number\n+\n+\t\t// zip64 end of central directory locator\n+\t\tb.uint32(directory64LocSignature)\n+\t\tb.uint32(0)           // number of the disk with the start of the zip64 end of central directory\n+\t\tb.uint64(uint64(end)) // relative offset of the zip64 end of central directory record\n+\t\tb.uint32(1)           // total number of disks\n+\n+\t\tif _, err := w.cw.Write(buf[:]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\t// store max values in the regular end record to signal that\n+\t\t// that the zip64 values should be used instead\n+\t\trecords = uint16max\n+\t\tsize = uint32max\n+\t\toffset = uint32max\n+\t}\n+\n \t// write end record\n \tvar buf [directoryEndLen]byte\n \tb := writeBuf(buf[:])\n \tb.uint32(uint32(directoryEndSignature))\n-\tb = b[4:]                     // skip over disk number and first disk number (2x uint16)\n-\tb.uint16(uint16(len(w.dir)))  // number of entries this disk\n-\tb.uint16(uint16(len(w.dir)))  // number of entries total\n-\tb.uint32(uint32(end - start)) // size of directory\n-\tb.uint32(uint32(start))       // start of directory\n+\tb = b[4:]                 // skip over disk number and first disk number (2x uint16)\n+\tb.uint16(uint16(records)) // number of entries this disk\n+\tb.uint16(uint16(records)) // number of entries total\n+\tb.uint32(uint32(size))    // size of directory\n+\tb.uint32(uint32(offset))  // start of directory\n \t// skipped size of comment (always zero)\n \tif _, err := w.cw.Write(buf[:]); err != nil {\n \t\treturn err\n@@ -127,8 +186,9 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \t}\n \n \tfh.Flags |= 0x8 // we will write a data descriptor\n-\tfh.CreatorVersion = fh.CreatorVersion&0xff00 | 0x14\n-\tfh.ReaderVersion = 0x14\n+\n+\tfh.CreatorVersion = fh.CreatorVersion&0xff00 | zipVersion20 // preserve compatibility byte\n+\tfh.ReaderVersion = zipVersion20\n \n \tfw := &fileWriter{\n \t\tzipw:      w.cw,\n@@ -151,7 +211,7 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \n \th := &header{\n \t\tFileHeader: fh,\n-\t\toffset:     uint32(w.cw.count),\n+\t\toffset:     uint64(w.cw.count),\n \t}\n \tw.dir = append(w.dir, h)\n \tfw.header = h\n@@ -173,9 +233,9 @@ func writeHeader(w io.Writer, h *FileHeader) error {\n \tb.uint16(h.Method)\n \tb.uint16(h.ModifiedTime)\n \tb.uint16(h.ModifiedDate)\n-\tb.uint32(h.CRC32)\n-\tb.uint32(h.CompressedSize)\n-\tb.uint32(h.UncompressedSize)\n+\tb.uint32(0) // since we are writing a data descriptor crc32,\n+\tb.uint32(0) // compressed size,\n+\tb.uint32(0) // and uncompressed size should be zero\n \tb.uint16(uint16(len(h.Name)))\n \tb.uint16(uint16(len(h.Extra)))\n \tif _, err := w.Write(buf[:]); err != nil {\n@@ -218,17 +278,40 @@ func (w *fileWriter) close() error {\n \t// update FileHeader\n \tfh := w.header.FileHeader\n \tfh.CRC32 = w.crc32.Sum32()\n-\tfh.CompressedSize = uint32(w.compCount.count)\n-\tfh.UncompressedSize = uint32(w.rawCount.count)\n+\tfh.CompressedSize64 = uint64(w.compCount.count)\n+\tfh.UncompressedSize64 = uint64(w.rawCount.count)\n \n-\t// write data descriptor\n-\tvar buf [dataDescriptorLen]byte\n-\tb := writeBuf(buf[:])\n+\tif fh.isZip64() {\n+\t\tfh.CompressedSize = uint32max\n+\t\tfh.UncompressedSize = uint32max\n+\t\tfh.ReaderVersion = zipVersion45 // requires 4.5 - File uses ZIP64 format extensions\n+\t} else {\n+\t\tfh.CompressedSize = uint32(fh.CompressedSize64)\n+\t\tfh.UncompressedSize = uint32(fh.UncompressedSize64)\n+\t}\n+\n+\t// Write data descriptor. This is more complicated than one would\n+\t// think, see e.g. comments in zipfile.c:putextended() and\n+\t// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588.\n+\t// The approach here is to write 8 byte sizes if needed without\n+\t// adding a zip64 extra in the local header (too late anyway).\n+\tvar buf []byte\n+\tif fh.isZip64() {\n+\t\tbuf = make([]byte, dataDescriptor64Len)\n+\t} else {\n+\t\tbuf = make([]byte, dataDescriptorLen)\n+\t}\n+\tb := writeBuf(buf)\n \tb.uint32(dataDescriptorSignature) // de-facto standard, required by OS X\n \tb.uint32(fh.CRC32)\n-\tb.uint32(fh.CompressedSize)\n-\tb.uint32(fh.UncompressedSize)\n-\t_, err := w.zipw.Write(buf[:])\n+\tif fh.isZip64() {\n+\t\tb.uint64(fh.CompressedSize64)\n+\t\tb.uint64(fh.UncompressedSize64)\n+\t} else {\n+\t\tb.uint32(fh.CompressedSize)\n+\t\tb.uint32(fh.UncompressedSize)\n+\t}\n+\t_, err := w.zipw.Write(buf)\n \treturn err\n }\n \n@@ -262,3 +345,8 @@ func (b *writeBuf) uint32(v uint32) {\n \tbinary.LittleEndian.PutUint32(*b, v)\n \t*b = (*b)[4:]\n }\n+\n+func (b *writeBuf) uint64(v uint64) {\n+\tbinary.LittleEndian.PutUint64(*b, v)\n+\t*b = (*b)[8:]\n+}"}, {"sha": "1d229d080ac7bc6c97315631d2ff61c432da4518", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 104, "deletions": 10, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -9,7 +9,8 @@ package zip\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"reflect\"\n+\t\"io\"\n+\t\"io/ioutil\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -58,24 +59,117 @@ func TestModTime(t *testing.T) {\n \t}\n }\n \n+func testHeaderRoundTrip(fh *FileHeader, wantUncompressedSize uint32, wantUncompressedSize64 uint64, t *testing.T) {\n+\tfi := fh.FileInfo()\n+\tfh2, err := FileInfoHeader(fi)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := fh2.Name, fh.Name; got != want {\n+\t\tt.Errorf(\"Name: got %s, want %s\\n\", got, want)\n+\t}\n+\tif got, want := fh2.UncompressedSize, wantUncompressedSize; got != want {\n+\t\tt.Errorf(\"UncompressedSize: got %d, want %d\\n\", got, want)\n+\t}\n+\tif got, want := fh2.UncompressedSize64, wantUncompressedSize64; got != want {\n+\t\tt.Errorf(\"UncompressedSize64: got %d, want %d\\n\", got, want)\n+\t}\n+\tif got, want := fh2.ModifiedTime, fh.ModifiedTime; got != want {\n+\t\tt.Errorf(\"ModifiedTime: got %d, want %d\\n\", got, want)\n+\t}\n+\tif got, want := fh2.ModifiedDate, fh.ModifiedDate; got != want {\n+\t\tt.Errorf(\"ModifiedDate: got %d, want %d\\n\", got, want)\n+\t}\n+\n+\tif sysfh, ok := fi.Sys().(*FileHeader); !ok && sysfh != fh {\n+\t\tt.Errorf(\"Sys didn't return original *FileHeader\")\n+\t}\n+}\n+\n func TestFileHeaderRoundTrip(t *testing.T) {\n \tfh := &FileHeader{\n \t\tName:             \"foo.txt\",\n \t\tUncompressedSize: 987654321,\n \t\tModifiedTime:     1234,\n \t\tModifiedDate:     5678,\n \t}\n-\tfi := fh.FileInfo()\n-\tfh2, err := FileInfoHeader(fi)\n+\ttestHeaderRoundTrip(fh, fh.UncompressedSize, uint64(fh.UncompressedSize), t)\n+}\n \n-\t// Ignore these fields:\n-\tfh2.CreatorVersion = 0\n-\tfh2.ExternalAttrs = 0\n+func TestFileHeaderRoundTrip64(t *testing.T) {\n+\tfh := &FileHeader{\n+\t\tName:               \"foo.txt\",\n+\t\tUncompressedSize64: 9876543210,\n+\t\tModifiedTime:       1234,\n+\t\tModifiedDate:       5678,\n+\t}\n+\ttestHeaderRoundTrip(fh, uint32max, fh.UncompressedSize64, t)\n+}\n \n-\tif !reflect.DeepEqual(fh, fh2) {\n-\t\tt.Errorf(\"mismatch\\n input=%#v\\noutput=%#v\\nerr=%v\", fh, fh2, err)\n+func TestZip64(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"slow test; skipping\")\n+\t\treturn\n \t}\n-\tif sysfh, ok := fi.Sys().(*FileHeader); !ok && sysfh != fh {\n-\t\tt.Errorf(\"Sys didn't return original *FileHeader\")\n+\t// write 2^32 bytes plus \"END\\n\" to a zip file\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\tf, err := w.Create(\"huge.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tchunk := make([]byte, 1024)\n+\tfor i := range chunk {\n+\t\tchunk[i] = '.'\n+\t}\n+\tchunk[len(chunk)-1] = '\\n'\n+\tend := []byte(\"END\\n\")\n+\tfor i := 0; i < (1<<32)/1024; i++ {\n+\t\t_, err := f.Write(chunk)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"write chunk:\", err)\n+\t\t}\n+\t}\n+\t_, err = f.Write(end)\n+\tif err != nil {\n+\t\tt.Fatal(\"write end:\", err)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read back zip file and check that we get to the end of it\n+\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(\"reader:\", err)\n+\t}\n+\tf0 := r.File[0]\n+\trc, err := f0.Open()\n+\tif err != nil {\n+\t\tt.Fatal(\"opening:\", err)\n+\t}\n+\tfor i := 0; i < (1<<32)/1024; i++ {\n+\t\t_, err := io.ReadFull(rc, chunk)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"read:\", err)\n+\t\t}\n+\t}\n+\tgotEnd, err := ioutil.ReadAll(rc)\n+\tif err != nil {\n+\t\tt.Fatal(\"read end:\", err)\n+\t}\n+\tif !bytes.Equal(gotEnd, end) {\n+\t\tt.Errorf(\"End of zip64 archive %q, want %q\", gotEnd, end)\n+\t}\n+\terr = rc.Close()\n+\tif err != nil {\n+\t\tt.Fatal(\"closing:\", err)\n+\t}\n+\tif got, want := f0.UncompressedSize, uint32(uint32max); got != want {\n+\t\tt.Errorf(\"UncompressedSize %d, want %d\", got, want)\n+\t}\n+\n+\tif got, want := f0.UncompressedSize64, (1<<32)+uint64(len(end)); got != want {\n+\t\tt.Errorf(\"UncompressedSize64 %d, want %d\", got, want)\n \t}\n }"}, {"sha": "d6ba485fa3e88aeb95731f430891f8ae12a74bb1", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -375,6 +375,41 @@ func (b *Reader) ReadString(delim byte) (line string, err error) {\n \treturn string(bytes), e\n }\n \n+// WriteTo implements io.WriterTo.\n+func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {\n+\tn, err = b.writeBuf(w)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif r, ok := b.rd.(io.WriterTo); ok {\n+\t\tm, err := r.WriteTo(w)\n+\t\tn += m\n+\t\treturn n, err\n+\t}\n+\n+\tfor b.fill(); b.r < b.w; b.fill() {\n+\t\tm, err := b.writeBuf(w)\n+\t\tn += m\n+\t\tif err != nil {\n+\t\t\treturn n, err\n+\t\t}\n+\t}\n+\n+\tif b.err == io.EOF {\n+\t\tb.err = nil\n+\t}\n+\n+\treturn n, b.readErr()\n+}\n+\n+// writeBuf writes the Reader's buffer to the writer.\n+func (b *Reader) writeBuf(w io.Writer) (int64, error) {\n+\tn, err := w.Write(b.buf[b.r:b.w])\n+\tb.r += n\n+\treturn int64(n), err\n+}\n+\n // buffered output\n \n // Writer implements buffering for an io.Writer object."}, {"sha": "4e10207efbd4948a4e8ecd28972a073f41fbfc34", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -762,3 +762,107 @@ func testReadLineNewlines(t *testing.T, input string, expect []readLineResult) {\n \t\t}\n \t}\n }\n+\n+func TestReaderWriteTo(t *testing.T) {\n+\tinput := make([]byte, 8192)\n+\tfor i := range input {\n+\t\t// 101 and 251 are arbitrary prime numbers.\n+\t\t// The idea is to create an input sequence\n+\t\t// which doesn't repeat too frequently.\n+\t\tinput[i] = byte(i % 251)\n+\t\tif i%101 == 0 {\n+\t\t\tinput[i] ^= byte(i / 101)\n+\t\t}\n+\t}\n+\tr := NewReader(bytes.NewBuffer(input))\n+\tw := new(bytes.Buffer)\n+\tif n, err := r.WriteTo(w); err != nil || n != int64(len(input)) {\n+\t\tt.Fatalf(\"r.WriteTo(w) = %d, %v, want %d, nil\", n, err, len(input))\n+\t}\n+\n+\tfor i, val := range w.Bytes() {\n+\t\tif val != input[i] {\n+\t\t\tt.Errorf(\"after write: out[%d] = %#x, want %#x\", i, val, input[i])\n+\t\t}\n+\t}\n+}\n+\n+type errorWriterToTest struct {\n+\trn, wn     int\n+\trerr, werr error\n+\texpected   error\n+}\n+\n+func (r errorWriterToTest) Read(p []byte) (int, error) {\n+\treturn len(p) * r.rn, r.rerr\n+}\n+\n+func (w errorWriterToTest) Write(p []byte) (int, error) {\n+\treturn len(p) * w.wn, w.werr\n+}\n+\n+var errorWriterToTests = []errorWriterToTest{\n+\t{1, 0, nil, io.ErrClosedPipe, io.ErrClosedPipe},\n+\t{0, 1, io.ErrClosedPipe, nil, io.ErrClosedPipe},\n+\t{0, 0, io.ErrUnexpectedEOF, io.ErrClosedPipe, io.ErrClosedPipe},\n+\t{0, 1, io.EOF, nil, nil},\n+}\n+\n+func TestReaderWriteToErrors(t *testing.T) {\n+\tfor i, rw := range errorWriterToTests {\n+\t\tr := NewReader(rw)\n+\t\tif _, err := r.WriteTo(rw); err != rw.expected {\n+\t\t\tt.Errorf(\"r.WriteTo(errorWriterToTests[%d]) = _, %v, want _,%v\", i, err, rw.expected)\n+\t\t}\n+\t}\n+}\n+\n+// An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n+type onlyReader struct {\n+\tr io.Reader\n+}\n+\n+func (r *onlyReader) Read(b []byte) (int, error) {\n+\treturn r.r.Read(b)\n+}\n+\n+// An onlyWriter only implements io.Writer, no matter what other methods the underlying implementation may have.\n+type onlyWriter struct {\n+\tw io.Writer\n+}\n+\n+func (w *onlyWriter) Write(b []byte) (int, error) {\n+\treturn w.w.Write(b)\n+}\n+\n+func BenchmarkReaderCopyOptimal(b *testing.B) {\n+\t// Optimal case is where the underlying reader implements io.WriterTo\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := NewReader(bytes.NewBuffer(make([]byte, 8192)))\n+\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}\n+\n+func BenchmarkReaderCopyUnoptimal(b *testing.B) {\n+\t// Unoptimal case is where the underlying reader doesn't implement io.WriterTo\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := NewReader(&onlyReader{bytes.NewBuffer(make([]byte, 8192))})\n+\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}\n+\n+func BenchmarkReaderCopyNoWriteTo(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := &onlyReader{NewReader(bytes.NewBuffer(make([]byte, 8192)))}\n+\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}"}, {"sha": "efb9798ee018b0040672648e360a7941a4e7f23a", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -99,6 +99,19 @@ func (b *Buffer) grow(n int) int {\n \treturn b.off + m\n }\n \n+// Grow grows the buffer's capacity, if necessary, to guarantee space for\n+// another n bytes. After Grow(n), at least n bytes can be written to the\n+// buffer without another allocation.\n+// If n is negative, Grow will panic.\n+// If the buffer can't grow it will panic with ErrTooLarge.\n+func (b *Buffer) Grow(n int) {\n+\tif n < 0 {\n+\t\tpanic(\"bytes.Buffer.Grow: negative count\")\n+\t}\n+\tm := b.grow(n)\n+\tb.buf = b.buf[0:m]\n+}\n+\n // Write appends the contents of p to the buffer.  The return\n // value n is the length of p; err is always nil.\n // If the buffer becomes too large, Write will panic with"}, {"sha": "dfecea19ae39e7924bbc1ccddd19678e15934781", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -8,20 +8,21 @@ import (\n \t. \"bytes\"\n \t\"io\"\n \t\"math/rand\"\n+\t\"runtime\"\n \t\"testing\"\n \t\"unicode/utf8\"\n )\n \n-const N = 10000  // make this bigger for a larger (and slower) test\n-var data string  // test data for write tests\n-var bytes []byte // test data; same as data but as a slice.\n+const N = 10000      // make this bigger for a larger (and slower) test\n+var data string      // test data for write tests\n+var testBytes []byte // test data; same as data but as a slice.\n \n func init() {\n-\tbytes = make([]byte, N)\n+\ttestBytes = make([]byte, N)\n \tfor i := 0; i < N; i++ {\n-\t\tbytes[i] = 'a' + byte(i%26)\n+\t\ttestBytes[i] = 'a' + byte(i%26)\n \t}\n-\tdata = string(bytes)\n+\tdata = string(testBytes)\n }\n \n // Verify that contents of buf match the string s.\n@@ -84,7 +85,7 @@ func fillBytes(t *testing.T, testname string, buf *Buffer, s string, n int, fub\n }\n \n func TestNewBuffer(t *testing.T) {\n-\tbuf := NewBuffer(bytes)\n+\tbuf := NewBuffer(testBytes)\n \tcheck(t, \"NewBuffer\", buf, data)\n }\n \n@@ -187,7 +188,7 @@ func TestLargeByteWrites(t *testing.T) {\n \t\tlimit = 9\n \t}\n \tfor i := 3; i < limit; i += 3 {\n-\t\ts := fillBytes(t, \"TestLargeWrites (1)\", &buf, \"\", 5, bytes)\n+\t\ts := fillBytes(t, \"TestLargeWrites (1)\", &buf, \"\", 5, testBytes)\n \t\tempty(t, \"TestLargeByteWrites (2)\", &buf, s, make([]byte, len(data)/i))\n \t}\n \tcheck(t, \"TestLargeByteWrites (3)\", &buf, \"\")\n@@ -205,7 +206,7 @@ func TestLargeStringReads(t *testing.T) {\n func TestLargeByteReads(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n-\t\ts := fillBytes(t, \"TestLargeReads (1)\", &buf, \"\", 5, bytes[0:len(bytes)/i])\n+\t\ts := fillBytes(t, \"TestLargeReads (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tempty(t, \"TestLargeReads (2)\", &buf, s, make([]byte, len(data)))\n \t}\n \tcheck(t, \"TestLargeByteReads (3)\", &buf, \"\")\n@@ -219,7 +220,7 @@ func TestMixedReadsAndWrites(t *testing.T) {\n \t\tif i%2 == 0 {\n \t\t\ts = fillString(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, data[0:wlen])\n \t\t} else {\n-\t\t\ts = fillBytes(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, bytes[0:wlen])\n+\t\t\ts = fillBytes(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, testBytes[0:wlen])\n \t\t}\n \n \t\trlen := rand.Intn(len(data))\n@@ -240,7 +241,7 @@ func TestNil(t *testing.T) {\n func TestReadFrom(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n-\t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, bytes[0:len(bytes)/i])\n+\t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tvar b Buffer\n \t\tb.ReadFrom(&buf)\n \t\tempty(t, \"TestReadFrom (2)\", &b, s, make([]byte, len(data)))\n@@ -250,7 +251,7 @@ func TestReadFrom(t *testing.T) {\n func TestWriteTo(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n-\t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, bytes[0:len(bytes)/i])\n+\t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tvar b Buffer\n \t\tbuf.WriteTo(&b)\n \t\tempty(t, \"TestReadFrom (2)\", &b, s, make([]byte, len(data)))\n@@ -374,6 +375,37 @@ func TestReadBytes(t *testing.T) {\n \t}\n }\n \n+func TestGrow(t *testing.T) {\n+\tx := []byte{'x'}\n+\ty := []byte{'y'}\n+\ttmp := make([]byte, 72)\n+\tfor _, startLen := range []int{0, 100, 1000, 10000, 100000} {\n+\t\txBytes := Repeat(x, startLen)\n+\t\tfor _, growLen := range []int{0, 100, 1000, 10000, 100000} {\n+\t\t\tbuf := NewBuffer(xBytes)\n+\t\t\t// If we read, this affects buf.off, which is good to test.\n+\t\t\treadBytes, _ := buf.Read(tmp)\n+\t\t\tbuf.Grow(growLen)\n+\t\t\tyBytes := Repeat(y, growLen)\n+\t\t\t// Check no allocation occurs in write, as long as we're single-threaded.\n+\t\t\tvar m1, m2 runtime.MemStats\n+\t\t\truntime.ReadMemStats(&m1)\n+\t\t\tbuf.Write(yBytes)\n+\t\t\truntime.ReadMemStats(&m2)\n+\t\t\tif runtime.GOMAXPROCS(-1) == 1 && m1.Mallocs != m2.Mallocs {\n+\t\t\t\tt.Errorf(\"allocation occurred during write\")\n+\t\t\t}\n+\t\t\t// Check that buffer has correct data.\n+\t\t\tif !Equal(buf.Bytes()[0:startLen-readBytes], xBytes[readBytes:]) {\n+\t\t\t\tt.Errorf(\"bad initial data at %d %d\", startLen, growLen)\n+\t\t\t}\n+\t\t\tif !Equal(buf.Bytes()[startLen-readBytes:startLen-readBytes+growLen], yBytes) {\n+\t\t\t\tt.Errorf(\"bad written data at %d %d\", startLen, growLen)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n // Was a bug: used to give EOF reading empty slice at EOF.\n func TestReadEmptyAtEOF(t *testing.T) {\n \tb := new(Buffer)"}, {"sha": "c3980bb2ab56a3308fa94b7a1baba67058231c3e", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -333,14 +333,15 @@ func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \treturn a[0:na]\n }\n \n-// Join concatenates the elements of a to create a single byte array.   The separator\n+// Join concatenates the elements of a to create a new byte array. The separator\n // sep is placed between elements in the resulting array.\n func Join(a [][]byte, sep []byte) []byte {\n \tif len(a) == 0 {\n \t\treturn []byte{}\n \t}\n \tif len(a) == 1 {\n-\t\treturn a[0]\n+\t\t// Just return a copy.\n+\t\treturn append([]byte(nil), a[0]...)\n \t}\n \tn := len(sep) * (len(a) - 1)\n \tfor i := 0; i < len(a); i++ {\n@@ -619,10 +620,8 @@ func Replace(s, old, new []byte, n int) []byte {\n \t\tm = Count(s, old)\n \t}\n \tif m == 0 {\n-\t\t// Nothing to do. Just copy.\n-\t\tt := make([]byte, len(s))\n-\t\tcopy(t, s)\n-\t\treturn t\n+\t\t// Just return a copy.\n+\t\treturn append([]byte(nil), s...)\n \t}\n \tif n < 0 || m < n {\n \t\tn = m"}, {"sha": "124760ac741d0bba559490177f6c903c32585d4d", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"math/rand\"\n \t\"reflect\"\n \t\"testing\"\n \t\"unicode\"\n@@ -490,6 +491,12 @@ func TestSplit(t *testing.T) {\n \t\t\t\tt.Errorf(\"Split disagrees withSplitN(%q, %q, %d) = %v; want %v\", tt.s, tt.sep, tt.n, b, a)\n \t\t\t}\n \t\t}\n+\t\tif len(a) > 0 {\n+\t\t\tin, out := a[0], s\n+\t\t\tif cap(in) == cap(out) && &in[:1][0] == &out[:1][0] {\n+\t\t\t\tt.Errorf(\"Join(%#v, %q) didn't copy\", a, tt.sep)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -561,6 +568,14 @@ func TestFields(t *testing.T) {\n }\n \n func TestFieldsFunc(t *testing.T) {\n+\tfor _, tt := range fieldstests {\n+\t\ta := FieldsFunc([]byte(tt.s), unicode.IsSpace)\n+\t\tresult := arrayOfString(a)\n+\t\tif !eq(result, tt.a) {\n+\t\t\tt.Errorf(\"FieldsFunc(%q, unicode.IsSpace) = %v; want %v\", tt.s, a, tt.a)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n \tpred := func(c rune) bool { return c == 'X' }\n \tvar fieldsFuncTests = []FieldsTest{\n \t\t{\"\", []string{}},\n@@ -1008,3 +1023,39 @@ func TestEqualFold(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var makeFieldsInput = func() []byte {\n+\tx := make([]byte, 1<<20)\n+\t// Input is ~10% space, ~10% 2-byte UTF-8, rest ASCII non-space. \n+\tfor i := range x {\n+\t\tswitch rand.Intn(10) {\n+\t\tcase 0:\n+\t\t\tx[i] = ' '\n+\t\tcase 1:\n+\t\t\tif i > 0 && x[i-1] == 'x' {\n+\t\t\t\tcopy(x[i-1:], \"\u03c7\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfallthrough\n+\t\tdefault:\n+\t\t\tx[i] = 'x'\n+\t\t}\n+\t}\n+\treturn x\n+}\n+\n+var fieldsInput = makeFieldsInput()\n+\n+func BenchmarkFields(b *testing.B) {\n+\tb.SetBytes(int64(len(fieldsInput)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFields(fieldsInput)\n+\t}\n+}\n+\n+func BenchmarkFieldsFunc(b *testing.B) {\n+\tb.SetBytes(int64(len(fieldsInput)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFieldsFunc(fieldsInput, unicode.IsSpace)\n+\t}\n+}"}, {"sha": "1774a5ab42612a563b702f696e06d3c7d9fbd686", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,23 +5,24 @@\n package bytes_test\n \n import (\n-\t. \"bytes\"\n+\t\"bytes\"\n \t\"encoding/base64\"\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n )\n \n func ExampleBuffer() {\n-\tvar b Buffer // A Buffer needs no initialization.\n+\tvar b bytes.Buffer // A Buffer needs no initialization.\n \tb.Write([]byte(\"Hello \"))\n-\tb.Write([]byte(\"world!\"))\n+\tfmt.Fprintf(&b, \"world!\")\n \tb.WriteTo(os.Stdout)\n \t// Output: Hello world!\n }\n \n func ExampleBuffer_reader() {\n \t// A Buffer can turn a string or a []byte into an io.Reader.\n-\tbuf := NewBufferString(\"R29waGVycyBydWxlIQ==\")\n+\tbuf := bytes.NewBufferString(\"R29waGVycyBydWxlIQ==\")\n \tdec := base64.NewDecoder(base64.StdEncoding, buf)\n \tio.Copy(os.Stdout, dec)\n \t// Output: Gophers rule!"}, {"sha": "06e5d2e66d9fd54284a1f8c8aa3dd7110ffe715d", "filename": "libgo/go/compress/flate/copy.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+// forwardCopy is like the built-in copy function except that it always goes\n+// forward from the start, even if the dst and src overlap.\n+func forwardCopy(dst, src []byte) int {\n+\tif len(src) > len(dst) {\n+\t\tsrc = src[:len(dst)]\n+\t}\n+\tfor i, x := range src {\n+\t\tdst[i] = x\n+\t}\n+\treturn len(src)\n+}"}, {"sha": "a9281d446e9c407aeea97e710956aaf50720a123", "filename": "libgo/go/compress/flate/copy_test.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestForwardCopy(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tdst0, dst1 int\n+\t\tsrc0, src1 int\n+\t\twant       string\n+\t}{\n+\t\t{0, 9, 0, 9, \"012345678\"},\n+\t\t{0, 5, 4, 9, \"45678\"},\n+\t\t{4, 9, 0, 5, \"01230\"},\n+\t\t{1, 6, 3, 8, \"34567\"},\n+\t\t{3, 8, 1, 6, \"12121\"},\n+\t\t{0, 9, 3, 6, \"345\"},\n+\t\t{3, 6, 0, 9, \"012\"},\n+\t\t{1, 6, 0, 9, \"00000\"},\n+\t\t{0, 4, 7, 8, \"7\"},\n+\t\t{0, 1, 6, 8, \"6\"},\n+\t\t{4, 4, 6, 9, \"\"},\n+\t\t{2, 8, 6, 6, \"\"},\n+\t\t{0, 0, 0, 0, \"\"},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tb := []byte(\"0123456789\")\n+\t\tdst := b[tc.dst0:tc.dst1]\n+\t\tsrc := b[tc.src0:tc.src1]\n+\t\tn := forwardCopy(dst, src)\n+\t\tgot := string(dst[:n])\n+\t\tif got != tc.want {\n+\t\t\tt.Errorf(\"dst=b[%d:%d], src=b[%d:%d]: got %q, want %q\",\n+\t\t\t\ttc.dst0, tc.dst1, tc.src0, tc.src1, got, tc.want)\n+\t\t}\n+\t\t// Check that the bytes outside of dst[:n] were not modified.\n+\t\tfor i, x := range b {\n+\t\t\tif i >= tc.dst0 && i < tc.dst0+n {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif int(x) != '0'+i {\n+\t\t\t\tt.Errorf(\"dst=b[%d:%d], src=b[%d:%d]: copy overrun at b[%d]: got '%c', want '%c'\",\n+\t\t\t\t\ttc.dst0, tc.dst1, tc.src0, tc.src1, i, x, '0'+i)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "e0b225e298835aeb2563dbdff851c7057f5562f9", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -334,7 +334,7 @@ var deflateInflateStringTests = []deflateInflateStringTest{\n \t{\n \t\t\"../testdata/e.txt\",\n \t\t\"2.718281828...\",\n-\t\t[...]int{10013, 5065, 5096, 5115, 5093, 5079, 5079, 5079, 5079, 5079},\n+\t\t[...]int{100018, 50650, 50960, 51150, 50930, 50790, 50790, 50790, 50790, 50790},\n \t},\n \t{\n \t\t\"../testdata/Mark.Twain-Tom.Sawyer.txt\","}, {"sha": "c7ef5ff7e6015fbf8c380b4b1eba8eaf204fe68b", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -212,7 +212,7 @@ type decompressor struct {\n \tcodebits [numCodes]int\n \n \t// Output history, buffer.\n-\thist  [maxHist]byte\n+\thist  *[maxHist]byte\n \thp    int  // current output position in buffer\n \thw    int  // have written hist[0:hw] already\n \thfull bool // buffer has filled at least once\n@@ -511,51 +511,49 @@ func (f *decompressor) huffmanBlock() {\n \t\t\treturn\n \t\t}\n \n-\t\tp := f.hp - dist\n-\t\tif p < 0 {\n-\t\t\tp += len(f.hist)\n-\t\t}\n-\t\tfor i := 0; i < length; i++ {\n-\t\t\tf.hist[f.hp] = f.hist[p]\n-\t\t\tf.hp++\n-\t\t\tp++\n-\t\t\tif f.hp == len(f.hist) {\n-\t\t\t\t// After flush continue copying out of history.\n-\t\t\t\tf.copyLen = length - (i + 1)\n-\t\t\t\tf.copyDist = dist\n-\t\t\t\tf.flush((*decompressor).copyHuff)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif p == len(f.hist) {\n-\t\t\t\tp = 0\n-\t\t\t}\n+\t\tf.copyLen, f.copyDist = length, dist\n+\t\tif f.copyHist() {\n+\t\t\treturn\n \t\t}\n \t}\n \tpanic(\"unreached\")\n }\n \n-func (f *decompressor) copyHuff() {\n-\tlength := f.copyLen\n-\tdist := f.copyDist\n-\tp := f.hp - dist\n+// copyHist copies f.copyLen bytes from f.hist (f.copyDist bytes ago) to itself.\n+// It reports whether the f.hist buffer is full.\n+func (f *decompressor) copyHist() bool {\n+\tp := f.hp - f.copyDist\n \tif p < 0 {\n \t\tp += len(f.hist)\n \t}\n-\tfor i := 0; i < length; i++ {\n-\t\tf.hist[f.hp] = f.hist[p]\n-\t\tf.hp++\n-\t\tp++\n+\tfor f.copyLen > 0 {\n+\t\tn := f.copyLen\n+\t\tif x := len(f.hist) - f.hp; n > x {\n+\t\t\tn = x\n+\t\t}\n+\t\tif x := len(f.hist) - p; n > x {\n+\t\t\tn = x\n+\t\t}\n+\t\tforwardCopy(f.hist[f.hp:f.hp+n], f.hist[p:p+n])\n+\t\tp += n\n+\t\tf.hp += n\n+\t\tf.copyLen -= n\n \t\tif f.hp == len(f.hist) {\n-\t\t\tf.copyLen = length - (i + 1)\n+\t\t\t// After flush continue copying out of history.\n \t\t\tf.flush((*decompressor).copyHuff)\n-\t\t\treturn\n+\t\t\treturn true\n \t\t}\n \t\tif p == len(f.hist) {\n \t\t\tp = 0\n \t\t}\n \t}\n+\treturn false\n+}\n \n-\t// Continue processing Huffman block.\n+func (f *decompressor) copyHuff() {\n+\tif f.copyHist() {\n+\t\treturn\n+\t}\n \tf.huffmanBlock()\n }\n \n@@ -590,9 +588,9 @@ func (f *decompressor) dataBlock() {\n \tf.copyData()\n }\n \n+// copyData copies f.copyLen bytes from the underlying reader into f.hist.\n+// It pauses for reads when f.hist is full.\n func (f *decompressor) copyData() {\n-\t// Read f.dataLen bytes into history,\n-\t// pausing for reads as history fills.\n \tn := f.copyLen\n \tfor n > 0 {\n \t\tm := len(f.hist) - f.hp\n@@ -695,6 +693,7 @@ func makeReader(r io.Reader) Reader {\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n \tf.r = makeReader(r)\n+\tf.hist = new([maxHist]byte)\n \tf.step = (*decompressor).nextBlock\n \treturn &f\n }\n@@ -706,8 +705,9 @@ func NewReader(r io.Reader) io.ReadCloser {\n // to read data compressed by NewWriterDict.\n func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \tvar f decompressor\n-\tf.setDict(dict)\n \tf.r = makeReader(r)\n+\tf.hist = new([maxHist]byte)\n \tf.step = (*decompressor).nextBlock\n+\tf.setDict(dict)\n \treturn &f\n }"}, {"sha": "58431774e0e3c2e77dc536704fe81519c986c8c3", "filename": "libgo/go/compress/flate/writer_test.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func benchmarkEncoder(b *testing.B, testfile, level, n int) {\n+\tb.StopTimer()\n+\tb.SetBytes(int64(n))\n+\tbuf0, err := ioutil.ReadFile(testfiles[testfile])\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tif len(buf0) == 0 {\n+\t\tb.Fatalf(\"test file %q has no data\", testfiles[testfile])\n+\t}\n+\tbuf1 := make([]byte, n)\n+\tfor i := 0; i < n; i += len(buf0) {\n+\t\tif len(buf0) > n-i {\n+\t\t\tbuf0 = buf0[:n-i]\n+\t\t}\n+\t\tcopy(buf1[i:], buf0)\n+\t}\n+\tbuf0 = nil\n+\truntime.GC()\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tw, err := NewWriter(ioutil.Discard, level)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t\tw.Write(buf1)\n+\t\tw.Close()\n+\t}\n+}\n+\n+func BenchmarkEncodeDigitsSpeed1e4(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e4) }\n+func BenchmarkEncodeDigitsSpeed1e5(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e5) }\n+func BenchmarkEncodeDigitsSpeed1e6(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e6) }\n+func BenchmarkEncodeDigitsDefault1e4(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e4) }\n+func BenchmarkEncodeDigitsDefault1e5(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e5) }\n+func BenchmarkEncodeDigitsDefault1e6(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e6) }\n+func BenchmarkEncodeDigitsCompress1e4(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e4) }\n+func BenchmarkEncodeDigitsCompress1e5(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e5) }\n+func BenchmarkEncodeDigitsCompress1e6(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e6) }\n+func BenchmarkEncodeTwainSpeed1e4(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e4) }\n+func BenchmarkEncodeTwainSpeed1e5(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e5) }\n+func BenchmarkEncodeTwainSpeed1e6(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e6) }\n+func BenchmarkEncodeTwainDefault1e4(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e4) }\n+func BenchmarkEncodeTwainDefault1e5(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e5) }\n+func BenchmarkEncodeTwainDefault1e6(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e6) }\n+func BenchmarkEncodeTwainCompress1e4(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e4) }\n+func BenchmarkEncodeTwainCompress1e5(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e5) }\n+func BenchmarkEncodeTwainCompress1e6(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e6) }"}, {"sha": "6f155b1bdee76ee543e1cb5bf7316c11da72fbcb", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -114,11 +114,19 @@ func TestReader(t *testing.T) {\n func benchmarkDecoder(b *testing.B, n int) {\n \tb.StopTimer()\n \tb.SetBytes(int64(n))\n-\tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n-\tbuf0 = buf0[:10000]\n+\tbuf0, err := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tif len(buf0) == 0 {\n+\t\tb.Fatalf(\"test file has no data\")\n+\t}\n \tcompressed := new(bytes.Buffer)\n \tw := NewWriter(compressed, LSB, 8)\n \tfor i := 0; i < n; i += len(buf0) {\n+\t\tif len(buf0) > n-i {\n+\t\t\tbuf0 = buf0[:n-i]\n+\t\t}\n \t\tio.Copy(w, bytes.NewBuffer(buf0))\n \t}\n \tw.Close()"}, {"sha": "c6f891b4bc0231b42fec66c750499d5c3247ddcd", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -131,13 +131,14 @@ func (e *encoder) incHi() error {\n }\n \n // Write writes a compressed representation of p to e's underlying writer.\n-func (e *encoder) Write(p []byte) (int, error) {\n+func (e *encoder) Write(p []byte) (n int, err error) {\n \tif e.err != nil {\n \t\treturn 0, e.err\n \t}\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}\n+\tn = len(p)\n \tlitMask := uint32(1<<e.litWidth - 1)\n \tcode := e.savedCode\n \tif code == invalidCode {\n@@ -167,11 +168,11 @@ loop:\n \t\tcode = literal\n \t\t// Increment e.hi, the next implied code. If we run out of codes, reset\n \t\t// the encoder state (including clearing the hash table) and continue.\n-\t\tif err := e.incHi(); err != nil {\n-\t\t\tif err == errOutOfCodes {\n+\t\tif err1 := e.incHi(); err1 != nil {\n+\t\t\tif err1 == errOutOfCodes {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\te.err = err\n+\t\t\te.err = err1\n \t\t\treturn 0, e.err\n \t\t}\n \t\t// Otherwise, insert key -> e.hi into the map that e.table represents.\n@@ -184,7 +185,7 @@ loop:\n \t\t}\n \t}\n \te.savedCode = code\n-\treturn len(p), nil\n+\treturn n, nil\n }\n \n // Close closes the encoder, flushing any pending output. It does not close or"}, {"sha": "3e4e6de2114772ebd51ced82f45ca5f2342b4269", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -96,13 +96,29 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+func TestWriterReturnValues(t *testing.T) {\n+\tw := NewWriter(ioutil.Discard, LSB, 8)\n+\tn, err := w.Write([]byte(\"asdf\"))\n+\tif n != 4 || err != nil {\n+\t\tt.Errorf(\"got %d, %v, want 4, nil\", n, err)\n+\t}\n+}\n+\n func benchmarkEncoder(b *testing.B, n int) {\n \tb.StopTimer()\n \tb.SetBytes(int64(n))\n-\tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n-\tbuf0 = buf0[:10000]\n+\tbuf0, err := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tif len(buf0) == 0 {\n+\t\tb.Fatalf(\"test file has no data\")\n+\t}\n \tbuf1 := make([]byte, n)\n \tfor i := 0; i < n; i += len(buf0) {\n+\t\tif len(buf0) > n-i {\n+\t\t\tbuf0 = buf0[:n-i]\n+\t\t}\n \t\tcopy(buf1[i:], buf0)\n \t}\n \tbuf0 = nil"}, {"sha": "c97da7eccf34b333e95a02fa256ba2f4413e03ba", "filename": "libgo/go/compress/testdata/Mark.Twain-Tom.Sawyer.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -1,4 +1,4 @@\n-\ufeffThe Project Gutenberg EBook of The Adventures of Tom Sawyer, Complete\n+The Project Gutenberg EBook of The Adventures of Tom Sawyer, Complete\n by Mark Twain (Samuel Clemens)\n \n This eBook is for the use of anyone anywhere at no cost and with"}, {"sha": "5ca186f14c1591c83e5348389ae018235af354e8", "filename": "libgo/go/compress/testdata/e.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ca99bbc2a2553d83b4a34d062294b9043bbbb46b", "filename": "libgo/go/compress/testdata/pi.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d54746f4c02418971619ae83cc4a627e3b3b4cbf", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -11,7 +11,7 @@ and compress during writing.  For example, to write compressed data\n to a buffer:\n \n \tvar b bytes.Buffer\n-\tw, err := zlib.NewWriter(&b)\n+\tw := zlib.NewWriter(&b)\n \tw.Write([]byte(\"hello, world\\n\"))\n \tw.Close()\n "}, {"sha": "bbaf40a989d5c26378b8a12792ce4a80476df309", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -79,7 +79,7 @@ func Remove(h Interface, i int) interface{} {\n func up(h Interface, j int) {\n \tfor {\n \t\ti := (j - 1) / 2 // parent\n-\t\tif i == j || h.Less(i, j) {\n+\t\tif i == j || !h.Less(j, i) {\n \t\t\tbreak\n \t\t}\n \t\th.Swap(i, j)\n@@ -97,7 +97,7 @@ func down(h Interface, i, n int) {\n \t\tif j2 := j1 + 1; j2 < n && !h.Less(j1, j2) {\n \t\t\tj = j2 // = 2*i + 2  // right child\n \t\t}\n-\t\tif h.Less(i, j) {\n+\t\tif !h.Less(j, i) {\n \t\t\tbreak\n \t\t}\n \t\th.Swap(i, j)"}, {"sha": "73f33e8d2cfc7067c2a4cd83fbcb22b1a0e1ee8f", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -170,3 +170,16 @@ func TestRemove2(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkDup(b *testing.B) {\n+\tconst n = 10000\n+\th := make(myHeap, n)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor j := 0; j < n; j++ {\n+\t\t\tPush(&h, 0) // all elements are the same\n+\t\t}\n+\t\tfor h.Len() > 0 {\n+\t\t\tPop(&h)\n+\t\t}\n+\t}\n+}"}, {"sha": "e29e3a79ac7c4c6f8908b487df384109cf4e159f", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 110, "deletions": 126, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -11,201 +11,185 @@\n //\n package list\n \n-// Element is an element in the linked list.\n+// Element is an element of a linked list.\n type Element struct {\n \t// Next and previous pointers in the doubly-linked list of elements.\n-\t// The front of the list has prev = nil, and the back has next = nil.\n+\t// To simplify the implementation, internally a list l is implemented\n+\t// as a ring, such that &l.root is both the next element of the last\n+\t// list element (l.Back()) and the previous element of the first list\n+\t// element (l.Front()).\n \tnext, prev *Element\n \n \t// The list to which this element belongs.\n \tlist *List\n \n-\t// The contents of this list element.\n+\t// The value stored with this element.\n \tValue interface{}\n }\n \n // Next returns the next list element or nil.\n-func (e *Element) Next() *Element { return e.next }\n+func (e *Element) Next() *Element {\n+\tif p := e.next; p != &e.list.root {\n+\t\treturn p\n+\t}\n+\treturn nil\n+}\n \n // Prev returns the previous list element or nil.\n-func (e *Element) Prev() *Element { return e.prev }\n+func (e *Element) Prev() *Element {\n+\tif p := e.prev; p != &e.list.root {\n+\t\treturn p\n+\t}\n+\treturn nil\n+}\n \n // List represents a doubly linked list.\n // The zero value for List is an empty list ready to use.\n type List struct {\n-\tfront, back *Element\n-\tlen         int\n+\troot Element // sentinel list element, only &root, root.prev, and root.next are used\n+\tlen  int     // current list length excluding (this) sentinel element\n }\n \n-// Init initializes or clears a List.\n+// Init initializes or clears list l.\n func (l *List) Init() *List {\n-\tl.front = nil\n-\tl.back = nil\n+\tl.root.next = &l.root\n+\tl.root.prev = &l.root\n \tl.len = 0\n \treturn l\n }\n \n // New returns an initialized list.\n-func New() *List { return new(List) }\n-\n-// Front returns the first element in the list.\n-func (l *List) Front() *Element { return l.front }\n+func New() *List { return new(List).Init() }\n \n-// Back returns the last element in the list.\n-func (l *List) Back() *Element { return l.back }\n+// Len returns the number of elements of list l.\n+func (l *List) Len() int { return l.len }\n \n-// Remove removes the element from the list\n-// and returns its Value.\n-func (l *List) Remove(e *Element) interface{} {\n-\tl.remove(e)\n-\te.list = nil // do what remove does not\n-\treturn e.Value\n+// Front returns the first element of list l or nil\n+func (l *List) Front() *Element {\n+\tif l.len == 0 {\n+\t\treturn nil\n+\t}\n+\treturn l.root.next\n }\n \n-// remove the element from the list, but do not clear the Element's list field.\n-// This is so that other List methods may use remove when relocating Elements\n-// without needing to restore the list field.\n-func (l *List) remove(e *Element) {\n-\tif e.list != l {\n-\t\treturn\n-\t}\n-\tif e.prev == nil {\n-\t\tl.front = e.next\n-\t} else {\n-\t\te.prev.next = e.next\n-\t}\n-\tif e.next == nil {\n-\t\tl.back = e.prev\n-\t} else {\n-\t\te.next.prev = e.prev\n+// Back returns the last element of list l or nil.\n+func (l *List) Back() *Element {\n+\tif l.len == 0 {\n+\t\treturn nil\n \t}\n-\n-\te.prev = nil\n-\te.next = nil\n-\tl.len--\n+\treturn l.root.prev\n }\n \n-func (l *List) insertBefore(e *Element, mark *Element) {\n-\tif mark.prev == nil {\n-\t\t// new front of the list\n-\t\tl.front = e\n-\t} else {\n-\t\tmark.prev.next = e\n+// lazyInit lazily initializes a zero List value.\n+func (l *List) lazyInit() {\n+\tif l.root.next == nil {\n+\t\tl.Init()\n \t}\n-\te.prev = mark.prev\n-\tmark.prev = e\n-\te.next = mark\n-\tl.len++\n }\n \n-func (l *List) insertAfter(e *Element, mark *Element) {\n-\tif mark.next == nil {\n-\t\t// new back of the list\n-\t\tl.back = e\n-\t} else {\n-\t\tmark.next.prev = e\n-\t}\n-\te.next = mark.next\n-\tmark.next = e\n-\te.prev = mark\n+// insert inserts e after at, increments l.len, and returns e.\n+func (l *List) insert(e, at *Element) *Element {\n+\tn := at.next\n+\tat.next = e\n+\te.prev = at\n+\te.next = n\n+\tn.prev = e\n+\te.list = l\n \tl.len++\n+\treturn e\n }\n \n-func (l *List) insertFront(e *Element) {\n-\tif l.front == nil {\n-\t\t// empty list\n-\t\tl.front, l.back = e, e\n-\t\te.prev, e.next = nil, nil\n-\t\tl.len = 1\n-\t\treturn\n-\t}\n-\tl.insertBefore(e, l.front)\n+// insertValue is a convenience wrapper for insert(&Element{Value: v}, at).\n+func (l *List) insertValue(v interface{}, at *Element) *Element {\n+\treturn l.insert(&Element{Value: v}, at)\n }\n \n-func (l *List) insertBack(e *Element) {\n-\tif l.back == nil {\n-\t\t// empty list\n-\t\tl.front, l.back = e, e\n-\t\te.prev, e.next = nil, nil\n-\t\tl.len = 1\n-\t\treturn\n+// remove removes e from its list, decrements l.len, and returns e.\n+func (l *List) remove(e *Element) *Element {\n+\te.prev.next = e.next\n+\te.next.prev = e.prev\n+\te.list = nil\n+\tl.len--\n+\treturn e\n+}\n+\n+// Remove removes e from l if e is an element of list l.\n+// It returns the element value e.Value.\n+func (l *List) Remove(e *Element) interface{} {\n+\tif e.list == l {\n+\t\t// if e.list == l, l must have been initialized when e was inserted\n+\t\t// in l or l == nil (e is a zero Element) and l.remove will crash\n+\t\tl.remove(e)\n \t}\n-\tl.insertAfter(e, l.back)\n+\treturn e.Value\n }\n \n-// PushFront inserts the value at the front of the list and returns a new Element containing the value.\n-func (l *List) PushFront(value interface{}) *Element {\n-\te := &Element{nil, nil, l, value}\n-\tl.insertFront(e)\n-\treturn e\n+// Pushfront inserts a new element e with value v at the front of list l and returns e.\n+func (l *List) PushFront(v interface{}) *Element {\n+\tl.lazyInit()\n+\treturn l.insertValue(v, &l.root)\n }\n \n-// PushBack inserts the value at the back of the list and returns a new Element containing the value.\n-func (l *List) PushBack(value interface{}) *Element {\n-\te := &Element{nil, nil, l, value}\n-\tl.insertBack(e)\n-\treturn e\n+// PushBack inserts a new element e with value v at the back of list l and returns e.\n+func (l *List) PushBack(v interface{}) *Element {\n+\tl.lazyInit()\n+\treturn l.insertValue(v, l.root.prev)\n }\n \n-// InsertBefore inserts the value immediately before mark and returns a new Element containing the value.\n-func (l *List) InsertBefore(value interface{}, mark *Element) *Element {\n+// InsertBefore inserts a new element e with value v immediately before mark and returns e.\n+// If mark is not an element of l, the list is not modified.\n+func (l *List) InsertBefore(v interface{}, mark *Element) *Element {\n \tif mark.list != l {\n \t\treturn nil\n \t}\n-\te := &Element{nil, nil, l, value}\n-\tl.insertBefore(e, mark)\n-\treturn e\n+\t// see comment in List.Remove about initialization of l\n+\treturn l.insertValue(v, mark.prev)\n }\n \n-// InsertAfter inserts the value immediately after mark and returns a new Element containing the value.\n-func (l *List) InsertAfter(value interface{}, mark *Element) *Element {\n+// InsertAfter inserts a new element e with value v immediately after mark and returns e.\n+// If mark is not an element of l, the list is not modified.\n+func (l *List) InsertAfter(v interface{}, mark *Element) *Element {\n \tif mark.list != l {\n \t\treturn nil\n \t}\n-\te := &Element{nil, nil, l, value}\n-\tl.insertAfter(e, mark)\n-\treturn e\n+\t// see comment in List.Remove about initialization of l\n+\treturn l.insertValue(v, mark)\n }\n \n-// MoveToFront moves the element to the front of the list.\n+// MoveToFront moves element e to the front of list l.\n+// If e is not an element of l, the list is not modified.\n func (l *List) MoveToFront(e *Element) {\n-\tif e.list != l || l.front == e {\n+\tif e.list != l || l.root.next == e {\n \t\treturn\n \t}\n-\tl.remove(e)\n-\tl.insertFront(e)\n+\t// see comment in List.Remove about initialization of l\n+\tl.insert(l.remove(e), &l.root)\n }\n \n-// MoveToBack moves the element to the back of the list.\n+// MoveToBack moves element e to the back of list l.\n+// If e is not an element of l, the list is not modified.\n func (l *List) MoveToBack(e *Element) {\n-\tif e.list != l || l.back == e {\n+\tif e.list != l || l.root.prev == e {\n \t\treturn\n \t}\n-\tl.remove(e)\n-\tl.insertBack(e)\n+\t// see comment in List.Remove about initialization of l\n+\tl.insert(l.remove(e), l.root.prev)\n }\n \n-// Len returns the number of elements in the list.\n-func (l *List) Len() int { return l.len }\n-\n-// PushBackList inserts each element of ol at the back of the list.\n-func (l *List) PushBackList(ol *List) {\n-\tlast := ol.Back()\n-\tfor e := ol.Front(); e != nil; e = e.Next() {\n-\t\tl.PushBack(e.Value)\n-\t\tif e == last {\n-\t\t\tbreak\n-\t\t}\n+// PuchBackList inserts a copy of an other list at the back of list l.\n+// The lists l and other may be the same.\n+func (l *List) PushBackList(other *List) {\n+\tl.lazyInit()\n+\tfor i, e := other.Len(), other.Front(); i > 0; i, e = i-1, e.Next() {\n+\t\tl.insertValue(e.Value, l.root.prev)\n \t}\n }\n \n-// PushFrontList inserts each element of ol at the front of the list. The ordering of the passed list is preserved.\n-func (l *List) PushFrontList(ol *List) {\n-\tfirst := ol.Front()\n-\tfor e := ol.Back(); e != nil; e = e.Prev() {\n-\t\tl.PushFront(e.Value)\n-\t\tif e == first {\n-\t\t\tbreak\n-\t\t}\n+// PushFrontList inserts a copy of an other list at the front of list l.\n+// The lists l and other may be the same.\n+func (l *List) PushFrontList(other *List) {\n+\tl.lazyInit()\n+\tfor i, e := other.Len(), other.Back(); i > 0; i, e = i-1, e.Prev() {\n+\t\tl.insertValue(e.Value, &l.root)\n \t}\n }"}, {"sha": "b4fc77d1403546e732e46ec79062c6e6f8221604", "filename": "libgo/go/container/list/list_test.go", "status": "modified", "additions": 64, "deletions": 38, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -4,77 +4,85 @@\n \n package list\n \n-import (\n-\t\"testing\"\n-)\n+import \"testing\"\n+\n+func checkListLen(t *testing.T, l *List, len int) bool {\n+\tif n := l.Len(); n != len {\n+\t\tt.Errorf(\"l.Len() = %d, want %d\", n, len)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n \n func checkListPointers(t *testing.T, l *List, es []*Element) {\n-\tif len(es) == 0 {\n-\t\tif l.front != nil || l.back != nil {\n-\t\t\tt.Errorf(\"l.front/l.back = %v/%v should be nil/nil\", l.front, l.back)\n-\t\t}\n+\troot := &l.root\n+\n+\tif !checkListLen(t, l, len(es)) {\n \t\treturn\n \t}\n \n-\tif l.front != es[0] {\n-\t\tt.Errorf(\"l.front = %v, want %v\", l.front, es[0])\n-\t}\n-\tif last := es[len(es)-1]; l.back != last {\n-\t\tt.Errorf(\"l.back = %v, want %v\", l.back, last)\n+\t// zero length lists must be the zero value or properly initialized (sentinel circle)\n+\tif len(es) == 0 {\n+\t\tif l.root.next != nil && l.root.next != root || l.root.prev != nil && l.root.prev != root {\n+\t\t\tt.Errorf(\"l.root.next = %p, l.root.prev = %p; both should both be nil or %p\", l.root.next, l.root.prev, root)\n+\t\t}\n+\t\treturn\n \t}\n+\t// len(es) > 0\n \n+\t// check internal and external prev/next connections\n \tfor i, e := range es {\n-\t\tvar e_prev, e_next *Element = nil, nil\n+\t\tprev := root\n+\t\tPrev := (*Element)(nil)\n \t\tif i > 0 {\n-\t\t\te_prev = es[i-1]\n+\t\t\tprev = es[i-1]\n+\t\t\tPrev = prev\n+\t\t}\n+\t\tif p := e.prev; p != prev {\n+\t\t\tt.Errorf(\"elt[%d](%p).prev = %p, want %p\", i, e, p, prev)\n+\t\t}\n+\t\tif p := e.Prev(); p != Prev {\n+\t\t\tt.Errorf(\"elt[%d](%p).Prev() = %p, want %p\", i, e, p, Prev)\n \t\t}\n+\n+\t\tnext := root\n+\t\tNext := (*Element)(nil)\n \t\tif i < len(es)-1 {\n-\t\t\te_next = es[i+1]\n+\t\t\tnext = es[i+1]\n+\t\t\tNext = next\n \t\t}\n-\t\tif e.prev != e_prev {\n-\t\t\tt.Errorf(\"elt #%d (%v) has prev=%v, want %v\", i, e, e.prev, e_prev)\n+\t\tif n := e.next; n != next {\n+\t\t\tt.Errorf(\"elt[%d](%p).next = %p, want %p\", i, e, n, next)\n \t\t}\n-\t\tif e.next != e_next {\n-\t\t\tt.Errorf(\"elt #%d (%v) has next=%v, want %v\", i, e, e.next, e_next)\n+\t\tif n := e.Next(); n != Next {\n+\t\t\tt.Errorf(\"elt[%d](%p).Next() = %p, want %p\", i, e, n, Next)\n \t\t}\n \t}\n }\n \n-func checkListLen(t *testing.T, l *List, n int) {\n-\tif an := l.Len(); an != n {\n-\t\tt.Errorf(\"l.Len() = %d, want %d\", an, n)\n-\t}\n-}\n-\n func TestList(t *testing.T) {\n \tl := New()\n \tcheckListPointers(t, l, []*Element{})\n-\tcheckListLen(t, l, 0)\n \n \t// Single element list\n \te := l.PushFront(\"a\")\n-\tcheckListLen(t, l, 1)\n \tcheckListPointers(t, l, []*Element{e})\n \tl.MoveToFront(e)\n \tcheckListPointers(t, l, []*Element{e})\n \tl.MoveToBack(e)\n \tcheckListPointers(t, l, []*Element{e})\n-\tcheckListLen(t, l, 1)\n \tl.Remove(e)\n \tcheckListPointers(t, l, []*Element{})\n-\tcheckListLen(t, l, 0)\n \n \t// Bigger list\n \te2 := l.PushFront(2)\n \te1 := l.PushFront(1)\n \te3 := l.PushBack(3)\n \te4 := l.PushBack(\"banana\")\n \tcheckListPointers(t, l, []*Element{e1, e2, e3, e4})\n-\tcheckListLen(t, l, 4)\n \n \tl.Remove(e2)\n \tcheckListPointers(t, l, []*Element{e1, e3, e4})\n-\tcheckListLen(t, l, 3)\n \n \tl.MoveToFront(e3) // move from middle\n \tcheckListPointers(t, l, []*Element{e3, e1, e4})\n@@ -121,7 +129,7 @@ func TestList(t *testing.T) {\n \t\t}\n \t}\n \tif sum != 4 {\n-\t\tt.Errorf(\"sum over l.Iter() = %d, want 4\", sum)\n+\t\tt.Errorf(\"sum over l = %d, want 4\", sum)\n \t}\n \n \t// Clear all elements by iterating\n@@ -131,19 +139,18 @@ func TestList(t *testing.T) {\n \t\tl.Remove(e)\n \t}\n \tcheckListPointers(t, l, []*Element{})\n-\tcheckListLen(t, l, 0)\n }\n \n func checkList(t *testing.T, l *List, es []interface{}) {\n-\tif l.Len() != len(es) {\n-\t\tt.Errorf(\"list has len=%v, want %v\", l.Len(), len(es))\n+\tif !checkListLen(t, l, len(es)) {\n \t\treturn\n \t}\n+\n \ti := 0\n \tfor e := l.Front(); e != nil; e = e.Next() {\n \t\tle := e.Value.(int)\n \t\tif le != es[i] {\n-\t\t\tt.Errorf(\"elt #%d has value=%v, want %v\", i, le, es[i])\n+\t\t\tt.Errorf(\"elt[%d].Value = %v, want %v\", i, le, es[i])\n \t\t}\n \t\ti++\n \t}\n@@ -202,8 +209,27 @@ func TestRemove(t *testing.T) {\n \te := l.Front()\n \tl.Remove(e)\n \tcheckListPointers(t, l, []*Element{e2})\n-\tcheckListLen(t, l, 1)\n \tl.Remove(e)\n \tcheckListPointers(t, l, []*Element{e2})\n-\tcheckListLen(t, l, 1)\n+}\n+\n+func TestIssue4103(t *testing.T) {\n+\tl1 := New()\n+\tl1.PushBack(1)\n+\tl1.PushBack(2)\n+\n+\tl2 := New()\n+\tl2.PushBack(3)\n+\tl2.PushBack(4)\n+\n+\te := l1.Front()\n+\tl2.Remove(e) // l2 should not change because e is not an element of l2\n+\tif n := l2.Len(); n != 2 {\n+\t\tt.Errorf(\"l2.Len() = %d, want 2\", n)\n+\t}\n+\n+\tl1.InsertBefore(8, e)\n+\tif n := l1.Len(); n != 3 {\n+\t\tt.Errorf(\"l1.Len() = %d, want 3\", n)\n+\t}\n }"}, {"sha": "6261dd09fb5e3d230e6a7c663dbc4bb31f51c38a", "filename": "libgo/go/crypto/aes/aes_test.go", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -221,7 +221,10 @@ L:\n \t\tif tt.dec != nil {\n \t\t\tdec = make([]uint32, len(tt.dec))\n \t\t}\n-\t\texpandKey(tt.key, enc, dec)\n+\t\t// This test could only test Go version of expandKey because asm\n+\t\t// version might use different memory layout for expanded keys\n+\t\t// This is OK because we don't expose expanded keys to the outside\n+\t\texpandKeyGo(tt.key, enc, dec)\n \t\tfor j, v := range enc {\n \t\t\tif v != tt.enc[j] {\n \t\t\t\tt.Errorf(\"key %d: enc[%d] = %#x, want %#x\", i, j, v, tt.enc[j])\n@@ -352,15 +355,39 @@ func TestCipherDecrypt(t *testing.T) {\n }\n \n func BenchmarkEncrypt(b *testing.B) {\n-\tb.StopTimer()\n \ttt := encryptTests[0]\n \tc, err := NewCipher(tt.key)\n \tif err != nil {\n \t\tb.Fatal(\"NewCipher:\", err)\n \t}\n \tout := make([]byte, len(tt.in))\n-\tb.StartTimer()\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tc.Encrypt(out, tt.in)\n \t}\n }\n+\n+func BenchmarkDecrypt(b *testing.B) {\n+\ttt := encryptTests[0]\n+\tc, err := NewCipher(tt.key)\n+\tif err != nil {\n+\t\tb.Fatal(\"NewCipher:\", err)\n+\t}\n+\tout := make([]byte, len(tt.out))\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Decrypt(out, tt.out)\n+\t}\n+}\n+\n+func BenchmarkExpand(b *testing.B) {\n+\ttt := encryptTests[0]\n+\tn := len(tt.key) + 28\n+\tc := &aesCipher{make([]uint32, n), make([]uint32, n)}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\texpandKey(tt.key, c.enc, c.dec)\n+\t}\n+}"}, {"sha": "57a7e9e25f2f36abdba68c03f6fd5f011e5fd2e9", "filename": "libgo/go/crypto/aes/block.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -37,7 +37,7 @@\n package aes\n \n // Encrypt one block from src into dst, using the expanded key xk.\n-func encryptBlock(xk []uint32, dst, src []byte) {\n+func encryptBlockGo(xk []uint32, dst, src []byte) {\n \tvar s0, s1, s2, s3, t0, t1, t2, t3 uint32\n \n \ts0 = uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n@@ -82,7 +82,7 @@ func encryptBlock(xk []uint32, dst, src []byte) {\n }\n \n // Decrypt one block from src into dst, using the expanded key xk.\n-func decryptBlock(xk []uint32, dst, src []byte) {\n+func decryptBlockGo(xk []uint32, dst, src []byte) {\n \tvar s0, s1, s2, s3, t0, t1, t2, t3 uint32\n \n \ts0 = uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n@@ -139,7 +139,7 @@ func rotw(w uint32) uint32 { return w<<8 | w>>24 }\n \n // Key expansion algorithm.  See FIPS-197, Figure 11.\n // Their rcon[i] is our powx[i-1] << 24.\n-func expandKey(key []byte, enc, dec []uint32) {\n+func expandKeyGo(key []byte, enc, dec []uint32) {\n \t// Encryption key setup.\n \tvar i int\n \tnk := len(key) / 4"}, {"sha": "d931134a70ef176cc545ab03026f993ddc2c3db9", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -45,6 +45,10 @@ func NewCipher(key []byte) (cipher.Block, error) {\n \n func (c *aesCipher) BlockSize() int { return BlockSize }\n \n-func (c *aesCipher) Encrypt(dst, src []byte) { encryptBlock(c.enc, dst, src) }\n+func (c *aesCipher) Encrypt(dst, src []byte) {\n+\tencryptBlock(c.enc, dst, src)\n+}\n \n-func (c *aesCipher) Decrypt(dst, src []byte) { decryptBlock(c.dec, dst, src) }\n+func (c *aesCipher) Decrypt(dst, src []byte) {\n+\tdecryptBlock(c.dec, dst, src)\n+}"}, {"sha": "21369fc382c43462d5c6c3d20585547bf355ccec", "filename": "libgo/go/crypto/aes/cipher_asm.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build amd64\n+\n+package aes\n+\n+// defined in asm_$GOARCH.s\n+func hasAsm() bool\n+func encryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n+func decryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n+func expandKeyAsm(nr int, key *byte, enc *uint32, dec *uint32)\n+\n+var useAsm = hasAsm()\n+\n+func encryptBlock(xk []uint32, dst, src []byte) {\n+\tif useAsm {\n+\t\tencryptBlockAsm(len(xk)/4-1, &xk[0], &dst[0], &src[0])\n+\t} else {\n+\t\tencryptBlockGo(xk, dst, src)\n+\t}\n+}\n+func decryptBlock(xk []uint32, dst, src []byte) {\n+\tif useAsm {\n+\t\tdecryptBlockAsm(len(xk)/4-1, &xk[0], &dst[0], &src[0])\n+\t} else {\n+\t\tdecryptBlockGo(xk, dst, src)\n+\t}\n+}\n+func expandKey(key []byte, enc, dec []uint32) {\n+\tif useAsm {\n+\t\trounds := 10\n+\t\tswitch len(key) {\n+\t\tcase 128 / 8:\n+\t\t\trounds = 10\n+\t\tcase 192 / 8:\n+\t\t\trounds = 12\n+\t\tcase 256 / 8:\n+\t\t\trounds = 14\n+\t\t}\n+\t\texpandKeyAsm(rounds, &key[0], &enc[0], &dec[0])\n+\t} else {\n+\t\texpandKeyGo(key, enc, dec)\n+\t}\n+}"}, {"sha": "1714e0f1e5cbdba4d890998e9f0f6bc9388ac5fe", "filename": "libgo/go/crypto/aes/cipher_generic.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !amd64\n+\n+package aes\n+\n+func encryptBlock(xk []uint32, dst, src []byte) {\n+\tencryptBlockGo(xk, dst, src)\n+}\n+\n+func decryptBlock(xk []uint32, dst, src []byte) {\n+\tdecryptBlockGo(xk, dst, src)\n+}\n+\n+func expandKey(key []byte, enc, dec []uint32) {\n+\texpandKeyGo(key, enc, dec)\n+}"}, {"sha": "512d20c635c24d8e0f9d9a4741329426bf1ab98f", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -140,14 +140,16 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \tw := new(big.Int).ModInverse(s, N)\n \n \tu1 := e.Mul(e, w)\n+\tu1.Mod(u1, N)\n \tu2 := w.Mul(r, w)\n+\tu2.Mod(u2, N)\n \n \tx1, y1 := c.ScalarBaseMult(u1.Bytes())\n \tx2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes())\n-\tif x1.Cmp(x2) == 0 {\n+\tx, y := c.Add(x1, y1, x2, y2)\n+\tif x.Sign() == 0 && y.Sign() == 0 {\n \t\treturn false\n \t}\n-\tx, _ := c.Add(x1, y1, x2, y2)\n \tx.Mod(x, N)\n \treturn x.Cmp(r) == 0\n }"}, {"sha": "0c064319324e09d7b99334d16b1e3cafbd7bd48a", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 110, "deletions": 146, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,11 +5,19 @@\n package ecdsa\n \n import (\n+\t\"bufio\"\n+\t\"compress/bzip2\"\n \t\"crypto/elliptic\"\n \t\"crypto/rand\"\n \t\"crypto/sha1\"\n+\t\"crypto/sha256\"\n+\t\"crypto/sha512\"\n \t\"encoding/hex\"\n+\t\"hash\"\n+\t\"io\"\n \t\"math/big\"\n+\t\"os\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -72,156 +80,112 @@ func fromHex(s string) *big.Int {\n \treturn r\n }\n \n-// These test vectors were taken from\n-//   http://csrc.nist.gov/groups/STM/cavp/documents/dss/ecdsatestvectors.zip\n-var testVectors = []struct {\n-\tmsg    string\n-\tQx, Qy string\n-\tr, s   string\n-\tok     bool\n-}{\n-\t{\n-\t\t\"09626b45493672e48f3d1226a3aff3201960e577d33a7f72c7eb055302db8fe8ed61685dd036b554942a5737cd1512cdf811ee0c00e6dd2f08c69f08643be396e85dafda664801e772cdb7396868ac47b172245b41986aa2648cb77fbbfa562581be06651355a0c4b090f9d17d8f0ab6cced4e0c9d386cf465a516630f0231bd\",\n-\t\t\"9504b5b82d97a264d8b3735e0568decabc4b6ca275bc53cbadfc1c40\",\n-\t\t\"03426f80e477603b10dee670939623e3da91a94267fc4e51726009ed\",\n-\t\t\"81d3ac609f9575d742028dd496450a58a60eea2dcf8b9842994916e1\",\n-\t\t\"96a8c5f382c992e8f30ccce9af120b067ec1d74678fa8445232f75a5\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"96b2b6536f6df29be8567a72528aceeaccbaa66c66c534f3868ca9778b02faadb182e4ed34662e73b9d52ecbe9dc8e875fc05033c493108b380689ebf47e5b062e6a0cdb3dd34ce5fe347d92768d72f7b9b377c20aea927043b509c078ed2467d7113405d2ddd458811e6faf41c403a2a239240180f1430a6f4330df5d77de37\",\n-\t\t\"851e3100368a22478a0029353045ae40d1d8202ef4d6533cfdddafd8\",\n-\t\t\"205302ac69457dd345e86465afa72ee8c74ca97e2b0b999aec1f10c2\",\n-\t\t\"4450c2d38b697e990721aa2dbb56578d32b4f5aeb3b9072baa955ee0\",\n-\t\t\"e26d4b589166f7b4ba4b1c8fce823fa47aad22f8c9c396b8c6526e12\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"86778dbb4a068a01047a8d245d632f636c11d2ad350740b36fad90428b454ad0f120cb558d12ea5c8a23db595d87543d06d1ef489263d01ee529871eb68737efdb8ff85bc7787b61514bed85b7e01d6be209e0a4eb0db5c8df58a5c5bf706d76cb2bdf7800208639e05b89517155d11688236e6a47ed37d8e5a2b1e0adea338e\",\n-\t\t\"ad5bda09d319a717c1721acd6688d17020b31b47eef1edea57ceeffc\",\n-\t\t\"c8ce98e181770a7c9418c73c63d01494b8b80a41098c5ea50692c984\",\n-\t\t\"de5558c257ab4134e52c19d8db3b224a1899cbd08cc508ce8721d5e9\",\n-\t\t\"745db7af5a477e5046705c0a5eff1f52cb94a79d481f0c5a5e108ecd\",\n-\t\ttrue,\n-\t},\n-\t{\n-\t\t\"4bc6ef1958556686dab1e39c3700054a304cbd8f5928603dcd97fafd1f29e69394679b638f71c9344ce6a535d104803d22119f57b5f9477e253817a52afa9bfbc9811d6cc8c8be6b6566c6ef48b439bbb532abe30627548c598867f3861ba0b154dc1c3deca06eb28df8efd28258554b5179883a36fbb1eecf4f93ee19d41e3d\",\n-\t\t\"cc5eea2edf964018bdc0504a3793e4d2145142caa09a72ac5fb8d3e8\",\n-\t\t\"a48d78ae5d08aa725342773975a00d4219cf7a8029bb8cf3c17c374a\",\n-\t\t\"67b861344b4e416d4094472faf4272f6d54a497177fbc5f9ef292836\",\n-\t\t\"1d54f3fcdad795bf3b23408ecbac3e1321d1d66f2e4e3d05f41f7020\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"bb658732acbf3147729959eb7318a2058308b2739ec58907dd5b11cfa3ecf69a1752b7b7d806fe00ec402d18f96039f0b78dbb90a59c4414fb33f1f4e02e4089de4122cd93df5263a95be4d7084e2126493892816e6a5b4ed123cb705bf930c8f67af0fb4514d5769232a9b008a803af225160ce63f675bd4872c4c97b146e5e\",\n-\t\t\"6234c936e27bf141fc7534bfc0a7eedc657f91308203f1dcbd642855\",\n-\t\t\"27983d87ca785ef4892c3591ef4a944b1deb125dd58bd351034a6f84\",\n-\t\t\"e94e05b42d01d0b965ffdd6c3a97a36a771e8ea71003de76c4ecb13f\",\n-\t\t\"1dc6464ffeefbd7872a081a5926e9fc3e66d123f1784340ba17737e9\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"7c00be9123bfa2c4290be1d8bc2942c7f897d9a5b7917e3aabd97ef1aab890f148400a89abd554d19bec9d8ed911ce57b22fbcf6d30ca2115f13ce0a3f569a23bad39ee645f624c49c60dcfc11e7d2be24de9c905596d8f23624d63dc46591d1f740e46f982bfae453f107e80db23545782be23ce43708245896fc54e1ee5c43\",\n-\t\t\"9f3f037282aaf14d4772edffff331bbdda845c3f65780498cde334f1\",\n-\t\t\"8308ee5a16e3bcb721b6bc30000a0419bc1aaedd761be7f658334066\",\n-\t\t\"6381d7804a8808e3c17901e4d283b89449096a8fba993388fa11dc54\",\n-\t\t\"8e858f6b5b253686a86b757bad23658cda53115ac565abca4e3d9f57\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"cffc122a44840dc705bb37130069921be313d8bde0b66201aebc48add028ca131914ef2e705d6bedd19dc6cf9459bbb0f27cdfe3c50483808ffcdaffbeaa5f062e097180f07a40ef4ab6ed03fe07ed6bcfb8afeb42c97eafa2e8a8df469de07317c5e1494c41547478eff4d8c7d9f0f484ad90fedf6e1c35ee68fa73f1691601\",\n-\t\t\"a03b88a10d930002c7b17ca6af2fd3e88fa000edf787dc594f8d4fd4\",\n-\t\t\"e0cf7acd6ddc758e64847fe4df9915ebda2f67cdd5ec979aa57421f5\",\n-\t\t\"387b84dcf37dc343c7d2c5beb82f0bf8bd894b395a7b894565d296c1\",\n-\t\t\"4adc12ce7d20a89ce3925e10491c731b15ddb3f339610857a21b53b4\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"26e0e0cafd85b43d16255908ccfd1f061c680df75aba3081246b337495783052ba06c60f4a486c1591a4048bae11b4d7fec4f161d80bdc9a7b79d23e44433ed625eab280521a37f23dd3e1bdc5c6a6cfaa026f3c45cf703e76dab57add93fe844dd4cda67dc3bddd01f9152579e49df60969b10f09ce9372fdd806b0c7301866\",\n-\t\t\"9a8983c42f2b5a87c37a00458b5970320d247f0c8a88536440173f7d\",\n-\t\t\"15e489ec6355351361900299088cfe8359f04fe0cab78dde952be80c\",\n-\t\t\"929a21baa173d438ec9f28d6a585a2f9abcfc0a4300898668e476dc0\",\n-\t\t\"59a853f046da8318de77ff43f26fe95a92ee296fa3f7e56ce086c872\",\n-\t\ttrue,\n-\t},\n-\t{\n-\t\t\"1078eac124f48ae4f807e946971d0de3db3748dd349b14cca5c942560fb25401b2252744f18ad5e455d2d97ed5ae745f55ff509c6c8e64606afe17809affa855c4c4cdcaf6b69ab4846aa5624ed0687541aee6f2224d929685736c6a23906d974d3c257abce1a3fb8db5951b89ecb0cda92b5207d93f6618fd0f893c32cf6a6e\",\n-\t\t\"d6e55820bb62c2be97650302d59d667a411956138306bd566e5c3c2b\",\n-\t\t\"631ab0d64eaf28a71b9cbd27a7a88682a2167cee6251c44e3810894f\",\n-\t\t\"65af72bc7721eb71c2298a0eb4eed3cec96a737cc49125706308b129\",\n-\t\t\"bd5a987c78e2d51598dbd9c34a9035b0069c580edefdacee17ad892a\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"919deb1fdd831c23481dfdb2475dcbe325b04c34f82561ced3d2df0b3d749b36e255c4928973769d46de8b95f162b53cd666cad9ae145e7fcfba97919f703d864efc11eac5f260a5d920d780c52899e5d76f8fe66936ff82130761231f536e6a3d59792f784902c469aa897aabf9a0678f93446610d56d5e0981e4c8a563556b\",\n-\t\t\"269b455b1024eb92d860a420f143ac1286b8cce43031562ae7664574\",\n-\t\t\"baeb6ca274a77c44a0247e5eb12ca72bdd9a698b3f3ae69c9f1aaa57\",\n-\t\t\"cb4ec2160f04613eb0dfe4608486091a25eb12aa4dec1afe91cfb008\",\n-\t\t\"40b01d8cd06589481574f958b98ca08ade9d2a8fe31024375c01bb40\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"6e012361250dacf6166d2dd1aa7be544c3206a9d43464b3fcd90f3f8cf48d08ec099b59ba6fe7d9bdcfaf244120aed1695d8be32d1b1cd6f143982ab945d635fb48a7c76831c0460851a3d62b7209c30cd9c2abdbe3d2a5282a9fcde1a6f418dd23c409bc351896b9b34d7d3a1a63bbaf3d677e612d4a80fa14829386a64b33f\",\n-\t\t\"6d2d695efc6b43b13c14111f2109608f1020e3e03b5e21cfdbc82fcd\",\n-\t\t\"26a4859296b7e360b69cf40be7bd97ceaffa3d07743c8489fc47ca1b\",\n-\t\t\"9a8cb5f2fdc288b7183c5b32d8e546fc2ed1ca4285eeae00c8b572ad\",\n-\t\t\"8c623f357b5d0057b10cdb1a1593dab57cda7bdec9cf868157a79b97\",\n-\t\ttrue,\n-\t},\n-\t{\n-\t\t\"bf6bd7356a52b234fe24d25557200971fc803836f6fec3cade9642b13a8e7af10ab48b749de76aada9d8927f9b12f75a2c383ca7358e2566c4bb4f156fce1fd4e87ef8c8d2b6b1bdd351460feb22cdca0437ac10ca5e0abbbce9834483af20e4835386f8b1c96daaa41554ceee56730aac04f23a5c765812efa746051f396566\",\n-\t\t\"14250131b2599939cf2d6bc491be80ddfe7ad9de644387ee67de2d40\",\n-\t\t\"b5dc473b5d014cd504022043c475d3f93c319a8bdcb7262d9e741803\",\n-\t\t\"4f21642f2201278a95339a80f75cc91f8321fcb3c9462562f6cbf145\",\n-\t\t\"452a5f816ea1f75dee4fd514fa91a0d6a43622981966c59a1b371ff8\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"0eb7f4032f90f0bd3cf9473d6d9525d264d14c031a10acd31a053443ed5fe919d5ac35e0be77813071b4062f0b5fdf58ad5f637b76b0b305aec18f82441b6e607b44cdf6e0e3c7c57f24e6fd565e39430af4a6b1d979821ed0175fa03e3125506847654d7e1ae904ce1190ae38dc5919e257bdac2db142a6e7cd4da6c2e83770\",\n-\t\t\"d1f342b7790a1667370a1840255ac5bbbdc66f0bc00ae977d99260ac\",\n-\t\t\"76416cabae2de9a1000b4646338b774baabfa3db4673790771220cdb\",\n-\t\t\"bc85e3fc143d19a7271b2f9e1c04b86146073f3fab4dda1c3b1f35ca\",\n-\t\t\"9a5c70ede3c48d5f43307a0c2a4871934424a3303b815df4bb0f128e\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"5cc25348a05d85e56d4b03cec450128727bc537c66ec3a9fb613c151033b5e86878632249cba83adcefc6c1e35dcd31702929c3b57871cda5c18d1cf8f9650a25b917efaed56032e43b6fc398509f0d2997306d8f26675f3a8683b79ce17128e006aa0903b39eeb2f1001be65de0520115e6f919de902b32c38d691a69c58c92\",\n-\t\t\"7e49a7abf16a792e4c7bbc4d251820a2abd22d9f2fc252a7bf59c9a6\",\n-\t\t\"44236a8fb4791c228c26637c28ae59503a2f450d4cfb0dc42aa843b9\",\n-\t\t\"084461b4050285a1a85b2113be76a17878d849e6bc489f4d84f15cd8\",\n-\t\t\"079b5bddcc4d45de8dbdfd39f69817c7e5afa454a894d03ee1eaaac3\",\n-\t\tfalse,\n-\t},\n-\t{\n-\t\t\"1951533ce33afb58935e39e363d8497a8dd0442018fd96dff167b3b23d7206a3ee182a3194765df4768a3284e23b8696c199b4686e670d60c9d782f08794a4bccc05cffffbd1a12acd9eb1cfa01f7ebe124da66ecff4599ea7720c3be4bb7285daa1a86ebf53b042bd23208d468c1b3aa87381f8e1ad63e2b4c2ba5efcf05845\",\n-\t\t\"31945d12ebaf4d81f02be2b1768ed80784bf35cf5e2ff53438c11493\",\n-\t\t\"a62bebffac987e3b9d3ec451eb64c462cdf7b4aa0b1bbb131ceaa0a4\",\n-\t\t\"bc3c32b19e42b710bca5c6aaa128564da3ddb2726b25f33603d2af3c\",\n-\t\t\"ed1a719cc0c507edc5239d76fe50e2306c145ad252bd481da04180c0\",\n-\t\tfalse,\n-\t},\n-}\n-\n func TestVectors(t *testing.T) {\n-\tsha := sha1.New()\n+\t// This test runs the full set of NIST test vectors from\n+\t// http://csrc.nist.gov/groups/STM/cavp/documents/dss/186-3ecdsatestvectors.zip\n+\t//\n+\t// The SigVer.rsp file has been edited to remove test vectors for\n+\t// unsupported algorithms and has been compressed.\n+\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\tf, err := os.Open(\"testdata/SigVer.rsp.bz2\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tbuf := bufio.NewReader(bzip2.NewReader(f))\n+\n+\tlineNo := 1\n+\tvar h hash.Hash\n+\tvar msg []byte\n+\tvar hashed []byte\n+\tvar r, s *big.Int\n+\tpub := new(PublicKey)\n \n-\tfor i, test := range testVectors {\n-\t\tpub := PublicKey{\n-\t\t\tCurve: elliptic.P224(),\n-\t\t\tX:     fromHex(test.Qx),\n-\t\t\tY:     fromHex(test.Qy),\n+\tfor {\n+\t\tline, err := buf.ReadString('\\n')\n+\t\tif len(line) == 0 {\n+\t\t\tif err == io.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.Fatalf(\"error reading from input: %s\", err)\n \t\t}\n-\t\tmsg, _ := hex.DecodeString(test.msg)\n-\t\tsha.Reset()\n-\t\tsha.Write(msg)\n-\t\thashed := sha.Sum(nil)\n-\t\tr := fromHex(test.r)\n-\t\ts := fromHex(test.s)\n-\t\tif Verify(&pub, hashed, r, s) != test.ok {\n-\t\t\tt.Errorf(\"%d: bad result\", i)\n+\t\tlineNo++\n+\t\t// Need to remove \\r\\n from the end of the line.\n+\t\tif !strings.HasSuffix(line, \"\\r\\n\") {\n+\t\t\tt.Fatalf(\"bad line ending (expected \\\\r\\\\n) on line %d\", lineNo)\n \t\t}\n-\t\tif testing.Short() {\n-\t\t\tbreak\n+\t\tline = line[:len(line)-2]\n+\n+\t\tif len(line) == 0 || line[0] == '#' {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif line[0] == '[' {\n+\t\t\tline = line[1 : len(line)-1]\n+\t\t\tparts := strings.SplitN(line, \",\", 2)\n+\n+\t\t\tswitch parts[0] {\n+\t\t\tcase \"P-224\":\n+\t\t\t\tpub.Curve = elliptic.P224()\n+\t\t\tcase \"P-256\":\n+\t\t\t\tpub.Curve = elliptic.P256()\n+\t\t\tcase \"P-384\":\n+\t\t\t\tpub.Curve = elliptic.P384()\n+\t\t\tcase \"P-521\":\n+\t\t\t\tpub.Curve = elliptic.P521()\n+\t\t\tdefault:\n+\t\t\t\tpub.Curve = nil\n+\t\t\t}\n+\n+\t\t\tswitch parts[1] {\n+\t\t\tcase \"SHA-1\":\n+\t\t\t\th = sha1.New()\n+\t\t\tcase \"SHA-224\":\n+\t\t\t\th = sha256.New224()\n+\t\t\tcase \"SHA-256\":\n+\t\t\t\th = sha256.New()\n+\t\t\tcase \"SHA-384\":\n+\t\t\t\th = sha512.New384()\n+\t\t\tcase \"SHA-512\":\n+\t\t\t\th = sha512.New()\n+\t\t\tdefault:\n+\t\t\t\th = nil\n+\t\t\t}\n+\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif h == nil || pub.Curve == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch {\n+\t\tcase strings.HasPrefix(line, \"Msg = \"):\n+\t\t\tif msg, err = hex.DecodeString(line[6:]); err != nil {\n+\t\t\t\tt.Fatalf(\"failed to decode message on line %d: %s\", lineNo, err)\n+\t\t\t}\n+\t\tcase strings.HasPrefix(line, \"Qx = \"):\n+\t\t\tpub.X = fromHex(line[5:])\n+\t\tcase strings.HasPrefix(line, \"Qy = \"):\n+\t\t\tpub.Y = fromHex(line[5:])\n+\t\tcase strings.HasPrefix(line, \"R = \"):\n+\t\t\tr = fromHex(line[4:])\n+\t\tcase strings.HasPrefix(line, \"S = \"):\n+\t\t\ts = fromHex(line[4:])\n+\t\tcase strings.HasPrefix(line, \"Result = \"):\n+\t\t\texpected := line[9] == 'P'\n+\t\t\th.Reset()\n+\t\t\th.Write(msg)\n+\t\t\thashed := h.Sum(hashed[:0])\n+\t\t\tif Verify(pub, hashed, r, s) != expected {\n+\t\t\t\tt.Fatalf(\"incorrect result on line %d\", lineNo)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"unknown variable on line %d: %s\", lineNo, line)\n \t\t}\n \t}\n }"}, {"sha": "7a4ff6614c13374930e2eb1afe587c70d2781e8b", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -31,10 +31,10 @@ type Curve interface {\n \t// Double returns 2*(x,y)\n \tDouble(x1, y1 *big.Int) (x, y *big.Int)\n \t// ScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n-\tScalarMult(x1, y1 *big.Int, scalar []byte) (x, y *big.Int)\n-\t// ScalarBaseMult returns k*G, where G is the base point of the group and k\n-\t// is an integer in big-endian form.\n-\tScalarBaseMult(scalar []byte) (x, y *big.Int)\n+\tScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int)\n+\t// ScalarBaseMult returns k*G, where G is the base point of the group\n+\t// and k is an integer in big-endian form.\n+\tScalarBaseMult(k []byte) (x, y *big.Int)\n }\n \n // CurveParams contains the parameters of an elliptic curve and also provides\n@@ -69,9 +69,24 @@ func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {\n \treturn x3.Cmp(y2) == 0\n }\n \n+// zForAffine returns a Jacobian Z value for the affine point (x, y). If x and\n+// y are zero, it assumes that they represent the point at infinity because (0,\n+// 0) is not on the any of the curves handled here.\n+func zForAffine(x, y *big.Int) *big.Int {\n+\tz := new(big.Int)\n+\tif x.Sign() != 0 || y.Sign() != 0 {\n+\t\tz.SetInt64(1)\n+\t}\n+\treturn z\n+}\n+\n // affineFromJacobian reverses the Jacobian transform. See the comment at the\n-// top of the file.\n+// top of the file. If the point is \u221e it returns 0, 0.\n func (curve *CurveParams) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.Int) {\n+\tif z.Sign() == 0 {\n+\t\treturn new(big.Int), new(big.Int)\n+\t}\n+\n \tzinv := new(big.Int).ModInverse(z, curve.P)\n \tzinvsq := new(big.Int).Mul(zinv, zinv)\n \n@@ -84,14 +99,29 @@ func (curve *CurveParams) affineFromJacobian(x, y, z *big.Int) (xOut, yOut *big.\n }\n \n func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int) {\n-\tz := new(big.Int).SetInt64(1)\n-\treturn curve.affineFromJacobian(curve.addJacobian(x1, y1, z, x2, y2, z))\n+\tz1 := zForAffine(x1, y1)\n+\tz2 := zForAffine(x2, y2)\n+\treturn curve.affineFromJacobian(curve.addJacobian(x1, y1, z1, x2, y2, z2))\n }\n \n // addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and\n // (x2, y2, z2) and returns their sum, also in Jacobian form.\n func (curve *CurveParams) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int, *big.Int, *big.Int) {\n \t// See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl\n+\tx3, y3, z3 := new(big.Int), new(big.Int), new(big.Int)\n+\tif z1.Sign() == 0 {\n+\t\tx3.Set(x2)\n+\t\ty3.Set(y2)\n+\t\tz3.Set(z2)\n+\t\treturn x3, y3, z3\n+\t}\n+\tif z2.Sign() == 0 {\n+\t\tx3.Set(x1)\n+\t\ty3.Set(y1)\n+\t\tz3.Set(z1)\n+\t\treturn x3, y3, z3\n+\t}\n+\n \tz1z1 := new(big.Int).Mul(z1, z1)\n \tz1z1.Mod(z1z1, curve.P)\n \tz2z2 := new(big.Int).Mul(z2, z2)\n@@ -102,6 +132,7 @@ func (curve *CurveParams) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int\n \tu2 := new(big.Int).Mul(x2, z1z1)\n \tu2.Mod(u2, curve.P)\n \th := new(big.Int).Sub(u2, u1)\n+\txEqual := h.Sign() == 0\n \tif h.Sign() == -1 {\n \t\th.Add(h, curve.P)\n \t}\n@@ -119,42 +150,40 @@ func (curve *CurveParams) addJacobian(x1, y1, z1, x2, y2, z2 *big.Int) (*big.Int\n \tif r.Sign() == -1 {\n \t\tr.Add(r, curve.P)\n \t}\n+\tyEqual := r.Sign() == 0\n+\tif xEqual && yEqual {\n+\t\treturn curve.doubleJacobian(x1, y1, z1)\n+\t}\n \tr.Lsh(r, 1)\n \tv := new(big.Int).Mul(u1, i)\n \n-\tx3 := new(big.Int).Set(r)\n+\tx3.Set(r)\n \tx3.Mul(x3, x3)\n \tx3.Sub(x3, j)\n \tx3.Sub(x3, v)\n \tx3.Sub(x3, v)\n \tx3.Mod(x3, curve.P)\n \n-\ty3 := new(big.Int).Set(r)\n+\ty3.Set(r)\n \tv.Sub(v, x3)\n \ty3.Mul(y3, v)\n \ts1.Mul(s1, j)\n \ts1.Lsh(s1, 1)\n \ty3.Sub(y3, s1)\n \ty3.Mod(y3, curve.P)\n \n-\tz3 := new(big.Int).Add(z1, z2)\n+\tz3.Add(z1, z2)\n \tz3.Mul(z3, z3)\n \tz3.Sub(z3, z1z1)\n-\tif z3.Sign() == -1 {\n-\t\tz3.Add(z3, curve.P)\n-\t}\n \tz3.Sub(z3, z2z2)\n-\tif z3.Sign() == -1 {\n-\t\tz3.Add(z3, curve.P)\n-\t}\n \tz3.Mul(z3, h)\n \tz3.Mod(z3, curve.P)\n \n \treturn x3, y3, z3\n }\n \n func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int) {\n-\tz1 := new(big.Int).SetInt64(1)\n+\tz1 := zForAffine(x1, y1)\n \treturn curve.affineFromJacobian(curve.doubleJacobian(x1, y1, z1))\n }\n \n@@ -219,40 +248,19 @@ func (curve *CurveParams) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int,\n }\n \n func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int) {\n-\t// We have a slight problem in that the identity of the group (the\n-\t// point at infinity) cannot be represented in (x, y) form on a finite\n-\t// machine. Thus the standard add/double algorithm has to be tweaked\n-\t// slightly: our initial state is not the identity, but x, and we\n-\t// ignore the first true bit in |k|.  If we don't find any true bits in\n-\t// |k|, then we return nil, nil, because we cannot return the identity\n-\t// element.\n-\n \tBz := new(big.Int).SetInt64(1)\n-\tx := Bx\n-\ty := By\n-\tz := Bz\n+\tx, y, z := new(big.Int), new(big.Int), new(big.Int)\n \n-\tseenFirstTrue := false\n \tfor _, byte := range k {\n \t\tfor bitNum := 0; bitNum < 8; bitNum++ {\n-\t\t\tif seenFirstTrue {\n-\t\t\t\tx, y, z = curve.doubleJacobian(x, y, z)\n-\t\t\t}\n+\t\t\tx, y, z = curve.doubleJacobian(x, y, z)\n \t\t\tif byte&0x80 == 0x80 {\n-\t\t\t\tif !seenFirstTrue {\n-\t\t\t\t\tseenFirstTrue = true\n-\t\t\t\t} else {\n-\t\t\t\t\tx, y, z = curve.addJacobian(Bx, By, Bz, x, y, z)\n-\t\t\t\t}\n+\t\t\t\tx, y, z = curve.addJacobian(Bx, By, Bz, x, y, z)\n \t\t\t}\n \t\t\tbyte <<= 1\n \t\t}\n \t}\n \n-\tif !seenFirstTrue {\n-\t\treturn nil, nil\n-\t}\n-\n \treturn curve.affineFromJacobian(x, y, z)\n }\n "}, {"sha": "58f903966ce321f1680e08468fb084de0bf0914c", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -322,6 +322,44 @@ func TestGenericBaseMult(t *testing.T) {\n \t}\n }\n \n+func TestInfinity(t *testing.T) {\n+\ttests := []struct {\n+\t\tname  string\n+\t\tcurve Curve\n+\t}{\n+\t\t{\"p224\", P224()},\n+\t\t{\"p256\", P256()},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\tcurve := test.curve\n+\t\tx, y := curve.ScalarBaseMult(nil)\n+\t\tif x.Sign() != 0 || y.Sign() != 0 {\n+\t\t\tt.Errorf(\"%s: x^0 != \u221e\", test.name)\n+\t\t}\n+\t\tx.SetInt64(0)\n+\t\ty.SetInt64(0)\n+\n+\t\tx2, y2 := curve.Double(x, y)\n+\t\tif x2.Sign() != 0 || y2.Sign() != 0 {\n+\t\t\tt.Errorf(\"%s: 2\u221e != \u221e\", test.name)\n+\t\t}\n+\n+\t\tbaseX := curve.Params().Gx\n+\t\tbaseY := curve.Params().Gy\n+\n+\t\tx3, y3 := curve.Add(baseX, baseY, x, y)\n+\t\tif x3.Cmp(baseX) != 0 || y3.Cmp(baseY) != 0 {\n+\t\t\tt.Errorf(\"%s: x+\u221e != x\", test.name)\n+\t\t}\n+\n+\t\tx4, y4 := curve.Add(x, y, baseX, baseY)\n+\t\tif x4.Cmp(baseX) != 0 || y4.Cmp(baseY) != 0 {\n+\t\t\tt.Errorf(\"%s: \u221e+x != x\", test.name)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkBaseMult(b *testing.B) {\n \tb.ResetTimer()\n \tp224 := P224()"}, {"sha": "1f7ff3f9da6933b640fbe59741855195bc1fcaf1", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -80,10 +80,14 @@ func (p224Curve) Add(bigX1, bigY1, bigX2, bigY2 *big.Int) (x, y *big.Int) {\n \n \tp224FromBig(&x1, bigX1)\n \tp224FromBig(&y1, bigY1)\n-\tz1[0] = 1\n+\tif bigX1.Sign() != 0 || bigY1.Sign() != 0 {\n+\t\tz1[0] = 1\n+\t}\n \tp224FromBig(&x2, bigX2)\n \tp224FromBig(&y2, bigY2)\n-\tz2[0] = 1\n+\tif bigX2.Sign() != 0 || bigY2.Sign() != 0 {\n+\t\tz2[0] = 1\n+\t}\n \n \tp224AddJacobian(&x3, &y3, &z3, &x1, &y1, &z1, &x2, &y2, &z2)\n \treturn p224ToAffine(&x3, &y3, &z3)\n@@ -132,6 +136,44 @@ func (curve p224Curve) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n // exactly, making the reflections during a reduce much nicer.\n type p224FieldElement [8]uint32\n \n+// p224P is the order of the field, represented as a p224FieldElement.\n+var p224P = [8]uint32{1, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\n+// p224IsZero returns 1 if a == 0 mod p and 0 otherwise.\n+//\n+// a[i] < 2**29\n+func p224IsZero(a *p224FieldElement) uint32 {\n+\t// Since a p224FieldElement contains 224 bits there are two possible\n+\t// representations of 0: 0 and p.\n+\tvar minimal p224FieldElement\n+\tp224Contract(&minimal, a)\n+\n+\tvar isZero, isP uint32\n+\tfor i, v := range minimal {\n+\t\tisZero |= v\n+\t\tisP |= v - p224P[i]\n+\t}\n+\n+\t// If either isZero or isP is 0, then we should return 1.\n+\tisZero |= isZero >> 16\n+\tisZero |= isZero >> 8\n+\tisZero |= isZero >> 4\n+\tisZero |= isZero >> 2\n+\tisZero |= isZero >> 1\n+\n+\tisP |= isP >> 16\n+\tisP |= isP >> 8\n+\tisP |= isP >> 4\n+\tisP |= isP >> 2\n+\tisP |= isP >> 1\n+\n+\t// For isZero and isP, the LSB is 0 iff all the bits are zero.\n+\tresult := isZero & isP\n+\tresult = (^result) & 1\n+\n+\treturn result\n+}\n+\n // p224Add computes *out = a+b\n //\n // a[i] + b[i] < 2**32\n@@ -406,7 +448,7 @@ func p224Contract(out, in *p224FieldElement) {\n \t// true.\n \ttop4AllOnes := uint32(0xffffffff)\n \tfor i := 4; i < 8; i++ {\n-\t\ttop4AllOnes &= (out[i] & bottom28Bits) - 1\n+\t\ttop4AllOnes &= out[i]\n \t}\n \ttop4AllOnes |= 0xf0000000\n \t// Now we replicate any zero bits to all the bits in top4AllOnes.\n@@ -441,7 +483,7 @@ func p224Contract(out, in *p224FieldElement) {\n \tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n \n \t// If out[3] > 0xffff000 then n's MSB will be zero.\n-\tout3GT := ^uint32(int32(n<<31) >> 31)\n+\tout3GT := ^uint32(int32(n) >> 31)\n \n \tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n \tout[0] -= 1 & mask\n@@ -463,6 +505,9 @@ func p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n \tvar z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v p224FieldElement\n \tvar c p224LargeFieldElement\n \n+\tz1IsZero := p224IsZero(z1)\n+\tz2IsZero := p224IsZero(z2)\n+\n \t// Z1Z1 = Z1\u00b2\n \tp224Square(&z1z1, z1, &c)\n \t// Z2Z2 = Z2\u00b2\n@@ -480,6 +525,7 @@ func p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n \t// H = U2-U1\n \tp224Sub(&h, &u2, &u1)\n \tp224Reduce(&h)\n+\txEqual := p224IsZero(&h)\n \t// I = (2*H)\u00b2\n \tfor j := 0; j < 8; j++ {\n \t\ti[j] = h[j] << 1\n@@ -491,6 +537,11 @@ func p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n \t// r = 2*(S2-S1)\n \tp224Sub(&r, &s2, &s1)\n \tp224Reduce(&r)\n+\tyEqual := p224IsZero(&r)\n+\tif xEqual == 1 && yEqual == 1 && z1IsZero == 0 && z2IsZero == 0 {\n+\t\tp224DoubleJacobian(x3, y3, z3, x1, y1, z1)\n+\t\treturn\n+\t}\n \tfor i := 0; i < 8; i++ {\n \t\tr[i] <<= 1\n \t}\n@@ -524,6 +575,13 @@ func p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n \tp224Mul(&z1z1, &z1z1, &r, &c)\n \tp224Sub(y3, &z1z1, &s1)\n \tp224Reduce(y3)\n+\n+\tp224CopyConditional(x3, x2, z1IsZero)\n+\tp224CopyConditional(x3, x1, z2IsZero)\n+\tp224CopyConditional(y3, y2, z1IsZero)\n+\tp224CopyConditional(y3, y1, z2IsZero)\n+\tp224CopyConditional(z3, z2, z1IsZero)\n+\tp224CopyConditional(z3, z1, z2IsZero)\n }\n \n // p224DoubleJacobian computes *out = a+a.\n@@ -593,22 +651,19 @@ func p224CopyConditional(out, in *p224FieldElement, control uint32) {\n func p224ScalarMult(outX, outY, outZ, inX, inY, inZ *p224FieldElement, scalar []byte) {\n \tvar xx, yy, zz p224FieldElement\n \tfor i := 0; i < 8; i++ {\n+\t\toutX[i] = 0\n+\t\toutY[i] = 0\n \t\toutZ[i] = 0\n \t}\n \n-\tfirstBit := uint32(1)\n \tfor _, byte := range scalar {\n \t\tfor bitNum := uint(0); bitNum < 8; bitNum++ {\n \t\t\tp224DoubleJacobian(outX, outY, outZ, outX, outY, outZ)\n \t\t\tbit := uint32((byte >> (7 - bitNum)) & 1)\n \t\t\tp224AddJacobian(&xx, &yy, &zz, inX, inY, inZ, outX, outY, outZ)\n-\t\t\tp224CopyConditional(outX, inX, firstBit&bit)\n-\t\t\tp224CopyConditional(outY, inY, firstBit&bit)\n-\t\t\tp224CopyConditional(outZ, inZ, firstBit&bit)\n-\t\t\tp224CopyConditional(outX, &xx, ^firstBit&bit)\n-\t\t\tp224CopyConditional(outY, &yy, ^firstBit&bit)\n-\t\t\tp224CopyConditional(outZ, &zz, ^firstBit&bit)\n-\t\t\tfirstBit = firstBit & ^bit\n+\t\t\tp224CopyConditional(outX, &xx, bit)\n+\t\t\tp224CopyConditional(outY, &yy, bit)\n+\t\t\tp224CopyConditional(outZ, &zz, bit)\n \t\t}\n \t}\n }\n@@ -618,16 +673,8 @@ func p224ToAffine(x, y, z *p224FieldElement) (*big.Int, *big.Int) {\n \tvar zinv, zinvsq, outx, outy p224FieldElement\n \tvar tmp p224LargeFieldElement\n \n-\tisPointAtInfinity := true\n-\tfor i := 0; i < 8; i++ {\n-\t\tif z[i] != 0 {\n-\t\t\tisPointAtInfinity = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\tif isPointAtInfinity {\n-\t\treturn nil, nil\n+\tif isPointAtInfinity := p224IsZero(z); isPointAtInfinity == 1 {\n+\t\treturn new(big.Int), new(big.Int)\n \t}\n \n \tp224Invert(&zinv, z)"}, {"sha": "1a9c4ab33dd0d6cd42850796598ca648ce46c448", "filename": "libgo/go/crypto/md5/gen.go", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// This program generates md5block.go\n+// Invoke as\n+//\n+//\tgo run gen.go [-full] |gofmt >md5block.go\n+//\n+// The -full flag causes the generated code to do a full\n+// (16x) unrolling instead of a 4x unrolling.\n+\n+package main\n+\n+import (\n+\t\"flag\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/template\"\n+)\n+\n+func main() {\n+\tflag.Parse()\n+\n+\tt := template.Must(template.New(\"main\").Funcs(funcs).Parse(program))\n+\tif err := t.Execute(os.Stdout, data); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}\n+\n+type Data struct {\n+\ta, b, c, d string\n+\tShift1     []int\n+\tShift2     []int\n+\tShift3     []int\n+\tShift4     []int\n+\tTable1     []uint32\n+\tTable2     []uint32\n+\tTable3     []uint32\n+\tTable4     []uint32\n+\tFull       bool\n+}\n+\n+var funcs = template.FuncMap{\n+\t\"dup\":     dup,\n+\t\"relabel\": relabel,\n+\t\"rotate\":  rotate,\n+}\n+\n+func dup(count int, x []int) []int {\n+\tvar out []int\n+\tfor i := 0; i < count; i++ {\n+\t\tout = append(out, x...)\n+\t}\n+\treturn out\n+}\n+\n+func relabel(s string) string {\n+\treturn strings.NewReplacer(\"a\", data.a, \"b\", data.b, \"c\", data.c, \"d\", data.d).Replace(s)\n+}\n+\n+func rotate() string {\n+\tdata.a, data.b, data.c, data.d = data.d, data.a, data.b, data.c\n+\treturn \"\" // no output\n+}\n+\n+func init() {\n+\tflag.BoolVar(&data.Full, \"full\", false, \"complete unrolling\")\n+}\n+\n+var data = Data{\n+\ta:      \"a\",\n+\tb:      \"b\",\n+\tc:      \"c\",\n+\td:      \"d\",\n+\tShift1: []int{7, 12, 17, 22},\n+\tShift2: []int{5, 9, 14, 20},\n+\tShift3: []int{4, 11, 16, 23},\n+\tShift4: []int{6, 10, 15, 21},\n+\n+\t// table[i] = int((1<<32) * abs(sin(i+1 radians))).\n+\tTable1: []uint32{\n+\t\t// round 1\n+\t\t0xd76aa478,\n+\t\t0xe8c7b756,\n+\t\t0x242070db,\n+\t\t0xc1bdceee,\n+\t\t0xf57c0faf,\n+\t\t0x4787c62a,\n+\t\t0xa8304613,\n+\t\t0xfd469501,\n+\t\t0x698098d8,\n+\t\t0x8b44f7af,\n+\t\t0xffff5bb1,\n+\t\t0x895cd7be,\n+\t\t0x6b901122,\n+\t\t0xfd987193,\n+\t\t0xa679438e,\n+\t\t0x49b40821,\n+\t},\n+\tTable2: []uint32{\n+\t\t// round 2\n+\t\t0xf61e2562,\n+\t\t0xc040b340,\n+\t\t0x265e5a51,\n+\t\t0xe9b6c7aa,\n+\t\t0xd62f105d,\n+\t\t0x2441453,\n+\t\t0xd8a1e681,\n+\t\t0xe7d3fbc8,\n+\t\t0x21e1cde6,\n+\t\t0xc33707d6,\n+\t\t0xf4d50d87,\n+\t\t0x455a14ed,\n+\t\t0xa9e3e905,\n+\t\t0xfcefa3f8,\n+\t\t0x676f02d9,\n+\t\t0x8d2a4c8a,\n+\t},\n+\tTable3: []uint32{\n+\t\t// round3\n+\t\t0xfffa3942,\n+\t\t0x8771f681,\n+\t\t0x6d9d6122,\n+\t\t0xfde5380c,\n+\t\t0xa4beea44,\n+\t\t0x4bdecfa9,\n+\t\t0xf6bb4b60,\n+\t\t0xbebfbc70,\n+\t\t0x289b7ec6,\n+\t\t0xeaa127fa,\n+\t\t0xd4ef3085,\n+\t\t0x4881d05,\n+\t\t0xd9d4d039,\n+\t\t0xe6db99e5,\n+\t\t0x1fa27cf8,\n+\t\t0xc4ac5665,\n+\t},\n+\tTable4: []uint32{\n+\t\t// round 4\n+\t\t0xf4292244,\n+\t\t0x432aff97,\n+\t\t0xab9423a7,\n+\t\t0xfc93a039,\n+\t\t0x655b59c3,\n+\t\t0x8f0ccc92,\n+\t\t0xffeff47d,\n+\t\t0x85845dd1,\n+\t\t0x6fa87e4f,\n+\t\t0xfe2ce6e0,\n+\t\t0xa3014314,\n+\t\t0x4e0811a1,\n+\t\t0xf7537e82,\n+\t\t0xbd3af235,\n+\t\t0x2ad7d2bb,\n+\t\t0xeb86d391,\n+\t},\n+}\n+\n+var program = `\n+package md5\n+\n+import (\n+\t\"unsafe\"\n+\t\"runtime\"\n+)\n+\n+{{if not .Full}}\n+\tvar t1 = [...]uint32{\n+\t{{range .Table1}}{{printf \"\\t%#x,\\n\" .}}{{end}}\n+\t}\n+\t\n+\tvar t2 = [...]uint32{\n+\t{{range .Table2}}{{printf \"\\t%#x,\\n\" .}}{{end}}\n+\t}\n+\t\n+\tvar t3 = [...]uint32{\n+\t{{range .Table3}}{{printf \"\\t%#x,\\n\" .}}{{end}}\n+\t}\n+\t\n+\tvar t4 = [...]uint32{\n+\t{{range .Table4}}{{printf \"\\t%#x,\\n\" .}}{{end}}\n+\t}\n+{{end}}\n+\n+func block(dig *digest, p []byte) {\n+\ta := dig.s[0]\n+\tb := dig.s[1]\n+\tc := dig.s[2]\n+\td := dig.s[3]\n+\tvar X *[16]uint32\n+\tvar xbuf [16]uint32\n+\tfor len(p) >= chunk {\n+\t\taa, bb, cc, dd := a, b, c, d\n+\n+\t\t// This is a constant condition - it is not evaluated on each iteration.\n+\t\tif runtime.GOARCH == \"amd64\" || runtime.GOARCH == \"386\" {\n+\t\t\t// MD5 was designed so that x86 processors can just iterate\n+\t\t\t// over the block data directly as uint32s, and we generate\n+\t\t\t// less code and run 1.3x faster if we take advantage of that.\n+\t\t\t// My apologies.\n+\t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n+\t\t} else {\n+\t\t\tX = &xbuf\n+\t\t\tj := 0\n+\t\t\tfor i := 0; i < 16; i++ {\n+\t\t\t\tX[i&15] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24\n+\t\t\t\tj += 4\n+\t\t\t}\n+\t\t}\n+\n+\t\t{{if .Full}}\n+\t\t\t// Round 1.\n+\t\t\t{{range $i, $s := dup 4 .Shift1}}\n+\t\t\t\t{{index $.Table1 $i | printf \"a += (((c^d)&b)^d) + X[%d] + %d\" $i | relabel}}\n+\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t{{rotate}}\n+\t\t\t{{end}}\n+\t\n+\t\t\t// Round 2.\n+\t\t\t{{range $i, $s := dup 4 .Shift2}}\n+\t\t\t\t{{index $.Table2 $i | printf \"a += (((b^c)&d)^c) + X[(1+5*%d)&15] + %d\" $i | relabel}}\n+\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t{{rotate}}\n+\t\t\t{{end}}\n+\t\n+\t\t\t// Round 3.\n+\t\t\t{{range $i, $s := dup 4 .Shift3}}\n+\t\t\t\t{{index $.Table3 $i | printf \"a += (b^c^d) + X[(5+3*%d)&15] + %d\" $i | relabel}}\n+\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t{{rotate}}\n+\t\t\t{{end}}\n+\t\n+\t\t\t// Round 4.\n+\t\t\t{{range $i, $s := dup 4 .Shift4}}\n+\t\t\t\t{{index $.Table4 $i | printf \"a += (c^(b|^d)) + X[(7*%d)&15] + %d\" $i | relabel}}\n+\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t{{rotate}}\n+\t\t\t{{end}}\n+\t\t{{else}}\n+\t\t\t// Round 1.\n+\t\t\tfor i := uint(0); i < 16; {\n+\t\t\t\t{{range $s := .Shift1}}\n+\t\t\t\t\t{{printf \"a += (((c^d)&b)^d) + X[i&15] + t1[i&15]\" | relabel}}\n+\t\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t\ti++\n+\t\t\t\t\t{{rotate}}\n+\t\t\t\t{{end}}\n+\t\t\t}\n+\t\n+\t\t\t// Round 2.\n+\t\t\tfor i := uint(0); i < 16; {\n+\t\t\t\t{{range $s := .Shift2}}\n+\t\t\t\t\t{{printf \"a += (((b^c)&d)^c) + X[(1+5*i)&15] + t2[i&15]\" | relabel}}\n+\t\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t\ti++\n+\t\t\t\t\t{{rotate}}\n+\t\t\t\t{{end}}\n+\t\t\t}\n+\t\n+\t\t\t// Round 3.\n+\t\t\tfor i := uint(0); i < 16; {\n+\t\t\t\t{{range $s := .Shift3}}\n+\t\t\t\t\t{{printf \"a += (b^c^d) + X[(5+3*i)&15] + t3[i&15]\" | relabel}}\n+\t\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t\ti++\n+\t\t\t\t\t{{rotate}}\n+\t\t\t\t{{end}}\n+\t\t\t}\n+\t\n+\t\t\t// Round 4.\n+\t\t\tfor i := uint(0); i < 16; {\n+\t\t\t\t{{range $s := .Shift4}}\n+\t\t\t\t\t{{printf \"a += (c^(b|^d)) + X[(7*i)&15] + t4[i&15]\" | relabel}}\n+\t\t\t\t\t{{printf \"a = a<<%d | a>>(32-%d) + b\" $s $s | relabel}}\n+\t\t\t\t\ti++\n+\t\t\t\t\t{{rotate}}\n+\t\t\t\t{{end}}\n+\t\t\t}\n+\t\t{{end}}\n+\n+\t\ta += aa\n+\t\tb += bb\n+\t\tc += cc\n+\t\td += dd\n+\n+\t\tp = p[chunk:]\n+\t}\n+\n+\tdig.s[0] = a\n+\tdig.s[1] = b\n+\tdig.s[2] = c\n+\tdig.s[3] = d\n+}\n+`"}, {"sha": "825e5c8a28295fd6d1b75fbf9b527b63669f84d1", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -21,26 +21,26 @@ const Size = 16\n const BlockSize = 64\n \n const (\n-\t_Chunk = 64\n-\t_Init0 = 0x67452301\n-\t_Init1 = 0xEFCDAB89\n-\t_Init2 = 0x98BADCFE\n-\t_Init3 = 0x10325476\n+\tchunk = 64\n+\tinit0 = 0x67452301\n+\tinit1 = 0xEFCDAB89\n+\tinit2 = 0x98BADCFE\n+\tinit3 = 0x10325476\n )\n \n // digest represents the partial evaluation of a checksum.\n type digest struct {\n \ts   [4]uint32\n-\tx   [_Chunk]byte\n+\tx   [chunk]byte\n \tnx  int\n \tlen uint64\n }\n \n func (d *digest) Reset() {\n-\td.s[0] = _Init0\n-\td.s[1] = _Init1\n-\td.s[2] = _Init2\n-\td.s[3] = _Init3\n+\td.s[0] = init0\n+\td.s[1] = init1\n+\td.s[2] = init2\n+\td.s[3] = init3\n \td.nx = 0\n \td.len = 0\n }\n@@ -61,21 +61,24 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \td.len += uint64(nn)\n \tif d.nx > 0 {\n \t\tn := len(p)\n-\t\tif n > _Chunk-d.nx {\n-\t\t\tn = _Chunk - d.nx\n+\t\tif n > chunk-d.nx {\n+\t\t\tn = chunk - d.nx\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\td.x[d.nx+i] = p[i]\n \t\t}\n \t\td.nx += n\n-\t\tif d.nx == _Chunk {\n-\t\t\t_Block(d, d.x[0:])\n+\t\tif d.nx == chunk {\n+\t\t\tblock(d, d.x[0:chunk])\n \t\t\td.nx = 0\n \t\t}\n \t\tp = p[n:]\n \t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n+\tif len(p) >= chunk {\n+\t\tn := len(p) &^ (chunk - 1)\n+\t\tblock(d, p[:n])\n+\t\tp = p[n:]\n+\t}\n \tif len(p) > 0 {\n \t\td.nx = copy(d.x[:], p)\n \t}"}, {"sha": "b474a90d5a3c4a341c17b1de1d8101f623950860", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -78,3 +78,28 @@ func ExampleNew() {\n \tfmt.Printf(\"%x\", h.Sum(nil))\n \t// Output: e2c569be17396eca2a2e3c11578123ed\n }\n+\n+var bench = md5.New()\n+var buf = makeBuf()\n+\n+func makeBuf() []byte {\n+\tb := make([]byte, 8<<10)\n+\tfor i := range b {\n+\t\tb[i] = byte(i)\n+\t}\n+\treturn b\n+}\n+\n+func BenchmarkHash1K(b *testing.B) {\n+\tb.SetBytes(1024)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf[:1024])\n+\t}\n+}\n+\n+func BenchmarkHash8K(b *testing.B) {\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf)\n+\t}\n+}"}, {"sha": "5dbdf5606b1059dbcfee2964d8b2f53ee3a86131", "filename": "libgo/go/crypto/md5/md5block.go", "status": "modified", "additions": 215, "deletions": 141, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -1,172 +1,246 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MD5 block step.\n-// In its own file so that a faster assembly or C version\n-// can be substituted easily.\n-\n package md5\n \n-// table[i] = int((1<<32) * abs(sin(i+1 radians))).\n-var table = []uint32{\n-\t// round 1\n-\t0xd76aa478,\n-\t0xe8c7b756,\n-\t0x242070db,\n-\t0xc1bdceee,\n-\t0xf57c0faf,\n-\t0x4787c62a,\n-\t0xa8304613,\n-\t0xfd469501,\n-\t0x698098d8,\n-\t0x8b44f7af,\n-\t0xffff5bb1,\n-\t0x895cd7be,\n-\t0x6b901122,\n-\t0xfd987193,\n-\t0xa679438e,\n-\t0x49b40821,\n-\n-\t// round 2\n-\t0xf61e2562,\n-\t0xc040b340,\n-\t0x265e5a51,\n-\t0xe9b6c7aa,\n-\t0xd62f105d,\n-\t0x2441453,\n-\t0xd8a1e681,\n-\t0xe7d3fbc8,\n-\t0x21e1cde6,\n-\t0xc33707d6,\n-\t0xf4d50d87,\n-\t0x455a14ed,\n-\t0xa9e3e905,\n-\t0xfcefa3f8,\n-\t0x676f02d9,\n-\t0x8d2a4c8a,\n-\n-\t// round3\n-\t0xfffa3942,\n-\t0x8771f681,\n-\t0x6d9d6122,\n-\t0xfde5380c,\n-\t0xa4beea44,\n-\t0x4bdecfa9,\n-\t0xf6bb4b60,\n-\t0xbebfbc70,\n-\t0x289b7ec6,\n-\t0xeaa127fa,\n-\t0xd4ef3085,\n-\t0x4881d05,\n-\t0xd9d4d039,\n-\t0xe6db99e5,\n-\t0x1fa27cf8,\n-\t0xc4ac5665,\n-\n-\t// round 4\n-\t0xf4292244,\n-\t0x432aff97,\n-\t0xab9423a7,\n-\t0xfc93a039,\n-\t0x655b59c3,\n-\t0x8f0ccc92,\n-\t0xffeff47d,\n-\t0x85845dd1,\n-\t0x6fa87e4f,\n-\t0xfe2ce6e0,\n-\t0xa3014314,\n-\t0x4e0811a1,\n-\t0xf7537e82,\n-\t0xbd3af235,\n-\t0x2ad7d2bb,\n-\t0xeb86d391,\n-}\n+import (\n+\t\"runtime\"\n+\t\"unsafe\"\n+)\n \n-var shift1 = []uint{7, 12, 17, 22}\n-var shift2 = []uint{5, 9, 14, 20}\n-var shift3 = []uint{4, 11, 16, 23}\n-var shift4 = []uint{6, 10, 15, 21}\n-\n-func _Block(dig *digest, p []byte) int {\n+func block(dig *digest, p []byte) {\n \ta := dig.s[0]\n \tb := dig.s[1]\n \tc := dig.s[2]\n \td := dig.s[3]\n-\tn := 0\n-\tvar X [16]uint32\n-\tfor len(p) >= _Chunk {\n+\tvar X *[16]uint32\n+\tvar xbuf [16]uint32\n+\tfor len(p) >= chunk {\n \t\taa, bb, cc, dd := a, b, c, d\n \n-\t\tj := 0\n-\t\tfor i := 0; i < 16; i++ {\n-\t\t\tX[i] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24\n-\t\t\tj += 4\n+\t\t// This is a constant condition - it is not evaluated on each iteration.\n+\t\tif runtime.GOARCH == \"amd64\" || runtime.GOARCH == \"386\" {\n+\t\t\t// MD5 was designed so that x86 processors can just iterate\n+\t\t\t// over the block data directly as uint32s, and we generate\n+\t\t\t// less code and run 1.3x faster if we take advantage of that.\n+\t\t\t// My apologies.\n+\t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n+\t\t} else {\n+\t\t\tX = &xbuf\n+\t\t\tj := 0\n+\t\t\tfor i := 0; i < 16; i++ {\n+\t\t\t\tX[i&15] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24\n+\t\t\t\tj += 4\n+\t\t\t}\n \t\t}\n \n-\t\t// If this needs to be made faster in the future,\n-\t\t// the usual trick is to unroll each of these\n-\t\t// loops by a factor of 4; that lets you replace\n-\t\t// the shift[] lookups with constants and,\n-\t\t// with suitable variable renaming in each\n-\t\t// unrolled body, delete the a, b, c, d = d, a, b, c\n-\t\t// (or you can let the optimizer do the renaming).\n-\t\t//\n-\t\t// The index variables are uint so that % by a power\n-\t\t// of two can be optimized easily by a compiler.\n-\n \t\t// Round 1.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := i\n-\t\t\ts := shift1[i%4]\n-\t\t\tf := ((c ^ d) & b) ^ d\n-\t\t\ta += f + X[x] + table[i]\n-\t\t\ta = a<<s | a>>(32-s) + b\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n+\n+\t\ta += (((c ^ d) & b) ^ d) + X[0] + 3614090360\n+\t\ta = a<<7 | a>>(32-7) + b\n+\n+\t\td += (((b ^ c) & a) ^ c) + X[1] + 3905402710\n+\t\td = d<<12 | d>>(32-12) + a\n+\n+\t\tc += (((a ^ b) & d) ^ b) + X[2] + 606105819\n+\t\tc = c<<17 | c>>(32-17) + d\n+\n+\t\tb += (((d ^ a) & c) ^ a) + X[3] + 3250441966\n+\t\tb = b<<22 | b>>(32-22) + c\n+\n+\t\ta += (((c ^ d) & b) ^ d) + X[4] + 4118548399\n+\t\ta = a<<7 | a>>(32-7) + b\n+\n+\t\td += (((b ^ c) & a) ^ c) + X[5] + 1200080426\n+\t\td = d<<12 | d>>(32-12) + a\n+\n+\t\tc += (((a ^ b) & d) ^ b) + X[6] + 2821735955\n+\t\tc = c<<17 | c>>(32-17) + d\n+\n+\t\tb += (((d ^ a) & c) ^ a) + X[7] + 4249261313\n+\t\tb = b<<22 | b>>(32-22) + c\n+\n+\t\ta += (((c ^ d) & b) ^ d) + X[8] + 1770035416\n+\t\ta = a<<7 | a>>(32-7) + b\n+\n+\t\td += (((b ^ c) & a) ^ c) + X[9] + 2336552879\n+\t\td = d<<12 | d>>(32-12) + a\n+\n+\t\tc += (((a ^ b) & d) ^ b) + X[10] + 4294925233\n+\t\tc = c<<17 | c>>(32-17) + d\n+\n+\t\tb += (((d ^ a) & c) ^ a) + X[11] + 2304563134\n+\t\tb = b<<22 | b>>(32-22) + c\n+\n+\t\ta += (((c ^ d) & b) ^ d) + X[12] + 1804603682\n+\t\ta = a<<7 | a>>(32-7) + b\n+\n+\t\td += (((b ^ c) & a) ^ c) + X[13] + 4254626195\n+\t\td = d<<12 | d>>(32-12) + a\n+\n+\t\tc += (((a ^ b) & d) ^ b) + X[14] + 2792965006\n+\t\tc = c<<17 | c>>(32-17) + d\n+\n+\t\tb += (((d ^ a) & c) ^ a) + X[15] + 1236535329\n+\t\tb = b<<22 | b>>(32-22) + c\n \n \t\t// Round 2.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := (1 + 5*i) % 16\n-\t\t\ts := shift2[i%4]\n-\t\t\tg := ((b ^ c) & d) ^ c\n-\t\t\ta += g + X[x] + table[i+16]\n-\t\t\ta = a<<s | a>>(32-s) + b\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n+\n+\t\ta += (((b ^ c) & d) ^ c) + X[(1+5*0)&15] + 4129170786\n+\t\ta = a<<5 | a>>(32-5) + b\n+\n+\t\td += (((a ^ b) & c) ^ b) + X[(1+5*1)&15] + 3225465664\n+\t\td = d<<9 | d>>(32-9) + a\n+\n+\t\tc += (((d ^ a) & b) ^ a) + X[(1+5*2)&15] + 643717713\n+\t\tc = c<<14 | c>>(32-14) + d\n+\n+\t\tb += (((c ^ d) & a) ^ d) + X[(1+5*3)&15] + 3921069994\n+\t\tb = b<<20 | b>>(32-20) + c\n+\n+\t\ta += (((b ^ c) & d) ^ c) + X[(1+5*4)&15] + 3593408605\n+\t\ta = a<<5 | a>>(32-5) + b\n+\n+\t\td += (((a ^ b) & c) ^ b) + X[(1+5*5)&15] + 38016083\n+\t\td = d<<9 | d>>(32-9) + a\n+\n+\t\tc += (((d ^ a) & b) ^ a) + X[(1+5*6)&15] + 3634488961\n+\t\tc = c<<14 | c>>(32-14) + d\n+\n+\t\tb += (((c ^ d) & a) ^ d) + X[(1+5*7)&15] + 3889429448\n+\t\tb = b<<20 | b>>(32-20) + c\n+\n+\t\ta += (((b ^ c) & d) ^ c) + X[(1+5*8)&15] + 568446438\n+\t\ta = a<<5 | a>>(32-5) + b\n+\n+\t\td += (((a ^ b) & c) ^ b) + X[(1+5*9)&15] + 3275163606\n+\t\td = d<<9 | d>>(32-9) + a\n+\n+\t\tc += (((d ^ a) & b) ^ a) + X[(1+5*10)&15] + 4107603335\n+\t\tc = c<<14 | c>>(32-14) + d\n+\n+\t\tb += (((c ^ d) & a) ^ d) + X[(1+5*11)&15] + 1163531501\n+\t\tb = b<<20 | b>>(32-20) + c\n+\n+\t\ta += (((b ^ c) & d) ^ c) + X[(1+5*12)&15] + 2850285829\n+\t\ta = a<<5 | a>>(32-5) + b\n+\n+\t\td += (((a ^ b) & c) ^ b) + X[(1+5*13)&15] + 4243563512\n+\t\td = d<<9 | d>>(32-9) + a\n+\n+\t\tc += (((d ^ a) & b) ^ a) + X[(1+5*14)&15] + 1735328473\n+\t\tc = c<<14 | c>>(32-14) + d\n+\n+\t\tb += (((c ^ d) & a) ^ d) + X[(1+5*15)&15] + 2368359562\n+\t\tb = b<<20 | b>>(32-20) + c\n \n \t\t// Round 3.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := (5 + 3*i) % 16\n-\t\t\ts := shift3[i%4]\n-\t\t\th := b ^ c ^ d\n-\t\t\ta += h + X[x] + table[i+32]\n-\t\t\ta = a<<s | a>>(32-s) + b\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n+\n+\t\ta += (b ^ c ^ d) + X[(5+3*0)&15] + 4294588738\n+\t\ta = a<<4 | a>>(32-4) + b\n+\n+\t\td += (a ^ b ^ c) + X[(5+3*1)&15] + 2272392833\n+\t\td = d<<11 | d>>(32-11) + a\n+\n+\t\tc += (d ^ a ^ b) + X[(5+3*2)&15] + 1839030562\n+\t\tc = c<<16 | c>>(32-16) + d\n+\n+\t\tb += (c ^ d ^ a) + X[(5+3*3)&15] + 4259657740\n+\t\tb = b<<23 | b>>(32-23) + c\n+\n+\t\ta += (b ^ c ^ d) + X[(5+3*4)&15] + 2763975236\n+\t\ta = a<<4 | a>>(32-4) + b\n+\n+\t\td += (a ^ b ^ c) + X[(5+3*5)&15] + 1272893353\n+\t\td = d<<11 | d>>(32-11) + a\n+\n+\t\tc += (d ^ a ^ b) + X[(5+3*6)&15] + 4139469664\n+\t\tc = c<<16 | c>>(32-16) + d\n+\n+\t\tb += (c ^ d ^ a) + X[(5+3*7)&15] + 3200236656\n+\t\tb = b<<23 | b>>(32-23) + c\n+\n+\t\ta += (b ^ c ^ d) + X[(5+3*8)&15] + 681279174\n+\t\ta = a<<4 | a>>(32-4) + b\n+\n+\t\td += (a ^ b ^ c) + X[(5+3*9)&15] + 3936430074\n+\t\td = d<<11 | d>>(32-11) + a\n+\n+\t\tc += (d ^ a ^ b) + X[(5+3*10)&15] + 3572445317\n+\t\tc = c<<16 | c>>(32-16) + d\n+\n+\t\tb += (c ^ d ^ a) + X[(5+3*11)&15] + 76029189\n+\t\tb = b<<23 | b>>(32-23) + c\n+\n+\t\ta += (b ^ c ^ d) + X[(5+3*12)&15] + 3654602809\n+\t\ta = a<<4 | a>>(32-4) + b\n+\n+\t\td += (a ^ b ^ c) + X[(5+3*13)&15] + 3873151461\n+\t\td = d<<11 | d>>(32-11) + a\n+\n+\t\tc += (d ^ a ^ b) + X[(5+3*14)&15] + 530742520\n+\t\tc = c<<16 | c>>(32-16) + d\n+\n+\t\tb += (c ^ d ^ a) + X[(5+3*15)&15] + 3299628645\n+\t\tb = b<<23 | b>>(32-23) + c\n \n \t\t// Round 4.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := (7 * i) % 16\n-\t\t\ts := shift4[i%4]\n-\t\t\tj := c ^ (b | ^d)\n-\t\t\ta += j + X[x] + table[i+48]\n-\t\t\ta = a<<s | a>>(32-s) + b\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n+\n+\t\ta += (c ^ (b | ^d)) + X[(7*0)&15] + 4096336452\n+\t\ta = a<<6 | a>>(32-6) + b\n+\n+\t\td += (b ^ (a | ^c)) + X[(7*1)&15] + 1126891415\n+\t\td = d<<10 | d>>(32-10) + a\n+\n+\t\tc += (a ^ (d | ^b)) + X[(7*2)&15] + 2878612391\n+\t\tc = c<<15 | c>>(32-15) + d\n+\n+\t\tb += (d ^ (c | ^a)) + X[(7*3)&15] + 4237533241\n+\t\tb = b<<21 | b>>(32-21) + c\n+\n+\t\ta += (c ^ (b | ^d)) + X[(7*4)&15] + 1700485571\n+\t\ta = a<<6 | a>>(32-6) + b\n+\n+\t\td += (b ^ (a | ^c)) + X[(7*5)&15] + 2399980690\n+\t\td = d<<10 | d>>(32-10) + a\n+\n+\t\tc += (a ^ (d | ^b)) + X[(7*6)&15] + 4293915773\n+\t\tc = c<<15 | c>>(32-15) + d\n+\n+\t\tb += (d ^ (c | ^a)) + X[(7*7)&15] + 2240044497\n+\t\tb = b<<21 | b>>(32-21) + c\n+\n+\t\ta += (c ^ (b | ^d)) + X[(7*8)&15] + 1873313359\n+\t\ta = a<<6 | a>>(32-6) + b\n+\n+\t\td += (b ^ (a | ^c)) + X[(7*9)&15] + 4264355552\n+\t\td = d<<10 | d>>(32-10) + a\n+\n+\t\tc += (a ^ (d | ^b)) + X[(7*10)&15] + 2734768916\n+\t\tc = c<<15 | c>>(32-15) + d\n+\n+\t\tb += (d ^ (c | ^a)) + X[(7*11)&15] + 1309151649\n+\t\tb = b<<21 | b>>(32-21) + c\n+\n+\t\ta += (c ^ (b | ^d)) + X[(7*12)&15] + 4149444226\n+\t\ta = a<<6 | a>>(32-6) + b\n+\n+\t\td += (b ^ (a | ^c)) + X[(7*13)&15] + 3174756917\n+\t\td = d<<10 | d>>(32-10) + a\n+\n+\t\tc += (a ^ (d | ^b)) + X[(7*14)&15] + 718787259\n+\t\tc = c<<15 | c>>(32-15) + d\n+\n+\t\tb += (d ^ (c | ^a)) + X[(7*15)&15] + 3951481745\n+\t\tb = b<<21 | b>>(32-21) + c\n \n \t\ta += aa\n \t\tb += bb\n \t\tc += cc\n \t\td += dd\n \n-\t\tp = p[_Chunk:]\n-\t\tn += _Chunk\n+\t\tp = p[chunk:]\n \t}\n \n \tdig.s[0] = a\n \tdig.s[1] = b\n \tdig.s[2] = c\n \tdig.s[3] = d\n-\treturn n\n }"}, {"sha": "18f482472d3bd03e4e43a29f73289a0f55ff6ee3", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux netbsd openbsd\n+// +build darwin freebsd linux netbsd openbsd plan9\n \n // Unix cryptographically secure pseudorandom number\n // generator.\n@@ -15,14 +15,21 @@ import (\n \t\"crypto/cipher\"\n \t\"io\"\n \t\"os\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n )\n \n // Easy implementation: read from /dev/urandom.\n // This is sufficient on Linux, OS X, and FreeBSD.\n \n-func init() { Reader = &devReader{name: \"/dev/urandom\"} }\n+func init() {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tReader = newReader(nil)\n+\t} else {\n+\t\tReader = &devReader{name: \"/dev/urandom\"}\n+\t}\n+}\n \n // A devReader satisfies reads by reading the file named name.\n type devReader struct {\n@@ -39,14 +46,17 @@ func (r *devReader) Read(b []byte) (n int, err error) {\n \t\tif f == nil {\n \t\t\treturn 0, err\n \t\t}\n-\t\tr.f = bufio.NewReader(f)\n+\t\tif runtime.GOOS == \"plan9\" {\n+\t\t\tr.f = f\n+\t\t} else {\n+\t\t\tr.f = bufio.NewReader(f)\n+\t\t}\n \t}\n \treturn r.f.Read(b)\n }\n \n // Alternate pseudo-random implementation for use on\n-// systems without a reliable /dev/urandom.  So far we\n-// haven't needed it.\n+// systems without a reliable /dev/urandom.\n \n // newReader returns a new pseudorandom generator that\n // seeds itself by reading from entropy.  If entropy == nil,"}, {"sha": "28ca5d73b39cfb715de8620c7dc8dcc3f6f5d32c", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -19,6 +19,9 @@ import (\n // WARNING: use of this function to encrypt plaintexts other than session keys\n // is dangerous. Use RSA OAEP in new protocols.\n func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error) {\n+\tif err := checkPub(pub); err != nil {\n+\t\treturn nil, err\n+\t}\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-11 {\n \t\terr = ErrMessageTooLong\n@@ -47,6 +50,9 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n // DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\n // If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error) {\n+\tif err := checkPub(&priv.PublicKey); err != nil {\n+\t\treturn nil, err\n+\t}\n \tvalid, out, err := decryptPKCS1v15(rand, priv, ciphertext)\n \tif err == nil && valid == 0 {\n \t\terr = ErrDecryption\n@@ -69,6 +75,9 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [\n // Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n // (Crypto '98).\n func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err error) {\n+\tif err := checkPub(&priv.PublicKey); err != nil {\n+\t\treturn err\n+\t}\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k-(len(key)+3+8) < 0 {\n \t\terr = ErrDecryption\n@@ -238,11 +247,11 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err error) {\n \thashLen = hash.Size()\n \tif inLen != hashLen {\n-\t\treturn 0, nil, errors.New(\"input must be hashed message\")\n+\t\treturn 0, nil, errors.New(\"crypto/rsa: input must be hashed message\")\n \t}\n \tprefix, ok := hashPrefixes[hash]\n \tif !ok {\n-\t\treturn 0, nil, errors.New(\"unsupported hash function\")\n+\t\treturn 0, nil, errors.New(\"crypto/rsa: unsupported hash function\")\n \t}\n \treturn\n }"}, {"sha": "7faae67430441771092cd5fc4d25e41c45bedfe7", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -25,6 +25,30 @@ type PublicKey struct {\n \tE int      // public exponent\n }\n \n+var (\n+\terrPublicModulus       = errors.New(\"crypto/rsa: missing public modulus\")\n+\terrPublicExponentSmall = errors.New(\"crypto/rsa: public exponent too small\")\n+\terrPublicExponentLarge = errors.New(\"crypto/rsa: public exponent too large\")\n+)\n+\n+// checkPub sanity checks the public key before we use it.\n+// We require pub.E to fit into a 32-bit integer so that we\n+// do not have different behavior depending on whether\n+// int is 32 or 64 bits. See also\n+// http://www.imperialviolet.org/2012/03/16/rsae.html.\n+func checkPub(pub *PublicKey) error {\n+\tif pub.N == nil {\n+\t\treturn errPublicModulus\n+\t}\n+\tif pub.E < 2 {\n+\t\treturn errPublicExponentSmall\n+\t}\n+\tif pub.E > 1<<31-1 {\n+\t\treturn errPublicExponentLarge\n+\t}\n+\treturn nil\n+}\n+\n // A PrivateKey represents an RSA key\n type PrivateKey struct {\n \tPublicKey            // public part.\n@@ -57,13 +81,17 @@ type CRTValue struct {\n // Validate performs basic sanity checks on the key.\n // It returns nil if the key is valid, or else an error describing a problem.\n func (priv *PrivateKey) Validate() error {\n+\tif err := checkPub(&priv.PublicKey); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Check that the prime factors are actually prime. Note that this is\n \t// just a sanity check. Since the random witnesses chosen by\n \t// ProbablyPrime are deterministic, given the candidate number, it's\n \t// easy for an attack to generate composites that pass this test.\n \tfor _, prime := range priv.Primes {\n \t\tif !prime.ProbablyPrime(20) {\n-\t\t\treturn errors.New(\"prime factor is composite\")\n+\t\t\treturn errors.New(\"crypto/rsa: prime factor is composite\")\n \t\t}\n \t}\n \n@@ -73,27 +101,23 @@ func (priv *PrivateKey) Validate() error {\n \t\tmodulus.Mul(modulus, prime)\n \t}\n \tif modulus.Cmp(priv.N) != 0 {\n-\t\treturn errors.New(\"invalid modulus\")\n+\t\treturn errors.New(\"crypto/rsa: invalid modulus\")\n \t}\n-\t// Check that e and totient(\u03a0primes) are coprime.\n-\ttotient := new(big.Int).Set(bigOne)\n+\n+\t// Check that de \u2261 1 mod p-1, for each prime.\n+\t// This implies that e is coprime to each p-1 as e has a multiplicative\n+\t// inverse. Therefore e is coprime to lcm(p-1,q-1,r-1,...) =\n+\t// exponent(\u2124/n\u2124). It also implies that a^de \u2261 a mod p as a^(p-1) \u2261 1\n+\t// mod p. Thus a^de \u2261 a mod n for all a coprime to n, as required.\n+\tcongruence := new(big.Int)\n+\tde := new(big.Int).SetInt64(int64(priv.E))\n+\tde.Mul(de, priv.D)\n \tfor _, prime := range priv.Primes {\n \t\tpminus1 := new(big.Int).Sub(prime, bigOne)\n-\t\ttotient.Mul(totient, pminus1)\n-\t}\n-\te := big.NewInt(int64(priv.E))\n-\tgcd := new(big.Int)\n-\tx := new(big.Int)\n-\ty := new(big.Int)\n-\tgcd.GCD(x, y, totient, e)\n-\tif gcd.Cmp(bigOne) != 0 {\n-\t\treturn errors.New(\"invalid public exponent E\")\n-\t}\n-\t// Check that de \u2261 1 (mod totient(\u03a0primes))\n-\tde := new(big.Int).Mul(priv.D, e)\n-\tde.Mod(de, totient)\n-\tif de.Cmp(bigOne) != 0 {\n-\t\treturn errors.New(\"invalid private exponent D\")\n+\t\tcongruence.Mod(de, pminus1)\n+\t\tif congruence.Cmp(bigOne) != 0 {\n+\t\t\treturn errors.New(\"crypto/rsa: invalid exponents\")\n+\t\t}\n \t}\n \treturn nil\n }\n@@ -118,7 +142,7 @@ func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *Priva\n \tpriv.E = 65537\n \n \tif nprimes < 2 {\n-\t\treturn nil, errors.New(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n+\t\treturn nil, errors.New(\"crypto/rsa: GenerateMultiPrimeKey: nprimes must be >= 2\")\n \t}\n \n \tprimes := make([]*big.Int, nprimes)\n@@ -220,6 +244,9 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n // The message must be no longer than the length of the public modulus less\n // twice the hash length plus 2.\n func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error) {\n+\tif err := checkPub(pub); err != nil {\n+\t\treturn nil, err\n+\t}\n \thash.Reset()\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-2*hash.Size()-2 {\n@@ -406,6 +433,9 @@ func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err er\n // DecryptOAEP decrypts ciphertext using RSA-OAEP.\n // If random != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\n func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err error) {\n+\tif err := checkPub(&priv.PublicKey); err != nil {\n+\t\treturn nil, err\n+\t}\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||\n \t\tk < hash.Size()*2+2 {"}, {"sha": "62bbdc4aec3a2113d33ee3c93a7f3ce0c484587a", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -50,6 +50,24 @@ func Test4PrimeKeyGeneration(t *testing.T) {\n \ttestKeyBasics(t, priv)\n }\n \n+func TestGnuTLSKey(t *testing.T) {\n+\t// This is a key generated by `certtool --generate-privkey --bits 128`.\n+\t// It's such that de \u2262 1 mod \u03c6(n), but is congruent mod the order of\n+\t// the group.\n+\tpriv := &PrivateKey{\n+\t\tPublicKey: PublicKey{\n+\t\t\tN: fromBase10(\"290684273230919398108010081414538931343\"),\n+\t\t\tE: 65537,\n+\t\t},\n+\t\tD: fromBase10(\"31877380284581499213530787347443987241\"),\n+\t\tPrimes: []*big.Int{\n+\t\t\tfromBase10(\"16775196964030542637\"),\n+\t\t\tfromBase10(\"17328218193455850539\"),\n+\t\t},\n+\t}\n+\ttestKeyBasics(t, priv)\n+}\n+\n func testKeyBasics(t *testing.T, priv *PrivateKey) {\n \tif err := priv.Validate(); err != nil {\n \t\tt.Errorf(\"Validate() failed: %s\", err)"}, {"sha": "7cfde47dc07dd4353ddb5e4d34cbcd1ffa71e7b9", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -21,28 +21,28 @@ const Size = 20\n const BlockSize = 64\n \n const (\n-\t_Chunk = 64\n-\t_Init0 = 0x67452301\n-\t_Init1 = 0xEFCDAB89\n-\t_Init2 = 0x98BADCFE\n-\t_Init3 = 0x10325476\n-\t_Init4 = 0xC3D2E1F0\n+\tchunk = 64\n+\tinit0 = 0x67452301\n+\tinit1 = 0xEFCDAB89\n+\tinit2 = 0x98BADCFE\n+\tinit3 = 0x10325476\n+\tinit4 = 0xC3D2E1F0\n )\n \n // digest represents the partial evaluation of a checksum.\n type digest struct {\n \th   [5]uint32\n-\tx   [_Chunk]byte\n+\tx   [chunk]byte\n \tnx  int\n \tlen uint64\n }\n \n func (d *digest) Reset() {\n-\td.h[0] = _Init0\n-\td.h[1] = _Init1\n-\td.h[2] = _Init2\n-\td.h[3] = _Init3\n-\td.h[4] = _Init4\n+\td.h[0] = init0\n+\td.h[1] = init1\n+\td.h[2] = init2\n+\td.h[3] = init3\n+\td.h[4] = init4\n \td.nx = 0\n \td.len = 0\n }\n@@ -63,21 +63,24 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \td.len += uint64(nn)\n \tif d.nx > 0 {\n \t\tn := len(p)\n-\t\tif n > _Chunk-d.nx {\n-\t\t\tn = _Chunk - d.nx\n+\t\tif n > chunk-d.nx {\n+\t\t\tn = chunk - d.nx\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\td.x[d.nx+i] = p[i]\n \t\t}\n \t\td.nx += n\n-\t\tif d.nx == _Chunk {\n-\t\t\t_Block(d, d.x[0:])\n+\t\tif d.nx == chunk {\n+\t\t\tblock(d, d.x[0:])\n \t\t\td.nx = 0\n \t\t}\n \t\tp = p[n:]\n \t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n+\tif len(p) >= chunk {\n+\t\tn := len(p) &^ (chunk - 1)\n+\t\tblock(d, p[:n])\n+\t\tp = p[n:]\n+\t}\n \tif len(p) > 0 {\n \t\td.nx = copy(d.x[:], p)\n \t}"}, {"sha": "e3d03e52a31a0b06e307907b3e437986aaa4188a", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -79,3 +79,28 @@ func ExampleNew() {\n \tfmt.Printf(\"% x\", h.Sum(nil))\n \t// Output: 59 7f 6a 54 00 10 f9 4c 15 d7 18 06 a9 9a 2c 87 10 e7 47 bd\n }\n+\n+var bench = sha1.New()\n+var buf = makeBuf()\n+\n+func makeBuf() []byte {\n+\tb := make([]byte, 8<<10)\n+\tfor i := range b {\n+\t\tb[i] = byte(i)\n+\t}\n+\treturn b\n+}\n+\n+func BenchmarkHash1K(b *testing.B) {\n+\tb.SetBytes(1024)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf[:1024])\n+\t}\n+}\n+\n+func BenchmarkHash8K(b *testing.B) {\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf)\n+\t}\n+}"}, {"sha": "b9fe21d9e3debf3c6bc925e81b276242d086eebb", "filename": "libgo/go/crypto/sha1/sha1block.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -15,12 +15,11 @@ const (\n \t_K3 = 0xCA62C1D6\n )\n \n-func _Block(dig *digest, p []byte) int {\n+func block(dig *digest, p []byte) {\n \tvar w [80]uint32\n \n-\tn := 0\n \th0, h1, h2, h3, h4 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4]\n-\tfor len(p) >= _Chunk {\n+\tfor len(p) >= chunk {\n \t\t// Can interlace the computation of w with the\n \t\t// rounds below if needed for speed.\n \t\tfor i := 0; i < 16; i++ {\n@@ -72,10 +71,8 @@ func _Block(dig *digest, p []byte) int {\n \t\th3 += d\n \t\th4 += e\n \n-\t\tp = p[_Chunk:]\n-\t\tn += _Chunk\n+\t\tp = p[chunk:]\n \t}\n \n \tdig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4] = h0, h1, h2, h3, h4\n-\treturn n\n }"}, {"sha": "dc0e18f50df2d4567b97211c6bff2f82c81beb57", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -26,53 +26,53 @@ const Size224 = 28\n const BlockSize = 64\n \n const (\n-\t_Chunk     = 64\n-\t_Init0     = 0x6A09E667\n-\t_Init1     = 0xBB67AE85\n-\t_Init2     = 0x3C6EF372\n-\t_Init3     = 0xA54FF53A\n-\t_Init4     = 0x510E527F\n-\t_Init5     = 0x9B05688C\n-\t_Init6     = 0x1F83D9AB\n-\t_Init7     = 0x5BE0CD19\n-\t_Init0_224 = 0xC1059ED8\n-\t_Init1_224 = 0x367CD507\n-\t_Init2_224 = 0x3070DD17\n-\t_Init3_224 = 0xF70E5939\n-\t_Init4_224 = 0xFFC00B31\n-\t_Init5_224 = 0x68581511\n-\t_Init6_224 = 0x64F98FA7\n-\t_Init7_224 = 0xBEFA4FA4\n+\tchunk     = 64\n+\tinit0     = 0x6A09E667\n+\tinit1     = 0xBB67AE85\n+\tinit2     = 0x3C6EF372\n+\tinit3     = 0xA54FF53A\n+\tinit4     = 0x510E527F\n+\tinit5     = 0x9B05688C\n+\tinit6     = 0x1F83D9AB\n+\tinit7     = 0x5BE0CD19\n+\tinit0_224 = 0xC1059ED8\n+\tinit1_224 = 0x367CD507\n+\tinit2_224 = 0x3070DD17\n+\tinit3_224 = 0xF70E5939\n+\tinit4_224 = 0xFFC00B31\n+\tinit5_224 = 0x68581511\n+\tinit6_224 = 0x64F98FA7\n+\tinit7_224 = 0xBEFA4FA4\n )\n \n // digest represents the partial evaluation of a checksum.\n type digest struct {\n \th     [8]uint32\n-\tx     [_Chunk]byte\n+\tx     [chunk]byte\n \tnx    int\n \tlen   uint64\n \tis224 bool // mark if this digest is SHA-224\n }\n \n func (d *digest) Reset() {\n \tif !d.is224 {\n-\t\td.h[0] = _Init0\n-\t\td.h[1] = _Init1\n-\t\td.h[2] = _Init2\n-\t\td.h[3] = _Init3\n-\t\td.h[4] = _Init4\n-\t\td.h[5] = _Init5\n-\t\td.h[6] = _Init6\n-\t\td.h[7] = _Init7\n+\t\td.h[0] = init0\n+\t\td.h[1] = init1\n+\t\td.h[2] = init2\n+\t\td.h[3] = init3\n+\t\td.h[4] = init4\n+\t\td.h[5] = init5\n+\t\td.h[6] = init6\n+\t\td.h[7] = init7\n \t} else {\n-\t\td.h[0] = _Init0_224\n-\t\td.h[1] = _Init1_224\n-\t\td.h[2] = _Init2_224\n-\t\td.h[3] = _Init3_224\n-\t\td.h[4] = _Init4_224\n-\t\td.h[5] = _Init5_224\n-\t\td.h[6] = _Init6_224\n-\t\td.h[7] = _Init7_224\n+\t\td.h[0] = init0_224\n+\t\td.h[1] = init1_224\n+\t\td.h[2] = init2_224\n+\t\td.h[3] = init3_224\n+\t\td.h[4] = init4_224\n+\t\td.h[5] = init5_224\n+\t\td.h[6] = init6_224\n+\t\td.h[7] = init7_224\n \t}\n \td.nx = 0\n \td.len = 0\n@@ -107,21 +107,24 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \td.len += uint64(nn)\n \tif d.nx > 0 {\n \t\tn := len(p)\n-\t\tif n > _Chunk-d.nx {\n-\t\t\tn = _Chunk - d.nx\n+\t\tif n > chunk-d.nx {\n+\t\t\tn = chunk - d.nx\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\td.x[d.nx+i] = p[i]\n \t\t}\n \t\td.nx += n\n-\t\tif d.nx == _Chunk {\n-\t\t\t_Block(d, d.x[0:])\n+\t\tif d.nx == chunk {\n+\t\t\tblock(d, d.x[0:])\n \t\t\td.nx = 0\n \t\t}\n \t\tp = p[n:]\n \t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n+\tif len(p) >= chunk {\n+\t\tn := len(p) &^ (chunk - 1)\n+\t\tblock(d, p[:n])\n+\t\tp = p[n:]\n+\t}\n \tif len(p) > 0 {\n \t\td.nx = copy(d.x[:], p)\n \t}"}, {"sha": "8e66b4b306d6442e96b74c22b62c2442747e07b6", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -123,3 +123,28 @@ func TestGolden(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var bench = New()\n+var buf = makeBuf()\n+\n+func makeBuf() []byte {\n+\tb := make([]byte, 8<<10)\n+\tfor i := range b {\n+\t\tb[i] = byte(i)\n+\t}\n+\treturn b\n+}\n+\n+func BenchmarkHash1K(b *testing.B) {\n+\tb.SetBytes(1024)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf[:1024])\n+\t}\n+}\n+\n+func BenchmarkHash8K(b *testing.B) {\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf)\n+\t}\n+}"}, {"sha": "2ac49100ac65264ceb74b9363a9638ec1780e14e", "filename": "libgo/go/crypto/sha256/sha256block.go", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -75,22 +75,21 @@ var _K = []uint32{\n \t0xc67178f2,\n }\n \n-func _Block(dig *digest, p []byte) int {\n+func block(dig *digest, p []byte) {\n \tvar w [64]uint32\n-\tn := 0\n \th0, h1, h2, h3, h4, h5, h6, h7 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7]\n-\tfor len(p) >= _Chunk {\n+\tfor len(p) >= chunk {\n \t\t// Can interlace the computation of w with the\n \t\t// rounds below if needed for speed.\n \t\tfor i := 0; i < 16; i++ {\n \t\t\tj := i * 4\n \t\t\tw[i] = uint32(p[j])<<24 | uint32(p[j+1])<<16 | uint32(p[j+2])<<8 | uint32(p[j+3])\n \t\t}\n \t\tfor i := 16; i < 64; i++ {\n-\t\t\tt1 := (w[i-2]>>17 | w[i-2]<<(32-17)) ^ (w[i-2]>>19 | w[i-2]<<(32-19)) ^ (w[i-2] >> 10)\n-\n-\t\t\tt2 := (w[i-15]>>7 | w[i-15]<<(32-7)) ^ (w[i-15]>>18 | w[i-15]<<(32-18)) ^ (w[i-15] >> 3)\n-\n+\t\t\tv1 := w[i-2]\n+\t\t\tt1 := (v1>>17 | v1<<(32-17)) ^ (v1>>19 | v1<<(32-19)) ^ (v1 >> 10)\n+\t\t\tv2 := w[i-15]\n+\t\t\tt2 := (v2>>7 | v2<<(32-7)) ^ (v2>>18 | v2<<(32-18)) ^ (v2 >> 3)\n \t\t\tw[i] = t1 + w[i-7] + t2 + w[i-16]\n \t\t}\n \n@@ -120,10 +119,8 @@ func _Block(dig *digest, p []byte) int {\n \t\th6 += g\n \t\th7 += h\n \n-\t\tp = p[_Chunk:]\n-\t\tn += _Chunk\n+\t\tp = p[chunk:]\n \t}\n \n \tdig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7] = h0, h1, h2, h3, h4, h5, h6, h7\n-\treturn n\n }"}, {"sha": "4aec5293858522ae27fc788e4b148534d1386b6d", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -26,53 +26,53 @@ const Size384 = 48\n const BlockSize = 128\n \n const (\n-\t_Chunk     = 128\n-\t_Init0     = 0x6a09e667f3bcc908\n-\t_Init1     = 0xbb67ae8584caa73b\n-\t_Init2     = 0x3c6ef372fe94f82b\n-\t_Init3     = 0xa54ff53a5f1d36f1\n-\t_Init4     = 0x510e527fade682d1\n-\t_Init5     = 0x9b05688c2b3e6c1f\n-\t_Init6     = 0x1f83d9abfb41bd6b\n-\t_Init7     = 0x5be0cd19137e2179\n-\t_Init0_384 = 0xcbbb9d5dc1059ed8\n-\t_Init1_384 = 0x629a292a367cd507\n-\t_Init2_384 = 0x9159015a3070dd17\n-\t_Init3_384 = 0x152fecd8f70e5939\n-\t_Init4_384 = 0x67332667ffc00b31\n-\t_Init5_384 = 0x8eb44a8768581511\n-\t_Init6_384 = 0xdb0c2e0d64f98fa7\n-\t_Init7_384 = 0x47b5481dbefa4fa4\n+\tchunk     = 128\n+\tinit0     = 0x6a09e667f3bcc908\n+\tinit1     = 0xbb67ae8584caa73b\n+\tinit2     = 0x3c6ef372fe94f82b\n+\tinit3     = 0xa54ff53a5f1d36f1\n+\tinit4     = 0x510e527fade682d1\n+\tinit5     = 0x9b05688c2b3e6c1f\n+\tinit6     = 0x1f83d9abfb41bd6b\n+\tinit7     = 0x5be0cd19137e2179\n+\tinit0_384 = 0xcbbb9d5dc1059ed8\n+\tinit1_384 = 0x629a292a367cd507\n+\tinit2_384 = 0x9159015a3070dd17\n+\tinit3_384 = 0x152fecd8f70e5939\n+\tinit4_384 = 0x67332667ffc00b31\n+\tinit5_384 = 0x8eb44a8768581511\n+\tinit6_384 = 0xdb0c2e0d64f98fa7\n+\tinit7_384 = 0x47b5481dbefa4fa4\n )\n \n // digest represents the partial evaluation of a checksum.\n type digest struct {\n \th     [8]uint64\n-\tx     [_Chunk]byte\n+\tx     [chunk]byte\n \tnx    int\n \tlen   uint64\n \tis384 bool // mark if this digest is SHA-384\n }\n \n func (d *digest) Reset() {\n \tif !d.is384 {\n-\t\td.h[0] = _Init0\n-\t\td.h[1] = _Init1\n-\t\td.h[2] = _Init2\n-\t\td.h[3] = _Init3\n-\t\td.h[4] = _Init4\n-\t\td.h[5] = _Init5\n-\t\td.h[6] = _Init6\n-\t\td.h[7] = _Init7\n+\t\td.h[0] = init0\n+\t\td.h[1] = init1\n+\t\td.h[2] = init2\n+\t\td.h[3] = init3\n+\t\td.h[4] = init4\n+\t\td.h[5] = init5\n+\t\td.h[6] = init6\n+\t\td.h[7] = init7\n \t} else {\n-\t\td.h[0] = _Init0_384\n-\t\td.h[1] = _Init1_384\n-\t\td.h[2] = _Init2_384\n-\t\td.h[3] = _Init3_384\n-\t\td.h[4] = _Init4_384\n-\t\td.h[5] = _Init5_384\n-\t\td.h[6] = _Init6_384\n-\t\td.h[7] = _Init7_384\n+\t\td.h[0] = init0_384\n+\t\td.h[1] = init1_384\n+\t\td.h[2] = init2_384\n+\t\td.h[3] = init3_384\n+\t\td.h[4] = init4_384\n+\t\td.h[5] = init5_384\n+\t\td.h[6] = init6_384\n+\t\td.h[7] = init7_384\n \t}\n \td.nx = 0\n \td.len = 0\n@@ -107,21 +107,24 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \td.len += uint64(nn)\n \tif d.nx > 0 {\n \t\tn := len(p)\n-\t\tif n > _Chunk-d.nx {\n-\t\t\tn = _Chunk - d.nx\n+\t\tif n > chunk-d.nx {\n+\t\t\tn = chunk - d.nx\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\td.x[d.nx+i] = p[i]\n \t\t}\n \t\td.nx += n\n-\t\tif d.nx == _Chunk {\n-\t\t\t_Block(d, d.x[0:])\n+\t\tif d.nx == chunk {\n+\t\t\tblock(d, d.x[0:])\n \t\t\td.nx = 0\n \t\t}\n \t\tp = p[n:]\n \t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n+\tif len(p) >= chunk {\n+\t\tn := len(p) &^ (chunk - 1)\n+\t\tblock(d, p[:n])\n+\t\tp = p[n:]\n+\t}\n \tif len(p) > 0 {\n \t\td.nx = copy(d.x[:], p)\n \t}"}, {"sha": "977655ddb4103fb99e102b3ca72144811e41f956", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -123,3 +123,28 @@ func TestGolden(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var bench = New()\n+var buf = makeBuf()\n+\n+func makeBuf() []byte {\n+\tb := make([]byte, 8<<10)\n+\tfor i := range b {\n+\t\tb[i] = byte(i)\n+\t}\n+\treturn b\n+}\n+\n+func BenchmarkHash1K(b *testing.B) {\n+\tb.SetBytes(1024)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf[:1024])\n+\t}\n+}\n+\n+func BenchmarkHash8K(b *testing.B) {\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Write(buf)\n+\t}\n+}"}, {"sha": "3577b4f3df143f67ccc27d8b818bfc29c6ce0650", "filename": "libgo/go/crypto/sha512/sha512block.go", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -91,20 +91,20 @@ var _K = []uint64{\n \t0x6c44198c4a475817,\n }\n \n-func _Block(dig *digest, p []byte) int {\n+func block(dig *digest, p []byte) {\n \tvar w [80]uint64\n-\tn := 0\n \th0, h1, h2, h3, h4, h5, h6, h7 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7]\n-\tfor len(p) >= _Chunk {\n+\tfor len(p) >= chunk {\n \t\tfor i := 0; i < 16; i++ {\n \t\t\tj := i * 8\n \t\t\tw[i] = uint64(p[j])<<56 | uint64(p[j+1])<<48 | uint64(p[j+2])<<40 | uint64(p[j+3])<<32 |\n \t\t\t\tuint64(p[j+4])<<24 | uint64(p[j+5])<<16 | uint64(p[j+6])<<8 | uint64(p[j+7])\n \t\t}\n \t\tfor i := 16; i < 80; i++ {\n-\t\t\tt1 := (w[i-2]>>19 | w[i-2]<<(64-19)) ^ (w[i-2]>>61 | w[i-2]<<(64-61)) ^ (w[i-2] >> 6)\n-\n-\t\t\tt2 := (w[i-15]>>1 | w[i-15]<<(64-1)) ^ (w[i-15]>>8 | w[i-15]<<(64-8)) ^ (w[i-15] >> 7)\n+\t\t\tv1 := w[i-2]\n+\t\t\tt1 := (v1>>19 | v1<<(64-19)) ^ (v1>>61 | v1<<(64-61)) ^ (v1 >> 6)\n+\t\t\tv2 := w[i-15]\n+\t\t\tt2 := (v2>>1 | v2<<(64-1)) ^ (v2>>8 | v2<<(64-8)) ^ (v2 >> 7)\n \n \t\t\tw[i] = t1 + w[i-7] + t2 + w[i-16]\n \t\t}\n@@ -135,10 +135,8 @@ func _Block(dig *digest, p []byte) int {\n \t\th6 += g\n \t\th7 += h\n \n-\t\tp = p[_Chunk:]\n-\t\tn += _Chunk\n+\t\tp = p[chunk:]\n \t}\n \n \tdig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7] = h0, h1, h2, h3, h4, h5, h6, h7\n-\treturn n\n }"}, {"sha": "a647e19aa19993510a67436ea1fdaf9b3bf82c56", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -55,9 +55,11 @@ var cipherSuites = []*cipherSuite{\n \t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n \t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n \t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n+\t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, false, cipherAES, macSHA1},\n \t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n \t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n \t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n+\t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n@@ -182,7 +184,9 @@ const (\n \tTLS_RSA_WITH_RC4_128_SHA            uint16 = 0x0005\n \tTLS_RSA_WITH_3DES_EDE_CBC_SHA       uint16 = 0x000a\n \tTLS_RSA_WITH_AES_128_CBC_SHA        uint16 = 0x002f\n+\tTLS_RSA_WITH_AES_256_CBC_SHA        uint16 = 0x0035\n \tTLS_ECDHE_RSA_WITH_RC4_128_SHA      uint16 = 0xc011\n \tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012\n \tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA  uint16 = 0xc013\n+\tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA  uint16 = 0xc014\n )"}, {"sha": "cfe2f2227fb104ec32dd565e736f3d74be50ada2", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -41,6 +41,7 @@ const (\n const (\n \ttypeClientHello        uint8 = 1\n \ttypeServerHello        uint8 = 2\n+\ttypeNewSessionTicket   uint8 = 4\n \ttypeCertificate        uint8 = 11\n \ttypeServerKeyExchange  uint8 = 12\n \ttypeCertificateRequest uint8 = 13\n@@ -63,6 +64,7 @@ var (\n \textensionStatusRequest   uint16 = 5\n \textensionSupportedCurves uint16 = 10\n \textensionSupportedPoints uint16 = 11\n+\textensionSessionTicket   uint16 = 35\n \textensionNextProtoNeg    uint16 = 13172 // not IANA assigned\n )\n \n@@ -97,6 +99,7 @@ const (\n // ConnectionState records basic TLS details about the connection.\n type ConnectionState struct {\n \tHandshakeComplete          bool\n+\tDidResume                  bool\n \tCipherSuite                uint16\n \tNegotiatedProtocol         string\n \tNegotiatedProtocolIsMutual bool\n@@ -180,6 +183,22 @@ type Config struct {\n \t// CipherSuites is a list of supported cipher suites. If CipherSuites\n \t// is nil, TLS uses a list of suites supported by the implementation.\n \tCipherSuites []uint16\n+\n+\t// SessionTicketsDisabled may be set to true to disable session ticket\n+\t// (resumption) support.\n+\tSessionTicketsDisabled bool\n+\n+\t// SessionTicketKey is used by TLS servers to provide session\n+\t// resumption. See RFC 5077. If zero, it will be filled with\n+\t// random data before the first server handshake.\n+\t//\n+\t// If multiple servers are terminating connections for the same host\n+\t// they should all have the same SessionTicketKey. If the\n+\t// SessionTicketKey leaks, previously recorded and future TLS\n+\t// connections using that key are compromised.\n+\tSessionTicketKey [32]byte\n+\n+\tserverInitOnce sync.Once\n }\n \n func (c *Config) rand() io.Reader {"}, {"sha": "fd2ef1ecfa8de4501ad3f670719a3b86816a4216", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -31,6 +31,7 @@ type Conn struct {\n \thaveVers          bool       // version has been negotiated\n \tconfig            *Config    // configuration passed to constructor\n \thandshakeComplete bool\n+\tdidResume         bool // whether this connection was a session resumption\n \tcipherSuite       uint16\n \tocspResponse      []byte // stapled OCSP response\n \tpeerCertificates  []*x509.Certificate\n@@ -44,8 +45,7 @@ type Conn struct {\n \tclientProtocolFallback bool\n \n \t// first permanent error\n-\terrMutex sync.Mutex\n-\terr      error\n+\tconnErr\n \n \t// input/output\n \tin, out  halfConn     // in.Mutex < out.Mutex\n@@ -56,21 +56,25 @@ type Conn struct {\n \ttmp [16]byte\n }\n \n-func (c *Conn) setError(err error) error {\n-\tc.errMutex.Lock()\n-\tdefer c.errMutex.Unlock()\n+type connErr struct {\n+\tmu    sync.Mutex\n+\tvalue error\n+}\n+\n+func (e *connErr) setError(err error) error {\n+\te.mu.Lock()\n+\tdefer e.mu.Unlock()\n \n-\tif c.err == nil {\n-\t\tc.err = err\n+\tif e.value == nil {\n+\t\te.value = err\n \t}\n \treturn err\n }\n \n-func (c *Conn) error() error {\n-\tc.errMutex.Lock()\n-\tdefer c.errMutex.Unlock()\n-\n-\treturn c.err\n+func (e *connErr) error() error {\n+\te.mu.Lock()\n+\tdefer e.mu.Unlock()\n+\treturn e.value\n }\n \n // Access to net.Conn methods.\n@@ -660,8 +664,7 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n \t\t\tc.tmp[0] = alertLevelError\n \t\t\tc.tmp[1] = byte(err.(alert))\n \t\t\tc.writeRecord(recordTypeAlert, c.tmp[0:2])\n-\t\t\tc.err = &net.OpError{Op: \"local error\", Err: err}\n-\t\t\treturn n, c.err\n+\t\t\treturn n, c.setError(&net.OpError{Op: \"local error\", Err: err})\n \t\t}\n \t}\n \treturn\n@@ -672,8 +675,8 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n // c.in.Mutex < L; c.out.Mutex < L.\n func (c *Conn) readHandshake() (interface{}, error) {\n \tfor c.hand.Len() < 4 {\n-\t\tif c.err != nil {\n-\t\t\treturn nil, c.err\n+\t\tif err := c.error(); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n \t\tif err := c.readRecord(recordTypeHandshake); err != nil {\n \t\t\treturn nil, err\n@@ -684,11 +687,11 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \tn := int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n \tif n > maxHandshake {\n \t\tc.sendAlert(alertInternalError)\n-\t\treturn nil, c.err\n+\t\treturn nil, c.error()\n \t}\n \tfor c.hand.Len() < 4+n {\n-\t\tif c.err != nil {\n-\t\t\treturn nil, c.err\n+\t\tif err := c.error(); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n \t\tif err := c.readRecord(recordTypeHandshake); err != nil {\n \t\t\treturn nil, err\n@@ -738,12 +741,12 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \n // Write writes data to the connection.\n func (c *Conn) Write(b []byte) (int, error) {\n-\tif c.err != nil {\n-\t\treturn 0, c.err\n+\tif err := c.error(); err != nil {\n+\t\treturn 0, err\n \t}\n \n-\tif c.err = c.Handshake(); c.err != nil {\n-\t\treturn 0, c.err\n+\tif err := c.Handshake(); err != nil {\n+\t\treturn 0, c.setError(err)\n \t}\n \n \tc.out.Lock()\n@@ -753,9 +756,8 @@ func (c *Conn) Write(b []byte) (int, error) {\n \t\treturn 0, alertInternalError\n \t}\n \n-\tvar n int\n-\tn, c.err = c.writeRecord(recordTypeApplicationData, b)\n-\treturn n, c.err\n+\tn, err := c.writeRecord(recordTypeApplicationData, b)\n+\treturn n, c.setError(err)\n }\n \n // Read can be made to time out and return a net.Error with Timeout() == true\n@@ -768,14 +770,14 @@ func (c *Conn) Read(b []byte) (n int, err error) {\n \tc.in.Lock()\n \tdefer c.in.Unlock()\n \n-\tfor c.input == nil && c.err == nil {\n+\tfor c.input == nil && c.error() == nil {\n \t\tif err := c.readRecord(recordTypeApplicationData); err != nil {\n \t\t\t// Soft error, like EAGAIN\n \t\t\treturn 0, err\n \t\t}\n \t}\n-\tif c.err != nil {\n-\t\treturn 0, c.err\n+\tif err := c.error(); err != nil {\n+\t\treturn 0, err\n \t}\n \tn, err = c.input.Read(b)\n \tif c.input.off >= len(c.input.data) {\n@@ -829,6 +831,7 @@ func (c *Conn) ConnectionState() ConnectionState {\n \tstate.HandshakeComplete = c.handshakeComplete\n \tif c.handshakeComplete {\n \t\tstate.NegotiatedProtocol = c.clientProtocol\n+\t\tstate.DidResume = c.didResume\n \t\tstate.NegotiatedProtocolIsMutual = !c.clientProtocolFallback\n \t\tstate.CipherSuite = c.cipherSuite\n \t\tstate.PeerCertificates = c.peerCertificates"}, {"sha": "7db13bf70d8f9d700d9c8dafddd05704f59bf8b8", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -278,8 +278,9 @@ func (c *Conn) clientHandshake() error {\n \t\tc.writeRecord(recordTypeHandshake, certVerify.marshal())\n \t}\n \n-\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n-\t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n+\tmasterSecret := masterFromPreMasterSecret(c.vers, preMasterSecret, hello.random, serverHello.random)\n+\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n+\t\tkeysFromMasterSecret(c.vers, masterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n \tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */)\n \tclientHash := suite.mac(c.vers, clientMAC)\n@@ -306,8 +307,8 @@ func (c *Conn) clientHandshake() error {\n \tserverHash := suite.mac(c.vers, serverMAC)\n \tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n-\tif c.err != nil {\n-\t\treturn c.err\n+\tif err := c.error(); err != nil {\n+\t\treturn err\n \t}\n \n \tmsg, err = c.readHandshake()"}, {"sha": "e127049bb0527206d14550733fd99d1de5e5e4dd", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 199, "deletions": 19, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"flag\"\n \t\"io\"\n \t\"net\"\n+\t\"os\"\n \t\"testing\"\n )\n \n@@ -39,7 +40,15 @@ func testClientScript(t *testing.T, name string, clientScript [][]byte, config *\n }\n \n func TestHandshakeClientRC4(t *testing.T) {\n-\ttestClientScript(t, \"RC4\", rc4ClientScript, testConfig)\n+\tvar config = *testConfig\n+\tconfig.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}\n+\ttestClientScript(t, \"RC4\", rc4ClientScript, &config)\n+}\n+\n+func TestHandshakeClientECDHEAES(t *testing.T) {\n+\tvar config = *testConfig\n+\tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA}\n+\ttestClientScript(t, \"ECDHE-AES\", ecdheAESClientScript, &config)\n }\n \n var connect = flag.Bool(\"connect\", false, \"connect to a TLS server on :10443\")\n@@ -49,25 +58,33 @@ func TestRunClient(t *testing.T) {\n \t\treturn\n \t}\n \n-\ttestConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n-\n-\tconn, err := Dial(\"tcp\", \"127.0.0.1:10443\", testConfig)\n+\ttcpConn, err := net.Dial(\"tcp\", \"127.0.0.1:10443\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \n+\trecord := &recordingConn{\n+\t\tConn: tcpConn,\n+\t}\n+\n+\tconfig := GetTestConfig()\n+\tconn := Client(record, config)\n+\tif err := conn.Handshake(); err != nil {\n+\t\tt.Fatalf(\"error from TLS handshake: %s\", err)\n+\t}\n+\n \tconn.Write([]byte(\"hello\\n\"))\n \tconn.Close()\n+\n+\trecord.WriteTo(os.Stdout)\n }\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in client mode:\n-//   % go test -run \"TestRunClient\" -connect\n-// and then:\n-//   % gnutls-serv -p 10443 --debug 100 --x509keyfile key.pem --x509certfile cert.pem -a > /tmp/log 2>&1\n-//   % python parse-gnutls-cli-debug-log.py < /tmp/log\n+//   % go test -test.run \"TestRunClient\" -connect\n+// The recorded bytes are written to stdout.\n //\n-// Where key.pem is:\n+// The server private key is:\n // -----BEGIN RSA PRIVATE KEY-----\n // MIIBPAIBAAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVD\n // TGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAAQJAN6W31vDEP2DjdqhzCDDu\n@@ -78,17 +95,20 @@ func TestRunClient(t *testing.T) {\n // vnlEGo8K85u+KwIOimM48ZG8oTk7iFdkqLJR1utT3aU=\n // -----END RSA PRIVATE KEY-----\n //\n-// and cert.pem is:\n+// and certificate is:\n // -----BEGIN CERTIFICATE-----\n-// MIIBoDCCAUoCAQAwDQYJKoZIhvcNAQEEBQAwYzELMAkGA1UEBhMCQVUxEzARBgNV\n-// BAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMSMwIQYD\n-// VQQDExpTZXJ2ZXIgdGVzdCBjZXJ0ICg1MTIgYml0KTAeFw05NzA5MDkwMzQxMjZa\n-// Fw05NzEwMDkwMzQxMjZaMF4xCzAJBgNVBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0\n-// YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxFzAVBgNVBAMT\n-// DkVyaWMgdGhlIFlvdW5nMFEwCQYFKw4DAgwFAANEAAJBALVEqPODnpI4rShlY8S7\n-// tB713JNvabvn6Gned7zylwLLiXQAo/PAT6mfdWPTyCX9RlId/Aroh1ou893BA32Q\n-// sggwDQYJKoZIhvcNAQEEBQADQQCU5SSgapJSdRXJoX+CpCvFy+JVh9HpSjCpSNKO\n-// 19raHv98hKAUJuP9HyM+SUsffO6mAIgitUaqW8/wDMePhEC3\n+// MIICKzCCAdWgAwIBAgIJALE1E2URIMWSMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n+// BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\n+// aWRnaXRzIFB0eSBMdGQwHhcNMTIwNDA2MTcxMDEzWhcNMTUwNDA2MTcxMDEzWjBF\n+// MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50\n+// ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ+z\n+// w4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVDTGiXav6ooKXfX3j/\n+// 7tdkuD8Ey2//Kv7+ue0CAwEAAaOBpzCBpDAdBgNVHQ4EFgQUeKaXmmO1xaGlM7oi\n+// fCNuWxt6zCswdQYDVR0jBG4wbIAUeKaXmmO1xaGlM7oifCNuWxt6zCuhSaRHMEUx\n+// CzAJBgNVBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRl\n+// cm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCxNRNlESDFkjAMBgNVHRMEBTADAQH/MA0G\n+// CSqGSIb3DQEBBQUAA0EAhTZAc8G7GtrUWZ8tonAxRnTsg26oyDxRrzms7EC86CJG\n+// HZnWRiok1IsFCEv7NRFukrt3uuQSu/TIXpyBqJdgTA==\n // -----END CERTIFICATE-----\n var rc4ClientScript = [][]byte{\n \t{\n@@ -210,3 +230,163 @@ var rc4ClientScript = [][]byte{\n \t\t0x59, 0xac, 0xc6, 0xb5, 0x56, 0x55, 0x96,\n \t},\n }\n+\n+var ecdheAESClientScript = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x4a, 0x01, 0x00, 0x00,\n+\t\t0x46, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x13,\n+\t\t0x01, 0x00, 0x00, 0x1b, 0x00, 0x05, 0x00, 0x05,\n+\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,\n+\t\t0x08, 0x00, 0x06, 0x00, 0x17, 0x00, 0x18, 0x00,\n+\t\t0x19, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x02, 0x00, 0x00,\n+\t\t0x50, 0x03, 0x01, 0x4f, 0x7f, 0x24, 0x25, 0x10,\n+\t\t0xa8, 0x9d, 0xb1, 0x33, 0xd6, 0x53, 0x81, 0xce,\n+\t\t0xb0, 0x69, 0xed, 0x1b, 0x9c, 0x5e, 0x40, 0x3a,\n+\t\t0x4d, 0x06, 0xbc, 0xc7, 0x84, 0x51, 0x5a, 0x30,\n+\t\t0x40, 0x50, 0x48, 0x20, 0xcd, 0x91, 0x80, 0x08,\n+\t\t0xff, 0x82, 0x38, 0xc6, 0x03, 0x2d, 0x45, 0x4c,\n+\t\t0x91, 0xbb, 0xcc, 0x27, 0x3d, 0x58, 0xff, 0x0d,\n+\t\t0x26, 0x34, 0x7b, 0x48, 0x7a, 0xce, 0x25, 0x20,\n+\t\t0x90, 0x0f, 0x35, 0x9f, 0xc0, 0x13, 0x00, 0x00,\n+\t\t0x08, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n+\t\t0x02, 0x16, 0x03, 0x01, 0x02, 0x39, 0x0b, 0x00,\n+\t\t0x02, 0x35, 0x00, 0x02, 0x32, 0x00, 0x02, 0x2f,\n+\t\t0x30, 0x82, 0x02, 0x2b, 0x30, 0x82, 0x01, 0xd5,\n+\t\t0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,\n+\t\t0xb1, 0x35, 0x13, 0x65, 0x11, 0x20, 0xc5, 0x92,\n+\t\t0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n+\t\t0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,\n+\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e,\n+\t\t0x17, 0x0d, 0x31, 0x32, 0x30, 0x34, 0x30, 0x36,\n+\t\t0x31, 0x37, 0x31, 0x30, 0x31, 0x33, 0x5a, 0x17,\n+\t\t0x0d, 0x31, 0x35, 0x30, 0x34, 0x30, 0x36, 0x31,\n+\t\t0x37, 0x31, 0x30, 0x31, 0x33, 0x5a, 0x30, 0x45,\n+\t\t0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30,\n+\t\t0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a,\n+\t\t0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61,\n+\t\t0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74,\n+\t\t0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69,\n+\t\t0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74,\n+\t\t0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x5c, 0x30,\n+\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x4b,\n+\t\t0x00, 0x30, 0x48, 0x02, 0x41, 0x00, 0x9f, 0xb3,\n+\t\t0xc3, 0x84, 0x27, 0x95, 0xff, 0x12, 0x31, 0x52,\n+\t\t0x0f, 0x15, 0xef, 0x46, 0x11, 0xc4, 0xad, 0x80,\n+\t\t0xe6, 0x36, 0x5b, 0x0f, 0xdd, 0x80, 0xd7, 0x61,\n+\t\t0x8d, 0xe0, 0xfc, 0x72, 0x45, 0x09, 0x34, 0xfe,\n+\t\t0x55, 0x66, 0x45, 0x43, 0x4c, 0x68, 0x97, 0x6a,\n+\t\t0xfe, 0xa8, 0xa0, 0xa5, 0xdf, 0x5f, 0x78, 0xff,\n+\t\t0xee, 0xd7, 0x64, 0xb8, 0x3f, 0x04, 0xcb, 0x6f,\n+\t\t0xff, 0x2a, 0xfe, 0xfe, 0xb9, 0xed, 0x02, 0x03,\n+\t\t0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81,\n+\t\t0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,\n+\t\t0x04, 0x16, 0x04, 0x14, 0x78, 0xa6, 0x97, 0x9a,\n+\t\t0x63, 0xb5, 0xc5, 0xa1, 0xa5, 0x33, 0xba, 0x22,\n+\t\t0x7c, 0x23, 0x6e, 0x5b, 0x1b, 0x7a, 0xcc, 0x2b,\n+\t\t0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,\n+\t\t0x6e, 0x30, 0x6c, 0x80, 0x14, 0x78, 0xa6, 0x97,\n+\t\t0x9a, 0x63, 0xb5, 0xc5, 0xa1, 0xa5, 0x33, 0xba,\n+\t\t0x22, 0x7c, 0x23, 0x6e, 0x5b, 0x1b, 0x7a, 0xcc,\n+\t\t0x2b, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x82, 0x09, 0x00, 0xb1,\n+\t\t0x35, 0x13, 0x65, 0x11, 0x20, 0xc5, 0x92, 0x30,\n+\t\t0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,\n+\t\t0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,\n+\t\t0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n+\t\t0x01, 0x05, 0x05, 0x00, 0x03, 0x41, 0x00, 0x85,\n+\t\t0x36, 0x40, 0x73, 0xc1, 0xbb, 0x1a, 0xda, 0xd4,\n+\t\t0x59, 0x9f, 0x2d, 0xa2, 0x70, 0x31, 0x46, 0x74,\n+\t\t0xec, 0x83, 0x6e, 0xa8, 0xc8, 0x3c, 0x51, 0xaf,\n+\t\t0x39, 0xac, 0xec, 0x40, 0xbc, 0xe8, 0x22, 0x46,\n+\t\t0x1d, 0x99, 0xd6, 0x46, 0x2a, 0x24, 0xd4, 0x8b,\n+\t\t0x05, 0x08, 0x4b, 0xfb, 0x35, 0x11, 0x6e, 0x92,\n+\t\t0xbb, 0x77, 0xba, 0xe4, 0x12, 0xbb, 0xf4, 0xc8,\n+\t\t0x5e, 0x9c, 0x81, 0xa8, 0x97, 0x60, 0x4c, 0x16,\n+\t\t0x03, 0x01, 0x00, 0x8b, 0x0c, 0x00, 0x00, 0x87,\n+\t\t0x03, 0x00, 0x17, 0x41, 0x04, 0x0b, 0xe5, 0x39,\n+\t\t0xde, 0x17, 0x7a, 0xaf, 0x96, 0xd5, 0x16, 0x01,\n+\t\t0xa8, 0x06, 0x80, 0x98, 0x75, 0x52, 0x56, 0x92,\n+\t\t0x15, 0xf9, 0x8d, 0xc0, 0x98, 0x62, 0xed, 0x54,\n+\t\t0xb7, 0xef, 0x03, 0x11, 0x34, 0x82, 0x65, 0xd1,\n+\t\t0xde, 0x25, 0x15, 0x4c, 0xf3, 0xdf, 0x4d, 0xbd,\n+\t\t0x6c, 0xed, 0x3d, 0xd6, 0x04, 0xcc, 0xd1, 0xf7,\n+\t\t0x6d, 0x32, 0xb1, 0x1c, 0x59, 0xca, 0xfb, 0xbc,\n+\t\t0x61, 0xeb, 0x4b, 0xe6, 0x00, 0x00, 0x40, 0x3e,\n+\t\t0xe6, 0x23, 0x54, 0x61, 0x3f, 0x63, 0x16, 0xeb,\n+\t\t0x5c, 0xc3, 0xba, 0x8a, 0x19, 0x13, 0x60, 0x9f,\n+\t\t0x23, 0xbf, 0x36, 0x1a, 0x32, 0x7a, 0xae, 0x34,\n+\t\t0x7f, 0x2f, 0x89, 0x85, 0xe1, 0x0e, 0x93, 0xd7,\n+\t\t0xf0, 0xab, 0xa1, 0x0d, 0x54, 0x95, 0x79, 0x0b,\n+\t\t0xb4, 0xf1, 0x1c, 0x1d, 0x0f, 0x8c, 0x16, 0xec,\n+\t\t0x82, 0x60, 0xee, 0xa3, 0x71, 0x2f, 0xaf, 0x3e,\n+\t\t0xf1, 0xbd, 0xb5, 0x1b, 0x7f, 0xe0, 0xd2, 0x16,\n+\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x46, 0x10, 0x00, 0x00,\n+\t\t0x42, 0x41, 0x04, 0x1e, 0x18, 0x37, 0xef, 0x0d,\n+\t\t0x19, 0x51, 0x88, 0x35, 0x75, 0x71, 0xb5, 0xe5,\n+\t\t0x54, 0x5b, 0x12, 0x2e, 0x8f, 0x09, 0x67, 0xfd,\n+\t\t0xa7, 0x24, 0x20, 0x3e, 0xb2, 0x56, 0x1c, 0xce,\n+\t\t0x97, 0x28, 0x5e, 0xf8, 0x2b, 0x2d, 0x4f, 0x9e,\n+\t\t0xf1, 0x07, 0x9f, 0x6c, 0x4b, 0x5b, 0x83, 0x56,\n+\t\t0xe2, 0x32, 0x42, 0xe9, 0x58, 0xb6, 0xd7, 0x49,\n+\t\t0xa6, 0xb5, 0x68, 0x1a, 0x41, 0x03, 0x56, 0x6b,\n+\t\t0xdc, 0x5a, 0x89, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x09, 0xac,\n+\t\t0xbe, 0x94, 0x75, 0x4d, 0x73, 0x45, 0xbd, 0xa8,\n+\t\t0x0c, 0xe3, 0x5f, 0x72, 0x0b, 0x40, 0x4f, 0xd0,\n+\t\t0xd2, 0xcb, 0x16, 0x50, 0xfe, 0xdd, 0x1a, 0x33,\n+\t\t0x5c, 0x18, 0x37, 0x98, 0x42, 0xfc, 0x25, 0x42,\n+\t\t0x33, 0xce, 0x60, 0xcf, 0x8e, 0x95, 0x6e, 0x48,\n+\t\t0xed, 0x00, 0x35, 0x50, 0x26, 0x7f,\n+\t},\n+\t{\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x30, 0xf6, 0x6a, 0xdb, 0x83, 0xd4,\n+\t\t0x3c, 0x77, 0x52, 0xad, 0xc0, 0x0f, 0x3a, 0x2c,\n+\t\t0x42, 0xb9, 0x60, 0x4b, 0xb2, 0xf6, 0x84, 0xfd,\n+\t\t0x4e, 0x96, 0xfc, 0x15, 0xe7, 0x94, 0x25, 0xb0,\n+\t\t0x59, 0x9f, 0xdd, 0xb6, 0x58, 0x03, 0x13, 0x8d,\n+\t\t0xeb, 0xb0, 0xad, 0x30, 0x31, 0x58, 0x6c, 0xa0,\n+\t\t0x8f, 0x57, 0x50,\n+\t},\n+\t{\n+\t\t0x17, 0x03, 0x01, 0x00, 0x20, 0xab, 0x64, 0x3d,\n+\t\t0x79, 0x69, 0x3e, 0xba, 0xc4, 0x24, 0x7b, 0xe5,\n+\t\t0xe5, 0x23, 0x66, 0x6f, 0x32, 0xdf, 0x50, 0x7c,\n+\t\t0x06, 0x2a, 0x02, 0x82, 0x79, 0x40, 0xdb, 0xb1,\n+\t\t0x04, 0xc0, 0x2b, 0xdc, 0x3a, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x20, 0xf8, 0xad, 0xca, 0xd7, 0x96, 0xf0,\n+\t\t0xd6, 0xa3, 0x62, 0xe1, 0x03, 0x44, 0xdb, 0xd0,\n+\t\t0xc9, 0x63, 0x3e, 0x1b, 0x70, 0x41, 0x57, 0x0c,\n+\t\t0xd8, 0x8e, 0x71, 0x49, 0x68, 0xe3, 0x04, 0x53,\n+\t\t0x5a, 0xbe,\n+\t},\n+}"}, {"sha": "cdd49170777ff25410149319dd68bc12cf4b1272", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 104, "deletions": 4, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -18,6 +18,8 @@ type clientHelloMsg struct {\n \tocspStapling       bool\n \tsupportedCurves    []uint16\n \tsupportedPoints    []uint8\n+\tticketSupported    bool\n+\tsessionTicket      []uint8\n }\n \n func (m *clientHelloMsg) equal(i interface{}) bool {\n@@ -36,7 +38,9 @@ func (m *clientHelloMsg) equal(i interface{}) bool {\n \t\tm.serverName == m1.serverName &&\n \t\tm.ocspStapling == m1.ocspStapling &&\n \t\teqUint16s(m.supportedCurves, m1.supportedCurves) &&\n-\t\tbytes.Equal(m.supportedPoints, m1.supportedPoints)\n+\t\tbytes.Equal(m.supportedPoints, m1.supportedPoints) &&\n+\t\tm.ticketSupported == m1.ticketSupported &&\n+\t\tbytes.Equal(m.sessionTicket, m1.sessionTicket)\n }\n \n func (m *clientHelloMsg) marshal() []byte {\n@@ -66,6 +70,10 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\textensionsLength += 1 + len(m.supportedPoints)\n \t\tnumExtensions++\n \t}\n+\tif m.ticketSupported {\n+\t\textensionsLength += len(m.sessionTicket)\n+\t\tnumExtensions++\n+\t}\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -180,6 +188,17 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\t\tz = z[1:]\n \t\t}\n \t}\n+\tif m.ticketSupported {\n+\t\t// http://tools.ietf.org/html/rfc5077#section-3.2\n+\t\tz[0] = byte(extensionSessionTicket >> 8)\n+\t\tz[1] = byte(extensionSessionTicket)\n+\t\tl := len(m.sessionTicket)\n+\t\tz[2] = byte(l >> 8)\n+\t\tz[3] = byte(l)\n+\t\tz = z[4:]\n+\t\tcopy(z, m.sessionTicket)\n+\t\tz = z[len(m.sessionTicket):]\n+\t}\n \n \tm.raw = x\n \n@@ -228,6 +247,8 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \tm.nextProtoNeg = false\n \tm.serverName = \"\"\n \tm.ocspStapling = false\n+\tm.ticketSupported = false\n+\tm.sessionTicket = nil\n \n \tif len(data) == 0 {\n \t\t// ClientHello is optionally followed by extension data\n@@ -311,6 +332,10 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\t}\n \t\t\tm.supportedPoints = make([]uint8, l)\n \t\t\tcopy(m.supportedPoints, data[1:])\n+\t\tcase extensionSessionTicket:\n+\t\t\t// http://tools.ietf.org/html/rfc5077#section-3.2\n+\t\t\tm.ticketSupported = true\n+\t\t\tm.sessionTicket = data[:length]\n \t\t}\n \t\tdata = data[length:]\n \t}\n@@ -328,6 +353,7 @@ type serverHelloMsg struct {\n \tnextProtoNeg      bool\n \tnextProtos        []string\n \tocspStapling      bool\n+\tticketSupported   bool\n }\n \n func (m *serverHelloMsg) equal(i interface{}) bool {\n@@ -344,7 +370,8 @@ func (m *serverHelloMsg) equal(i interface{}) bool {\n \t\tm.compressionMethod == m1.compressionMethod &&\n \t\tm.nextProtoNeg == m1.nextProtoNeg &&\n \t\teqStrings(m.nextProtos, m1.nextProtos) &&\n-\t\tm.ocspStapling == m1.ocspStapling\n+\t\tm.ocspStapling == m1.ocspStapling &&\n+\t\tm.ticketSupported == m1.ticketSupported\n }\n \n func (m *serverHelloMsg) marshal() []byte {\n@@ -368,6 +395,9 @@ func (m *serverHelloMsg) marshal() []byte {\n \tif m.ocspStapling {\n \t\tnumExtensions++\n \t}\n+\tif m.ticketSupported {\n+\t\tnumExtensions++\n+\t}\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -416,6 +446,11 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\tz[1] = byte(extensionStatusRequest)\n \t\tz = z[4:]\n \t}\n+\tif m.ticketSupported {\n+\t\tz[0] = byte(extensionSessionTicket >> 8)\n+\t\tz[1] = byte(extensionSessionTicket)\n+\t\tz = z[4:]\n+\t}\n \n \tm.raw = x\n \n@@ -445,6 +480,7 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \tm.nextProtoNeg = false\n \tm.nextProtos = nil\n \tm.ocspStapling = false\n+\tm.ticketSupported = false\n \n \tif len(data) == 0 {\n \t\t// ServerHello is optionally followed by extension data\n@@ -474,21 +510,26 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\tswitch extension {\n \t\tcase extensionNextProtoNeg:\n \t\t\tm.nextProtoNeg = true\n-\t\t\td := data\n+\t\t\td := data[:length]\n \t\t\tfor len(d) > 0 {\n \t\t\t\tl := int(d[0])\n \t\t\t\td = d[1:]\n \t\t\t\tif l == 0 || l > len(d) {\n \t\t\t\t\treturn false\n \t\t\t\t}\n-\t\t\t\tm.nextProtos = append(m.nextProtos, string(d[0:l]))\n+\t\t\t\tm.nextProtos = append(m.nextProtos, string(d[:l]))\n \t\t\t\td = d[l:]\n \t\t\t}\n \t\tcase extensionStatusRequest:\n \t\t\tif length > 0 {\n \t\t\t\treturn false\n \t\t\t}\n \t\t\tm.ocspStapling = true\n+\t\tcase extensionSessionTicket:\n+\t\t\tif length > 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tm.ticketSupported = true\n \t\t}\n \t\tdata = data[length:]\n \t}\n@@ -1030,6 +1071,65 @@ func (m *certificateVerifyMsg) unmarshal(data []byte) bool {\n \treturn true\n }\n \n+type newSessionTicketMsg struct {\n+\traw    []byte\n+\tticket []byte\n+}\n+\n+func (m *newSessionTicketMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*newSessionTicketMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.ticket, m1.ticket)\n+}\n+\n+func (m *newSessionTicketMsg) marshal() (x []byte) {\n+\tif m.raw != nil {\n+\t\treturn m.raw\n+\t}\n+\n+\t// See http://tools.ietf.org/html/rfc5077#section-3.3\n+\tticketLen := len(m.ticket)\n+\tlength := 2 + 4 + ticketLen\n+\tx = make([]byte, 4+length)\n+\tx[0] = typeNewSessionTicket\n+\tx[1] = uint8(length >> 16)\n+\tx[2] = uint8(length >> 8)\n+\tx[3] = uint8(length)\n+\tx[8] = uint8(ticketLen >> 8)\n+\tx[9] = uint8(ticketLen)\n+\tcopy(x[10:], m.ticket)\n+\n+\tm.raw = x\n+\n+\treturn\n+}\n+\n+func (m *newSessionTicketMsg) unmarshal(data []byte) bool {\n+\tm.raw = data\n+\n+\tif len(data) < 10 {\n+\t\treturn false\n+\t}\n+\n+\tlength := uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])\n+\tif uint32(len(data))-4 != length {\n+\t\treturn false\n+\t}\n+\n+\tticketLen := int(data[8])<<8 + int(data[9])\n+\tif len(data)-10 != ticketLen {\n+\t\treturn false\n+\t}\n+\n+\tm.ticket = data[10:]\n+\n+\treturn true\n+}\n+\n func eqUint16s(x, y []uint16) bool {\n \tif len(x) != len(y) {\n \t\treturn false"}, {"sha": "3434bad9fba5756eed1308969e23efcee71439c1", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -22,6 +22,8 @@ var tests = []interface{}{\n \t&certificateStatusMsg{},\n \t&clientKeyExchangeMsg{},\n \t&nextProtoMsg{},\n+\t&newSessionTicketMsg{},\n+\t&sessionState{},\n }\n \n type testMessage interface {\n@@ -127,6 +129,12 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tfor i := range m.supportedCurves {\n \t\tm.supportedCurves[i] = uint16(rand.Intn(30000))\n \t}\n+\tif rand.Intn(10) > 5 {\n+\t\tm.ticketSupported = true\n+\t\tif rand.Intn(10) > 5 {\n+\t\t\tm.sessionTicket = randomBytes(rand.Intn(300), rand)\n+\t\t}\n+\t}\n \n \treturn reflect.ValueOf(m)\n }\n@@ -149,6 +157,13 @@ func (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t\t}\n \t}\n \n+\tif rand.Intn(10) > 5 {\n+\t\tm.ocspStapling = true\n+\t}\n+\tif rand.Intn(10) > 5 {\n+\t\tm.ticketSupported = true\n+\t}\n+\n \treturn reflect.ValueOf(m)\n }\n \n@@ -207,3 +222,22 @@ func (*nextProtoMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm.proto = randomString(rand.Intn(255), rand)\n \treturn reflect.ValueOf(m)\n }\n+\n+func (*newSessionTicketMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n+\tm := &newSessionTicketMsg{}\n+\tm.ticket = randomBytes(rand.Intn(4), rand)\n+\treturn reflect.ValueOf(m)\n+}\n+\n+func (*sessionState) Generate(rand *rand.Rand, size int) reflect.Value {\n+\ts := &sessionState{}\n+\ts.vers = uint16(rand.Intn(10000))\n+\ts.cipherSuite = uint16(rand.Intn(10000))\n+\ts.masterSecret = randomBytes(rand.Intn(100), rand)\n+\tnumCerts := rand.Intn(20)\n+\ts.certificates = make([][]byte, numCerts)\n+\tfor i := 0; i < numCerts; i++ {\n+\t\ts.certificates[i] = randomBytes(rand.Intn(10)+1, rand)\n+\t}\n+\treturn reflect.ValueOf(s)\n+}"}, {"sha": "d84103450204c5ca6551247ca382dd4181285cd7", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 384, "deletions": 141, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -13,31 +13,120 @@ import (\n \t\"io\"\n )\n \n+// serverHandshakeState contains details of a server handshake in progress.\n+// It's discarded once the handshake has completed.\n+type serverHandshakeState struct {\n+\tc               *Conn\n+\tclientHello     *clientHelloMsg\n+\thello           *serverHelloMsg\n+\tsuite           *cipherSuite\n+\tellipticOk      bool\n+\tsessionState    *sessionState\n+\tfinishedHash    finishedHash\n+\tmasterSecret    []byte\n+\tcertsFromClient [][]byte\n+}\n+\n+// serverHandshake performs a TLS handshake as a server.\n func (c *Conn) serverHandshake() error {\n \tconfig := c.config\n-\tmsg, err := c.readHandshake()\n+\n+\t// If this is the first server handshake, we generate a random key to\n+\t// encrypt the tickets with.\n+\tconfig.serverInitOnce.Do(func() {\n+\t\tif config.SessionTicketsDisabled {\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// If the key has already been set then we have nothing to do.\n+\t\tfor _, b := range config.SessionTicketKey {\n+\t\t\tif b != 0 {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif _, err := io.ReadFull(config.rand(), config.SessionTicketKey[:]); err != nil {\n+\t\t\tconfig.SessionTicketsDisabled = true\n+\t\t}\n+\t})\n+\n+\ths := serverHandshakeState{\n+\t\tc: c,\n+\t}\n+\tisResume, err := hs.readClientHello()\n \tif err != nil {\n \t\treturn err\n \t}\n-\tclientHello, ok := msg.(*clientHelloMsg)\n+\n+\t// For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3\n+\tif isResume {\n+\t\t// The client has included a session ticket and so we do an abbreviated handshake.\n+\t\tif err := hs.doResumeHandshake(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.establishKeys(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.sendFinished(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.readFinished(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tc.didResume = true\n+\t} else {\n+\t\t// The client didn't include a session ticket, or it wasn't\n+\t\t// valid so we do a full handshake.\n+\t\tif err := hs.doFullHandshake(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.establishKeys(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.readFinished(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.sendSessionTicket(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := hs.sendFinished(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tc.handshakeComplete = true\n+\n+\treturn nil\n+}\n+\n+// readClientHello reads a ClientHello message from the client and decides\n+// whether we will perform session resumption.\n+func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n+\tconfig := hs.c.config\n+\tc := hs.c\n+\n+\tmsg, err := c.readHandshake()\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tvar ok bool\n+\ths.clientHello, ok = msg.(*clientHelloMsg)\n \tif !ok {\n-\t\treturn c.sendAlert(alertUnexpectedMessage)\n+\t\treturn false, c.sendAlert(alertUnexpectedMessage)\n \t}\n-\tvers, ok := mutualVersion(clientHello.vers)\n+\tc.vers, ok = mutualVersion(hs.clientHello.vers)\n \tif !ok {\n-\t\treturn c.sendAlert(alertProtocolVersion)\n+\t\treturn false, c.sendAlert(alertProtocolVersion)\n \t}\n-\tc.vers = vers\n \tc.haveVers = true\n \n-\tfinishedHash := newFinishedHash(vers)\n-\tfinishedHash.Write(clientHello.marshal())\n+\ths.finishedHash = newFinishedHash(c.vers)\n+\ths.finishedHash.Write(hs.clientHello.marshal())\n \n-\thello := new(serverHelloMsg)\n+\ths.hello = new(serverHelloMsg)\n \n \tsupportedCurve := false\n Curves:\n-\tfor _, curve := range clientHello.supportedCurves {\n+\tfor _, curve := range hs.clientHello.supportedCurves {\n \t\tswitch curve {\n \t\tcase curveP256, curveP384, curveP521:\n \t\t\tsupportedCurve = true\n@@ -46,110 +135,173 @@ Curves:\n \t}\n \n \tsupportedPointFormat := false\n-\tfor _, pointFormat := range clientHello.supportedPoints {\n+\tfor _, pointFormat := range hs.clientHello.supportedPoints {\n \t\tif pointFormat == pointFormatUncompressed {\n \t\t\tsupportedPointFormat = true\n \t\t\tbreak\n \t\t}\n \t}\n-\n-\tellipticOk := supportedCurve && supportedPointFormat\n-\n-\tvar suite *cipherSuite\n-FindCipherSuite:\n-\tfor _, id := range clientHello.cipherSuites {\n-\t\tfor _, supported := range config.cipherSuites() {\n-\t\t\tif id == supported {\n-\t\t\t\tvar candidate *cipherSuite\n-\n-\t\t\t\tfor _, s := range cipherSuites {\n-\t\t\t\t\tif s.id == id {\n-\t\t\t\t\t\tcandidate = s\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif candidate == nil {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\t// Don't select a ciphersuite which we can't\n-\t\t\t\t// support for this client.\n-\t\t\t\tif candidate.elliptic && !ellipticOk {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tsuite = candidate\n-\t\t\t\tbreak FindCipherSuite\n-\t\t\t}\n-\t\t}\n-\t}\n+\ths.ellipticOk = supportedCurve && supportedPointFormat\n \n \tfoundCompression := false\n \t// We only support null compression, so check that the client offered it.\n-\tfor _, compression := range clientHello.compressionMethods {\n+\tfor _, compression := range hs.clientHello.compressionMethods {\n \t\tif compression == compressionNone {\n \t\t\tfoundCompression = true\n \t\t\tbreak\n \t\t}\n \t}\n \n-\tif suite == nil || !foundCompression {\n-\t\treturn c.sendAlert(alertHandshakeFailure)\n+\tif !foundCompression {\n+\t\treturn false, c.sendAlert(alertHandshakeFailure)\n \t}\n \n-\thello.vers = vers\n-\thello.cipherSuite = suite.id\n+\ths.hello.vers = c.vers\n \tt := uint32(config.time().Unix())\n-\thello.random = make([]byte, 32)\n-\thello.random[0] = byte(t >> 24)\n-\thello.random[1] = byte(t >> 16)\n-\thello.random[2] = byte(t >> 8)\n-\thello.random[3] = byte(t)\n-\t_, err = io.ReadFull(config.rand(), hello.random[4:])\n+\ths.hello.random = make([]byte, 32)\n+\ths.hello.random[0] = byte(t >> 24)\n+\ths.hello.random[1] = byte(t >> 16)\n+\ths.hello.random[2] = byte(t >> 8)\n+\ths.hello.random[3] = byte(t)\n+\t_, err = io.ReadFull(config.rand(), hs.hello.random[4:])\n \tif err != nil {\n-\t\treturn c.sendAlert(alertInternalError)\n+\t\treturn false, c.sendAlert(alertInternalError)\n+\t}\n+\ths.hello.compressionMethod = compressionNone\n+\tif len(hs.clientHello.serverName) > 0 {\n+\t\tc.serverName = hs.clientHello.serverName\n+\t}\n+\tif hs.clientHello.nextProtoNeg {\n+\t\ths.hello.nextProtoNeg = true\n+\t\ths.hello.nextProtos = config.NextProtos\n+\t}\n+\n+\tif hs.checkForResumption() {\n+\t\treturn true, nil\n+\t}\n+\n+\tfor _, id := range hs.clientHello.cipherSuites {\n+\t\tif hs.suite = c.tryCipherSuite(id, hs.ellipticOk); hs.suite != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif hs.suite == nil {\n+\t\treturn false, c.sendAlert(alertHandshakeFailure)\n+\t}\n+\n+\treturn false, nil\n+}\n+\n+// checkForResumption returns true if we should perform resumption on this connection.\n+func (hs *serverHandshakeState) checkForResumption() bool {\n+\tc := hs.c\n+\n+\tvar ok bool\n+\tif hs.sessionState, ok = c.decryptTicket(hs.clientHello.sessionTicket); !ok {\n+\t\treturn false\n+\t}\n+\n+\tif hs.sessionState.vers > hs.clientHello.vers {\n+\t\treturn false\n+\t}\n+\tif vers, ok := mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers {\n+\t\treturn false\n+\t}\n+\n+\tcipherSuiteOk := false\n+\t// Check that the client is still offering the ciphersuite in the session.\n+\tfor _, id := range hs.clientHello.cipherSuites {\n+\t\tif id == hs.sessionState.cipherSuite {\n+\t\t\tcipherSuiteOk = true\n+\t\t\tbreak\n+\t\t}\n \t}\n-\thello.compressionMethod = compressionNone\n-\tif clientHello.nextProtoNeg {\n-\t\thello.nextProtoNeg = true\n-\t\thello.nextProtos = config.NextProtos\n+\tif !cipherSuiteOk {\n+\t\treturn false\n \t}\n \n+\t// Check that we also support the ciphersuite from the session.\n+\ths.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, hs.ellipticOk)\n+\tif hs.suite == nil {\n+\t\treturn false\n+\t}\n+\n+\tsessionHasClientCerts := len(hs.sessionState.certificates) != 0\n+\tneedClientCerts := c.config.ClientAuth == RequireAnyClientCert || c.config.ClientAuth == RequireAndVerifyClientCert\n+\tif needClientCerts && !sessionHasClientCerts {\n+\t\treturn false\n+\t}\n+\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n+func (hs *serverHandshakeState) doResumeHandshake() error {\n+\tc := hs.c\n+\n+\ths.hello.cipherSuite = hs.suite.id\n+\t// We echo the client's session ID in the ServerHello to let it know\n+\t// that we're doing a resumption.\n+\ths.hello.sessionId = hs.clientHello.sessionId\n+\ths.finishedHash.Write(hs.hello.marshal())\n+\tc.writeRecord(recordTypeHandshake, hs.hello.marshal())\n+\n+\tif len(hs.sessionState.certificates) > 0 {\n+\t\tif _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\ths.masterSecret = hs.sessionState.masterSecret\n+\n+\treturn nil\n+}\n+\n+func (hs *serverHandshakeState) doFullHandshake() error {\n+\tconfig := hs.c.config\n+\tc := hs.c\n+\n \tif len(config.Certificates) == 0 {\n \t\treturn c.sendAlert(alertInternalError)\n \t}\n \tcert := &config.Certificates[0]\n-\tif len(clientHello.serverName) > 0 {\n-\t\tc.serverName = clientHello.serverName\n-\t\tcert = config.getCertificateForName(clientHello.serverName)\n+\tif len(hs.clientHello.serverName) > 0 {\n+\t\tcert = config.getCertificateForName(hs.clientHello.serverName)\n \t}\n \n-\tif clientHello.ocspStapling && len(cert.OCSPStaple) > 0 {\n-\t\thello.ocspStapling = true\n+\tif hs.clientHello.ocspStapling && len(cert.OCSPStaple) > 0 {\n+\t\ths.hello.ocspStapling = true\n \t}\n \n-\tfinishedHash.Write(hello.marshal())\n-\tc.writeRecord(recordTypeHandshake, hello.marshal())\n+\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !config.SessionTicketsDisabled\n+\ths.hello.cipherSuite = hs.suite.id\n+\ths.finishedHash.Write(hs.hello.marshal())\n+\tc.writeRecord(recordTypeHandshake, hs.hello.marshal())\n \n \tcertMsg := new(certificateMsg)\n \tcertMsg.certificates = cert.Certificate\n-\tfinishedHash.Write(certMsg.marshal())\n+\ths.finishedHash.Write(certMsg.marshal())\n \tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \n-\tif hello.ocspStapling {\n+\tif hs.hello.ocspStapling {\n \t\tcertStatus := new(certificateStatusMsg)\n \t\tcertStatus.statusType = statusTypeOCSP\n \t\tcertStatus.response = cert.OCSPStaple\n-\t\tfinishedHash.Write(certStatus.marshal())\n+\t\ths.finishedHash.Write(certStatus.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certStatus.marshal())\n \t}\n \n-\tkeyAgreement := suite.ka()\n-\tskx, err := keyAgreement.generateServerKeyExchange(config, cert, clientHello, hello)\n+\tkeyAgreement := hs.suite.ka()\n+\tskx, err := keyAgreement.generateServerKeyExchange(config, cert, hs.clientHello, hs.hello)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n \t}\n \tif skx != nil {\n-\t\tfinishedHash.Write(skx.marshal())\n+\t\ths.finishedHash.Write(skx.marshal())\n \t\tc.writeRecord(recordTypeHandshake, skx.marshal())\n \t}\n \n@@ -166,28 +318,29 @@ FindCipherSuite:\n \t\tif config.ClientCAs != nil {\n \t\t\tcertReq.certificateAuthorities = config.ClientCAs.Subjects()\n \t\t}\n-\t\tfinishedHash.Write(certReq.marshal())\n+\t\ths.finishedHash.Write(certReq.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certReq.marshal())\n \t}\n \n \thelloDone := new(serverHelloDoneMsg)\n-\tfinishedHash.Write(helloDone.marshal())\n+\ths.finishedHash.Write(helloDone.marshal())\n \tc.writeRecord(recordTypeHandshake, helloDone.marshal())\n \n \tvar pub *rsa.PublicKey // public key for client auth, if any\n \n-\tmsg, err = c.readHandshake()\n+\tmsg, err := c.readHandshake()\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\tvar ok bool\n \t// If we requested a client certificate, then the client must send a\n \t// certificate message, even if it's empty.\n \tif config.ClientAuth >= RequestClientCert {\n \t\tif certMsg, ok = msg.(*certificateMsg); !ok {\n \t\t\treturn c.sendAlert(alertHandshakeFailure)\n \t\t}\n-\t\tfinishedHash.Write(certMsg.marshal())\n+\t\ths.finishedHash.Write(certMsg.marshal())\n \n \t\tif len(certMsg.certificates) == 0 {\n \t\t\t// The client didn't actually send a certificate\n@@ -198,54 +351,9 @@ FindCipherSuite:\n \t\t\t}\n \t\t}\n \n-\t\tcerts := make([]*x509.Certificate, len(certMsg.certificates))\n-\t\tfor i, asn1Data := range certMsg.certificates {\n-\t\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n-\t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n-\t\t\t}\n-\t\t}\n-\n-\t\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n-\t\t\topts := x509.VerifyOptions{\n-\t\t\t\tRoots:         c.config.ClientCAs,\n-\t\t\t\tCurrentTime:   c.config.time(),\n-\t\t\t\tIntermediates: x509.NewCertPool(),\n-\t\t\t}\n-\n-\t\t\tfor i, cert := range certs {\n-\t\t\t\tif i == 0 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\topts.Intermediates.AddCert(cert)\n-\t\t\t}\n-\n-\t\t\tchains, err := certs[0].Verify(opts)\n-\t\t\tif err != nil {\n-\t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn errors.New(\"tls: failed to verify client's certificate: \" + err.Error())\n-\t\t\t}\n-\n-\t\t\tok := false\n-\t\t\tfor _, ku := range certs[0].ExtKeyUsage {\n-\t\t\t\tif ku == x509.ExtKeyUsageClientAuth {\n-\t\t\t\t\tok = true\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !ok {\n-\t\t\t\tc.sendAlert(alertHandshakeFailure)\n-\t\t\t\treturn errors.New(\"tls: client's certificate's extended key usage doesn't permit it to be used for client authentication\")\n-\t\t\t}\n-\n-\t\t\tc.verifiedChains = chains\n-\t\t}\n-\n-\t\tif len(certs) > 0 {\n-\t\t\tif pub, ok = certs[0].PublicKey.(*rsa.PublicKey); !ok {\n-\t\t\t\treturn c.sendAlert(alertUnsupportedCertificate)\n-\t\t\t}\n-\t\t\tc.peerCertificates = certs\n+\t\tpub, err = hs.processCertsFromClient(certMsg.certificates)\n+\t\tif err != nil {\n+\t\t\treturn err\n \t\t}\n \n \t\tmsg, err = c.readHandshake()\n@@ -259,7 +367,7 @@ FindCipherSuite:\n \tif !ok {\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n-\tfinishedHash.Write(ckx.marshal())\n+\ths.finishedHash.Write(ckx.marshal())\n \n \t// If we received a client cert in response to our certificate request message,\n \t// the client will send us a certificateVerifyMsg immediately after the\n@@ -278,48 +386,66 @@ FindCipherSuite:\n \t\t}\n \n \t\tdigest := make([]byte, 0, 36)\n-\t\tdigest = finishedHash.serverMD5.Sum(digest)\n-\t\tdigest = finishedHash.serverSHA1.Sum(digest)\n+\t\tdigest = hs.finishedHash.serverMD5.Sum(digest)\n+\t\tdigest = hs.finishedHash.serverSHA1.Sum(digest)\n \t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n \t\t\treturn errors.New(\"could not validate signature of connection nonces: \" + err.Error())\n \t\t}\n \n-\t\tfinishedHash.Write(certVerify.marshal())\n+\t\ths.finishedHash.Write(certVerify.marshal())\n \t}\n \n \tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, cert, ckx, c.vers)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n \t}\n+\ths.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.clientHello.random, hs.hello.random)\n+\n+\treturn nil\n+}\n+\n+func (hs *serverHandshakeState) establishKeys() error {\n+\tc := hs.c\n \n-\tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n-\t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, clientHello.random, hello.random, suite.macLen, suite.keyLen, suite.ivLen)\n+\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n+\t\tkeysFromMasterSecret(c.vers, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n \n-\tclientCipher := suite.cipher(clientKey, clientIV, true /* for reading */)\n-\tclientHash := suite.mac(c.vers, clientMAC)\n+\tclientCipher := hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n+\tclientHash := hs.suite.mac(c.vers, clientMAC)\n \tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n+\n+\tserverCipher := hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n+\tserverHash := hs.suite.mac(c.vers, serverMAC)\n+\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n+\n+\treturn nil\n+}\n+\n+func (hs *serverHandshakeState) readFinished() error {\n+\tc := hs.c\n+\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif err := c.error(); err != nil {\n \t\treturn err\n \t}\n \n-\tif hello.nextProtoNeg {\n-\t\tmsg, err = c.readHandshake()\n+\tif hs.hello.nextProtoNeg {\n+\t\tmsg, err := c.readHandshake()\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\tnextProto, ok := msg.(*nextProtoMsg)\n \t\tif !ok {\n \t\t\treturn c.sendAlert(alertUnexpectedMessage)\n \t\t}\n-\t\tfinishedHash.Write(nextProto.marshal())\n+\t\ths.finishedHash.Write(nextProto.marshal())\n \t\tc.clientProtocol = nextProto.proto\n \t}\n \n-\tmsg, err = c.readHandshake()\n+\tmsg, err := c.readHandshake()\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -328,25 +454,142 @@ FindCipherSuite:\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n \n-\tverify := finishedHash.clientSum(masterSecret)\n+\tverify := hs.finishedHash.clientSum(hs.masterSecret)\n \tif len(verify) != len(clientFinished.verifyData) ||\n \t\tsubtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 {\n \t\treturn c.sendAlert(alertHandshakeFailure)\n \t}\n \n-\tfinishedHash.Write(clientFinished.marshal())\n+\ths.finishedHash.Write(clientFinished.marshal())\n+\treturn nil\n+}\n+\n+func (hs *serverHandshakeState) sendSessionTicket() error {\n+\tif !hs.hello.ticketSupported {\n+\t\treturn nil\n+\t}\n+\n+\tc := hs.c\n+\tm := new(newSessionTicketMsg)\n+\n+\tvar err error\n+\tstate := sessionState{\n+\t\tvers:         c.vers,\n+\t\tcipherSuite:  hs.suite.id,\n+\t\tmasterSecret: hs.masterSecret,\n+\t\tcertificates: hs.certsFromClient,\n+\t}\n+\tm.ticket, err = c.encryptTicket(&state)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\ths.finishedHash.Write(m.marshal())\n+\tc.writeRecord(recordTypeHandshake, m.marshal())\n+\n+\treturn nil\n+}\n+\n+func (hs *serverHandshakeState) sendFinished() error {\n+\tc := hs.c\n \n-\tserverCipher := suite.cipher(serverKey, serverIV, false /* not for reading */)\n-\tserverHash := suite.mac(c.vers, serverMAC)\n-\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n \tfinished := new(finishedMsg)\n-\tfinished.verifyData = finishedHash.serverSum(masterSecret)\n+\tfinished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)\n+\ths.finishedHash.Write(finished.marshal())\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n-\tc.handshakeComplete = true\n-\tc.cipherSuite = suite.id\n+\tc.cipherSuite = hs.suite.id\n+\n+\treturn nil\n+}\n+\n+// processCertsFromClient takes a chain of client certificates either from a\n+// Certificates message or from a sessionState and verifies them. It returns\n+// the public key of the leaf certificate.\n+func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (*rsa.PublicKey, error) {\n+\tc := hs.c\n+\n+\ths.certsFromClient = certificates\n+\tcerts := make([]*x509.Certificate, len(certificates))\n+\tvar err error\n+\tfor i, asn1Data := range certificates {\n+\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n+\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\treturn nil, errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n+\t\t}\n+\t}\n+\n+\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n+\t\topts := x509.VerifyOptions{\n+\t\t\tRoots:         c.config.ClientCAs,\n+\t\t\tCurrentTime:   c.config.time(),\n+\t\t\tIntermediates: x509.NewCertPool(),\n+\t\t\tKeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},\n+\t\t}\n+\n+\t\tfor _, cert := range certs[1:] {\n+\t\t\topts.Intermediates.AddCert(cert)\n+\t\t}\n+\n+\t\tchains, err := certs[0].Verify(opts)\n+\t\tif err != nil {\n+\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\treturn nil, errors.New(\"tls: failed to verify client's certificate: \" + err.Error())\n+\t\t}\n+\n+\t\tok := false\n+\t\tfor _, ku := range certs[0].ExtKeyUsage {\n+\t\t\tif ku == x509.ExtKeyUsageClientAuth {\n+\t\t\t\tok = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !ok {\n+\t\t\tc.sendAlert(alertHandshakeFailure)\n+\t\t\treturn nil, errors.New(\"tls: client's certificate's extended key usage doesn't permit it to be used for client authentication\")\n+\t\t}\n+\n+\t\tc.verifiedChains = chains\n+\t}\n+\n+\tif len(certs) > 0 {\n+\t\tpub, ok := certs[0].PublicKey.(*rsa.PublicKey)\n+\t\tif !ok {\n+\t\t\treturn nil, c.sendAlert(alertUnsupportedCertificate)\n+\t\t}\n+\t\tc.peerCertificates = certs\n+\t\treturn pub, nil\n+\t}\n+\n+\treturn nil, nil\n+}\n+\n+// tryCipherSuite returns a cipherSuite with the given id if that cipher suite\n+// is acceptable to use.\n+func (c *Conn) tryCipherSuite(id uint16, ellipticOk bool) *cipherSuite {\n+\tfor _, supported := range c.config.cipherSuites() {\n+\t\tif id == supported {\n+\t\t\tvar candidate *cipherSuite\n+\n+\t\t\tfor _, s := range cipherSuites {\n+\t\t\t\tif s.id == id {\n+\t\t\t\t\tcandidate = s\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif candidate == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Don't select a ciphersuite which we can't\n+\t\t\t// support for this client.\n+\t\t\tif candidate.elliptic && !ellipticOk {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn candidate\n+\t\t}\n+\t}\n \n \treturn nil\n }"}, {"sha": "8ca3c2cf191a819f377d974d834cbd711ba91817", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 462, "deletions": 77, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -11,12 +11,15 @@ import (\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"flag\"\n+\t\"fmt\"\n \t\"io\"\n \t\"log\"\n \t\"math/big\"\n \t\"net\"\n+\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -80,13 +83,20 @@ func TestRejectBadProtocolVersion(t *testing.T) {\n }\n \n func TestNoSuiteOverlap(t *testing.T) {\n-\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{0xff00}, []uint8{0}, false, \"\", false, nil, nil}\n+\tclientHello := &clientHelloMsg{\n+\t\tvers:               0x0301,\n+\t\tcipherSuites:       []uint16{0xff00},\n+\t\tcompressionMethods: []uint8{0},\n+\t}\n \ttestClientHelloFailure(t, clientHello, alertHandshakeFailure)\n-\n }\n \n func TestNoCompressionOverlap(t *testing.T) {\n-\tclientHello := &clientHelloMsg{nil, 0x0301, nil, nil, []uint16{TLS_RSA_WITH_RC4_128_SHA}, []uint8{0xff}, false, \"\", false, nil, nil}\n+\tclientHello := &clientHelloMsg{\n+\t\tvers:               0x0301,\n+\t\tcipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n+\t\tcompressionMethods: []uint8{0xff},\n+\t}\n \ttestClientHelloFailure(t, clientHello, alertHandshakeFailure)\n }\n \n@@ -186,6 +196,11 @@ func TestHandshakeServerSNI(t *testing.T) {\n \ttestServerScript(t, \"SNI\", selectCertificateBySNIScript, testConfig, nil)\n }\n \n+func TestResumption(t *testing.T) {\n+\ttestServerScript(t, \"IssueTicket\", issueSessionTicketTest, testConfig, nil)\n+\ttestServerScript(t, \"Resume\", serverResumeTest, testConfig, nil)\n+}\n+\n type clientauthTest struct {\n \tname       string\n \tclientauth ClientAuthType\n@@ -203,55 +218,133 @@ func TestClientAuth(t *testing.T) {\n \t}\n }\n \n+// recordingConn is a net.Conn that records the traffic that passes through it.\n+// WriteTo can be used to produce Go code that contains the recorded traffic.\n+type recordingConn struct {\n+\tnet.Conn\n+\tlock             sync.Mutex\n+\tflows            [][]byte\n+\tcurrentlyReading bool\n+}\n+\n+func (r *recordingConn) Read(b []byte) (n int, err error) {\n+\tif n, err = r.Conn.Read(b); n == 0 {\n+\t\treturn\n+\t}\n+\tb = b[:n]\n+\n+\tr.lock.Lock()\n+\tdefer r.lock.Unlock()\n+\n+\tif l := len(r.flows); l == 0 || !r.currentlyReading {\n+\t\tbuf := make([]byte, len(b))\n+\t\tcopy(buf, b)\n+\t\tr.flows = append(r.flows, buf)\n+\t} else {\n+\t\tr.flows[l-1] = append(r.flows[l-1], b[:n]...)\n+\t}\n+\tr.currentlyReading = true\n+\treturn\n+}\n+\n+func (r *recordingConn) Write(b []byte) (n int, err error) {\n+\tif n, err = r.Conn.Write(b); n == 0 {\n+\t\treturn\n+\t}\n+\tb = b[:n]\n+\n+\tr.lock.Lock()\n+\tdefer r.lock.Unlock()\n+\n+\tif l := len(r.flows); l == 0 || r.currentlyReading {\n+\t\tbuf := make([]byte, len(b))\n+\t\tcopy(buf, b)\n+\t\tr.flows = append(r.flows, buf)\n+\t} else {\n+\t\tr.flows[l-1] = append(r.flows[l-1], b[:n]...)\n+\t}\n+\tr.currentlyReading = false\n+\treturn\n+}\n+\n+// WriteTo writes Go source code to w that contains the recorded traffic.\n+func (r *recordingConn) WriteTo(w io.Writer) {\n+\tfmt.Fprintf(w, \"var changeMe = [][]byte {\\n\")\n+\tfor _, buf := range r.flows {\n+\t\tfmt.Fprintf(w, \"\\t{\")\n+\t\tfor i, b := range buf {\n+\t\t\tif i%8 == 0 {\n+\t\t\t\tfmt.Fprintf(w, \"\\n\\t\\t\")\n+\t\t\t}\n+\t\t\tfmt.Fprintf(w, \"0x%02x, \", b)\n+\t\t}\n+\t\tfmt.Fprintf(w, \"\\n\\t},\\n\")\n+\t}\n+\tfmt.Fprintf(w, \"}\\n\")\n+}\n+\n var serve = flag.Bool(\"serve\", false, \"run a TLS server on :10443\")\n var testCipherSuites = flag.String(\"ciphersuites\",\n \t\"0x\"+strconv.FormatInt(int64(TLS_RSA_WITH_RC4_128_SHA), 16),\n \t\"cipher suites to accept in serving mode\")\n var testClientAuth = flag.Int(\"clientauth\", 0, \"value for tls.Config.ClientAuth\")\n \n-func TestRunServer(t *testing.T) {\n-\tif !*serve {\n-\t\treturn\n-\t}\n-\n+func GetTestConfig() *Config {\n+\tvar config = *testConfig\n \tsuites := strings.Split(*testCipherSuites, \",\")\n-\ttestConfig.CipherSuites = make([]uint16, len(suites))\n+\tconfig.CipherSuites = make([]uint16, len(suites))\n \tfor i := range suites {\n \t\tsuite, err := strconv.ParseUint(suites[i], 0, 64)\n \t\tif err != nil {\n \t\t\tpanic(err)\n \t\t}\n-\t\ttestConfig.CipherSuites[i] = uint16(suite)\n+\t\tconfig.CipherSuites[i] = uint16(suite)\n \t}\n \n-\ttestConfig.ClientAuth = ClientAuthType(*testClientAuth)\n+\tconfig.ClientAuth = ClientAuthType(*testClientAuth)\n+\treturn &config\n+}\n \n-\tl, err := Listen(\"tcp\", \":10443\", testConfig)\n+func TestRunServer(t *testing.T) {\n+\tif !*serve {\n+\t\treturn\n+\t}\n+\n+\tconfig := GetTestConfig()\n+\n+\tconst addr = \":10443\"\n+\tl, err := net.Listen(\"tcp\", addr)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\tlog.Printf(\"Now listening for connections on %s\", addr)\n \n \tfor {\n-\t\tc, err := l.Accept()\n+\t\ttcpConn, err := l.Accept()\n \t\tif err != nil {\n+\t\t\tlog.Printf(\"error accepting connection: %s\", err)\n+\t\t\tbreak\n+\t\t}\n+\n+\t\trecord := &recordingConn{\n+\t\t\tConn: tcpConn,\n+\t\t}\n+\n+\t\tconn := Server(record, config)\n+\t\tif err := conn.Handshake(); err != nil {\n \t\t\tlog.Printf(\"error from TLS handshake: %s\", err)\n \t\t\tbreak\n \t\t}\n \n-\t\t_, err = c.Write([]byte(\"hello, world\\n\"))\n+\t\t_, err = conn.Write([]byte(\"hello, world\\n\"))\n \t\tif err != nil {\n-\t\t\tlog.Printf(\"error from TLS: %s\", err)\n+\t\t\tlog.Printf(\"error from Write: %s\", err)\n \t\t\tcontinue\n \t\t}\n \n-\t\tst := c.(*Conn).ConnectionState()\n-\t\tif len(st.PeerCertificates) > 0 {\n-\t\t\tlog.Print(\"Handling request from client \", st.PeerCertificates[0].Subject.CommonName)\n-\t\t} else {\n-\t\t\tlog.Print(\"Handling request from anon client\")\n-\t\t}\n+\t\tconn.Close()\n \n-\t\tc.Close()\n+\t\trecord.WriteTo(os.Stdout)\n \t}\n }\n \n@@ -296,10 +389,8 @@ func loadPEMCert(in string) *x509.Certificate {\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in server mode:\n-//   % go test -run \"TestRunServer\" -serve\n-// and then:\n-//   % gnutls-cli --insecure --debug 100 -p 10443 localhost > /tmp/log 2>&1\n-//   % python parse-gnutls-cli-debug-log.py < /tmp/log\n+//   % go test -test.run \"TestRunServer\" -serve\n+// The recorded bytes are written to stdout.\n var rc4ServerScript = [][]byte{\n \t{\n \t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n@@ -961,21 +1052,37 @@ var sslv3ServerScript = [][]byte{\n \n var selectCertificateBySNIScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x6e, 0x01, 0x00, 0x00,\n-\t\t0x6a, 0x03, 0x01, 0x4f, 0x85, 0xc4, 0xc2, 0xb9,\n-\t\t0x39, 0x80, 0x91, 0x66, 0x65, 0x56, 0x8e, 0xdd,\n-\t\t0x48, 0xe9, 0xca, 0x34, 0x02, 0x3c, 0xaf, 0x0d,\n-\t\t0x73, 0xb5, 0x2a, 0x05, 0x6e, 0xbd, 0x5e, 0x8f,\n-\t\t0x38, 0xf9, 0xe5, 0x00, 0x00, 0x28, 0x00, 0x39,\n-\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n-\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n-\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n-\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n-\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n-\t\t0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x10, 0x00,\n-\t\t0x0e, 0x00, 0x00, 0x0b, 0x73, 0x6e, 0x69, 0x74,\n-\t\t0x65, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x00,\n-\t\t0x23, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0xed, 0x01, 0x00, 0x00,\n+\t\t0xe9, 0x03, 0x02, 0x50, 0x5a, 0x1c, 0x90, 0x2b,\n+\t\t0xc8, 0xf1, 0xd9, 0x4b, 0xd0, 0x18, 0x69, 0xed,\n+\t\t0x5a, 0xbd, 0x68, 0xf6, 0xf7, 0xe3, 0xf0, 0x6e,\n+\t\t0xd1, 0xcc, 0xf1, 0x2d, 0x94, 0xa4, 0x01, 0x63,\n+\t\t0x91, 0xbe, 0xd0, 0x00, 0x00, 0x66, 0xc0, 0x14,\n+\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n+\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n+\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n+\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n+\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n+\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n+\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n+\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n+\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n+\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n+\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n+\t\t0x59, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e, 0x00,\n+\t\t0x00, 0x0b, 0x73, 0x6e, 0x69, 0x74, 0x65, 0x73,\n+\t\t0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0b, 0x00,\n+\t\t0x04, 0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00,\n+\t\t0x34, 0x00, 0x32, 0x00, 0x0e, 0x00, 0x0d, 0x00,\n+\t\t0x19, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x18, 0x00,\n+\t\t0x09, 0x00, 0x0a, 0x00, 0x16, 0x00, 0x17, 0x00,\n+\t\t0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x14, 0x00,\n+\t\t0x15, 0x00, 0x04, 0x00, 0x05, 0x00, 0x12, 0x00,\n+\t\t0x13, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,\n+\t\t0x0f, 0x00, 0x10, 0x00, 0x11, 0x00, 0x0f, 0x00,\n+\t\t0x01, 0x01,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n@@ -1053,45 +1160,323 @@ var selectCertificateBySNIScript = [][]byte{\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x70, 0x1d, 0x34, 0x75, 0xa2,\n-\t\t0xe7, 0xe3, 0x2f, 0x3d, 0xc1, 0x1d, 0xca, 0x0b,\n-\t\t0xe3, 0x64, 0xb9, 0x1a, 0x00, 0x69, 0xc4, 0x14,\n-\t\t0x05, 0x07, 0x7e, 0xc3, 0x51, 0x43, 0x52, 0x66,\n-\t\t0xe3, 0xbd, 0xff, 0x1b, 0x1a, 0x6a, 0x84, 0xf2,\n-\t\t0x07, 0x24, 0xd7, 0x12, 0xa8, 0x58, 0xcf, 0x8a,\n-\t\t0x50, 0x30, 0xe8, 0xc8, 0xb2, 0xf9, 0x58, 0x1c,\n-\t\t0x56, 0x53, 0x76, 0x21, 0xe0, 0x03, 0x7f, 0x77,\n-\t\t0xa7, 0xf1, 0xad, 0x67, 0xd4, 0xe2, 0x8f, 0xa0,\n-\t\t0x58, 0x6c, 0xe0, 0x28, 0x59, 0xf3, 0xd1, 0x53,\n-\t\t0x2b, 0x21, 0xbd, 0xa3, 0x84, 0x31, 0x73, 0xbf,\n-\t\t0x84, 0x0f, 0x83, 0xf4, 0xc4, 0xd0, 0xe5, 0x3c,\n-\t\t0x2d, 0x3e, 0xf2, 0x8a, 0x1e, 0xe7, 0xe9, 0x1f,\n-\t\t0x12, 0x13, 0xad, 0x29, 0xd6, 0x0c, 0xc7, 0xc6,\n-\t\t0x05, 0x53, 0x7d, 0x5e, 0xc6, 0x92, 0x72, 0xba,\n-\t\t0xd2, 0x93, 0x8f, 0x53, 0x84, 0x87, 0x44, 0x05,\n-\t\t0x9f, 0x5d, 0x66, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xfc, 0x71,\n-\t\t0xaa, 0xa8, 0x37, 0xa8, 0xbd, 0x63, 0xb7, 0xbc,\n-\t\t0x95, 0xef, 0x0c, 0xcf, 0x39, 0x31, 0x93, 0xe6,\n-\t\t0x86, 0xbd, 0x3f, 0x56, 0x9d, 0xf0, 0xb2, 0xb5,\n-\t\t0xd1, 0xa7, 0xc6, 0x45, 0x89, 0x18, 0xfb, 0xa0,\n-\t\t0x7f, 0xc1,\n+\t\t0x82, 0x00, 0x80, 0x45, 0x6d, 0x68, 0x61, 0xb9,\n+\t\t0x1a, 0xe5, 0xeb, 0x67, 0x22, 0x3b, 0x87, 0x19,\n+\t\t0x52, 0x86, 0x31, 0x91, 0xee, 0xcd, 0x17, 0x75,\n+\t\t0xc6, 0x44, 0xaf, 0x23, 0xef, 0xd9, 0xfa, 0xd2,\n+\t\t0x0b, 0xa2, 0xbb, 0xbf, 0x8b, 0x4b, 0x34, 0x50,\n+\t\t0xf6, 0x2e, 0x05, 0x09, 0x7e, 0xbf, 0xb3, 0xa6,\n+\t\t0x10, 0xe3, 0xc3, 0x49, 0x55, 0xa8, 0xdf, 0x6c,\n+\t\t0xaa, 0xab, 0x11, 0x4c, 0x80, 0x0a, 0x45, 0xf8,\n+\t\t0x37, 0xbb, 0xd3, 0x18, 0x4e, 0xec, 0x51, 0xbf,\n+\t\t0x1a, 0xf6, 0x11, 0x1b, 0xcf, 0x2c, 0xaf, 0x5f,\n+\t\t0x0b, 0x52, 0x4e, 0x92, 0x0c, 0x7a, 0xb2, 0x5d,\n+\t\t0xe2, 0x1f, 0x83, 0xbe, 0xf5, 0xbf, 0x05, 0xbf,\n+\t\t0x99, 0xd6, 0x9c, 0x86, 0x47, 0x5e, 0xb4, 0xff,\n+\t\t0xe7, 0xac, 0xad, 0x1e, 0x3c, 0xaa, 0x91, 0x39,\n+\t\t0xca, 0xad, 0xc5, 0x54, 0x64, 0x7e, 0xc2, 0x8a,\n+\t\t0x48, 0xee, 0xb6, 0x4e, 0xf9, 0x33, 0x82, 0x52,\n+\t\t0xe8, 0xed, 0x48, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xc1, 0x2f,\n+\t\t0x34, 0x03, 0x2a, 0xf2, 0xfd, 0x83, 0x69, 0x23,\n+\t\t0x8c, 0x9e, 0x66, 0x3b, 0xbb, 0xd1, 0xab, 0xbb,\n+\t\t0x51, 0x89, 0x27, 0x88, 0x0f, 0x08, 0x3e, 0x00,\n+\t\t0xdc, 0xc7, 0x47, 0x82, 0x13, 0x34, 0xec, 0xca,\n+\t\t0x68, 0x6a,\n+\t},\n+\t{\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x24, 0xda, 0x61, 0x76, 0x9f, 0x7a,\n+\t\t0x8a, 0xd0, 0x5f, 0x9b, 0x3d, 0xa7, 0xd5, 0xdd,\n+\t\t0x95, 0x4b, 0xd4, 0x64, 0x2d, 0x2d, 0x6a, 0x98,\n+\t\t0x9e, 0xfe, 0x77, 0x76, 0xe3, 0x02, 0x05, 0x0c,\n+\t\t0xb2, 0xa6, 0x15, 0x82, 0x28, 0x25, 0xc5, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x21, 0x4e, 0x66, 0x2d, 0x50,\n+\t\t0x00, 0xa2, 0x44, 0x4d, 0xee, 0x5f, 0x81, 0x67,\n+\t\t0x21, 0x5d, 0x94, 0xc0, 0xfb, 0xdc, 0xbd, 0xf6,\n+\t\t0xa8, 0x32, 0x8e, 0x2c, 0x22, 0x58, 0x37, 0xb6,\n+\t\t0xa3, 0x1e, 0xf8, 0xdd, 0x83, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x16, 0x68, 0x3b, 0x3a, 0xd0, 0x1e, 0xc4,\n+\t\t0x5e, 0x97, 0x6a, 0x47, 0x38, 0xfe, 0x17, 0x8e,\n+\t\t0xc0, 0xb6, 0x4a, 0x94, 0x00, 0xb5, 0x91, 0xbf,\n+\t},\n+}\n+\n+var issueSessionTicketTest = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0xdd, 0x01, 0x00, 0x00,\n+\t\t0xd9, 0x03, 0x02, 0x50, 0x5a, 0x32, 0xb6, 0x36,\n+\t\t0x0e, 0x94, 0x63, 0x57, 0x93, 0xd7, 0x1e, 0xb2,\n+\t\t0xa7, 0xd3, 0x20, 0x24, 0x30, 0x3f, 0x46, 0xf9,\n+\t\t0xfe, 0x22, 0x02, 0xa1, 0xff, 0x57, 0xf8, 0x8f,\n+\t\t0x95, 0x4c, 0xdd, 0x00, 0x00, 0x66, 0xc0, 0x14,\n+\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n+\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n+\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n+\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n+\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n+\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n+\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n+\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n+\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n+\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n+\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n+\t\t0x49, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n+\t\t0x02, 0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00,\n+\t\t0x0e, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00,\n+\t\t0x0c, 0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00,\n+\t\t0x16, 0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00,\n+\t\t0x07, 0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00,\n+\t\t0x05, 0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00,\n+\t\t0x02, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00,\n+\t\t0x11, 0x00, 0x23, 0x00, 0x00, 0x00, 0x0f, 0x00,\n+\t\t0x01, 0x01,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x30, 0x02, 0x00, 0x00,\n+\t\t0x2c, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,\n+\t\t0x04, 0x00, 0x23, 0x00, 0x00, 0x16, 0x03, 0x01,\n+\t\t0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba, 0x00, 0x02,\n+\t\t0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82, 0x02, 0xb0,\n+\t\t0x30, 0x82, 0x02, 0x19, 0xa0, 0x03, 0x02, 0x01,\n+\t\t0x02, 0x02, 0x09, 0x00, 0x85, 0xb0, 0xbb, 0xa4,\n+\t\t0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x05, 0x05, 0x00, 0x30, 0x45, 0x31, 0x0b, 0x30,\n+\t\t0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n+\t\t0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,\n+\t\t0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d,\n+\t\t0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31,\n+\t\t0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a,\n+\t\t0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+\t\t0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69,\n+\t\t0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c,\n+\t\t0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x30,\n+\t\t0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39,\n+\t\t0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31, 0x31, 0x30,\n+\t\t0x34, 0x32, 0x34, 0x30, 0x39, 0x30, 0x39, 0x33,\n+\t\t0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41,\n+\t\t0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f, 0x6d, 0x65,\n+\t\t0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21,\n+\t\t0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65,\n+\t\t0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74,\n+\t\t0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74,\n+\t\t0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09,\n+\t\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t\t0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30,\n+\t\t0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xbb, 0x79,\n+\t\t0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf, 0x46, 0x10,\n+\t\t0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b, 0x07, 0x43,\n+\t\t0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a, 0x43, 0x85,\n+\t\t0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65, 0x4c, 0x2c,\n+\t\t0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4, 0x82, 0xe5,\n+\t\t0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62, 0xa5, 0x2c,\n+\t\t0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c, 0x7a, 0x56,\n+\t\t0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58, 0x7b, 0x26,\n+\t\t0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0, 0xc9, 0x21,\n+\t\t0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f, 0x5a, 0xbf,\n+\t\t0xef, 0x42, 0x71, 0x00, 0xfe, 0x18, 0x99, 0x07,\n+\t\t0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1, 0x04, 0x39,\n+\t\t0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9, 0x7c, 0xe3,\n+\t\t0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01, 0xcf, 0xaf,\n+\t\t0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d, 0xdb, 0xdb,\n+\t\t0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79, 0x02, 0x03,\n+\t\t0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7, 0x30, 0x81,\n+\t\t0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,\n+\t\t0x04, 0x16, 0x04, 0x14, 0xb1, 0xad, 0xe2, 0x85,\n+\t\t0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce, 0x23,\n+\t\t0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88, 0x39,\n+\t\t0x30, 0x75, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,\n+\t\t0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1, 0xad, 0xe2,\n+\t\t0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69, 0xce,\n+\t\t0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18, 0x88,\n+\t\t0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x82, 0x09, 0x00, 0x85,\n+\t\t0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30,\n+\t\t0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05,\n+\t\t0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,\n+\t\t0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n+\t\t0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,\n+\t\t0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b, 0xb1, 0x59,\n+\t\t0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0, 0x14, 0xd7,\n+\t\t0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5, 0x5a, 0x95,\n+\t\t0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae, 0x12, 0x66,\n+\t\t0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e, 0x60, 0xd3,\n+\t\t0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5, 0x25, 0x13,\n+\t\t0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30, 0x1d, 0xba,\n+\t\t0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7, 0xd7, 0x31,\n+\t\t0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78, 0xea, 0x50,\n+\t\t0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d, 0x5a, 0x5f,\n+\t\t0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75, 0x90, 0x96,\n+\t\t0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd, 0x98, 0x1f,\n+\t\t0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c, 0xa3, 0x1b,\n+\t\t0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57, 0xe9, 0x70,\n+\t\t0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b, 0x26, 0x6e,\n+\t\t0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7, 0xbd, 0xd9,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00,\n+\t\t0x00,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t0x82, 0x00, 0x80, 0x92, 0x3f, 0xcc, 0x4d, 0x2f,\n+\t\t0xb2, 0x12, 0xc4, 0xf5, 0x72, 0xf3, 0x5a, 0x3c,\n+\t\t0x5a, 0xbb, 0x99, 0x89, 0xe6, 0x21, 0x0f, 0xdf,\n+\t\t0xf3, 0xa3, 0xd0, 0xce, 0x76, 0x55, 0xfd, 0xec,\n+\t\t0x38, 0x80, 0xf0, 0x46, 0x0b, 0xfa, 0x61, 0x7c,\n+\t\t0xc2, 0xb5, 0xe2, 0x89, 0x7b, 0xeb, 0xcf, 0x3e,\n+\t\t0x97, 0xab, 0x72, 0xf6, 0xfd, 0xcf, 0x10, 0x82,\n+\t\t0x3a, 0x05, 0x55, 0x7c, 0x2d, 0x7f, 0x44, 0x38,\n+\t\t0x9d, 0xeb, 0xa4, 0x7e, 0x53, 0x35, 0xda, 0xe0,\n+\t\t0x7c, 0x24, 0x66, 0x42, 0x5d, 0x85, 0xcf, 0xa6,\n+\t\t0x98, 0x81, 0xec, 0x42, 0x94, 0x4e, 0x25, 0xb1,\n+\t\t0x64, 0xac, 0x89, 0x98, 0x74, 0xd2, 0xeb, 0x51,\n+\t\t0x5a, 0xb3, 0xbd, 0x14, 0xf6, 0xc6, 0xec, 0x0b,\n+\t\t0xdd, 0x8b, 0x89, 0xdc, 0xde, 0xf3, 0xd6, 0x62,\n+\t\t0xee, 0xe3, 0xcf, 0xf5, 0x39, 0x23, 0x46, 0x4f,\n+\t\t0xb8, 0xef, 0x14, 0x39, 0x06, 0x36, 0xad, 0x84,\n+\t\t0x42, 0xb9, 0xd7, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xa1, 0xf0,\n+\t\t0x68, 0xf5, 0x29, 0x7e, 0x78, 0xaa, 0xbd, 0x59,\n+\t\t0xdc, 0x32, 0xab, 0x8e, 0x25, 0x54, 0x64, 0x9e,\n+\t\t0x2b, 0x08, 0xf9, 0xb8, 0xe3, 0x89, 0x09, 0xa4,\n+\t\t0xfd, 0x05, 0x78, 0x59, 0xcb, 0x33, 0xfc, 0x66,\n+\t\t0xb5, 0x73,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x72, 0x04, 0x00, 0x00,\n+\t\t0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,\n+\t\t0xe8, 0x4b, 0xd1, 0xef, 0xba, 0xfc, 0x00, 0xd4,\n+\t\t0x2f, 0xf5, 0x6f, 0xba, 0xdc, 0xb7, 0xd7, 0x87,\n+\t\t0x59, 0x58, 0x05, 0x06, 0x36, 0x8f, 0x47, 0xc7,\n+\t\t0x9e, 0x4c, 0xf8, 0xb5, 0xd7, 0x55, 0x84, 0x64,\n+\t\t0x0b, 0x4c, 0x0b, 0xad, 0x8d, 0x9b, 0x79, 0x4d,\n+\t\t0xd7, 0x61, 0xf7, 0x2b, 0x89, 0x46, 0x2b, 0x52,\n+\t\t0x1a, 0x3f, 0x51, 0x58, 0xce, 0x59, 0x23, 0xef,\n+\t\t0x60, 0x55, 0x07, 0xc0, 0x46, 0x97, 0xad, 0x0a,\n+\t\t0xe3, 0x55, 0x10, 0x06, 0xff, 0x57, 0x0c, 0xb1,\n+\t\t0x49, 0xac, 0x80, 0xc6, 0xc3, 0x95, 0x5f, 0x12,\n+\t\t0xe2, 0xe5, 0xaa, 0x9f, 0x78, 0xc2, 0x20, 0x14,\n+\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x24, 0x47, 0x51, 0xf1, 0x13, 0xc8, 0xa6,\n+\t\t0xd2, 0x2c, 0xad, 0x35, 0xff, 0x53, 0xe2, 0x72,\n+\t\t0x01, 0xcb, 0x33, 0xcd, 0xf4, 0xa0, 0x9c, 0x03,\n+\t\t0x47, 0xfe, 0xcd, 0xc1, 0x46, 0x8d, 0x41, 0x5e,\n+\t\t0x54, 0xf7, 0xc3, 0x85, 0x2b, 0x2f, 0x17, 0x03,\n+\t\t0x01, 0x00, 0x21, 0xf4, 0xbf, 0x94, 0x3e, 0x93,\n+\t\t0x0b, 0x1b, 0x75, 0x3a, 0xd9, 0xd0, 0x57, 0x75,\n+\t\t0xf3, 0xa7, 0x82, 0xc9, 0x6b, 0x9e, 0x43, 0x98,\n+\t\t0x44, 0x9e, 0x9f, 0xad, 0x03, 0xa8, 0xb9, 0xa3,\n+\t\t0x0a, 0xd1, 0xc4, 0xb4, 0x15, 0x03, 0x01, 0x00,\n+\t\t0x16, 0xee, 0x57, 0xbd, 0xd3, 0xb7, 0x20, 0x29,\n+\t\t0xd1, 0x24, 0xe2, 0xdc, 0x24, 0xc3, 0x73, 0x86,\n+\t\t0x81, 0x8e, 0x40, 0xc3, 0x6e, 0x99, 0x9e,\n+\t},\n+}\n+\n+var serverResumeTest = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x01, 0x65, 0x01, 0x00, 0x01,\n+\t\t0x61, 0x03, 0x01, 0x50, 0x5a, 0x32, 0xe2, 0xde,\n+\t\t0x19, 0x5c, 0xb6, 0x51, 0x87, 0xa4, 0x30, 0x2e,\n+\t\t0x95, 0x26, 0xd6, 0xed, 0xbf, 0xbf, 0x24, 0xbb,\n+\t\t0xd1, 0x1a, 0x29, 0x9f, 0x37, 0xfd, 0xfb, 0xae,\n+\t\t0xc2, 0xba, 0x2b, 0x20, 0xb5, 0x7a, 0x00, 0x96,\n+\t\t0x92, 0x51, 0xfc, 0x41, 0x16, 0x29, 0xc0, 0x54,\n+\t\t0x5e, 0xa7, 0xa9, 0x1f, 0xf8, 0xbf, 0x79, 0xfa,\n+\t\t0x49, 0x5a, 0x15, 0x28, 0x72, 0x9a, 0x59, 0xf9,\n+\t\t0x9b, 0xc4, 0x3a, 0xa8, 0x00, 0x66, 0xc0, 0x14,\n+\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n+\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n+\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n+\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n+\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n+\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n+\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n+\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n+\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n+\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n+\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n+\t\t0xb1, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n+\t\t0x02, 0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00,\n+\t\t0x0e, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00,\n+\t\t0x0c, 0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00,\n+\t\t0x16, 0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00,\n+\t\t0x07, 0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00,\n+\t\t0x05, 0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00,\n+\t\t0x02, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00,\n+\t\t0x11, 0x00, 0x23, 0x00, 0x68, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xe8, 0x4b,\n+\t\t0xd1, 0xef, 0xba, 0xfc, 0x00, 0xd4, 0x2f, 0xf5,\n+\t\t0x6f, 0xba, 0xdc, 0xb7, 0xd7, 0x87, 0x59, 0x58,\n+\t\t0x05, 0x06, 0x36, 0x8f, 0x47, 0xc7, 0x9e, 0x4c,\n+\t\t0xf8, 0xb5, 0xd7, 0x55, 0x84, 0x64, 0x0b, 0x4c,\n+\t\t0x0b, 0xad, 0x8d, 0x9b, 0x79, 0x4d, 0xd7, 0x61,\n+\t\t0xf7, 0x2b, 0x89, 0x46, 0x2b, 0x52, 0x1a, 0x3f,\n+\t\t0x51, 0x58, 0xce, 0x59, 0x23, 0xef, 0x60, 0x55,\n+\t\t0x07, 0xc0, 0x46, 0x97, 0xad, 0x0a, 0xe3, 0x55,\n+\t\t0x10, 0x06, 0xff, 0x57, 0x0c, 0xb1, 0x49, 0xac,\n+\t\t0x80, 0xc6, 0xc3, 0x95, 0x5f, 0x12, 0xe2, 0xe5,\n+\t\t0xaa, 0x9f, 0x78, 0xc2, 0x20, 0x00, 0x0f, 0x00,\n+\t\t0x01, 0x01,\n+\t},\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x4a, 0x02, 0x00, 0x00,\n+\t\t0x46, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x20, 0xb5, 0x7a, 0x00, 0x96,\n+\t\t0x92, 0x51, 0xfc, 0x41, 0x16, 0x29, 0xc0, 0x54,\n+\t\t0x5e, 0xa7, 0xa9, 0x1f, 0xf8, 0xbf, 0x79, 0xfa,\n+\t\t0x49, 0x5a, 0x15, 0x28, 0x72, 0x9a, 0x59, 0xf9,\n+\t\t0x9b, 0xc4, 0x3a, 0xa8, 0x00, 0x05, 0x00, 0x14,\n+\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t0x00, 0x24, 0x2c, 0x86, 0xdd, 0x85, 0x21, 0xa7,\n+\t\t0xda, 0x25, 0xf5, 0x55, 0x62, 0x2d, 0x82, 0x6b,\n+\t\t0x9d, 0x67, 0x22, 0x28, 0xf4, 0x55, 0x33, 0xd0,\n+\t\t0x77, 0xc0, 0x9e, 0xb7, 0xf4, 0x96, 0x07, 0x8c,\n+\t\t0xf5, 0xea, 0x5b, 0x50, 0xa4, 0xb7,\n \t},\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x24, 0xb8, 0x6d, 0x9a, 0x90, 0x3c,\n-\t\t0x45, 0xe0, 0xff, 0x63, 0xba, 0xab, 0x3d, 0x7a,\n-\t\t0xa6, 0x49, 0x5a, 0x13, 0xdc, 0x0e, 0xa3, 0xba,\n-\t\t0x7f, 0x04, 0x19, 0x45, 0xfd, 0xfb, 0xbd, 0x00,\n-\t\t0xa3, 0xa7, 0x78, 0x81, 0x38, 0x9f, 0x10, 0x17,\n-\t\t0x03, 0x01, 0x00, 0x21, 0x43, 0xc3, 0x91, 0xb7,\n-\t\t0xbf, 0x50, 0x0b, 0x04, 0xb4, 0x5d, 0xc6, 0x20,\n-\t\t0x64, 0xb8, 0x01, 0x09, 0x25, 0x2c, 0x03, 0x30,\n-\t\t0xc0, 0x77, 0xc9, 0x5e, 0xe6, 0xe0, 0x99, 0xdc,\n-\t\t0xcd, 0x75, 0x9d, 0x51, 0x82, 0x15, 0x03, 0x01,\n-\t\t0x00, 0x16, 0x2d, 0x7a, 0x89, 0x7b, 0x36, 0x85,\n-\t\t0x2a, 0x93, 0xcb, 0x83, 0xa7, 0x2f, 0x9e, 0x91,\n-\t\t0xfc, 0xad, 0x57, 0xca, 0xf5, 0xbc, 0x13, 0x2f,\n+\t\t0x01, 0x00, 0x24, 0x15, 0x14, 0x9c, 0x21, 0xdd,\n+\t\t0x47, 0x61, 0x52, 0xf9, 0x22, 0x15, 0x55, 0x3c,\n+\t\t0xbd, 0xd7, 0xff, 0xf9, 0xbd, 0x84, 0xec, 0x97,\n+\t\t0x2d, 0x4e, 0xa9, 0x6a, 0xb9, 0x9b, 0x96, 0xc6,\n+\t\t0x9e, 0x5c, 0x77, 0xa8, 0x5d, 0x7a, 0x08,\n+\t},\n+\t{\n+\t\t0x17, 0x03, 0x01, 0x00, 0x21, 0x04, 0xab, 0x0f,\n+\t\t0x7c, 0x54, 0x20, 0xab, 0x34, 0xa3, 0x73, 0x92,\n+\t\t0xc5, 0xaa, 0xdd, 0x5b, 0xf5, 0x0c, 0xe4, 0x4f,\n+\t\t0xf1, 0x93, 0x07, 0xe5, 0xe8, 0x72, 0xc2, 0x03,\n+\t\t0x60, 0xfa, 0x64, 0x01, 0x00, 0x25, 0x15, 0x03,\n+\t\t0x01, 0x00, 0x16, 0xc7, 0xd9, 0xff, 0x67, 0xfc,\n+\t\t0x7a, 0xac, 0x8a, 0xe6, 0x23, 0xfe, 0x32, 0xbf,\n+\t\t0x84, 0xe1, 0xe2, 0xf5, 0x6a, 0xc8, 0xda, 0x30,\n+\t\t0x8f,\n \t},\n }\n "}, {"sha": "df1eaad0586316fb25fd7576eb63f7d101ae4385", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -106,10 +106,9 @@ var keyExpansionLabel = []byte(\"key expansion\")\n var clientFinishedLabel = []byte(\"client finished\")\n var serverFinishedLabel = []byte(\"server finished\")\n \n-// keysFromPreMasterSecret generates the connection keys from the pre master\n-// secret, given the lengths of the MAC key, cipher key and IV, as defined in\n-// RFC 2246, section 6.3.\n-func keysFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n+// masterFromPreMasterSecret generates the master secret from the pre-master\n+// secret. See http://tools.ietf.org/html/rfc5246#section-8.1\n+func masterFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte) []byte {\n \tprf := pRF10\n \tif version == versionSSL30 {\n \t\tprf = pRF30\n@@ -118,9 +117,21 @@ func keysFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serv\n \tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], clientRandom)\n \tcopy(seed[len(clientRandom):], serverRandom)\n-\tmasterSecret = make([]byte, masterSecretLength)\n+\tmasterSecret := make([]byte, masterSecretLength)\n \tprf(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n+\treturn masterSecret\n+}\n \n+// keysFromMasterSecret generates the connection keys from the master\n+// secret, given the lengths of the MAC key, cipher key and IV, as defined in\n+// RFC 2246, section 6.3.\n+func keysFromMasterSecret(version uint16, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n+\tprf := pRF10\n+\tif version == versionSSL30 {\n+\t\tprf = pRF30\n+\t}\n+\n+\tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], serverRandom)\n \tcopy(seed[len(serverRandom):], clientRandom)\n "}, {"sha": "ce6e36de8a1c1c06f3b8ef7ad050c8bedaa5d347", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -48,18 +48,23 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n \t\tin, _ := hex.DecodeString(test.preMasterSecret)\n \t\tclientRandom, _ := hex.DecodeString(test.clientRandom)\n \t\tserverRandom, _ := hex.DecodeString(test.serverRandom)\n-\t\tmaster, clientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromPreMasterSecret(test.version, in, clientRandom, serverRandom, test.macLen, test.keyLen, 0)\n-\t\tmasterString := hex.EncodeToString(master)\n+\n+\t\tmasterSecret := masterFromPreMasterSecret(test.version, in, clientRandom, serverRandom)\n+\t\tif s := hex.EncodeToString(masterSecret); s != test.masterSecret {\n+\t\t\tt.Errorf(\"#%d: bad master secret %s, want %s\", s, test.masterSecret)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tclientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromMasterSecret(test.version, masterSecret, clientRandom, serverRandom, test.macLen, test.keyLen, 0)\n \t\tclientMACString := hex.EncodeToString(clientMAC)\n \t\tserverMACString := hex.EncodeToString(serverMAC)\n \t\tclientKeyString := hex.EncodeToString(clientKey)\n \t\tserverKeyString := hex.EncodeToString(serverKey)\n-\t\tif masterString != test.masterSecret ||\n-\t\t\tclientMACString != test.clientMAC ||\n+\t\tif clientMACString != test.clientMAC ||\n \t\t\tserverMACString != test.serverMAC ||\n \t\t\tclientKeyString != test.clientKey ||\n \t\t\tserverKeyString != test.serverKey {\n-\t\t\tt.Errorf(\"#%d: got: (%s, %s, %s, %s, %s) want: (%s, %s, %s, %s, %s)\", i, masterString, clientMACString, serverMACString, clientKeyString, serverKeyString, test.masterSecret, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey)\n+\t\t\tt.Errorf(\"#%d: got: (%s, %s, %s, %s) want: (%s, %s, %s, %s)\", i, clientMACString, serverMACString, clientKeyString, serverKeyString, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey)\n \t\t}\n \t}\n }"}, {"sha": "e61c2185126c154536f391585e41374e928b14fe", "filename": "libgo/go/crypto/tls/root_test.go", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7463235f0e23c624d1911c9b15f531108cc5a6/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7463235f0e23c624d1911c9b15f531108cc5a6/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go?ref=0b7463235f0e23c624d1911c9b15f531108cc5a6", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tls\n-\n-import (\n-\t\"crypto/x509\"\n-\t\"runtime\"\n-\t\"testing\"\n-)\n-\n-var tlsServers = []string{\n-\t\"google.com\",\n-\t\"github.com\",\n-\t\"twitter.com\",\n-}\n-\n-func TestOSCertBundles(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Logf(\"skipping certificate tests in short mode\")\n-\t\treturn\n-\t}\n-\n-\tfor _, addr := range tlsServers {\n-\t\tconn, err := Dial(\"tcp\", addr+\":443\", &Config{ServerName: addr})\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"unable to verify %v: %v\", addr, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\terr = conn.Close()\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t}\n-}\n-\n-func TestCertHostnameVerifyWindows(t *testing.T) {\n-\tif runtime.GOOS != \"windows\" {\n-\t\treturn\n-\t}\n-\n-\tif testing.Short() {\n-\t\tt.Logf(\"skipping certificate tests in short mode\")\n-\t\treturn\n-\t}\n-\n-\tfor _, addr := range tlsServers {\n-\t\tcfg := &Config{ServerName: \"example.com\"}\n-\t\tconn, err := Dial(\"tcp\", addr+\":443\", cfg)\n-\t\tif err == nil {\n-\t\t\tconn.Close()\n-\t\t\tt.Errorf(\"should fail to verify for example.com: %v\", addr)\n-\t\t\tcontinue\n-\t\t}\n-\t\t_, ok := err.(x509.HostnameError)\n-\t\tif !ok {\n-\t\t\tt.Errorf(\"error type mismatch, got: %v\", err)\n-\t\t}\n-\t}\n-}"}, {"sha": "4cfc5a53ffeb1bff70cb3310ee0c5e6cd98221cb", "filename": "libgo/go/crypto/tls/ticket.go", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,182 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/hmac\"\n+\t\"crypto/sha256\"\n+\t\"crypto/subtle\"\n+\t\"errors\"\n+\t\"io\"\n+)\n+\n+// sessionState contains the information that is serialized into a session\n+// ticket in order to later resume a connection.\n+type sessionState struct {\n+\tvers         uint16\n+\tcipherSuite  uint16\n+\tmasterSecret []byte\n+\tcertificates [][]byte\n+}\n+\n+func (s *sessionState) equal(i interface{}) bool {\n+\ts1, ok := i.(*sessionState)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\tif s.vers != s1.vers ||\n+\t\ts.cipherSuite != s1.cipherSuite ||\n+\t\t!bytes.Equal(s.masterSecret, s1.masterSecret) {\n+\t\treturn false\n+\t}\n+\n+\tif len(s.certificates) != len(s1.certificates) {\n+\t\treturn false\n+\t}\n+\n+\tfor i := range s.certificates {\n+\t\tif !bytes.Equal(s.certificates[i], s1.certificates[i]) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+func (s *sessionState) marshal() []byte {\n+\tlength := 2 + 2 + 2 + len(s.masterSecret) + 2\n+\tfor _, cert := range s.certificates {\n+\t\tlength += 4 + len(cert)\n+\t}\n+\n+\tret := make([]byte, length)\n+\tx := ret\n+\tx[0] = byte(s.vers >> 8)\n+\tx[1] = byte(s.vers)\n+\tx[2] = byte(s.cipherSuite >> 8)\n+\tx[3] = byte(s.cipherSuite)\n+\tx[4] = byte(len(s.masterSecret) >> 8)\n+\tx[5] = byte(len(s.masterSecret))\n+\tx = x[6:]\n+\tcopy(x, s.masterSecret)\n+\tx = x[len(s.masterSecret):]\n+\n+\tx[0] = byte(len(s.certificates) >> 8)\n+\tx[1] = byte(len(s.certificates))\n+\tx = x[2:]\n+\n+\tfor _, cert := range s.certificates {\n+\t\tx[0] = byte(len(cert) >> 24)\n+\t\tx[1] = byte(len(cert) >> 16)\n+\t\tx[2] = byte(len(cert) >> 8)\n+\t\tx[3] = byte(len(cert))\n+\t\tcopy(x[4:], cert)\n+\t\tx = x[4+len(cert):]\n+\t}\n+\n+\treturn ret\n+}\n+\n+func (s *sessionState) unmarshal(data []byte) bool {\n+\tif len(data) < 8 {\n+\t\treturn false\n+\t}\n+\n+\ts.vers = uint16(data[0])<<8 | uint16(data[1])\n+\ts.cipherSuite = uint16(data[2])<<8 | uint16(data[3])\n+\tmasterSecretLen := int(data[4])<<8 | int(data[5])\n+\tdata = data[6:]\n+\tif len(data) < masterSecretLen {\n+\t\treturn false\n+\t}\n+\n+\ts.masterSecret = data[:masterSecretLen]\n+\tdata = data[masterSecretLen:]\n+\n+\tif len(data) < 2 {\n+\t\treturn false\n+\t}\n+\n+\tnumCerts := int(data[0])<<8 | int(data[1])\n+\tdata = data[2:]\n+\n+\ts.certificates = make([][]byte, numCerts)\n+\tfor i := range s.certificates {\n+\t\tif len(data) < 4 {\n+\t\t\treturn false\n+\t\t}\n+\t\tcertLen := int(data[0])<<24 | int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n+\t\tdata = data[4:]\n+\t\tif certLen < 0 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif len(data) < certLen {\n+\t\t\treturn false\n+\t\t}\n+\t\ts.certificates[i] = data[:certLen]\n+\t\tdata = data[certLen:]\n+\t}\n+\n+\tif len(data) > 0 {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n+func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) {\n+\tserialized := state.marshal()\n+\tencrypted := make([]byte, aes.BlockSize+len(serialized)+sha256.Size)\n+\tiv := encrypted[:aes.BlockSize]\n+\tmacBytes := encrypted[len(encrypted)-sha256.Size:]\n+\n+\tif _, err := io.ReadFull(c.config.rand(), iv); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tblock, err := aes.NewCipher(c.config.SessionTicketKey[:16])\n+\tif err != nil {\n+\t\treturn nil, errors.New(\"tls: failed to create cipher while encrypting ticket: \" + err.Error())\n+\t}\n+\tcipher.NewCTR(block, iv).XORKeyStream(encrypted[aes.BlockSize:], serialized)\n+\n+\tmac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])\n+\tmac.Write(encrypted[:len(encrypted)-sha256.Size])\n+\tmac.Sum(macBytes[:0])\n+\n+\treturn encrypted, nil\n+}\n+\n+func (c *Conn) decryptTicket(encrypted []byte) (*sessionState, bool) {\n+\tif len(encrypted) < aes.BlockSize+sha256.Size {\n+\t\treturn nil, false\n+\t}\n+\n+\tiv := encrypted[:aes.BlockSize]\n+\tmacBytes := encrypted[len(encrypted)-sha256.Size:]\n+\n+\tmac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])\n+\tmac.Write(encrypted[:len(encrypted)-sha256.Size])\n+\texpected := mac.Sum(nil)\n+\n+\tif subtle.ConstantTimeCompare(macBytes, expected) != 1 {\n+\t\treturn nil, false\n+\t}\n+\n+\tblock, err := aes.NewCipher(c.config.SessionTicketKey[:16])\n+\tif err != nil {\n+\t\treturn nil, false\n+\t}\n+\tciphertext := encrypted[aes.BlockSize : len(encrypted)-sha256.Size]\n+\tplaintext := ciphertext\n+\tcipher.NewCTR(block, iv).XORKeyStream(plaintext, ciphertext)\n+\n+\tstate := new(sessionState)\n+\tok := state.unmarshal(plaintext)\n+\treturn state, ok\n+}"}, {"sha": "80f852edf7ba9d80cf1ca00518b0681588da9a36", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -146,10 +146,16 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)\n \t\treturn\n \t}\n \n-\tkeyDERBlock, _ := pem.Decode(keyPEMBlock)\n-\tif keyDERBlock == nil {\n-\t\terr = errors.New(\"crypto/tls: failed to parse key PEM data\")\n-\t\treturn\n+\tvar keyDERBlock *pem.Block\n+\tfor {\n+\t\tkeyDERBlock, keyPEMBlock = pem.Decode(keyPEMBlock)\n+\t\tif keyDERBlock == nil {\n+\t\t\terr = errors.New(\"crypto/tls: failed to parse key PEM data\")\n+\t\t\treturn\n+\t\t}\n+\t\tif keyDERBlock.Type != \"CERTIFICATE\" {\n+\t\t\tbreak\n+\t\t}\n \t}\n \n \t// OpenSSL 0.9.8 generates PKCS#1 private keys by default, while"}, {"sha": "5df43c385fd8d073272cdd2ef2e60c686ac34f35", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var certPEM = `-----BEGIN CERTIFICATE-----\n+MIIB0zCCAX2gAwIBAgIJAI/M7BYjwB+uMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n+aWRnaXRzIFB0eSBMdGQwHhcNMTIwOTEyMjE1MjAyWhcNMTUwOTEyMjE1MjAyWjBF\n+MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n+ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANLJ\n+hPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wok/4xIA+ui35/MmNa\n+rtNuC+BdZ1tMuVCPFZcCAwEAAaNQME4wHQYDVR0OBBYEFJvKs8RfJaXTH08W+SGv\n+zQyKn0H8MB8GA1UdIwQYMBaAFJvKs8RfJaXTH08W+SGvzQyKn0H8MAwGA1UdEwQF\n+MAMBAf8wDQYJKoZIhvcNAQEFBQADQQBJlffJHybjDGxRMqaRmDhX0+6v02TUKZsW\n+r5QuVbpQhH6u+0UgcW0jp9QwpxoPTLTWGXEWBBBurxFwiCBhkQ+V\n+-----END CERTIFICATE-----\n+`\n+\n+var keyPEM = `-----BEGIN RSA PRIVATE KEY-----\n+MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo\n+k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G\n+6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N\n+MQIhAPW+eyZo7ay3lMz1V01WVjNKK9QSn1MJlb06h/LuYv9FAiEA25WPedKgVyCW\n+SmUwbPw8fnTcpqDWE3yTO3vKcebqMSsCIBF3UmVue8YU3jybC3NxuXq3wNm34R8T\n+xVLHwDXh/6NJAiEAl2oHGGLz64BuAfjKrqwz7qMYr9HCLIe/YsoWq/olzScCIQDi\n+D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==\n+-----END RSA PRIVATE KEY-----\n+`\n+\n+func TestX509KeyPair(t *testing.T) {\n+\t_, err := X509KeyPair([]byte(keyPEM+certPEM), []byte(keyPEM+certPEM))\n+\tif err != nil {\n+\t\tt.Errorf(\"Failed to load key followed by cert: %s\", err)\n+\t}\n+\n+\t_, err = X509KeyPair([]byte(certPEM+keyPEM), []byte(certPEM+keyPEM))\n+\tif err != nil {\n+\t\tt.Errorf(\"Failed to load cert followed by key: %s\", err)\n+\t\tprintln(err.Error())\n+\t}\n+}"}, {"sha": "21f62e5d76bdfb85f57c072b07553c21201be4a0", "filename": "libgo/go/crypto/x509/pem_decrypt.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+// RFC 1423 describes the encryption of PEM blocks. The algorithm used to\n+// generate a key from the password was derived by looking at the OpenSSL\n+// implementation.\n+\n+import (\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/des\"\n+\t\"crypto/md5\"\n+\t\"encoding/hex\"\n+\t\"encoding/pem\"\n+\t\"errors\"\n+\t\"strings\"\n+)\n+\n+// rfc1423Algos represents how to create a block cipher for a decryption mode.\n+type rfc1423Algo struct {\n+\tcipherFunc func([]byte) (cipher.Block, error)\n+\tkeySize    int\n+}\n+\n+// deriveKey uses a key derivation function to stretch the password into a key\n+// with the number of bits our cipher requires. This algorithm was derived from\n+// the OpenSSL source.\n+func (c rfc1423Algo) deriveKey(password, salt []byte) []byte {\n+\thash := md5.New()\n+\tout := make([]byte, c.keySize)\n+\tvar digest []byte\n+\n+\tfor i := 0; i < len(out); i += len(digest) {\n+\t\thash.Reset()\n+\t\thash.Write(digest)\n+\t\thash.Write(password)\n+\t\thash.Write(salt)\n+\t\tdigest = hash.Sum(digest[:0])\n+\t\tcopy(out[i:], digest)\n+\t}\n+\n+\treturn out\n+}\n+\n+// rfc1423Algos is a mapping of encryption algorithm to an rfc1423Algo that can\n+// create block ciphers for that mode.\n+var rfc1423Algos = map[string]rfc1423Algo{\n+\t\"DES-CBC\":      {des.NewCipher, 8},\n+\t\"DES-EDE3-CBC\": {des.NewTripleDESCipher, 24},\n+\t\"AES-128-CBC\":  {aes.NewCipher, 16},\n+\t\"AES-192-CBC\":  {aes.NewCipher, 24},\n+\t\"AES-256-CBC\":  {aes.NewCipher, 32},\n+}\n+\n+// IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n+func IsEncryptedPEMBlock(b *pem.Block) bool {\n+\t_, ok := b.Headers[\"DEK-Info\"]\n+\treturn ok\n+}\n+\n+// IncorrectPasswordError is returned when an incorrect password is detected.\n+var IncorrectPasswordError = errors.New(\"x509: decryption password incorrect\")\n+\n+// DecryptPEMBlock takes a password encrypted PEM block and the password used to\n+// encrypt it and returns a slice of decrypted DER encoded bytes. It inspects\n+// the DEK-Info header to determine the algorithm used for decryption. If no\n+// DEK-Info header is present, an error is returned. If an incorrect password\n+// is detected an IncorrectPasswordError is returned.\n+func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error) {\n+\tdek, ok := b.Headers[\"DEK-Info\"]\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: no DEK-Info header in block\")\n+\t}\n+\n+\tidx := strings.Index(dek, \",\")\n+\tif idx == -1 {\n+\t\treturn nil, errors.New(\"x509: malformed DEK-Info header\")\n+\t}\n+\n+\tmode, hexIV := dek[:idx], dek[idx+1:]\n+\tiv, err := hex.DecodeString(hexIV)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(iv) < 8 {\n+\t\treturn nil, errors.New(\"x509: not enough bytes in IV\")\n+\t}\n+\n+\tciph, ok := rfc1423Algos[mode]\n+\tif !ok {\n+\t\treturn nil, errors.New(\"x509: unknown encryption mode\")\n+\t}\n+\n+\t// Based on the OpenSSL implementation. The salt is the first 8 bytes\n+\t// of the initialization vector.\n+\tkey := ciph.deriveKey(password, iv[:8])\n+\tblock, err := ciph.cipherFunc(key)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdata := make([]byte, len(b.Bytes))\n+\tdec := cipher.NewCBCDecrypter(block, iv)\n+\tdec.CryptBlocks(data, b.Bytes)\n+\n+\t// Blocks are padded using a scheme where the last n bytes of padding are all\n+\t// equal to n. It can pad from 1 to 8 bytes inclusive. See RFC 1423.\n+\t// For example:\n+\t//\t[x y z 2 2]\n+\t//\t[x y 7 7 7 7 7 7 7]\n+\t// If we detect a bad padding, we assume it is an invalid password.\n+\tdlen := len(data)\n+\tif dlen == 0 {\n+\t\treturn nil, errors.New(\"x509: invalid padding\")\n+\t}\n+\tlast := data[dlen-1]\n+\tif dlen < int(last) {\n+\t\treturn nil, IncorrectPasswordError\n+\t}\n+\tif last == 0 || last > 8 {\n+\t\treturn nil, IncorrectPasswordError\n+\t}\n+\tfor _, val := range data[dlen-int(last):] {\n+\t\tif val != last {\n+\t\t\treturn nil, IncorrectPasswordError\n+\t\t}\n+\t}\n+\n+\treturn data[:dlen-int(last)], nil\n+}"}, {"sha": "2cb99836eae040d9057105211f4b6db5ea3d502f", "filename": "libgo/go/crypto/x509/pem_decrypt_test.go", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"encoding/pem\"\n+\t\"testing\"\n+)\n+\n+func TestDecrypt(t *testing.T) {\n+\tfor _, data := range testData {\n+\t\tblock, rest := pem.Decode(data.pemData)\n+\t\tif len(rest) > 0 {\n+\t\t\tt.Error(data.kind, \"extra data\")\n+\t\t}\n+\t\tder, err := DecryptPEMBlock(block, data.password)\n+\t\tif err != nil {\n+\t\t\tt.Error(data.kind, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif _, err := ParsePKCS1PrivateKey(der); err != nil {\n+\t\t\tt.Error(data.kind, \"Invalid private key\")\n+\t\t}\n+\t}\n+}\n+\n+var testData = []struct {\n+\tkind     string\n+\tpassword []byte\n+\tpemData  []byte\n+}{\n+\t{\n+\t\tkind:     \"DES-CBC\",\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: DES-CBC,34F09A4FC8DE22B5\n+\n+WXxy8kbZdiZvANtKvhmPBLV7eVFj2A5z6oAxvI9KGyhG0ZK0skfnt00C24vfU7m5\n+ICXeoqP67lzJ18xCzQfHjDaBNs53DSDT+Iz4e8QUep1xQ30+8QKX2NA2coee3nwc\n+6oM1cuvhNUDemBH2i3dKgMVkfaga0zQiiOq6HJyGSncCMSruQ7F9iWEfRbFcxFCx\n+qtHb1kirfGKEtgWTF+ynyco6+2gMXNu70L7nJcnxnV/RLFkHt7AUU1yrclxz7eZz\n+XOH9VfTjb52q/I8Suozq9coVQwg4tXfIoYUdT//O+mB7zJb9HI9Ps77b9TxDE6Gm\n+4C9brwZ3zg2vqXcwwV6QRZMtyll9rOpxkbw6NPlpfBqkc3xS51bbxivbO/Nve4KD\n+r12ymjFNF4stXCfJnNqKoZ50BHmEEUDu5Wb0fpVn82XrGw7CYc4iug==\n+-----END RSA PRIVATE KEY-----`),\n+\t},\n+\t{\n+\t\tkind:     \"DES-EDE3-CBC\",\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: DES-EDE3-CBC,C1F4A6A03682C2C7\n+\n+0JqVdBEH6iqM7drTkj+e2W/bE3LqakaiWhb9WUVonFkhyu8ca/QzebY3b5gCvAZQ\n+YwBvDcT/GHospKqPx+cxDHJNsUASDZws6bz8ZXWJGwZGExKzr0+Qx5fgXn44Ms3x\n+8g1ENFuTXtxo+KoNK0zuAMAqp66Llcds3Fjl4XR18QaD0CrVNAfOdgATWZm5GJxk\n+Fgx5f84nT+/ovvreG+xeOzWgvtKo0UUZVrhGOgfKLpa57adumcJ6SkUuBtEFpZFB\n+ldw5w7WC7d13x2LsRkwo8ZrDKgIV+Y9GNvhuCCkTzNP0V3gNeJpd201HZHR+9n3w\n+3z0VjR/MGqsfcy1ziEWMNOO53At3zlG6zP05aHMnMcZoVXadEK6L1gz++inSSDCq\n+gI0UJP4e3JVB7AkgYymYAwiYALAkoEIuanxoc50njJk=\n+-----END RSA PRIVATE KEY-----`),\n+\t},\n+\t{\n+\t\tkind:     \"AES-128-CBC\",\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: AES-128-CBC,D4492E793FC835CC038A728ED174F78A\n+\n+EyfQSzXSjv6BaNH+NHdXRlkHdimpF9izWlugVJAPApgXrq5YldPe2aGIOFXyJ+QE\n+ZIG20DYqaPzJRjTEbPNZ6Es0S2JJ5yCpKxwJuDkgJZKtF39Q2i36JeGbSZQIuWJE\n+GZbBpf1jDH/pr0iGonuAdl2PCCZUiy+8eLsD2tyviHUkFLOB+ykYoJ5t8ngZ/B6D\n+33U43LLb7+9zD4y3Q9OVHqBFGyHcxCY9+9Qh4ZnFp7DTf6RY5TNEvE3s4g6aDpBs\n+3NbvRVvYTgs8K9EPk4K+5R+P2kD8J8KvEIGxVa1vz8QoCJ/jr7Ka2rvNgPCex5/E\n+080LzLHPCrXKdlr/f50yhNWq08ZxMWQFkui+FDHPDUaEELKAXV8/5PDxw80Rtybo\n+AVYoCVIbZXZCuCO81op8UcOgEpTtyU5Lgh3Mw5scQL0=\n+-----END RSA PRIVATE KEY-----`),\n+\t},\n+\t{\n+\t\tkind:     \"AES-192-CBC\",\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: AES-192-CBC,E2C9FB02BCA23ADE1829F8D8BC5F5369\n+\n+cqVslvHqDDM6qwU6YjezCRifXmKsrgEev7ng6Qs7UmDJOpHDgJQZI9fwMFUhIyn5\n+FbCu1SHkLMW52Ld3CuEqMnzWMlhPrW8tFvUOrMWPYSisv7nNq88HobZEJcUNL2MM\n+Y15XmHW6IJwPqhKyLHpWXyOCVEh4ODND2nV15PCoi18oTa475baxSk7+1qH7GuIs\n+Rb7tshNTMqHbCpyo9Rn3UxeFIf9efdl8YLiMoIqc7J8E5e9VlbeQSdLMQOgDAQJG\n+ReUtTw8exmKsY4gsSjhkg5uiw7/ZB1Ihto0qnfQJgjGc680qGkT1d6JfvOfeYAk6\n+xn5RqS/h8rYAYm64KnepfC9vIujo4NqpaREDmaLdX5MJPQ+SlytITQvgUsUq3q/t\n+Ss85xjQEZH3hzwjQqdJvmA4hYP6SUjxYpBM+02xZ1Xw=\n+-----END RSA PRIVATE KEY-----`),\n+\t},\n+\t{\n+\t\tkind:     \"AES-256-CBC\",\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: AES-256-CBC,8E7ED5CD731902CE938957A886A5FFBD\n+\n+4Mxr+KIzRVwoOP0wwq6caSkvW0iS+GE2h2Ov/u+n9ZTMwL83PRnmjfjzBgfRZLVf\n+JFPXxUK26kMNpIdssNnqGOds+DhB+oSrsNKoxgxSl5OBoYv9eJTVYm7qOyAFIsjr\n+DRKAcjYCmzfesr7PVTowwy0RtHmYwyXMGDlAzzZrEvaiySFFmMyKKvtoavwaFoc7\n+Pz3RZScwIuubzTGJ1x8EzdffYOsdCa9Mtgpp3L136+23dOd6L/qK2EG2fzrJSHs/\n+2XugkleBFSMKzEp9mxXKRfa++uidQvMZTFLDK9w5YjrRvMBo/l2BoZIsq0jAIE1N\n+sv5Z/KwlX+3MDEpPQpUwGPlGGdLnjI3UZ+cjgqBcoMiNc6HfgbBgYJSU6aDSHuCk\n+clCwByxWkBNgJ2GrkwNrF26v+bGJJJNR4SKouY1jQf0=\n+-----END RSA PRIVATE KEY-----`),\n+\t},\n+}"}, {"sha": "8c3b65f80784d2d2f85cee957efeb7bc005211b5", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -28,7 +28,7 @@ func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \t\treturn nil, err\n \t}\n \tswitch {\n-\tcase privKey.Algo.Algorithm.Equal(oidRSA):\n+\tcase privKey.Algo.Algorithm.Equal(oidPublicKeyRSA):\n \t\tkey, err = ParsePKCS1PrivateKey(privKey.PrivateKey)\n \t\tif err != nil {\n \t\t\treturn nil, errors.New(\"crypto/x509: failed to parse RSA private key embedded in PKCS#8: \" + err.Error())"}, {"sha": "677927a3b6335fc9bb657d1be3faf0d1b959be2e", "filename": "libgo/go/crypto/x509/root_plan9.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build plan9\n+\n+package x509\n+\n+import \"io/ioutil\"\n+\n+// Possible certificate files; stop after finding one.\n+var certFiles = []string{\n+\t\"/sys/lib/tls/ca.pem\",\n+}\n+\n+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n+\treturn nil, nil\n+}\n+\n+func initSystemRoots() {\n+\troots := NewCertPool()\n+\tfor _, file := range certFiles {\n+\t\tdata, err := ioutil.ReadFile(file)\n+\t\tif err == nil {\n+\t\t\troots.AppendCertsFromPEM(data)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tsystemRoots = roots\n+}"}, {"sha": "756732f7d4ffb8f74962302b5ad6a3c60a94de2a", "filename": "libgo/go/crypto/x509/root_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build plan9 darwin,!cgo\n+// +build darwin,!cgo\n \n package x509\n "}, {"sha": "96ca57b420d0bf9cecbc48897178c81afff6e034", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -98,9 +98,13 @@ func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e\n // checkChainSSLServerPolicy checks that the certificate chain in chainCtx is valid for\n // use as a certificate chain for a SSL/TLS server.\n func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContext, opts *VerifyOptions) error {\n+\tservernamep, err := syscall.UTF16PtrFromString(opts.DNSName)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tsslPara := &syscall.SSLExtraCertChainPolicyPara{\n \t\tAuthType:   syscall.AUTHTYPE_SERVER,\n-\t\tServerName: syscall.StringToUTF16Ptr(opts.DNSName),\n+\t\tServerName: servernamep,\n \t}\n \tsslPara.Size = uint32(unsafe.Sizeof(*sslPara))\n \n@@ -110,7 +114,7 @@ func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContex\n \tpara.Size = uint32(unsafe.Sizeof(*para))\n \n \tstatus := syscall.CertChainPolicyStatus{}\n-\terr := syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, para, &status)\n+\terr = syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, para, &status)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "68929c7bb680f34475c1b3c9531203d91aad93b8", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -27,6 +27,9 @@ const (\n \t// TooManyIntermediates results when a path length constraint is\n \t// violated.\n \tTooManyIntermediates\n+\t// IncompatibleUsage results when the certificate's key usage indicates\n+\t// that it may only be used for a different purpose.\n+\tIncompatibleUsage\n )\n \n // CertificateInvalidError results when an odd error occurs. Users of this\n@@ -46,6 +49,8 @@ func (e CertificateInvalidError) Error() string {\n \t\treturn \"x509: a root or intermediate certificate is not authorized to sign in this domain\"\n \tcase TooManyIntermediates:\n \t\treturn \"x509: too many intermediates for path length constraint\"\n+\tcase IncompatibleUsage:\n+\t\treturn \"x509: certificate specifies an incompatible key usage\"\n \t}\n \treturn \"x509: unknown error\"\n }\n@@ -84,6 +89,11 @@ type VerifyOptions struct {\n \tIntermediates *CertPool\n \tRoots         *CertPool // if nil, the system roots are used\n \tCurrentTime   time.Time // if zero, the current time is used\n+\t// KeyUsage specifies which Extended Key Usage values are acceptable.\n+\t// An empty list means ExtKeyUsageServerAuth. Key usage is considered a\n+\t// constraint down the chain which mirrors Windows CryptoAPI behaviour,\n+\t// but not the spec. To accept any key usage, include ExtKeyUsageAny.\n+\tKeyUsages []ExtKeyUsage\n }\n \n const (\n@@ -174,7 +184,35 @@ func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e\n \t\t}\n \t}\n \n-\treturn c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts)\n+\tcandidateChains, err := c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tkeyUsages := opts.KeyUsages\n+\tif len(keyUsages) == 0 {\n+\t\tkeyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}\n+\t}\n+\n+\t// If any key usage is acceptable then we're done.\n+\tfor _, usage := range keyUsages {\n+\t\tif usage == ExtKeyUsageAny {\n+\t\t\tchains = candidateChains\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfor _, candidate := range candidateChains {\n+\t\tif checkChainForKeyUsage(candidate, keyUsages) {\n+\t\t\tchains = append(chains, candidate)\n+\t\t}\n+\t}\n+\n+\tif len(chains) == 0 {\n+\t\terr = CertificateInvalidError{c, IncompatibleUsage}\n+\t}\n+\n+\treturn\n }\n \n func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate {\n@@ -300,3 +338,56 @@ func (c *Certificate) VerifyHostname(h string) error {\n \n \treturn HostnameError{c, h}\n }\n+\n+func checkChainForKeyUsage(chain []*Certificate, keyUsages []ExtKeyUsage) bool {\n+\tusages := make([]ExtKeyUsage, len(keyUsages))\n+\tcopy(usages, keyUsages)\n+\n+\tif len(chain) == 0 {\n+\t\treturn false\n+\t}\n+\n+\tusagesRemaining := len(usages)\n+\n+\t// We walk down the list and cross out any usages that aren't supported\n+\t// by each certificate. If we cross out all the usages, then the chain\n+\t// is unacceptable.\n+\n+\tfor i := len(chain) - 1; i >= 0; i-- {\n+\t\tcert := chain[i]\n+\t\tif len(cert.ExtKeyUsage) == 0 && len(cert.UnknownExtKeyUsage) == 0 {\n+\t\t\t// The certificate doesn't have any extended key usage specified.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor _, usage := range cert.ExtKeyUsage {\n+\t\t\tif usage == ExtKeyUsageAny {\n+\t\t\t\t// The certificate is explicitly good for any usage.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tconst invalidUsage ExtKeyUsage = -1\n+\n+\tNextRequestedUsage:\n+\t\tfor i, requestedUsage := range usages {\n+\t\t\tif requestedUsage == invalidUsage {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, usage := range cert.ExtKeyUsage {\n+\t\t\t\tif requestedUsage == usage {\n+\t\t\t\t\tcontinue NextRequestedUsage\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tusages[i] = invalidUsage\n+\t\t\tusagesRemaining--\n+\t\t\tif usagesRemaining == 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn true\n+}"}, {"sha": "510a119ff7c07c4e7c01c8492222115ea78ece0a", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -21,6 +21,7 @@ type verifyTest struct {\n \tcurrentTime   int64\n \tdnsName       string\n \tsystemSkip    bool\n+\tkeyUsages     []ExtKeyUsage\n \n \terrorCallback  func(*testing.T, int, error) bool\n \texpectedChains [][]string\n@@ -113,6 +114,38 @@ var verifyTests = []verifyTest{\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n+\t{\n+\t\t// The default configuration should reject an S/MIME chain.\n+\t\tleaf:        smimeLeaf,\n+\t\troots:       []string{smimeIntermediate},\n+\t\tcurrentTime: 1339436154,\n+\n+\t\t// Key usage not implemented for Windows yet.\n+\t\tsystemSkip:    true,\n+\t\terrorCallback: expectUsageError,\n+\t},\n+\t{\n+\t\tleaf:        smimeLeaf,\n+\t\troots:       []string{smimeIntermediate},\n+\t\tcurrentTime: 1339436154,\n+\t\tkeyUsages:   []ExtKeyUsage{ExtKeyUsageServerAuth},\n+\n+\t\t// Key usage not implemented for Windows yet.\n+\t\tsystemSkip:    true,\n+\t\terrorCallback: expectUsageError,\n+\t},\n+\t{\n+\t\tleaf:        smimeLeaf,\n+\t\troots:       []string{smimeIntermediate},\n+\t\tcurrentTime: 1339436154,\n+\t\tkeyUsages:   []ExtKeyUsage{ExtKeyUsageEmailProtection},\n+\n+\t\t// Key usage not implemented for Windows yet.\n+\t\tsystemSkip: true,\n+\t\texpectedChains: [][]string{\n+\t\t\t{\"Ryan Hurst\", \"GlobalSign PersonalSign 2 CA - G2\"},\n+\t\t},\n+\t},\n }\n \n func expectHostnameError(t *testing.T, i int, err error) (ok bool) {\n@@ -131,6 +164,14 @@ func expectExpired(t *testing.T, i int, err error) (ok bool) {\n \treturn true\n }\n \n+func expectUsageError(t *testing.T, i int, err error) (ok bool) {\n+\tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != IncompatibleUsage {\n+\t\tt.Errorf(\"#%d: error was not IncompatibleUsage: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n func expectAuthorityUnknown(t *testing.T, i int, err error) (ok bool) {\n \tif _, ok := err.(UnknownAuthorityError); !ok {\n \t\tt.Errorf(\"#%d: error was not UnknownAuthorityError: %s\", i, err)\n@@ -157,6 +198,7 @@ func testVerify(t *testing.T, useSystemRoots bool) {\n \t\t\tIntermediates: NewCertPool(),\n \t\t\tDNSName:       test.dnsName,\n \t\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n+\t\t\tKeyUsages:     test.keyUsages,\n \t\t}\n \n \t\tif !useSystemRoots {\n@@ -433,3 +475,58 @@ O3NJo2pXh5Tl1njFmUNj403gdy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6V\n um0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh\n NOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n -----END CERTIFICATE-----`\n+\n+const smimeLeaf = `-----BEGIN CERTIFICATE-----\n+MIIFBjCCA+6gAwIBAgISESFvrjT8XcJTEe6rBlPptILlMA0GCSqGSIb3DQEBBQUA\n+MFQxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMSowKAYD\n+VQQDEyFHbG9iYWxTaWduIFBlcnNvbmFsU2lnbiAyIENBIC0gRzIwHhcNMTIwMTIz\n+MTYzNjU5WhcNMTUwMTIzMTYzNjU5WjCBlDELMAkGA1UEBhMCVVMxFjAUBgNVBAgT\n+DU5ldyBIYW1zcGhpcmUxEzARBgNVBAcTClBvcnRzbW91dGgxGTAXBgNVBAoTEEds\n+b2JhbFNpZ24sIEluYy4xEzARBgNVBAMTClJ5YW4gSHVyc3QxKDAmBgkqhkiG9w0B\n+CQEWGXJ5YW4uaHVyc3RAZ2xvYmFsc2lnbi5jb20wggEiMA0GCSqGSIb3DQEBAQUA\n+A4IBDwAwggEKAoIBAQC4ASSTvavmsFQAob60ukSSwOAL9nT/s99ltNUCAf5fPH5j\n+NceMKxaQse2miOmRRIXaykcq1p/TbI70Ztce38r2mbOwqDHHPVi13GxJEyUXWgaR\n+BteDMu5OGyWNG1kchVsGWpbstT0Z4v0md5m1BYFnxB20ebJyOR2lXDxsFK28nnKV\n++5eMj76U8BpPQ4SCH7yTMG6y0XXsB3cCrBKr2o3TOYgEKv+oNnbaoMt3UxMt9nSf\n+9jyIshjqfnT5Aew3CUNMatO55g5FXXdIukAweg1YSb1ls05qW3sW00T3d7dQs9/7\n+NuxCg/A2elmVJSoy8+MLR8JSFEf/aMgjO/TyLg/jAgMBAAGjggGPMIIBizAOBgNV\n+HQ8BAf8EBAMCBaAwTQYDVR0gBEYwRDBCBgorBgEEAaAyASgKMDQwMgYIKwYBBQUH\n+AgEWJmh0dHBzOi8vd3d3Lmdsb2JhbHNpZ24uY29tL3JlcG9zaXRvcnkvMCQGA1Ud\n+EQQdMBuBGXJ5YW4uaHVyc3RAZ2xvYmFsc2lnbi5jb20wCQYDVR0TBAIwADAdBgNV\n+HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwQwYDVR0fBDwwOjA4oDagNIYyaHR0\n+cDovL2NybC5nbG9iYWxzaWduLmNvbS9ncy9nc3BlcnNvbmFsc2lnbjJnMi5jcmww\n+VQYIKwYBBQUHAQEESTBHMEUGCCsGAQUFBzAChjlodHRwOi8vc2VjdXJlLmdsb2Jh\n+bHNpZ24uY29tL2NhY2VydC9nc3BlcnNvbmFsc2lnbjJnMi5jcnQwHQYDVR0OBBYE\n+FFWiECe0/L72eVYqcWYnLV6SSjzhMB8GA1UdIwQYMBaAFD8V0m18L+cxnkMKBqiU\n+bCw7xe5lMA0GCSqGSIb3DQEBBQUAA4IBAQAhQi6hLPeudmf3IBF4IDzCvRI0FaYd\n+BKfprSk/H0PDea4vpsLbWpA0t0SaijiJYtxKjlM4bPd+2chb7ejatDdyrZIzmDVy\n+q4c30/xMninGKokpYA11/Ve+i2dvjulu65qasrtQRGybAuuZ67lrp/K3OMFgjV5N\n+C3AHYLzvNU4Dwc4QQ1BaMOg6KzYSrKbABRZajfrpC9uiePsv7mDIXLx/toBPxWNl\n+a5vJm5DrZdn7uHdvBCE6kMykbOLN5pmEK0UIlwKh6Qi5XD0pzlVkEZliFkBMJgub\n+d/eF7xeg7TKPWC5xyOFp9SdMolJM7LTC3wnSO3frBAev+q/nGs9Xxyvs\n+-----END CERTIFICATE-----`\n+\n+const smimeIntermediate = `-----BEGIN CERTIFICATE-----\n+MIIEFjCCAv6gAwIBAgILBAAAAAABL07hL1IwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n+A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n+b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw0xMTA0MTMxMDAw\n+MDBaFw0xOTA0MTMxMDAwMDBaMFQxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n+YWxTaWduIG52LXNhMSowKAYDVQQDEyFHbG9iYWxTaWduIFBlcnNvbmFsU2lnbiAy\n+IENBIC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDBa0H5Nez4\n+En3dIlFpX7e5E0YndxQ74xOBbz7kdBd+DLX0LOQMjVPU3DAgKL9ujhH+ZhHkURbH\n+3X/94TQSUL/z2JjsaQvS0NqyZXHhM5eeuquzOJRzEQ8+odETzHg2G0Erv7yjSeww\n+gkwDWDJnYUDlOjYTDUEG6+i+8Mn425reo4I0E277wD542kmVWeW7+oHv5dZo9e1Q\n+yWwiKTEP6BEQVVSBgThXMG4traSSDRUt3T1eQTZx5EObpiBEBO4OTqiBTJfg4vEI\n+YgkXzKLpnfszTB6YMDpR9/QS6p3ANB3kfAb+t6udSO3WCst0DGrwHDLBFGDR4UeY\n+T5KGGnI7cWL7AgMBAAGjgeUwgeIwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQI\n+MAYBAf8CAQAwHQYDVR0OBBYEFD8V0m18L+cxnkMKBqiUbCw7xe5lMEcGA1UdIARA\n+MD4wPAYEVR0gADA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5nbG9iYWxzaWdu\n+LmNvbS9yZXBvc2l0b3J5LzAzBgNVHR8ELDAqMCigJqAkhiJodHRwOi8vY3JsLmds\n+b2JhbHNpZ24ubmV0L3Jvb3QuY3JsMB8GA1UdIwQYMBaAFGB7ZhpFDZfKiVAvfQTN\n+NKj//P1LMA0GCSqGSIb3DQEBBQUAA4IBAQBDc3nMpMxJMQMcYUCB3+C73UpvwDE8\n+eCOr7t2F/uaQKKcyqqstqLZc6vPwI/rcE9oDHugY5QEjQzIBIEaTnN6P0vege2IX\n+eCOr7t2F/uaQKKcyqqstqLZc6vPwI/rcE9oDHugY5QEjQzIBIEaTnN6P0vege2IX\n+YEvTWbWwGdPytDFPYIl3/6OqNSXSnZ7DxPcdLJq2uyiga8PB/TTIIHYkdM2+1DE0\n+7y3rH/7TjwDVD7SLu5/SdOfKskuMPTjOEvz3K161mymW06klVhubCIWOro/Gx1Q2\n+2FQOZ7/2k4uYoOdBTSlb8kTAuzZNgIE0rB2BIYCTz/P6zZIKW0ogbRSH\n+-----END CERTIFICATE-----`"}, {"sha": "cfefbc5acec73f2999b22274b1d7b31b312e5085", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 287, "deletions": 61, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -9,6 +9,8 @@ import (\n \t\"bytes\"\n \t\"crypto\"\n \t\"crypto/dsa\"\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"crypto/x509/pkix\"\n@@ -106,6 +108,8 @@ type dsaSignature struct {\n \tR, S *big.Int\n }\n \n+type ecdsaSignature dsaSignature\n+\n type validity struct {\n \tNotBefore, NotAfter time.Time\n }\n@@ -133,6 +137,10 @@ const (\n \tSHA512WithRSA\n \tDSAWithSHA1\n \tDSAWithSHA256\n+\tECDSAWithSHA1\n+\tECDSAWithSHA256\n+\tECDSAWithSHA384\n+\tECDSAWithSHA512\n )\n \n type PublicKeyAlgorithm int\n@@ -141,6 +149,7 @@ const (\n \tUnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n \tRSA\n \tDSA\n+\tECDSA\n )\n \n // OIDs for signature algorithms\n@@ -160,6 +169,12 @@ const (\n // dsaWithSha1 OBJECT IDENTIFIER ::= {\n //    iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 3 } \n //\n+// RFC 3279 2.2.3 ECDSA Signature Algorithm\n+// \n+// ecdsa-with-SHA1 OBJECT IDENTIFIER ::= {\n+// \t  iso(1) member-body(2) us(840) ansi-x962(10045)\n+//    signatures(4) ecdsa-with-SHA1(1)}\n+//\n //\n // RFC 4055 5 PKCS #1 Version 1.5\n // \n@@ -176,15 +191,30 @@ const (\n //    joint-iso-ccitt(2) country(16) us(840) organization(1) gov(101)\n //    csor(3) algorithms(4) id-dsa-with-sha2(3) 2}\n //\n+// RFC 5758 3.2 ECDSA Signature Algorithm\n+//\n+// ecdsa-with-SHA256 OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n+//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2 }\n+//\n+// ecdsa-with-SHA384 OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n+//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 3 }\n+//\n+// ecdsa-with-SHA512 OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n+//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 4 }\n+\n var (\n-\toidSignatureMD2WithRSA    = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 2}\n-\toidSignatureMD5WithRSA    = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 4}\n-\toidSignatureSHA1WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 5}\n-\toidSignatureSHA256WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}\n-\toidSignatureSHA384WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 12}\n-\toidSignatureSHA512WithRSA = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 13}\n-\toidSignatureDSAWithSHA1   = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 3}\n-\toidSignatureDSAWithSHA256 = asn1.ObjectIdentifier{2, 16, 840, 1, 101, 4, 3, 2}\n+\toidSignatureMD2WithRSA      = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 2}\n+\toidSignatureMD5WithRSA      = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 4}\n+\toidSignatureSHA1WithRSA     = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 5}\n+\toidSignatureSHA256WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}\n+\toidSignatureSHA384WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 12}\n+\toidSignatureSHA512WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 13}\n+\toidSignatureDSAWithSHA1     = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 3}\n+\toidSignatureDSAWithSHA256   = asn1.ObjectIdentifier{2, 16, 840, 1, 101, 4, 3, 2}\n+\toidSignatureECDSAWithSHA1   = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 1}\n+\toidSignatureECDSAWithSHA256 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 2}\n+\toidSignatureECDSAWithSHA384 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 3}\n+\toidSignatureECDSAWithSHA512 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 4}\n )\n \n func getSignatureAlgorithmFromOID(oid asn1.ObjectIdentifier) SignatureAlgorithm {\n@@ -205,6 +235,14 @@ func getSignatureAlgorithmFromOID(oid asn1.ObjectIdentifier) SignatureAlgorithm\n \t\treturn DSAWithSHA1\n \tcase oid.Equal(oidSignatureDSAWithSHA256):\n \t\treturn DSAWithSHA256\n+\tcase oid.Equal(oidSignatureECDSAWithSHA1):\n+\t\treturn ECDSAWithSHA1\n+\tcase oid.Equal(oidSignatureECDSAWithSHA256):\n+\t\treturn ECDSAWithSHA256\n+\tcase oid.Equal(oidSignatureECDSAWithSHA384):\n+\t\treturn ECDSAWithSHA384\n+\tcase oid.Equal(oidSignatureECDSAWithSHA512):\n+\t\treturn ECDSAWithSHA512\n \t}\n \treturn UnknownSignatureAlgorithm\n }\n@@ -218,21 +256,81 @@ func getSignatureAlgorithmFromOID(oid asn1.ObjectIdentifier) SignatureAlgorithm\n //\n // id-dsa OBJECT IDENTIFIER ::== { iso(1) member-body(2) us(840)\n //    x9-57(10040) x9cm(4) 1 }\n+//\n+// RFC 5480, 2.1.1 Unrestricted Algorithm Identifier and Parameters\n+//\n+// id-ecPublicKey OBJECT IDENTIFIER ::= {\n+//       iso(1) member-body(2) us(840) ansi-X9-62(10045) keyType(2) 1 }\n var (\n-\toidPublicKeyRsa = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 1}\n-\toidPublicKeyDsa = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 1}\n+\toidPublicKeyRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 1}\n+\toidPublicKeyDSA   = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 1}\n+\toidPublicKeyECDSA = asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}\n )\n \n func getPublicKeyAlgorithmFromOID(oid asn1.ObjectIdentifier) PublicKeyAlgorithm {\n \tswitch {\n-\tcase oid.Equal(oidPublicKeyRsa):\n+\tcase oid.Equal(oidPublicKeyRSA):\n \t\treturn RSA\n-\tcase oid.Equal(oidPublicKeyDsa):\n+\tcase oid.Equal(oidPublicKeyDSA):\n \t\treturn DSA\n+\tcase oid.Equal(oidPublicKeyECDSA):\n+\t\treturn ECDSA\n \t}\n \treturn UnknownPublicKeyAlgorithm\n }\n \n+// RFC 5480, 2.1.1.1. Named Curve\n+//\n+// secp224r1 OBJECT IDENTIFIER ::= {\n+//   iso(1) identified-organization(3) certicom(132) curve(0) 33 }\n+//\n+// secp256r1 OBJECT IDENTIFIER ::= {\n+//   iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3)\n+//   prime(1) 7 }\n+//\n+// secp384r1 OBJECT IDENTIFIER ::= {\n+//   iso(1) identified-organization(3) certicom(132) curve(0) 34 }\n+//\n+// secp521r1 OBJECT IDENTIFIER ::= {\n+//   iso(1) identified-organization(3) certicom(132) curve(0) 35 }\n+//\n+// NB: secp256r1 is equivalent to prime256v1\n+var (\n+\toidNamedCurveP224 = asn1.ObjectIdentifier{1, 3, 132, 0, 33}\n+\toidNamedCurveP256 = asn1.ObjectIdentifier{1, 2, 840, 10045, 3, 1, 7}\n+\toidNamedCurveP384 = asn1.ObjectIdentifier{1, 3, 132, 0, 34}\n+\toidNamedCurveP521 = asn1.ObjectIdentifier{1, 3, 132, 0, 35}\n+)\n+\n+func namedCurveFromOID(oid asn1.ObjectIdentifier) elliptic.Curve {\n+\tswitch {\n+\tcase oid.Equal(oidNamedCurveP224):\n+\t\treturn elliptic.P224()\n+\tcase oid.Equal(oidNamedCurveP256):\n+\t\treturn elliptic.P256()\n+\tcase oid.Equal(oidNamedCurveP384):\n+\t\treturn elliptic.P384()\n+\tcase oid.Equal(oidNamedCurveP521):\n+\t\treturn elliptic.P521()\n+\t}\n+\treturn nil\n+}\n+\n+func oidFromNamedCurve(curve elliptic.Curve) (asn1.ObjectIdentifier, bool) {\n+\tswitch curve {\n+\tcase elliptic.P224():\n+\t\treturn oidNamedCurveP224, true\n+\tcase elliptic.P256():\n+\t\treturn oidNamedCurveP256, true\n+\tcase elliptic.P384():\n+\t\treturn oidNamedCurveP384, true\n+\tcase elliptic.P521():\n+\t\treturn oidNamedCurveP521, true\n+\t}\n+\n+\treturn nil, false\n+}\n+\n // KeyUsage represents the set of actions that are valid for a given key. It's\n // a bitmap of the KeyUsage* constants.\n type KeyUsage int\n@@ -267,6 +365,9 @@ var (\n \toidExtKeyUsageClientAuth      = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 2}\n \toidExtKeyUsageCodeSigning     = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 3}\n \toidExtKeyUsageEmailProtection = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 4}\n+\toidExtKeyUsageIPSECEndSystem  = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 5}\n+\toidExtKeyUsageIPSECTunnel     = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 6}\n+\toidExtKeyUsageIPSECUser       = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 7}\n \toidExtKeyUsageTimeStamping    = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 8}\n \toidExtKeyUsageOCSPSigning     = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 9}\n )\n@@ -281,10 +382,48 @@ const (\n \tExtKeyUsageClientAuth\n \tExtKeyUsageCodeSigning\n \tExtKeyUsageEmailProtection\n+\tExtKeyUsageIPSECEndSystem\n+\tExtKeyUsageIPSECTunnel\n+\tExtKeyUsageIPSECUser\n \tExtKeyUsageTimeStamping\n \tExtKeyUsageOCSPSigning\n )\n \n+// extKeyUsageOIDs contains the mapping between an ExtKeyUsage and its OID.\n+var extKeyUsageOIDs = []struct {\n+\textKeyUsage ExtKeyUsage\n+\toid         asn1.ObjectIdentifier\n+}{\n+\t{ExtKeyUsageAny, oidExtKeyUsageAny},\n+\t{ExtKeyUsageServerAuth, oidExtKeyUsageServerAuth},\n+\t{ExtKeyUsageClientAuth, oidExtKeyUsageClientAuth},\n+\t{ExtKeyUsageCodeSigning, oidExtKeyUsageCodeSigning},\n+\t{ExtKeyUsageEmailProtection, oidExtKeyUsageEmailProtection},\n+\t{ExtKeyUsageIPSECEndSystem, oidExtKeyUsageIPSECEndSystem},\n+\t{ExtKeyUsageIPSECTunnel, oidExtKeyUsageIPSECTunnel},\n+\t{ExtKeyUsageIPSECUser, oidExtKeyUsageIPSECUser},\n+\t{ExtKeyUsageTimeStamping, oidExtKeyUsageTimeStamping},\n+\t{ExtKeyUsageOCSPSigning, oidExtKeyUsageOCSPSigning},\n+}\n+\n+func extKeyUsageFromOID(oid asn1.ObjectIdentifier) (eku ExtKeyUsage, ok bool) {\n+\tfor _, pair := range extKeyUsageOIDs {\n+\t\tif oid.Equal(pair.oid) {\n+\t\t\treturn pair.extKeyUsage, true\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func oidFromExtKeyUsage(eku ExtKeyUsage) (oid asn1.ObjectIdentifier, ok bool) {\n+\tfor _, pair := range extKeyUsageOIDs {\n+\t\tif eku == pair.extKeyUsage {\n+\t\t\treturn pair.oid, true\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n // A Certificate represents an X.509 certificate.\n type Certificate struct {\n \tRaw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n@@ -427,13 +566,13 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \tvar hashType crypto.Hash\n \n \tswitch algo {\n-\tcase SHA1WithRSA, DSAWithSHA1:\n+\tcase SHA1WithRSA, DSAWithSHA1, ECDSAWithSHA1:\n \t\thashType = crypto.SHA1\n-\tcase SHA256WithRSA, DSAWithSHA256:\n+\tcase SHA256WithRSA, DSAWithSHA256, ECDSAWithSHA256:\n \t\thashType = crypto.SHA256\n-\tcase SHA384WithRSA:\n+\tcase SHA384WithRSA, ECDSAWithSHA384:\n \t\thashType = crypto.SHA384\n-\tcase SHA512WithRSA:\n+\tcase SHA512WithRSA, ECDSAWithSHA512:\n \t\thashType = crypto.SHA512\n \tdefault:\n \t\treturn ErrUnsupportedAlgorithm\n@@ -462,6 +601,18 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\t\treturn errors.New(\"DSA verification failure\")\n \t\t}\n \t\treturn\n+\tcase *ecdsa.PublicKey:\n+\t\tecdsaSig := new(ecdsaSignature)\n+\t\tif _, err := asn1.Unmarshal(signature, ecdsaSig); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n+\t\t\treturn errors.New(\"crypto/x509: ECDSA signature contained zero or negative values\")\n+\t\t}\n+\t\tif !ecdsa.Verify(pub, digest, ecdsaSig.R, ecdsaSig.S) {\n+\t\t\treturn errors.New(\"crypto/x509: ECDSA verification failure\")\n+\t\t}\n+\t\treturn\n \t}\n \treturn ErrUnsupportedAlgorithm\n }\n@@ -497,8 +648,6 @@ type nameConstraints struct {\n \n type generalSubtree struct {\n \tName string `asn1:\"tag:2,optional,ia5\"`\n-\tMin  int    `asn1:\"optional,tag:0\"`\n-\tMax  int    `asn1:\"optional,tag:1\"`\n }\n \n func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, error) {\n@@ -540,6 +689,27 @@ func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{\n \t\t\tY: p,\n \t\t}\n \t\treturn pub, nil\n+\tcase ECDSA:\n+\t\tparamsData := keyData.Algorithm.Parameters.FullBytes\n+\t\tnamedCurveOID := new(asn1.ObjectIdentifier)\n+\t\t_, err := asn1.Unmarshal(paramsData, namedCurveOID)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tnamedCurve := namedCurveFromOID(*namedCurveOID)\n+\t\tif namedCurve == nil {\n+\t\t\treturn nil, errors.New(\"crypto/x509: unsupported elliptic curve\")\n+\t\t}\n+\t\tx, y := elliptic.Unmarshal(namedCurve, asn1Data)\n+\t\tif x == nil {\n+\t\t\treturn nil, errors.New(\"crypto/x509: failed to unmarshal elliptic curve point\")\n+\t\t}\n+\t\tpub := &ecdsa.PublicKey{\n+\t\t\tCurve: namedCurve,\n+\t\t\tX:     x,\n+\t\t\tY:     y,\n+\t\t}\n+\t\treturn pub, nil\n \tdefault:\n \t\treturn nil, nil\n \t}\n@@ -694,7 +864,7 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t}\n \n \t\t\t\tfor _, subtree := range constraints.Permitted {\n-\t\t\t\t\tif subtree.Min > 0 || subtree.Max > 0 || len(subtree.Name) == 0 {\n+\t\t\t\t\tif len(subtree.Name) == 0 {\n \t\t\t\t\t\tif e.Critical {\n \t\t\t\t\t\t\treturn out, UnhandledCriticalExtension{}\n \t\t\t\t\t\t}\n@@ -730,22 +900,9 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t}\n \n \t\t\t\tfor _, u := range keyUsage {\n-\t\t\t\t\tswitch {\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageAny):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageAny)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageServerAuth):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageServerAuth)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageClientAuth):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageClientAuth)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageCodeSigning):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageCodeSigning)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageEmailProtection):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageEmailProtection)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageTimeStamping):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageTimeStamping)\n-\t\t\t\t\tcase u.Equal(oidExtKeyUsageOCSPSigning):\n-\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageOCSPSigning)\n-\t\t\t\t\tdefault:\n+\t\t\t\t\tif extKeyUsage, ok := extKeyUsageFromOID(u); ok {\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, extKeyUsage)\n+\t\t\t\t\t} else {\n \t\t\t\t\t\tout.UnknownExtKeyUsage = append(out.UnknownExtKeyUsage, u)\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -834,6 +991,7 @@ func reverseBitsInAByte(in byte) byte {\n var (\n \toidExtensionSubjectKeyId        = []int{2, 5, 29, 14}\n \toidExtensionKeyUsage            = []int{2, 5, 29, 15}\n+\toidExtensionExtendedKeyUsage    = []int{2, 5, 29, 37}\n \toidExtensionAuthorityKeyId      = []int{2, 5, 29, 35}\n \toidExtensionBasicConstraints    = []int{2, 5, 29, 19}\n \toidExtensionSubjectAltName      = []int{2, 5, 29, 17}\n@@ -842,7 +1000,7 @@ var (\n )\n \n func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n-\tret = make([]pkix.Extension, 7 /* maximum number of elements. */)\n+\tret = make([]pkix.Extension, 8 /* maximum number of elements. */)\n \tn := 0\n \n \tif template.KeyUsage != 0 {\n@@ -865,6 +1023,27 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n+\tif len(template.ExtKeyUsage) > 0 || len(template.UnknownExtKeyUsage) > 0 {\n+\t\tret[n].Id = oidExtensionExtendedKeyUsage\n+\n+\t\tvar oids []asn1.ObjectIdentifier\n+\t\tfor _, u := range template.ExtKeyUsage {\n+\t\t\tif oid, ok := oidFromExtKeyUsage(u); ok {\n+\t\t\t\toids = append(oids, oid)\n+\t\t\t} else {\n+\t\t\t\tpanic(\"internal error\")\n+\t\t\t}\n+\t\t}\n+\n+\t\toids = append(oids, template.UnknownExtKeyUsage...)\n+\n+\t\tret[n].Value, err = asn1.Marshal(oids)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn++\n+\t}\n+\n \tif template.BasicConstraintsValid {\n \t\tret[n].Id = oidExtensionBasicConstraints\n \t\tret[n].Value, err = asn1.Marshal(basicConstraints{template.IsCA, template.MaxPathLen})\n@@ -941,11 +1120,6 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \treturn ret[0:n], nil\n }\n \n-var (\n-\toidSHA1WithRSA = []int{1, 2, 840, 113549, 1, 1, 5}\n-\toidRSA         = []int{1, 2, 840, 113549, 1, 1, 1}\n-)\n-\n func subjectBytes(cert *Certificate) ([]byte, error) {\n \tif len(cert.RawSubject) > 0 {\n \t\treturn cert.RawSubject, nil\n@@ -956,32 +1130,71 @@ func subjectBytes(cert *Certificate) ([]byte, error) {\n \n // CreateCertificate creates a new certificate based on a template. The\n // following members of template are used: SerialNumber, Subject, NotBefore,\n-// NotAfter, KeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId,\n-// DNSNames, PermittedDNSDomainsCritical, PermittedDNSDomains.\n+// NotAfter, KeyUsage, ExtKeyUsage, UnknownExtKeyUsage, BasicConstraintsValid,\n+// IsCA, MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\n+// PermittedDNSDomains.\n //\n // The certificate is signed by parent. If parent is equal to template then the\n // certificate is self-signed. The parameter pub is the public key of the\n // signee and priv is the private key of the signer.\n //\n // The returned slice is the certificate in DER encoding.\n //\n-// The only supported key type is RSA (*rsa.PublicKey for pub, *rsa.PrivateKey\n-// for priv).\n+// The only supported key types are RSA and ECDSA (*rsa.PublicKey or\n+// *ecdsa.PublicKey for pub, *rsa.PrivateKey or *ecdsa.PublicKey for priv).\n func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interface{}, priv interface{}) (cert []byte, err error) {\n-\trsaPub, ok := pub.(*rsa.PublicKey)\n-\tif !ok {\n-\t\treturn nil, errors.New(\"x509: non-RSA public keys not supported\")\n+\tvar publicKeyBytes []byte\n+\tvar publicKeyAlgorithm pkix.AlgorithmIdentifier\n+\n+\tswitch pub := pub.(type) {\n+\tcase *rsa.PublicKey:\n+\t\tpublicKeyBytes, err = asn1.Marshal(rsaPublicKey{\n+\t\t\tN: pub.N,\n+\t\t\tE: pub.E,\n+\t\t})\n+\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyRSA\n+\tcase *ecdsa.PublicKey:\n+\t\toid, ok := oidFromNamedCurve(pub.Curve)\n+\t\tif !ok {\n+\t\t\treturn nil, errors.New(\"x509: unknown elliptic curve\")\n+\t\t}\n+\t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyECDSA\n+\t\tvar paramBytes []byte\n+\t\tparamBytes, err = asn1.Marshal(oid)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tpublicKeyAlgorithm.Parameters.FullBytes = paramBytes\n+\t\tpublicKeyBytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)\n+\tdefault:\n+\t\treturn nil, errors.New(\"x509: only RSA and ECDSA public keys supported\")\n \t}\n \n-\trsaPriv, ok := priv.(*rsa.PrivateKey)\n-\tif !ok {\n-\t\treturn nil, errors.New(\"x509: non-RSA private keys not supported\")\n+\tvar signatureAlgorithm pkix.AlgorithmIdentifier\n+\tvar hashFunc crypto.Hash\n+\n+\tswitch priv := priv.(type) {\n+\tcase *rsa.PrivateKey:\n+\t\tsignatureAlgorithm.Algorithm = oidSignatureSHA1WithRSA\n+\t\thashFunc = crypto.SHA1\n+\tcase *ecdsa.PrivateKey:\n+\t\tswitch priv.Curve {\n+\t\tcase elliptic.P224(), elliptic.P256():\n+\t\t\thashFunc = crypto.SHA256\n+\t\t\tsignatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA256\n+\t\tcase elliptic.P384():\n+\t\t\thashFunc = crypto.SHA384\n+\t\t\tsignatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA384\n+\t\tcase elliptic.P521():\n+\t\t\thashFunc = crypto.SHA512\n+\t\t\tsignatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA512\n+\t\tdefault:\n+\t\t\treturn nil, errors.New(\"x509: unknown elliptic curve\")\n+\t\t}\n+\tdefault:\n+\t\treturn nil, errors.New(\"x509: only RSA and ECDSA private keys supported\")\n \t}\n \n-\tasn1PublicKey, err := asn1.Marshal(rsaPublicKey{\n-\t\tN: rsaPub.N,\n-\t\tE: rsaPub.E,\n-\t})\n \tif err != nil {\n \t\treturn\n \t}\n@@ -1005,15 +1218,15 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interf\n \t\treturn\n \t}\n \n-\tencodedPublicKey := asn1.BitString{BitLength: len(asn1PublicKey) * 8, Bytes: asn1PublicKey}\n+\tencodedPublicKey := asn1.BitString{BitLength: len(publicKeyBytes) * 8, Bytes: publicKeyBytes}\n \tc := tbsCertificate{\n \t\tVersion:            2,\n \t\tSerialNumber:       template.SerialNumber,\n-\t\tSignatureAlgorithm: pkix.AlgorithmIdentifier{Algorithm: oidSHA1WithRSA},\n+\t\tSignatureAlgorithm: signatureAlgorithm,\n \t\tIssuer:             asn1.RawValue{FullBytes: asn1Issuer},\n \t\tValidity:           validity{template.NotBefore, template.NotAfter},\n \t\tSubject:            asn1.RawValue{FullBytes: asn1Subject},\n-\t\tPublicKey:          publicKeyInfo{nil, pkix.AlgorithmIdentifier{Algorithm: oidRSA}, encodedPublicKey},\n+\t\tPublicKey:          publicKeyInfo{nil, publicKeyAlgorithm, encodedPublicKey},\n \t\tExtensions:         extensions,\n \t}\n \n@@ -1024,19 +1237,32 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interf\n \n \tc.Raw = tbsCertContents\n \n-\th := sha1.New()\n+\th := hashFunc.New()\n \th.Write(tbsCertContents)\n \tdigest := h.Sum(nil)\n \n-\tsignature, err := rsa.SignPKCS1v15(rand, rsaPriv, crypto.SHA1, digest)\n+\tvar signature []byte\n+\n+\tswitch priv := priv.(type) {\n+\tcase *rsa.PrivateKey:\n+\t\tsignature, err = rsa.SignPKCS1v15(rand, priv, hashFunc, digest)\n+\tcase *ecdsa.PrivateKey:\n+\t\tvar r, s *big.Int\n+\t\tif r, s, err = ecdsa.Sign(rand, priv, digest); err == nil {\n+\t\t\tsignature, err = asn1.Marshal(ecdsaSignature{r, s})\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"internal error\")\n+\t}\n+\n \tif err != nil {\n \t\treturn\n \t}\n \n \tcert, err = asn1.Marshal(certificate{\n \t\tnil,\n \t\tc,\n-\t\tpkix.AlgorithmIdentifier{Algorithm: oidSHA1WithRSA},\n+\t\tsignatureAlgorithm,\n \t\tasn1.BitString{Bytes: signature, BitLength: len(signature) * 8},\n \t})\n \treturn"}, {"sha": "a13f4598d58aee648fe6a945219124e9a4150081", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 190, "deletions": 45, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -7,14 +7,19 @@ package x509\n import (\n \t\"bytes\"\n \t\"crypto/dsa\"\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n+\t_ \"crypto/sha256\"\n+\t_ \"crypto/sha512\"\n \t\"crypto/x509/pkix\"\n \t\"encoding/asn1\"\n \t\"encoding/base64\"\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"math/big\"\n+\t\"reflect\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -237,65 +242,205 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \trandom := rand.Reader\n \n \tblock, _ := pem.Decode([]byte(pemPrivateKey))\n-\tpriv, err := ParsePKCS1PrivateKey(block.Bytes)\n+\trsaPriv, err := ParsePKCS1PrivateKey(block.Bytes)\n \tif err != nil {\n-\t\tt.Errorf(\"Failed to parse private key: %s\", err)\n-\t\treturn\n+\t\tt.Fatalf(\"Failed to parse private key: %s\", err)\n \t}\n \n-\tcommonName := \"test.example.com\"\n-\ttemplate := Certificate{\n-\t\tSerialNumber: big.NewInt(1),\n-\t\tSubject: pkix.Name{\n-\t\t\tCommonName:   commonName,\n-\t\t\tOrganization: []string{\"Acme Co\"},\n-\t\t},\n-\t\tNotBefore: time.Unix(1000, 0),\n-\t\tNotAfter:  time.Unix(100000, 0),\n+\tecdsaPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to generate ECDSA key: %s\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname      string\n+\t\tpub, priv interface{}\n+\t\tcheckSig  bool\n+\t}{\n+\t\t{\"RSA/RSA\", &rsaPriv.PublicKey, rsaPriv, true},\n+\t\t{\"RSA/ECDSA\", &rsaPriv.PublicKey, ecdsaPriv, false},\n+\t\t{\"ECDSA/RSA\", &ecdsaPriv.PublicKey, rsaPriv, false},\n+\t\t{\"ECDSA/ECDSA\", &ecdsaPriv.PublicKey, ecdsaPriv, true},\n+\t}\n+\n+\ttestExtKeyUsage := []ExtKeyUsage{ExtKeyUsageClientAuth, ExtKeyUsageServerAuth}\n+\ttestUnknownExtKeyUsage := []asn1.ObjectIdentifier{[]int{1, 2, 3}, []int{3, 2, 1}}\n+\n+\tfor _, test := range tests {\n+\t\tcommonName := \"test.example.com\"\n+\t\ttemplate := Certificate{\n+\t\t\tSerialNumber: big.NewInt(1),\n+\t\t\tSubject: pkix.Name{\n+\t\t\t\tCommonName:   commonName,\n+\t\t\t\tOrganization: []string{\"\u03a3 Acme Co\"},\n+\t\t\t},\n+\t\t\tNotBefore: time.Unix(1000, 0),\n+\t\t\tNotAfter:  time.Unix(100000, 0),\n+\n+\t\t\tSubjectKeyId: []byte{1, 2, 3, 4},\n+\t\t\tKeyUsage:     KeyUsageCertSign,\n+\n+\t\t\tExtKeyUsage:        testExtKeyUsage,\n+\t\t\tUnknownExtKeyUsage: testUnknownExtKeyUsage,\n+\n+\t\t\tBasicConstraintsValid: true,\n+\t\t\tIsCA:     true,\n+\t\t\tDNSNames: []string{\"test.example.com\"},\n+\n+\t\t\tPolicyIdentifiers:   []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n+\t\t\tPermittedDNSDomains: []string{\".example.com\", \"example.com\"},\n+\t\t}\n \n-\t\tSubjectKeyId: []byte{1, 2, 3, 4},\n-\t\tKeyUsage:     KeyUsageCertSign,\n+\t\tderBytes, err := CreateCertificate(random, &template, &template, test.pub, test.priv)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: failed to create certificate: %s\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n \n-\t\tBasicConstraintsValid: true,\n-\t\tIsCA:                  true,\n-\t\tDNSNames:              []string{\"test.example.com\"},\n+\t\tcert, err := ParseCertificate(derBytes)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: failed to parse certificate: %s\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n \n-\t\tPolicyIdentifiers:   []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n-\t\tPermittedDNSDomains: []string{\".example.com\", \"example.com\"},\n-\t}\n+\t\tif len(cert.PolicyIdentifiers) != 1 || !cert.PolicyIdentifiers[0].Equal(template.PolicyIdentifiers[0]) {\n+\t\t\tt.Errorf(\"%s: failed to parse policy identifiers: got:%#v want:%#v\", test.name, cert.PolicyIdentifiers, template.PolicyIdentifiers)\n+\t\t}\n \n-\tderBytes, err := CreateCertificate(random, &template, &template, &priv.PublicKey, priv)\n-\tif err != nil {\n-\t\tt.Errorf(\"Failed to create certificate: %s\", err)\n-\t\treturn\n-\t}\n+\t\tif len(cert.PermittedDNSDomains) != 2 || cert.PermittedDNSDomains[0] != \".example.com\" || cert.PermittedDNSDomains[1] != \"example.com\" {\n+\t\t\tt.Errorf(\"%s: failed to parse name constraints: %#v\", test.name, cert.PermittedDNSDomains)\n+\t\t}\n \n-\tcert, err := ParseCertificate(derBytes)\n-\tif err != nil {\n-\t\tt.Errorf(\"Failed to parse certificate: %s\", err)\n-\t\treturn\n-\t}\n+\t\tif cert.Subject.CommonName != commonName {\n+\t\t\tt.Errorf(\"%s: subject wasn't correctly copied from the template. Got %s, want %s\", test.name, cert.Subject.CommonName, commonName)\n+\t\t}\n \n-\tif len(cert.PolicyIdentifiers) != 1 || !cert.PolicyIdentifiers[0].Equal(template.PolicyIdentifiers[0]) {\n-\t\tt.Errorf(\"Failed to parse policy identifiers: got:%#v want:%#v\", cert.PolicyIdentifiers, template.PolicyIdentifiers)\n-\t}\n+\t\tif cert.Issuer.CommonName != commonName {\n+\t\t\tt.Errorf(\"%s: issuer wasn't correctly copied from the template. Got %s, want %s\", test.name, cert.Issuer.CommonName, commonName)\n+\t\t}\n \n-\tif len(cert.PermittedDNSDomains) != 2 || cert.PermittedDNSDomains[0] != \".example.com\" || cert.PermittedDNSDomains[1] != \"example.com\" {\n-\t\tt.Errorf(\"Failed to parse name constraints: %#v\", cert.PermittedDNSDomains)\n-\t}\n+\t\tif !reflect.DeepEqual(cert.ExtKeyUsage, testExtKeyUsage) {\n+\t\t\tt.Errorf(\"%s: extkeyusage wasn't correctly copied from the template. Got %v, want %v\", test.name, cert.ExtKeyUsage, testExtKeyUsage)\n+\t\t}\n \n-\tif cert.Subject.CommonName != commonName {\n-\t\tt.Errorf(\"Subject wasn't correctly copied from the template. Got %s, want %s\", cert.Subject.CommonName, commonName)\n-\t}\n+\t\tif !reflect.DeepEqual(cert.UnknownExtKeyUsage, testUnknownExtKeyUsage) {\n+\t\t\tt.Errorf(\"%s: unknown extkeyusage wasn't correctly copied from the template. Got %v, want %v\", test.name, cert.UnknownExtKeyUsage, testUnknownExtKeyUsage)\n+\t\t}\n \n-\tif cert.Issuer.CommonName != commonName {\n-\t\tt.Errorf(\"Issuer wasn't correctly copied from the template. Got %s, want %s\", cert.Issuer.CommonName, commonName)\n+\t\tif test.checkSig {\n+\t\t\terr = cert.CheckSignatureFrom(cert)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%s: signature verification failed: %s\", test.name, err)\n+\t\t\t}\n+\t\t}\n \t}\n+}\n \n-\terr = cert.CheckSignatureFrom(cert)\n-\tif err != nil {\n-\t\tt.Errorf(\"Signature verification failed: %s\", err)\n-\t\treturn\n+// Self-signed certificate using ECDSA with SHA1 & secp256r1\n+var ecdsaSHA1CertPem = `\n+-----BEGIN CERTIFICATE-----\n+MIICDjCCAbUCCQDF6SfN0nsnrjAJBgcqhkjOPQQBMIGPMQswCQYDVQQGEwJVUzET\n+MBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMG\n+A1UECgwMR29vZ2xlLCBJbmMuMRcwFQYDVQQDDA53d3cuZ29vZ2xlLmNvbTEjMCEG\n+CSqGSIb3DQEJARYUZ29sYW5nLWRldkBnbWFpbC5jb20wHhcNMTIwNTIwMjAyMDUw\n+WhcNMjIwNTE4MjAyMDUwWjCBjzELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlm\n+b3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTATBgNVBAoMDEdvb2dsZSwg\n+SW5jLjEXMBUGA1UEAwwOd3d3Lmdvb2dsZS5jb20xIzAhBgkqhkiG9w0BCQEWFGdv\n+bGFuZy1kZXZAZ21haWwuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/Wgn\n+WQDo5+bz71T0327ERgd5SDDXFbXLpzIZDXTkjpe8QTEbsF+ezsQfrekrpDPC4Cd3\n+P9LY0tG+aI8IyVKdUjAJBgcqhkjOPQQBA0gAMEUCIGlsqMcRqWVIWTD6wXwe6Jk2\n+DKxL46r/FLgJYnzBEH99AiEA3fBouObsvV1R3oVkb4BQYnD4/4LeId6lAT43YvyV\n+a/A=\n+-----END CERTIFICATE-----\n+`\n+\n+// Self-signed certificate using ECDSA with SHA256 & secp256r1\n+var ecdsaSHA256p256CertPem = `\n+-----BEGIN CERTIFICATE-----\n+MIICDzCCAbYCCQDlsuMWvgQzhTAKBggqhkjOPQQDAjCBjzELMAkGA1UEBhMCVVMx\n+EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\n+BgNVBAoMDEdvb2dsZSwgSW5jLjEXMBUGA1UEAwwOd3d3Lmdvb2dsZS5jb20xIzAh\n+BgkqhkiG9w0BCQEWFGdvbGFuZy1kZXZAZ21haWwuY29tMB4XDTEyMDUyMTAwMTkx\n+NloXDTIyMDUxOTAwMTkxNlowgY8xCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxp\n+Zm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRUwEwYDVQQKDAxHb29nbGUs\n+IEluYy4xFzAVBgNVBAMMDnd3dy5nb29nbGUuY29tMSMwIQYJKoZIhvcNAQkBFhRn\n+b2xhbmctZGV2QGdtYWlsLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABPMt\n+2ErhxAty5EJRu9yM+MTy+hUXm3pdW1ensAv382KoGExSXAFWP7pjJnNtHO+XSwVm\n+YNtqjcAGFKpweoN//kQwCgYIKoZIzj0EAwIDRwAwRAIgIYSaUA/IB81gjbIw/hUV\n+70twxJr5EcgOo0hLp3Jm+EYCIFDO3NNcgmURbJ1kfoS3N/0O+irUtoPw38YoNkqJ\n+h5wi\n+-----END CERTIFICATE-----\n+`\n+\n+// Self-signed certificate using ECDSA with SHA256 & secp384r1\n+var ecdsaSHA256p384CertPem = `\n+-----BEGIN CERTIFICATE-----\n+MIICSjCCAdECCQDje/no7mXkVzAKBggqhkjOPQQDAjCBjjELMAkGA1UEBhMCVVMx\n+EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFDAS\n+BgNVBAoMC0dvb2dsZSwgSW5jMRcwFQYDVQQDDA53d3cuZ29vZ2xlLmNvbTEjMCEG\n+CSqGSIb3DQEJARYUZ29sYW5nLWRldkBnbWFpbC5jb20wHhcNMTIwNTIxMDYxMDM0\n+WhcNMjIwNTE5MDYxMDM0WjCBjjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlm\n+b3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFDASBgNVBAoMC0dvb2dsZSwg\n+SW5jMRcwFQYDVQQDDA53d3cuZ29vZ2xlLmNvbTEjMCEGCSqGSIb3DQEJARYUZ29s\n+YW5nLWRldkBnbWFpbC5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAARRuzRNIKRK\n+jIktEmXanNmrTR/q/FaHXLhWRZ6nHWe26Fw7Rsrbk+VjGy4vfWtNn7xSFKrOu5ze\n+qxKnmE0h5E480MNgrUiRkaGO2GMJJVmxx20aqkXOk59U8yGA4CghE6MwCgYIKoZI\n+zj0EAwIDZwAwZAIwBZEN8gvmRmfeP/9C1PRLzODIY4JqWub2PLRT4mv9GU+yw3Gr\n+PU9A3CHMdEcdw/MEAjBBO1lId8KOCh9UZunsSMfqXiVurpzmhWd6VYZ/32G+M+Mh\n+3yILeYQzllt/g0rKVRk=\n+-----END CERTIFICATE-----\n+`\n+\n+// Self-signed certificate using ECDSA with SHA384 & secp521r1\n+var ecdsaSHA384p521CertPem = `\n+-----BEGIN CERTIFICATE-----\n+MIICljCCAfcCCQDhp1AFD/ahKjAKBggqhkjOPQQDAzCBjjELMAkGA1UEBhMCVVMx\n+EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFDAS\n+BgNVBAoMC0dvb2dsZSwgSW5jMRcwFQYDVQQDDA53d3cuZ29vZ2xlLmNvbTEjMCEG\n+CSqGSIb3DQEJARYUZ29sYW5nLWRldkBnbWFpbC5jb20wHhcNMTIwNTIxMTUwNDI5\n+WhcNMjIwNTE5MTUwNDI5WjCBjjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlm\n+b3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFDASBgNVBAoMC0dvb2dsZSwg\n+SW5jMRcwFQYDVQQDDA53d3cuZ29vZ2xlLmNvbTEjMCEGCSqGSIb3DQEJARYUZ29s\n+YW5nLWRldkBnbWFpbC5jb20wgZswEAYHKoZIzj0CAQYFK4EEACMDgYYABACqx9Rv\n+IssRs1LWYcNN+WffwlHw4Tv3y8/LIAA9MF1ZScIonU9nRMxt4a2uGJVCPDw6JHpz\n+PaYc0E9puLoE9AfKpwFr59Jkot7dBg55SKPEFkddoip/rvmN7NPAWjMBirOwjOkm\n+8FPthvPhGPqsu9AvgVuHu3PosWiHGNrhh379pva8MzAKBggqhkjOPQQDAwOBjAAw\n+gYgCQgEHNmswkUdPpHqrVxp9PvLVl+xxPuHBkT+75z9JizyxtqykHQo9Uh6SWCYH\n+BF9KLolo01wMt8DjoYP5Fb3j5MH7xwJCAbWZzTOp4l4DPkIvAh4LeC4VWbwPPyqh\n+kBg71w/iEcSY3wUKgHGcJJrObZw7wys91I5kENljqw/Samdr3ka+jBJa\n+-----END CERTIFICATE-----\n+`\n+\n+var ecdsaTests = []struct {\n+\tsigAlgo SignatureAlgorithm\n+\tpemCert string\n+}{\n+\t{ECDSAWithSHA1, ecdsaSHA1CertPem},\n+\t{ECDSAWithSHA256, ecdsaSHA256p256CertPem},\n+\t{ECDSAWithSHA256, ecdsaSHA256p384CertPem},\n+\t{ECDSAWithSHA384, ecdsaSHA384p521CertPem},\n+}\n+\n+func TestECDSA(t *testing.T) {\n+\tfor i, test := range ecdsaTests {\n+\t\tpemBlock, _ := pem.Decode([]byte(test.pemCert))\n+\t\tcert, err := ParseCertificate(pemBlock.Bytes)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: failed to parse certificate: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif sa := cert.SignatureAlgorithm; sa != test.sigAlgo {\n+\t\t\tt.Errorf(\"%d: signature algorithm is %v, want %v\", i, sa, test.sigAlgo)\n+\t\t}\n+\t\tif parsedKey, ok := cert.PublicKey.(*ecdsa.PublicKey); !ok {\n+\t\t\tt.Errorf(\"%d: wanted an ECDSA public key but found: %#v\", i, parsedKey)\n+\t\t}\n+\t\tif pka := cert.PublicKeyAlgorithm; pka != ECDSA {\n+\t\t\tt.Errorf(\"%d: public key algorithm is %v, want ECDSA\", i, pka)\n+\t\t}\n+\t\tif err = cert.CheckSignatureFrom(cert); err != nil {\n+\t\t\tt.Errorf(\"%d: certificate verfication failed: %s\", i, err)\n+\t\t}\n \t}\n }\n "}, {"sha": "964dc1848504830aaa33ff3a55a25a5a2802c5c8", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -14,19 +14,61 @@ import (\n \t\"strconv\"\n )\n \n-// subsetTypeArgs takes a slice of arguments from callers of the sql\n-// package and converts them into a slice of the driver package's\n-// \"subset types\".\n-func subsetTypeArgs(args []interface{}) ([]driver.Value, error) {\n-\tout := make([]driver.Value, len(args))\n+// driverArgs converts arguments from callers of Stmt.Exec and\n+// Stmt.Query into driver Values.\n+//\n+// The statement si may be nil, if no statement is available.\n+func driverArgs(si driver.Stmt, args []interface{}) ([]driver.Value, error) {\n+\tdargs := make([]driver.Value, len(args))\n+\tcc, ok := si.(driver.ColumnConverter)\n+\n+\t// Normal path, for a driver.Stmt that is not a ColumnConverter.\n+\tif !ok {\n+\t\tfor n, arg := range args {\n+\t\t\tvar err error\n+\t\t\tdargs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n+\t\t\t}\n+\t\t}\n+\t\treturn dargs, nil\n+\t}\n+\n+\t// Let the Stmt convert its own arguments.\n \tfor n, arg := range args {\n+\t\t// First, see if the value itself knows how to convert\n+\t\t// itself to a driver type.  For example, a NullString\n+\t\t// struct changing into a string or nil.\n+\t\tif svi, ok := arg.(driver.Valuer); ok {\n+\t\t\tsv, err := svi.Value()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d from Value: %v\", n, err)\n+\t\t\t}\n+\t\t\tif !driver.IsValue(sv) {\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d: non-subset type %T returned from Value\", n, sv)\n+\t\t\t}\n+\t\t\targ = sv\n+\t\t}\n+\n+\t\t// Second, ask the column to sanity check itself. For\n+\t\t// example, drivers might use this to make sure that\n+\t\t// an int64 values being inserted into a 16-bit\n+\t\t// integer field is in range (before getting\n+\t\t// truncated), or that a nil can't go into a NOT NULL\n+\t\t// column before going across the network to get the\n+\t\t// same error.\n \t\tvar err error\n-\t\tout[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n+\t\tdargs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n \t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"sql: converting argument #%d's type: %v\", n+1, err)\n+\t\t\treturn nil, fmt.Errorf(\"sql: converting argument #%d's type: %v\", n, err)\n+\t\t}\n+\t\tif !driver.IsValue(dargs[n]) {\n+\t\t\treturn nil, fmt.Errorf(\"sql: driver ColumnConverter error converted %T to unsupported type %T\",\n+\t\t\t\targ, dargs[n])\n \t\t}\n \t}\n-\treturn out, nil\n+\n+\treturn dargs, nil\n }\n \n // convertAssign copies to dest the value in src, converting it if possible."}, {"sha": "aec572760fe6a1f4f93404e8cad55cd572d66fa3", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -383,6 +383,9 @@ func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n }\n \n func (s *fakeStmt) ColumnConverter(idx int) driver.ValueConverter {\n+\tif len(s.placeholderConverter) == 0 {\n+\t\treturn driver.DefaultParameterConverter\n+\t}\n \treturn s.placeholderConverter[idx]\n }\n \n@@ -598,6 +601,28 @@ func (rc *rowsCursor) Next(dest []driver.Value) error {\n \treturn nil\n }\n \n+// fakeDriverString is like driver.String, but indirects pointers like\n+// DefaultValueConverter.\n+//\n+// This could be surprising behavior to retroactively apply to\n+// driver.String now that Go1 is out, but this is convenient for\n+// our TestPointerParamsAndScans.\n+//\n+type fakeDriverString struct{}\n+\n+func (fakeDriverString) ConvertValue(v interface{}) (driver.Value, error) {\n+\tswitch c := v.(type) {\n+\tcase string, []byte:\n+\t\treturn v, nil\n+\tcase *string:\n+\t\tif c == nil {\n+\t\t\treturn nil, nil\n+\t\t}\n+\t\treturn *c, nil\n+\t}\n+\treturn fmt.Sprintf(\"%v\", v), nil\n+}\n+\n func converterForType(typ string) driver.ValueConverter {\n \tswitch typ {\n \tcase \"bool\":\n@@ -607,9 +632,9 @@ func converterForType(typ string) driver.ValueConverter {\n \tcase \"int32\":\n \t\treturn driver.Int32\n \tcase \"string\":\n-\t\treturn driver.NotNull{Converter: driver.String}\n+\t\treturn driver.NotNull{Converter: fakeDriverString{}}\n \tcase \"nullstring\":\n-\t\treturn driver.Null{Converter: driver.String}\n+\t\treturn driver.Null{Converter: fakeDriverString{}}\n \tcase \"int64\":\n \t\t// TODO(coopernurse): add type-specific converter\n \t\treturn driver.NotNull{Converter: driver.DefaultParameterConverter}"}, {"sha": "b0cba949c6bd9e70f7715bd01b150e209b5ddcd6", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 33, "deletions": 60, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -329,21 +329,18 @@ func (db *DB) prepare(query string) (stmt *Stmt, err error) {\n \n // Exec executes a query without returning any rows.\n func (db *DB) Exec(query string, args ...interface{}) (Result, error) {\n-\tsargs, err := subsetTypeArgs(args)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n \tvar res Result\n+\tvar err error\n \tfor i := 0; i < 10; i++ {\n-\t\tres, err = db.exec(query, sargs)\n+\t\tres, err = db.exec(query, args)\n \t\tif err != driver.ErrBadConn {\n \t\t\tbreak\n \t\t}\n \t}\n \treturn res, err\n }\n \n-func (db *DB) exec(query string, sargs []driver.Value) (res Result, err error) {\n+func (db *DB) exec(query string, args []interface{}) (res Result, err error) {\n \tci, err := db.conn()\n \tif err != nil {\n \t\treturn nil, err\n@@ -353,7 +350,11 @@ func (db *DB) exec(query string, sargs []driver.Value) (res Result, err error) {\n \t}()\n \n \tif execer, ok := ci.(driver.Execer); ok {\n-\t\tresi, err := execer.Exec(query, sargs)\n+\t\tdargs, err := driverArgs(nil, args)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tresi, err := execer.Exec(query, dargs)\n \t\tif err != driver.ErrSkip {\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n@@ -368,7 +369,12 @@ func (db *DB) exec(query string, sargs []driver.Value) (res Result, err error) {\n \t}\n \tdefer sti.Close()\n \n-\tresi, err := sti.Exec(sargs)\n+\tdargs, err := driverArgs(sti, args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tresi, err := sti.Exec(dargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -582,13 +588,12 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t}\n \tdefer tx.releaseConn()\n \n-\tsargs, err := subsetTypeArgs(args)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tif execer, ok := ci.(driver.Execer); ok {\n-\t\tresi, err := execer.Exec(query, sargs)\n+\t\tdargs, err := driverArgs(nil, args)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tresi, err := execer.Exec(query, dargs)\n \t\tif err == nil {\n \t\t\treturn result{resi}, nil\n \t\t}\n@@ -603,7 +608,12 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t}\n \tdefer sti.Close()\n \n-\tresi, err := sti.Exec(sargs)\n+\tdargs, err := driverArgs(sti, args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tresi, err := sti.Exec(dargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -679,51 +689,12 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t\treturn nil, fmt.Errorf(\"sql: expected %d arguments, got %d\", want, len(args))\n \t}\n \n-\tsargs := make([]driver.Value, len(args))\n-\n-\t// Convert args to subset types.\n-\tif cc, ok := si.(driver.ColumnConverter); ok {\n-\t\tfor n, arg := range args {\n-\t\t\t// First, see if the value itself knows how to convert\n-\t\t\t// itself to a driver type.  For example, a NullString\n-\t\t\t// struct changing into a string or nil.\n-\t\t\tif svi, ok := arg.(driver.Valuer); ok {\n-\t\t\t\tsv, err := svi.Value()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d from Value: %v\", n, err)\n-\t\t\t\t}\n-\t\t\t\tif !driver.IsValue(sv) {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"sql: argument index %d: non-subset type %T returned from Value\", n, sv)\n-\t\t\t\t}\n-\t\t\t\targ = sv\n-\t\t\t}\n-\n-\t\t\t// Second, ask the column to sanity check itself. For\n-\t\t\t// example, drivers might use this to make sure that\n-\t\t\t// an int64 values being inserted into a 16-bit\n-\t\t\t// integer field is in range (before getting\n-\t\t\t// truncated), or that a nil can't go into a NOT NULL\n-\t\t\t// column before going across the network to get the\n-\t\t\t// same error.\n-\t\t\tsargs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n-\t\t\t}\n-\t\t\tif !driver.IsValue(sargs[n]) {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: driver ColumnConverter error converted %T to unsupported type %T\",\n-\t\t\t\t\targ, sargs[n])\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tfor n, arg := range args {\n-\t\t\tsargs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n-\t\t\t}\n-\t\t}\n+\tdargs, err := driverArgs(si, args)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\tresi, err := si.Exec(sargs)\n+\tresi, err := si.Exec(dargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -810,11 +781,13 @@ func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n \tif want := si.NumInput(); want != -1 && len(args) != want {\n \t\treturn nil, fmt.Errorf(\"sql: statement expects %d inputs; got %d\", si.NumInput(), len(args))\n \t}\n-\tsargs, err := subsetTypeArgs(args)\n+\n+\tdargs, err := driverArgs(si, args)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\trowsi, err := si.Query(sargs)\n+\n+\trowsi, err := si.Query(dargs)\n \tif err != nil {\n \t\treleaseConn(err)\n \t\treturn nil, err"}, {"sha": "1bfb59020b4380eda25deadda398deda4090f1c7", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -306,8 +306,8 @@ func TestExec(t *testing.T) {\n \t\t{[]interface{}{7, 9}, \"\"},\n \n \t\t// Invalid conversions:\n-\t\t{[]interface{}{\"Brad\", int64(0xFFFFFFFF)}, \"sql: converting Exec argument #1's type: sql/driver: value 4294967295 overflows int32\"},\n-\t\t{[]interface{}{\"Brad\", \"strconv fail\"}, \"sql: converting Exec argument #1's type: sql/driver: value \\\"strconv fail\\\" can't be converted to int32\"},\n+\t\t{[]interface{}{\"Brad\", int64(0xFFFFFFFF)}, \"sql: converting argument #1's type: sql/driver: value 4294967295 overflows int32\"},\n+\t\t{[]interface{}{\"Brad\", \"strconv fail\"}, \"sql: converting argument #1's type: sql/driver: value \\\"strconv fail\\\" can't be converted to int32\"},\n \n \t\t// Wrong number of args:\n \t\t{[]interface{}{}, \"sql: expected 2 arguments, got 0\"},"}, {"sha": "7b66730bed70c771a1e03a6d7715c69435f83a57", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -31,6 +31,7 @@ type FileHeader struct {\n \tByteOrder  binary.ByteOrder\n \tType       Type\n \tMachine    Machine\n+\tEntry      uint64\n }\n \n // A File represents an open ELF file.\n@@ -240,6 +241,7 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t\t}\n \t\tf.Type = Type(hdr.Type)\n \t\tf.Machine = Machine(hdr.Machine)\n+\t\tf.Entry = uint64(hdr.Entry)\n \t\tif v := Version(hdr.Version); v != f.Version {\n \t\t\treturn nil, &FormatError{0, \"mismatched ELF version\", v}\n \t\t}\n@@ -258,6 +260,7 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t\t}\n \t\tf.Type = Type(hdr.Type)\n \t\tf.Machine = Machine(hdr.Machine)\n+\t\tf.Entry = uint64(hdr.Entry)\n \t\tif v := Version(hdr.Version); v != f.Version {\n \t\t\treturn nil, &FormatError{0, \"mismatched ELF version\", v}\n \t\t}\n@@ -723,6 +726,20 @@ func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n // referred to by the binary f that are expected to be\n // linked with the binary at dynamic link time.\n func (f *File) ImportedLibraries() ([]string, error) {\n+\treturn f.DynString(DT_NEEDED)\n+}\n+\n+// DynString returns the strings listed for the given tag in the file's dynamic\n+// section.\n+//\n+// The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or\n+// DT_RUNPATH.\n+func (f *File) DynString(tag DynTag) ([]string, error) {\n+\tswitch tag {\n+\tcase DT_NEEDED, DT_SONAME, DT_RPATH, DT_RUNPATH:\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"non-string-valued tag %v\", tag)\n+\t}\n \tds := f.SectionByType(SHT_DYNAMIC)\n \tif ds == nil {\n \t\t// not dynamic, so no libraries\n@@ -738,25 +755,24 @@ func (f *File) ImportedLibraries() ([]string, error) {\n \t}\n \tvar all []string\n \tfor len(d) > 0 {\n-\t\tvar tag DynTag\n-\t\tvar value uint64\n+\t\tvar t DynTag\n+\t\tvar v uint64\n \t\tswitch f.Class {\n \t\tcase ELFCLASS32:\n-\t\t\ttag = DynTag(f.ByteOrder.Uint32(d[0:4]))\n-\t\t\tvalue = uint64(f.ByteOrder.Uint32(d[4:8]))\n+\t\t\tt = DynTag(f.ByteOrder.Uint32(d[0:4]))\n+\t\t\tv = uint64(f.ByteOrder.Uint32(d[4:8]))\n \t\t\td = d[8:]\n \t\tcase ELFCLASS64:\n-\t\t\ttag = DynTag(f.ByteOrder.Uint64(d[0:8]))\n-\t\t\tvalue = f.ByteOrder.Uint64(d[8:16])\n+\t\t\tt = DynTag(f.ByteOrder.Uint64(d[0:8]))\n+\t\t\tv = f.ByteOrder.Uint64(d[8:16])\n \t\t\td = d[16:]\n \t\t}\n-\t\tif tag == DT_NEEDED {\n-\t\t\ts, ok := getString(str, int(value))\n+\t\tif t == tag {\n+\t\t\ts, ok := getString(str, int(v))\n \t\t\tif ok {\n \t\t\t\tall = append(all, s)\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn all, nil\n }"}, {"sha": "12036e816b4bdc766f59c8a106558fc661739187", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -19,12 +19,13 @@ type fileTest struct {\n \thdr      FileHeader\n \tsections []SectionHeader\n \tprogs    []ProgHeader\n+\tneeded   []string\n }\n \n var fileTests = []fileTest{\n \t{\n \t\t\"testdata/gcc-386-freebsd-exec\",\n-\t\tFileHeader{ELFCLASS32, ELFDATA2LSB, EV_CURRENT, ELFOSABI_FREEBSD, 0, binary.LittleEndian, ET_EXEC, EM_386},\n+\t\tFileHeader{ELFCLASS32, ELFDATA2LSB, EV_CURRENT, ELFOSABI_FREEBSD, 0, binary.LittleEndian, ET_EXEC, EM_386, 0x80483cc},\n \t\t[]SectionHeader{\n \t\t\t{\"\", SHT_NULL, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n \t\t\t{\".interp\", SHT_PROGBITS, SHF_ALLOC, 0x80480d4, 0xd4, 0x15, 0x0, 0x0, 0x1, 0x0},\n@@ -64,10 +65,11 @@ var fileTests = []fileTest{\n \t\t\t{PT_LOAD, PF_R + PF_W, 0x5fc, 0x80495fc, 0x80495fc, 0xd8, 0xf8, 0x1000},\n \t\t\t{PT_DYNAMIC, PF_R + PF_W, 0x60c, 0x804960c, 0x804960c, 0x98, 0x98, 0x4},\n \t\t},\n+\t\t[]string{\"libc.so.6\"},\n \t},\n \t{\n \t\t\"testdata/gcc-amd64-linux-exec\",\n-\t\tFileHeader{ELFCLASS64, ELFDATA2LSB, EV_CURRENT, ELFOSABI_NONE, 0, binary.LittleEndian, ET_EXEC, EM_X86_64},\n+\t\tFileHeader{ELFCLASS64, ELFDATA2LSB, EV_CURRENT, ELFOSABI_NONE, 0, binary.LittleEndian, ET_EXEC, EM_X86_64, 0x4003e0},\n \t\t[]SectionHeader{\n \t\t\t{\"\", SHT_NULL, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n \t\t\t{\".interp\", SHT_PROGBITS, SHF_ALLOC, 0x400200, 0x200, 0x1c, 0x0, 0x0, 0x1, 0x0},\n@@ -117,6 +119,7 @@ var fileTests = []fileTest{\n \t\t\t{PT_LOOS + 0x474E550, PF_R, 0x5b8, 0x4005b8, 0x4005b8, 0x24, 0x24, 0x4},\n \t\t\t{PT_LOOS + 0x474E551, PF_R + PF_W, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8},\n \t\t},\n+\t\t[]string{\"libc.so.6\"},\n \t},\n }\n \n@@ -161,6 +164,14 @@ func TestOpen(t *testing.T) {\n \t\tif tn != fn {\n \t\t\tt.Errorf(\"open %s: len(Progs) = %d, want %d\", tt.file, fn, tn)\n \t\t}\n+\t\ttl := tt.needed\n+\t\tfl, err := f.ImportedLibraries()\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(tl, fl) {\n+\t\t\tt.Errorf(\"open %s: DT_NEEDED = %v, want %v\", tt.file, tl, fl)\n+\t\t}\n \t}\n }\n "}, {"sha": "f521566efa7abb5a8c33e172f89afb2618af0b3f", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -19,6 +19,7 @@ import (\n type File struct {\n \tFileHeader\n \tSections []*Section\n+\tSymbols  []*Symbol\n \n \tcloser io.Closer\n }\n@@ -49,6 +50,14 @@ type Section struct {\n \tsr *io.SectionReader\n }\n \n+type Symbol struct {\n+\tName          string\n+\tValue         uint32\n+\tSectionNumber int16\n+\tType          uint16\n+\tStorageClass  uint8\n+}\n+\n type ImportDirectory struct {\n \tOriginalFirstThunk uint32\n \tTimeDateStamp      uint32\n@@ -122,12 +131,13 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t}\n \tvar base int64\n \tif dosheader[0] == 'M' && dosheader[1] == 'Z' {\n+\t\tsignoff := int64(binary.LittleEndian.Uint32(dosheader[0x3c:]))\n \t\tvar sign [4]byte\n-\t\tr.ReadAt(sign[0:], int64(dosheader[0x3c]))\n+\t\tr.ReadAt(sign[:], signoff)\n \t\tif !(sign[0] == 'P' && sign[1] == 'E' && sign[2] == 0 && sign[3] == 0) {\n \t\t\treturn nil, errors.New(\"Invalid PE File Format.\")\n \t\t}\n-\t\tbase = int64(dosheader[0x3c]) + 4\n+\t\tbase = signoff + 4\n \t} else {\n \t\tbase = int64(0)\n \t}\n@@ -138,16 +148,52 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \tif f.FileHeader.Machine != IMAGE_FILE_MACHINE_UNKNOWN && f.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64 && f.FileHeader.Machine != IMAGE_FILE_MACHINE_I386 {\n \t\treturn nil, errors.New(\"Invalid PE File Format.\")\n \t}\n-\t// get symbol string table\n-\tsr.Seek(int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols), os.SEEK_SET)\n-\tvar l uint32\n-\tif err := binary.Read(sr, binary.LittleEndian, &l); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tss := make([]byte, l)\n-\tif _, err := r.ReadAt(ss, int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols)); err != nil {\n-\t\treturn nil, err\n+\n+\tvar ss []byte\n+\tif f.FileHeader.NumberOfSymbols > 0 {\n+\t\t// Get COFF string table, which is located at the end of the COFF symbol table.\n+\t\tsr.Seek(int64(f.FileHeader.PointerToSymbolTable+COFFSymbolSize*f.FileHeader.NumberOfSymbols), os.SEEK_SET)\n+\t\tvar l uint32\n+\t\tif err := binary.Read(sr, binary.LittleEndian, &l); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tss = make([]byte, l)\n+\t\tif _, err := r.ReadAt(ss, int64(f.FileHeader.PointerToSymbolTable+COFFSymbolSize*f.FileHeader.NumberOfSymbols)); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Process COFF symbol table.\n+\t\tsr.Seek(int64(f.FileHeader.PointerToSymbolTable), os.SEEK_SET)\n+\t\taux := uint8(0)\n+\t\tfor i := 0; i < int(f.FileHeader.NumberOfSymbols); i++ {\n+\t\t\tcs := new(COFFSymbol)\n+\t\t\tif err := binary.Read(sr, binary.LittleEndian, cs); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif aux > 0 {\n+\t\t\t\taux--\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvar name string\n+\t\t\tif cs.Name[0] == 0 && cs.Name[1] == 0 && cs.Name[2] == 0 && cs.Name[3] == 0 {\n+\t\t\t\tsi := int(binary.LittleEndian.Uint32(cs.Name[4:]))\n+\t\t\t\tname, _ = getString(ss, si)\n+\t\t\t} else {\n+\t\t\t\tname = cstring(cs.Name[:])\n+\t\t\t}\n+\t\t\taux = cs.NumberOfAuxSymbols\n+\t\t\ts := &Symbol{\n+\t\t\t\tName:          name,\n+\t\t\t\tValue:         cs.Value,\n+\t\t\t\tSectionNumber: cs.SectionNumber,\n+\t\t\t\tType:          cs.Type,\n+\t\t\t\tStorageClass:  cs.StorageClass,\n+\t\t\t}\n+\t\t\tf.Symbols = append(f.Symbols, s)\n+\t\t}\n \t}\n+\n+\t// Process sections.\n \tsr.Seek(base, os.SEEK_SET)\n \tbinary.Read(sr, binary.LittleEndian, &f.FileHeader)\n \tsr.Seek(int64(f.FileHeader.SizeOfOptionalHeader), os.SEEK_CUR) //Skip OptionalHeader"}, {"sha": "c0f9fcb95db770e999f5a24186d6cde42e4ef73b", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -13,6 +13,7 @@ type fileTest struct {\n \tfile     string\n \thdr      FileHeader\n \tsections []*SectionHeader\n+\tsymbols  []*Symbol\n }\n \n var fileTests = []fileTest{\n@@ -33,6 +34,24 @@ var fileTests = []fileTest{\n \t\t\t{\".debug_pubtypes\", 0, 0, 38, 1370, 1580, 0, 1, 0, 1108344832},\n \t\t\t{\".debug_aranges\", 0, 0, 32, 1408, 1590, 0, 2, 0, 1108344832},\n \t\t},\n+\t\t[]*Symbol{\n+\t\t\t{\".file\", 0x0, -2, 0x0, 0x67},\n+\t\t\t{\"_main\", 0x0, 1, 0x20, 0x2},\n+\t\t\t{\".text\", 0x0, 1, 0x0, 0x3},\n+\t\t\t{\".data\", 0x0, 2, 0x0, 0x3},\n+\t\t\t{\".bss\", 0x0, 3, 0x0, 0x3},\n+\t\t\t{\".debug_abbrev\", 0x0, 4, 0x0, 0x3},\n+\t\t\t{\".debug_info\", 0x0, 5, 0x0, 0x3},\n+\t\t\t{\".debug_line\", 0x0, 6, 0x0, 0x3},\n+\t\t\t{\".rdata\", 0x0, 7, 0x0, 0x3},\n+\t\t\t{\".debug_frame\", 0x0, 8, 0x0, 0x3},\n+\t\t\t{\".debug_loc\", 0x0, 9, 0x0, 0x3},\n+\t\t\t{\".debug_pubnames\", 0x0, 10, 0x0, 0x3},\n+\t\t\t{\".debug_pubtypes\", 0x0, 11, 0x0, 0x3},\n+\t\t\t{\".debug_aranges\", 0x0, 12, 0x0, 0x3},\n+\t\t\t{\"___main\", 0x0, 0, 0x20, 0x2},\n+\t\t\t{\"_puts\", 0x0, 0, 0x20, 0x2},\n+\t\t},\n \t},\n \t{\n \t\t\"testdata/gcc-386-mingw-exec\",\n@@ -54,6 +73,7 @@ var fileTests = []fileTest{\n \t\t\t{Name: \".debug_frame\", VirtualSize: 0x34, VirtualAddress: 0xe000, Size: 0x200, Offset: 0x3800, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42300000},\n \t\t\t{Name: \".debug_loc\", VirtualSize: 0x38, VirtualAddress: 0xf000, Size: 0x200, Offset: 0x3a00, PointerToRelocations: 0x0, PointerToLineNumbers: 0x0, NumberOfRelocations: 0x0, NumberOfLineNumbers: 0x0, Characteristics: 0x42100000},\n \t\t},\n+\t\t[]*Symbol{},\n \t},\n }\n \n@@ -86,7 +106,15 @@ func TestOpen(t *testing.T) {\n \t\tif tn != fn {\n \t\t\tt.Errorf(\"open %s: len(Sections) = %d, want %d\", tt.file, fn, tn)\n \t\t}\n-\n+\t\tfor i, have := range f.Symbols {\n+\t\t\tif i >= len(tt.symbols) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\twant := tt.symbols[i]\n+\t\t\tif !reflect.DeepEqual(have, want) {\n+\t\t\t\tt.Errorf(\"open %s, symbol %d:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, i, have, want)\n+\t\t\t}\n+\t\t}\n \t}\n }\n "}, {"sha": "0606217b3bfdf3f9c641dfd57acebd5ae09e9c63", "filename": "libgo/go/debug/pe/pe.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Fpe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fdebug%2Fpe%2Fpe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Fpe.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -27,6 +27,17 @@ type SectionHeader32 struct {\n \tCharacteristics      uint32\n }\n \n+const COFFSymbolSize = 18\n+\n+type COFFSymbol struct {\n+\tName               [8]uint8\n+\tValue              uint32\n+\tSectionNumber      int16\n+\tType               uint16\n+\tStorageClass       uint8\n+\tNumberOfAuxSymbols uint8\n+}\n+\n const (\n \tIMAGE_FILE_MACHINE_UNKNOWN   = 0x0\n \tIMAGE_FILE_MACHINE_AM33      = 0x1d3"}, {"sha": "cac9d64b5e95d7a758d20459d99d84ae1e45c997", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -77,15 +77,15 @@ func parseInt64(bytes []byte) (ret int64, err error) {\n \n // parseInt treats the given bytes as a big-endian, signed integer and returns\n // the result.\n-func parseInt(bytes []byte) (int, error) {\n+func parseInt32(bytes []byte) (int32, error) {\n \tret64, err := parseInt64(bytes)\n \tif err != nil {\n \t\treturn 0, err\n \t}\n-\tif ret64 != int64(int(ret64)) {\n+\tif ret64 != int64(int32(ret64)) {\n \t\treturn 0, StructuralError{\"integer too large\"}\n \t}\n-\treturn int(ret64), nil\n+\treturn int32(ret64), nil\n }\n \n var bigOne = big.NewInt(1)\n@@ -670,7 +670,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\terr = err1\n \t\treturn\n \tcase enumeratedType:\n-\t\tparsedInt, err1 := parseInt(innerBytes)\n+\t\tparsedInt, err1 := parseInt32(innerBytes)\n \t\tif err1 == nil {\n \t\t\tv.SetInt(int64(parsedInt))\n \t\t}\n@@ -692,19 +692,20 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t\terr = err1\n \t\treturn\n-\tcase reflect.Int, reflect.Int32:\n-\t\tparsedInt, err1 := parseInt(innerBytes)\n-\t\tif err1 == nil {\n-\t\t\tval.SetInt(int64(parsedInt))\n-\t\t}\n-\t\terr = err1\n-\t\treturn\n-\tcase reflect.Int64:\n-\t\tparsedInt, err1 := parseInt64(innerBytes)\n-\t\tif err1 == nil {\n-\t\t\tval.SetInt(parsedInt)\n+\tcase reflect.Int, reflect.Int32, reflect.Int64:\n+\t\tif val.Type().Size() == 4 {\n+\t\t\tparsedInt, err1 := parseInt32(innerBytes)\n+\t\t\tif err1 == nil {\n+\t\t\t\tval.SetInt(int64(parsedInt))\n+\t\t\t}\n+\t\t\terr = err1\n+\t\t} else {\n+\t\t\tparsedInt, err1 := parseInt64(innerBytes)\n+\t\t\tif err1 == nil {\n+\t\t\t\tval.SetInt(parsedInt)\n+\t\t\t}\n+\t\t\terr = err1\n \t\t}\n-\t\terr = err1\n \t\treturn\n \t// TODO(dfc) Add support for the remaining integer types\n \tcase reflect.Struct:"}, {"sha": "cabdf03b4824fd52e3623579d667c63baee2825b", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -64,7 +64,7 @@ var int32TestData = []int32Test{\n \n func TestParseInt32(t *testing.T) {\n \tfor i, test := range int32TestData {\n-\t\tret, err := parseInt(test.in)\n+\t\tret, err := parseInt32(test.in)\n \t\tif (err == nil) != test.ok {\n \t\t\tt.Errorf(\"#%d: Incorrect error result (did fail? %v, expected: %v)\", i, err == nil, test.ok)\n \t\t}"}, {"sha": "33a117ece195411304421f4ccedac5c6698325d4", "filename": "libgo/go/encoding/asn1/common.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -98,6 +98,8 @@ func parseFieldParameters(str string) (ret fieldParameters) {\n \t\t\tret.stringType = tagIA5String\n \t\tcase part == \"printable\":\n \t\t\tret.stringType = tagPrintableString\n+\t\tcase part == \"utf8\":\n+\t\t\tret.stringType = tagUTF8String\n \t\tcase strings.HasPrefix(part, \"default:\"):\n \t\t\ti, err := strconv.ParseInt(part[8:], 10, 64)\n \t\t\tif err == nil {"}, {"sha": "3fd6be8ad92627391dd110a5538f56a2c6798db0", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -6,11 +6,13 @@ package asn1\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"math/big\"\n \t\"reflect\"\n \t\"time\"\n+\t\"unicode/utf8\"\n )\n \n // A forkableWriter is an in-memory buffer that can be\n@@ -280,6 +282,11 @@ func marshalIA5String(out *forkableWriter, s string) (err error) {\n \treturn\n }\n \n+func marshalUTF8String(out *forkableWriter, s string) (err error) {\n+\t_, err = out.Write([]byte(s))\n+\treturn\n+}\n+\n func marshalTwoDigits(out *forkableWriter, v int) (err error) {\n \terr = out.WriteByte(byte('0' + (v/10)%10))\n \tif err != nil {\n@@ -446,10 +453,13 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\t}\n \t\treturn\n \tcase reflect.String:\n-\t\tif params.stringType == tagIA5String {\n+\t\tswitch params.stringType {\n+\t\tcase tagIA5String:\n \t\t\treturn marshalIA5String(out, v.String())\n-\t\t} else {\n+\t\tcase tagPrintableString:\n \t\t\treturn marshalPrintableString(out, v.String())\n+\t\tdefault:\n+\t\t\treturn marshalUTF8String(out, v.String())\n \t\t}\n \t\treturn\n \t}\n@@ -492,11 +502,27 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t}\n \tclass := classUniversal\n \n-\tif params.stringType != 0 {\n-\t\tif tag != tagPrintableString {\n-\t\t\treturn StructuralError{\"Explicit string type given to non-string member\"}\n+\tif params.stringType != 0 && tag != tagPrintableString {\n+\t\treturn StructuralError{\"Explicit string type given to non-string member\"}\n+\t}\n+\n+\tif tag == tagPrintableString {\n+\t\tif params.stringType == 0 {\n+\t\t\t// This is a string without an explicit string type. We'll use\n+\t\t\t// a PrintableString if the character set in the string is\n+\t\t\t// sufficiently limited, otherwise we'll use a UTF8String.\n+\t\t\tfor _, r := range v.String() {\n+\t\t\t\tif r >= utf8.RuneSelf || !isPrintable(byte(r)) {\n+\t\t\t\t\tif !utf8.ValidString(v.String()) {\n+\t\t\t\t\t\treturn errors.New(\"asn1: string not valid UTF-8\")\n+\t\t\t\t\t}\n+\t\t\t\t\ttag = tagUTF8String\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttag = params.stringType\n \t\t}\n-\t\ttag = params.stringType\n \t}\n \n \tif params.set {"}, {"sha": "c203533a91761c9a9c9c86ebc889b093d71b9ae4", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -122,6 +122,7 @@ var marshalTests = []marshalTest{\n \t{testSET([]int{10}), \"310302010a\"},\n \t{omitEmptyTest{[]string{}}, \"3000\"},\n \t{omitEmptyTest{[]string{\"1\"}}, \"30053003130131\"},\n+\t{\"\u03a3\", \"0c02cea3\"},\n }\n \n func TestMarshal(t *testing.T) {\n@@ -137,3 +138,10 @@ func TestMarshal(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestInvalidUTF8(t *testing.T) {\n+\t_, err := Marshal(string([]byte{0xff, 0xff}))\n+\tif err == nil {\n+\t\tt.Errorf(\"invalid UTF8 string was accepted\")\n+\t}\n+}"}, {"sha": "dbefc48fa37eef5a658b9aa17a20f51a5fbdee87", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -237,7 +237,6 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \t\tdlen := 8\n \n \t\t// do the top bytes contain any data?\n-\tdbufloop:\n \t\tfor j := 0; j < 8; {\n \t\t\tif len(src) == 0 {\n \t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - j)\n@@ -258,7 +257,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \t\t\t\t}\n \t\t\t\tdlen = j\n \t\t\t\tend = true\n-\t\t\t\tbreak dbufloop\n+\t\t\t\tbreak\n \t\t\t}\n \t\t\tdbuf[j] = enc.decodeMap[in]\n \t\t\tif dbuf[j] == 0xFF {"}, {"sha": "e66672a1c93e972d8c6a00589434f4782852f0bb", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -216,7 +216,6 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \t\tvar dbuf [4]byte\n \t\tdlen := 4\n \n-\tdbufloop:\n \t\tfor j := 0; j < 4; {\n \t\t\tif len(src) == 0 {\n \t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - j)\n@@ -240,7 +239,7 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \t\t\t\t}\n \t\t\t\tdlen = j\n \t\t\t\tend = true\n-\t\t\t\tbreak dbufloop\n+\t\t\t\tbreak\n \t\t\t}\n \t\t\tdbuf[j] = enc.decodeMap[in]\n \t\t\tif dbuf[j] == 0xFF {"}, {"sha": "324944cc8299ff6ab3eac21629ac8b1b8404136f", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -101,11 +101,10 @@ func (w *Writer) WriteAll(records [][]string) (err error) {\n \tfor _, record := range records {\n \t\terr = w.Write(record)\n \t\tif err != nil {\n-\t\t\tbreak\n+\t\t\treturn err\n \t\t}\n \t}\n-\tw.Flush()\n-\treturn nil\n+\treturn w.w.Flush()\n }\n \n // fieldNeedsQuotes returns true if our field must be enclosed in quotes."}, {"sha": "482212b7467b08d4d7df6cecb0c98fc467266982", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -7,6 +7,7 @@ package gob\n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"flag\"\n \t\"math\"\n \t\"math/rand\"\n \t\"reflect\"\n@@ -16,6 +17,8 @@ import (\n \t\"unsafe\"\n )\n \n+var doFuzzTests = flag.Bool(\"gob.fuzz\", false, \"run the fuzz tests, which are large and very slow\")\n+\n // Guarantee encoding format by comparing some encodings to hand-written values\n type EncodeT struct {\n \tx uint64\n@@ -1434,7 +1437,8 @@ func encFuzzDec(rng *rand.Rand, in interface{}) error {\n \n // This does some \"fuzz testing\" by attempting to decode a sequence of random bytes.\n func TestFuzz(t *testing.T) {\n-\tif testing.Short() {\n+\tif !*doFuzzTests {\n+\t\tt.Logf(\"disabled; run with -gob.fuzz to enable\")\n \t\treturn\n \t}\n \n@@ -1453,11 +1457,16 @@ func TestFuzz(t *testing.T) {\n }\n \n func TestFuzzRegressions(t *testing.T) {\n+\tif !*doFuzzTests {\n+\t\tt.Logf(\"disabled; run with -gob.fuzz to enable\")\n+\t\treturn\n+\t}\n+\n \t// An instance triggering a type name of length ~102 GB.\n \ttestFuzz(t, 1328492090837718000, 100, new(float32))\n \t// An instance triggering a type name of 1.6 GB.\n-\t// Commented out because it takes 5m to run.\n-\t//testFuzz(t, 1330522872628565000, 100, new(int))\n+\t// Note: can take several minutes to run.\n+\ttestFuzz(t, 1330522872628565000, 100, new(int))\n }\n \n func testFuzz(t *testing.T, seed int64, n int, input ...interface{}) {"}, {"sha": "900c69ddb478440684bdaaab1bcab452d225c459", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -717,7 +717,9 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \t\terrorf(\"name too long (%d bytes): %.20q...\", len(name), name)\n \t}\n \t// The concrete type must be registered.\n+\tregisterLock.RLock()\n \ttyp, ok := nameToConcreteType[name]\n+\tregisterLock.RUnlock()\n \tif !ok {\n \t\terrorf(\"name not registered for interface: %q\", name)\n \t}"}, {"sha": "04f706ca540327602488de59dad780b4e22a8846", "filename": "libgo/go/encoding/gob/decoder.go", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -87,21 +87,38 @@ func (dec *Decoder) recvMessage() bool {\n \n // readMessage reads the next nbytes bytes from the input.\n func (dec *Decoder) readMessage(nbytes int) {\n-\t// Allocate the buffer.\n-\tif cap(dec.tmp) < nbytes {\n-\t\tdec.tmp = make([]byte, nbytes+100) // room to grow\n+\t// Allocate the dec.tmp buffer, up to 10KB.\n+\tconst maxBuf = 10 * 1024\n+\tnTmp := nbytes\n+\tif nTmp > maxBuf {\n+\t\tnTmp = maxBuf\n \t}\n-\tdec.tmp = dec.tmp[:nbytes]\n+\tif cap(dec.tmp) < nTmp {\n+\t\tnAlloc := nTmp + 100 // A little extra for growth.\n+\t\tif nAlloc > maxBuf {\n+\t\t\tnAlloc = maxBuf\n+\t\t}\n+\t\tdec.tmp = make([]byte, nAlloc)\n+\t}\n+\tdec.tmp = dec.tmp[:nTmp]\n \n \t// Read the data\n-\t_, dec.err = io.ReadFull(dec.r, dec.tmp)\n-\tif dec.err != nil {\n-\t\tif dec.err == io.EOF {\n-\t\t\tdec.err = io.ErrUnexpectedEOF\n+\tdec.buf.Grow(nbytes)\n+\tfor nbytes > 0 {\n+\t\tif nbytes < nTmp {\n+\t\t\tdec.tmp = dec.tmp[:nbytes]\n \t\t}\n-\t\treturn\n+\t\tvar nRead int\n+\t\tnRead, dec.err = io.ReadFull(dec.r, dec.tmp)\n+\t\tif dec.err != nil {\n+\t\t\tif dec.err == io.EOF {\n+\t\t\t\tdec.err = io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdec.buf.Write(dec.tmp)\n+\t\tnbytes -= nRead\n \t}\n-\tdec.buf.Write(dec.tmp)\n }\n \n // toInt turns an encoded uint64 into an int, according to the marshaling rules."}, {"sha": "ea37a6cbd589c7898e2750b8098a0693cb76ca5b", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -426,6 +426,12 @@ func (enc *Encoder) encodeMap(b *bytes.Buffer, mv reflect.Value, keyOp, elemOp e\n // by the concrete value.  A nil value gets sent as the empty string for the name,\n // followed by no value.\n func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n+\t// Gobs can encode nil interface values but not typed interface\n+\t// values holding nil pointers, since nil pointers point to no value.\n+\telem := iv.Elem()\n+\tif elem.Kind() == reflect.Ptr && elem.IsNil() {\n+\t\terrorf(\"gob: cannot encode nil pointer of type %s inside interface\", iv.Elem().Type())\n+\t}\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n@@ -435,7 +441,9 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \t}\n \n \tut := userType(iv.Elem().Type())\n+\tregisterLock.RLock()\n \tname, ok := concreteTypeToName[ut.base]\n+\tregisterLock.RUnlock()\n \tif !ok {\n \t\terrorf(\"type not registered for interface: %s\", ut.base)\n \t}\n@@ -454,7 +462,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tenc.pushWriter(b)\n \tdata := new(bytes.Buffer)\n \tdata.Write(spaceForLength)\n-\tenc.encode(data, iv.Elem(), ut)\n+\tenc.encode(data, elem, ut)\n \tif enc.err != nil {\n \t\terror_(enc.err)\n \t}\n@@ -698,9 +706,20 @@ func (enc *Encoder) getEncEngine(ut *userTypeInfo) *encEngine {\n \t\terror_(err1)\n \t}\n \tif info.encoder == nil {\n-\t\t// mark this engine as underway before compiling to handle recursive types.\n+\t\t// Assign the encEngine now, so recursive types work correctly. But...\n \t\tinfo.encoder = new(encEngine)\n+\t\t// ... if we fail to complete building the engine, don't cache the half-built machine.\n+\t\t// Doing this here means we won't cache a type that is itself OK but\n+\t\t// that contains a nested type that won't compile. The result is consistent\n+\t\t// error behavior when Encode is called multiple times on the top-level type.\n+\t\tok := false\n+\t\tdefer func() {\n+\t\t\tif !ok {\n+\t\t\t\tinfo.encoder = nil\n+\t\t\t}\n+\t\t}()\n \t\tinfo.encoder = enc.compileEnc(ut)\n+\t\tok = true\n \t}\n \treturn info.encoder\n }"}, {"sha": "51444bb5269f2dc177702a138f89dd1bd1011242", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -218,6 +218,12 @@ func (enc *Encoder) sendTypeId(state *encoderState, ut *userTypeInfo) {\n // EncodeValue transmits the data item represented by the reflection value,\n // guaranteeing that all necessary type information has been transmitted first.\n func (enc *Encoder) EncodeValue(value reflect.Value) error {\n+\t// Gobs contain values. They cannot represent nil pointers, which\n+\t// have no value to encode.\n+\tif value.Kind() == reflect.Ptr && value.IsNil() {\n+\t\tpanic(\"gob: cannot encode nil pointer of type \" + value.Type().String())\n+\t}\n+\n \t// Make sure we're single-threaded through here, so multiple\n \t// goroutines can share an encoder.\n \tenc.mutex.Lock()"}, {"sha": "b684772c69150861b4afd6616fb99077db1599b9", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -737,6 +737,83 @@ func TestPtrToMapOfMap(t *testing.T) {\n \t}\n }\n \n+// A top-level nil pointer generates a panic with a helpful string-valued message.\n+func TestTopLevelNilPointer(t *testing.T) {\n+\terrMsg := topLevelNilPanic(t)\n+\tif errMsg == \"\" {\n+\t\tt.Fatal(\"top-level nil pointer did not panic\")\n+\t}\n+\tif !strings.Contains(errMsg, \"nil pointer\") {\n+\t\tt.Fatal(\"expected nil pointer error, got:\", errMsg)\n+\t}\n+}\n+\n+func topLevelNilPanic(t *testing.T) (panicErr string) {\n+\tdefer func() {\n+\t\te := recover()\n+\t\tif err, ok := e.(string); ok {\n+\t\t\tpanicErr = err\n+\t\t}\n+\t}()\n+\tvar ip *int\n+\tbuf := new(bytes.Buffer)\n+\tif err := NewEncoder(buf).Encode(ip); err != nil {\n+\t\tt.Fatal(\"error in encode:\", err)\n+\t}\n+\treturn\n+}\n+\n+func TestNilPointerInsideInterface(t *testing.T) {\n+\tvar ip *int\n+\tsi := struct {\n+\t\tI interface{}\n+\t}{\n+\t\tI: ip,\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\terr := NewEncoder(buf).Encode(si)\n+\tif err == nil {\n+\t\tt.Fatal(\"expected error, got none\")\n+\t}\n+\terrMsg := err.Error()\n+\tif !strings.Contains(errMsg, \"nil pointer\") || !strings.Contains(errMsg, \"interface\") {\n+\t\tt.Fatal(\"expected error about nil pointer and interface, got:\", errMsg)\n+\t}\n+}\n+\n+type Bug4Public struct {\n+\tName   string\n+\tSecret Bug4Secret\n+}\n+\n+type Bug4Secret struct {\n+\ta int // error: no exported fields.\n+}\n+\n+// Test that a failed compilation doesn't leave around an executable encoder.\n+// Issue 3273.\n+func TestMutipleEncodingsOfBadType(t *testing.T) {\n+\tx := Bug4Public{\n+\t\tName:   \"name\",\n+\t\tSecret: Bug4Secret{1},\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\tenc := NewEncoder(buf)\n+\terr := enc.Encode(x)\n+\tif err == nil {\n+\t\tt.Fatal(\"first encoding: expected error\")\n+\t}\n+\tbuf.Reset()\n+\tenc = NewEncoder(buf)\n+\terr = enc.Encode(x)\n+\tif err == nil {\n+\t\tt.Fatal(\"second encoding: expected error\")\n+\t}\n+\tif !strings.Contains(err.Error(), \"no exported fields\") {\n+\t\tt.Errorf(\"expected error about no exported fields; got %v\", err)\n+\t}\n+}\n+\n // There was an error check comparing the length of the input with the\n // length of the slice being decoded. It was wrong because the next\n // thing in the input might be a type definition, which would lead to"}, {"sha": "ea0db4eac45276a61768d3a384fcc6f35e298568", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -712,6 +712,7 @@ type GobDecoder interface {\n }\n \n var (\n+\tregisterLock       sync.RWMutex\n \tnameToConcreteType = make(map[string]reflect.Type)\n \tconcreteTypeToName = make(map[reflect.Type]string)\n )\n@@ -723,6 +724,8 @@ func RegisterName(name string, value interface{}) {\n \t\t// reserved for nil\n \t\tpanic(\"attempt to register empty name\")\n \t}\n+\tregisterLock.Lock()\n+\tdefer registerLock.Unlock()\n \tut := userType(reflect.TypeOf(value))\n \t// Check for incompatible duplicates. The name must refer to the\n \t// same user type, and vice versa."}, {"sha": "e230d22d4315584702e5f89ace19f6ee8088b547", "filename": "libgo/go/encoding/gob/type_test.go", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,6 +5,7 @@\n package gob\n \n import (\n+\t\"bytes\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -159,3 +160,63 @@ func TestRegistration(t *testing.T) {\n \tRegister(new(T))\n \tRegister(new(T))\n }\n+\n+type N1 struct{}\n+type N2 struct{}\n+\n+// See comment in type.go/Register.\n+func TestRegistrationNaming(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tt    interface{}\n+\t\tname string\n+\t}{\n+\t\t{&N1{}, \"*gob.N1\"},\n+\t\t{N2{}, \"encoding/gob.N2\"},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tRegister(tc.t)\n+\n+\t\ttct := reflect.TypeOf(tc.t)\n+\t\tregisterLock.RLock()\n+\t\tct := nameToConcreteType[tc.name]\n+\t\tregisterLock.RUnlock()\n+\t\tif ct != tct {\n+\t\t\tt.Errorf(\"nameToConcreteType[%q] = %v, want %v\", tc.name, ct, tct)\n+\t\t}\n+\t\t// concreteTypeToName is keyed off the base type.\n+\t\tif tct.Kind() == reflect.Ptr {\n+\t\t\ttct = tct.Elem()\n+\t\t}\n+\t\tif n := concreteTypeToName[tct]; n != tc.name {\n+\t\t\tt.Errorf(\"concreteTypeToName[%v] got %v, want %v\", tct, n, tc.name)\n+\t\t}\n+\t}\n+}\n+\n+func TestStressParallel(t *testing.T) {\n+\ttype T2 struct{ A int }\n+\tc := make(chan bool)\n+\tconst N = 10\n+\tfor i := 0; i < N; i++ {\n+\t\tgo func() {\n+\t\t\tp := new(T2)\n+\t\t\tRegister(p)\n+\t\t\tb := new(bytes.Buffer)\n+\t\t\tenc := NewEncoder(b)\n+\t\t\terr := enc.Encode(p)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"encoder fail:\", err)\n+\t\t\t}\n+\t\t\tdec := NewDecoder(b)\n+\t\t\terr = dec.Decode(p)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(\"decoder fail:\", err)\n+\t\t\t}\n+\t\t\tc <- true\n+\t\t}()\n+\t}\n+\tfor i := 0; i < N; i++ {\n+\t\t<-c\n+\t}\n+}"}, {"sha": "47e3d89aa358ca0a8cb529aa779b45ffd0730fae", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -137,6 +137,22 @@ func (d *decodeState) unmarshal(v interface{}) (err error) {\n \treturn d.savedError\n }\n \n+// A Number represents a JSON number literal.\n+type Number string\n+\n+// String returns the literal text of the number.\n+func (n Number) String() string { return string(n) }\n+\n+// Float64 returns the number as a float64.\n+func (n Number) Float64() (float64, error) {\n+\treturn strconv.ParseFloat(string(n), 64)\n+}\n+\n+// Int64 returns the number as an int64.\n+func (n Number) Int64() (int64, error) {\n+\treturn strconv.ParseInt(string(n), 10, 64)\n+}\n+\n // decodeState represents the state while decoding a JSON value.\n type decodeState struct {\n \tdata       []byte\n@@ -145,6 +161,7 @@ type decodeState struct {\n \tnextscan   scanner // for calls to nextValue\n \tsavedError error\n \ttempstr    string // scratch space to avoid some allocations\n+\tuseNumber  bool\n }\n \n // errPhase is used for errors that should not happen unless\n@@ -265,47 +282,32 @@ func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler,\n \t\tv = v.Addr()\n \t}\n \tfor {\n-\t\tvar isUnmarshaler bool\n-\t\tif v.Type().NumMethod() > 0 {\n-\t\t\t// Remember that this is an unmarshaler,\n-\t\t\t// but wait to return it until after allocating\n-\t\t\t// the pointer (if necessary).\n-\t\t\t_, isUnmarshaler = v.Interface().(Unmarshaler)\n-\t\t}\n-\n \t\t// Load value from interface, but only if the result will be\n \t\t// usefully addressable.\n-\t\tif iv := v; iv.Kind() == reflect.Interface && !iv.IsNil() {\n-\t\t\te := iv.Elem()\n+\t\tif v.Kind() == reflect.Interface && !v.IsNil() {\n+\t\t\te := v.Elem()\n \t\t\tif e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {\n \t\t\t\tv = e\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \n-\t\tpv := v\n-\t\tif pv.Kind() != reflect.Ptr {\n+\t\tif v.Kind() != reflect.Ptr {\n \t\t\tbreak\n \t\t}\n \n-\t\tif pv.Elem().Kind() != reflect.Ptr && decodingNull && pv.CanSet() {\n-\t\t\treturn nil, pv\n+\t\tif v.Elem().Kind() != reflect.Ptr && decodingNull && v.CanSet() {\n+\t\t\tbreak\n \t\t}\n-\t\tif pv.IsNil() {\n-\t\t\tpv.Set(reflect.New(pv.Type().Elem()))\n+\t\tif v.IsNil() {\n+\t\t\tv.Set(reflect.New(v.Type().Elem()))\n \t\t}\n-\t\tif isUnmarshaler {\n-\t\t\t// Using v.Interface().(Unmarshaler)\n-\t\t\t// here means that we have to use a pointer\n-\t\t\t// as the struct field.  We cannot use a value inside\n-\t\t\t// a pointer to a struct, because in that case\n-\t\t\t// v.Interface() is the value (x.f) not the pointer (&x.f).\n-\t\t\t// This is an unfortunate consequence of reflect.\n-\t\t\t// An alternative would be to look up the\n-\t\t\t// UnmarshalJSON method and return a FuncValue.\n-\t\t\treturn v.Interface().(Unmarshaler), reflect.Value{}\n+\t\tif v.Type().NumMethod() > 0 {\n+\t\t\tif unmarshaler, ok := v.Interface().(Unmarshaler); ok {\n+\t\t\t\treturn unmarshaler, reflect.Value{}\n+\t\t\t}\n \t\t}\n-\t\tv = pv.Elem()\n+\t\tv = v.Elem()\n \t}\n \treturn nil, v\n }\n@@ -491,51 +493,39 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\t}\n \t\t\tsubv = mapElem\n \t\t} else {\n-\t\t\tvar f reflect.StructField\n-\t\t\tvar ok bool\n-\t\t\tst := sv.Type()\n-\t\t\tfor i := 0; i < sv.NumField(); i++ {\n-\t\t\t\tsf := st.Field(i)\n-\t\t\t\ttag := sf.Tag.Get(\"json\")\n-\t\t\t\tif tag == \"-\" {\n-\t\t\t\t\t// Pretend this field doesn't exist.\n-\t\t\t\t\tcontinue\n+\t\t\tvar f *field\n+\t\t\tfields := cachedTypeFields(sv.Type())\n+\t\t\tfor i := range fields {\n+\t\t\t\tff := &fields[i]\n+\t\t\t\tif ff.name == key {\n+\t\t\t\t\tf = ff\n+\t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tif sf.Anonymous {\n-\t\t\t\t\t// Pretend this field doesn't exist,\n-\t\t\t\t\t// so that we can do a good job with\n-\t\t\t\t\t// these in a later version.\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\t// First, tag match\n-\t\t\t\ttagName, _ := parseTag(tag)\n-\t\t\t\tif tagName == key {\n-\t\t\t\t\tf = sf\n-\t\t\t\t\tok = true\n-\t\t\t\t\tbreak // no better match possible\n-\t\t\t\t}\n-\t\t\t\t// Second, exact field name match\n-\t\t\t\tif sf.Name == key {\n-\t\t\t\t\tf = sf\n-\t\t\t\t\tok = true\n-\t\t\t\t}\n-\t\t\t\t// Third, case-insensitive field name match,\n-\t\t\t\t// but only if a better match hasn't already been seen\n-\t\t\t\tif !ok && strings.EqualFold(sf.Name, key) {\n-\t\t\t\t\tf = sf\n-\t\t\t\t\tok = true\n+\t\t\t\tif f == nil && strings.EqualFold(ff.name, key) {\n+\t\t\t\t\tf = ff\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\t// Extract value; name must be exported.\n-\t\t\tif ok {\n-\t\t\t\tif f.PkgPath != \"\" {\n-\t\t\t\t\td.saveError(&UnmarshalFieldError{key, st, f})\n-\t\t\t\t} else {\n-\t\t\t\t\tsubv = sv.FieldByIndex(f.Index)\n+\t\t\tif f != nil {\n+\t\t\t\tsubv = sv\n+\t\t\t\tdestring = f.quoted\n+\t\t\t\tfor _, i := range f.index {\n+\t\t\t\t\tif subv.Kind() == reflect.Ptr {\n+\t\t\t\t\t\tif subv.IsNil() {\n+\t\t\t\t\t\t\tsubv.Set(reflect.New(subv.Type().Elem()))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tsubv = subv.Elem()\n+\t\t\t\t\t}\n+\t\t\t\t\tsubv = subv.Field(i)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// To give a good error, a quick scan for unexported fields in top level.\n+\t\t\t\tst := sv.Type()\n+\t\t\t\tfor i := 0; i < st.NumField(); i++ {\n+\t\t\t\t\tf := st.Field(i)\n+\t\t\t\t\tif f.PkgPath != \"\" && strings.EqualFold(f.Name, key) {\n+\t\t\t\t\t\td.saveError(&UnmarshalFieldError{key, st, f})\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\t_, opts := parseTag(f.Tag.Get(\"json\"))\n-\t\t\t\tdestring = opts.Contains(\"string\")\n \t\t\t}\n \t\t}\n \n@@ -586,6 +576,21 @@ func (d *decodeState) literal(v reflect.Value) {\n \td.literalStore(d.data[start:d.off], v, false)\n }\n \n+// convertNumber converts the number literal s to a float64 or a Number\n+// depending on the setting of d.useNumber.\n+func (d *decodeState) convertNumber(s string) (interface{}, error) {\n+\tif d.useNumber {\n+\t\treturn Number(s), nil\n+\t}\n+\tf, err := strconv.ParseFloat(s, 64)\n+\tif err != nil {\n+\t\treturn nil, &UnmarshalTypeError{\"number \" + s, reflect.TypeOf(0.0)}\n+\t}\n+\treturn f, nil\n+}\n+\n+var numberType = reflect.TypeOf(Number(\"\"))\n+\n // literalStore decodes a literal stored in item into v.\n //\n // fromQuoted indicates whether this literal came from unwrapping a\n@@ -674,15 +679,19 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\ts := string(item)\n \t\tswitch v.Kind() {\n \t\tdefault:\n+\t\t\tif v.Kind() == reflect.String && v.Type() == numberType {\n+\t\t\t\tv.SetString(s)\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\tif fromQuoted {\n \t\t\t\td.error(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n \t\t\t} else {\n \t\t\t\td.error(&UnmarshalTypeError{\"number\", v.Type()})\n \t\t\t}\n \t\tcase reflect.Interface:\n-\t\t\tn, err := strconv.ParseFloat(s, 64)\n+\t\t\tn, err := d.convertNumber(s)\n \t\t\tif err != nil {\n-\t\t\t\td.saveError(&UnmarshalTypeError{\"number \" + s, v.Type()})\n+\t\t\t\td.saveError(err)\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tv.Set(reflect.ValueOf(n))\n@@ -836,9 +845,9 @@ func (d *decodeState) literalInterface() interface{} {\n \t\tif c != '-' && (c < '0' || c > '9') {\n \t\t\td.error(errPhase)\n \t\t}\n-\t\tn, err := strconv.ParseFloat(string(item), 64)\n+\t\tn, err := d.convertNumber(string(item))\n \t\tif err != nil {\n-\t\t\td.saveError(&UnmarshalTypeError{\"number \" + string(item), reflect.TypeOf(0.0)})\n+\t\t\td.saveError(err)\n \t\t}\n \t\treturn n\n \t}\n@@ -979,11 +988,3 @@ func unquoteBytes(s []byte) (t []byte, ok bool) {\n \t}\n \treturn b[0:w], true\n }\n-\n-// The following is issue 3069.\n-\n-// BUG(rsc): This package ignores anonymous (embedded) struct fields\n-// during encoding and decoding.  A future version may assign meaning\n-// to them.  To force an anonymous field to be ignored in all future\n-// versions of this package, use an explicit `json:\"-\"` tag in the struct\n-// definition."}, {"sha": "f2da141b8f999aa7ba05c2e920415f377b9fd3b2", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 314, "deletions": 64, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -7,6 +7,7 @@ package json\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"image\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -18,6 +19,32 @@ type T struct {\n \tZ int `json:\"-\"`\n }\n \n+type U struct {\n+\tAlphabet string `json:\"alpha\"`\n+}\n+\n+type V struct {\n+\tF1 interface{}\n+\tF2 int32\n+\tF3 Number\n+}\n+\n+// ifaceNumAsFloat64/ifaceNumAsNumber are used to test unmarshalling with and\n+// without UseNumber\n+var ifaceNumAsFloat64 = map[string]interface{}{\n+\t\"k1\": float64(1),\n+\t\"k2\": \"s\",\n+\t\"k3\": []interface{}{float64(1), float64(2.0), float64(3e-3)},\n+\t\"k4\": map[string]interface{}{\"kk1\": \"s\", \"kk2\": float64(2)},\n+}\n+\n+var ifaceNumAsNumber = map[string]interface{}{\n+\t\"k1\": Number(\"1\"),\n+\t\"k2\": \"s\",\n+\t\"k3\": []interface{}{Number(\"1\"), Number(\"2.0\"), Number(\"3e-3\")},\n+\t\"k4\": map[string]interface{}{\"kk1\": \"s\", \"kk2\": Number(\"2\")},\n+}\n+\n type tx struct {\n \tx int\n }\n@@ -48,55 +75,237 @@ var (\n \tumstruct = ustruct{unmarshaler{true}}\n )\n \n+// Test data structures for anonymous fields.\n+\n+type Point struct {\n+\tZ int\n+}\n+\n+type Top struct {\n+\tLevel0 int\n+\tEmbed0\n+\t*Embed0a\n+\t*Embed0b `json:\"e,omitempty\"` // treated as named\n+\tEmbed0c  `json:\"-\"`           // ignored\n+\tLoop\n+\tEmbed0p // has Point with X, Y, used\n+\tEmbed0q // has Point with Z, used\n+}\n+\n+type Embed0 struct {\n+\tLevel1a int // overridden by Embed0a's Level1a with json tag\n+\tLevel1b int // used because Embed0a's Level1b is renamed\n+\tLevel1c int // used because Embed0a's Level1c is ignored\n+\tLevel1d int // annihilated by Embed0a's Level1d\n+\tLevel1e int `json:\"x\"` // annihilated by Embed0a.Level1e\n+}\n+\n+type Embed0a struct {\n+\tLevel1a int `json:\"Level1a,omitempty\"`\n+\tLevel1b int `json:\"LEVEL1B,omitempty\"`\n+\tLevel1c int `json:\"-\"`\n+\tLevel1d int // annihilated by Embed0's Level1d\n+\tLevel1f int `json:\"x\"` // annihilated by Embed0's Level1e\n+}\n+\n+type Embed0b Embed0\n+\n+type Embed0c Embed0\n+\n+type Embed0p struct {\n+\timage.Point\n+}\n+\n+type Embed0q struct {\n+\tPoint\n+}\n+\n+type Loop struct {\n+\tLoop1 int `json:\",omitempty\"`\n+\tLoop2 int `json:\",omitempty\"`\n+\t*Loop\n+}\n+\n+// From reflect test:\n+// The X in S6 and S7 annihilate, but they also block the X in S8.S9.\n+type S5 struct {\n+\tS6\n+\tS7\n+\tS8\n+}\n+\n+type S6 struct {\n+\tX int\n+}\n+\n+type S7 S6\n+\n+type S8 struct {\n+\tS9\n+}\n+\n+type S9 struct {\n+\tX int\n+\tY int\n+}\n+\n+// From reflect test:\n+// The X in S11.S6 and S12.S6 annihilate, but they also block the X in S13.S8.S9.\n+type S10 struct {\n+\tS11\n+\tS12\n+\tS13\n+}\n+\n+type S11 struct {\n+\tS6\n+}\n+\n+type S12 struct {\n+\tS6\n+}\n+\n+type S13 struct {\n+\tS8\n+}\n+\n type unmarshalTest struct {\n-\tin  string\n-\tptr interface{}\n-\tout interface{}\n-\terr error\n+\tin        string\n+\tptr       interface{}\n+\tout       interface{}\n+\terr       error\n+\tuseNumber bool\n+}\n+\n+type Ambig struct {\n+\t// Given \"hello\", the first match should win.\n+\tFirst  int `json:\"HELLO\"`\n+\tSecond int `json:\"Hello\"`\n }\n \n var unmarshalTests = []unmarshalTest{\n \t// basic types\n-\t{`true`, new(bool), true, nil},\n-\t{`1`, new(int), 1, nil},\n-\t{`1.2`, new(float64), 1.2, nil},\n-\t{`-5`, new(int16), int16(-5), nil},\n-\t{`\"a\\u1234\"`, new(string), \"a\\u1234\", nil},\n-\t{`\"http:\\/\\/\"`, new(string), \"http://\", nil},\n-\t{`\"g-clef: \\uD834\\uDD1E\"`, new(string), \"g-clef: \\U0001D11E\", nil},\n-\t{`\"invalid: \\uD834x\\uDD1E\"`, new(string), \"invalid: \\uFFFDx\\uFFFD\", nil},\n-\t{\"null\", new(interface{}), nil, nil},\n-\t{`{\"X\": [1,2,3], \"Y\": 4}`, new(T), T{Y: 4}, &UnmarshalTypeError{\"array\", reflect.TypeOf(\"\")}},\n-\t{`{\"x\": 1}`, new(tx), tx{}, &UnmarshalFieldError{\"x\", txType, txType.Field(0)}},\n+\t{in: `true`, ptr: new(bool), out: true},\n+\t{in: `1`, ptr: new(int), out: 1},\n+\t{in: `1.2`, ptr: new(float64), out: 1.2},\n+\t{in: `-5`, ptr: new(int16), out: int16(-5)},\n+\t{in: `2`, ptr: new(Number), out: Number(\"2\"), useNumber: true},\n+\t{in: `2`, ptr: new(Number), out: Number(\"2\")},\n+\t{in: `2`, ptr: new(interface{}), out: float64(2.0)},\n+\t{in: `2`, ptr: new(interface{}), out: Number(\"2\"), useNumber: true},\n+\t{in: `\"a\\u1234\"`, ptr: new(string), out: \"a\\u1234\"},\n+\t{in: `\"http:\\/\\/\"`, ptr: new(string), out: \"http://\"},\n+\t{in: `\"g-clef: \\uD834\\uDD1E\"`, ptr: new(string), out: \"g-clef: \\U0001D11E\"},\n+\t{in: `\"invalid: \\uD834x\\uDD1E\"`, ptr: new(string), out: \"invalid: \\uFFFDx\\uFFFD\"},\n+\t{in: \"null\", ptr: new(interface{}), out: nil},\n+\t{in: `{\"X\": [1,2,3], \"Y\": 4}`, ptr: new(T), out: T{Y: 4}, err: &UnmarshalTypeError{\"array\", reflect.TypeOf(\"\")}},\n+\t{in: `{\"x\": 1}`, ptr: new(tx), out: tx{}, err: &UnmarshalFieldError{\"x\", txType, txType.Field(0)}},\n+\t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: float64(1), F2: int32(2), F3: Number(\"3\")}},\n+\t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: Number(\"1\"), F2: int32(2), F3: Number(\"3\")}, useNumber: true},\n+\t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsFloat64},\n+\t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsNumber, useNumber: true},\n \n \t// Z has a \"-\" tag.\n-\t{`{\"Y\": 1, \"Z\": 2}`, new(T), T{Y: 1}, nil},\n+\t{in: `{\"Y\": 1, \"Z\": 2}`, ptr: new(T), out: T{Y: 1}},\n+\n+\t{in: `{\"alpha\": \"abc\", \"alphabet\": \"xyz\"}`, ptr: new(U), out: U{Alphabet: \"abc\"}},\n+\t{in: `{\"alpha\": \"abc\"}`, ptr: new(U), out: U{Alphabet: \"abc\"}},\n+\t{in: `{\"alphabet\": \"xyz\"}`, ptr: new(U), out: U{}},\n \n \t// syntax errors\n-\t{`{\"X\": \"foo\", \"Y\"}`, nil, nil, &SyntaxError{\"invalid character '}' after object key\", 17}},\n-\t{`[1, 2, 3+]`, nil, nil, &SyntaxError{\"invalid character '+' after array element\", 9}},\n+\t{in: `{\"X\": \"foo\", \"Y\"}`, err: &SyntaxError{\"invalid character '}' after object key\", 17}},\n+\t{in: `[1, 2, 3+]`, err: &SyntaxError{\"invalid character '+' after array element\", 9}},\n+\t{in: `{\"X\":12x}`, err: &SyntaxError{\"invalid character 'x' after object key:value pair\", 8}, useNumber: true},\n \n \t// array tests\n-\t{`[1, 2, 3]`, new([3]int), [3]int{1, 2, 3}, nil},\n-\t{`[1, 2, 3]`, new([1]int), [1]int{1}, nil},\n-\t{`[1, 2, 3]`, new([5]int), [5]int{1, 2, 3, 0, 0}, nil},\n+\t{in: `[1, 2, 3]`, ptr: new([3]int), out: [3]int{1, 2, 3}},\n+\t{in: `[1, 2, 3]`, ptr: new([1]int), out: [1]int{1}},\n+\t{in: `[1, 2, 3]`, ptr: new([5]int), out: [5]int{1, 2, 3, 0, 0}},\n \n \t// composite tests\n-\t{allValueIndent, new(All), allValue, nil},\n-\t{allValueCompact, new(All), allValue, nil},\n-\t{allValueIndent, new(*All), &allValue, nil},\n-\t{allValueCompact, new(*All), &allValue, nil},\n-\t{pallValueIndent, new(All), pallValue, nil},\n-\t{pallValueCompact, new(All), pallValue, nil},\n-\t{pallValueIndent, new(*All), &pallValue, nil},\n-\t{pallValueCompact, new(*All), &pallValue, nil},\n+\t{in: allValueIndent, ptr: new(All), out: allValue},\n+\t{in: allValueCompact, ptr: new(All), out: allValue},\n+\t{in: allValueIndent, ptr: new(*All), out: &allValue},\n+\t{in: allValueCompact, ptr: new(*All), out: &allValue},\n+\t{in: pallValueIndent, ptr: new(All), out: pallValue},\n+\t{in: pallValueCompact, ptr: new(All), out: pallValue},\n+\t{in: pallValueIndent, ptr: new(*All), out: &pallValue},\n+\t{in: pallValueCompact, ptr: new(*All), out: &pallValue},\n \n \t// unmarshal interface test\n-\t{`{\"T\":false}`, &um0, umtrue, nil}, // use \"false\" so test will fail if custom unmarshaler is not called\n-\t{`{\"T\":false}`, &ump, &umtrue, nil},\n-\t{`[{\"T\":false}]`, &umslice, umslice, nil},\n-\t{`[{\"T\":false}]`, &umslicep, &umslice, nil},\n-\t{`{\"M\":{\"T\":false}}`, &umstruct, umstruct, nil},\n+\t{in: `{\"T\":false}`, ptr: &um0, out: umtrue}, // use \"false\" so test will fail if custom unmarshaler is not called\n+\t{in: `{\"T\":false}`, ptr: &ump, out: &umtrue},\n+\t{in: `[{\"T\":false}]`, ptr: &umslice, out: umslice},\n+\t{in: `[{\"T\":false}]`, ptr: &umslicep, out: &umslice},\n+\t{in: `{\"M\":{\"T\":false}}`, ptr: &umstruct, out: umstruct},\n+\n+\t{\n+\t\tin: `{\n+\t\t\t\"Level0\": 1,\n+\t\t\t\"Level1b\": 2,\n+\t\t\t\"Level1c\": 3,\n+\t\t\t\"x\": 4,\n+\t\t\t\"Level1a\": 5,\n+\t\t\t\"LEVEL1B\": 6,\n+\t\t\t\"e\": {\n+\t\t\t\t\"Level1a\": 8,\n+\t\t\t\t\"Level1b\": 9,\n+\t\t\t\t\"Level1c\": 10,\n+\t\t\t\t\"Level1d\": 11,\n+\t\t\t\t\"x\": 12\n+\t\t\t},\n+\t\t\t\"Loop1\": 13,\n+\t\t\t\"Loop2\": 14,\n+\t\t\t\"X\": 15,\n+\t\t\t\"Y\": 16,\n+\t\t\t\"Z\": 17\n+\t\t}`,\n+\t\tptr: new(Top),\n+\t\tout: Top{\n+\t\t\tLevel0: 1,\n+\t\t\tEmbed0: Embed0{\n+\t\t\t\tLevel1b: 2,\n+\t\t\t\tLevel1c: 3,\n+\t\t\t},\n+\t\t\tEmbed0a: &Embed0a{\n+\t\t\t\tLevel1a: 5,\n+\t\t\t\tLevel1b: 6,\n+\t\t\t},\n+\t\t\tEmbed0b: &Embed0b{\n+\t\t\t\tLevel1a: 8,\n+\t\t\t\tLevel1b: 9,\n+\t\t\t\tLevel1c: 10,\n+\t\t\t\tLevel1d: 11,\n+\t\t\t\tLevel1e: 12,\n+\t\t\t},\n+\t\t\tLoop: Loop{\n+\t\t\t\tLoop1: 13,\n+\t\t\t\tLoop2: 14,\n+\t\t\t},\n+\t\t\tEmbed0p: Embed0p{\n+\t\t\t\tPoint: image.Point{X: 15, Y: 16},\n+\t\t\t},\n+\t\t\tEmbed0q: Embed0q{\n+\t\t\t\tPoint: Point{Z: 17},\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tin:  `{\"hello\": 1}`,\n+\t\tptr: new(Ambig),\n+\t\tout: Ambig{First: 1},\n+\t},\n+\n+\t{\n+\t\tin:  `{\"X\": 1,\"Y\":2}`,\n+\t\tptr: new(S5),\n+\t\tout: S5{S8: S8{S9: S9{Y: 2}}},\n+\t},\n+\t{\n+\t\tin:  `{\"X\": 1,\"Y\":2}`,\n+\t\tptr: new(S10),\n+\t\tout: S10{S13: S13{S8: S8{S9: S9{Y: 2}}}},\n+\t},\n }\n \n func TestMarshal(t *testing.T) {\n@@ -135,6 +344,18 @@ func TestMarshalBadUTF8(t *testing.T) {\n \t}\n }\n \n+func TestMarshalNumberZeroVal(t *testing.T) {\n+\tvar n Number\n+\tout, err := Marshal(n)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\toutStr := string(out)\n+\tif outStr != \"0\" {\n+\t\tt.Fatalf(\"Invalid zero val for Number: %q\", outStr)\n+\t}\n+}\n+\n func TestUnmarshal(t *testing.T) {\n \tfor i, tt := range unmarshalTests {\n \t\tvar scan scanner\n@@ -150,7 +371,11 @@ func TestUnmarshal(t *testing.T) {\n \t\t}\n \t\t// v = new(right-type)\n \t\tv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n-\t\tif err := Unmarshal([]byte(in), v.Interface()); !reflect.DeepEqual(err, tt.err) {\n+\t\tdec := NewDecoder(bytes.NewBuffer(in))\n+\t\tif tt.useNumber {\n+\t\t\tdec.UseNumber()\n+\t\t}\n+\t\tif err := dec.Decode(v.Interface()); !reflect.DeepEqual(err, tt.err) {\n \t\t\tt.Errorf(\"#%d: %v want %v\", i, err, tt.err)\n \t\t\tcontinue\n \t\t}\n@@ -162,6 +387,28 @@ func TestUnmarshal(t *testing.T) {\n \t\t\tprintln(string(data))\n \t\t\tcontinue\n \t\t}\n+\n+\t\t// Check round trip.\n+\t\tif tt.err == nil {\n+\t\t\tenc, err := Marshal(v.Interface())\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"#%d: error re-marshaling: %v\", i, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n+\t\t\tdec = NewDecoder(bytes.NewBuffer(enc))\n+\t\t\tif tt.useNumber {\n+\t\t\t\tdec.UseNumber()\n+\t\t\t}\n+\t\t\tif err := dec.Decode(vv.Interface()); err != nil {\n+\t\t\t\tt.Errorf(\"#%d: error re-unmarshaling: %v\", i, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(v.Elem().Interface(), vv.Elem().Interface()) {\n+\t\t\t\tt.Errorf(\"#%d: mismatch\\nhave: %#+v\\nwant: %#+v\", i, v.Elem().Interface(), vv.Elem().Interface())\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -182,6 +429,38 @@ func TestUnmarshalMarshal(t *testing.T) {\n \t}\n }\n \n+var numberTests = []struct {\n+\tin       string\n+\ti        int64\n+\tintErr   string\n+\tf        float64\n+\tfloatErr string\n+}{\n+\t{in: \"-1.23e1\", intErr: \"strconv.ParseInt: parsing \\\"-1.23e1\\\": invalid syntax\", f: -1.23e1},\n+\t{in: \"-12\", i: -12, f: -12.0},\n+\t{in: \"1e1000\", intErr: \"strconv.ParseInt: parsing \\\"1e1000\\\": invalid syntax\", floatErr: \"strconv.ParseFloat: parsing \\\"1e1000\\\": value out of range\"},\n+}\n+\n+// Independent of Decode, basic coverage of the accessors in Number\n+func TestNumberAccessors(t *testing.T) {\n+\tfor _, tt := range numberTests {\n+\t\tn := Number(tt.in)\n+\t\tif s := n.String(); s != tt.in {\n+\t\t\tt.Errorf(\"Number(%q).String() is %q\", tt.in, s)\n+\t\t}\n+\t\tif i, err := n.Int64(); err == nil && tt.intErr == \"\" && i != tt.i {\n+\t\t\tt.Errorf(\"Number(%q).Int64() is %d\", tt.in, i)\n+\t\t} else if (err == nil && tt.intErr != \"\") || (err != nil && err.Error() != tt.intErr) {\n+\t\t\tt.Errorf(\"Number(%q).Int64() wanted error %q but got: %v\", tt.in, tt.intErr, err)\n+\t\t}\n+\t\tif f, err := n.Float64(); err == nil && tt.floatErr == \"\" && f != tt.f {\n+\t\t\tt.Errorf(\"Number(%q).Float64() is %g\", tt.in, f)\n+\t\t} else if (err == nil && tt.floatErr != \"\") || (err != nil && err.Error() != tt.floatErr) {\n+\t\t\tt.Errorf(\"Number(%q).Float64() wanted error %q but got: %v\", tt.in, tt.floatErr, err)\n+\t\t}\n+\t}\n+}\n+\n func TestLargeByteSlice(t *testing.T) {\n \ts0 := make([]byte, 2000)\n \tfor i := range s0 {\n@@ -610,35 +889,6 @@ func TestRefUnmarshal(t *testing.T) {\n \t}\n }\n \n-// Test that anonymous fields are ignored.\n-// We may assign meaning to them later.\n-func TestAnonymous(t *testing.T) {\n-\ttype S struct {\n-\t\tT\n-\t\tN int\n-\t}\n-\n-\tdata, err := Marshal(new(S))\n-\tif err != nil {\n-\t\tt.Fatalf(\"Marshal: %v\", err)\n-\t}\n-\twant := `{\"N\":0}`\n-\tif string(data) != want {\n-\t\tt.Fatalf(\"Marshal = %#q, want %#q\", string(data), want)\n-\t}\n-\n-\tvar s S\n-\tif err := Unmarshal([]byte(`{\"T\": 1, \"T\": {\"Y\": 1}, \"N\": 2}`), &s); err != nil {\n-\t\tt.Fatalf(\"Unmarshal: %v\", err)\n-\t}\n-\tif s.N != 2 {\n-\t\tt.Fatal(\"Unmarshal: did not set N\")\n-\t}\n-\tif s.T.Y != 0 {\n-\t\tt.Fatal(\"Unmarshal: did set T.Y\")\n-\t}\n-}\n-\n // Test that the empty string doesn't panic decoding when ,string is specified\n // Issue 3450\n func TestEmptyString(t *testing.T) {"}, {"sha": "c8535ef79d6f5e832cc77fa8bf47d5ed6aca9689", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 201, "deletions": 54, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -36,7 +36,7 @@ import (\n //\n // Boolean values encode as JSON booleans.\n //\n-// Floating point and integer values encode as JSON numbers.\n+// Floating point, integer, and Number values encode as JSON numbers.\n //\n // String values encode as JSON strings, with each invalid UTF-8 sequence\n // replaced by the encoding of the Unicode replacement character U+FFFD.\n@@ -84,6 +84,16 @@ import (\n // only Unicode letters, digits, dollar signs, percent signs, hyphens,\n // underscores and slashes.\n //\n+// Anonymous struct fields are usually marshaled as if their inner exported fields\n+// were fields in the outer struct, subject to the usual Go visibility rules.\n+// An anonymous struct field with a name given in its JSON tag is treated as \n+// having that name instead of as anonymous.\n+//\n+// Handling of anonymous struct fields is new in Go 1.1.\n+// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\n+// an anonymous struct field in both current and earlier versions, give the field\n+// a JSON tag of \"-\".\n+//\n // Map values encode as JSON objects.\n // The map's key type must be string; the object keys are used directly\n // as map keys.\n@@ -312,6 +322,14 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\t\te.Write(b)\n \t\t}\n \tcase reflect.String:\n+\t\tif v.Type() == numberType {\n+\t\t\tnumStr := v.String()\n+\t\t\tif numStr == \"\" {\n+\t\t\t\tnumStr = \"0\" // Number's zero-val\n+\t\t\t}\n+\t\t\te.WriteString(numStr)\n+\t\t\tbreak\n+\t\t}\n \t\tif quoted {\n \t\t\tsb, err := Marshal(v.String())\n \t\t\tif err != nil {\n@@ -325,19 +343,19 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \tcase reflect.Struct:\n \t\te.WriteByte('{')\n \t\tfirst := true\n-\t\tfor _, ef := range encodeFields(v.Type()) {\n-\t\t\tfieldValue := v.Field(ef.i)\n-\t\t\tif ef.omitEmpty && isEmptyValue(fieldValue) {\n+\t\tfor _, f := range cachedTypeFields(v.Type()) {\n+\t\t\tfv := fieldByIndex(v, f.index)\n+\t\t\tif !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif first {\n \t\t\t\tfirst = false\n \t\t\t} else {\n \t\t\t\te.WriteByte(',')\n \t\t\t}\n-\t\t\te.string(ef.tag)\n+\t\t\te.string(f.name)\n \t\t\te.WriteByte(':')\n-\t\t\te.reflectValueQuoted(fieldValue, ef.quoted)\n+\t\t\te.reflectValueQuoted(fv, f.quoted)\n \t\t}\n \t\te.WriteByte('}')\n \n@@ -432,6 +450,19 @@ func isValidTag(s string) bool {\n \treturn true\n }\n \n+func fieldByIndex(v reflect.Value, index []int) reflect.Value {\n+\tfor _, i := range index {\n+\t\tif v.Kind() == reflect.Ptr {\n+\t\t\tif v.IsNil() {\n+\t\t\t\treturn reflect.Value{}\n+\t\t\t}\n+\t\t\tv = v.Elem()\n+\t\t}\n+\t\tv = v.Field(i)\n+\t}\n+\treturn v\n+}\n+\n // stringValues is a slice of reflect.Value holding *reflect.StringValue.\n // It implements the methods to sort by string.\n type stringValues []reflect.Value\n@@ -490,67 +521,183 @@ func (e *encodeState) string(s string) (int, error) {\n \treturn e.Len() - len0, nil\n }\n \n-// encodeField contains information about how to encode a field of a\n-// struct.\n-type encodeField struct {\n-\ti         int // field index in struct\n-\ttag       string\n-\tquoted    bool\n+// A field represents a single field found in a struct.\n+type field struct {\n+\tname      string\n+\ttag       bool\n+\tindex     []int\n+\ttyp       reflect.Type\n \tomitEmpty bool\n+\tquoted    bool\n }\n \n-var (\n-\ttypeCacheLock     sync.RWMutex\n-\tencodeFieldsCache = make(map[reflect.Type][]encodeField)\n-)\n+// byName sorts field by name, breaking ties with depth,\n+// then breaking ties with \"name came from json tag\", then\n+// breaking ties with index sequence.\n+type byName []field\n \n-// encodeFields returns a slice of encodeField for a given\n-// struct type.\n-func encodeFields(t reflect.Type) []encodeField {\n-\ttypeCacheLock.RLock()\n-\tfs, ok := encodeFieldsCache[t]\n-\ttypeCacheLock.RUnlock()\n-\tif ok {\n-\t\treturn fs\n-\t}\n+func (x byName) Len() int { return len(x) }\n+\n+func (x byName) Swap(i, j int) { x[i], x[j] = x[j], x[i] }\n \n-\ttypeCacheLock.Lock()\n-\tdefer typeCacheLock.Unlock()\n-\tfs, ok = encodeFieldsCache[t]\n-\tif ok {\n-\t\treturn fs\n+func (x byName) Less(i, j int) bool {\n+\tif x[i].name != x[j].name {\n+\t\treturn x[i].name < x[j].name\n \t}\n+\tif len(x[i].index) != len(x[j].index) {\n+\t\treturn len(x[i].index) < len(x[j].index)\n+\t}\n+\tif x[i].tag != x[j].tag {\n+\t\treturn x[i].tag\n+\t}\n+\treturn byIndex(x).Less(i, j)\n+}\n \n-\tv := reflect.Zero(t)\n-\tn := v.NumField()\n-\tfor i := 0; i < n; i++ {\n-\t\tf := t.Field(i)\n-\t\tif f.PkgPath != \"\" {\n-\t\t\tcontinue\n+// byIndex sorts field by index sequence.\n+type byIndex []field\n+\n+func (x byIndex) Len() int { return len(x) }\n+\n+func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }\n+\n+func (x byIndex) Less(i, j int) bool {\n+\tfor k, xik := range x[i].index {\n+\t\tif k >= len(x[j].index) {\n+\t\t\treturn false\n \t\t}\n-\t\tif f.Anonymous {\n-\t\t\t// We want to do a better job with these later,\n-\t\t\t// so for now pretend they don't exist.\n-\t\t\tcontinue\n+\t\tif xik != x[j].index[k] {\n+\t\t\treturn xik < x[j].index[k]\n \t\t}\n-\t\tvar ef encodeField\n-\t\tef.i = i\n-\t\tef.tag = f.Name\n+\t}\n+\treturn len(x[i].index) < len(x[j].index)\n+}\n+\n+// typeFields returns a list of fields that JSON should recognize for the given type.\n+// The algorithm is breadth-first search over the set of structs to include - the top struct\n+// and then any reachable anonymous structs.\n+func typeFields(t reflect.Type) []field {\n+\t// Anonymous fields to explore at the current level and the next.\n+\tcurrent := []field{}\n+\tnext := []field{{typ: t}}\n+\n+\t// Count of queued names for current level and the next.\n+\tcount := map[reflect.Type]int{}\n+\tnextCount := map[reflect.Type]int{}\n+\n+\t// Types already visited at an earlier level.\n+\tvisited := map[reflect.Type]bool{}\n+\n+\t// Fields found.\n+\tvar fields []field\n+\n+\tfor len(next) > 0 {\n+\t\tcurrent, next = next, current[:0]\n+\t\tcount, nextCount = nextCount, map[reflect.Type]int{}\n \n-\t\ttv := f.Tag.Get(\"json\")\n-\t\tif tv != \"\" {\n-\t\t\tif tv == \"-\" {\n+\t\tfor _, f := range current {\n+\t\t\tif visited[f.typ] {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tname, opts := parseTag(tv)\n-\t\t\tif isValidTag(name) {\n-\t\t\t\tef.tag = name\n+\t\t\tvisited[f.typ] = true\n+\n+\t\t\t// Scan f.typ for fields to include.\n+\t\t\tfor i := 0; i < f.typ.NumField(); i++ {\n+\t\t\t\tsf := f.typ.Field(i)\n+\t\t\t\tif sf.PkgPath != \"\" { // unexported\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\ttag := sf.Tag.Get(\"json\")\n+\t\t\t\tif tag == \"-\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tname, opts := parseTag(tag)\n+\t\t\t\tif !isValidTag(name) {\n+\t\t\t\t\tname = \"\"\n+\t\t\t\t}\n+\t\t\t\tindex := make([]int, len(f.index)+1)\n+\t\t\t\tcopy(index, f.index)\n+\t\t\t\tindex[len(f.index)] = i\n+\t\t\t\t// Record found field and index sequence.\n+\t\t\t\tif name != \"\" || !sf.Anonymous {\n+\t\t\t\t\ttagged := name != \"\"\n+\t\t\t\t\tif name == \"\" {\n+\t\t\t\t\t\tname = sf.Name\n+\t\t\t\t\t}\n+\t\t\t\t\tfields = append(fields, field{name, tagged, index, sf.Type,\n+\t\t\t\t\t\topts.Contains(\"omitempty\"), opts.Contains(\"string\")})\n+\t\t\t\t\tif count[f.typ] > 1 {\n+\t\t\t\t\t\t// If there were multiple instances, add a second,\n+\t\t\t\t\t\t// so that the annihilation code will see a duplicate.\n+\t\t\t\t\t\t// It only cares about the distinction between 1 or 2,\n+\t\t\t\t\t\t// so don't bother generating any more copies.\n+\t\t\t\t\t\tfields = append(fields, fields[len(fields)-1])\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\t// Record new anonymous struct to explore in next round.\n+\t\t\t\tft := sf.Type\n+\t\t\t\tif ft.Name() == \"\" {\n+\t\t\t\t\t// Must be pointer.\n+\t\t\t\t\tft = ft.Elem()\n+\t\t\t\t}\n+\t\t\t\tnextCount[ft]++\n+\t\t\t\tif nextCount[ft] == 1 {\n+\t\t\t\t\tnext = append(next, field{name: ft.Name(), index: index, typ: ft})\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tef.omitEmpty = opts.Contains(\"omitempty\")\n-\t\t\tef.quoted = opts.Contains(\"string\")\n \t\t}\n-\t\tfs = append(fs, ef)\n \t}\n-\tencodeFieldsCache[t] = fs\n-\treturn fs\n+\n+\tsort.Sort(byName(fields))\n+\n+\t// Remove fields with annihilating name collisions\n+\t// and also fields shadowed by fields with explicit JSON tags.\n+\tname := \"\"\n+\tout := fields[:0]\n+\tfor _, f := range fields {\n+\t\tif f.name != name {\n+\t\t\tname = f.name\n+\t\t\tout = append(out, f)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n := len(out); n > 0 && out[n-1].name == name && (!out[n-1].tag || f.tag) {\n+\t\t\tout = out[:n-1]\n+\t\t}\n+\t}\n+\tfields = out\n+\n+\tsort.Sort(byIndex(fields))\n+\n+\treturn fields\n+}\n+\n+var fieldCache struct {\n+\tsync.RWMutex\n+\tm map[reflect.Type][]field\n+}\n+\n+// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.\n+func cachedTypeFields(t reflect.Type) []field {\n+\tfieldCache.RLock()\n+\tf := fieldCache.m[t]\n+\tfieldCache.RUnlock()\n+\tif f != nil {\n+\t\treturn f\n+\t}\n+\n+\t// Compute fields without lock.\n+\t// Might duplicate effort but won't hold other computations back.\n+\tf = typeFields(t)\n+\tif f == nil {\n+\t\tf = []field{}\n+\t}\n+\n+\tfieldCache.Lock()\n+\tif fieldCache.m == nil {\n+\t\tfieldCache.m = map[reflect.Type][]field{}\n+\t}\n+\tfieldCache.m[t] = f\n+\tfieldCache.Unlock()\n+\treturn f\n }"}, {"sha": "9592467d25baaefa853bdc2f1c87751b8fe4564f", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -26,6 +26,10 @@ func NewDecoder(r io.Reader) *Decoder {\n \treturn &Decoder{r: r}\n }\n \n+// UseNumber causes the Decoder to unmarshal a number into an interface{} as a\n+// Number instead of as a float64.\n+func (dec *Decoder) UseNumber() { dec.d.useNumber = true }\n+\n // Decode reads the next JSON-encoded value from its\n // input and stores it in the value pointed to by v.\n //\n@@ -74,7 +78,7 @@ Input:\n \t\t\t// scanEnd is delayed one byte.\n \t\t\t// We might block trying to get that byte from src,\n \t\t\t// so instead invent a space byte.\n-\t\t\tif v == scanEndObject && dec.scan.step(&dec.scan, ' ') == scanEnd {\n+\t\t\tif (v == scanEndObject || v == scanEndArray) && dec.scan.step(&dec.scan, ' ') == scanEnd {\n \t\t\t\tscanp += i + 1\n \t\t\t\tbreak Input\n \t\t\t}"}, {"sha": "4d66f556767215d8abd4e88d6b161d8caf85efac", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -6,6 +6,7 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"net\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -145,3 +146,24 @@ func TestNullRawMessage(t *testing.T) {\n \t\tt.Fatalf(\"Marshal: have %#q want %#q\", b, msg)\n \t}\n }\n+\n+var blockingTests = []string{\n+\t`{\"x\": 1}`,\n+\t`[1, 2, 3]`,\n+}\n+\n+func TestBlocking(t *testing.T) {\n+\tfor _, enc := range blockingTests {\n+\t\tr, w := net.Pipe()\n+\t\tgo w.Write([]byte(enc))\n+\t\tvar val interface{}\n+\n+\t\t// If Decode reads beyond what w.Write writes above,\n+\t\t// it will block, and the test will deadlock.\n+\t\tif err := NewDecoder(r).Decode(&val); err != nil {\n+\t\t\tt.Errorf(\"decoding %s: %v\", enc, err)\n+\t\t}\n+\t\tr.Close()\n+\t\tw.Close()\n+\t}\n+}"}, {"sha": "8592a0c15cb963872ce3b5fabf896111929f2473", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -57,8 +57,8 @@ const (\n //       if the field value is empty. The empty values are false, 0, any\n //       nil pointer or interface value, and any array, slice, map, or\n //       string of length zero.\n-//     - a non-pointer anonymous struct field is handled as if the\n-//       fields of its value were part of the outer struct.\n+//     - an anonymous struct field is handled as if the fields of its\n+//       value were part of the outer struct.\n //\n // If a field uses a tag \"a>b>c\", then the element c will be nested inside\n // parent elements a and b.  Fields that appear next to each other that name\n@@ -83,9 +83,7 @@ func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n \tenc := NewEncoder(&b)\n \tenc.prefix = prefix\n \tenc.indent = indent\n-\terr := enc.marshalValue(reflect.ValueOf(v), nil)\n-\tenc.Flush()\n-\tif err != nil {\n+\tif err := enc.Encode(v); err != nil {\n \t\treturn nil, err\n \t}\n \treturn b.Bytes(), nil\n@@ -107,8 +105,10 @@ func NewEncoder(w io.Writer) *Encoder {\n // of Go values to XML.\n func (enc *Encoder) Encode(v interface{}) error {\n \terr := enc.marshalValue(reflect.ValueOf(v), nil)\n-\tenc.Flush()\n-\treturn err\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn enc.Flush()\n }\n \n type printer struct {\n@@ -164,7 +164,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\txmlname := tinfo.xmlname\n \t\tif xmlname.name != \"\" {\n \t\t\txmlns, name = xmlname.xmlns, xmlname.name\n-\t\t} else if v, ok := val.FieldByIndex(xmlname.idx).Interface().(Name); ok && v.Local != \"\" {\n+\t\t} else if v, ok := xmlname.value(val).Interface().(Name); ok && v.Local != \"\" {\n \t\t\txmlns, name = v.Space, v.Local\n \t\t}\n \t}\n@@ -195,7 +195,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\tif finfo.flags&fAttr == 0 {\n \t\t\tcontinue\n \t\t}\n-\t\tfv := val.FieldByIndex(finfo.idx)\n+\t\tfv := finfo.value(val)\n \t\tif finfo.flags&fOmitEmpty != 0 && isEmptyValue(fv) {\n \t\t\tcontinue\n \t\t}\n@@ -224,7 +224,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tp.WriteString(name)\n \tp.WriteByte('>')\n \n-\treturn nil\n+\treturn p.cachedWriteError()\n }\n \n var timeType = reflect.TypeOf(time.Time{})\n@@ -260,23 +260,23 @@ func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n \tdefault:\n \t\treturn &UnsupportedTypeError{typ}\n \t}\n-\treturn nil\n+\treturn p.cachedWriteError()\n }\n \n var ddBytes = []byte(\"--\")\n \n func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \tif val.Type() == timeType {\n-\t\tp.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n-\t\treturn nil\n+\t\t_, err := p.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n+\t\treturn err\n \t}\n \ts := parentStack{printer: p}\n \tfor i := range tinfo.fields {\n \t\tfinfo := &tinfo.fields[i]\n \t\tif finfo.flags&(fAttr|fAny) != 0 {\n \t\t\tcontinue\n \t\t}\n-\t\tvf := val.FieldByIndex(finfo.idx)\n+\t\tvf := finfo.value(val)\n \t\tswitch finfo.flags & fMode {\n \t\tcase fCharData:\n \t\t\tswitch vf.Kind() {\n@@ -353,7 +353,13 @@ func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n \t\t}\n \t}\n \ts.trim(nil)\n-\treturn nil\n+\treturn p.cachedWriteError()\n+}\n+\n+// return the bufio Writer's cached write error\n+func (p *printer) cachedWriteError() error {\n+\t_, err := p.Write(nil)\n+\treturn err\n }\n \n func (p *printer) writeIndent(depthDelta int) {"}, {"sha": "e729a247af40d5110068f519c10f69c328e1b371", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,6 +5,9 @@\n package xml\n \n import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n@@ -108,7 +111,7 @@ type EmbedA struct {\n \n type EmbedB struct {\n \tFieldB string\n-\tEmbedC\n+\t*EmbedC\n }\n \n type EmbedC struct {\n@@ -493,7 +496,7 @@ var marshalTests = []struct {\n \t\t\t},\n \t\t\tEmbedB: EmbedB{\n \t\t\t\tFieldB: \"A.B.B\",\n-\t\t\t\tEmbedC: EmbedC{\n+\t\t\t\tEmbedC: &EmbedC{\n \t\t\t\t\tFieldA1: \"A.B.C.A1\",\n \t\t\t\t\tFieldA2: \"A.B.C.A2\",\n \t\t\t\t\tFieldB:  \"\", // Shadowed by A.B.B\n@@ -779,6 +782,55 @@ func TestUnmarshal(t *testing.T) {\n \t}\n }\n \n+type limitedBytesWriter struct {\n+\tw      io.Writer\n+\tremain int // until writes fail\n+}\n+\n+func (lw *limitedBytesWriter) Write(p []byte) (n int, err error) {\n+\tif lw.remain <= 0 {\n+\t\tprintln(\"error\")\n+\t\treturn 0, errors.New(\"write limit hit\")\n+\t}\n+\tif len(p) > lw.remain {\n+\t\tp = p[:lw.remain]\n+\t\tn, _ = lw.w.Write(p)\n+\t\tlw.remain = 0\n+\t\treturn n, errors.New(\"write limit hit\")\n+\t}\n+\tn, err = lw.w.Write(p)\n+\tlw.remain -= n\n+\treturn n, err\n+}\n+\n+func TestMarshalWriteErrors(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tconst writeCap = 1024\n+\tw := &limitedBytesWriter{&buf, writeCap}\n+\tenc := NewEncoder(w)\n+\tvar err error\n+\tvar i int\n+\tconst n = 4000\n+\tfor i = 1; i <= n; i++ {\n+\t\terr = enc.Encode(&Passenger{\n+\t\t\tName:   []string{\"Alice\", \"Bob\"},\n+\t\t\tWeight: 5,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif err == nil {\n+\t\tt.Error(\"expected an error\")\n+\t}\n+\tif i == n {\n+\t\tt.Errorf(\"expected to fail before the end\")\n+\t}\n+\tif buf.Len() != writeCap {\n+\t\tt.Errorf(\"buf.Len() = %d; want %d\", buf.Len(), writeCap)\n+\t}\n+}\n+\n func BenchmarkMarshal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tMarshal(atomValue)"}, {"sha": "0e6761d66adac7916ea3b7be8fff331142c1c0f6", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -81,8 +81,8 @@ import (\n //      of the above rules and the struct has a field with tag \",any\",\n //      unmarshal maps the sub-element to that struct field.\n //\n-//   * A non-pointer anonymous struct field is handled as if the\n-//      fields of its value were part of the outer struct.\n+//   * An anonymous struct field is handled as if the fields of its\n+//      value were part of the outer struct.\n //\n //   * A struct field with tag \"-\" is never unmarshalled into.\n //\n@@ -248,7 +248,7 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\t\t}\n \t\t\t\treturn UnmarshalError(e)\n \t\t\t}\n-\t\t\tfv := sv.FieldByIndex(finfo.idx)\n+\t\t\tfv := finfo.value(sv)\n \t\t\tif _, ok := fv.Interface().(Name); ok {\n \t\t\t\tfv.Set(reflect.ValueOf(start.Name))\n \t\t\t}\n@@ -260,7 +260,7 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\tfinfo := &tinfo.fields[i]\n \t\t\tswitch finfo.flags & fMode {\n \t\t\tcase fAttr:\n-\t\t\t\tstrv := sv.FieldByIndex(finfo.idx)\n+\t\t\t\tstrv := finfo.value(sv)\n \t\t\t\t// Look for attribute.\n \t\t\t\tfor _, a := range start.Attr {\n \t\t\t\t\tif a.Name.Local == finfo.name {\n@@ -271,22 +271,22 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \n \t\t\tcase fCharData:\n \t\t\t\tif !saveData.IsValid() {\n-\t\t\t\t\tsaveData = sv.FieldByIndex(finfo.idx)\n+\t\t\t\t\tsaveData = finfo.value(sv)\n \t\t\t\t}\n \n \t\t\tcase fComment:\n \t\t\t\tif !saveComment.IsValid() {\n-\t\t\t\t\tsaveComment = sv.FieldByIndex(finfo.idx)\n+\t\t\t\t\tsaveComment = finfo.value(sv)\n \t\t\t\t}\n \n \t\t\tcase fAny:\n \t\t\t\tif !saveAny.IsValid() {\n-\t\t\t\t\tsaveAny = sv.FieldByIndex(finfo.idx)\n+\t\t\t\t\tsaveAny = finfo.value(sv)\n \t\t\t\t}\n \n \t\t\tcase fInnerXml:\n \t\t\t\tif !saveXML.IsValid() {\n-\t\t\t\t\tsaveXML = sv.FieldByIndex(finfo.idx)\n+\t\t\t\t\tsaveXML = finfo.value(sv)\n \t\t\t\t\tif p.saved == nil {\n \t\t\t\t\t\tsaveXMLIndex = 0\n \t\t\t\t\t\tp.saved = new(bytes.Buffer)\n@@ -461,7 +461,7 @@ Loop:\n \t\t}\n \t\tif len(finfo.parents) == len(parents) && finfo.name == start.Name.Local {\n \t\t\t// It's a perfect match, unmarshal the field.\n-\t\t\treturn true, p.unmarshal(sv.FieldByIndex(finfo.idx), start)\n+\t\t\treturn true, p.unmarshal(finfo.value(sv), start)\n \t\t}\n \t\tif len(finfo.parents) > len(parents) && finfo.parents[len(parents)] == start.Name.Local {\n \t\t\t// It's a prefix for the field. Break and recurse"}, {"sha": "970d1701932d4a1eea02cf35ddefb914eb413a7c", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -66,10 +66,14 @@ func getTypeInfo(typ reflect.Type) (*typeInfo, error) {\n \n \t\t\t// For embedded structs, embed its fields.\n \t\t\tif f.Anonymous {\n-\t\t\t\tif f.Type.Kind() != reflect.Struct {\n+\t\t\t\tt := f.Type\n+\t\t\t\tif t.Kind() == reflect.Ptr {\n+\t\t\t\t\tt = t.Elem()\n+\t\t\t\t}\n+\t\t\t\tif t.Kind() != reflect.Struct {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tinner, err := getTypeInfo(f.Type)\n+\t\t\t\tinner, err := getTypeInfo(t)\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n@@ -327,3 +331,22 @@ type TagPathError struct {\n func (e *TagPathError) Error() string {\n \treturn fmt.Sprintf(\"%s field %q with tag %q conflicts with field %q with tag %q\", e.Struct, e.Field1, e.Tag1, e.Field2, e.Tag2)\n }\n+\n+// value returns v's field value corresponding to finfo.\n+// It's equivalent to v.FieldByIndex(finfo.idx), but initializes\n+// and dereferences pointers as necessary.\n+func (finfo *fieldInfo) value(v reflect.Value) reflect.Value {\n+\tfor i, x := range finfo.idx {\n+\t\tif i > 0 {\n+\t\t\tt := v.Type()\n+\t\t\tif t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Struct {\n+\t\t\t\tif v.IsNil() {\n+\t\t\t\t\tv.Set(reflect.New(v.Type().Elem()))\n+\t\t\t\t}\n+\t\t\t\tv = v.Elem()\n+\t\t\t}\n+\t\t}\n+\t\tv = v.Field(x)\n+\t}\n+\treturn v\n+}"}, {"sha": "fbd2208e33415da948121fbce0ef842e990562af", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -584,6 +584,7 @@ func (d *Decoder) RawToken() (Token, error) {\n \t\t\tif inquote == 0 && b == '>' && depth == 0 {\n \t\t\t\tbreak\n \t\t\t}\n+\t\tHandleB:\n \t\t\td.buf.WriteByte(b)\n \t\t\tswitch {\n \t\t\tcase b == inquote:\n@@ -599,7 +600,35 @@ func (d *Decoder) RawToken() (Token, error) {\n \t\t\t\tdepth--\n \n \t\t\tcase b == '<' && inquote == 0:\n-\t\t\t\tdepth++\n+\t\t\t\t// Look for <!-- to begin comment.\n+\t\t\t\ts := \"!--\"\n+\t\t\t\tfor i := 0; i < len(s); i++ {\n+\t\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\t\treturn nil, d.err\n+\t\t\t\t\t}\n+\t\t\t\t\tif b != s[i] {\n+\t\t\t\t\t\tfor j := 0; j < i; j++ {\n+\t\t\t\t\t\t\td.buf.WriteByte(s[j])\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tdepth++\n+\t\t\t\t\t\tgoto HandleB\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Remove < that was written above.\n+\t\t\t\td.buf.Truncate(d.buf.Len() - 1)\n+\n+\t\t\t\t// Look for terminator.\n+\t\t\t\tvar b0, b1 byte\n+\t\t\t\tfor {\n+\t\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\t\treturn nil, d.err\n+\t\t\t\t\t}\n+\t\t\t\t\tif b0 == '-' && b1 == '-' && b == '>' {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tb0, b1 = b1, b\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn Directive(d.buf.Bytes()), nil\n@@ -850,6 +879,8 @@ Input:\n \t\t\t// Parsers are required to recognize lt, gt, amp, apos, and quot\n \t\t\t// even if they have not been declared.  That's all we allow.\n \t\t\tvar i int\n+\t\t\tvar semicolon bool\n+\t\t\tvar valid bool\n \t\t\tfor i = 0; i < len(d.tmp); i++ {\n \t\t\t\tvar ok bool\n \t\t\t\td.tmp[i], ok = d.getc()\n@@ -861,6 +892,8 @@ Input:\n \t\t\t\t}\n \t\t\t\tc := d.tmp[i]\n \t\t\t\tif c == ';' {\n+\t\t\t\t\tsemicolon = true\n+\t\t\t\t\tvalid = i > 0\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tif 'a' <= c && c <= 'z' ||\n@@ -873,14 +906,25 @@ Input:\n \t\t\t\tbreak\n \t\t\t}\n \t\t\ts := string(d.tmp[0:i])\n-\t\t\tif i >= len(d.tmp) {\n+\t\t\tif !valid {\n \t\t\t\tif !d.Strict {\n \t\t\t\t\tb0, b1 = 0, 0\n \t\t\t\t\td.buf.WriteByte('&')\n \t\t\t\t\td.buf.Write(d.tmp[0:i])\n+\t\t\t\t\tif semicolon {\n+\t\t\t\t\t\td.buf.WriteByte(';')\n+\t\t\t\t\t}\n \t\t\t\t\tcontinue Input\n \t\t\t\t}\n-\t\t\t\td.err = d.syntaxError(\"character entity expression &\" + s + \"... too long\")\n+\t\t\t\tsemi := \";\"\n+\t\t\t\tif !semicolon {\n+\t\t\t\t\tsemi = \" (no semicolon)\"\n+\t\t\t\t}\n+\t\t\t\tif i < len(d.tmp) {\n+\t\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + semi)\n+\t\t\t\t} else {\n+\t\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + \"... too long\")\n+\t\t\t\t}\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tvar haveText bool\n@@ -910,6 +954,7 @@ Input:\n \t\t\t\t\tb0, b1 = 0, 0\n \t\t\t\t\td.buf.WriteByte('&')\n \t\t\t\t\td.buf.Write(d.tmp[0:i])\n+\t\t\t\t\td.buf.WriteByte(';')\n \t\t\t\t\tcontinue Input\n \t\t\t\t}\n \t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + \";\")"}, {"sha": "2ad4d4af5df595fee839ca85d0517422a72b3db4", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,6 +5,7 @@\n package xml\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"reflect\"\n \t\"strings\"\n@@ -158,6 +159,39 @@ func TestRawToken(t *testing.T) {\n \ttestRawToken(t, d, rawTokens)\n }\n \n+const nonStrictInput = `\n+<tag>non&entity</tag>\n+<tag>&unknown;entity</tag>\n+<tag>&#123</tag>\n+<tag>&#zzz;</tag>\n+`\n+\n+var nonStrictTokens = []Token{\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"non&entity\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&unknown;entity\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&#123\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&#zzz;\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+}\n+\n+func TestNonStrictRawToken(t *testing.T) {\n+\td := NewDecoder(strings.NewReader(nonStrictInput))\n+\td.Strict = false\n+\ttestRawToken(t, d, nonStrictTokens)\n+}\n+\n type downCaser struct {\n \tt *testing.T\n \tr io.ByteReader\n@@ -219,7 +253,18 @@ func testRawToken(t *testing.T, d *Decoder, rawTokens []Token) {\n \t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n \t\t}\n \t\tif !reflect.DeepEqual(have, want) {\n-\t\t\tt.Errorf(\"token %d = %#v want %#v\", i, have, want)\n+\t\t\tvar shave, swant string\n+\t\t\tif _, ok := have.(CharData); ok {\n+\t\t\t\tshave = fmt.Sprintf(\"CharData(%q)\", have)\n+\t\t\t} else {\n+\t\t\t\tshave = fmt.Sprintf(\"%#v\", have)\n+\t\t\t}\n+\t\t\tif _, ok := want.(CharData); ok {\n+\t\t\t\tswant = fmt.Sprintf(\"CharData(%q)\", want)\n+\t\t\t} else {\n+\t\t\t\tswant = fmt.Sprintf(\"%#v\", want)\n+\t\t\t}\n+\t\t\tt.Errorf(\"token %d = %s, want %s\", i, shave, swant)\n \t\t}\n \t}\n }\n@@ -531,8 +576,8 @@ var characterTests = []struct {\n \t{\"\\xef\\xbf\\xbe<doc/>\", \"illegal character code U+FFFE\"},\n \t{\"<?xml version=\\\"1.0\\\"?><doc>\\r\\n<hiya/>\\x07<toots/></doc>\", \"illegal character code U+0007\"},\n \t{\"<?xml version=\\\"1.0\\\"?><doc \\x12='value'>what's up</doc>\", \"expected attribute name in element\"},\n-\t{\"<doc>&\\x01;</doc>\", \"invalid character entity &;\"},\n-\t{\"<doc>&\\xef\\xbf\\xbe;</doc>\", \"invalid character entity &;\"},\n+\t{\"<doc>&\\x01;</doc>\", \"invalid character entity & (no semicolon)\"},\n+\t{\"<doc>&\\xef\\xbf\\xbe;</doc>\", \"invalid character entity & (no semicolon)\"},\n }\n \n func TestDisallowedCharacters(t *testing.T) {\n@@ -576,3 +621,36 @@ func TestProcInstEncoding(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Ensure that directives with comments include the complete\n+// text of any nested directives.\n+\n+var directivesWithCommentsInput = `\n+<!DOCTYPE [<!-- a comment --><!ENTITY rdf \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">]>\n+<!DOCTYPE [<!ENTITY go \"Golang\"><!-- a comment-->]>\n+<!DOCTYPE <!-> <!> <!----> <!-->--> <!--->--> [<!ENTITY go \"Golang\"><!-- a comment-->]>\n+`\n+\n+var directivesWithCommentsTokens = []Token{\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY rdf \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY go \"Golang\">]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE <!-> <!>    [<!ENTITY go \"Golang\">]`),\n+\tCharData(\"\\n\"),\n+}\n+\n+func TestDirectivesWithComments(t *testing.T) {\n+\td := NewDecoder(strings.NewReader(directivesWithCommentsInput))\n+\n+\tfor i, want := range directivesWithCommentsTokens {\n+\t\thave, err := d.Token()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(have, want) {\n+\t\t\tt.Errorf(\"token %d = %#v want %#v\", i, have, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "2dbd0fbf7f51cec0932da617b3dd9eac241dfb02", "filename": "libgo/go/exp/html/atom/atom.go", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package atom provides integer codes (also known as atoms) for a fixed set of\n+// frequently occurring HTML strings: tag names and attribute keys such as \"p\"\n+// and \"id\".\n+//\n+// Sharing an atom's name between all elements with the same tag can result in\n+// fewer string allocations when tokenizing and parsing HTML. Integer\n+// comparisons are also generally faster than string comparisons.\n+//\n+// The value of an atom's particular code is not guaranteed to stay the same\n+// between versions of this package. Neither is any ordering guaranteed:\n+// whether atom.H1 < atom.H2 may also change. The codes are not guaranteed to\n+// be dense. The only guarantees are that e.g. looking up \"div\" will yield\n+// atom.Div, calling atom.Div.String will return \"div\", and atom.Div != 0.\n+//\n+// TODO(rsc): When this package moves out of exp we need to freeze atom values\n+// across releases.\n+package atom\n+\n+// Atom is an integer code for a string. The zero value maps to \"\".\n+type Atom uint32\n+\n+// String returns the atom's name.\n+func (a Atom) String() string {\n+\tstart := uint32(a >> 8)\n+\tn := uint32(a & 0xff)\n+\tif start+n > uint32(len(atomText)) {\n+\t\treturn \"\"\n+\t}\n+\treturn atomText[start : start+n]\n+}\n+\n+func (a Atom) string() string {\n+\treturn atomText[a>>8 : a>>8+a&0xff]\n+}\n+\n+// fnv computes the FNV hash with an arbitrary starting value h.\n+func fnv(h uint32, s []byte) uint32 {\n+\tfor i := range s {\n+\t\th ^= uint32(s[i])\n+\t\th *= 16777619\n+\t}\n+\treturn h\n+}\n+\n+func match(s string, t []byte) bool {\n+\tfor i, c := range t {\n+\t\tif s[i] != c {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// Lookup returns the atom whose name is s. It returns zero if there is no\n+// such atom. The lookup is case sensitive.\n+func Lookup(s []byte) Atom {\n+\tif len(s) == 0 || len(s) > maxAtomLen {\n+\t\treturn 0\n+\t}\n+\th := fnv(hash0, s)\n+\tif a := table[h&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {\n+\t\treturn a\n+\t}\n+\tif a := table[(h>>16)&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {\n+\t\treturn a\n+\t}\n+\treturn 0\n+}\n+\n+// String returns a string whose contents are equal to s. In that sense, it is\n+// equivalent to string(s) but may be more efficient.\n+func String(s []byte) string {\n+\tif a := Lookup(s); a != 0 {\n+\t\treturn a.String()\n+\t}\n+\treturn string(s)\n+}"}, {"sha": "6e33704dd5e114c1610e8239f6162a828db39132", "filename": "libgo/go/exp/html/atom/atom_test.go", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fatom_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package atom\n+\n+import (\n+\t\"sort\"\n+\t\"testing\"\n+)\n+\n+func TestKnown(t *testing.T) {\n+\tfor _, s := range testAtomList {\n+\t\tif atom := Lookup([]byte(s)); atom.String() != s {\n+\t\t\tt.Errorf(\"Lookup(%q) = %#x (%q)\", s, uint32(atom), atom.String())\n+\t\t}\n+\t}\n+}\n+\n+func TestHits(t *testing.T) {\n+\tfor _, a := range table {\n+\t\tif a == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tgot := Lookup([]byte(a.String()))\n+\t\tif got != a {\n+\t\t\tt.Errorf(\"Lookup(%q) = %#x, want %#x\", a.String(), uint32(got), uint32(a))\n+\t\t}\n+\t}\n+}\n+\n+func TestMisses(t *testing.T) {\n+\ttestCases := []string{\n+\t\t\"\",\n+\t\t\"\\x00\",\n+\t\t\"\\xff\",\n+\t\t\"A\",\n+\t\t\"DIV\",\n+\t\t\"Div\",\n+\t\t\"dIV\",\n+\t\t\"aa\",\n+\t\t\"a\\x00\",\n+\t\t\"ab\",\n+\t\t\"abb\",\n+\t\t\"abbr0\",\n+\t\t\"abbr \",\n+\t\t\" abbr\",\n+\t\t\" a\",\n+\t\t\"acceptcharset\",\n+\t\t\"acceptCharset\",\n+\t\t\"accept_charset\",\n+\t\t\"h0\",\n+\t\t\"h1h2\",\n+\t\t\"h7\",\n+\t\t\"onClick\",\n+\t\t\"\u03bb\",\n+\t\t// The following string has the same hash (0xa1d7fab7) as \"onmouseover\".\n+\t\t\"\\x00\\x00\\x00\\x00\\x00\\x50\\x18\\xae\\x38\\xd0\\xb7\",\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tgot := Lookup([]byte(tc))\n+\t\tif got != 0 {\n+\t\t\tt.Errorf(\"Lookup(%q): got %d, want 0\", tc, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestForeignObject(t *testing.T) {\n+\tconst (\n+\t\tafo = Foreignobject\n+\t\tafO = ForeignObject\n+\t\tsfo = \"foreignobject\"\n+\t\tsfO = \"foreignObject\"\n+\t)\n+\tif got := Lookup([]byte(sfo)); got != afo {\n+\t\tt.Errorf(\"Lookup(%q): got %#v, want %#v\", sfo, got, afo)\n+\t}\n+\tif got := Lookup([]byte(sfO)); got != afO {\n+\t\tt.Errorf(\"Lookup(%q): got %#v, want %#v\", sfO, got, afO)\n+\t}\n+\tif got := afo.String(); got != sfo {\n+\t\tt.Errorf(\"Atom(%#v).String(): got %q, want %q\", afo, got, sfo)\n+\t}\n+\tif got := afO.String(); got != sfO {\n+\t\tt.Errorf(\"Atom(%#v).String(): got %q, want %q\", afO, got, sfO)\n+\t}\n+}\n+\n+func BenchmarkLookup(b *testing.B) {\n+\tsortedTable := make([]string, 0, len(table))\n+\tfor _, a := range table {\n+\t\tif a != 0 {\n+\t\t\tsortedTable = append(sortedTable, a.String())\n+\t\t}\n+\t}\n+\tsort.Strings(sortedTable)\n+\n+\tx := make([][]byte, 1000)\n+\tfor i := range x {\n+\t\tx[i] = []byte(sortedTable[i%len(sortedTable)])\n+\t}\n+\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor _, s := range x {\n+\t\t\tLookup(s)\n+\t\t}\n+\t}\n+}"}, {"sha": "9958a71884266f49b663dad4645189d17ca49654", "filename": "libgo/go/exp/html/atom/gen.go", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Fgen.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,636 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package main\n+\n+// This program generates table.go and table_test.go.\n+// Invoke as\n+//\n+//\tgo run gen.go |gofmt >table.go\n+//\tgo run gen.go -test |gofmt >table_test.go\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+// identifier converts s to a Go exported identifier.\n+// It converts \"div\" to \"Div\" and \"accept-charset\" to \"AcceptCharset\".\n+func identifier(s string) string {\n+\tb := make([]byte, 0, len(s))\n+\tcap := true\n+\tfor _, c := range s {\n+\t\tif c == '-' {\n+\t\t\tcap = true\n+\t\t\tcontinue\n+\t\t}\n+\t\tif cap && 'a' <= c && c <= 'z' {\n+\t\t\tc -= 'a' - 'A'\n+\t\t}\n+\t\tcap = false\n+\t\tb = append(b, byte(c))\n+\t}\n+\treturn string(b)\n+}\n+\n+var test = flag.Bool(\"test\", false, \"generate table_test.go\")\n+\n+func main() {\n+\tflag.Parse()\n+\n+\tvar all []string\n+\tall = append(all, elements...)\n+\tall = append(all, attributes...)\n+\tall = append(all, eventHandlers...)\n+\tall = append(all, extra...)\n+\tsort.Strings(all)\n+\n+\tif *test {\n+\t\tfmt.Printf(\"// generated by go run gen.go -test; DO NOT EDIT\\n\\n\")\n+\t\tfmt.Printf(\"package atom\\n\\n\")\n+\t\tfmt.Printf(\"var testAtomList = []string{\\n\")\n+\t\tfor _, s := range all {\n+\t\t\tfmt.Printf(\"\\t%q,\\n\", s)\n+\t\t}\n+\t\tfmt.Printf(\"}\\n\")\n+\t\treturn\n+\t}\n+\n+\t// uniq - lists have dups\n+\t// compute max len too\n+\tmaxLen := 0\n+\tw := 0\n+\tfor _, s := range all {\n+\t\tif w == 0 || all[w-1] != s {\n+\t\t\tif maxLen < len(s) {\n+\t\t\t\tmaxLen = len(s)\n+\t\t\t}\n+\t\t\tall[w] = s\n+\t\t\tw++\n+\t\t}\n+\t}\n+\tall = all[:w]\n+\n+\t// Find hash that minimizes table size.\n+\tvar best *table\n+\tfor i := 0; i < 1000000; i++ {\n+\t\tif best != nil && 1<<(best.k-1) < len(all) {\n+\t\t\tbreak\n+\t\t}\n+\t\th := rand.Uint32()\n+\t\tfor k := uint(0); k <= 16; k++ {\n+\t\t\tif best != nil && k >= best.k {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tvar t table\n+\t\t\tif t.init(h, k, all) {\n+\t\t\t\tbest = &t\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif best == nil {\n+\t\tfmt.Fprintf(os.Stderr, \"failed to construct string table\\n\")\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Lay out strings, using overlaps when possible.\n+\tlayout := append([]string{}, all...)\n+\n+\t// Remove strings that are substrings of other strings\n+\tfor changed := true; changed; {\n+\t\tchanged = false\n+\t\tfor i, s := range layout {\n+\t\t\tif s == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor j, t := range layout {\n+\t\t\t\tif i != j && t != \"\" && strings.Contains(s, t) {\n+\t\t\t\t\tchanged = true\n+\t\t\t\t\tlayout[j] = \"\"\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Join strings where one suffix matches another prefix.\n+\tfor {\n+\t\t// Find best i, j, k such that layout[i][len-k:] == layout[j][:k],\n+\t\t// maximizing overlap length k.\n+\t\tbesti := -1\n+\t\tbestj := -1\n+\t\tbestk := 0\n+\t\tfor i, s := range layout {\n+\t\t\tif s == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor j, t := range layout {\n+\t\t\t\tif i == j {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tfor k := bestk + 1; k <= len(s) && k <= len(t); k++ {\n+\t\t\t\t\tif s[len(s)-k:] == t[:k] {\n+\t\t\t\t\t\tbesti = i\n+\t\t\t\t\t\tbestj = j\n+\t\t\t\t\t\tbestk = k\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif bestk > 0 {\n+\t\t\tlayout[besti] += layout[bestj][bestk:]\n+\t\t\tlayout[bestj] = \"\"\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\n+\ttext := strings.Join(layout, \"\")\n+\n+\tatom := map[string]uint32{}\n+\tfor _, s := range all {\n+\t\toff := strings.Index(text, s)\n+\t\tif off < 0 {\n+\t\t\tpanic(\"lost string \" + s)\n+\t\t}\n+\t\tatom[s] = uint32(off<<8 | len(s))\n+\t}\n+\n+\t// Generate the Go code.\n+\tfmt.Printf(\"// generated by go run gen.go; DO NOT EDIT\\n\\n\")\n+\tfmt.Printf(\"package atom\\n\\nconst (\\n\")\n+\tfor _, s := range all {\n+\t\tfmt.Printf(\"\\t%s Atom = %#x\\n\", identifier(s), atom[s])\n+\t}\n+\tfmt.Printf(\")\\n\\n\")\n+\n+\tfmt.Printf(\"const hash0 = %#x\\n\\n\", best.h0)\n+\tfmt.Printf(\"const maxAtomLen = %d\\n\\n\", maxLen)\n+\n+\tfmt.Printf(\"var table = [1<<%d]Atom{\\n\", best.k)\n+\tfor i, s := range best.tab {\n+\t\tif s == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfmt.Printf(\"\\t%#x: %#x, // %s\\n\", i, atom[s], s)\n+\t}\n+\tfmt.Printf(\"}\\n\")\n+\tdatasize := (1 << best.k) * 4\n+\n+\tfmt.Printf(\"const atomText =\\n\")\n+\ttextsize := len(text)\n+\tfor len(text) > 60 {\n+\t\tfmt.Printf(\"\\t%q +\\n\", text[:60])\n+\t\ttext = text[60:]\n+\t}\n+\tfmt.Printf(\"\\t%q\\n\\n\", text)\n+\n+\tfmt.Fprintf(os.Stderr, \"%d atoms; %d string bytes + %d tables = %d total data\\n\", len(all), textsize, datasize, textsize+datasize)\n+}\n+\n+type byLen []string\n+\n+func (x byLen) Less(i, j int) bool { return len(x[i]) > len(x[j]) }\n+func (x byLen) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n+func (x byLen) Len() int           { return len(x) }\n+\n+// fnv computes the FNV hash with an arbitrary starting value h.\n+func fnv(h uint32, s string) uint32 {\n+\tfor i := 0; i < len(s); i++ {\n+\t\th ^= uint32(s[i])\n+\t\th *= 16777619\n+\t}\n+\treturn h\n+}\n+\n+// A table represents an attempt at constructing the lookup table.\n+// The lookup table uses cuckoo hashing, meaning that each string\n+// can be found in one of two positions.\n+type table struct {\n+\th0   uint32\n+\tk    uint\n+\tmask uint32\n+\ttab  []string\n+}\n+\n+// hash returns the two hashes for s.\n+func (t *table) hash(s string) (h1, h2 uint32) {\n+\th := fnv(t.h0, s)\n+\th1 = h & t.mask\n+\th2 = (h >> 16) & t.mask\n+\treturn\n+}\n+\n+// init initializes the table with the given parameters.\n+// h0 is the initial hash value,\n+// k is the number of bits of hash value to use, and\n+// x is the list of strings to store in the table.\n+// init returns false if the table cannot be constructed.\n+func (t *table) init(h0 uint32, k uint, x []string) bool {\n+\tt.h0 = h0\n+\tt.k = k\n+\tt.tab = make([]string, 1<<k)\n+\tt.mask = 1<<k - 1\n+\tfor _, s := range x {\n+\t\tif !t.insert(s) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// insert inserts s in the table.\n+func (t *table) insert(s string) bool {\n+\th1, h2 := t.hash(s)\n+\tif t.tab[h1] == \"\" {\n+\t\tt.tab[h1] = s\n+\t\treturn true\n+\t}\n+\tif t.tab[h2] == \"\" {\n+\t\tt.tab[h2] = s\n+\t\treturn true\n+\t}\n+\tif t.push(h1, 0) {\n+\t\tt.tab[h1] = s\n+\t\treturn true\n+\t}\n+\tif t.push(h2, 0) {\n+\t\tt.tab[h2] = s\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// push attempts to push aside the entry in slot i.\n+func (t *table) push(i uint32, depth int) bool {\n+\tif depth > len(t.tab) {\n+\t\treturn false\n+\t}\n+\ts := t.tab[i]\n+\th1, h2 := t.hash(s)\n+\tj := h1 + h2 - i\n+\tif t.tab[j] != \"\" && !t.push(j, depth+1) {\n+\t\treturn false\n+\t}\n+\tt.tab[j] = s\n+\treturn true\n+}\n+\n+// The lists of element names and attribute keys were taken from\n+// http://www.whatwg.org/specs/web-apps/current-work/multipage/section-index.html\n+// as of the \"HTML Living Standard - Last Updated 30 May 2012\" version.\n+\n+var elements = []string{\n+\t\"a\",\n+\t\"abbr\",\n+\t\"address\",\n+\t\"area\",\n+\t\"article\",\n+\t\"aside\",\n+\t\"audio\",\n+\t\"b\",\n+\t\"base\",\n+\t\"bdi\",\n+\t\"bdo\",\n+\t\"blockquote\",\n+\t\"body\",\n+\t\"br\",\n+\t\"button\",\n+\t\"canvas\",\n+\t\"caption\",\n+\t\"cite\",\n+\t\"code\",\n+\t\"col\",\n+\t\"colgroup\",\n+\t\"command\",\n+\t\"data\",\n+\t\"datalist\",\n+\t\"dd\",\n+\t\"del\",\n+\t\"details\",\n+\t\"dfn\",\n+\t\"dialog\",\n+\t\"div\",\n+\t\"dl\",\n+\t\"dt\",\n+\t\"em\",\n+\t\"embed\",\n+\t\"fieldset\",\n+\t\"figcaption\",\n+\t\"figure\",\n+\t\"footer\",\n+\t\"form\",\n+\t\"h1\",\n+\t\"h2\",\n+\t\"h3\",\n+\t\"h4\",\n+\t\"h5\",\n+\t\"h6\",\n+\t\"head\",\n+\t\"header\",\n+\t\"hgroup\",\n+\t\"hr\",\n+\t\"html\",\n+\t\"i\",\n+\t\"iframe\",\n+\t\"img\",\n+\t\"input\",\n+\t\"ins\",\n+\t\"kbd\",\n+\t\"keygen\",\n+\t\"label\",\n+\t\"legend\",\n+\t\"li\",\n+\t\"link\",\n+\t\"map\",\n+\t\"mark\",\n+\t\"menu\",\n+\t\"meta\",\n+\t\"meter\",\n+\t\"nav\",\n+\t\"noscript\",\n+\t\"object\",\n+\t\"ol\",\n+\t\"optgroup\",\n+\t\"option\",\n+\t\"output\",\n+\t\"p\",\n+\t\"param\",\n+\t\"pre\",\n+\t\"progress\",\n+\t\"q\",\n+\t\"rp\",\n+\t\"rt\",\n+\t\"ruby\",\n+\t\"s\",\n+\t\"samp\",\n+\t\"script\",\n+\t\"section\",\n+\t\"select\",\n+\t\"small\",\n+\t\"source\",\n+\t\"span\",\n+\t\"strong\",\n+\t\"style\",\n+\t\"sub\",\n+\t\"summary\",\n+\t\"sup\",\n+\t\"table\",\n+\t\"tbody\",\n+\t\"td\",\n+\t\"textarea\",\n+\t\"tfoot\",\n+\t\"th\",\n+\t\"thead\",\n+\t\"time\",\n+\t\"title\",\n+\t\"tr\",\n+\t\"track\",\n+\t\"u\",\n+\t\"ul\",\n+\t\"var\",\n+\t\"video\",\n+\t\"wbr\",\n+}\n+\n+var attributes = []string{\n+\t\"accept\",\n+\t\"accept-charset\",\n+\t\"accesskey\",\n+\t\"action\",\n+\t\"alt\",\n+\t\"async\",\n+\t\"autocomplete\",\n+\t\"autofocus\",\n+\t\"autoplay\",\n+\t\"border\",\n+\t\"challenge\",\n+\t\"charset\",\n+\t\"checked\",\n+\t\"cite\",\n+\t\"class\",\n+\t\"cols\",\n+\t\"colspan\",\n+\t\"command\",\n+\t\"content\",\n+\t\"contenteditable\",\n+\t\"contextmenu\",\n+\t\"controls\",\n+\t\"coords\",\n+\t\"crossorigin\",\n+\t\"data\",\n+\t\"datetime\",\n+\t\"default\",\n+\t\"defer\",\n+\t\"dir\",\n+\t\"dirname\",\n+\t\"disabled\",\n+\t\"download\",\n+\t\"draggable\",\n+\t\"dropzone\",\n+\t\"enctype\",\n+\t\"for\",\n+\t\"form\",\n+\t\"formaction\",\n+\t\"formenctype\",\n+\t\"formmethod\",\n+\t\"formnovalidate\",\n+\t\"formtarget\",\n+\t\"headers\",\n+\t\"height\",\n+\t\"hidden\",\n+\t\"high\",\n+\t\"href\",\n+\t\"hreflang\",\n+\t\"http-equiv\",\n+\t\"icon\",\n+\t\"id\",\n+\t\"inert\",\n+\t\"ismap\",\n+\t\"itemid\",\n+\t\"itemprop\",\n+\t\"itemref\",\n+\t\"itemscope\",\n+\t\"itemtype\",\n+\t\"keytype\",\n+\t\"kind\",\n+\t\"label\",\n+\t\"lang\",\n+\t\"list\",\n+\t\"loop\",\n+\t\"low\",\n+\t\"manifest\",\n+\t\"max\",\n+\t\"maxlength\",\n+\t\"media\",\n+\t\"mediagroup\",\n+\t\"method\",\n+\t\"min\",\n+\t\"multiple\",\n+\t\"muted\",\n+\t\"name\",\n+\t\"novalidate\",\n+\t\"open\",\n+\t\"optimum\",\n+\t\"pattern\",\n+\t\"ping\",\n+\t\"placeholder\",\n+\t\"poster\",\n+\t\"preload\",\n+\t\"radiogroup\",\n+\t\"readonly\",\n+\t\"rel\",\n+\t\"required\",\n+\t\"reversed\",\n+\t\"rows\",\n+\t\"rowspan\",\n+\t\"sandbox\",\n+\t\"spellcheck\",\n+\t\"scope\",\n+\t\"scoped\",\n+\t\"seamless\",\n+\t\"selected\",\n+\t\"shape\",\n+\t\"size\",\n+\t\"sizes\",\n+\t\"span\",\n+\t\"src\",\n+\t\"srcdoc\",\n+\t\"srclang\",\n+\t\"start\",\n+\t\"step\",\n+\t\"style\",\n+\t\"tabindex\",\n+\t\"target\",\n+\t\"title\",\n+\t\"translate\",\n+\t\"type\",\n+\t\"typemustmatch\",\n+\t\"usemap\",\n+\t\"value\",\n+\t\"width\",\n+\t\"wrap\",\n+}\n+\n+var eventHandlers = []string{\n+\t\"onabort\",\n+\t\"onafterprint\",\n+\t\"onbeforeprint\",\n+\t\"onbeforeunload\",\n+\t\"onblur\",\n+\t\"oncancel\",\n+\t\"oncanplay\",\n+\t\"oncanplaythrough\",\n+\t\"onchange\",\n+\t\"onclick\",\n+\t\"onclose\",\n+\t\"oncontextmenu\",\n+\t\"oncuechange\",\n+\t\"ondblclick\",\n+\t\"ondrag\",\n+\t\"ondragend\",\n+\t\"ondragenter\",\n+\t\"ondragleave\",\n+\t\"ondragover\",\n+\t\"ondragstart\",\n+\t\"ondrop\",\n+\t\"ondurationchange\",\n+\t\"onemptied\",\n+\t\"onended\",\n+\t\"onerror\",\n+\t\"onfocus\",\n+\t\"onhashchange\",\n+\t\"oninput\",\n+\t\"oninvalid\",\n+\t\"onkeydown\",\n+\t\"onkeypress\",\n+\t\"onkeyup\",\n+\t\"onload\",\n+\t\"onloadeddata\",\n+\t\"onloadedmetadata\",\n+\t\"onloadstart\",\n+\t\"onmessage\",\n+\t\"onmousedown\",\n+\t\"onmousemove\",\n+\t\"onmouseout\",\n+\t\"onmouseover\",\n+\t\"onmouseup\",\n+\t\"onmousewheel\",\n+\t\"onoffline\",\n+\t\"ononline\",\n+\t\"onpagehide\",\n+\t\"onpageshow\",\n+\t\"onpause\",\n+\t\"onplay\",\n+\t\"onplaying\",\n+\t\"onpopstate\",\n+\t\"onprogress\",\n+\t\"onratechange\",\n+\t\"onreset\",\n+\t\"onresize\",\n+\t\"onscroll\",\n+\t\"onseeked\",\n+\t\"onseeking\",\n+\t\"onselect\",\n+\t\"onshow\",\n+\t\"onstalled\",\n+\t\"onstorage\",\n+\t\"onsubmit\",\n+\t\"onsuspend\",\n+\t\"ontimeupdate\",\n+\t\"onunload\",\n+\t\"onvolumechange\",\n+\t\"onwaiting\",\n+}\n+\n+// extra are ad-hoc values not covered by any of the lists above.\n+var extra = []string{\n+\t\"align\",\n+\t\"annotation\",\n+\t\"annotation-xml\",\n+\t\"applet\",\n+\t\"basefont\",\n+\t\"bgsound\",\n+\t\"big\",\n+\t\"blink\",\n+\t\"center\",\n+\t\"color\",\n+\t\"desc\",\n+\t\"face\",\n+\t\"font\",\n+\t\"foreignObject\", // HTML is case-insensitive, but SVG-embedded-in-HTML is case-sensitive.\n+\t\"foreignobject\",\n+\t\"frame\",\n+\t\"frameset\",\n+\t\"image\",\n+\t\"isindex\",\n+\t\"listing\",\n+\t\"malignmark\",\n+\t\"marquee\",\n+\t\"math\",\n+\t\"mglyph\",\n+\t\"mi\",\n+\t\"mn\",\n+\t\"mo\",\n+\t\"ms\",\n+\t\"mtext\",\n+\t\"nobr\",\n+\t\"noembed\",\n+\t\"noframes\",\n+\t\"plaintext\",\n+\t\"prompt\",\n+\t\"public\",\n+\t\"spacer\",\n+\t\"strike\",\n+\t\"svg\",\n+\t\"system\",\n+\t\"tt\",\n+\t\"xmp\",\n+}"}, {"sha": "20b8b8a5903df330ad3608e9c0b81774592c3d33", "filename": "libgo/go/exp/html/atom/table.go", "status": "added", "additions": 694, "deletions": 0, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,694 @@\n+// generated by go run gen.go; DO NOT EDIT\n+\n+package atom\n+\n+const (\n+\tA                Atom = 0x1\n+\tAbbr             Atom = 0x4\n+\tAccept           Atom = 0x2106\n+\tAcceptCharset    Atom = 0x210e\n+\tAccesskey        Atom = 0x3309\n+\tAction           Atom = 0x21b06\n+\tAddress          Atom = 0x5d507\n+\tAlign            Atom = 0x1105\n+\tAlt              Atom = 0x4503\n+\tAnnotation       Atom = 0x18d0a\n+\tAnnotationXml    Atom = 0x18d0e\n+\tApplet           Atom = 0x2d106\n+\tArea             Atom = 0x31804\n+\tArticle          Atom = 0x39907\n+\tAside            Atom = 0x4f05\n+\tAsync            Atom = 0x9305\n+\tAudio            Atom = 0xaf05\n+\tAutocomplete     Atom = 0xd50c\n+\tAutofocus        Atom = 0xe109\n+\tAutoplay         Atom = 0x10c08\n+\tB                Atom = 0x101\n+\tBase             Atom = 0x11404\n+\tBasefont         Atom = 0x11408\n+\tBdi              Atom = 0x1a03\n+\tBdo              Atom = 0x12503\n+\tBgsound          Atom = 0x13807\n+\tBig              Atom = 0x14403\n+\tBlink            Atom = 0x14705\n+\tBlockquote       Atom = 0x14c0a\n+\tBody             Atom = 0x2f04\n+\tBorder           Atom = 0x15606\n+\tBr               Atom = 0x202\n+\tButton           Atom = 0x15c06\n+\tCanvas           Atom = 0x4b06\n+\tCaption          Atom = 0x1e007\n+\tCenter           Atom = 0x2df06\n+\tChallenge        Atom = 0x23e09\n+\tCharset          Atom = 0x2807\n+\tChecked          Atom = 0x33f07\n+\tCite             Atom = 0x9704\n+\tClass            Atom = 0x3d905\n+\tCode             Atom = 0x16f04\n+\tCol              Atom = 0x17603\n+\tColgroup         Atom = 0x17608\n+\tColor            Atom = 0x18305\n+\tCols             Atom = 0x18804\n+\tColspan          Atom = 0x18807\n+\tCommand          Atom = 0x19b07\n+\tContent          Atom = 0x42c07\n+\tContenteditable  Atom = 0x42c0f\n+\tContextmenu      Atom = 0x3480b\n+\tControls         Atom = 0x1ae08\n+\tCoords           Atom = 0x1ba06\n+\tCrossorigin      Atom = 0x1c40b\n+\tData             Atom = 0x44304\n+\tDatalist         Atom = 0x44308\n+\tDatetime         Atom = 0x25b08\n+\tDd               Atom = 0x28802\n+\tDefault          Atom = 0x5207\n+\tDefer            Atom = 0x17105\n+\tDel              Atom = 0x4d603\n+\tDesc             Atom = 0x4804\n+\tDetails          Atom = 0x6507\n+\tDfn              Atom = 0x8303\n+\tDialog           Atom = 0x1b06\n+\tDir              Atom = 0x9d03\n+\tDirname          Atom = 0x9d07\n+\tDisabled         Atom = 0x10008\n+\tDiv              Atom = 0x10703\n+\tDl               Atom = 0x13e02\n+\tDownload         Atom = 0x40908\n+\tDraggable        Atom = 0x1a109\n+\tDropzone         Atom = 0x3a208\n+\tDt               Atom = 0x4e402\n+\tEm               Atom = 0x7f02\n+\tEmbed            Atom = 0x7f05\n+\tEnctype          Atom = 0x23007\n+\tFace             Atom = 0x2dd04\n+\tFieldset         Atom = 0x1d508\n+\tFigcaption       Atom = 0x1dd0a\n+\tFigure           Atom = 0x1f106\n+\tFont             Atom = 0x11804\n+\tFooter           Atom = 0x5906\n+\tFor              Atom = 0x1fd03\n+\tForeignObject    Atom = 0x1fd0d\n+\tForeignobject    Atom = 0x20a0d\n+\tForm             Atom = 0x21704\n+\tFormaction       Atom = 0x2170a\n+\tFormenctype      Atom = 0x22c0b\n+\tFormmethod       Atom = 0x2470a\n+\tFormnovalidate   Atom = 0x2510e\n+\tFormtarget       Atom = 0x2660a\n+\tFrame            Atom = 0x8705\n+\tFrameset         Atom = 0x8708\n+\tH1               Atom = 0x13602\n+\tH2               Atom = 0x29602\n+\tH3               Atom = 0x2c502\n+\tH4               Atom = 0x30e02\n+\tH5               Atom = 0x4e602\n+\tH6               Atom = 0x27002\n+\tHead             Atom = 0x2fa04\n+\tHeader           Atom = 0x2fa06\n+\tHeaders          Atom = 0x2fa07\n+\tHeight           Atom = 0x27206\n+\tHgroup           Atom = 0x27a06\n+\tHidden           Atom = 0x28606\n+\tHigh             Atom = 0x29304\n+\tHr               Atom = 0x13102\n+\tHref             Atom = 0x29804\n+\tHreflang         Atom = 0x29808\n+\tHtml             Atom = 0x27604\n+\tHttpEquiv        Atom = 0x2a00a\n+\tI                Atom = 0x601\n+\tIcon             Atom = 0x42b04\n+\tId               Atom = 0x5102\n+\tIframe           Atom = 0x2b406\n+\tImage            Atom = 0x2ba05\n+\tImg              Atom = 0x2bf03\n+\tInert            Atom = 0x4c105\n+\tInput            Atom = 0x3f605\n+\tIns              Atom = 0x1cd03\n+\tIsindex          Atom = 0x2c707\n+\tIsmap            Atom = 0x2ce05\n+\tItemid           Atom = 0x9806\n+\tItemprop         Atom = 0x57e08\n+\tItemref          Atom = 0x2d707\n+\tItemscope        Atom = 0x2e509\n+\tItemtype         Atom = 0x2ef08\n+\tKbd              Atom = 0x1903\n+\tKeygen           Atom = 0x3906\n+\tKeytype          Atom = 0x51207\n+\tKind             Atom = 0xfd04\n+\tLabel            Atom = 0xba05\n+\tLang             Atom = 0x29c04\n+\tLegend           Atom = 0x1a806\n+\tLi               Atom = 0x1202\n+\tLink             Atom = 0x14804\n+\tList             Atom = 0x44704\n+\tListing          Atom = 0x44707\n+\tLoop             Atom = 0xbe04\n+\tLow              Atom = 0x13f03\n+\tMalignmark       Atom = 0x100a\n+\tManifest         Atom = 0x5b608\n+\tMap              Atom = 0x2d003\n+\tMark             Atom = 0x1604\n+\tMarquee          Atom = 0x5f207\n+\tMath             Atom = 0x2f704\n+\tMax              Atom = 0x30603\n+\tMaxlength        Atom = 0x30609\n+\tMedia            Atom = 0xa205\n+\tMediagroup       Atom = 0xa20a\n+\tMenu             Atom = 0x34f04\n+\tMeta             Atom = 0x45604\n+\tMeter            Atom = 0x26105\n+\tMethod           Atom = 0x24b06\n+\tMglyph           Atom = 0x2c006\n+\tMi               Atom = 0x9b02\n+\tMin              Atom = 0x31003\n+\tMn               Atom = 0x25402\n+\tMo               Atom = 0x47a02\n+\tMs               Atom = 0x2e802\n+\tMtext            Atom = 0x31305\n+\tMultiple         Atom = 0x32108\n+\tMuted            Atom = 0x32905\n+\tName             Atom = 0xa004\n+\tNav              Atom = 0x3e03\n+\tNobr             Atom = 0x7404\n+\tNoembed          Atom = 0x7d07\n+\tNoframes         Atom = 0x8508\n+\tNoscript         Atom = 0x28b08\n+\tNovalidate       Atom = 0x2550a\n+\tObject           Atom = 0x21106\n+\tOl               Atom = 0xcd02\n+\tOnabort          Atom = 0x16007\n+\tOnafterprint     Atom = 0x1e50c\n+\tOnbeforeprint    Atom = 0x21f0d\n+\tOnbeforeunload   Atom = 0x5c90e\n+\tOnblur           Atom = 0x3e206\n+\tOncancel         Atom = 0xb308\n+\tOncanplay        Atom = 0x12709\n+\tOncanplaythrough Atom = 0x12710\n+\tOnchange         Atom = 0x3b808\n+\tOnclick          Atom = 0x2ad07\n+\tOnclose          Atom = 0x32e07\n+\tOncontextmenu    Atom = 0x3460d\n+\tOncuechange      Atom = 0x3530b\n+\tOndblclick       Atom = 0x35e0a\n+\tOndrag           Atom = 0x36806\n+\tOndragend        Atom = 0x36809\n+\tOndragenter      Atom = 0x3710b\n+\tOndragleave      Atom = 0x37c0b\n+\tOndragover       Atom = 0x3870a\n+\tOndragstart      Atom = 0x3910b\n+\tOndrop           Atom = 0x3a006\n+\tOndurationchange Atom = 0x3b010\n+\tOnemptied        Atom = 0x3a709\n+\tOnended          Atom = 0x3c007\n+\tOnerror          Atom = 0x3c707\n+\tOnfocus          Atom = 0x3ce07\n+\tOnhashchange     Atom = 0x3e80c\n+\tOninput          Atom = 0x3f407\n+\tOninvalid        Atom = 0x3fb09\n+\tOnkeydown        Atom = 0x40409\n+\tOnkeypress       Atom = 0x4110a\n+\tOnkeyup          Atom = 0x42107\n+\tOnload           Atom = 0x43b06\n+\tOnloadeddata     Atom = 0x43b0c\n+\tOnloadedmetadata Atom = 0x44e10\n+\tOnloadstart      Atom = 0x4640b\n+\tOnmessage        Atom = 0x46f09\n+\tOnmousedown      Atom = 0x4780b\n+\tOnmousemove      Atom = 0x4830b\n+\tOnmouseout       Atom = 0x48e0a\n+\tOnmouseover      Atom = 0x49b0b\n+\tOnmouseup        Atom = 0x4a609\n+\tOnmousewheel     Atom = 0x4af0c\n+\tOnoffline        Atom = 0x4bb09\n+\tOnonline         Atom = 0x4c608\n+\tOnpagehide       Atom = 0x4ce0a\n+\tOnpageshow       Atom = 0x4d90a\n+\tOnpause          Atom = 0x4e807\n+\tOnplay           Atom = 0x4f206\n+\tOnplaying        Atom = 0x4f209\n+\tOnpopstate       Atom = 0x4fb0a\n+\tOnprogress       Atom = 0x5050a\n+\tOnratechange     Atom = 0x5190c\n+\tOnreset          Atom = 0x52507\n+\tOnresize         Atom = 0x52c08\n+\tOnscroll         Atom = 0x53a08\n+\tOnseeked         Atom = 0x54208\n+\tOnseeking        Atom = 0x54a09\n+\tOnselect         Atom = 0x55308\n+\tOnshow           Atom = 0x55d06\n+\tOnstalled        Atom = 0x56609\n+\tOnstorage        Atom = 0x56f09\n+\tOnsubmit         Atom = 0x57808\n+\tOnsuspend        Atom = 0x58809\n+\tOntimeupdate     Atom = 0x1190c\n+\tOnunload         Atom = 0x59108\n+\tOnvolumechange   Atom = 0x5990e\n+\tOnwaiting        Atom = 0x5a709\n+\tOpen             Atom = 0x58404\n+\tOptgroup         Atom = 0xc008\n+\tOptimum          Atom = 0x5b007\n+\tOption           Atom = 0x5c506\n+\tOutput           Atom = 0x49506\n+\tP                Atom = 0xc01\n+\tParam            Atom = 0xc05\n+\tPattern          Atom = 0x6e07\n+\tPing             Atom = 0xab04\n+\tPlaceholder      Atom = 0xc70b\n+\tPlaintext        Atom = 0xf109\n+\tPoster           Atom = 0x17d06\n+\tPre              Atom = 0x27f03\n+\tPreload          Atom = 0x27f07\n+\tProgress         Atom = 0x50708\n+\tPrompt           Atom = 0x5bf06\n+\tPublic           Atom = 0x42706\n+\tQ                Atom = 0x15101\n+\tRadiogroup       Atom = 0x30a\n+\tReadonly         Atom = 0x31908\n+\tRel              Atom = 0x28003\n+\tRequired         Atom = 0x1f508\n+\tReversed         Atom = 0x5e08\n+\tRows             Atom = 0x7704\n+\tRowspan          Atom = 0x7707\n+\tRp               Atom = 0x1eb02\n+\tRt               Atom = 0x16502\n+\tRuby             Atom = 0xd104\n+\tS                Atom = 0x2c01\n+\tSamp             Atom = 0x6b04\n+\tSandbox          Atom = 0xe907\n+\tScope            Atom = 0x2e905\n+\tScoped           Atom = 0x2e906\n+\tScript           Atom = 0x28d06\n+\tSeamless         Atom = 0x33308\n+\tSection          Atom = 0x3dd07\n+\tSelect           Atom = 0x55506\n+\tSelected         Atom = 0x55508\n+\tShape            Atom = 0x1b505\n+\tSize             Atom = 0x53004\n+\tSizes            Atom = 0x53005\n+\tSmall            Atom = 0x1bf05\n+\tSource           Atom = 0x1cf06\n+\tSpacer           Atom = 0x30006\n+\tSpan             Atom = 0x7a04\n+\tSpellcheck       Atom = 0x33a0a\n+\tSrc              Atom = 0x3d403\n+\tSrcdoc           Atom = 0x3d406\n+\tSrclang          Atom = 0x41a07\n+\tStart            Atom = 0x39705\n+\tStep             Atom = 0x5bc04\n+\tStrike           Atom = 0x50e06\n+\tStrong           Atom = 0x53406\n+\tStyle            Atom = 0x5db05\n+\tSub              Atom = 0x57a03\n+\tSummary          Atom = 0x5e007\n+\tSup              Atom = 0x5e703\n+\tSvg              Atom = 0x5ea03\n+\tSystem           Atom = 0x5ed06\n+\tTabindex         Atom = 0x45c08\n+\tTable            Atom = 0x43605\n+\tTarget           Atom = 0x26a06\n+\tTbody            Atom = 0x2e05\n+\tTd               Atom = 0x4702\n+\tTextarea         Atom = 0x31408\n+\tTfoot            Atom = 0x5805\n+\tTh               Atom = 0x13002\n+\tThead            Atom = 0x2f905\n+\tTime             Atom = 0x11b04\n+\tTitle            Atom = 0x8e05\n+\tTr               Atom = 0xf902\n+\tTrack            Atom = 0xf905\n+\tTranslate        Atom = 0x16609\n+\tTt               Atom = 0x7002\n+\tType             Atom = 0x23304\n+\tTypemustmatch    Atom = 0x2330d\n+\tU                Atom = 0xb01\n+\tUl               Atom = 0x5602\n+\tUsemap           Atom = 0x4ec06\n+\tValue            Atom = 0x4005\n+\tVar              Atom = 0x10903\n+\tVideo            Atom = 0x2a905\n+\tWbr              Atom = 0x14103\n+\tWidth            Atom = 0x4e205\n+\tWrap             Atom = 0x56204\n+\tXmp              Atom = 0xef03\n+)\n+\n+const hash0 = 0xc17da63e\n+\n+const maxAtomLen = 16\n+\n+var table = [1 << 9]Atom{\n+\t0x1:   0x4830b, // onmousemove\n+\t0x2:   0x5a709, // onwaiting\n+\t0x4:   0x5bf06, // prompt\n+\t0x7:   0x5b007, // optimum\n+\t0x8:   0x1604,  // mark\n+\t0xa:   0x2d707, // itemref\n+\t0xb:   0x4d90a, // onpageshow\n+\t0xc:   0x55506, // select\n+\t0xd:   0x1a109, // draggable\n+\t0xe:   0x3e03,  // nav\n+\t0xf:   0x19b07, // command\n+\t0x11:  0xb01,   // u\n+\t0x14:  0x2fa07, // headers\n+\t0x15:  0x44308, // datalist\n+\t0x17:  0x6b04,  // samp\n+\t0x1a:  0x40409, // onkeydown\n+\t0x1b:  0x53a08, // onscroll\n+\t0x1c:  0x17603, // col\n+\t0x20:  0x57e08, // itemprop\n+\t0x21:  0x2a00a, // http-equiv\n+\t0x22:  0x5e703, // sup\n+\t0x24:  0x1f508, // required\n+\t0x2b:  0x27f07, // preload\n+\t0x2c:  0x21f0d, // onbeforeprint\n+\t0x2d:  0x3710b, // ondragenter\n+\t0x2e:  0x4e402, // dt\n+\t0x2f:  0x57808, // onsubmit\n+\t0x30:  0x13102, // hr\n+\t0x31:  0x3460d, // oncontextmenu\n+\t0x33:  0x2ba05, // image\n+\t0x34:  0x4e807, // onpause\n+\t0x35:  0x27a06, // hgroup\n+\t0x36:  0xab04,  // ping\n+\t0x37:  0x55308, // onselect\n+\t0x3a:  0x10703, // div\n+\t0x40:  0x9b02,  // mi\n+\t0x41:  0x33308, // seamless\n+\t0x42:  0x2807,  // charset\n+\t0x43:  0x5102,  // id\n+\t0x44:  0x4fb0a, // onpopstate\n+\t0x45:  0x4d603, // del\n+\t0x46:  0x5f207, // marquee\n+\t0x47:  0x3309,  // accesskey\n+\t0x49:  0x5906,  // footer\n+\t0x4a:  0x2d106, // applet\n+\t0x4b:  0x2ce05, // ismap\n+\t0x51:  0x34f04, // menu\n+\t0x52:  0x2f04,  // body\n+\t0x55:  0x8708,  // frameset\n+\t0x56:  0x52507, // onreset\n+\t0x57:  0x14705, // blink\n+\t0x58:  0x8e05,  // title\n+\t0x59:  0x39907, // article\n+\t0x5b:  0x13002, // th\n+\t0x5d:  0x15101, // q\n+\t0x5e:  0x58404, // open\n+\t0x5f:  0x31804, // area\n+\t0x61:  0x43b06, // onload\n+\t0x62:  0x3f605, // input\n+\t0x63:  0x11404, // base\n+\t0x64:  0x18807, // colspan\n+\t0x65:  0x51207, // keytype\n+\t0x66:  0x13e02, // dl\n+\t0x68:  0x1d508, // fieldset\n+\t0x6a:  0x31003, // min\n+\t0x6b:  0x10903, // var\n+\t0x6f:  0x2fa06, // header\n+\t0x70:  0x16502, // rt\n+\t0x71:  0x17608, // colgroup\n+\t0x72:  0x25402, // mn\n+\t0x74:  0x16007, // onabort\n+\t0x75:  0x3906,  // keygen\n+\t0x76:  0x4bb09, // onoffline\n+\t0x77:  0x23e09, // challenge\n+\t0x78:  0x2d003, // map\n+\t0x7a:  0x30e02, // h4\n+\t0x7b:  0x3c707, // onerror\n+\t0x7c:  0x30609, // maxlength\n+\t0x7d:  0x31305, // mtext\n+\t0x7e:  0x5805,  // tfoot\n+\t0x7f:  0x11804, // font\n+\t0x80:  0x100a,  // malignmark\n+\t0x81:  0x45604, // meta\n+\t0x82:  0x9305,  // async\n+\t0x83:  0x2c502, // h3\n+\t0x84:  0x28802, // dd\n+\t0x85:  0x29804, // href\n+\t0x86:  0xa20a,  // mediagroup\n+\t0x87:  0x1ba06, // coords\n+\t0x88:  0x41a07, // srclang\n+\t0x89:  0x35e0a, // ondblclick\n+\t0x8a:  0x4005,  // value\n+\t0x8c:  0xb308,  // oncancel\n+\t0x8e:  0x33a0a, // spellcheck\n+\t0x8f:  0x8705,  // frame\n+\t0x91:  0x14403, // big\n+\t0x94:  0x21b06, // action\n+\t0x95:  0x9d03,  // dir\n+\t0x97:  0x31908, // readonly\n+\t0x99:  0x43605, // table\n+\t0x9a:  0x5e007, // summary\n+\t0x9b:  0x14103, // wbr\n+\t0x9c:  0x30a,   // radiogroup\n+\t0x9d:  0xa004,  // name\n+\t0x9f:  0x5ed06, // system\n+\t0xa1:  0x18305, // color\n+\t0xa2:  0x4b06,  // canvas\n+\t0xa3:  0x27604, // html\n+\t0xa5:  0x54a09, // onseeking\n+\t0xac:  0x1b505, // shape\n+\t0xad:  0x28003, // rel\n+\t0xae:  0x12710, // oncanplaythrough\n+\t0xaf:  0x3870a, // ondragover\n+\t0xb1:  0x1fd0d, // foreignObject\n+\t0xb3:  0x7704,  // rows\n+\t0xb6:  0x44707, // listing\n+\t0xb7:  0x49506, // output\n+\t0xb9:  0x3480b, // contextmenu\n+\t0xbb:  0x13f03, // low\n+\t0xbc:  0x1eb02, // rp\n+\t0xbd:  0x58809, // onsuspend\n+\t0xbe:  0x15c06, // button\n+\t0xbf:  0x4804,  // desc\n+\t0xc1:  0x3dd07, // section\n+\t0xc2:  0x5050a, // onprogress\n+\t0xc3:  0x56f09, // onstorage\n+\t0xc4:  0x2f704, // math\n+\t0xc5:  0x4f206, // onplay\n+\t0xc7:  0x5602,  // ul\n+\t0xc8:  0x6e07,  // pattern\n+\t0xc9:  0x4af0c, // onmousewheel\n+\t0xca:  0x36809, // ondragend\n+\t0xcb:  0xd104,  // ruby\n+\t0xcc:  0xc01,   // p\n+\t0xcd:  0x32e07, // onclose\n+\t0xce:  0x26105, // meter\n+\t0xcf:  0x13807, // bgsound\n+\t0xd2:  0x27206, // height\n+\t0xd4:  0x101,   // b\n+\t0xd5:  0x2ef08, // itemtype\n+\t0xd8:  0x1e007, // caption\n+\t0xd9:  0x10008, // disabled\n+\t0xdc:  0x5ea03, // svg\n+\t0xdd:  0x1bf05, // small\n+\t0xde:  0x44304, // data\n+\t0xe0:  0x4c608, // ononline\n+\t0xe1:  0x2c006, // mglyph\n+\t0xe3:  0x7f05,  // embed\n+\t0xe4:  0xf902,  // tr\n+\t0xe5:  0x4640b, // onloadstart\n+\t0xe7:  0x3b010, // ondurationchange\n+\t0xed:  0x12503, // bdo\n+\t0xee:  0x4702,  // td\n+\t0xef:  0x4f05,  // aside\n+\t0xf0:  0x29602, // h2\n+\t0xf1:  0x50708, // progress\n+\t0xf2:  0x14c0a, // blockquote\n+\t0xf4:  0xba05,  // label\n+\t0xf5:  0x601,   // i\n+\t0xf7:  0x7707,  // rowspan\n+\t0xfb:  0x4f209, // onplaying\n+\t0xfd:  0x2bf03, // img\n+\t0xfe:  0xc008,  // optgroup\n+\t0xff:  0x42c07, // content\n+\t0x101: 0x5190c, // onratechange\n+\t0x103: 0x3e80c, // onhashchange\n+\t0x104: 0x6507,  // details\n+\t0x106: 0x40908, // download\n+\t0x109: 0xe907,  // sandbox\n+\t0x10b: 0x42c0f, // contenteditable\n+\t0x10d: 0x37c0b, // ondragleave\n+\t0x10e: 0x2106,  // accept\n+\t0x10f: 0x55508, // selected\n+\t0x112: 0x2170a, // formaction\n+\t0x113: 0x2df06, // center\n+\t0x115: 0x44e10, // onloadedmetadata\n+\t0x116: 0x14804, // link\n+\t0x117: 0x11b04, // time\n+\t0x118: 0x1c40b, // crossorigin\n+\t0x119: 0x3ce07, // onfocus\n+\t0x11a: 0x56204, // wrap\n+\t0x11b: 0x42b04, // icon\n+\t0x11d: 0x2a905, // video\n+\t0x11e: 0x3d905, // class\n+\t0x121: 0x5990e, // onvolumechange\n+\t0x122: 0x3e206, // onblur\n+\t0x123: 0x2e509, // itemscope\n+\t0x124: 0x5db05, // style\n+\t0x127: 0x42706, // public\n+\t0x129: 0x2510e, // formnovalidate\n+\t0x12a: 0x55d06, // onshow\n+\t0x12c: 0x16609, // translate\n+\t0x12d: 0x9704,  // cite\n+\t0x12e: 0x2e802, // ms\n+\t0x12f: 0x1190c, // ontimeupdate\n+\t0x130: 0xfd04,  // kind\n+\t0x131: 0x2660a, // formtarget\n+\t0x135: 0x3c007, // onended\n+\t0x136: 0x28606, // hidden\n+\t0x137: 0x2c01,  // s\n+\t0x139: 0x2470a, // formmethod\n+\t0x13a: 0x44704, // list\n+\t0x13c: 0x27002, // h6\n+\t0x13d: 0xcd02,  // ol\n+\t0x13e: 0x3530b, // oncuechange\n+\t0x13f: 0x20a0d, // foreignobject\n+\t0x143: 0x5c90e, // onbeforeunload\n+\t0x145: 0x3a709, // onemptied\n+\t0x146: 0x17105, // defer\n+\t0x147: 0xef03,  // xmp\n+\t0x148: 0xaf05,  // audio\n+\t0x149: 0x1903,  // kbd\n+\t0x14c: 0x46f09, // onmessage\n+\t0x14d: 0x5c506, // option\n+\t0x14e: 0x4503,  // alt\n+\t0x14f: 0x33f07, // checked\n+\t0x150: 0x10c08, // autoplay\n+\t0x152: 0x202,   // br\n+\t0x153: 0x2550a, // novalidate\n+\t0x156: 0x7d07,  // noembed\n+\t0x159: 0x2ad07, // onclick\n+\t0x15a: 0x4780b, // onmousedown\n+\t0x15b: 0x3b808, // onchange\n+\t0x15e: 0x3fb09, // oninvalid\n+\t0x15f: 0x2e906, // scoped\n+\t0x160: 0x1ae08, // controls\n+\t0x161: 0x32905, // muted\n+\t0x163: 0x4ec06, // usemap\n+\t0x164: 0x1dd0a, // figcaption\n+\t0x165: 0x36806, // ondrag\n+\t0x166: 0x29304, // high\n+\t0x168: 0x3d403, // src\n+\t0x169: 0x17d06, // poster\n+\t0x16b: 0x18d0e, // annotation-xml\n+\t0x16c: 0x5bc04, // step\n+\t0x16d: 0x4,     // abbr\n+\t0x16e: 0x1b06,  // dialog\n+\t0x170: 0x1202,  // li\n+\t0x172: 0x47a02, // mo\n+\t0x175: 0x1fd03, // for\n+\t0x176: 0x1cd03, // ins\n+\t0x178: 0x53004, // size\n+\t0x17a: 0x5207,  // default\n+\t0x17b: 0x1a03,  // bdi\n+\t0x17c: 0x4ce0a, // onpagehide\n+\t0x17d: 0x9d07,  // dirname\n+\t0x17e: 0x23304, // type\n+\t0x17f: 0x21704, // form\n+\t0x180: 0x4c105, // inert\n+\t0x181: 0x12709, // oncanplay\n+\t0x182: 0x8303,  // dfn\n+\t0x183: 0x45c08, // tabindex\n+\t0x186: 0x7f02,  // em\n+\t0x187: 0x29c04, // lang\n+\t0x189: 0x3a208, // dropzone\n+\t0x18a: 0x4110a, // onkeypress\n+\t0x18b: 0x25b08, // datetime\n+\t0x18c: 0x18804, // cols\n+\t0x18d: 0x1,     // a\n+\t0x18e: 0x43b0c, // onloadeddata\n+\t0x191: 0x15606, // border\n+\t0x192: 0x2e05,  // tbody\n+\t0x193: 0x24b06, // method\n+\t0x195: 0xbe04,  // loop\n+\t0x196: 0x2b406, // iframe\n+\t0x198: 0x2fa04, // head\n+\t0x19e: 0x5b608, // manifest\n+\t0x19f: 0xe109,  // autofocus\n+\t0x1a0: 0x16f04, // code\n+\t0x1a1: 0x53406, // strong\n+\t0x1a2: 0x32108, // multiple\n+\t0x1a3: 0xc05,   // param\n+\t0x1a6: 0x23007, // enctype\n+\t0x1a7: 0x2dd04, // face\n+\t0x1a8: 0xf109,  // plaintext\n+\t0x1a9: 0x13602, // h1\n+\t0x1aa: 0x56609, // onstalled\n+\t0x1ad: 0x28d06, // script\n+\t0x1ae: 0x30006, // spacer\n+\t0x1af: 0x52c08, // onresize\n+\t0x1b0: 0x49b0b, // onmouseover\n+\t0x1b1: 0x59108, // onunload\n+\t0x1b2: 0x54208, // onseeked\n+\t0x1b4: 0x2330d, // typemustmatch\n+\t0x1b5: 0x1f106, // figure\n+\t0x1b6: 0x48e0a, // onmouseout\n+\t0x1b7: 0x27f03, // pre\n+\t0x1b8: 0x4e205, // width\n+\t0x1bb: 0x7404,  // nobr\n+\t0x1be: 0x7002,  // tt\n+\t0x1bf: 0x1105,  // align\n+\t0x1c0: 0x3f407, // oninput\n+\t0x1c3: 0x42107, // onkeyup\n+\t0x1c6: 0x1e50c, // onafterprint\n+\t0x1c7: 0x210e,  // accept-charset\n+\t0x1c8: 0x9806,  // itemid\n+\t0x1cb: 0x50e06, // strike\n+\t0x1cc: 0x57a03, // sub\n+\t0x1cd: 0xf905,  // track\n+\t0x1ce: 0x39705, // start\n+\t0x1d0: 0x11408, // basefont\n+\t0x1d6: 0x1cf06, // source\n+\t0x1d7: 0x1a806, // legend\n+\t0x1d8: 0x2f905, // thead\n+\t0x1da: 0x2e905, // scope\n+\t0x1dd: 0x21106, // object\n+\t0x1de: 0xa205,  // media\n+\t0x1df: 0x18d0a, // annotation\n+\t0x1e0: 0x22c0b, // formenctype\n+\t0x1e2: 0x28b08, // noscript\n+\t0x1e4: 0x53005, // sizes\n+\t0x1e5: 0xd50c,  // autocomplete\n+\t0x1e6: 0x7a04,  // span\n+\t0x1e7: 0x8508,  // noframes\n+\t0x1e8: 0x26a06, // target\n+\t0x1e9: 0x3a006, // ondrop\n+\t0x1ea: 0x3d406, // srcdoc\n+\t0x1ec: 0x5e08,  // reversed\n+\t0x1f0: 0x2c707, // isindex\n+\t0x1f3: 0x29808, // hreflang\n+\t0x1f5: 0x4e602, // h5\n+\t0x1f6: 0x5d507, // address\n+\t0x1fa: 0x30603, // max\n+\t0x1fb: 0xc70b,  // placeholder\n+\t0x1fc: 0x31408, // textarea\n+\t0x1fe: 0x4a609, // onmouseup\n+\t0x1ff: 0x3910b, // ondragstart\n+}\n+\n+const atomText = \"abbradiogrouparamalignmarkbdialogaccept-charsetbodyaccesskey\" +\n+\t\"genavaluealtdescanvasidefaultfootereversedetailsampatternobr\" +\n+\t\"owspanoembedfnoframesetitleasyncitemidirnamediagroupingaudio\" +\n+\t\"ncancelabelooptgrouplaceholderubyautocompleteautofocusandbox\" +\n+\t\"mplaintextrackindisabledivarautoplaybasefontimeupdatebdoncan\" +\n+\t\"playthrough1bgsoundlowbrbigblinkblockquoteborderbuttonabortr\" +\n+\t\"anslatecodefercolgroupostercolorcolspannotation-xmlcommandra\" +\n+\t\"ggablegendcontrolshapecoordsmallcrossoriginsourcefieldsetfig\" +\n+\t\"captionafterprintfigurequiredforeignObjectforeignobjectforma\" +\n+\t\"ctionbeforeprintformenctypemustmatchallengeformmethodformnov\" +\n+\t\"alidatetimeterformtargeth6heightmlhgroupreloadhiddenoscripth\" +\n+\t\"igh2hreflanghttp-equivideonclickiframeimageimglyph3isindexis\" +\n+\t\"mappletitemrefacenteritemscopeditemtypematheaderspacermaxlen\" +\n+\t\"gth4minmtextareadonlymultiplemutedoncloseamlesspellcheckedon\" +\n+\t\"contextmenuoncuechangeondblclickondragendondragenterondragle\" +\n+\t\"aveondragoverondragstarticleondropzonemptiedondurationchange\" +\n+\t\"onendedonerroronfocusrcdoclassectionbluronhashchangeoninputo\" +\n+\t\"ninvalidonkeydownloadonkeypressrclangonkeyupublicontentedita\" +\n+\t\"bleonloadeddatalistingonloadedmetadatabindexonloadstartonmes\" +\n+\t\"sageonmousedownonmousemoveonmouseoutputonmouseoveronmouseupo\" +\n+\t\"nmousewheelonofflinertononlineonpagehidelonpageshowidth5onpa\" +\n+\t\"usemaponplayingonpopstateonprogresstrikeytypeonratechangeonr\" +\n+\t\"esetonresizestrongonscrollonseekedonseekingonselectedonshowr\" +\n+\t\"aponstalledonstorageonsubmitempropenonsuspendonunloadonvolum\" +\n+\t\"echangeonwaitingoptimumanifestepromptoptionbeforeunloaddress\" +\n+\t\"tylesummarysupsvgsystemarquee\""}, {"sha": "db016a1c01cdd34e57ec9c5779c70f717b8f3c82", "filename": "libgo/go/exp/html/atom/table_test.go", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fatom%2Ftable_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,341 @@\n+// generated by go run gen.go -test; DO NOT EDIT\n+\n+package atom\n+\n+var testAtomList = []string{\n+\t\"a\",\n+\t\"abbr\",\n+\t\"accept\",\n+\t\"accept-charset\",\n+\t\"accesskey\",\n+\t\"action\",\n+\t\"address\",\n+\t\"align\",\n+\t\"alt\",\n+\t\"annotation\",\n+\t\"annotation-xml\",\n+\t\"applet\",\n+\t\"area\",\n+\t\"article\",\n+\t\"aside\",\n+\t\"async\",\n+\t\"audio\",\n+\t\"autocomplete\",\n+\t\"autofocus\",\n+\t\"autoplay\",\n+\t\"b\",\n+\t\"base\",\n+\t\"basefont\",\n+\t\"bdi\",\n+\t\"bdo\",\n+\t\"bgsound\",\n+\t\"big\",\n+\t\"blink\",\n+\t\"blockquote\",\n+\t\"body\",\n+\t\"border\",\n+\t\"br\",\n+\t\"button\",\n+\t\"canvas\",\n+\t\"caption\",\n+\t\"center\",\n+\t\"challenge\",\n+\t\"charset\",\n+\t\"checked\",\n+\t\"cite\",\n+\t\"cite\",\n+\t\"class\",\n+\t\"code\",\n+\t\"col\",\n+\t\"colgroup\",\n+\t\"color\",\n+\t\"cols\",\n+\t\"colspan\",\n+\t\"command\",\n+\t\"command\",\n+\t\"content\",\n+\t\"contenteditable\",\n+\t\"contextmenu\",\n+\t\"controls\",\n+\t\"coords\",\n+\t\"crossorigin\",\n+\t\"data\",\n+\t\"data\",\n+\t\"datalist\",\n+\t\"datetime\",\n+\t\"dd\",\n+\t\"default\",\n+\t\"defer\",\n+\t\"del\",\n+\t\"desc\",\n+\t\"details\",\n+\t\"dfn\",\n+\t\"dialog\",\n+\t\"dir\",\n+\t\"dirname\",\n+\t\"disabled\",\n+\t\"div\",\n+\t\"dl\",\n+\t\"download\",\n+\t\"draggable\",\n+\t\"dropzone\",\n+\t\"dt\",\n+\t\"em\",\n+\t\"embed\",\n+\t\"enctype\",\n+\t\"face\",\n+\t\"fieldset\",\n+\t\"figcaption\",\n+\t\"figure\",\n+\t\"font\",\n+\t\"footer\",\n+\t\"for\",\n+\t\"foreignObject\",\n+\t\"foreignobject\",\n+\t\"form\",\n+\t\"form\",\n+\t\"formaction\",\n+\t\"formenctype\",\n+\t\"formmethod\",\n+\t\"formnovalidate\",\n+\t\"formtarget\",\n+\t\"frame\",\n+\t\"frameset\",\n+\t\"h1\",\n+\t\"h2\",\n+\t\"h3\",\n+\t\"h4\",\n+\t\"h5\",\n+\t\"h6\",\n+\t\"head\",\n+\t\"header\",\n+\t\"headers\",\n+\t\"height\",\n+\t\"hgroup\",\n+\t\"hidden\",\n+\t\"high\",\n+\t\"hr\",\n+\t\"href\",\n+\t\"hreflang\",\n+\t\"html\",\n+\t\"http-equiv\",\n+\t\"i\",\n+\t\"icon\",\n+\t\"id\",\n+\t\"iframe\",\n+\t\"image\",\n+\t\"img\",\n+\t\"inert\",\n+\t\"input\",\n+\t\"ins\",\n+\t\"isindex\",\n+\t\"ismap\",\n+\t\"itemid\",\n+\t\"itemprop\",\n+\t\"itemref\",\n+\t\"itemscope\",\n+\t\"itemtype\",\n+\t\"kbd\",\n+\t\"keygen\",\n+\t\"keytype\",\n+\t\"kind\",\n+\t\"label\",\n+\t\"label\",\n+\t\"lang\",\n+\t\"legend\",\n+\t\"li\",\n+\t\"link\",\n+\t\"list\",\n+\t\"listing\",\n+\t\"loop\",\n+\t\"low\",\n+\t\"malignmark\",\n+\t\"manifest\",\n+\t\"map\",\n+\t\"mark\",\n+\t\"marquee\",\n+\t\"math\",\n+\t\"max\",\n+\t\"maxlength\",\n+\t\"media\",\n+\t\"mediagroup\",\n+\t\"menu\",\n+\t\"meta\",\n+\t\"meter\",\n+\t\"method\",\n+\t\"mglyph\",\n+\t\"mi\",\n+\t\"min\",\n+\t\"mn\",\n+\t\"mo\",\n+\t\"ms\",\n+\t\"mtext\",\n+\t\"multiple\",\n+\t\"muted\",\n+\t\"name\",\n+\t\"nav\",\n+\t\"nobr\",\n+\t\"noembed\",\n+\t\"noframes\",\n+\t\"noscript\",\n+\t\"novalidate\",\n+\t\"object\",\n+\t\"ol\",\n+\t\"onabort\",\n+\t\"onafterprint\",\n+\t\"onbeforeprint\",\n+\t\"onbeforeunload\",\n+\t\"onblur\",\n+\t\"oncancel\",\n+\t\"oncanplay\",\n+\t\"oncanplaythrough\",\n+\t\"onchange\",\n+\t\"onclick\",\n+\t\"onclose\",\n+\t\"oncontextmenu\",\n+\t\"oncuechange\",\n+\t\"ondblclick\",\n+\t\"ondrag\",\n+\t\"ondragend\",\n+\t\"ondragenter\",\n+\t\"ondragleave\",\n+\t\"ondragover\",\n+\t\"ondragstart\",\n+\t\"ondrop\",\n+\t\"ondurationchange\",\n+\t\"onemptied\",\n+\t\"onended\",\n+\t\"onerror\",\n+\t\"onfocus\",\n+\t\"onhashchange\",\n+\t\"oninput\",\n+\t\"oninvalid\",\n+\t\"onkeydown\",\n+\t\"onkeypress\",\n+\t\"onkeyup\",\n+\t\"onload\",\n+\t\"onloadeddata\",\n+\t\"onloadedmetadata\",\n+\t\"onloadstart\",\n+\t\"onmessage\",\n+\t\"onmousedown\",\n+\t\"onmousemove\",\n+\t\"onmouseout\",\n+\t\"onmouseover\",\n+\t\"onmouseup\",\n+\t\"onmousewheel\",\n+\t\"onoffline\",\n+\t\"ononline\",\n+\t\"onpagehide\",\n+\t\"onpageshow\",\n+\t\"onpause\",\n+\t\"onplay\",\n+\t\"onplaying\",\n+\t\"onpopstate\",\n+\t\"onprogress\",\n+\t\"onratechange\",\n+\t\"onreset\",\n+\t\"onresize\",\n+\t\"onscroll\",\n+\t\"onseeked\",\n+\t\"onseeking\",\n+\t\"onselect\",\n+\t\"onshow\",\n+\t\"onstalled\",\n+\t\"onstorage\",\n+\t\"onsubmit\",\n+\t\"onsuspend\",\n+\t\"ontimeupdate\",\n+\t\"onunload\",\n+\t\"onvolumechange\",\n+\t\"onwaiting\",\n+\t\"open\",\n+\t\"optgroup\",\n+\t\"optimum\",\n+\t\"option\",\n+\t\"output\",\n+\t\"p\",\n+\t\"param\",\n+\t\"pattern\",\n+\t\"ping\",\n+\t\"placeholder\",\n+\t\"plaintext\",\n+\t\"poster\",\n+\t\"pre\",\n+\t\"preload\",\n+\t\"progress\",\n+\t\"prompt\",\n+\t\"public\",\n+\t\"q\",\n+\t\"radiogroup\",\n+\t\"readonly\",\n+\t\"rel\",\n+\t\"required\",\n+\t\"reversed\",\n+\t\"rows\",\n+\t\"rowspan\",\n+\t\"rp\",\n+\t\"rt\",\n+\t\"ruby\",\n+\t\"s\",\n+\t\"samp\",\n+\t\"sandbox\",\n+\t\"scope\",\n+\t\"scoped\",\n+\t\"script\",\n+\t\"seamless\",\n+\t\"section\",\n+\t\"select\",\n+\t\"selected\",\n+\t\"shape\",\n+\t\"size\",\n+\t\"sizes\",\n+\t\"small\",\n+\t\"source\",\n+\t\"spacer\",\n+\t\"span\",\n+\t\"span\",\n+\t\"spellcheck\",\n+\t\"src\",\n+\t\"srcdoc\",\n+\t\"srclang\",\n+\t\"start\",\n+\t\"step\",\n+\t\"strike\",\n+\t\"strong\",\n+\t\"style\",\n+\t\"style\",\n+\t\"sub\",\n+\t\"summary\",\n+\t\"sup\",\n+\t\"svg\",\n+\t\"system\",\n+\t\"tabindex\",\n+\t\"table\",\n+\t\"target\",\n+\t\"tbody\",\n+\t\"td\",\n+\t\"textarea\",\n+\t\"tfoot\",\n+\t\"th\",\n+\t\"thead\",\n+\t\"time\",\n+\t\"title\",\n+\t\"title\",\n+\t\"tr\",\n+\t\"track\",\n+\t\"translate\",\n+\t\"tt\",\n+\t\"type\",\n+\t\"typemustmatch\",\n+\t\"u\",\n+\t\"ul\",\n+\t\"usemap\",\n+\t\"value\",\n+\t\"var\",\n+\t\"video\",\n+\t\"wbr\",\n+\t\"width\",\n+\t\"wrap\",\n+\t\"xmp\",\n+}"}, {"sha": "4dd453091c63a92555ffcab0f5f625c61e586f7b", "filename": "libgo/go/exp/html/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -84,7 +84,7 @@ example, to process each anchor node in depth-first order:\n \t\tif n.Type == html.ElementNode && n.Data == \"a\" {\n \t\t\t// Do something with n...\n \t\t}\n-\t\tfor _, c := range n.Child {\n+\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n \t\t\tf(c)\n \t\t}\n \t}"}, {"sha": "af8a007ed04629c83e1046b76cb977658ddcf3c2", "filename": "libgo/go/exp/html/entity.go", "status": "modified", "additions": 2077, "deletions": 2077, "changes": 4154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "7827dc2d506637e37b4cc5a08c9775ee0c68a035", "filename": "libgo/go/exp/html/escape.go", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -163,14 +163,15 @@ func unescapeEntity(b []byte, dst, src int, attribute bool) (dst1, src1 int) {\n }\n \n // unescape unescapes b's entities in-place, so that \"a&lt;b\" becomes \"a<b\".\n-func unescape(b []byte) []byte {\n+// attribute should be true if parsing an attribute value.\n+func unescape(b []byte, attribute bool) []byte {\n \tfor i, c := range b {\n \t\tif c == '&' {\n-\t\t\tdst, src := unescapeEntity(b, i, i, false)\n+\t\t\tdst, src := unescapeEntity(b, i, i, attribute)\n \t\t\tfor src < len(b) {\n \t\t\t\tc := b[src]\n \t\t\t\tif c == '&' {\n-\t\t\t\t\tdst, src = unescapeEntity(b, dst, src, false)\n+\t\t\t\t\tdst, src = unescapeEntity(b, dst, src, attribute)\n \t\t\t\t} else {\n \t\t\t\t\tb[dst] = c\n \t\t\t\t\tdst, src = dst+1, src+1\n@@ -192,7 +193,7 @@ func lower(b []byte) []byte {\n \treturn b\n }\n \n-const escapedChars = `&'<>\"`\n+const escapedChars = \"&'<>\\\"\\r\"\n \n func escape(w writer, s string) error {\n \ti := strings.IndexAny(s, escapedChars)\n@@ -205,13 +206,17 @@ func escape(w writer, s string) error {\n \t\tcase '&':\n \t\t\tesc = \"&amp;\"\n \t\tcase '\\'':\n-\t\t\tesc = \"&apos;\"\n+\t\t\t// \"&#39;\" is shorter than \"&apos;\" and apos was not in HTML until HTML5.\n+\t\t\tesc = \"&#39;\"\n \t\tcase '<':\n \t\t\tesc = \"&lt;\"\n \t\tcase '>':\n \t\t\tesc = \"&gt;\"\n \t\tcase '\"':\n-\t\t\tesc = \"&quot;\"\n+\t\t\t// \"&#34;\" is shorter than \"&quot;\".\n+\t\t\tesc = \"&#34;\"\n+\t\tcase '\\r':\n+\t\t\tesc = \"&#13;\"\n \t\tdefault:\n \t\t\tpanic(\"unrecognized escape character\")\n \t\t}\n@@ -226,7 +231,7 @@ func escape(w writer, s string) error {\n }\n \n // EscapeString escapes special characters like \"<\" to become \"&lt;\". It\n-// escapes only five such characters: amp, apos, lt, gt and quot.\n+// escapes only five such characters: <, >, &, ' and \".\n // UnescapeString(EscapeString(s)) == s always holds, but the converse isn't\n // always true.\n func EscapeString(s string) string {\n@@ -246,7 +251,7 @@ func EscapeString(s string) string {\n func UnescapeString(s string) string {\n \tfor _, c := range s {\n \t\tif c == '&' {\n-\t\t\treturn string(unescape([]byte(s)))\n+\t\t\treturn string(unescape([]byte(s), false))\n \t\t}\n \t}\n \treturn s"}, {"sha": "d3b3844099bf151b97131dde31a161b7de630053", "filename": "libgo/go/exp/html/foreign.go", "status": "modified", "additions": 98, "deletions": 4, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -8,6 +8,14 @@ import (\n \t\"strings\"\n )\n \n+func adjustAttributeNames(aa []Attribute, nameMap map[string]string) {\n+\tfor i := range aa {\n+\t\tif newName, ok := nameMap[aa[i].Key]; ok {\n+\t\t\taa[i].Key = newName\n+\t\t}\n+\t}\n+}\n+\n func adjustForeignAttributes(aa []Attribute) {\n \tfor i, a := range aa {\n \t\tif a.Key == \"\" || a.Key[0] != 'x' {\n@@ -29,8 +37,16 @@ func htmlIntegrationPoint(n *Node) bool {\n \t}\n \tswitch n.Namespace {\n \tcase \"math\":\n-\t\t// TODO: annotation-xml elements whose start tags have \"text/html\" or\n-\t\t// \"application/xhtml+xml\" encodings.\n+\t\tif n.Data == \"annotation-xml\" {\n+\t\t\tfor _, a := range n.Attr {\n+\t\t\t\tif a.Key == \"encoding\" {\n+\t\t\t\t\tval := strings.ToLower(a.Val)\n+\t\t\t\t\tif val == \"text/html\" || val == \"application/xhtml+xml\" {\n+\t\t\t\t\t\treturn true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \tcase \"svg\":\n \t\tswitch n.Data {\n \t\tcase \"desc\", \"foreignObject\", \"title\":\n@@ -40,6 +56,17 @@ func htmlIntegrationPoint(n *Node) bool {\n \treturn false\n }\n \n+func mathMLTextIntegrationPoint(n *Node) bool {\n+\tif n.Namespace != \"math\" {\n+\t\treturn false\n+\t}\n+\tswitch n.Data {\n+\tcase \"mi\", \"mo\", \"mn\", \"ms\", \"mtext\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // Section 12.2.5.5.\n var breakout = map[string]bool{\n \t\"b\":          true,\n@@ -55,7 +82,6 @@ var breakout = map[string]bool{\n \t\"dt\":         true,\n \t\"em\":         true,\n \t\"embed\":      true,\n-\t\"font\":       true,\n \t\"h1\":         true,\n \t\"h2\":         true,\n \t\"h3\":         true,\n@@ -129,4 +155,72 @@ var svgTagNameAdjustments = map[string]string{\n \t\"textpath\":            \"textPath\",\n }\n \n-// TODO: add look-up tables for MathML and SVG attribute adjustments.\n+// Section 12.2.5.1\n+var mathMLAttributeAdjustments = map[string]string{\n+\t\"definitionurl\": \"definitionURL\",\n+}\n+\n+var svgAttributeAdjustments = map[string]string{\n+\t\"attributename\":             \"attributeName\",\n+\t\"attributetype\":             \"attributeType\",\n+\t\"basefrequency\":             \"baseFrequency\",\n+\t\"baseprofile\":               \"baseProfile\",\n+\t\"calcmode\":                  \"calcMode\",\n+\t\"clippathunits\":             \"clipPathUnits\",\n+\t\"contentscripttype\":         \"contentScriptType\",\n+\t\"contentstyletype\":          \"contentStyleType\",\n+\t\"diffuseconstant\":           \"diffuseConstant\",\n+\t\"edgemode\":                  \"edgeMode\",\n+\t\"externalresourcesrequired\": \"externalResourcesRequired\",\n+\t\"filterres\":                 \"filterRes\",\n+\t\"filterunits\":               \"filterUnits\",\n+\t\"glyphref\":                  \"glyphRef\",\n+\t\"gradienttransform\":         \"gradientTransform\",\n+\t\"gradientunits\":             \"gradientUnits\",\n+\t\"kernelmatrix\":              \"kernelMatrix\",\n+\t\"kernelunitlength\":          \"kernelUnitLength\",\n+\t\"keypoints\":                 \"keyPoints\",\n+\t\"keysplines\":                \"keySplines\",\n+\t\"keytimes\":                  \"keyTimes\",\n+\t\"lengthadjust\":              \"lengthAdjust\",\n+\t\"limitingconeangle\":         \"limitingConeAngle\",\n+\t\"markerheight\":              \"markerHeight\",\n+\t\"markerunits\":               \"markerUnits\",\n+\t\"markerwidth\":               \"markerWidth\",\n+\t\"maskcontentunits\":          \"maskContentUnits\",\n+\t\"maskunits\":                 \"maskUnits\",\n+\t\"numoctaves\":                \"numOctaves\",\n+\t\"pathlength\":                \"pathLength\",\n+\t\"patterncontentunits\":       \"patternContentUnits\",\n+\t\"patterntransform\":          \"patternTransform\",\n+\t\"patternunits\":              \"patternUnits\",\n+\t\"pointsatx\":                 \"pointsAtX\",\n+\t\"pointsaty\":                 \"pointsAtY\",\n+\t\"pointsatz\":                 \"pointsAtZ\",\n+\t\"preservealpha\":             \"preserveAlpha\",\n+\t\"preserveaspectratio\":       \"preserveAspectRatio\",\n+\t\"primitiveunits\":            \"primitiveUnits\",\n+\t\"refx\":                      \"refX\",\n+\t\"refy\":                      \"refY\",\n+\t\"repeatcount\":               \"repeatCount\",\n+\t\"repeatdur\":                 \"repeatDur\",\n+\t\"requiredextensions\":        \"requiredExtensions\",\n+\t\"requiredfeatures\":          \"requiredFeatures\",\n+\t\"specularconstant\":          \"specularConstant\",\n+\t\"specularexponent\":          \"specularExponent\",\n+\t\"spreadmethod\":              \"spreadMethod\",\n+\t\"startoffset\":               \"startOffset\",\n+\t\"stddeviation\":              \"stdDeviation\",\n+\t\"stitchtiles\":               \"stitchTiles\",\n+\t\"surfacescale\":              \"surfaceScale\",\n+\t\"systemlanguage\":            \"systemLanguage\",\n+\t\"tablevalues\":               \"tableValues\",\n+\t\"targetx\":                   \"targetX\",\n+\t\"targety\":                   \"targetY\",\n+\t\"textlength\":                \"textLength\",\n+\t\"viewbox\":                   \"viewBox\",\n+\t\"viewtarget\":                \"viewTarget\",\n+\t\"xchannelselector\":          \"xChannelSelector\",\n+\t\"ychannelselector\":          \"yChannelSelector\",\n+\t\"zoomandpan\":                \"zoomAndPan\",\n+}"}, {"sha": "01f8c42ce3af74b1f4b0c4c0600126f026b70c02", "filename": "libgo/go/exp/html/node.go", "status": "modified", "additions": 88, "deletions": 49, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -4,8 +4,12 @@\n \n package html\n \n+import (\n+\t\"exp/html/atom\"\n+)\n+\n // A NodeType is the type of a Node.\n-type NodeType int\n+type NodeType uint32\n \n const (\n \tErrorNode NodeType = iota\n@@ -25,67 +29,115 @@ var scopeMarker = Node{Type: scopeMarkerNode}\n // A Node consists of a NodeType and some Data (tag name for element nodes,\n // content for text) and are part of a tree of Nodes. Element nodes may also\n // have a Namespace and contain a slice of Attributes. Data is unescaped, so\n-// that it looks like \"a<b\" rather than \"a&lt;b\".\n+// that it looks like \"a<b\" rather than \"a&lt;b\". For element nodes, DataAtom\n+// is the atom for Data, or zero if Data is not a known tag name.\n //\n // An empty Namespace implies a \"http://www.w3.org/1999/xhtml\" namespace.\n // Similarly, \"math\" is short for \"http://www.w3.org/1998/Math/MathML\", and\n // \"svg\" is short for \"http://www.w3.org/2000/svg\".\n type Node struct {\n-\tParent    *Node\n-\tChild     []*Node\n+\tParent, FirstChild, LastChild, PrevSibling, NextSibling *Node\n+\n \tType      NodeType\n+\tDataAtom  atom.Atom\n \tData      string\n \tNamespace string\n \tAttr      []Attribute\n }\n \n-// Add adds a node as a child of n.\n-// It will panic if the child's parent is not nil.\n-func (n *Node) Add(child *Node) {\n-\tif child.Parent != nil {\n-\t\tpanic(\"html: Node.Add called for a child Node that already has a parent\")\n+// InsertBefore inserts newChild as a child of n, immediately before oldChild\n+// in the sequence of n's children. oldChild may be nil, in which case newChild\n+// is appended to the end of n's children.\n+//\n+// It will panic if newChild already has a parent or siblings.\n+func (n *Node) InsertBefore(newChild, oldChild *Node) {\n+\tif newChild.Parent != nil || newChild.PrevSibling != nil || newChild.NextSibling != nil {\n+\t\tpanic(\"html: InsertBefore called for an attached child Node\")\n+\t}\n+\tvar prev, next *Node\n+\tif oldChild != nil {\n+\t\tprev, next = oldChild.PrevSibling, oldChild\n+\t} else {\n+\t\tprev = n.LastChild\n+\t}\n+\tif prev != nil {\n+\t\tprev.NextSibling = newChild\n+\t} else {\n+\t\tn.FirstChild = newChild\n+\t}\n+\tif next != nil {\n+\t\tnext.PrevSibling = newChild\n+\t} else {\n+\t\tn.LastChild = newChild\n \t}\n-\tchild.Parent = n\n-\tn.Child = append(n.Child, child)\n+\tnewChild.Parent = n\n+\tnewChild.PrevSibling = prev\n+\tnewChild.NextSibling = next\n }\n \n-// Remove removes a node as a child of n.\n-// It will panic if the child's parent is not n.\n-func (n *Node) Remove(child *Node) {\n-\tif child.Parent == n {\n-\t\tchild.Parent = nil\n-\t\tfor i, m := range n.Child {\n-\t\t\tif m == child {\n-\t\t\t\tcopy(n.Child[i:], n.Child[i+1:])\n-\t\t\t\tj := len(n.Child) - 1\n-\t\t\t\tn.Child[j] = nil\n-\t\t\t\tn.Child = n.Child[:j]\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n+// AppendChild adds a node c as a child of n.\n+//\n+// It will panic if c already has a parent or siblings.\n+func (n *Node) AppendChild(c *Node) {\n+\tif c.Parent != nil || c.PrevSibling != nil || c.NextSibling != nil {\n+\t\tpanic(\"html: AppendChild called for an attached child Node\")\n+\t}\n+\tlast := n.LastChild\n+\tif last != nil {\n+\t\tlast.NextSibling = c\n+\t} else {\n+\t\tn.FirstChild = c\n \t}\n-\tpanic(\"html: Node.Remove called for a non-child Node\")\n+\tn.LastChild = c\n+\tc.Parent = n\n+\tc.PrevSibling = last\n+}\n+\n+// RemoveChild removes a node c that is a child of n. Afterwards, c will have\n+// no parent and no siblings.\n+//\n+// It will panic if c's parent is not n.\n+func (n *Node) RemoveChild(c *Node) {\n+\tif c.Parent != n {\n+\t\tpanic(\"html: RemoveChild called for a non-child Node\")\n+\t}\n+\tif n.FirstChild == c {\n+\t\tn.FirstChild = c.NextSibling\n+\t}\n+\tif c.NextSibling != nil {\n+\t\tc.NextSibling.PrevSibling = c.PrevSibling\n+\t}\n+\tif n.LastChild == c {\n+\t\tn.LastChild = c.PrevSibling\n+\t}\n+\tif c.PrevSibling != nil {\n+\t\tc.PrevSibling.NextSibling = c.NextSibling\n+\t}\n+\tc.Parent = nil\n+\tc.PrevSibling = nil\n+\tc.NextSibling = nil\n }\n \n // reparentChildren reparents all of src's child nodes to dst.\n func reparentChildren(dst, src *Node) {\n-\tfor _, n := range src.Child {\n-\t\tif n.Parent != src {\n-\t\t\tpanic(\"html: nodes have an inconsistent parent/child relationship\")\n+\tfor {\n+\t\tchild := src.FirstChild\n+\t\tif child == nil {\n+\t\t\tbreak\n \t\t}\n-\t\tn.Parent = dst\n+\t\tsrc.RemoveChild(child)\n+\t\tdst.AppendChild(child)\n \t}\n-\tdst.Child = append(dst.Child, src.Child...)\n-\tsrc.Child = nil\n }\n \n // clone returns a new node with the same type, data and attributes.\n-// The clone has no parent and no children.\n+// The clone has no parent, no siblings and no children.\n func (n *Node) clone() *Node {\n \tm := &Node{\n-\t\tType: n.Type,\n-\t\tData: n.Data,\n-\t\tAttr: make([]Attribute, len(n.Attr)),\n+\t\tType:     n.Type,\n+\t\tDataAtom: n.DataAtom,\n+\t\tData:     n.Data,\n+\t\tAttr:     make([]Attribute, len(n.Attr)),\n \t}\n \tcopy(m.Attr, n.Attr)\n \treturn m\n@@ -139,16 +191,3 @@ func (s *nodeStack) remove(n *Node) {\n \t(*s)[j] = nil\n \t*s = (*s)[:j]\n }\n-\n-// TODO(nigeltao): forTag no longer used. Should it be deleted?\n-\n-// forTag returns the top-most element node with the given tag.\n-func (s *nodeStack) forTag(tag string) *Node {\n-\tfor i := len(*s) - 1; i >= 0; i-- {\n-\t\tn := (*s)[i]\n-\t\tif n.Type == ElementNode && n.Data == tag {\n-\t\t\treturn n\n-\t\t}\n-\t}\n-\treturn nil\n-}"}, {"sha": "471102f3a2218e2d19c882fbc94e0c7d7b1fb046", "filename": "libgo/go/exp/html/node_test.go", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fnode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fnode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fnode_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+// checkTreeConsistency checks that a node and its descendants are all\n+// consistent in their parent/child/sibling relationships.\n+func checkTreeConsistency(n *Node) error {\n+\treturn checkTreeConsistency1(n, 0)\n+}\n+\n+func checkTreeConsistency1(n *Node, depth int) error {\n+\tif depth == 1e4 {\n+\t\treturn fmt.Errorf(\"html: tree looks like it contains a cycle\")\n+\t}\n+\tif err := checkNodeConsistency(n); err != nil {\n+\t\treturn err\n+\t}\n+\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n+\t\tif err := checkTreeConsistency1(c, depth+1); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// checkNodeConsistency checks that a node's parent/child/sibling relationships\n+// are consistent.\n+func checkNodeConsistency(n *Node) error {\n+\tif n == nil {\n+\t\treturn nil\n+\t}\n+\n+\tnParent := 0\n+\tfor p := n.Parent; p != nil; p = p.Parent {\n+\t\tnParent++\n+\t\tif nParent == 1e4 {\n+\t\t\treturn fmt.Errorf(\"html: parent list looks like an infinite loop\")\n+\t\t}\n+\t}\n+\n+\tnForward := 0\n+\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n+\t\tnForward++\n+\t\tif nForward == 1e6 {\n+\t\t\treturn fmt.Errorf(\"html: forward list of children looks like an infinite loop\")\n+\t\t}\n+\t\tif c.Parent != n {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent child/parent relationship\")\n+\t\t}\n+\t}\n+\n+\tnBackward := 0\n+\tfor c := n.LastChild; c != nil; c = c.PrevSibling {\n+\t\tnBackward++\n+\t\tif nBackward == 1e6 {\n+\t\t\treturn fmt.Errorf(\"html: backward list of children looks like an infinite loop\")\n+\t\t}\n+\t\tif c.Parent != n {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent child/parent relationship\")\n+\t\t}\n+\t}\n+\n+\tif n.Parent != nil {\n+\t\tif n.Parent == n {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent relationship\")\n+\t\t}\n+\t\tif n.Parent == n.FirstChild {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent/first relationship\")\n+\t\t}\n+\t\tif n.Parent == n.LastChild {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent/last relationship\")\n+\t\t}\n+\t\tif n.Parent == n.PrevSibling {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent/prev relationship\")\n+\t\t}\n+\t\tif n.Parent == n.NextSibling {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent/next relationship\")\n+\t\t}\n+\n+\t\tparentHasNAsAChild := false\n+\t\tfor c := n.Parent.FirstChild; c != nil; c = c.NextSibling {\n+\t\t\tif c == n {\n+\t\t\t\tparentHasNAsAChild = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !parentHasNAsAChild {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent parent/child relationship\")\n+\t\t}\n+\t}\n+\n+\tif n.PrevSibling != nil && n.PrevSibling.NextSibling != n {\n+\t\treturn fmt.Errorf(\"html: inconsistent prev/next relationship\")\n+\t}\n+\tif n.NextSibling != nil && n.NextSibling.PrevSibling != n {\n+\t\treturn fmt.Errorf(\"html: inconsistent next/prev relationship\")\n+\t}\n+\n+\tif (n.FirstChild == nil) != (n.LastChild == nil) {\n+\t\treturn fmt.Errorf(\"html: inconsistent first/last relationship\")\n+\t}\n+\tif n.FirstChild != nil && n.FirstChild == n.LastChild {\n+\t\t// We have a sole child.\n+\t\tif n.FirstChild.PrevSibling != nil || n.FirstChild.NextSibling != nil {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent sole child's sibling relationship\")\n+\t\t}\n+\t}\n+\n+\tseen := map[*Node]bool{}\n+\n+\tvar last *Node\n+\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n+\t\tif seen[c] {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent repeated child\")\n+\t\t}\n+\t\tseen[c] = true\n+\t\tlast = c\n+\t}\n+\tif last != n.LastChild {\n+\t\treturn fmt.Errorf(\"html: inconsistent last relationship\")\n+\t}\n+\n+\tvar first *Node\n+\tfor c := n.LastChild; c != nil; c = c.PrevSibling {\n+\t\tif !seen[c] {\n+\t\t\treturn fmt.Errorf(\"html: inconsistent missing child\")\n+\t\t}\n+\t\tdelete(seen, c)\n+\t\tfirst = c\n+\t}\n+\tif first != n.FirstChild {\n+\t\treturn fmt.Errorf(\"html: inconsistent first relationship\")\n+\t}\n+\n+\tif len(seen) != 0 {\n+\t\treturn fmt.Errorf(\"html: inconsistent forwards/backwards child list\")\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "cae836e14b4894dcd586a29473c6fd1b4de62a46", "filename": "libgo/go/exp/html/parse.go", "status": "modified", "additions": 869, "deletions": 647, "changes": 1516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -5,6 +5,9 @@\n package html\n \n import (\n+\t\"errors\"\n+\ta \"exp/html/atom\"\n+\t\"fmt\"\n \t\"io\"\n \t\"strings\"\n )\n@@ -16,9 +19,8 @@ type parser struct {\n \ttokenizer *Tokenizer\n \t// tok is the most recently read token.\n \ttok Token\n-\t// Self-closing tags like <hr/> are re-interpreted as a two-token sequence:\n-\t// <hr> followed by </hr>. hasSelfClosingToken is true if we have just read\n-\t// the synthetic start tag and the next one due is the matching end tag.\n+\t// Self-closing tags like <hr/> are treated as start tags, except that\n+\t// hasSelfClosingToken is set while they are being processed.\n \thasSelfClosingToken bool\n \t// doc is the document root element.\n \tdoc *Node\n@@ -39,6 +41,8 @@ type parser struct {\n \tfosterParenting bool\n \t// quirks is whether the parser is operating in \"quirks mode.\"\n \tquirks bool\n+\t// fragment is whether the parser is parsing an HTML fragment.\n+\tfragment bool\n \t// context is the context element when parsing an HTML fragment\n \t// (section 12.4).\n \tcontext *Node\n@@ -53,10 +57,10 @@ func (p *parser) top() *Node {\n \n // Stop tags for use in popUntil. These come from section 12.2.3.2.\n var (\n-\tdefaultScopeStopTags = map[string][]string{\n-\t\t\"\":     {\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"},\n-\t\t\"math\": {\"annotation-xml\", \"mi\", \"mn\", \"mo\", \"ms\", \"mtext\"},\n-\t\t\"svg\":  {\"desc\", \"foreignObject\", \"title\"},\n+\tdefaultScopeStopTags = map[string][]a.Atom{\n+\t\t\"\":     {a.Applet, a.Caption, a.Html, a.Table, a.Td, a.Th, a.Marquee, a.Object},\n+\t\t\"math\": {a.AnnotationXml, a.Mi, a.Mn, a.Mo, a.Ms, a.Mtext},\n+\t\t\"svg\":  {a.Desc, a.ForeignObject, a.Title},\n \t}\n )\n \n@@ -68,6 +72,8 @@ const (\n \tbuttonScope\n \ttableScope\n \ttableRowScope\n+\ttableBodyScope\n+\tselectScope\n )\n \n // popUntil pops the stack of open elements at the highest element whose tag\n@@ -87,7 +93,7 @@ const (\n // no higher element in the stack that was also in the stop tags). For example,\n // popUntil(tableScope, \"table\") returns true and leaves:\n // [\"html\", \"body\", \"font\"]\n-func (p *parser) popUntil(s scope, matchTags ...string) bool {\n+func (p *parser) popUntil(s scope, matchTags ...a.Atom) bool {\n \tif i := p.indexOfElementInScope(s, matchTags...); i != -1 {\n \t\tp.oe = p.oe[:i]\n \t\treturn true\n@@ -98,28 +104,32 @@ func (p *parser) popUntil(s scope, matchTags ...string) bool {\n // indexOfElementInScope returns the index in p.oe of the highest element whose\n // tag is in matchTags that is in scope. If no matching element is in scope, it\n // returns -1.\n-func (p *parser) indexOfElementInScope(s scope, matchTags ...string) int {\n+func (p *parser) indexOfElementInScope(s scope, matchTags ...a.Atom) int {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\ttag := p.oe[i].Data\n+\t\ttagAtom := p.oe[i].DataAtom\n \t\tif p.oe[i].Namespace == \"\" {\n \t\t\tfor _, t := range matchTags {\n-\t\t\t\tif t == tag {\n+\t\t\t\tif t == tagAtom {\n \t\t\t\t\treturn i\n \t\t\t\t}\n \t\t\t}\n \t\t\tswitch s {\n \t\t\tcase defaultScope:\n \t\t\t\t// No-op.\n \t\t\tcase listItemScope:\n-\t\t\t\tif tag == \"ol\" || tag == \"ul\" {\n+\t\t\t\tif tagAtom == a.Ol || tagAtom == a.Ul {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n \t\t\tcase buttonScope:\n-\t\t\t\tif tag == \"button\" {\n+\t\t\t\tif tagAtom == a.Button {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n \t\t\tcase tableScope:\n-\t\t\t\tif tag == \"html\" || tag == \"table\" {\n+\t\t\t\tif tagAtom == a.Html || tagAtom == a.Table {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\tcase selectScope:\n+\t\t\t\tif tagAtom != a.Optgroup && tagAtom != a.Option {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n \t\t\tdefault:\n@@ -129,7 +139,7 @@ func (p *parser) indexOfElementInScope(s scope, matchTags ...string) int {\n \t\tswitch s {\n \t\tcase defaultScope, listItemScope, buttonScope:\n \t\t\tfor _, t := range defaultScopeStopTags[p.oe[i].Namespace] {\n-\t\t\t\tif t == tag {\n+\t\t\t\tif t == tagAtom {\n \t\t\t\t\treturn -1\n \t\t\t\t}\n \t\t\t}\n@@ -140,23 +150,28 @@ func (p *parser) indexOfElementInScope(s scope, matchTags ...string) int {\n \n // elementInScope is like popUntil, except that it doesn't modify the stack of\n // open elements.\n-func (p *parser) elementInScope(s scope, matchTags ...string) bool {\n+func (p *parser) elementInScope(s scope, matchTags ...a.Atom) bool {\n \treturn p.indexOfElementInScope(s, matchTags...) != -1\n }\n \n // clearStackToContext pops elements off the stack of open elements until a\n // scope-defined element is found.\n func (p *parser) clearStackToContext(s scope) {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\ttag := p.oe[i].Data\n+\t\ttagAtom := p.oe[i].DataAtom\n \t\tswitch s {\n \t\tcase tableScope:\n-\t\t\tif tag == \"html\" || tag == \"table\" {\n+\t\t\tif tagAtom == a.Html || tagAtom == a.Table {\n \t\t\t\tp.oe = p.oe[:i+1]\n \t\t\t\treturn\n \t\t\t}\n \t\tcase tableRowScope:\n-\t\t\tif tag == \"html\" || tag == \"tr\" {\n+\t\t\tif tagAtom == a.Html || tagAtom == a.Tr {\n+\t\t\t\tp.oe = p.oe[:i+1]\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase tableBodyScope:\n+\t\t\tif tagAtom == a.Html || tagAtom == a.Tbody || tagAtom == a.Tfoot || tagAtom == a.Thead {\n \t\t\t\tp.oe = p.oe[:i+1]\n \t\t\t\treturn\n \t\t\t}\n@@ -166,28 +181,64 @@ func (p *parser) clearStackToContext(s scope) {\n \t}\n }\n \n+// generateImpliedEndTags pops nodes off the stack of open elements as long as\n+// the top node has a tag name of dd, dt, li, option, optgroup, p, rp, or rt.\n+// If exceptions are specified, nodes with that name will not be popped off.\n+func (p *parser) generateImpliedEndTags(exceptions ...string) {\n+\tvar i int\n+loop:\n+\tfor i = len(p.oe) - 1; i >= 0; i-- {\n+\t\tn := p.oe[i]\n+\t\tif n.Type == ElementNode {\n+\t\t\tswitch n.DataAtom {\n+\t\t\tcase a.Dd, a.Dt, a.Li, a.Option, a.Optgroup, a.P, a.Rp, a.Rt:\n+\t\t\t\tfor _, except := range exceptions {\n+\t\t\t\t\tif n.Data == except {\n+\t\t\t\t\t\tbreak loop\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tbreak\n+\t}\n+\n+\tp.oe = p.oe[:i+1]\n+}\n+\n // addChild adds a child node n to the top element, and pushes n onto the stack\n // of open elements if it is an element node.\n func (p *parser) addChild(n *Node) {\n-\tif p.fosterParenting {\n+\tif p.shouldFosterParent() {\n \t\tp.fosterParent(n)\n \t} else {\n-\t\tp.top().Add(n)\n+\t\tp.top().AppendChild(n)\n \t}\n \n \tif n.Type == ElementNode {\n \t\tp.oe = append(p.oe, n)\n \t}\n }\n \n+// shouldFosterParent returns whether the next node to be added should be\n+// foster parented.\n+func (p *parser) shouldFosterParent() bool {\n+\tif p.fosterParenting {\n+\t\tswitch p.top().DataAtom {\n+\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // fosterParent adds a child node according to the foster parenting rules.\n // Section 12.2.5.3, \"foster parenting\".\n func (p *parser) fosterParent(n *Node) {\n-\tp.fosterParenting = false\n-\tvar table, parent *Node\n+\tvar table, parent, prev *Node\n \tvar i int\n \tfor i = len(p.oe) - 1; i >= 0; i-- {\n-\t\tif p.oe[i].Data == \"table\" {\n+\t\tif p.oe[i].DataAtom == a.Table {\n \t\t\ttable = p.oe[i]\n \t\t\tbreak\n \t\t}\n@@ -203,35 +254,37 @@ func (p *parser) fosterParent(n *Node) {\n \t\tparent = p.oe[i-1]\n \t}\n \n-\tvar child *Node\n-\tfor i, child = range parent.Child {\n-\t\tif child == table {\n-\t\t\tbreak\n-\t\t}\n+\tif table != nil {\n+\t\tprev = table.PrevSibling\n+\t} else {\n+\t\tprev = parent.LastChild\n \t}\n-\n-\tif i > 0 && parent.Child[i-1].Type == TextNode && n.Type == TextNode {\n-\t\tparent.Child[i-1].Data += n.Data\n+\tif prev != nil && prev.Type == TextNode && n.Type == TextNode {\n+\t\tprev.Data += n.Data\n \t\treturn\n \t}\n \n-\tif i == len(parent.Child) {\n-\t\tparent.Add(n)\n-\t} else {\n-\t\t// Insert n into parent.Child at index i.\n-\t\tparent.Child = append(parent.Child[:i+1], parent.Child[i:]...)\n-\t\tparent.Child[i] = n\n-\t\tn.Parent = parent\n-\t}\n+\tparent.InsertBefore(n, table)\n }\n \n // addText adds text to the preceding node if it is a text node, or else it\n // calls addChild with a new text node.\n func (p *parser) addText(text string) {\n-\t// TODO: distinguish whitespace text from others.\n+\tif text == \"\" {\n+\t\treturn\n+\t}\n+\n+\tif p.shouldFosterParent() {\n+\t\tp.fosterParent(&Node{\n+\t\t\tType: TextNode,\n+\t\t\tData: text,\n+\t\t})\n+\t\treturn\n+\t}\n+\n \tt := p.top()\n-\tif i := len(t.Child); i > 0 && t.Child[i-1].Type == TextNode {\n-\t\tt.Child[i-1].Data += text\n+\tif n := t.LastChild; n != nil && n.Type == TextNode {\n+\t\tn.Data += text\n \t\treturn\n \t}\n \tp.addChild(&Node{\n@@ -240,20 +293,61 @@ func (p *parser) addText(text string) {\n \t})\n }\n \n-// addElement calls addChild with an element node.\n-func (p *parser) addElement(tag string, attr []Attribute) {\n+// addElement adds a child element based on the current token.\n+func (p *parser) addElement() {\n \tp.addChild(&Node{\n-\t\tType: ElementNode,\n-\t\tData: tag,\n-\t\tAttr: attr,\n+\t\tType:     ElementNode,\n+\t\tDataAtom: p.tok.DataAtom,\n+\t\tData:     p.tok.Data,\n+\t\tAttr:     p.tok.Attr,\n \t})\n }\n \n // Section 12.2.3.3.\n-func (p *parser) addFormattingElement(tag string, attr []Attribute) {\n-\tp.addElement(tag, attr)\n+func (p *parser) addFormattingElement() {\n+\ttagAtom, attr := p.tok.DataAtom, p.tok.Attr\n+\tp.addElement()\n+\n+\t// Implement the Noah's Ark clause, but with three per family instead of two.\n+\tidenticalElements := 0\n+findIdenticalElements:\n+\tfor i := len(p.afe) - 1; i >= 0; i-- {\n+\t\tn := p.afe[i]\n+\t\tif n.Type == scopeMarkerNode {\n+\t\t\tbreak\n+\t\t}\n+\t\tif n.Type != ElementNode {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n.Namespace != \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n.DataAtom != tagAtom {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(n.Attr) != len(attr) {\n+\t\t\tcontinue\n+\t\t}\n+\tcompareAttributes:\n+\t\tfor _, t0 := range n.Attr {\n+\t\t\tfor _, t1 := range attr {\n+\t\t\t\tif t0.Key == t1.Key && t0.Namespace == t1.Namespace && t0.Val == t1.Val {\n+\t\t\t\t\t// Found a match for this attribute, continue with the next attribute.\n+\t\t\t\t\tcontinue compareAttributes\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// If we get here, there is no attribute that matches a.\n+\t\t\t// Therefore the element is not identical to the new one.\n+\t\t\tcontinue findIdenticalElements\n+\t\t}\n+\n+\t\tidenticalElements++\n+\t\tif identicalElements >= 3 {\n+\t\t\tp.afe.remove(n)\n+\t\t}\n+\t}\n+\n \tp.afe = append(p.afe, p.top())\n-\t// TODO.\n }\n \n // Section 12.2.3.3.\n@@ -295,27 +389,6 @@ func (p *parser) reconstructActiveFormattingElements() {\n \t}\n }\n \n-// read reads the next token. This is usually from the tokenizer, but it may\n-// be the synthesized end tag implied by a self-closing tag.\n-func (p *parser) read() error {\n-\tif p.hasSelfClosingToken {\n-\t\tp.hasSelfClosingToken = false\n-\t\tp.tok.Type = EndTagToken\n-\t\tp.tok.Attr = nil\n-\t\treturn nil\n-\t}\n-\tp.tokenizer.Next()\n-\tp.tok = p.tokenizer.Token()\n-\tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\treturn p.tokenizer.Err()\n-\tcase SelfClosingTagToken:\n-\t\tp.hasSelfClosingToken = true\n-\t\tp.tok.Type = StartTagToken\n-\t}\n-\treturn nil\n-}\n-\n // Section 12.2.4.\n func (p *parser) acknowledgeSelfClosingTag() {\n \tp.hasSelfClosingToken = false\n@@ -345,28 +418,28 @@ func (p *parser) resetInsertionMode() {\n \t\t\tn = p.context\n \t\t}\n \n-\t\tswitch n.Data {\n-\t\tcase \"select\":\n+\t\tswitch n.DataAtom {\n+\t\tcase a.Select:\n \t\t\tp.im = inSelectIM\n-\t\tcase \"td\", \"th\":\n+\t\tcase a.Td, a.Th:\n \t\t\tp.im = inCellIM\n-\t\tcase \"tr\":\n+\t\tcase a.Tr:\n \t\t\tp.im = inRowIM\n-\t\tcase \"tbody\", \"thead\", \"tfoot\":\n+\t\tcase a.Tbody, a.Thead, a.Tfoot:\n \t\t\tp.im = inTableBodyIM\n-\t\tcase \"caption\":\n+\t\tcase a.Caption:\n \t\t\tp.im = inCaptionIM\n-\t\tcase \"colgroup\":\n+\t\tcase a.Colgroup:\n \t\t\tp.im = inColumnGroupIM\n-\t\tcase \"table\":\n+\t\tcase a.Table:\n \t\t\tp.im = inTableIM\n-\t\tcase \"head\":\n+\t\tcase a.Head:\n \t\t\tp.im = inBodyIM\n-\t\tcase \"body\":\n+\t\tcase a.Body:\n \t\t\tp.im = inBodyIM\n-\t\tcase \"frameset\":\n+\t\tcase a.Frameset:\n \t\t\tp.im = inFramesetIM\n-\t\tcase \"html\":\n+\t\tcase a.Html:\n \t\t\tp.im = beforeHeadIM\n \t\tdefault:\n \t\t\tcontinue\n@@ -388,14 +461,14 @@ func initialIM(p *parser) bool {\n \t\t\treturn true\n \t\t}\n \tcase CommentToken:\n-\t\tp.doc.Add(&Node{\n+\t\tp.doc.AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n \tcase DoctypeToken:\n \t\tn, quirks := parseDoctype(p.tok.Data)\n-\t\tp.doc.Add(n)\n+\t\tp.doc.AppendChild(n)\n \t\tp.quirks = quirks\n \t\tp.im = beforeHTMLIM\n \t\treturn true\n@@ -408,97 +481,87 @@ func initialIM(p *parser) bool {\n // Section 12.2.5.4.2.\n func beforeHTMLIM(p *parser) bool {\n \tswitch p.tok.Type {\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \tcase TextToken:\n \t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n \t\tif len(p.tok.Data) == 0 {\n \t\t\t// It was all whitespace, so ignore it.\n \t\t\treturn true\n \t\t}\n \tcase StartTagToken:\n-\t\tif p.tok.Data == \"html\" {\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tif p.tok.DataAtom == a.Html {\n+\t\t\tp.addElement()\n \t\t\tp.im = beforeHeadIM\n \t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"head\", \"body\", \"html\", \"br\":\n-\t\t\t// Drop down to creating an implied <html> tag.\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Head, a.Body, a.Html, a.Br:\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n+\t\t\treturn false\n \t\tdefault:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\t}\n \tcase CommentToken:\n-\t\tp.doc.Add(&Node{\n+\t\tp.doc.AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n \t}\n-\t// Create an implied <html> tag.\n-\tp.addElement(\"html\", nil)\n-\tp.im = beforeHeadIM\n+\tp.parseImpliedToken(StartTagToken, a.Html, a.Html.String())\n \treturn false\n }\n \n // Section 12.2.5.4.3.\n func beforeHeadIM(p *parser) bool {\n-\tvar (\n-\t\tadd     bool\n-\t\tattr    []Attribute\n-\t\timplied bool\n-\t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\timplied = true\n \tcase TextToken:\n \t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n \t\tif len(p.tok.Data) == 0 {\n \t\t\t// It was all whitespace, so ignore it.\n \t\t\treturn true\n \t\t}\n-\t\timplied = true\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"head\":\n-\t\t\tadd = true\n-\t\t\tattr = p.tok.Attr\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Head:\n+\t\t\tp.addElement()\n+\t\t\tp.head = p.top()\n+\t\t\tp.im = inHeadIM\n+\t\t\treturn true\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tdefault:\n-\t\t\timplied = true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"head\", \"body\", \"html\", \"br\":\n-\t\t\timplied = true\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Head, a.Body, a.Html, a.Br:\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n+\t\t\treturn false\n \t\tdefault:\n \t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \t}\n-\tif add || implied {\n-\t\tp.addElement(\"head\", attr)\n-\t\tp.head = p.top()\n-\t}\n-\tp.im = inHeadIM\n-\treturn !implied\n+\n+\tp.parseImpliedToken(StartTagToken, a.Head, a.Head.String())\n+\treturn false\n }\n \n // Section 12.2.5.4.4.\n func inHeadIM(p *parser) bool {\n-\tvar (\n-\t\tpop     bool\n-\t\timplied bool\n-\t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\timplied = true\n \tcase TextToken:\n \t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n \t\tif len(s) < len(p.tok.Data) {\n@@ -509,32 +572,36 @@ func inHeadIM(p *parser) bool {\n \t\t\t}\n \t\t\tp.tok.Data = s\n \t\t}\n-\t\timplied = true\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tcase \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta:\n+\t\t\tp.addElement()\n \t\t\tp.oe.pop()\n \t\t\tp.acknowledgeSelfClosingTag()\n-\t\tcase \"script\", \"title\", \"noscript\", \"noframes\", \"style\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\treturn true\n+\t\tcase a.Script, a.Title, a.Noscript, a.Noframes, a.Style:\n+\t\t\tp.addElement()\n \t\t\tp.setOriginalIM()\n \t\t\tp.im = textIM\n \t\t\treturn true\n-\t\tcase \"head\":\n+\t\tcase a.Head:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tdefault:\n-\t\t\timplied = true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"head\":\n-\t\t\tpop = true\n-\t\tcase \"body\", \"html\", \"br\":\n-\t\t\timplied = true\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Head:\n+\t\t\tn := p.oe.pop()\n+\t\t\tif n.DataAtom != a.Head {\n+\t\t\t\tpanic(\"html: bad parser state: <head> element not found, in the in-head insertion mode\")\n+\t\t\t}\n+\t\t\tp.im = afterHeadIM\n+\t\t\treturn true\n+\t\tcase a.Body, a.Html, a.Br:\n+\t\t\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n+\t\t\treturn false\n \t\tdefault:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n@@ -545,30 +612,18 @@ func inHeadIM(p *parser) bool {\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \t}\n-\tif pop || implied {\n-\t\tn := p.oe.pop()\n-\t\tif n.Data != \"head\" {\n-\t\t\tpanic(\"html: bad parser state: <head> element not found, in the in-head insertion mode\")\n-\t\t}\n-\t\tp.im = afterHeadIM\n-\t\treturn !implied\n-\t}\n-\treturn true\n+\n+\tp.parseImpliedToken(EndTagToken, a.Head, a.Head.String())\n+\treturn false\n }\n \n // Section 12.2.5.4.6.\n func afterHeadIM(p *parser) bool {\n-\tvar (\n-\t\tadd        bool\n-\t\tattr       []Attribute\n-\t\tframesetOK bool\n-\t\timplied    bool\n-\t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\timplied = true\n-\t\tframesetOK = true\n \tcase TextToken:\n \t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n \t\tif len(s) < len(p.tok.Data) {\n@@ -579,36 +634,31 @@ func afterHeadIM(p *parser) bool {\n \t\t\t}\n \t\t\tp.tok.Data = s\n \t\t}\n-\t\timplied = true\n-\t\tframesetOK = true\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n-\t\t\t// TODO.\n-\t\tcase \"body\":\n-\t\t\tadd = true\n-\t\t\tattr = p.tok.Attr\n-\t\t\tframesetOK = false\n-\t\tcase \"frameset\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n+\t\t\treturn inBodyIM(p)\n+\t\tcase a.Body:\n+\t\t\tp.addElement()\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = inBodyIM\n+\t\t\treturn true\n+\t\tcase a.Frameset:\n+\t\t\tp.addElement()\n \t\t\tp.im = inFramesetIM\n \t\t\treturn true\n-\t\tcase \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\":\n+\t\tcase a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:\n \t\t\tp.oe = append(p.oe, p.head)\n-\t\t\tdefer p.oe.pop()\n+\t\t\tdefer p.oe.remove(p.head)\n \t\t\treturn inHeadIM(p)\n-\t\tcase \"head\":\n+\t\tcase a.Head:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tdefault:\n-\t\t\timplied = true\n-\t\t\tframesetOK = true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"body\", \"html\", \"br\":\n-\t\t\timplied = true\n-\t\t\tframesetOK = true\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Body, a.Html, a.Br:\n+\t\t\t// Drop down to creating an implied <body> tag.\n \t\tdefault:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n@@ -619,13 +669,14 @@ func afterHeadIM(p *parser) bool {\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \t}\n-\tif add || implied {\n-\t\tp.addElement(\"body\", attr)\n-\t\tp.framesetOK = framesetOK\n-\t}\n-\tp.im = inBodyIM\n-\treturn !implied\n+\n+\tp.parseImpliedToken(StartTagToken, a.Body, a.Body.String())\n+\tp.framesetOK = true\n+\treturn false\n }\n \n // copyAttributes copies attributes of src not found on dst to dst.\n@@ -634,13 +685,13 @@ func copyAttributes(dst *Node, src Token) {\n \t\treturn\n \t}\n \tattr := map[string]string{}\n-\tfor _, a := range dst.Attr {\n-\t\tattr[a.Key] = a.Val\n+\tfor _, t := range dst.Attr {\n+\t\tattr[t.Key] = t.Val\n \t}\n-\tfor _, a := range src.Attr {\n-\t\tif _, ok := attr[a.Key]; !ok {\n-\t\t\tdst.Attr = append(dst.Attr, a)\n-\t\t\tattr[a.Key] = a.Val\n+\tfor _, t := range src.Attr {\n+\t\tif _, ok := attr[t.Key]; !ok {\n+\t\t\tdst.Attr = append(dst.Attr, t)\n+\t\t\tattr[t.Key] = t.Val\n \t\t}\n \t}\n }\n@@ -649,106 +700,85 @@ func copyAttributes(dst *Node, src Token) {\n func inBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase TextToken:\n-\t\tswitch n := p.oe.top(); n.Data {\n-\t\tcase \"pre\", \"listing\", \"textarea\":\n-\t\t\tif len(n.Child) == 0 {\n+\t\td := p.tok.Data\n+\t\tswitch n := p.oe.top(); n.DataAtom {\n+\t\tcase a.Pre, a.Listing:\n+\t\t\tif n.FirstChild == nil {\n \t\t\t\t// Ignore a newline at the start of a <pre> block.\n-\t\t\t\td := p.tok.Data\n \t\t\t\tif d != \"\" && d[0] == '\\r' {\n \t\t\t\t\td = d[1:]\n \t\t\t\t}\n \t\t\t\tif d != \"\" && d[0] == '\\n' {\n \t\t\t\t\td = d[1:]\n \t\t\t\t}\n-\t\t\t\tif d == \"\" {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n-\t\t\t\tp.tok.Data = d\n \t\t\t}\n \t\t}\n+\t\td = strings.Replace(d, \"\\x00\", \"\", -1)\n+\t\tif d == \"\" {\n+\t\t\treturn true\n+\t\t}\n \t\tp.reconstructActiveFormattingElements()\n-\t\tp.addText(p.tok.Data)\n-\t\tp.framesetOK = false\n+\t\tp.addText(d)\n+\t\tif p.framesetOK && strings.TrimLeft(d, whitespace) != \"\" {\n+\t\t\t// There were non-whitespace characters inserted.\n+\t\t\tp.framesetOK = false\n+\t\t}\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\tcopyAttributes(p.oe[0], p.tok)\n-\t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\":\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\":\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tswitch n := p.top(); n.Data {\n-\t\t\tcase \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\":\n-\t\t\t\tp.oe.pop()\n-\t\t\t}\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"a\":\n-\t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n-\t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.Data == \"a\" {\n-\t\t\t\t\tp.inBodyEndTagFormatting(\"a\")\n-\t\t\t\t\tp.oe.remove(n)\n-\t\t\t\t\tp.afe.remove(n)\n-\t\t\t\t\tbreak\n+\t\tcase a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:\n+\t\t\treturn inHeadIM(p)\n+\t\tcase a.Body:\n+\t\t\tif len(p.oe) >= 2 {\n+\t\t\t\tbody := p.oe[1]\n+\t\t\t\tif body.Type == ElementNode && body.DataAtom == a.Body {\n+\t\t\t\t\tp.framesetOK = false\n+\t\t\t\t\tcopyAttributes(body, p.tok)\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\":\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"nobr\":\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tif p.elementInScope(defaultScope, \"nobr\") {\n-\t\t\t\tp.inBodyEndTagFormatting(\"nobr\")\n-\t\t\t\tp.reconstructActiveFormattingElements()\n+\t\tcase a.Frameset:\n+\t\t\tif !p.framesetOK || len(p.oe) < 2 || p.oe[1].DataAtom != a.Body {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n \t\t\t}\n-\t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"applet\", \"marquee\", \"object\":\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.afe = append(p.afe, &scopeMarker)\n-\t\t\tp.framesetOK = false\n-\t\tcase \"area\", \"br\", \"embed\", \"img\", \"input\", \"keygen\", \"wbr\":\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.oe.pop()\n-\t\t\tp.acknowledgeSelfClosingTag()\n-\t\t\tp.framesetOK = false\n-\t\tcase \"table\":\n-\t\t\tif !p.quirks {\n-\t\t\t\tp.popUntil(buttonScope, \"p\")\n+\t\t\tbody := p.oe[1]\n+\t\t\tif body.Parent != nil {\n+\t\t\t\tbody.Parent.RemoveChild(body)\n \t\t\t}\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.framesetOK = false\n-\t\t\tp.im = inTableIM\n+\t\t\tp.oe = p.oe[:1]\n+\t\t\tp.addElement()\n+\t\t\tp.im = inFramesetIM\n \t\t\treturn true\n-\t\tcase \"hr\":\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.oe.pop()\n-\t\t\tp.acknowledgeSelfClosingTag()\n-\t\t\tp.framesetOK = false\n-\t\tcase \"select\":\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Menu, a.Nav, a.Ol, a.P, a.Section, a.Summary, a.Ul:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tswitch n := p.top(); n.DataAtom {\n+\t\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tp.addElement()\n+\t\tcase a.Pre, a.Listing:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\t\t// The newline, if any, will be dealt with by the TextToken case.\n \t\t\tp.framesetOK = false\n-\t\t\tp.im = inSelectIM\n-\t\t\treturn true\n-\t\tcase \"form\":\n+\t\tcase a.Form:\n \t\t\tif p.form == nil {\n-\t\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\t\tp.addElement()\n \t\t\t\tp.form = p.top()\n \t\t\t}\n-\t\tcase \"li\":\n+\t\tcase a.Li:\n \t\t\tp.framesetOK = false\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\t\t\tnode := p.oe[i]\n-\t\t\t\tswitch node.Data {\n-\t\t\t\tcase \"li\":\n-\t\t\t\t\tp.popUntil(listItemScope, \"li\")\n-\t\t\t\tcase \"address\", \"div\", \"p\":\n+\t\t\t\tswitch node.DataAtom {\n+\t\t\t\tcase a.Li:\n+\t\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t\tcase a.Address, a.Div, a.P:\n \t\t\t\t\tcontinue\n \t\t\t\tdefault:\n \t\t\t\t\tif !isSpecialElement(node) {\n@@ -757,16 +787,16 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"dd\", \"dt\":\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\tcase a.Dd, a.Dt:\n \t\t\tp.framesetOK = false\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\t\t\tnode := p.oe[i]\n-\t\t\t\tswitch node.Data {\n-\t\t\t\tcase \"dd\", \"dt\":\n+\t\t\t\tswitch node.DataAtom {\n+\t\t\t\tcase a.Dd, a.Dt:\n \t\t\t\t\tp.oe = p.oe[:i]\n-\t\t\t\tcase \"address\", \"div\", \"p\":\n+\t\t\t\tcase a.Address, a.Div, a.P:\n \t\t\t\t\tcontinue\n \t\t\t\tdefault:\n \t\t\t\t\tif !isSpecialElement(node) {\n@@ -775,132 +805,224 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"plaintext\":\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"button\":\n-\t\t\tp.popUntil(defaultScope, \"button\")\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\tcase a.Plaintext:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\tcase a.Button:\n+\t\t\tp.popUntil(defaultScope, a.Button)\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.framesetOK = false\n-\t\tcase \"optgroup\", \"option\":\n-\t\t\tif p.top().Data == \"option\" {\n-\t\t\t\tp.oe.pop()\n-\t\t\t}\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"body\":\n-\t\t\tif len(p.oe) >= 2 {\n-\t\t\t\tbody := p.oe[1]\n-\t\t\t\tif body.Type == ElementNode && body.Data == \"body\" {\n-\t\t\t\t\tp.framesetOK = false\n-\t\t\t\t\tcopyAttributes(body, p.tok)\n+\t\tcase a.A:\n+\t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n+\t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {\n+\t\t\t\t\tp.inBodyEndTagFormatting(a.A)\n+\t\t\t\t\tp.oe.remove(n)\n+\t\t\t\t\tp.afe.remove(n)\n+\t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\tcase \"frameset\":\n-\t\t\tif !p.framesetOK || len(p.oe) < 2 || p.oe[1].Data != \"body\" {\n-\t\t\t\t// Ignore the token.\n-\t\t\t\treturn true\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addFormattingElement()\n+\t\tcase a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addFormattingElement()\n+\t\tcase a.Nobr:\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tif p.elementInScope(defaultScope, a.Nobr) {\n+\t\t\t\tp.inBodyEndTagFormatting(a.Nobr)\n+\t\t\t\tp.reconstructActiveFormattingElements()\n \t\t\t}\n-\t\t\tbody := p.oe[1]\n-\t\t\tif body.Parent != nil {\n-\t\t\t\tbody.Parent.Remove(body)\n+\t\t\tp.addFormattingElement()\n+\t\tcase a.Applet, a.Marquee, a.Object:\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement()\n+\t\t\tp.afe = append(p.afe, &scopeMarker)\n+\t\t\tp.framesetOK = false\n+\t\tcase a.Table:\n+\t\t\tif !p.quirks {\n+\t\t\t\tp.popUntil(buttonScope, a.P)\n \t\t\t}\n-\t\t\tp.oe = p.oe[:1]\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.im = inFramesetIM\n+\t\t\tp.addElement()\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = inTableIM\n \t\t\treturn true\n-\t\tcase \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\":\n-\t\t\treturn inHeadIM(p)\n-\t\tcase \"image\":\n-\t\t\tp.tok.Data = \"img\"\n+\t\tcase a.Area, a.Br, a.Embed, a.Img, a.Input, a.Keygen, a.Wbr:\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement()\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t\tif p.tok.DataAtom == a.Input {\n+\t\t\t\tfor _, t := range p.tok.Attr {\n+\t\t\t\t\tif t.Key == \"type\" {\n+\t\t\t\t\t\tif strings.ToLower(t.Val) == \"hidden\" {\n+\t\t\t\t\t\t\t// Skip setting framesetOK = false\n+\t\t\t\t\t\t\treturn true\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tp.framesetOK = false\n+\t\tcase a.Param, a.Source, a.Track:\n+\t\t\tp.addElement()\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\tcase a.Hr:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.addElement()\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t\tp.framesetOK = false\n+\t\tcase a.Image:\n+\t\t\tp.tok.DataAtom = a.Img\n+\t\t\tp.tok.Data = a.Img.String()\n \t\t\treturn false\n-\t\tcase \"isindex\":\n+\t\tcase a.Isindex:\n \t\t\tif p.form != nil {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n \t\t\taction := \"\"\n \t\t\tprompt := \"This is a searchable index. Enter search keywords: \"\n \t\t\tattr := []Attribute{{Key: \"name\", Val: \"isindex\"}}\n-\t\t\tfor _, a := range p.tok.Attr {\n-\t\t\t\tswitch a.Key {\n+\t\t\tfor _, t := range p.tok.Attr {\n+\t\t\t\tswitch t.Key {\n \t\t\t\tcase \"action\":\n-\t\t\t\t\taction = a.Val\n+\t\t\t\t\taction = t.Val\n \t\t\t\tcase \"name\":\n \t\t\t\t\t// Ignore the attribute.\n \t\t\t\tcase \"prompt\":\n-\t\t\t\t\tprompt = a.Val\n+\t\t\t\t\tprompt = t.Val\n \t\t\t\tdefault:\n-\t\t\t\t\tattr = append(attr, a)\n+\t\t\t\t\tattr = append(attr, t)\n \t\t\t\t}\n \t\t\t}\n \t\t\tp.acknowledgeSelfClosingTag()\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\t\tp.addElement(\"form\", nil)\n-\t\t\tp.form = p.top()\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Form, a.Form.String())\n \t\t\tif action != \"\" {\n \t\t\t\tp.form.Attr = []Attribute{{Key: \"action\", Val: action}}\n \t\t\t}\n-\t\t\tp.addElement(\"hr\", nil)\n-\t\t\tp.oe.pop()\n-\t\t\tp.addElement(\"label\", nil)\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Label, a.Label.String())\n \t\t\tp.addText(prompt)\n-\t\t\tp.addElement(\"input\", attr)\n-\t\t\tp.oe.pop()\n-\t\t\tp.oe.pop()\n-\t\t\tp.addElement(\"hr\", nil)\n-\t\t\tp.oe.pop()\n+\t\t\tp.addChild(&Node{\n+\t\t\t\tType:     ElementNode,\n+\t\t\t\tDataAtom: a.Input,\n+\t\t\t\tData:     a.Input.String(),\n+\t\t\t\tAttr:     attr,\n+\t\t\t})\n \t\t\tp.oe.pop()\n-\t\t\tp.form = nil\n-\t\tcase \"xmp\":\n-\t\t\tp.popUntil(buttonScope, \"p\")\n+\t\t\tp.parseImpliedToken(EndTagToken, a.Label, a.Label.String())\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())\n+\t\t\tp.parseImpliedToken(EndTagToken, a.Form, a.Form.String())\n+\t\tcase a.Textarea:\n+\t\t\tp.addElement()\n+\t\t\tp.setOriginalIM()\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = textIM\n+\t\tcase a.Xmp:\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.framesetOK = false\n+\t\t\tp.addElement()\n+\t\t\tp.setOriginalIM()\n+\t\t\tp.im = textIM\n+\t\tcase a.Iframe:\n+\t\t\tp.framesetOK = false\n+\t\t\tp.addElement()\n+\t\t\tp.setOriginalIM()\n+\t\t\tp.im = textIM\n+\t\tcase a.Noembed, a.Noscript:\n+\t\t\tp.addElement()\n+\t\t\tp.setOriginalIM()\n+\t\t\tp.im = textIM\n+\t\tcase a.Select:\n \t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement()\n \t\t\tp.framesetOK = false\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"math\", \"svg\":\n+\t\t\tp.im = inSelectIM\n+\t\t\treturn true\n+\t\tcase a.Optgroup, a.Option:\n+\t\t\tif p.top().DataAtom == a.Option {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tif p.tok.Data == \"math\" {\n-\t\t\t\t// TODO: adjust MathML attributes.\n+\t\t\tp.addElement()\n+\t\tcase a.Rp, a.Rt:\n+\t\t\tif p.elementInScope(defaultScope, a.Ruby) {\n+\t\t\t\tp.generateImpliedEndTags()\n+\t\t\t}\n+\t\t\tp.addElement()\n+\t\tcase a.Math, a.Svg:\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tif p.tok.DataAtom == a.Math {\n+\t\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n \t\t\t} else {\n-\t\t\t\t// TODO: adjust SVG attributes.\n+\t\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n \t\t\t}\n \t\t\tadjustForeignAttributes(p.tok.Attr)\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.top().Namespace = p.tok.Data\n+\t\t\tif p.hasSelfClosingToken {\n+\t\t\t\tp.oe.pop()\n+\t\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t\t}\n \t\t\treturn true\n-\t\tcase \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n+\t\tcase a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n \t\t\t// Ignore the token.\n \t\tdefault:\n-\t\t\t// TODO.\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement()\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"body\":\n-\t\t\t// TODO: autoclose the stack of open elements.\n-\t\t\tp.im = afterBodyIM\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Body:\n+\t\t\tif p.elementInScope(defaultScope, a.Body) {\n+\t\t\t\tp.im = afterBodyIM\n+\t\t\t}\n+\t\tcase a.Html:\n+\t\t\tif p.elementInScope(defaultScope, a.Body) {\n+\t\t\t\tp.parseImpliedToken(EndTagToken, a.Body, a.Body.String())\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn true\n-\t\tcase \"p\":\n-\t\t\tif !p.elementInScope(buttonScope, \"p\") {\n-\t\t\t\tp.addElement(\"p\", nil)\n-\t\t\t}\n-\t\t\tp.popUntil(buttonScope, \"p\")\n-\t\tcase \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\":\n-\t\t\tp.inBodyEndTagFormatting(p.tok.Data)\n-\t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\":\n-\t\t\tp.popUntil(defaultScope, p.tok.Data)\n-\t\tcase \"applet\", \"marquee\", \"object\":\n-\t\t\tif p.popUntil(defaultScope, p.tok.Data) {\n+\t\tcase a.Address, a.Article, a.Aside, a.Blockquote, a.Button, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Listing, a.Menu, a.Nav, a.Ol, a.Pre, a.Section, a.Summary, a.Ul:\n+\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n+\t\tcase a.Form:\n+\t\t\tnode := p.form\n+\t\t\tp.form = nil\n+\t\t\ti := p.indexOfElementInScope(defaultScope, a.Form)\n+\t\t\tif node == nil || i == -1 || p.oe[i] != node {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tp.generateImpliedEndTags()\n+\t\t\tp.oe.remove(node)\n+\t\tcase a.P:\n+\t\t\tif !p.elementInScope(buttonScope, a.P) {\n+\t\t\t\tp.parseImpliedToken(StartTagToken, a.P, a.P.String())\n+\t\t\t}\n+\t\t\tp.popUntil(buttonScope, a.P)\n+\t\tcase a.Li:\n+\t\t\tp.popUntil(listItemScope, a.Li)\n+\t\tcase a.Dd, a.Dt:\n+\t\t\tp.popUntil(defaultScope, p.tok.DataAtom)\n+\t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n+\t\t\tp.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)\n+\t\tcase a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n+\t\t\tp.inBodyEndTagFormatting(p.tok.DataAtom)\n+\t\tcase a.Applet, a.Marquee, a.Object:\n+\t\t\tif p.popUntil(defaultScope, p.tok.DataAtom) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t}\n-\t\tcase \"br\":\n+\t\tcase a.Br:\n \t\t\tp.tok.Type = StartTagToken\n \t\t\treturn false\n \t\tdefault:\n-\t\t\tp.inBodyEndTagOther(p.tok.Data)\n+\t\t\tp.inBodyEndTagOther(p.tok.DataAtom)\n \t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n@@ -912,7 +1034,7 @@ func inBodyIM(p *parser) bool {\n \treturn true\n }\n \n-func (p *parser) inBodyEndTagFormatting(tag string) {\n+func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {\n \t// This is the \"adoption agency\" algorithm, described at\n \t// http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#adoptionAgency\n \n@@ -928,21 +1050,21 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t\tif p.afe[j].Type == scopeMarkerNode {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif p.afe[j].Data == tag {\n+\t\t\tif p.afe[j].DataAtom == tagAtom {\n \t\t\t\tformattingElement = p.afe[j]\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t\tif formattingElement == nil {\n-\t\t\tp.inBodyEndTagOther(tag)\n+\t\t\tp.inBodyEndTagOther(tagAtom)\n \t\t\treturn\n \t\t}\n \t\tfeIndex := p.oe.index(formattingElement)\n \t\tif feIndex == -1 {\n \t\t\tp.afe.remove(formattingElement)\n \t\t\treturn\n \t\t}\n-\t\tif !p.elementInScope(defaultScope, tag) {\n+\t\tif !p.elementInScope(defaultScope, tagAtom) {\n \t\t\t// Ignore the tag.\n \t\t\treturn\n \t\t}\n@@ -997,30 +1119,30 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t\t}\n \t\t\t// Step 9.9.\n \t\t\tif lastNode.Parent != nil {\n-\t\t\t\tlastNode.Parent.Remove(lastNode)\n+\t\t\t\tlastNode.Parent.RemoveChild(lastNode)\n \t\t\t}\n-\t\t\tnode.Add(lastNode)\n+\t\t\tnode.AppendChild(lastNode)\n \t\t\t// Step 9.10.\n \t\t\tlastNode = node\n \t\t}\n \n \t\t// Step 10. Reparent lastNode to the common ancestor,\n \t\t// or for misnested table nodes, to the foster parent.\n \t\tif lastNode.Parent != nil {\n-\t\t\tlastNode.Parent.Remove(lastNode)\n+\t\t\tlastNode.Parent.RemoveChild(lastNode)\n \t\t}\n-\t\tswitch commonAncestor.Data {\n-\t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n+\t\tswitch commonAncestor.DataAtom {\n+\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n \t\t\tp.fosterParent(lastNode)\n \t\tdefault:\n-\t\t\tcommonAncestor.Add(lastNode)\n+\t\t\tcommonAncestor.AppendChild(lastNode)\n \t\t}\n \n \t\t// Steps 11-13. Reparent nodes from the furthest block's children\n \t\t// to a clone of the formatting element.\n \t\tclone := formattingElement.clone()\n \t\treparentChildren(clone, furthestBlock)\n-\t\tfurthestBlock.Add(clone)\n+\t\tfurthestBlock.AppendChild(clone)\n \n \t\t// Step 14. Fix up the list of active formatting elements.\n \t\tif oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {\n@@ -1037,9 +1159,9 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n }\n \n // inBodyEndTagOther performs the \"any other end tag\" algorithm for inBodyIM.\n-func (p *parser) inBodyEndTagOther(tag string) {\n+func (p *parser) inBodyEndTagOther(tagAtom a.Atom) {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\tif p.oe[i].Data == tag {\n+\t\tif p.oe[i].DataAtom == tagAtom {\n \t\t\tp.oe = p.oe[:i]\n \t\t\tbreak\n \t\t}\n@@ -1055,7 +1177,20 @@ func textIM(p *parser) bool {\n \tcase ErrorToken:\n \t\tp.oe.pop()\n \tcase TextToken:\n-\t\tp.addText(p.tok.Data)\n+\t\td := p.tok.Data\n+\t\tif n := p.oe.top(); n.DataAtom == a.Textarea && n.FirstChild == nil {\n+\t\t\t// Ignore a newline at the start of a <textarea> block.\n+\t\t\tif d != \"\" && d[0] == '\\r' {\n+\t\t\t\td = d[1:]\n+\t\t\t}\n+\t\t\tif d != \"\" && d[0] == '\\n' {\n+\t\t\t\td = d[1:]\n+\t\t\t}\n+\t\t}\n+\t\tif d == \"\" {\n+\t\t\treturn true\n+\t\t}\n+\t\tp.addText(d)\n \t\treturn true\n \tcase EndTagToken:\n \t\tp.oe.pop()\n@@ -1072,66 +1207,85 @@ func inTableIM(p *parser) bool {\n \t\t// Stop parsing.\n \t\treturn true\n \tcase TextToken:\n-\t\t// TODO.\n+\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\", -1)\n+\t\tswitch p.oe.top().DataAtom {\n+\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n+\t\t\tif strings.Trim(p.tok.Data, whitespace) == \"\" {\n+\t\t\t\tp.addText(p.tok.Data)\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"caption\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Caption:\n \t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.afe = append(p.afe, &scopeMarker)\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.im = inCaptionIM\n \t\t\treturn true\n-\t\tcase \"tbody\", \"tfoot\", \"thead\":\n+\t\tcase a.Colgroup:\n \t\t\tp.clearStackToContext(tableScope)\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.im = inTableBodyIM\n+\t\t\tp.addElement()\n+\t\t\tp.im = inColumnGroupIM\n \t\t\treturn true\n-\t\tcase \"td\", \"th\", \"tr\":\n+\t\tcase a.Col:\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Colgroup, a.Colgroup.String())\n+\t\t\treturn false\n+\t\tcase a.Tbody, a.Tfoot, a.Thead:\n \t\t\tp.clearStackToContext(tableScope)\n-\t\t\tp.addElement(\"tbody\", nil)\n+\t\t\tp.addElement()\n \t\t\tp.im = inTableBodyIM\n+\t\t\treturn true\n+\t\tcase a.Td, a.Th, a.Tr:\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Tbody, a.Tbody.String())\n \t\t\treturn false\n-\t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScope, \"table\") {\n+\t\tcase a.Table:\n+\t\t\tif p.popUntil(tableScope, a.Table) {\n \t\t\t\tp.resetInsertionMode()\n \t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tcase \"colgroup\":\n-\t\t\tp.clearStackToContext(tableScope)\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.im = inColumnGroupIM\n-\t\t\treturn true\n-\t\tcase \"col\":\n-\t\t\tp.clearStackToContext(tableScope)\n-\t\t\tp.addElement(\"colgroup\", p.tok.Attr)\n-\t\t\tp.im = inColumnGroupIM\n-\t\t\treturn false\n-\t\tcase \"select\":\n+\t\tcase a.Style, a.Script:\n+\t\t\treturn inHeadIM(p)\n+\t\tcase a.Input:\n+\t\t\tfor _, t := range p.tok.Attr {\n+\t\t\t\tif t.Key == \"type\" && strings.ToLower(t.Val) == \"hidden\" {\n+\t\t\t\t\tp.addElement()\n+\t\t\t\t\tp.oe.pop()\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// Otherwise drop down to the default action.\n+\t\tcase a.Form:\n+\t\t\tif p.form != nil {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tp.addElement()\n+\t\t\tp.form = p.oe.pop()\n+\t\tcase a.Select:\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tswitch p.top().Data {\n-\t\t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n+\t\t\tswitch p.top().DataAtom {\n+\t\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n \t\t\t\tp.fosterParenting = true\n \t\t\t}\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.fosterParenting = false\n \t\t\tp.framesetOK = false\n \t\t\tp.im = inSelectInTableIM\n \t\t\treturn true\n-\t\tdefault:\n-\t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScope, \"table\") {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Table:\n+\t\t\tif p.popUntil(tableScope, a.Table) {\n \t\t\t\tp.resetInsertionMode()\n \t\t\t\treturn true\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n+\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\t}\n@@ -1141,13 +1295,13 @@ func inTableIM(p *parser) bool {\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \t}\n \n-\tswitch p.top().Data {\n-\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n-\t\tp.fosterParenting = true\n-\t\tdefer func() { p.fosterParenting = false }()\n-\t}\n+\tp.fosterParenting = true\n+\tdefer func() { p.fosterParenting = false }()\n \n \treturn inBodyIM(p)\n }\n@@ -1156,41 +1310,41 @@ func inTableIM(p *parser) bool {\n func inCaptionIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\tif p.popUntil(tableScope, \"caption\") {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Thead, a.Tr:\n+\t\t\tif p.popUntil(tableScope, a.Caption) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n \t\t\t} else {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n-\t\tcase \"select\":\n+\t\tcase a.Select:\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.framesetOK = false\n \t\t\tp.im = inSelectInTableIM\n \t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"caption\":\n-\t\t\tif p.popUntil(tableScope, \"caption\") {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Caption:\n+\t\t\tif p.popUntil(tableScope, a.Caption) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t}\n \t\t\treturn true\n-\t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScope, \"caption\") {\n+\t\tcase a.Table:\n+\t\t\tif p.popUntil(tableScope, a.Caption) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n \t\t\t} else {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n-\t\tcase \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n+\t\tcase a.Body, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\t}\n@@ -1201,6 +1355,16 @@ func inCaptionIM(p *parser) bool {\n // Section 12.2.5.4.12.\n func inColumnGroupIM(p *parser) bool {\n \tswitch p.tok.Type {\n+\tcase TextToken:\n+\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(s) < len(p.tok.Data) {\n+\t\t\t// Add the initial whitespace to the current node.\n+\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n+\t\t\tif s == \"\" {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tp.tok.Data = s\n+\t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n@@ -1211,29 +1375,29 @@ func inColumnGroupIM(p *parser) bool {\n \t\t// Ignore the token.\n \t\treturn true\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tcase \"col\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase a.Col:\n+\t\t\tp.addElement()\n \t\t\tp.oe.pop()\n \t\t\tp.acknowledgeSelfClosingTag()\n \t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"colgroup\":\n-\t\t\tif p.oe.top().Data != \"html\" {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Colgroup:\n+\t\t\tif p.oe.top().DataAtom != a.Html {\n \t\t\t\tp.oe.pop()\n \t\t\t\tp.im = inTableIM\n \t\t\t}\n \t\t\treturn true\n-\t\tcase \"col\":\n+\t\tcase a.Col:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\t}\n \t}\n-\tif p.oe.top().Data != \"html\" {\n+\tif p.oe.top().DataAtom != a.Html {\n \t\tp.oe.pop()\n \t\tp.im = inTableIM\n \t\treturn false\n@@ -1243,48 +1407,42 @@ func inColumnGroupIM(p *parser) bool {\n \n // Section 12.2.5.4.13.\n func inTableBodyIM(p *parser) bool {\n-\tvar (\n-\t\tadd      bool\n-\t\tdata     string\n-\t\tattr     []Attribute\n-\t\tconsumed bool\n-\t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\t// TODO.\n-\tcase TextToken:\n-\t\t// TODO.\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"tr\":\n-\t\t\tadd = true\n-\t\t\tdata = p.tok.Data\n-\t\t\tattr = p.tok.Attr\n-\t\t\tconsumed = true\n-\t\tcase \"td\", \"th\":\n-\t\t\tadd = true\n-\t\t\tdata = \"tr\"\n-\t\t\tconsumed = false\n-\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\":\n-\t\t\tif !p.popUntil(tableScope, \"tbody\", \"thead\", \"tfoot\") {\n-\t\t\t\t// Ignore the token.\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t\tp.im = inTableIM\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Tr:\n+\t\t\tp.clearStackToContext(tableBodyScope)\n+\t\t\tp.addElement()\n+\t\t\tp.im = inRowIM\n+\t\t\treturn true\n+\t\tcase a.Td, a.Th:\n+\t\t\tp.parseImpliedToken(StartTagToken, a.Tr, a.Tr.String())\n \t\t\treturn false\n-\t\tdefault:\n-\t\t\t// TODO.\n+\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:\n+\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n+\t\t\t\tp.im = inTableIM\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScope, \"tbody\", \"thead\", \"tfoot\") {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Tbody, a.Tfoot, a.Thead:\n+\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n+\t\t\t\tp.clearStackToContext(tableBodyScope)\n+\t\t\t\tp.oe.pop()\n+\t\t\t\tp.im = inTableIM\n+\t\t\t}\n+\t\t\treturn true\n+\t\tcase a.Table:\n+\t\t\tif p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\":\n+\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th, a.Tr:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\t}\n@@ -1295,117 +1453,102 @@ func inTableBodyIM(p *parser) bool {\n \t\t})\n \t\treturn true\n \t}\n-\tif add {\n-\t\t// TODO: clear the stack back to a table body context.\n-\t\tp.addElement(data, attr)\n-\t\tp.im = inRowIM\n-\t\treturn consumed\n-\t}\n+\n \treturn inTableIM(p)\n }\n \n // Section 12.2.5.4.14.\n func inRowIM(p *parser) bool {\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\t// TODO.\n-\tcase TextToken:\n-\t\t// TODO.\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"td\", \"th\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Td, a.Th:\n \t\t\tp.clearStackToContext(tableRowScope)\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.afe = append(p.afe, &scopeMarker)\n \t\t\tp.im = inCellIM\n \t\t\treturn true\n-\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\tif p.popUntil(tableScope, \"tr\") {\n+\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n+\t\t\tif p.popUntil(tableScope, a.Tr) {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tdefault:\n-\t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"tr\":\n-\t\t\tif p.popUntil(tableScope, \"tr\") {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Tr:\n+\t\t\tif p.popUntil(tableScope, a.Tr) {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn true\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScope, \"tr\") {\n+\t\tcase a.Table:\n+\t\t\tif p.popUntil(tableScope, a.Tr) {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tcase \"tbody\", \"tfoot\", \"thead\":\n-\t\t\t// TODO.\n-\t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\":\n+\t\tcase a.Tbody, a.Tfoot, a.Thead:\n+\t\t\tif p.elementInScope(tableScope, p.tok.DataAtom) {\n+\t\t\t\tp.parseImpliedToken(EndTagToken, a.Tr, a.Tr.String())\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th:\n \t\t\t// Ignore the token.\n \t\t\treturn true\n-\t\tdefault:\n-\t\t\t// TODO.\n \t\t}\n-\tcase CommentToken:\n-\t\tp.addChild(&Node{\n-\t\t\tType: CommentNode,\n-\t\t\tData: p.tok.Data,\n-\t\t})\n-\t\treturn true\n \t}\n+\n \treturn inTableIM(p)\n }\n \n // Section 12.2.5.4.15.\n func inCellIM(p *parser) bool {\n-\tvar (\n-\t\tcloseTheCellAndReprocess bool\n-\t)\n \tswitch p.tok.Type {\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n-\t\t\t// TODO: check for \"td\" or \"th\" in table scope.\n-\t\t\tcloseTheCellAndReprocess = true\n-\t\tcase \"select\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:\n+\t\t\tif p.popUntil(tableScope, a.Td, a.Th) {\n+\t\t\t\t// Close the cell and reprocess.\n+\t\t\t\tp.clearActiveFormattingElements()\n+\t\t\t\tp.im = inRowIM\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\tcase a.Select:\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.addElement()\n \t\t\tp.framesetOK = false\n \t\t\tp.im = inSelectInTableIM\n \t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"td\", \"th\":\n-\t\t\tif !p.popUntil(tableScope, p.tok.Data) {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Td, a.Th:\n+\t\t\tif !p.popUntil(tableScope, p.tok.DataAtom) {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n \t\t\tp.clearActiveFormattingElements()\n \t\t\tp.im = inRowIM\n \t\t\treturn true\n-\t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\":\n-\t\t\t// TODO.\n-\t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\t// TODO: check for matching element in table scope.\n-\t\t\tcloseTheCellAndReprocess = true\n-\t\t}\n-\tcase CommentToken:\n-\t\tp.addChild(&Node{\n-\t\t\tType: CommentNode,\n-\t\t\tData: p.tok.Data,\n-\t\t})\n-\t\treturn true\n-\t}\n-\tif closeTheCellAndReprocess {\n-\t\tif p.popUntil(tableScope, \"td\") || p.popUntil(tableScope, \"th\") {\n+\t\tcase a.Body, a.Caption, a.Col, a.Colgroup, a.Html:\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\tcase a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:\n+\t\t\tif !p.elementInScope(tableScope, p.tok.DataAtom) {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\t// Close the cell and reprocess.\n+\t\t\tp.popUntil(tableScope, a.Td, a.Th)\n \t\t\tp.clearActiveFormattingElements()\n \t\t\tp.im = inRowIM\n \t\t\treturn false\n@@ -1416,77 +1559,84 @@ func inCellIM(p *parser) bool {\n \n // Section 12.2.5.4.16.\n func inSelectIM(p *parser) bool {\n-\tendSelect := false\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n-\t\t// TODO.\n+\t\t// Stop parsing.\n+\t\treturn true\n \tcase TextToken:\n-\t\tp.addText(p.tok.Data)\n+\t\tp.addText(strings.Replace(p.tok.Data, \"\\x00\", \"\", -1))\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n-\t\t\t// TODO.\n-\t\tcase \"option\":\n-\t\t\tif p.top().Data == \"option\" {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n+\t\t\treturn inBodyIM(p)\n+\t\tcase a.Option:\n+\t\t\tif p.top().DataAtom == a.Option {\n \t\t\t\tp.oe.pop()\n \t\t\t}\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"optgroup\":\n-\t\t\tif p.top().Data == \"option\" {\n+\t\t\tp.addElement()\n+\t\tcase a.Optgroup:\n+\t\t\tif p.top().DataAtom == a.Option {\n \t\t\t\tp.oe.pop()\n \t\t\t}\n-\t\t\tif p.top().Data == \"optgroup\" {\n+\t\t\tif p.top().DataAtom == a.Optgroup {\n \t\t\t\tp.oe.pop()\n \t\t\t}\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"select\":\n-\t\t\tendSelect = true\n-\t\tcase \"input\", \"keygen\", \"textarea\":\n-\t\t\t// TODO.\n-\t\tcase \"script\":\n-\t\t\t// TODO.\n-\t\tdefault:\n+\t\t\tp.addElement()\n+\t\tcase a.Select:\n+\t\t\tp.tok.Type = EndTagToken\n+\t\t\treturn false\n+\t\tcase a.Input, a.Keygen, a.Textarea:\n+\t\t\tif p.elementInScope(selectScope, a.Select) {\n+\t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// In order to properly ignore <textarea>, we need to change the tokenizer mode.\n+\t\t\tp.tokenizer.NextIsNotRawText()\n \t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\tcase a.Script:\n+\t\t\treturn inHeadIM(p)\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"option\":\n-\t\t\tif p.top().Data == \"option\" {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Option:\n+\t\t\tif p.top().DataAtom == a.Option {\n \t\t\t\tp.oe.pop()\n \t\t\t}\n-\t\tcase \"optgroup\":\n+\t\tcase a.Optgroup:\n \t\t\ti := len(p.oe) - 1\n-\t\t\tif p.oe[i].Data == \"option\" {\n+\t\t\tif p.oe[i].DataAtom == a.Option {\n \t\t\t\ti--\n \t\t\t}\n-\t\t\tif p.oe[i].Data == \"optgroup\" {\n+\t\t\tif p.oe[i].DataAtom == a.Optgroup {\n \t\t\t\tp.oe = p.oe[:i]\n \t\t\t}\n-\t\tcase \"select\":\n-\t\t\tendSelect = true\n-\t\tdefault:\n-\t\t\t// Ignore the token.\n+\t\tcase a.Select:\n+\t\t\tif p.popUntil(selectScope, a.Select) {\n+\t\t\t\tp.resetInsertionMode()\n+\t\t\t}\n \t\t}\n \tcase CommentToken:\n-\t\tp.doc.Add(&Node{\n+\t\tp.doc.AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n \t}\n-\tif endSelect {\n-\t\tp.endSelect()\n-\t}\n+\n \treturn true\n }\n \n // Section 12.2.5.4.17.\n func inSelectInTableIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase StartTagToken, EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\":\n-\t\t\tif p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.Data) {\n-\t\t\t\tp.endSelect()\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:\n+\t\t\tif p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {\n+\t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n \t\t\t\treturn false\n \t\t\t} else {\n \t\t\t\t// Ignore the token.\n@@ -1497,40 +1647,35 @@ func inSelectInTableIM(p *parser) bool {\n \treturn inSelectIM(p)\n }\n \n-func (p *parser) endSelect() {\n-\tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\tswitch p.oe[i].Data {\n-\t\tcase \"option\", \"optgroup\":\n-\t\t\tcontinue\n-\t\tcase \"select\":\n-\t\t\tp.oe = p.oe[:i]\n-\t\t\tp.resetInsertionMode()\n-\t\t}\n-\t\treturn\n-\t}\n-}\n-\n // Section 12.2.5.4.18.\n func afterBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\t// Stop parsing.\n \t\treturn true\n+\tcase TextToken:\n+\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(s) == 0 {\n+\t\t\t// It was all whitespace.\n+\t\t\treturn inBodyIM(p)\n+\t\t}\n \tcase StartTagToken:\n-\t\tif p.tok.Data == \"html\" {\n+\t\tif p.tok.DataAtom == a.Html {\n \t\t\treturn inBodyIM(p)\n \t\t}\n \tcase EndTagToken:\n-\t\tif p.tok.Data == \"html\" {\n-\t\t\tp.im = afterAfterBodyIM\n+\t\tif p.tok.DataAtom == a.Html {\n+\t\t\tif !p.fragment {\n+\t\t\t\tp.im = afterAfterBodyIM\n+\t\t\t}\n \t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\t// The comment is attached to the <html> element.\n-\t\tif len(p.oe) < 1 || p.oe[0].Data != \"html\" {\n+\t\tif len(p.oe) < 1 || p.oe[0].DataAtom != a.Html {\n \t\t\tpanic(\"html: bad parser state: <html> element not found, in the after-body insertion mode\")\n \t\t}\n-\t\tp.oe[0].Add(&Node{\n+\t\tp.oe[0].AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n@@ -1561,24 +1706,24 @@ func inFramesetIM(p *parser) bool {\n \t\t\tp.addText(s)\n \t\t}\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tcase \"frameset\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\tcase \"frame\":\n-\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase a.Frameset:\n+\t\t\tp.addElement()\n+\t\tcase a.Frame:\n+\t\t\tp.addElement()\n \t\t\tp.oe.pop()\n \t\t\tp.acknowledgeSelfClosingTag()\n-\t\tcase \"noframes\":\n+\t\tcase a.Noframes:\n \t\t\treturn inHeadIM(p)\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"frameset\":\n-\t\t\tif p.oe.top().Data != \"html\" {\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Frameset:\n+\t\t\tif p.oe.top().DataAtom != a.Html {\n \t\t\t\tp.oe.pop()\n-\t\t\t\tif p.oe.top().Data != \"frameset\" {\n+\t\t\t\tif p.oe.top().DataAtom != a.Frameset {\n \t\t\t\t\tp.im = afterFramesetIM\n \t\t\t\t\treturn true\n \t\t\t\t}\n@@ -1611,15 +1756,15 @@ func afterFramesetIM(p *parser) bool {\n \t\t\tp.addText(s)\n \t\t}\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tcase \"noframes\":\n+\t\tcase a.Noframes:\n \t\t\treturn inHeadIM(p)\n \t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\tp.im = afterAfterFramesetIM\n \t\t\treturn true\n \t\t}\n@@ -1636,17 +1781,23 @@ func afterAfterBodyIM(p *parser) bool {\n \t\t// Stop parsing.\n \t\treturn true\n \tcase TextToken:\n-\t\t// TODO.\n+\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(s) == 0 {\n+\t\t\t// It was all whitespace.\n+\t\t\treturn inBodyIM(p)\n+\t\t}\n \tcase StartTagToken:\n-\t\tif p.tok.Data == \"html\" {\n+\t\tif p.tok.DataAtom == a.Html {\n \t\t\treturn inBodyIM(p)\n \t\t}\n \tcase CommentToken:\n-\t\tp.doc.Add(&Node{\n+\t\tp.doc.AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n+\tcase DoctypeToken:\n+\t\treturn inBodyIM(p)\n \t}\n \tp.im = inBodyIM\n \treturn false\n@@ -1656,7 +1807,7 @@ func afterAfterBodyIM(p *parser) bool {\n func afterAfterFramesetIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase CommentToken:\n-\t\tp.addChild(&Node{\n+\t\tp.doc.AppendChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n@@ -1670,51 +1821,56 @@ func afterAfterFramesetIM(p *parser) bool {\n \t\t\treturn -1\n \t\t}, p.tok.Data)\n \t\tif s != \"\" {\n-\t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tp.addText(s)\n+\t\t\tp.tok.Data = s\n+\t\t\treturn inBodyIM(p)\n \t\t}\n \tcase StartTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n+\t\tswitch p.tok.DataAtom {\n+\t\tcase a.Html:\n \t\t\treturn inBodyIM(p)\n-\t\tcase \"noframes\":\n+\t\tcase a.Noframes:\n \t\t\treturn inHeadIM(p)\n \t\t}\n+\tcase DoctypeToken:\n+\t\treturn inBodyIM(p)\n \tdefault:\n \t\t// Ignore the token.\n \t}\n \treturn true\n }\n \n+const whitespaceOrNUL = whitespace + \"\\x00\"\n+\n // Section 12.2.5.5.\n func parseForeignContent(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase TextToken:\n-\t\t// TODO: HTML integration points.\n-\t\tif p.top().Namespace == \"\" {\n-\t\t\tinBodyIM(p)\n-\t\t\tp.resetInsertionMode()\n-\t\t\treturn true\n-\t\t}\n \t\tif p.framesetOK {\n-\t\t\tp.framesetOK = strings.TrimLeft(p.tok.Data, whitespace) == \"\"\n+\t\t\tp.framesetOK = strings.TrimLeft(p.tok.Data, whitespaceOrNUL) == \"\"\n \t\t}\n+\t\tp.tok.Data = strings.Replace(p.tok.Data, \"\\x00\", \"\\ufffd\", -1)\n \t\tp.addText(p.tok.Data)\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \tcase StartTagToken:\n-\t\tif htmlIntegrationPoint(p.top()) {\n-\t\t\tinBodyIM(p)\n-\t\t\tp.resetInsertionMode()\n-\t\t\treturn true\n+\t\tb := breakout[p.tok.Data]\n+\t\tif p.tok.DataAtom == a.Font {\n+\t\tloop:\n+\t\t\tfor _, attr := range p.tok.Attr {\n+\t\t\t\tswitch attr.Key {\n+\t\t\t\tcase \"color\", \"face\", \"size\":\n+\t\t\t\t\tb = true\n+\t\t\t\t\tbreak loop\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tif breakout[p.tok.Data] {\n+\t\tif b {\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\t\t\t// TODO: MathML integration points.\n-\t\t\t\tif p.oe[i].Namespace == \"\" || htmlIntegrationPoint(p.oe[i]) {\n+\t\t\t\tn := p.oe[i]\n+\t\t\t\tif n.Namespace == \"\" || htmlIntegrationPoint(n) || mathMLTextIntegrationPoint(n) {\n \t\t\t\t\tp.oe = p.oe[:i+1]\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -1723,21 +1879,31 @@ func parseForeignContent(p *parser) bool {\n \t\t}\n \t\tswitch p.top().Namespace {\n \t\tcase \"math\":\n-\t\t\t// TODO: adjust MathML attributes.\n+\t\t\tadjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)\n \t\tcase \"svg\":\n \t\t\t// Adjust SVG tag names. The tokenizer lower-cases tag names, but\n \t\t\t// SVG wants e.g. \"foreignObject\" with a capital second \"O\".\n \t\t\tif x := svgTagNameAdjustments[p.tok.Data]; x != \"\" {\n+\t\t\t\tp.tok.DataAtom = a.Lookup([]byte(x))\n \t\t\t\tp.tok.Data = x\n \t\t\t}\n-\t\t\t// TODO: adjust SVG attributes.\n+\t\t\tadjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)\n \t\tdefault:\n \t\t\tpanic(\"html: bad parser state: unexpected namespace\")\n \t\t}\n \t\tadjustForeignAttributes(p.tok.Attr)\n \t\tnamespace := p.top().Namespace\n-\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tp.addElement()\n \t\tp.top().Namespace = namespace\n+\t\tif namespace != \"\" {\n+\t\t\t// Don't let the tokenizer go into raw text mode in foreign content\n+\t\t\t// (e.g. in an SVG <title> tag).\n+\t\t\tp.tokenizer.NextIsNotRawText()\n+\t\t}\n+\t\tif p.hasSelfClosingToken {\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t}\n \tcase EndTagToken:\n \t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\t\tif p.oe[i].Namespace == \"\" {\n@@ -1764,34 +1930,80 @@ func (p *parser) inForeignContent() bool {\n \tif n.Namespace == \"\" {\n \t\treturn false\n \t}\n-\t// TODO: MathML, HTML integration points.\n-\t// TODO: MathML's annotation-xml combining with SVG's svg.\n+\tif mathMLTextIntegrationPoint(n) {\n+\t\tif p.tok.Type == StartTagToken && p.tok.DataAtom != a.Mglyph && p.tok.DataAtom != a.Malignmark {\n+\t\t\treturn false\n+\t\t}\n+\t\tif p.tok.Type == TextToken {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\tif n.Namespace == \"math\" && n.DataAtom == a.AnnotationXml && p.tok.Type == StartTagToken && p.tok.DataAtom == a.Svg {\n+\t\treturn false\n+\t}\n+\tif htmlIntegrationPoint(n) && (p.tok.Type == StartTagToken || p.tok.Type == TextToken) {\n+\t\treturn false\n+\t}\n+\tif p.tok.Type == ErrorToken {\n+\t\treturn false\n+\t}\n \treturn true\n }\n \n-func (p *parser) parse() error {\n-\t// Iterate until EOF. Any other error will cause an early return.\n-\tconsumed := true\n-\tfor {\n-\t\tif consumed {\n-\t\t\tif err := p.read(); err != nil {\n-\t\t\t\tif err == io.EOF {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n+// parseImpliedToken parses a token as though it had appeared in the parser's\n+// input.\n+func (p *parser) parseImpliedToken(t TokenType, dataAtom a.Atom, data string) {\n+\trealToken, selfClosing := p.tok, p.hasSelfClosingToken\n+\tp.tok = Token{\n+\t\tType:     t,\n+\t\tDataAtom: dataAtom,\n+\t\tData:     data,\n+\t}\n+\tp.hasSelfClosingToken = false\n+\tp.parseCurrentToken()\n+\tp.tok, p.hasSelfClosingToken = realToken, selfClosing\n+}\n+\n+// parseCurrentToken runs the current token through the parsing routines\n+// until it is consumed.\n+func (p *parser) parseCurrentToken() {\n+\tif p.tok.Type == SelfClosingTagToken {\n+\t\tp.hasSelfClosingToken = true\n+\t\tp.tok.Type = StartTagToken\n+\t}\n+\n+\tconsumed := false\n+\tfor !consumed {\n \t\tif p.inForeignContent() {\n \t\t\tconsumed = parseForeignContent(p)\n \t\t} else {\n \t\t\tconsumed = p.im(p)\n \t\t}\n \t}\n-\t// Loop until the final token (the ErrorToken signifying EOF) is consumed.\n-\tfor {\n-\t\tif consumed = p.im(p); consumed {\n-\t\t\tbreak\n+\n+\tif p.hasSelfClosingToken {\n+\t\t// This is a parse error, but ignore it.\n+\t\tp.hasSelfClosingToken = false\n+\t}\n+}\n+\n+func (p *parser) parse() error {\n+\t// Iterate until EOF. Any other error will cause an early return.\n+\tvar err error\n+\tfor err != io.EOF {\n+\t\t// CDATA sections are allowed only in foreign content.\n+\t\tn := p.oe.top()\n+\t\tp.tokenizer.AllowCDATA(n != nil && n.Namespace != \"\")\n+\t\t// Read and parse the next token.\n+\t\tp.tokenizer.Next()\n+\t\tp.tok = p.tokenizer.Token()\n+\t\tif p.tok.Type == ErrorToken {\n+\t\t\terr = p.tokenizer.Err()\n+\t\t\tif err != nil && err != io.EOF {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n+\t\tp.parseCurrentToken()\n \t}\n \treturn nil\n }\n@@ -1819,32 +2031,40 @@ func Parse(r io.Reader) (*Node, error) {\n // found. If the fragment is the InnerHTML for an existing element, pass that\n // element in context.\n func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {\n+\tcontextTag := \"\"\n+\tif context != nil {\n+\t\tif context.Type != ElementNode {\n+\t\t\treturn nil, errors.New(\"html: ParseFragment of non-element Node\")\n+\t\t}\n+\t\t// The next check isn't just context.DataAtom.String() == context.Data because\n+\t\t// it is valid to pass an element whose tag isn't a known atom. For example,\n+\t\t// DataAtom == 0 and Data = \"tagfromthefuture\" is perfectly consistent.\n+\t\tif context.DataAtom != a.Lookup([]byte(context.Data)) {\n+\t\t\treturn nil, fmt.Errorf(\"html: inconsistent Node: DataAtom=%q, Data=%q\", context.DataAtom, context.Data)\n+\t\t}\n+\t\tcontextTag = context.DataAtom.String()\n+\t}\n \tp := &parser{\n-\t\ttokenizer: NewTokenizer(r),\n+\t\ttokenizer: NewTokenizerFragment(r, contextTag),\n \t\tdoc: &Node{\n \t\t\tType: DocumentNode,\n \t\t},\n \t\tscripting: true,\n+\t\tfragment:  true,\n \t\tcontext:   context,\n \t}\n \n-\tif context != nil {\n-\t\tswitch context.Data {\n-\t\tcase \"iframe\", \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"title\", \"textarea\", \"xmp\":\n-\t\t\tp.tokenizer.rawTag = context.Data\n-\t\t}\n-\t}\n-\n \troot := &Node{\n-\t\tType: ElementNode,\n-\t\tData: \"html\",\n+\t\tType:     ElementNode,\n+\t\tDataAtom: a.Html,\n+\t\tData:     a.Html.String(),\n \t}\n-\tp.doc.Add(root)\n+\tp.doc.AppendChild(root)\n \tp.oe = nodeStack{root}\n \tp.resetInsertionMode()\n \n \tfor n := context; n != nil; n = n.Parent {\n-\t\tif n.Type == ElementNode && n.Data == \"form\" {\n+\t\tif n.Type == ElementNode && n.DataAtom == a.Form {\n \t\t\tp.form = n\n \t\t\tbreak\n \t\t}\n@@ -1860,10 +2080,12 @@ func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {\n \t\tparent = root\n \t}\n \n-\tresult := parent.Child\n-\tparent.Child = nil\n-\tfor _, n := range result {\n-\t\tn.Parent = nil\n+\tvar result []*Node\n+\tfor c := parent.FirstChild; c != nil; {\n+\t\tnext := c.NextSibling\n+\t\tparent.RemoveChild(c)\n+\t\tresult = append(result, c)\n+\t\tc = next\n \t}\n \treturn result, nil\n }"}, {"sha": "7cf2ff4163e43f01b916ef37082247402fcb6d88", "filename": "libgo/go/exp/html/parse_test.go", "status": "modified", "additions": 201, "deletions": 81, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -8,9 +8,14 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"errors\"\n+\t\"exp/html/atom\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sort\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -37,7 +42,10 @@ func readParseTest(r *bufio.Reader) (text, want, context string, err error) {\n \t\t}\n \t\tb = append(b, line...)\n \t}\n-\ttext = strings.TrimRight(string(b), \"\\n\")\n+\ttext = string(b)\n+\tif strings.HasSuffix(text, \"\\n\") {\n+\t\ttext = text[:len(text)-1]\n+\t}\n \tb = b[:0]\n \n \t// Skip the error list.\n@@ -70,12 +78,22 @@ func readParseTest(r *bufio.Reader) (text, want, context string, err error) {\n \tif string(line) != \"#document\\n\" {\n \t\treturn \"\", \"\", \"\", fmt.Errorf(`got %q want \"#document\\n\"`, line)\n \t}\n+\tinQuote := false\n \tfor {\n \t\tline, err = r.ReadSlice('\\n')\n \t\tif err != nil && err != io.EOF {\n \t\t\treturn \"\", \"\", \"\", err\n \t\t}\n-\t\tif len(line) == 0 || len(line) == 1 && line[0] == '\\n' {\n+\t\ttrimmed := bytes.Trim(line, \"| \\n\")\n+\t\tif len(trimmed) > 0 {\n+\t\t\tif line[0] == '|' && trimmed[0] == '\"' {\n+\t\t\t\tinQuote = true\n+\t\t\t}\n+\t\t\tif trimmed[len(trimmed)-1] == '\"' && !(line[0] == '|' && len(trimmed) == 1) {\n+\t\t\t\tinQuote = false\n+\t\t\t}\n+\t\t}\n+\t\tif len(line) == 0 || len(line) == 1 && line[0] == '\\n' && !inQuote {\n \t\t\tbreak\n \t\t}\n \t\tb = append(b, line...)\n@@ -90,6 +108,23 @@ func dumpIndent(w io.Writer, level int) {\n \t}\n }\n \n+type sortedAttributes []Attribute\n+\n+func (a sortedAttributes) Len() int {\n+\treturn len(a)\n+}\n+\n+func (a sortedAttributes) Less(i, j int) bool {\n+\tif a[i].Namespace != a[j].Namespace {\n+\t\treturn a[i].Namespace < a[j].Namespace\n+\t}\n+\treturn a[i].Key < a[j].Key\n+}\n+\n+func (a sortedAttributes) Swap(i, j int) {\n+\ta[i], a[j] = a[j], a[i]\n+}\n+\n func dumpLevel(w io.Writer, n *Node, level int) error {\n \tdumpIndent(w, level)\n \tswitch n.Type {\n@@ -103,13 +138,8 @@ func dumpLevel(w io.Writer, n *Node, level int) error {\n \t\t} else {\n \t\t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n \t\t}\n-\t\tattr := n.Attr\n-\t\tif len(attr) == 2 && attr[0].Namespace == \"xml\" && attr[1].Namespace == \"xlink\" {\n-\t\t\t// Some of the test cases in tests10.dat change the order of adjusted\n-\t\t\t// foreign attributes, but that behavior is not in the spec, and could\n-\t\t\t// simply be an implementation detail of html5lib's python map ordering.\n-\t\t\tattr[0], attr[1] = attr[1], attr[0]\n-\t\t}\n+\t\tattr := sortedAttributes(n.Attr)\n+\t\tsort.Sort(attr)\n \t\tfor _, a := range attr {\n \t\t\tio.WriteString(w, \"\\n\")\n \t\t\tdumpIndent(w, level+1)\n@@ -147,7 +177,7 @@ func dumpLevel(w io.Writer, n *Node, level int) error {\n \t\treturn errors.New(\"unknown node type\")\n \t}\n \tio.WriteString(w, \"\\n\")\n-\tfor _, c := range n.Child {\n+\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n \t\tif err := dumpLevel(w, c, level+1); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -156,106 +186,126 @@ func dumpLevel(w io.Writer, n *Node, level int) error {\n }\n \n func dump(n *Node) (string, error) {\n-\tif n == nil || len(n.Child) == 0 {\n+\tif n == nil || n.FirstChild == nil {\n \t\treturn \"\", nil\n \t}\n \tvar b bytes.Buffer\n-\tfor _, child := range n.Child {\n-\t\tif err := dumpLevel(&b, child, 0); err != nil {\n+\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n+\t\tif err := dumpLevel(&b, c, 0); err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t}\n \treturn b.String(), nil\n }\n \n+const testDataDir = \"testdata/webkit/\"\n+\n func TestParser(t *testing.T) {\n-\ttestFiles := []struct {\n-\t\tfilename string\n-\t\t// n is the number of test cases to run from that file.\n-\t\t// -1 means all test cases.\n-\t\tn int\n-\t}{\n-\t\t// TODO(nigeltao): Process all the test cases from all the .dat files.\n-\t\t{\"adoption01.dat\", -1},\n-\t\t{\"doctype01.dat\", -1},\n-\t\t{\"tests1.dat\", -1},\n-\t\t{\"tests2.dat\", -1},\n-\t\t{\"tests3.dat\", -1},\n-\t\t{\"tests4.dat\", -1},\n-\t\t{\"tests5.dat\", -1},\n-\t\t{\"tests6.dat\", -1},\n-\t\t{\"tests10.dat\", 35},\n+\ttestFiles, err := filepath.Glob(testDataDir + \"*.dat\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n \t}\n \tfor _, tf := range testFiles {\n-\t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)\n+\t\tf, err := os.Open(tf)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tdefer f.Close()\n \t\tr := bufio.NewReader(f)\n-\t\tfor i := 0; i != tf.n; i++ {\n+\n+\t\tfor i := 0; ; i++ {\n \t\t\ttext, want, context, err := readParseTest(r)\n-\t\t\tif err == io.EOF && tf.n == -1 {\n+\t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \n-\t\t\tvar doc *Node\n-\t\t\tif context == \"\" {\n-\t\t\t\tdoc, err = Parse(strings.NewReader(text))\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tcontextNode := &Node{\n-\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\tData: context,\n-\t\t\t\t}\n-\t\t\t\tnodes, err := ParseFragment(strings.NewReader(text), contextNode)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t}\n-\t\t\t\tdoc = &Node{\n-\t\t\t\t\tType: DocumentNode,\n-\t\t\t\t}\n-\t\t\t\tfor _, n := range nodes {\n-\t\t\t\t\tdoc.Add(n)\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\terr = testParseCase(text, want, context)\n \n-\t\t\tgot, err := dump(doc)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\t// Compare the parsed tree to the #document section.\n-\t\t\tif got != want {\n-\t\t\t\tt.Errorf(\"%s test #%d %q, got vs want:\\n----\\n%s----\\n%s----\", tf.filename, i, text, got, want)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif renderTestBlacklist[text] || context != \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// Check that rendering and re-parsing results in an identical tree.\n-\t\t\tpr, pw := io.Pipe()\n-\t\t\tgo func() {\n-\t\t\t\tpw.CloseWithError(Render(pw, doc))\n-\t\t\t}()\n-\t\t\tdoc1, err := Parse(pr)\n \t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tgot1, err := dump(doc1)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n+\t\t\t\tt.Errorf(\"%s test #%d %q, %s\", tf, i, text, err)\n \t\t\t}\n-\t\t\tif got != got1 {\n-\t\t\t\tt.Errorf(\"%s test #%d %q, got vs got1:\\n----\\n%s----\\n%s----\", tf.filename, i, text, got, got1)\n-\t\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+// testParseCase tests one test case from the test files. If the test does not\n+// pass, it returns an error that explains the failure.\n+// text is the HTML to be parsed, want is a dump of the correct parse tree,\n+// and context is the name of the context node, if any.\n+func testParseCase(text, want, context string) (err error) {\n+\tdefer func() {\n+\t\tif x := recover(); x != nil {\n+\t\t\tswitch e := x.(type) {\n+\t\t\tcase error:\n+\t\t\t\terr = e\n+\t\t\tdefault:\n+\t\t\t\terr = fmt.Errorf(\"%v\", e)\n \t\t\t}\n \t\t}\n+\t}()\n+\n+\tvar doc *Node\n+\tif context == \"\" {\n+\t\tdoc, err = Parse(strings.NewReader(text))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\tcontextNode := &Node{\n+\t\t\tType:     ElementNode,\n+\t\t\tDataAtom: atom.Lookup([]byte(context)),\n+\t\t\tData:     context,\n+\t\t}\n+\t\tnodes, err := ParseFragment(strings.NewReader(text), contextNode)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tdoc = &Node{\n+\t\t\tType: DocumentNode,\n+\t\t}\n+\t\tfor _, n := range nodes {\n+\t\t\tdoc.AppendChild(n)\n+\t\t}\n+\t}\n+\n+\tif err := checkTreeConsistency(doc); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tgot, err := dump(doc)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// Compare the parsed tree to the #document section.\n+\tif got != want {\n+\t\treturn fmt.Errorf(\"got vs want:\\n----\\n%s----\\n%s----\", got, want)\n+\t}\n+\n+\tif renderTestBlacklist[text] || context != \"\" {\n+\t\treturn nil\n \t}\n+\n+\t// Check that rendering and re-parsing results in an identical tree.\n+\tpr, pw := io.Pipe()\n+\tgo func() {\n+\t\tpw.CloseWithError(Render(pw, doc))\n+\t}()\n+\tdoc1, err := Parse(pr)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tgot1, err := dump(doc1)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif got != got1 {\n+\t\treturn fmt.Errorf(\"got vs got1:\\n----\\n%s----\\n%s----\", got, got1)\n+\t}\n+\n+\treturn nil\n }\n \n // Some test input result in parse trees are not 'well-formed' despite\n@@ -266,11 +316,81 @@ var renderTestBlacklist = map[string]bool{\n \t// The second <a> will be reparented to the first <table>'s parent. This\n \t// results in an <a> whose parent is an <a>, which is not 'well-formed'.\n \t`<a><table><td><a><table></table><a></tr><a></table><b>X</b>C<a>Y`: true,\n+\t// The same thing with a <p>:\n+\t`<p><table></p>`: true,\n \t// More cases of <a> being reparented:\n \t`<a href=\"blah\">aba<table><a href=\"foo\">br<tr><td></td></tr>x</table>aoe`: true,\n \t`<a><table><a></table><p><a><div><a>`:                                     true,\n \t`<a><table><td><a><table></table><a></tr><a></table><a>`:                  true,\n+\t// A similar reparenting situation involving <nobr>:\n+\t`<!DOCTYPE html><body><b><nobr>1<table><nobr></b><i><nobr>2<nobr></i>3`: true,\n \t// A <plaintext> element is reparented, putting it before a table.\n \t// A <plaintext> element can't have anything after it in HTML.\n-\t`<table><plaintext><td>`: true,\n+\t`<table><plaintext><td>`:                                   true,\n+\t`<!doctype html><table><plaintext></plaintext>`:            true,\n+\t`<!doctype html><table><tbody><plaintext></plaintext>`:     true,\n+\t`<!doctype html><table><tbody><tr><plaintext></plaintext>`: true,\n+\t// A form inside a table inside a form doesn't work either.\n+\t`<!doctype html><form><table></form><form></table></form>`: true,\n+\t// A script that ends at EOF may escape its own closing tag when rendered.\n+\t`<!doctype html><script><!--<script `:          true,\n+\t`<!doctype html><script><!--<script <`:         true,\n+\t`<!doctype html><script><!--<script <a`:        true,\n+\t`<!doctype html><script><!--<script </`:        true,\n+\t`<!doctype html><script><!--<script </s`:       true,\n+\t`<!doctype html><script><!--<script </script`:  true,\n+\t`<!doctype html><script><!--<script </scripta`: true,\n+\t`<!doctype html><script><!--<script -`:         true,\n+\t`<!doctype html><script><!--<script -a`:        true,\n+\t`<!doctype html><script><!--<script -<`:        true,\n+\t`<!doctype html><script><!--<script --`:        true,\n+\t`<!doctype html><script><!--<script --a`:       true,\n+\t`<!doctype html><script><!--<script --<`:       true,\n+\t`<script><!--<script `:                         true,\n+\t`<script><!--<script <a`:                       true,\n+\t`<script><!--<script </script`:                 true,\n+\t`<script><!--<script </scripta`:                true,\n+\t`<script><!--<script -`:                        true,\n+\t`<script><!--<script -a`:                       true,\n+\t`<script><!--<script --`:                       true,\n+\t`<script><!--<script --a`:                      true,\n+\t`<script><!--<script <`:                        true,\n+\t`<script><!--<script </`:                       true,\n+\t`<script><!--<script </s`:                      true,\n+\t// Reconstructing the active formatting elements results in a <plaintext>\n+\t// element that contains an <a> element.\n+\t`<!doctype html><p><a><plaintext>b`: true,\n+}\n+\n+func TestNodeConsistency(t *testing.T) {\n+\t// inconsistentNode is a Node whose DataAtom and Data do not agree.\n+\tinconsistentNode := &Node{\n+\t\tType:     ElementNode,\n+\t\tDataAtom: atom.Frameset,\n+\t\tData:     \"table\",\n+\t}\n+\t_, err := ParseFragment(strings.NewReader(\"<p>hello</p>\"), inconsistentNode)\n+\tif err == nil {\n+\t\tt.Errorf(\"got nil error, want non-nil\")\n+\t}\n+}\n+\n+func BenchmarkParser(b *testing.B) {\n+\tbuf, err := ioutil.ReadFile(\"testdata/go1.html\")\n+\tif err != nil {\n+\t\tb.Fatalf(\"could not read testdata/go1.html: %v\", err)\n+\t}\n+\tb.SetBytes(int64(len(buf)))\n+\truntime.GC()\n+\tvar ms runtime.MemStats\n+\truntime.ReadMemStats(&ms)\n+\tmallocs := ms.Mallocs\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tParse(bytes.NewBuffer(buf))\n+\t}\n+\tb.StopTimer()\n+\truntime.ReadMemStats(&ms)\n+\tmallocs = ms.Mallocs - mallocs\n+\tb.Logf(\"%d iterations, %d mallocs per iteration\\n\", b.N, int(mallocs)/b.N)\n }"}, {"sha": "65b10046a48af535655e920010c020119b83a417", "filename": "libgo/go/exp/html/render.go", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -73,7 +73,7 @@ func render1(w writer, n *Node) error {\n \tcase TextNode:\n \t\treturn escape(w, n.Data)\n \tcase DocumentNode:\n-\t\tfor _, c := range n.Child {\n+\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n \t\t\tif err := render1(w, c); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -171,7 +171,7 @@ func render1(w writer, n *Node) error {\n \t\t}\n \t}\n \tif voidElements[n.Data] {\n-\t\tif len(n.Child) != 0 {\n+\t\tif n.FirstChild != nil {\n \t\t\treturn fmt.Errorf(\"html: void element <%s> has child nodes\", n.Data)\n \t\t}\n \t\t_, err := w.WriteString(\"/>\")\n@@ -182,7 +182,7 @@ func render1(w writer, n *Node) error {\n \t}\n \n \t// Add initial newline where there is danger of a newline beging ignored.\n-\tif len(n.Child) > 0 && n.Child[0].Type == TextNode && strings.HasPrefix(n.Child[0].Data, \"\\n\") {\n+\tif c := n.FirstChild; c != nil && c.Type == TextNode && strings.HasPrefix(c.Data, \"\\n\") {\n \t\tswitch n.Data {\n \t\tcase \"pre\", \"listing\", \"textarea\":\n \t\t\tif err := w.WriteByte('\\n'); err != nil {\n@@ -194,30 +194,24 @@ func render1(w writer, n *Node) error {\n \t// Render any child nodes.\n \tswitch n.Data {\n \tcase \"iframe\", \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"xmp\":\n-\t\tfor _, c := range n.Child {\n-\t\t\tif c.Type != TextNode {\n-\t\t\t\treturn fmt.Errorf(\"html: raw text element <%s> has non-text child node\", n.Data)\n-\t\t\t}\n-\t\t\tif _, err := w.WriteString(c.Data); err != nil {\n-\t\t\t\treturn err\n+\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n+\t\t\tif c.Type == TextNode {\n+\t\t\t\tif _, err := w.WriteString(c.Data); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif err := render1(w, c); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif n.Data == \"plaintext\" {\n \t\t\t// Don't render anything else. <plaintext> must be the\n \t\t\t// last element in the file, with no closing tag.\n \t\t\treturn plaintextAbort\n \t\t}\n-\tcase \"textarea\", \"title\":\n-\t\tfor _, c := range n.Child {\n-\t\t\tif c.Type != TextNode {\n-\t\t\t\treturn fmt.Errorf(\"html: RCDATA element <%s> has non-text child node\", n.Data)\n-\t\t\t}\n-\t\t\tif err := render1(w, c); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n \tdefault:\n-\t\tfor _, c := range n.Child {\n+\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n \t\t\tif err := render1(w, c); err != nil {\n \t\t\t\treturn err\n \t\t\t}"}, {"sha": "11da54b313e5e8a33fae705db152b4a7792494d7", "filename": "libgo/go/exp/html/render_test.go", "status": "modified", "additions": 130, "deletions": 85, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf", "patch": "@@ -10,99 +10,144 @@ import (\n )\n \n func TestRenderer(t *testing.T) {\n-\tn := &Node{\n-\t\tType: ElementNode,\n-\t\tData: \"html\",\n-\t\tChild: []*Node{\n-\t\t\t{\n-\t\t\t\tType: ElementNode,\n-\t\t\t\tData: \"head\",\n+\tnodes := [...]*Node{\n+\t\t0: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"html\",\n+\t\t},\n+\t\t1: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"head\",\n+\t\t},\n+\t\t2: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"body\",\n+\t\t},\n+\t\t3: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"0<1\",\n+\t\t},\n+\t\t4: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"p\",\n+\t\t\tAttr: []Attribute{\n+\t\t\t\t{\n+\t\t\t\t\tKey: \"id\",\n+\t\t\t\t\tVal: \"A\",\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tKey: \"foo\",\n+\t\t\t\t\tVal: `abc\"def`,\n+\t\t\t\t},\n \t\t\t},\n-\t\t\t{\n-\t\t\t\tType: ElementNode,\n-\t\t\t\tData: \"body\",\n-\t\t\t\tChild: []*Node{\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\tData: \"0<1\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\t\tData: \"p\",\n-\t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tKey: \"id\",\n-\t\t\t\t\t\t\t\tVal: \"A\",\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tKey: \"foo\",\n-\t\t\t\t\t\t\t\tVal: `abc\"def`,\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\t\t\tData: \"2\",\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\t\t\t\tData: \"b\",\n-\t\t\t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tKey: \"empty\",\n-\t\t\t\t\t\t\t\t\t\tVal: \"\",\n-\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\t\t\t\t\tData: \"3\",\n-\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\t\t\t\tData: \"i\",\n-\t\t\t\t\t\t\t\tAttr: []Attribute{\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tKey: \"backslash\",\n-\t\t\t\t\t\t\t\t\t\tVal: `\\`,\n-\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\tChild: []*Node{\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\t\t\t\t\tData: \"&4\",\n-\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\tData: \"5\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\t\tData: \"blockquote\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: ElementNode,\n-\t\t\t\t\t\tData: \"br\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tType: TextNode,\n-\t\t\t\t\t\tData: \"6\",\n-\t\t\t\t\t},\n+\t\t},\n+\t\t5: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"2\",\n+\t\t},\n+\t\t6: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"b\",\n+\t\t\tAttr: []Attribute{\n+\t\t\t\t{\n+\t\t\t\t\tKey: \"empty\",\n+\t\t\t\t\tVal: \"\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t7: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"3\",\n+\t\t},\n+\t\t8: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"i\",\n+\t\t\tAttr: []Attribute{\n+\t\t\t\t{\n+\t\t\t\t\tKey: \"backslash\",\n+\t\t\t\t\tVal: `\\`,\n \t\t\t\t},\n \t\t\t},\n \t\t},\n+\t\t9: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"&4\",\n+\t\t},\n+\t\t10: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"5\",\n+\t\t},\n+\t\t11: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"blockquote\",\n+\t\t},\n+\t\t12: {\n+\t\t\tType: ElementNode,\n+\t\t\tData: \"br\",\n+\t\t},\n+\t\t13: {\n+\t\t\tType: TextNode,\n+\t\t\tData: \"6\",\n+\t\t},\n \t}\n-\twant := `<html><head></head><body>0&lt;1<p id=\"A\" foo=\"abc&quot;def\">` +\n+\n+\t// Build a tree out of those nodes, based on a textual representation.\n+\t// Only the \".\\t\"s are significant. The trailing HTML-like text is\n+\t// just commentary. The \"0:\" prefixes are for easy cross-reference with\n+\t// the nodes array.\n+\ttreeAsText := [...]string{\n+\t\t0: `<html>`,\n+\t\t1: `.\t<head>`,\n+\t\t2: `.\t<body>`,\n+\t\t3: `.\t.\t\"0&lt;1\"`,\n+\t\t4: `.\t.\t<p id=\"A\" foo=\"abc&#34;def\">`,\n+\t\t5: `.\t.\t.\t\"2\"`,\n+\t\t6: `.\t.\t.\t<b empty=\"\">`,\n+\t\t7: `.\t.\t.\t.\t\"3\"`,\n+\t\t8: `.\t.\t.\t<i backslash=\"\\\">`,\n+\t\t9: `.\t.\t.\t.\t\"&amp;4\"`,\n+\t\t10: `.\t.\t\"5\"`,\n+\t\t11: `.\t.\t<blockquote>`,\n+\t\t12: `.\t.\t<br>`,\n+\t\t13: `.\t.\t\"6\"`,\n+\t}\n+\tif len(nodes) != len(treeAsText) {\n+\t\tt.Fatal(\"len(nodes) != len(treeAsText)\")\n+\t}\n+\tvar stack [8]*Node\n+\tfor i, line := range treeAsText {\n+\t\tlevel := 0\n+\t\tfor line[0] == '.' {\n+\t\t\t// Strip a leading \".\\t\".\n+\t\t\tline = line[2:]\n+\t\t\tlevel++\n+\t\t}\n+\t\tn := nodes[i]\n+\t\tif level == 0 {\n+\t\t\tif stack[0] != nil {\n+\t\t\t\tt.Fatal(\"multiple root nodes\")\n+\t\t\t}\n+\t\t\tstack[0] = n\n+\t\t} else {\n+\t\t\tstack[level-1].AppendChild(n)\n+\t\t\tstack[level] = n\n+\t\t\tfor i := level + 1; i < len(stack); i++ {\n+\t\t\t\tstack[i] = nil\n+\t\t\t}\n+\t\t}\n+\t\t// At each stage of tree construction, we check all nodes for consistency.\n+\t\tfor j, m := range nodes {\n+\t\t\tif err := checkNodeConsistency(m); err != nil {\n+\t\t\t\tt.Fatalf(\"i=%d, j=%d: %v\", i, j, err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\twant := `<html><head></head><body>0&lt;1<p id=\"A\" foo=\"abc&#34;def\">` +\n \t\t`2<b empty=\"\">3</b><i backslash=\"\\\">&amp;4</i></p>` +\n \t\t`5<blockquote></blockquote><br/>6</body></html>`\n \tb := new(bytes.Buffer)\n-\tif err := Render(b, n); err != nil {\n+\tif err := Render(b, nodes[0]); err != nil {\n \t\tt.Fatal(err)\n \t}\n \tif got := b.String(); got != want {"}, {"sha": "a782cc71d209163e9197263951dfd445cf29deeb", "filename": "libgo/go/exp/html/testdata/go1.html", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fgo1.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fgo1.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fgo1.html?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "5a9208465f58a4554fec072b3259f50b11156b2b", "filename": "libgo/go/exp/html/testdata/webkit/pending-spec-changes.dat", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c4b47e48a816e6448fb7195269f483776bf22b3c", "filename": "libgo/go/exp/html/testdata/webkit/tables01.dat", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c8ef66f0e6e1146ff53d58bf8db17a433f58ab7f", "filename": "libgo/go/exp/html/testdata/webkit/tests16.dat", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0d62f5a5b02b0b56b0a20e42a7afddaae39f5890", "filename": "libgo/go/exp/html/testdata/webkit/tests19.dat", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "fae11ffdf9675bfe5a7882a98b836aa0466f102f", "filename": "libgo/go/exp/html/testdata/webkit/tests26.dat", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "6c78661e0cb83ebf19ff8db1fe5c7695d3489df6", "filename": "libgo/go/exp/html/testdata/webkit/tests_innerHTML_1.dat", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "9d425e99d5f76edc3e6f4bbdfc3e195de6624d3b", "filename": "libgo/go/exp/html/testdata/webkit/webkit01.dat", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "905783d3cdf2a433830969911c2daa62d8a410d8", "filename": "libgo/go/exp/html/testdata/webkit/webkit02.dat", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "517bd5d3ee8dd39ebbba38aea80f7a06fe5886c9", "filename": "libgo/go/exp/html/token.go", "status": "modified", "additions": 464, "deletions": 70, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "63a8bfc483486cfea42d204c4a75b3f83c7428af", "filename": "libgo/go/exp/html/token_test.go", "status": "modified", "additions": 114, "deletions": 19, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "97d5e81ddd04a62530c240d6073f930ae9123133", "filename": "libgo/go/exp/locale/collate/build/builder.go", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f80a2bcb5b513d81d313143a85ba92f4978acea7", "filename": "libgo/go/exp/locale/collate/build/builder_test.go", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "343aa740a73041f3bf5cf4d6bd8260b85fe288b2", "filename": "libgo/go/exp/locale/collate/build/colelem.go", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "28d7c894dc2090c1d27c5f7681efe8056ad60ee8", "filename": "libgo/go/exp/locale/collate/build/colelem_test.go", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f7cf64a7309b35a9e9cb0423fe5494ffa502b54d", "filename": "libgo/go/exp/locale/collate/build/contract.go", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0fc944d34b5822a7121dd425074cd366b28e53be", "filename": "libgo/go/exp/locale/collate/build/contract_test.go", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "7c550d59ba8c9c1982db5d4e46113f5829b04ae6", "filename": "libgo/go/exp/locale/collate/build/order.go", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e6fdfa38443a9e43a34a1f0d12939f4dc7f00298", "filename": "libgo/go/exp/locale/collate/build/order_test.go", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0a290cd00b534aab32d27a695b4e162233d89cfe", "filename": "libgo/go/exp/locale/collate/build/table.go", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftable.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d251a396533037ccdecf6a7ada611853d53fcdb7", "filename": "libgo/go/exp/locale/collate/build/trie.go", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "11da56664d04bd80cb2df09cb96269b15c3f5145", "filename": "libgo/go/exp/locale/collate/build/trie_test.go", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4af71f02de43dfc60f89a6e3a8101b6579b98972", "filename": "libgo/go/exp/locale/collate/colelem.go", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "bcb4ddb68c1307f0d7ce1078966805164fd81e4e", "filename": "libgo/go/exp/locale/collate/colelem_test.go", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "5853b710c337f025980c6eee8d2fe98e5d040a9e", "filename": "libgo/go/exp/locale/collate/collate.go", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0d9bc401bcfb452759d0ae2b7afee574bcfb9da9", "filename": "libgo/go/exp/locale/collate/contract.go", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f3710a183a211f401dc4fdf940f90072170b4b42", "filename": "libgo/go/exp/locale/collate/contract_test.go", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcontract_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "01750dd070e512ff78f0f0be9182afe10c8b5cc6", "filename": "libgo/go/exp/locale/collate/export.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "de6e9078b5cbf4c87e365b2513d73f1776ed773f", "filename": "libgo/go/exp/locale/collate/export_test.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ec03f8f845325905e76ca3925e1b54402a4b5fd0", "filename": "libgo/go/exp/locale/collate/maketables.go", "status": "added", "additions": 722, "deletions": 0, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "14a447c1e4e7cf5c8b7c63b58236f1d96b073cee", "filename": "libgo/go/exp/locale/collate/regtest.go", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c25799b98b231d5b13e78abf969fd445bdabaf93", "filename": "libgo/go/exp/locale/collate/table.go", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1b36a65c50f89a55f7ad23817f9d290c4cb232a7", "filename": "libgo/go/exp/locale/collate/tables.go", "status": "added", "additions": 7578, "deletions": 0, "changes": 7578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c04998d2ec367236714216befcb4191db33729fc", "filename": "libgo/go/exp/locale/collate/tools/colcmp/chars.go", "status": "added", "additions": 937, "deletions": 0, "changes": 937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fchars.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fchars.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fchars.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "26e015cb2f97c1dd9a9ccd57ba99d8e5462a7cce", "filename": "libgo/go/exp/locale/collate/tools/colcmp/col.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "61c90b55086378292597d98fec4bcf56e5054b10", "filename": "libgo/go/exp/locale/collate/tools/colcmp/colcmp.go", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ce2ab468b19f756f459cde6c93930bc426a72c13", "filename": "libgo/go/exp/locale/collate/tools/colcmp/darwin.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fdarwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fdarwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fdarwin.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f9e31187de1e92b204c117a31fdd8e75ce3dbfa6", "filename": "libgo/go/exp/locale/collate/tools/colcmp/gen.go", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fgen.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "91980ac98fdf633b9142086e66251759c828ea54", "filename": "libgo/go/exp/locale/collate/tools/colcmp/icu.go", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Ficu.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Ficu.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Ficu.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c70a89b089cff67f5a76c4a9ed83bcf02f3efe03", "filename": "libgo/go/exp/locale/collate/trie.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "00d636c6f8a7178921488b171ac8b097d369eed2", "filename": "libgo/go/exp/locale/collate/trie_test.go", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "7f84b9429662a42d74ee2562b4bc6d52c5338adc", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "a982174f54eb5cfcc729de91787494f87382dd24", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 76, "deletions": 28, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e37ad7b4103e30b8755c53bdf82976dc3386ec94", "filename": "libgo/go/exp/norm/iter.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "8ac64ba967df2695f8ab6a2e7a851b6a737e36d6", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1c3e49b7719bbae21c7ef7c48c9084fe20ff2d0f", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "6d2188498b105de5561fcb4ff8dcacd66cb88f16", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "231d85d898fc7bf4ecf3d8210a2820a9d065076b", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 127, "deletions": 126, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "82267a8d37fb440bdd96fe2b2cf2e968ee0800d6", "filename": "libgo/go/exp/norm/trie.go", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1a75cc705689f79cd1ace4328815ea2932298278", "filename": "libgo/go/exp/norm/trie_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d6c832d46a1435dc3f3c8a74f8bb30f865cd2267", "filename": "libgo/go/exp/norm/triedata_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1780ac7129dd45ba9c6a70b454eb41e6e11012c3", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "bd947a1639f9c68568ca754a6293ca77c54cb70c", "filename": "libgo/go/exp/types/check.go", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "50c58e3691ecd5336ce8c820125e3694b483e3d6", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "22190153bbf2daaf95928c4730d5aa1dabf42e31", "filename": "libgo/go/exp/types/exportdata.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "51121b76674aedc87e51813cc5f4c9c2a2fc72ff", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0fed72abdd54782b57fe9c62aa53694250388da7", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "15b01419327cc0b0761681925de735747e376de1", "filename": "libgo/go/exp/types/resolver_test.go", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fresolver_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ef9ae80e2b5c0ca8b5635be96a2ade8d40b9de0a", "filename": "libgo/go/exp/types/staging/builtins.go", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fbuiltins.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1fc41342d9bd956a08d76a4bc36f5ab15c158be5", "filename": "libgo/go/exp/types/staging/check.go", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "abcfcfb2cd3ab294cb5bfed309a232c5d5cd34d6", "filename": "libgo/go/exp/types/staging/check_test.go", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e817f1fd85860733c383e0c55208e29f72df3fc2", "filename": "libgo/go/exp/types/staging/const.go", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ac4d59fde7c45300c5a86e8d78d20e1525a88ed8", "filename": "libgo/go/exp/types/staging/conversions.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconversions.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconversions.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconversions.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "64ce25f0f35ee322d98b93abad3dafb3bbeb8c98", "filename": "libgo/go/exp/types/staging/errors.go", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ferrors.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "22190153bbf2daaf95928c4730d5aa1dabf42e31", "filename": "libgo/go/exp/types/staging/exportdata.go", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "560b16c16f363e08ee445679ee72765651dc8519", "filename": "libgo/go/exp/types/staging/expr.go", "status": "added", "additions": 867, "deletions": 0, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexpr.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b15238710e9abae3eaadf7e857f6c34a56584fa1", "filename": "libgo/go/exp/types/staging/gcimporter.go", "status": "added", "additions": 889, "deletions": 0, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "2f89d3ac91274888d316778e8a91674733cc429f", "filename": "libgo/go/exp/types/staging/gcimporter_test.go", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f2440c2999e2b630cfb85a62ec41160acfa3f05a", "filename": "libgo/go/exp/types/staging/operand.go", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Foperand.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "35fcf858b6198ee8a44c8584b3a39dd64febc379", "filename": "libgo/go/exp/types/staging/predicates.go", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fpredicates.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4e9aa0938d986a0fb35b12b8881e99b7f1146a71", "filename": "libgo/go/exp/types/staging/resolver_test.go", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "be5caa1e3645d64d703d9d903e041a755e357fb4", "filename": "libgo/go/exp/types/staging/stmt.go", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fstmt.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c641537e93c2433302894b743c2879fc6b243532", "filename": "libgo/go/exp/types/staging/testdata/builtins.src", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fbuiltins.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fbuiltins.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fbuiltins.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4599397c7a5ed5ccd95d03d7c9b153157c8f6fb8", "filename": "libgo/go/exp/types/staging/testdata/const0.src", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconst0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconst0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconst0.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1b1518366f34d09ce6a90f8093ba21c05923aa29", "filename": "libgo/go/exp/types/staging/testdata/conversions.src", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconversions.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconversions.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fconversions.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e8ae53b220830d96c1f6a957bdd3e122a80d0c99", "filename": "libgo/go/exp/types/staging/testdata/decls0.src", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls0.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "32859fc0ee5187caac59b2f825b255fa680a8486", "filename": "libgo/go/exp/types/staging/testdata/decls1.src", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls1.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "738bcb76ae66b151a87079f5f85cf2ee291d1506", "filename": "libgo/go/exp/types/staging/testdata/decls2a.src", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2a.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2a.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2a.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "9537c081e9273c18e6785cc2e30cdc8a2e2c4d1b", "filename": "libgo/go/exp/types/staging/testdata/decls2b.src", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2b.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2b.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fdecls2b.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "8ee28b0942b69cab01baef4e6203a6ce12c63c26", "filename": "libgo/go/exp/types/staging/testdata/exports.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c54d42b88192ce1a856db82f5e16ef5feec27a8a", "filename": "libgo/go/exp/types/staging/testdata/expr0.src", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr0.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "8ef0aed6d2ea16ed8d811338a04c1f68fab08751", "filename": "libgo/go/exp/types/staging/testdata/expr1.src", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr1.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "a3167f4505413099eb8257a167cc57af16dd5b06", "filename": "libgo/go/exp/types/staging/testdata/expr2.src", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr2.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr2.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr2.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "5635e12eeb0ba0b25e5e87f3b6a74874f4e0c243", "filename": "libgo/go/exp/types/staging/testdata/expr3.src", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexpr3.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "a98c930454a1f4095848216c354997f0f4dd0297", "filename": "libgo/go/exp/types/staging/testdata/stmt0.src", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fstmt0.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b6e7c1edb7a1eaaa24e377784249dbcc41c119a4", "filename": "libgo/go/exp/types/staging/types.go", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e6959bceeb0e0d260baec10cb014585ce0d1de27", "filename": "libgo/go/exp/types/staging/types_test.go", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "bb8b6a2bdacab89d7702a0999a3daecb4c7d45f5", "filename": "libgo/go/exp/types/staging/universe.go", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "8ee28b0942b69cab01baef4e6203a6ce12c63c26", "filename": "libgo/go/exp/types/testdata/exports.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "a770a19b803a5b7e92798f65185b954981d7d45d", "filename": "libgo/go/exp/types/testdata/test0.src", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "50d85b76443593b6ac80654dac4629ab85656600", "filename": "libgo/go/exp/types/types.go", "status": "modified", "additions": 136, "deletions": 14, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c49f366a863d7a99f9ac4561587cfdc9b7f93f60", "filename": "libgo/go/exp/types/types_test.go", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f704b7d03e8c005f1aa184bd40bb95ab51e6b5ec", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ce801162d6e288fc11add52523fbeec6863a9824", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "13e58737f964088938d442e67537daf299389ff5", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d69911c7d72306ea7790605c7c2746f706f905ce", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "cc09e910aad564747b77f4facaffde1dc9c6d072", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e1582c30064dc55cdccfa78a6cf3fbf1566566d6", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "201c948560321507814d863b8e3939dd2795033d", "filename": "libgo/go/go/ast/commentmap.go", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e372eab745b42c853eb5647c0a059eaf3fba5aa2", "filename": "libgo/go/go/ast/commentmap_test.go", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4a1ce480f42cd6ada35e1055f35166cdc36224cb", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b8b1c13b5b8ad5f3c363d7920a866cec3beea3f8", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d8cf98840d71f33ec435ce2f3cf2d13699661294", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "efed739dd216ee9482fc6c8ec587fdba104b9f59", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "04e48c1547b2f472f4b9b34e927e0295bc6b55c9", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "c8079dfd15d3dff3cfc4f3b1c814c57ffb5a217d", "filename": "libgo/go/go/build/read.go", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "2dcc1208f71cd978fdac962f1f04e180065a8c02", "filename": "libgo/go/go/build/read_test.go", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "79053b9a7357bb1fb75bc1367b9f561cb421651a", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 177, "deletions": 14, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "de42d47d9fe3676d849d28ed55c506e4f43452c6", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "2d18174393e67201f002a8ae6f68d7e08d398464", "filename": "libgo/go/go/doc/synopsis.go", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "fd7081a07c2c6adc3758192c2b6ed50c9ecbf1e7", "filename": "libgo/go/go/doc/synopsis_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fsynopsis_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "905e49644ad14f1524f138ef21494f67ed353d21", "filename": "libgo/go/go/doc/testdata/benchmark.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fbenchmark.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ffdb5c3b5887fbaae7c61282eec328617c9b95c1", "filename": "libgo/go/go/doc/testdata/testing.1.golden", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4a84a97ae7957b478d4eec9004e8916bb81da213", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "26b31b247ad01d3cdb7e4ad1fc8a2ea968e90995", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 88, "deletions": 78, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1960377b0a69287425a3ded030b813e9ef0a8dcd", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f2732c0e2b18d142c121d98bf22de920f4b57eef", "filename": "libgo/go/go/parser/performance_test.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "daba853088631f4bccfb81d37b666b17866888ef", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "e99a2e36d4fd8cb0d56093a98a98589118a3e329", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "516c37161c13959b3fa433880e99202ce4640dc1", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "36d1bf74d3ffe748f42b3ebaebd3e390aa456a93", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 93, "deletions": 57, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "d3b50bf3e05a44bc1593e06009bc04add3655e32", "filename": "libgo/go/go/printer/testdata/comments2.golden", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "6f8c85c94aad4bdfa2c48e557b7cf14b3d92146f", "filename": "libgo/go/go/printer/testdata/comments2.input", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "21bbf2b2d42d0a8f4b9bc737614fa4cefd13610c", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "6ac003699261baef1e7867008ef0a7433a1fa6c1", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "4291c557ce2aa6e8c8e21779a817bd4164cd1a32", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1ec12a0504970ad2e01081ca27e3c1dd07998701", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "062900e072476501dfc0660dc43af727703d0123", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1f3cabe75ecf26221f3d1c579ea4af51524abbcb", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "f93eea8925347f923bb1b6a12f9d1bce665b7c39", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "3322c58b339b1d0f260715d255cef87d579cba63", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "1c19053e64ec4427de0e277ea167660618d436f4", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 83, "deletions": 33, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "7c80796bf9fdca2e1c1e778237b06280ec0ce385", "filename": "libgo/go/hash/adler32/adler32.go", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0e9c938d80ccae3521847366c74131ca2e80efd8", "filename": "libgo/go/hash/adler32/adler32_test.go", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "a2a21a06f950bf722f78adf70a46867b2c0d9042", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b5bc6d3cf07df50da42a27afc27c27e576aaa3db", "filename": "libgo/go/hash/crc32/crc32_amd64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_amd64.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "75dc26e7cc249aab1ed80b7b1c9184a2308cfb16", "filename": "libgo/go/hash/crc32/crc32_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "692586798848cbfe6dad7cb386b3fad20ca238e8", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "81a87b56e355ab2060af2f7f4457d2136cf6d592", "filename": "libgo/go/hash/crc64/crc64_test.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b5ecd4a7c6d194d580675098ab9fe4a1012ac8fb", "filename": "libgo/go/hash/fnv/fnv.go", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "89d39b38ad3922403e03fb49b52fa174cc9a7e44", "filename": "libgo/go/hash/fnv/fnv_test.go", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "af8a007ed04629c83e1046b76cb977658ddcf3c2", "filename": "libgo/go/html/entity.go", "status": "modified", "additions": 2077, "deletions": 2077, "changes": 4154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Fentity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Fentity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fentity.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "ce11dedf6b9d0c5c6ba42e2b588f5275fbed7224", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "0d08101ecffc91badb25b5afd95d9431c68d4f92", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "770e274bac0123a8c7fbf272918154386ea4c2d0", "filename": "libgo/go/image/jpeg/dct_test.go", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "92ff1e4b41d3c128b93a29aa4b8f647e798eae2a", "filename": "libgo/go/image/jpeg/idct.go", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "415b093281dd28c5906a0a15f4b9aad36aa96d6b", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "90b89a7b0f19f441c7a20279221e99a9ce3b78a4", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "37978aa662d75befa9130f778874e71360eb7928", "filename": "libgo/go/image/png/paeth.go", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "bb084861ae96f0a5aa3d74bb4225f6b1b2a4fd8f", "filename": "libgo/go/image/png/paeth_test.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}, {"sha": "b3901b2adf944e62b203de9d5781745c7bc2f50c", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ccad563d2a3559f0557bfb177bcf45144219bdf/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=4ccad563d2a3559f0557bfb177bcf45144219bdf"}]}