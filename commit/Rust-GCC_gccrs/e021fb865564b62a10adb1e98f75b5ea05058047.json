{"sha": "e021fb865564b62a10adb1e98f75b5ea05058047", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyMWZiODY1NTY0YjYyYTEwYWRiMWU5OGY3NWI1ZWEwNTA1ODA0Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T15:03:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T15:03:17Z"}, "message": "Replace autovectorize_vector_sizes with autovectorize_vector_modes\n\nThis is another patch in the series to remove the assumption that\nall modes involved in vectorisation have to be the same size.\nRather than have the target provide a list of vector sizes,\nit makes the target provide a list of vector \"approaches\",\nwith each approach represented by a mode.\n\nA later patch will pass this mode to targetm.vectorize.related_mode\nto get the vector mode for a given element mode.  Until then, the modes\nsimply act as an alternative way of specifying the vector size.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.h (vector_sizes, auto_vector_sizes): Delete.\n\t(vector_modes, auto_vector_modes): New typedefs.\n\t* target.def (autovectorize_vector_sizes): Replace with...\n\t(autovectorize_vector_modes): ...this new hook.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES):\n\tReplace with...\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): ...this new hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_autovectorize_vector_sizes): Delete.\n\t(default_autovectorize_vector_modes): New function.\n\t* targhooks.c (default_autovectorize_vector_sizes): Delete.\n\t(default_autovectorize_vector_modes): New function.\n\t* omp-general.c (omp_max_vf): Use autovectorize_vector_modes instead\n\tof autovectorize_vector_sizes.  Use the number of units in the mode\n\tto calculate the maximum VF.\n\t* omp-low.c (omp_clause_aligned_alignment): Use\n\tautovectorize_vector_modes instead of autovectorize_vector_sizes.\n\tUse a loop based on related_mode to iterate through all supported\n\tvector modes for a given scalar mode.\n\t* optabs-query.c (can_vec_mask_load_store_p): Use\n\tautovectorize_vector_modes instead of autovectorize_vector_sizes.\n\t* tree-vect-loop.c (vect_analyze_loop, vect_transform_loop): Likewise.\n\t* tree-vect-slp.c (vect_slp_bb_region): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_sizes):\n\tReplace with...\n\t(aarch64_autovectorize_vector_modes): ...this new function.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n\t* config/arc/arc.c (arc_autovectorize_vector_sizes): Replace with...\n\t(arc_autovectorize_vector_modes): ...this new function.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n\t* config/arm/arm.c (arm_autovectorize_vector_sizes): Replace with...\n\t(arm_autovectorize_vector_modes): ...this new function.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n\t* config/i386/i386.c (ix86_autovectorize_vector_sizes): Replace with...\n\t(ix86_autovectorize_vector_modes): ...this new function.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n\t* config/mips/mips.c (mips_autovectorize_vector_sizes): Replace with...\n\t(mips_autovectorize_vector_modes): ...this new function.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n\nFrom-SVN: r278236", "tree": {"sha": "887a7266e62237498f1d6bfa5d1c8c9d681210e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/887a7266e62237498f1d6bfa5d1c8c9d681210e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e021fb865564b62a10adb1e98f75b5ea05058047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e021fb865564b62a10adb1e98f75b5ea05058047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e021fb865564b62a10adb1e98f75b5ea05058047", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e021fb865564b62a10adb1e98f75b5ea05058047/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0203c4f3bfb3e3242635b0cee0b9deedb4070a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0203c4f3bfb3e3242635b0cee0b9deedb4070a62"}], "stats": {"total": 299, "additions": 177, "deletions": 122}, "files": [{"sha": "218ce4cb3a11cf3e95af8c2249cb48cc341656df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -1,3 +1,50 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.h (vector_sizes, auto_vector_sizes): Delete.\n+\t(vector_modes, auto_vector_modes): New typedefs.\n+\t* target.def (autovectorize_vector_sizes): Replace with...\n+\t(autovectorize_vector_modes): ...this new hook.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES):\n+\tReplace with...\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): ...this new hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_autovectorize_vector_sizes): Delete.\n+\t(default_autovectorize_vector_modes): New function.\n+\t* targhooks.c (default_autovectorize_vector_sizes): Delete.\n+\t(default_autovectorize_vector_modes): New function.\n+\t* omp-general.c (omp_max_vf): Use autovectorize_vector_modes instead\n+\tof autovectorize_vector_sizes.  Use the number of units in the mode\n+\tto calculate the maximum VF.\n+\t* omp-low.c (omp_clause_aligned_alignment): Use\n+\tautovectorize_vector_modes instead of autovectorize_vector_sizes.\n+\tUse a loop based on related_mode to iterate through all supported\n+\tvector modes for a given scalar mode.\n+\t* optabs-query.c (can_vec_mask_load_store_p): Use\n+\tautovectorize_vector_modes instead of autovectorize_vector_sizes.\n+\t* tree-vect-loop.c (vect_analyze_loop, vect_transform_loop): Likewise.\n+\t* tree-vect-slp.c (vect_slp_bb_region): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_sizes):\n+\tReplace with...\n+\t(aarch64_autovectorize_vector_modes): ...this new function.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n+\t* config/arc/arc.c (arc_autovectorize_vector_sizes): Replace with...\n+\t(arc_autovectorize_vector_modes): ...this new function.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n+\t* config/arm/arm.c (arm_autovectorize_vector_sizes): Replace with...\n+\t(arm_autovectorize_vector_modes): ...this new function.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n+\t* config/i386/i386.c (ix86_autovectorize_vector_sizes): Replace with...\n+\t(ix86_autovectorize_vector_modes): ...this new function.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n+\t* config/mips/mips.c (mips_autovectorize_vector_sizes): Replace with...\n+\t(mips_autovectorize_vector_modes): ...this new function.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Delete.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES): Define.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vectorizable_shift): Check the number"}, {"sha": "d177541b2fd27418a1e8dbc0fe2e509cff610d43", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -15912,12 +15912,12 @@ aarch64_preferred_simd_mode (scalar_mode mode)\n /* Return a list of possible vector sizes for the vectorizer\n    to iterate over.  */\n static void\n-aarch64_autovectorize_vector_sizes (vector_sizes *sizes, bool)\n+aarch64_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (TARGET_SVE)\n-    sizes->safe_push (BYTES_PER_SVE_VECTOR);\n-  sizes->safe_push (16);\n-  sizes->safe_push (8);\n+    modes->safe_push (VNx16QImode);\n+  modes->safe_push (V16QImode);\n+  modes->safe_push (V8QImode);\n }\n \n /* Implement TARGET_MANGLE_TYPE.  */\n@@ -21751,9 +21751,9 @@ aarch64_libgcc_floating_mode_supported_p\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n   aarch64_builtin_vectorized_function\n \n-#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n-#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n-  aarch64_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES \\\n+  aarch64_autovectorize_vector_modes\n \n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV \\"}, {"sha": "f48f102f90d2cd5aecc5ff4c77c0d2d1fd07ab6e", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -607,15 +607,15 @@ arc_preferred_simd_mode (scalar_mode mode)\n }\n \n /* Implements target hook\n-   TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n+   TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES.  */\n \n static void\n-arc_autovectorize_vector_sizes (vector_sizes *sizes, bool)\n+arc_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (TARGET_PLUS_QMACW)\n     {\n-      sizes->quick_push (8);\n-      sizes->quick_push (4);\n+      modes->quick_push (V4HImode);\n+      modes->quick_push (V2HImode);\n     }\n }\n \n@@ -726,8 +726,8 @@ static rtx arc_legitimize_address_0 (rtx, rtx, machine_mode mode);\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE arc_preferred_simd_mode\n \n-#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n-#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES arc_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES arc_autovectorize_vector_modes\n \n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P arc_can_use_doloop_p"}, {"sha": "70a20f7646c3722a5ba66affb36dbe54aafcbec9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -288,7 +288,7 @@ static bool arm_builtin_support_vector_misalignment (machine_mode mode,\n static void arm_conditional_register_usage (void);\n static enum flt_eval_method arm_excess_precision (enum excess_precision_type);\n static reg_class_t arm_preferred_rename_class (reg_class_t rclass);\n-static void arm_autovectorize_vector_sizes (vector_sizes *, bool);\n+static void arm_autovectorize_vector_modes (vector_modes *, bool);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n@@ -524,9 +524,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_ARRAY_MODE_SUPPORTED_P arm_array_mode_supported_p\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE arm_preferred_simd_mode\n-#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n-#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n-  arm_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES \\\n+  arm_autovectorize_vector_modes\n \n #undef  TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG arm_reorg\n@@ -29016,12 +29016,12 @@ arm_vector_alignment (const_tree type)\n }\n \n static void\n-arm_autovectorize_vector_sizes (vector_sizes *sizes, bool)\n+arm_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (!TARGET_NEON_VECTORIZE_DOUBLE)\n     {\n-      sizes->safe_push (16);\n-      sizes->safe_push (8);\n+      modes->safe_push (V16QImode);\n+      modes->safe_push (V8QImode);\n     }\n }\n "}, {"sha": "c406be35239e703c4f83b8852e51dcf4d2861cdd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -21385,35 +21385,35 @@ ix86_preferred_simd_mode (scalar_mode mode)\n    256bit and 128bit vectors.  */\n \n static void\n-ix86_autovectorize_vector_sizes (vector_sizes *sizes, bool all)\n+ix86_autovectorize_vector_modes (vector_modes *modes, bool all)\n {\n   if (TARGET_AVX512F && !TARGET_PREFER_AVX256)\n     {\n-      sizes->safe_push (64);\n-      sizes->safe_push (32);\n-      sizes->safe_push (16);\n+      modes->safe_push (V64QImode);\n+      modes->safe_push (V32QImode);\n+      modes->safe_push (V16QImode);\n     }\n   else if (TARGET_AVX512F && all)\n     {\n-      sizes->safe_push (32);\n-      sizes->safe_push (16);\n-      sizes->safe_push (64);\n+      modes->safe_push (V32QImode);\n+      modes->safe_push (V16QImode);\n+      modes->safe_push (V64QImode);\n     }\n   else if (TARGET_AVX && !TARGET_PREFER_AVX128)\n     {\n-      sizes->safe_push (32);\n-      sizes->safe_push (16);\n+      modes->safe_push (V32QImode);\n+      modes->safe_push (V16QImode);\n     }\n   else if (TARGET_AVX && all)\n     {\n-      sizes->safe_push (16);\n-      sizes->safe_push (32);\n+      modes->safe_push (V16QImode);\n+      modes->safe_push (V32QImode);\n     }\n   else if (TARGET_MMX_WITH_SSE)\n-    sizes->safe_push (16);\n+    modes->safe_push (V16QImode);\n \n   if (TARGET_MMX_WITH_SSE)\n-    sizes->safe_push (8);\n+    modes->safe_push (V8QImode);\n }\n \n /* Implemenation of targetm.vectorize.get_mask_mode.  */\n@@ -22952,9 +22952,9 @@ ix86_run_selftests (void)\n #undef TARGET_VECTORIZE_SPLIT_REDUCTION\n #define TARGET_VECTORIZE_SPLIT_REDUCTION \\\n   ix86_split_reduction\n-#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n-#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n-  ix86_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES \\\n+  ix86_autovectorize_vector_modes\n #undef TARGET_VECTORIZE_GET_MASK_MODE\n #define TARGET_VECTORIZE_GET_MASK_MODE ix86_get_mask_mode\n #undef TARGET_VECTORIZE_INIT_COST"}, {"sha": "30017e379773837ae11887246f565cffedf84f57", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -13453,13 +13453,13 @@ mips_preferred_simd_mode (scalar_mode mode)\n   return word_mode;\n }\n \n-/* Implement TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n+/* Implement TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES.  */\n \n static void\n-mips_autovectorize_vector_sizes (vector_sizes *sizes, bool)\n+mips_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (ISA_HAS_MSA)\n-    sizes->safe_push (16);\n+    modes->safe_push (V16QImode);\n }\n \n /* Implement TARGET_INIT_LIBFUNCS.  */\n@@ -22716,9 +22716,9 @@ mips_starting_frame_offset (void)\n \n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE mips_preferred_simd_mode\n-#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n-#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n-  mips_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES \\\n+  mips_autovectorize_vector_modes\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS mips_init_builtins"}, {"sha": "037039afdcf0fb51197c751ae8305f7d61ca1de8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -6008,12 +6008,20 @@ against lower halves of vectors recursively until the specified mode is\n reached.  The default is @var{mode} which means no splitting.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES (vector_sizes *@var{sizes}, bool @var{all})\n-If the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is not\n-the only one that is worth considering, this hook should add all suitable\n-vector sizes to @var{sizes}, in order of decreasing preference.  The first\n-one should be the size of @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n-If @var{all} is true, add suitable vector sizes even when they are generally\n+@deftypefn {Target Hook} void TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES (vector_modes *@var{modes}, bool @var{all})\n+If using the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}\n+is not the only approach worth considering, this hook should add one mode to\n+@var{modes} for each useful alternative approach.  These modes are then\n+passed to @code{TARGET_VECTORIZE_RELATED_MODE} to obtain the vector mode\n+for a given element mode.\n+\n+The modes returned in @var{modes} should use the smallest element mode\n+possible for the vectorization approach that they represent, preferring\n+integer modes over floating-poing modes in the event of a tie.  The first\n+mode should be the @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} for its\n+element mode.\n+\n+If @var{all} is true, add suitable vector modes even when they are generally\n not expected to be worthwhile.\n \n The hook does not need to do anything if the vector returned by"}, {"sha": "73afd0a65a34667de10a6b8680009aa649a9c737", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -4175,7 +4175,7 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_SPLIT_REDUCTION\n \n-@hook TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n+@hook TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n \n @hook TARGET_VECTORIZE_RELATED_MODE\n "}, {"sha": "a8efc106779592f82b2d3a1d364ec5173fbe4dff", "filename": "gcc/omp-general.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -516,13 +516,16 @@ omp_max_vf (void)\n \t  && global_options_set.x_flag_tree_loop_vectorize))\n     return 1;\n \n-  auto_vector_sizes sizes;\n-  targetm.vectorize.autovectorize_vector_sizes (&sizes, true);\n-  if (!sizes.is_empty ())\n+  auto_vector_modes modes;\n+  targetm.vectorize.autovectorize_vector_modes (&modes, true);\n+  if (!modes.is_empty ())\n     {\n       poly_uint64 vf = 0;\n-      for (unsigned int i = 0; i < sizes.length (); ++i)\n-\tvf = ordered_max (vf, sizes[i]);\n+      for (unsigned int i = 0; i < modes.length (); ++i)\n+\t/* The returned modes use the smallest element size (and thus\n+\t   the largest nunits) for the vectorization approach that they\n+\t   represent.  */\n+\tvf = ordered_max (vf, GET_MODE_NUNITS (modes[i]));\n       return vf;\n     }\n "}, {"sha": "3e470afe32b018770bb9470f9ff71136d4b63108", "filename": "gcc/omp-low.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -4064,11 +4064,8 @@ omp_clause_aligned_alignment (tree clause)\n   /* Otherwise return implementation defined alignment.  */\n   unsigned int al = 1;\n   opt_scalar_mode mode_iter;\n-  auto_vector_sizes sizes;\n-  targetm.vectorize.autovectorize_vector_sizes (&sizes, true);\n-  poly_uint64 vs = 0;\n-  for (unsigned int i = 0; i < sizes.length (); ++i)\n-    vs = ordered_max (vs, sizes[i]);\n+  auto_vector_modes modes;\n+  targetm.vectorize.autovectorize_vector_modes (&modes, true);\n   static enum mode_class classes[]\n     = { MODE_INT, MODE_VECTOR_INT, MODE_FLOAT, MODE_VECTOR_FLOAT };\n   for (int i = 0; i < 4; i += 2)\n@@ -4079,19 +4076,18 @@ omp_clause_aligned_alignment (tree clause)\n \tmachine_mode vmode = targetm.vectorize.preferred_simd_mode (mode);\n \tif (GET_MODE_CLASS (vmode) != classes[i + 1])\n \t  continue;\n-\twhile (maybe_ne (vs, 0U)\n-\t       && known_lt (GET_MODE_SIZE (vmode), vs)\n-\t       && GET_MODE_2XWIDER_MODE (vmode).exists ())\n-\t  vmode = GET_MODE_2XWIDER_MODE (vmode).require ();\n+\tmachine_mode alt_vmode;\n+\tfor (unsigned int j = 0; j < modes.length (); ++j)\n+\t  if (related_vector_mode (modes[j], mode).exists (&alt_vmode)\n+\t      && known_ge (GET_MODE_SIZE (alt_vmode), GET_MODE_SIZE (vmode)))\n+\t    vmode = alt_vmode;\n \n \ttree type = lang_hooks.types.type_for_mode (mode, 1);\n \tif (type == NULL_TREE || TYPE_MODE (type) != mode)\n \t  continue;\n-\tpoly_uint64 nelts = exact_div (GET_MODE_SIZE (vmode),\n-\t\t\t\t       GET_MODE_SIZE (mode));\n-\ttype = build_vector_type (type, nelts);\n-\tif (TYPE_MODE (type) != vmode)\n-\t  continue;\n+\ttype = build_vector_type_for_mode (type, vmode);\n+\t/* The functions above are not allowed to return invalid modes.  */\n+\tgcc_assert (TYPE_MODE (type) == vmode);\n \tif (TYPE_ALIGN_UNIT (type) > al)\n \t  al = TYPE_ALIGN_UNIT (type);\n       }"}, {"sha": "fdca9803f73dbc536a3f4dfec09d239ad675bc52", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -589,11 +589,11 @@ can_vec_mask_load_store_p (machine_mode mode,\n       && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n     return true;\n \n-  auto_vector_sizes vector_sizes;\n-  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes, true);\n-  for (unsigned int i = 0; i < vector_sizes.length (); ++i)\n+  auto_vector_modes vector_modes;\n+  targetm.vectorize.autovectorize_vector_modes (&vector_modes, true);\n+  for (unsigned int i = 0; i < vector_modes.length (); ++i)\n     {\n-      poly_uint64 cur = vector_sizes[i];\n+      poly_uint64 cur = GET_MODE_SIZE (vector_modes[i]);\n       poly_uint64 nunits;\n       if (!multiple_p (cur, GET_MODE_SIZE (smode), &nunits))\n \tcontinue;"}, {"sha": "d220f8fbf12146e2cef281f0fc9d48f0f02c0d04", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -1909,20 +1909,28 @@ reached.  The default is @var{mode} which means no splitting.\",\n /* Returns a mask of vector sizes to iterate over when auto-vectorizing\n    after processing the preferred one derived from preferred_simd_mode.  */\n DEFHOOK\n-(autovectorize_vector_sizes,\n- \"If the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is not\\n\\\n-the only one that is worth considering, this hook should add all suitable\\n\\\n-vector sizes to @var{sizes}, in order of decreasing preference.  The first\\n\\\n-one should be the size of @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\\n\\\n-If @var{all} is true, add suitable vector sizes even when they are generally\\n\\\n+(autovectorize_vector_modes,\n+ \"If using the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}\\n\\\n+is not the only approach worth considering, this hook should add one mode to\\n\\\n+@var{modes} for each useful alternative approach.  These modes are then\\n\\\n+passed to @code{TARGET_VECTORIZE_RELATED_MODE} to obtain the vector mode\\n\\\n+for a given element mode.\\n\\\n+\\n\\\n+The modes returned in @var{modes} should use the smallest element mode\\n\\\n+possible for the vectorization approach that they represent, preferring\\n\\\n+integer modes over floating-poing modes in the event of a tie.  The first\\n\\\n+mode should be the @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} for its\\n\\\n+element mode.\\n\\\n+\\n\\\n+If @var{all} is true, add suitable vector modes even when they are generally\\n\\\n not expected to be worthwhile.\\n\\\n \\n\\\n The hook does not need to do anything if the vector returned by\\n\\\n @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\\n\\\n for autovectorization.  The default implementation does nothing.\",\n  void,\n- (vector_sizes *sizes, bool all),\n- default_autovectorize_vector_sizes)\n+ (vector_modes *modes, bool all),\n+ default_autovectorize_vector_modes)\n \n DEFHOOK\n (related_mode,"}, {"sha": "60757efe5dc95536c3c1b4e9518ece29f8b9919c", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -205,11 +205,11 @@ enum vect_cost_model_location {\n class vec_perm_indices;\n \n /* The type to use for lists of vector sizes.  */\n-typedef vec<poly_uint64> vector_sizes;\n+typedef vec<machine_mode> vector_modes;\n \n /* Same, but can be used to construct local lists that are\n    automatically freed.  */\n-typedef auto_vec<poly_uint64, 8> auto_vector_sizes;\n+typedef auto_vec<machine_mode, 8> auto_vector_modes;\n \n /* First argument of targetm.omp.device_kind_arch_isa.  */\n enum omp_device_kind_arch_isa {"}, {"sha": "b0362f969aafa21615a1605aee18966ebb7068c5", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -1298,11 +1298,10 @@ default_split_reduction (machine_mode mode)\n   return mode;\n }\n \n-/* By default only the size derived from the preferred vector mode\n-   is tried.  */\n+/* By default only the preferred vector mode is tried.  */\n \n void\n-default_autovectorize_vector_sizes (vector_sizes *, bool)\n+default_autovectorize_vector_modes (vector_modes *, bool)\n {\n }\n "}, {"sha": "7f96a7c0058ca0ef95dab428a7c26e97e0a92fae", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -113,7 +113,7 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t     int, bool);\n extern machine_mode default_preferred_simd_mode (scalar_mode mode);\n extern machine_mode default_split_reduction (machine_mode);\n-extern void default_autovectorize_vector_sizes (vector_sizes *, bool);\n+extern void default_autovectorize_vector_modes (vector_modes *, bool);\n extern opt_machine_mode default_vectorize_related_mode (machine_mode,\n \t\t\t\t\t\t\tscalar_mode,\n \t\t\t\t\t\t\tpoly_uint64);"}, {"sha": "77ae9f5151c1030264809e36a4f1743ef9876c9f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -2382,12 +2382,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n opt_loop_vec_info\n vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n {\n-  auto_vector_sizes vector_sizes;\n+  auto_vector_modes vector_modes;\n \n   /* Autodetect first vector size we try.  */\n-  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes,\n+  targetm.vectorize.autovectorize_vector_modes (&vector_modes,\n \t\t\t\t\t\tloop->simdlen != 0);\n-  unsigned int next_size = 0;\n+  unsigned int mode_i = 0;\n \n   DUMP_VECT_SCOPE (\"analyze_loop_nest\");\n \n@@ -2406,7 +2406,7 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   unsigned n_stmts = 0;\n   poly_uint64 autodetected_vector_size = 0;\n   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-  poly_uint64 next_vector_size = 0;\n+  machine_mode next_vector_mode = VOIDmode;\n   poly_uint64 lowest_th = 0;\n   unsigned vectorized_loops = 0;\n \n@@ -2425,15 +2425,15 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t  gcc_checking_assert (first_loop_vinfo == NULL);\n \t  return loop_vinfo;\n \t}\n-      loop_vinfo->vector_size = next_vector_size;\n+      loop_vinfo->vector_size = GET_MODE_SIZE (next_vector_mode);\n \n       bool fatal = false;\n \n       if (vect_epilogues)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n \n       res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n-      if (next_size == 0)\n+      if (mode_i == 0)\n \tautodetected_vector_size = loop_vinfo->vector_size;\n \n       loop->aux = NULL;\n@@ -2500,24 +2500,21 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t    }\n \t}\n \n-      if (next_size < vector_sizes.length ()\n-\t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n-\tnext_size += 1;\n+      if (mode_i < vector_modes.length ()\n+\t  && known_eq (GET_MODE_SIZE (vector_modes[mode_i]),\n+\t\t       autodetected_vector_size))\n+\tmode_i += 1;\n \n-      if (next_size == vector_sizes.length ()\n+      if (mode_i == vector_modes.length ()\n \t  || known_eq (autodetected_vector_size, 0U))\n \tbreak;\n \n       /* Try the next biggest vector size.  */\n-      next_vector_size = vector_sizes[next_size++];\n+      next_vector_mode = vector_modes[mode_i++];\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"***** Re-trying analysis with \"\n-\t\t\t   \"vector size \");\n-\t  dump_dec (MSG_NOTE, next_vector_size);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with vector mode %s\\n\",\n+\t\t\t GET_MODE_NAME (next_vector_mode));\n     }\n \n   if (first_loop_vinfo)"}, {"sha": "b6d75f86c95f4734cb6b48cf5bb5ac1b7a78b839", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021fb865564b62a10adb1e98f75b5ea05058047/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e021fb865564b62a10adb1e98f75b5ea05058047", "patch": "@@ -3172,12 +3172,12 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \t\t    unsigned int n_stmts)\n {\n   bb_vec_info bb_vinfo;\n-  auto_vector_sizes vector_sizes;\n+  auto_vector_modes vector_modes;\n \n   /* Autodetect first vector size we try.  */\n-  poly_uint64 next_vector_size = 0;\n-  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes, false);\n-  unsigned int next_size = 0;\n+  machine_mode next_vector_mode = VOIDmode;\n+  targetm.vectorize.autovectorize_vector_modes (&vector_modes, false);\n+  unsigned int mode_i = 0;\n \n   vec_info_shared shared;\n \n@@ -3194,7 +3194,7 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \tbb_vinfo->shared->save_datarefs ();\n       else\n \tbb_vinfo->shared->check_datarefs ();\n-      bb_vinfo->vector_size = next_vector_size;\n+      bb_vinfo->vector_size = GET_MODE_SIZE (next_vector_mode);\n \n       if (vect_slp_analyze_bb_1 (bb_vinfo, n_stmts, fatal)\n \t  && dbg_cnt (vect_slp))\n@@ -3221,33 +3221,30 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \t  vectorized = true;\n \t}\n \n-      if (next_size == 0)\n+      if (mode_i == 0)\n \tautodetected_vector_size = bb_vinfo->vector_size;\n \n       delete bb_vinfo;\n \n-      if (next_size < vector_sizes.length ()\n-\t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n-\tnext_size += 1;\n+      if (mode_i < vector_modes.length ()\n+\t  && known_eq (GET_MODE_SIZE (vector_modes[mode_i]),\n+\t\t       autodetected_vector_size))\n+\tmode_i += 1;\n \n       if (vectorized\n-\t  || next_size == vector_sizes.length ()\n+\t  || mode_i == vector_modes.length ()\n \t  || known_eq (autodetected_vector_size, 0U)\n \t  /* If vect_slp_analyze_bb_1 signaled that analysis for all\n \t     vector sizes will fail do not bother iterating.  */\n \t  || fatal)\n \treturn vectorized;\n \n       /* Try the next biggest vector size.  */\n-      next_vector_size = vector_sizes[next_size++];\n+      next_vector_mode = vector_modes[mode_i++];\n       if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"***** Re-trying analysis with \"\n-\t\t\t   \"vector size \");\n-\t  dump_dec (MSG_NOTE, next_vector_size);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with vector mode %s\\n\",\n+\t\t\t GET_MODE_NAME (next_vector_mode));\n     }\n }\n "}]}