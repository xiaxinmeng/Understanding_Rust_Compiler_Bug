{"sha": "a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhNTdiMDc0Zjc5ZGJlNWUwMTc0NWRhOWNmYmQwOGE1MmZhOGNmZA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-16T21:17:33Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-16T21:17:33Z"}, "message": "libphobos: Add IEEE quadruple support to core.internal.convert\n\nBackport from upstream druntime 2.083 for AArch64.\n\nReviewed-on: https://github.com/dlang/druntime/pull/2257\n\nFrom-SVN: r266222", "tree": {"sha": "31e420d0e68a201b98414879914219dd29fa10f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e420d0e68a201b98414879914219dd29fa10f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd/comments", "author": null, "committer": null, "parents": [{"sha": "2fbd3c37634c580500e15b55b08780a9db795b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbd3c37634c580500e15b55b08780a9db795b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbd3c37634c580500e15b55b08780a9db795b70"}], "stats": {"total": 135, "additions": 114, "deletions": 21}, "files": [{"sha": "c4745b6f5a7ffa05f9810ff447af3cd9912098f4", "filename": "libphobos/libdruntime/core/internal/convert.d", "status": "modified", "additions": 114, "deletions": 21, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d?ref=a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "patch": "@@ -10,13 +10,36 @@\n module core.internal.convert;\n import core.internal.traits : Unqual;\n \n+/+\n+A @nogc function can allocate memory during CTFE.\n++/\n+@nogc nothrow pure @trusted\n+private ubyte[] ctfe_alloc()(size_t n)\n+{\n+    if (!__ctfe)\n+    {\n+        assert(0, \"CTFE only\");\n+    }\n+    else\n+    {\n+        static ubyte[] alloc(size_t x) nothrow pure\n+        {\n+            if (__ctfe) // Needed to prevent _d_newarray from appearing in compiled prorgam.\n+                return new ubyte[x];\n+            else\n+                assert(0);\n+        }\n+        return (cast(ubyte[] function(size_t) @nogc nothrow pure) &alloc)(n);\n+    }\n+}\n+\n @trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(ref T val) if (is(Unqual!T == float) || is(Unqual!T == double) || is(Unqual!T == real) ||\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(Unqual!T == float) || is(Unqual!T == double) || is(Unqual!T == real) ||\n                                         is(Unqual!T == ifloat) || is(Unqual!T == idouble) || is(Unqual!T == ireal))\n {\n     static const(ubyte)[] reverse_(const(ubyte)[] arr)\n     {\n-        ubyte[] buff = new ubyte[arr.length];\n+        ubyte[] buff = ctfe_alloc(arr.length);\n         foreach (k, v; arr)\n         {\n             buff[$-k-1] = v;\n@@ -31,17 +54,35 @@ const(ubyte)[] toUbyte(T)(ref T val) if (is(Unqual!T == float) || is(Unqual!T ==\n         uint exp = parsed.exponent;\n         uint sign = parsed.sign;\n \n-        ubyte[T.sizeof] buff;\n+        ubyte[] buff = ctfe_alloc(T.sizeof);\n         size_t off_bytes = 0;\n         size_t off_bits  = 0;\n+        // Quadruples won't fit in one ulong, so check for that.\n+        enum mantissaMax = FloatTraits!T.MANTISSA < ulong.sizeof*8 ?\n+                           FloatTraits!T.MANTISSA : ulong.sizeof*8;\n \n-        for (; off_bytes < FloatTraits!T.MANTISSA/8; ++off_bytes)\n+        for (; off_bytes < mantissaMax/8; ++off_bytes)\n         {\n             buff[off_bytes] = cast(ubyte)mantissa;\n             mantissa >>= 8;\n         }\n-        off_bits = FloatTraits!T.MANTISSA%8;\n-        buff[off_bytes] = cast(ubyte)mantissa;\n+\n+        static if (floatFormat!T == FloatFormat.Quadruple)\n+        {\n+            ulong mantissa2 = parsed.mantissa2;\n+            off_bytes--; // go back one, since mantissa only stored data in 56\n+                         // bits, ie 7 bytes\n+            for(; off_bytes < FloatTraits!T.MANTISSA/8; ++off_bytes)\n+            {\n+                buff[off_bytes] = cast(ubyte)mantissa2;\n+                mantissa2 >>= 8;\n+            }\n+        }\n+        else\n+        {\n+            off_bits = FloatTraits!T.MANTISSA%8;\n+            buff[off_bytes] = cast(ubyte)mantissa;\n+        }\n \n         for (size_t i=0; i<FloatTraits!T.EXPONENT/8; ++i)\n         {\n@@ -60,7 +101,7 @@ const(ubyte)[] toUbyte(T)(ref T val) if (is(Unqual!T == float) || is(Unqual!T ==\n \n         version (LittleEndian)\n         {\n-            return buff.dup;\n+            return buff;\n         }\n         else\n         {\n@@ -83,8 +124,8 @@ private Float parse(bool is_denormalized = false, T)(T x) if (is(Unqual!T == ifl\n private Float parse(bool is_denormalized = false, T:real)(T x_) if (floatFormat!T != FloatFormat.Real80)\n {\n     Unqual!T x = x_;\n-    assert(floatFormat!T != FloatFormat.DoubleDouble && floatFormat!T != FloatFormat.Quadruple,\n-           \"doubledouble and quadruple float formats are not supported in CTFE\");\n+    static assert(floatFormat!T != FloatFormat.DoubleDouble,\n+           \"doubledouble float format not supported in CTFE\");\n     if (x is cast(T)0.0) return FloatTraits!T.ZERO;\n     if (x is cast(T)-0.0) return FloatTraits!T.NZERO;\n     if (x is T.nan) return FloatTraits!T.NAN;\n@@ -103,17 +144,38 @@ private Float parse(bool is_denormalized = false, T:real)(T x_) if (floatFormat!\n         if (is_denormalized)\n             return Float(0, 0, sign);\n         else\n-            return Float(denormalizedMantissa(x), 0, sign);\n+            return denormalizedMantissa(x, sign);\n     }\n \n     x2 /= binPow2(e);\n \n     static if (!is_denormalized)\n         x2 -= 1.0;\n \n-    x2 *=  2UL<<(FloatTraits!T.MANTISSA);\n-    ulong mant = shiftrRound(cast(ulong)x2);\n-    return Float(mant, exp, sign);\n+    static if (floatFormat!T == FloatFormat.Quadruple)\n+    {\n+        // Store the 112-bit mantissa in two ulongs, specifically the lower 56\n+        // bits of each, with the most significant bits in mantissa2. There's\n+        // an edge case exposed by the labeled test below, where only a subnormal\n+        // with the highest bit set being the 57th bit will \"overflow\" to the\n+        // 57th bit in mantissa2 with the following logic, but that special case\n+        // is handled by an additional check in denormalizedMantissa for\n+        // Quadruples below.\n+\n+        x2 *=  2UL<<(FloatTraits!T.MANTISSA - (ulong.sizeof - 1)*8 - 1);\n+        ulong mant2 = cast(ulong) x2;\n+        x2 -= mant2;\n+\n+        x2 *=  2UL<<((ulong.sizeof - 1)*8 - 1);\n+        ulong mant = cast(ulong) x2;\n+        return Float(mant, exp, sign, mant2);\n+    }\n+    else\n+    {\n+        x2 *=  2UL<<(FloatTraits!T.MANTISSA);\n+        ulong mant = shiftrRound(cast(ulong)x2);\n+        return Float(mant, exp, sign);\n+    }\n }\n \n @safe pure nothrow\n@@ -151,7 +213,7 @@ private Float parse(bool _ = false, T:real)(T x_) if (floatFormat!T == FloatForm\n     uint exp = cast(uint)(e + EXPONENT_MED);\n     if (!exp)\n     {\n-        return Float(denormalizedMantissa(x), 0, sign);\n+        return denormalizedMantissa(x, sign);\n     }\n     int pow = (FloatTraits!T.MANTISSA-1-e);\n     x *=  binPow2((pow / EXPONENT_MED)*EXPONENT_MED); //To avoid overflow in 2.0L ^^ pow\n@@ -165,6 +227,7 @@ private struct Float\n     ulong mantissa;\n     uint exponent;\n     uint sign;\n+    ulong mantissa2;\n }\n \n private template FloatTraits(T) if (floatFormat!T == FloatFormat.Float)\n@@ -215,14 +278,14 @@ private template FloatTraits(T) if (floatFormat!T == FloatFormat.DoubleDouble) /\n     enum NINF     = Float(0, 0x7ff, 1);\n }\n \n-private template FloatTraits(T) if (floatFormat!T == FloatFormat.Quadruple) //Unsupported in CTFE\n+private template FloatTraits(T) if (floatFormat!T == FloatFormat.Quadruple)\n {\n     enum EXPONENT = 15;\n     enum MANTISSA = 112;\n     enum ZERO     = Float(0, 0, 0);\n     enum NZERO    = Float(0, 0, 1);\n-    enum NAN      = Float(-1, 0x7fff, 0);\n-    enum NNAN     = Float(-1, 0x7fff, 1);\n+    enum NAN      = Float(0, 0x7fff, 0, 0x80000000000000UL);\n+    enum NNAN     = Float(0, 0x7fff, 1, 0x80000000000000UL);\n     enum INF      = Float(0, 0x7fff, 0);\n     enum NINF     = Float(0, 0x7fff, 1);\n }\n@@ -291,21 +354,49 @@ private uint binLog2(T)(T x)\n }\n \n @safe pure nothrow\n-private ulong denormalizedMantissa(T)(T x) if (floatFormat!T == FloatFormat.Real80)\n+private Float denormalizedMantissa(T)(T x, uint sign) if (floatFormat!T == FloatFormat.Real80)\n {\n     x *= 2.0L^^FloatTraits!T.MANTISSA;\n     auto fl = parse(x);\n     uint pow = FloatTraits!T.MANTISSA - fl.exponent + 1;\n-    return fl.mantissa >> pow;\n+    return Float(fl.mantissa >> pow, 0, sign);\n }\n \n @safe pure nothrow\n-private ulong denormalizedMantissa(T)(T x) if (floatFormat!T != FloatFormat.Real80)\n+private Float denormalizedMantissa(T)(T x, uint sign)\n+    if (floatFormat!T == FloatFormat.Float || floatFormat!T == FloatFormat.Double)\n {\n     x *= 2.0L^^FloatTraits!T.MANTISSA;\n     auto fl = parse!true(x);\n     ulong mant = fl.mantissa >> (FloatTraits!T.MANTISSA - fl.exponent);\n-    return shiftrRound(mant);\n+    return Float(shiftrRound(mant), 0, sign);\n+}\n+\n+@safe pure nothrow\n+private Float denormalizedMantissa(T)(T x, uint sign) if (floatFormat!T == FloatFormat.Quadruple)\n+{\n+    x *= 2.0L^^FloatTraits!T.MANTISSA;\n+    auto fl = parse!true(x);\n+    uint offset = FloatTraits!T.MANTISSA - fl.exponent + 1;\n+    enum mantissaSize = (ulong.sizeof - 1) * 8;\n+\n+    if (offset < mantissaSize)\n+    {   // Create a new mantissa ulong with the trailing mantissa2 bits that\n+        // need to be shifted into mantissa, by shifting the needed bits left,\n+        // zeroing out the first byte, and then ORing it with mantissa shifted\n+        // right by offset.\n+\n+        ulong shiftedMantissa = ((fl.mantissa2 << (mantissaSize - offset)) &\n+                                 0x00FFFFFFFFFFFFFFUL) | fl.mantissa >> offset;\n+        return Float(shiftedMantissa, 0, sign, fl.mantissa2 >> offset);\n+    }\n+    else if (offset > mantissaSize)\n+        return Float(fl.mantissa2 >> offset - mantissaSize , 0, sign, 0);\n+    else\n+        // Handle special case mentioned in parse() above by zeroing out the\n+        // 57'th bit of mantissa2, \"shifting\" it into mantissa, and setting the\n+        // first bit of mantissa2.\n+        return Float(fl.mantissa2 & 0x00FFFFFFFFFFFFFFUL , 0, sign, 1);\n }\n \n version (unittest)\n@@ -403,6 +494,8 @@ version (unittest)\n \n         testNumberConvert!(\"real.min_normal/2\");\n         testNumberConvert!(\"real.min_normal/2UL^^63\");\n+        // check subnormal storage edge case for Quadruple\n+        testNumberConvert!(\"real.min_normal/2UL^^56\");\n         //testNumberConvert!(\"real.min_normal/19\"); // XGDC: ct[0] == 0, rt[0] == 27\n         //testNumberConvert!(\"real.min_normal/17\"); // XGDC: ct[0= == 128, rt[0] == 136\n "}]}