{"sha": "10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhNWRkNWQzZDRjYzUzNjEzYjhlNDRiNzhlOTliN2Q2MWY4NWQ3Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-14T13:26:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-14T13:26:44Z"}, "message": "cgraph.c (dump_cgraph_node): Do not dump inline summaries.\n\n\n\t* cgraph.c (dump_cgraph_node): Do not dump inline summaries.\n\t* cgraph.h (struct inline_summary): Move to ipa-inline.h\n\t(cgraph_local_info): Remove inline_summary.\n\t* ipa-cp.c: Include ipa-inline.h.\n\t(ipcp_cloning_candidate_p, ipcp_estimate_growth,\n\tipcp_estimate_cloning_cost, ipcp_insert_stage): Use inline_summary\n\taccesor.\n\t* lto-cgraph.c (lto_output_node): Do not stream inline summary.\n\t(input_overwrite_node): Do not set inline summary.\n\t(input_node): Do not stream inline summary.\n\t* ipa-inline.c (cgraph_decide_inlining): Dump inline summaries.\n\t(cgraph_decide_inlining_incrementally): Do not try to estimate overall\n\tgrowth; we do not have inline parameters computed for that anyway.\n\t(cgraph_early_inlining): After inlining compute call_stmt_sizes.\n\t* ipa-inline.h (struct inline_summary): Move here from ipa-inline.h\n\t(inline_summary_t): New type and VECtor.\n\t(debug_inline_summary, dump_inline_summaries): Declare.\n\t(inline_summary): Use VOCtor.\n\t(estimate_edge_growth): Kill hack computing call stmt size directly.\n\t* lto-section-in.c (lto_section_name): Add inline section.\n\t* ipa-inline-analysis.c: Include lto-streamer.h\n\t(node_removal_hook_holder, node_duplication_hook_holder): New holders\n\t(inline_node_removal_hook, inline_node_duplication_hook): New functions.\n\t(inline_summary_vec): Define.\n\t(inline_summary_alloc, dump_inline_summary, debug_inline_summary,\n\tdump_inline_summaries): New functions.\n\t(estimate_function_body_sizes): Properly compute size/time of outgoing calls.\n\t(compute_inline_parameters): Alloc inline_summary; do not compute size/time\n\tof incomming calls.\n\t(estimate_edge_time): Avoid missing time summary hack.\n\t(inline_read_summary): Read inline summary info.\n\t(inline_write_summary): Write inline summary info.\n\t(inline_free_summary): Free all hooks and inline summary vector.\n\t* lto-streamer.h: Add LTO_section_inline_summary section.\n\t* Makefile.in (ipa-cp.o, ipa-inline-analysis.o): Update dependencies.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Fix dump file formating.\n\n\t* lto.c: Include ipa-inline.h\n\t(add_cgraph_node_to_partition, undo_partition): Use inline_summary accessor.\n\t(ipa_node_duplication_hook): Fix declaration.\n\t* Make-lang.in (lto.o): Update dependencies.\n\nFrom-SVN: r172430", "tree": {"sha": "eb6e4c913e14b3874133c0765b5a7b51b8c55868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb6e4c913e14b3874133c0765b5a7b51b8c55868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/comments", "author": null, "committer": null, "parents": [{"sha": "b602d918bc8a134e29e065c38776ecf1a382e932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b602d918bc8a134e29e065c38776ecf1a382e932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b602d918bc8a134e29e065c38776ecf1a382e932"}], "stats": {"total": 438, "additions": 318, "deletions": 120}, "files": [{"sha": "be9ccb246b5a9a5404763c1a3d0fea7733805abf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -1,3 +1,42 @@\n+2011-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Do not dump inline summaries.\n+\t* cgraph.h (struct inline_summary): Move to ipa-inline.h\n+\t(cgraph_local_info): Remove inline_summary.\n+\t* ipa-cp.c: Include ipa-inline.h.\n+\t(ipcp_cloning_candidate_p, ipcp_estimate_growth,\n+\tipcp_estimate_cloning_cost, ipcp_insert_stage): Use inline_summary\n+\taccesor.\n+\t* lto-cgraph.c (lto_output_node): Do not stream inline summary.\n+\t(input_overwrite_node): Do not set inline summary.\n+\t(input_node): Do not stream inline summary.\n+\t* ipa-inline.c (cgraph_decide_inlining): Dump inline summaries.\n+\t(cgraph_decide_inlining_incrementally): Do not try to estimate overall\n+\tgrowth; we do not have inline parameters computed for that anyway.\n+\t(cgraph_early_inlining): After inlining compute call_stmt_sizes.\n+\t* ipa-inline.h (struct inline_summary): Move here from ipa-inline.h\n+\t(inline_summary_t): New type and VECtor.\n+\t(debug_inline_summary, dump_inline_summaries): Declare.\n+\t(inline_summary): Use VOCtor.\n+\t(estimate_edge_growth): Kill hack computing call stmt size directly.\n+\t* lto-section-in.c (lto_section_name): Add inline section.\n+\t* ipa-inline-analysis.c: Include lto-streamer.h\n+\t(node_removal_hook_holder, node_duplication_hook_holder): New holders\n+\t(inline_node_removal_hook, inline_node_duplication_hook): New functions.\n+\t(inline_summary_vec): Define.\n+\t(inline_summary_alloc, dump_inline_summary, debug_inline_summary,\n+\tdump_inline_summaries): New functions.\n+\t(estimate_function_body_sizes): Properly compute size/time of outgoing calls.\n+\t(compute_inline_parameters): Alloc inline_summary; do not compute size/time\n+\tof incomming calls.\n+\t(estimate_edge_time): Avoid missing time summary hack.\n+\t(inline_read_summary): Read inline summary info.\n+\t(inline_write_summary): Write inline summary info.\n+\t(inline_free_summary): Free all hooks and inline summary vector.\n+\t* lto-streamer.h: Add LTO_section_inline_summary section.\n+\t* Makefile.in (ipa-cp.o, ipa-inline-analysis.o): Update dependencies.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Fix dump file formating.\n+\n 2011-04-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vectorizer.h (vect_strided_store_supported): Add a"}, {"sha": "04b10cd8cd920b47bc5c90218a66c0709467db27", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -3011,7 +3011,7 @@ ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TREE_H) $(TARGET_H) $(GIMPLE_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n-   $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H) tree-pretty-print.h\n+   $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H) tree-pretty-print.h ipa-inline.h\n ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n@@ -3032,7 +3032,7 @@ ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n-   gimple-pretty-print.h ipa-inline.h\n+   gimple-pretty-print.h ipa-inline.h $(LTO_STREAMER_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(GIMPLE_H) $(SPLAY_TREE_H) \\"}, {"sha": "09436c7cfb575c4653f93e7094a050c348468d8f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -1876,22 +1876,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n-  if (node->local.inline_summary.self_time)\n-    fprintf (f, \" %i time, %i benefit\", node->local.inline_summary.self_time,\n-    \t\t\t\t\tnode->local.inline_summary.time_inlining_benefit);\n-  if (node->global.time && node->global.time\n-      != node->local.inline_summary.self_time)\n-    fprintf (f, \" (%i after inlining)\", node->global.time);\n-  if (node->local.inline_summary.self_size)\n-    fprintf (f, \" %i size, %i benefit\", node->local.inline_summary.self_size,\n-    \t\t\t\t\tnode->local.inline_summary.size_inlining_benefit);\n-  if (node->global.size && node->global.size\n-      != node->local.inline_summary.self_size)\n-    fprintf (f, \" (%i after inlining)\", node->global.size);\n-  if (node->local.inline_summary.estimated_self_stack_size)\n-    fprintf (f, \" %i bytes stack usage\", (int)node->local.inline_summary.estimated_self_stack_size);\n-  if (node->global.estimated_stack_size != node->local.inline_summary.estimated_self_stack_size)\n-    fprintf (f, \" %i bytes after inlining\", (int)node->global.estimated_stack_size);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n   if (node->needed)"}, {"sha": "eb5154638bc8fd653164a0c6f1891b159e62fc8f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -58,23 +58,6 @@ struct lto_file_decl_data;\n extern const char * const cgraph_availability_names[];\n extern const char * const ld_plugin_symbol_resolution_names[];\n \n-/* Function inlining information.  */\n-\n-struct GTY(()) inline_summary\n-{\n-  /* Estimated stack frame consumption by the function.  */\n-  HOST_WIDE_INT estimated_self_stack_size;\n-\n-  /* Size of the function body.  */\n-  int self_size;\n-  /* How many instructions are likely going to disappear after inlining.  */\n-  int size_inlining_benefit;\n-  /* Estimated time spent executing the function body.  */\n-  int self_time;\n-  /* How much time is going to be saved by inlining.  */\n-  int time_inlining_benefit;\n-};\n-\n /* Information about thunk, used only for same body aliases.  */\n \n struct GTY(()) cgraph_thunk_info {\n@@ -95,8 +78,6 @@ struct GTY(()) cgraph_local_info {\n   /* File stream where this node is being written to.  */\n   struct lto_file_decl_data * lto_file_data;\n \n-  struct inline_summary inline_summary;\n-\n   /* Set when function function is visible in current compilation unit only\n      and its address is never taken.  */\n   unsigned local : 1;"}, {"sha": "4cee1d481e66bdcb711795b52b77c85a99d1c77d", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -148,6 +148,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"fibheap.h\"\n #include \"params.h\"\n+#include \"ipa-inline.h\"\n \n /* Number of functions identified as candidates for cloning. When not cloning\n    we can simplify iterate stage not forcing it to go through the decision\n@@ -495,7 +496,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n  \t         cgraph_node_name (node));\n       return false;\n     }\n-  if (node->local.inline_summary.self_size < n_calls)\n+  if (inline_summary (node)->self_size < n_calls)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Considering %s for cloning; code would shrink.\\n\",\n@@ -1189,7 +1190,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n      call site.  Precise cost is difficult to get, as our size metric counts\n      constants and moves as free.  Generally we are looking for cases that\n      small function is called very many times.  */\n-  growth = node->local.inline_summary.self_size\n+  growth = inline_summary (node)->self_size\n   \t   - removable_args * redirectable_node_callers;\n   if (growth < 0)\n     return 0;\n@@ -1229,7 +1230,7 @@ ipcp_estimate_cloning_cost (struct cgraph_node *node)\n     cost /= freq_sum * 1000 / REG_BR_PROB_BASE + 1;\n   if (dump_file)\n     fprintf (dump_file, \"Cost of versioning %s is %i, (size: %i, freq: %i)\\n\",\n-             cgraph_node_name (node), cost, node->local.inline_summary.self_size,\n+             cgraph_node_name (node), cost, inline_summary (node)->self_size,\n \t     freq_sum);\n   return cost + 1;\n }\n@@ -1364,7 +1365,7 @@ ipcp_insert_stage (void)\n       {\n \tif (node->count > max_count)\n \t  max_count = node->count;\n-\toverall_size += node->local.inline_summary.self_size;\n+\toverall_size += inline_summary (node)->self_size;\n       }\n \n   max_new_size = overall_size;"}, {"sha": "47bd2a8c1da1ab4ed4a64b89077786a3e402f020", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 204, "deletions": 23, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -23,13 +23,13 @@ along with GCC; see the file COPYING3.  If not see\n \n    We estimate for each function\n      - function body size\n-     - function runtime\n+     - average function execution time\n      - inlining size benefit (that is how much of function body size\n        and its call sequence is expected to disappear by inlining)\n      - inlining time benefit\n      - function frame size\n    For each call\n-     - call sequence size\n+     - call statement size and time\n \n    inlinie_summary datastructures store above information locally (i.e.\n    parameters of the function itself) and globally (i.e. parameters of\n@@ -61,12 +61,99 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"tree-flow.h\"\n #include \"ipa-prop.h\"\n+#include \"lto-streamer.h\"\n #include \"ipa-inline.h\"\n \n #define MAX_TIME 1000000000\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n+static struct cgraph_node_hook_list *node_removal_hook_holder;\n+static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static void inline_node_removal_hook (struct cgraph_node *, void *);\n+static void inline_node_duplication_hook (struct cgraph_node *,\n+\t\t\t\t\t  struct cgraph_node *, void *);\n+\n+/* VECtor holding inline summaries.  */\n+VEC(inline_summary_t,heap) *inline_summary_vec;\n+\n+/* Allocate the inline summary vector or resize it to cover all cgraph nodes. */\n+\n+static void\n+inline_summary_alloc (void)\n+{\n+  if (!node_removal_hook_holder)\n+    node_removal_hook_holder =\n+      cgraph_add_node_removal_hook (&inline_node_removal_hook, NULL);\n+  if (!node_duplication_hook_holder)\n+    node_duplication_hook_holder =\n+      cgraph_add_node_duplication_hook (&inline_node_duplication_hook, NULL);\n+\n+  if (VEC_length (inline_summary_t, inline_summary_vec)\n+      <= (unsigned) cgraph_max_uid)\n+    VEC_safe_grow_cleared (inline_summary_t, heap,\n+\t\t\t   inline_summary_vec, cgraph_max_uid + 1);\n+}\n+\n+/* Hook that is called by cgraph.c when a node is removed.  */\n+\n+static void\n+inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (VEC_length (inline_summary_t, inline_summary_vec)\n+      <= (unsigned)node->uid)\n+    return;\n+  memset (inline_summary (node),\n+\t  0, sizeof (inline_summary_t));\n+}\n+\n+/* Hook that is called by cgraph.c when a node is duplicated.  */\n+\n+static void\n+inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n+\t\t\t      ATTRIBUTE_UNUSED void *data)\n+{\n+  inline_summary_alloc ();\n+  memcpy (inline_summary (dst), inline_summary (src),\n+\t  sizeof (struct inline_summary));\n+}\n+\n+static void\n+dump_inline_summary (FILE *f, struct cgraph_node *node)\n+{\n+  if (node->analyzed)\n+    {\n+      struct inline_summary *s = inline_summary (node);\n+      fprintf (f, \"Inline summary for %s/%i\\n\", cgraph_node_name (node),\n+\t       node->uid);\n+      fprintf (f, \"  self time:       %i, benefit: %i\\n\",\n+      \t       s->self_time, s->time_inlining_benefit);\n+      fprintf (f, \"  global time:     %i\\n\", node->global.time);\n+      fprintf (f, \"  self size:       %i, benefit: %i\\n\",\n+\t       s->self_size, s->size_inlining_benefit);\n+      fprintf (f, \"  global size:     %i\", node->global.size);\n+      fprintf (f, \"  self stack:      %i\\n\",\n+\t       (int)s->estimated_self_stack_size);\n+      fprintf (f, \"  global stack:    %i\\n\\n\",\n+\t       (int)node->global.estimated_stack_size);\n+    }\n+}\n+\n+void\n+debug_inline_summary (struct cgraph_node *node)\n+{\n+  dump_inline_summary (stderr, node);\n+}\n+\n+void\n+dump_inline_summaries (FILE *f)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      dump_inline_summary (f, node);\n+}\n \n /* See if statement might disappear after inlining.\n    0 - means not eliminated\n@@ -179,16 +266,27 @@ estimate_function_body_sizes (struct cgraph_node *node)\n \t\t       freq, this_size, this_time);\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n+\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n+\t      edge->call_stmt_size = this_size;\n+\t      edge->call_stmt_time = this_time;\n+\t    }\n+\n \t  this_time *= freq;\n \t  time += this_time;\n \t  size += this_size;\n+\n \t  prob = eliminated_by_inlining_prob (stmt);\n \t  if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"    50%% will be eliminated by inlining\\n\");\n \t  if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"    will eliminated by inlining\\n\");\n+\n \t  size_inlining_benefit += this_size * prob;\n \t  time_inlining_benefit += this_time * prob;\n+\n \t  gcc_assert (time >= 0);\n \t  gcc_assert (size >= 0);\n \t}\n@@ -222,6 +320,8 @@ compute_inline_parameters (struct cgraph_node *node)\n \n   gcc_assert (!node->global.inlined_to);\n \n+  inline_summary_alloc ();\n+\n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n   inline_summary (node)->estimated_self_stack_size = self_stack_size;\n@@ -247,17 +347,7 @@ compute_inline_parameters (struct cgraph_node *node)\n       node->local.can_change_signature = !e;\n     }\n   estimate_function_body_sizes (node);\n-  /* Compute size of call statements.  We have to do this for callers here,\n-     those sizes need to be present for edges _to_ us as early as\n-     we are finished with early opts.  */\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (e->call_stmt)\n-      {\n-\te->call_stmt_size\n-\t  = estimate_num_insns (e->call_stmt, &eni_size_weights);\n-\te->call_stmt_time\n-\t  = estimate_num_insns (e->call_stmt, &eni_time_weights);\n-      }\n+\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   node->global.time = inline_summary (node)->self_time;\n   node->global.size = inline_summary (node)->self_size;\n@@ -300,12 +390,8 @@ static inline int\n estimate_edge_time (struct cgraph_edge *edge)\n {\n   int call_stmt_time;\n-  /* ???  We throw away cgraph edges all the time so the information\n-     we store in edges doesn't persist for early inlining.  Ugh.  */\n-  if (!edge->call_stmt)\n-    call_stmt_time = edge->call_stmt_time;\n-  else\n-    call_stmt_time = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+  call_stmt_time = edge->call_stmt_time;\n+  gcc_checking_assert (call_stmt_time);\n   return (((gcov_type)edge->callee->global.time\n \t   - inline_summary (edge->callee)->time_inlining_benefit\n \t   - call_stmt_time) * edge->frequency\n@@ -333,7 +419,7 @@ estimate_time_after_inlining (struct cgraph_node *node,\n \n int\n estimate_size_after_inlining (struct cgraph_node *node,\n-\t\t\t\t     struct cgraph_edge *edge)\n+\t\t\t      struct cgraph_edge *edge)\n {\n   int size = node->global.size + estimate_edge_growth (edge);\n   gcc_assert (size >= 0);\n@@ -379,8 +465,10 @@ estimate_growth (struct cgraph_node *node)\n   return growth;\n }\n \n+\n /* This function performs intraprocedural analysis in NODE that is required to\n    inline indirect calls.  */\n+\n static void\n inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n {\n@@ -437,8 +525,6 @@ inline_generate_summary (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n       inline_analyze_function (node);\n-\n-  return;\n }\n \n \n@@ -449,6 +535,57 @@ inline_generate_summary (void)\n void\n inline_read_summary (void)\n {\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  inline_summary_alloc ();\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data = lto_get_section_data (file_data, LTO_section_inline_summary, NULL, &len);\n+\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_inline_summary,\n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{\n+\t  unsigned int i;\n+\t  unsigned int f_count = lto_input_uleb128 (ib);\n+\n+\t  for (i = 0; i < f_count; i++)\n+\t    {\n+\t      unsigned int index;\n+\t      struct cgraph_node *node;\n+\t      struct inline_summary *info;\n+\t      lto_cgraph_encoder_t encoder;\n+\n+\t      index = lto_input_uleb128 (ib);\n+\t      encoder = file_data->cgraph_node_encoder;\n+\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      info = inline_summary (node);\n+\n+\t      node->global.estimated_stack_size\n+\t        = info->estimated_self_stack_size = lto_input_uleb128 (ib);\n+\t      node->global.time = info->self_time = lto_input_uleb128 (ib);\n+\t      info->time_inlining_benefit = lto_input_uleb128 (ib);\n+\t      node->global.size = info->self_size = lto_input_uleb128 (ib);\n+\t      info->size_inlining_benefit = lto_input_uleb128 (ib);\n+\t      node->global.estimated_growth = INT_MIN;\n+\t    }\n+\n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_inline_summary,\n+\t\t\t\t\t  ib, data, len);\n+\t}\n+      else\n+\t/* Fatal error here.  We do not want to support compiling ltrans units with\n+\t   different version of compiler or different flags than the WPA unit, so\n+\t   this should never happen.  */\n+\tfatal_error (\"ipa inline summary is missing in input file\");\n+    }\n   if (flag_indirect_inlining)\n     {\n       ipa_register_cgraph_hooks ();\n@@ -468,14 +605,58 @@ void\n inline_write_summary (cgraph_node_set set,\n \t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n+  struct cgraph_node *node;\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_inline_summary);\n+  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  unsigned int count = 0;\n+  int i;\n+\n+  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+    if (lto_cgraph_encoder_deref (encoder, i)->analyzed)\n+      count++;\n+  lto_output_uleb128_stream (ob->main_stream, count);\n+\n+  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+    {\n+      node = lto_cgraph_encoder_deref (encoder, i);\n+      if (node->analyzed)\n+\t{\n+\t  struct inline_summary *info = inline_summary (node);\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     lto_cgraph_encoder_encode (encoder, node));\n+\t  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t     info->estimated_self_stack_size);\n+\t  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t     info->self_size);\n+\t  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t     info->size_inlining_benefit);\n+\t  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t     info->self_time);\n+\t  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t     info->time_inlining_benefit);\n+\t}\n+    }\n+  lto_destroy_simple_output_block (ob);\n+\n   if (flag_indirect_inlining && !flag_ipa_cp)\n     ipa_prop_write_jump_functions (set);\n }\n \n+\n /* Release inline summary.  */\n \n void\n inline_free_summary (void)\n {\n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  if (function_insertion_hook_holder)\n+    cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  function_insertion_hook_holder = NULL;\n+  if (node_removal_hook_holder)\n+    cgraph_remove_node_removal_hook (node_removal_hook_holder);\n+  node_removal_hook_holder = NULL;\n+  if (node_duplication_hook_holder)\n+    cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n+  node_duplication_hook_holder = NULL;\n+  VEC_free (inline_summary_t, heap, inline_summary_vec);\n }"}, {"sha": "1dbb3248fabcd89ea421f325b9018546396c9cca", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -1301,6 +1301,9 @@ cgraph_decide_inlining (void)\n \t      max_benefit = benefit;\n \t  }\n       }\n+\n+  if (dump_file)\n+    dump_inline_summaries (dump_file);\n   gcc_assert (in_lto_p\n \t      || !max_count\n \t      || (profile_info && flag_branch_probabilities));\n@@ -1415,7 +1418,9 @@ cgraph_decide_inlining (void)\n \t     ncalls_inlined, nfunctions_inlined, initial_size,\n \t     overall_size);\n   free (order);\n-  inline_free_summary ();\n+  /* In WPA we use inline summaries for partitioning process.  */\n+  if (!flag_wpa)\n+    inline_free_summary ();\n   return 0;\n }\n \n@@ -1558,8 +1563,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n       /* When the function body would grow and inlining the function\n \t won't eliminate the need for offline copy of the function,\n \t don't inline.  */\n-      if (estimate_edge_growth (e) > allowed_growth\n-\t  && estimate_growth (e->callee) > allowed_growth)\n+      if (estimate_edge_growth (e) > allowed_growth)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -1601,6 +1605,7 @@ static unsigned int\n cgraph_early_inlining (void)\n {\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_edge *edge;\n   unsigned int todo = 0;\n   int iterations = 0;\n   bool inlined = false;\n@@ -1652,6 +1657,19 @@ cgraph_early_inlining (void)\n     {\n       timevar_push (TV_INTEGRATION);\n       todo |= optimize_inline_calls (current_function_decl);\n+\n+      /* Technically we ought to recompute inline parameters so the new iteration of\n+\t early inliner works as expected.  We however have values approximately right\n+\t and thus we only need to update edge info that might be cleared out for\n+\t newly discovered edges.  */\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t{\n+\t  edge->call_stmt_size\n+\t    = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+\t  edge->call_stmt_time\n+\t    = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t}\n+\n       timevar_pop (TV_INTEGRATION);\n     }\n "}, {"sha": "e9a7db21043f3b5cedba4d0e724f0488c2c6a57f", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -19,6 +19,30 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Function inlining information.  */\n+\n+struct inline_summary\n+{\n+  /* Estimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_self_stack_size;\n+\n+  /* Size of the function body.  */\n+  int self_size;\n+  /* How many instructions are likely going to disappear after inlining.  */\n+  int size_inlining_benefit;\n+  /* Estimated time spent executing the function body.  */\n+  int self_time;\n+  /* How much time is going to be saved by inlining.  */\n+  int time_inlining_benefit;\n+};\n+\n+typedef struct inline_summary inline_summary_t;\n+DEF_VEC_O(inline_summary_t);\n+DEF_VEC_ALLOC_O(inline_summary_t,heap);\n+extern VEC(inline_summary_t,heap) *inline_summary_vec;\n+\n+void debug_inline_summary (struct cgraph_node *);\n+void dump_inline_summaries (FILE *f);\n void inline_generate_summary (void);\n void inline_read_summary (void);\n void inline_write_summary (cgraph_node_set, varpool_node_set);\n@@ -30,7 +54,7 @@ int estimate_growth (struct cgraph_node *);\n static inline struct inline_summary *\n inline_summary (struct cgraph_node *node)\n {\n-  return &node->local.inline_summary;\n+  return VEC_index (inline_summary_t, inline_summary_vec, node->uid);\n }\n \n /* Estimate the growth of the caller when inlining EDGE.  */\n@@ -39,12 +63,8 @@ static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n   int call_stmt_size;\n-  /* ???  We throw away cgraph edges all the time so the information\n-     we store in edges doesn't persist for early inlining.  Ugh.  */\n-  if (!edge->call_stmt)\n-    call_stmt_size = edge->call_stmt_size;\n-  else\n-    call_stmt_size = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+  call_stmt_size = edge->call_stmt_size;\n+  gcc_checking_assert (call_stmt_size);\n   return (edge->callee->global.size\n \t  - inline_summary (edge->callee)->size_inlining_benefit\n \t  - call_stmt_size);"}, {"sha": "9a50ce2c007461bb5b24e479e6c6a3c232ecb9a9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -1998,7 +1998,7 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \n static void\n ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n-\t\t\t   __attribute__((unused)) void *data)\n+\t\t\t   ATTRIBUTE_UNUSED void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n   int param_count, i;"}, {"sha": "84a3d97e8a9b609bde904723eb92ecb1d7024e1e", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -517,6 +517,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      }\n \t  }\n       }\n+  if (file)\n+    fprintf (file, \"\\n\");\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph ();"}, {"sha": "c1544577dd5a28171a770dcfe4ab42c4ec071ab6", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -465,16 +465,6 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   if (tag == LTO_cgraph_analyzed_node)\n     {\n-      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t node->local.inline_summary.estimated_self_stack_size);\n-      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t node->local.inline_summary.self_size);\n-      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t node->local.inline_summary.size_inlining_benefit);\n-      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t node->local.inline_summary.self_time);\n-      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t node->local.inline_summary.time_inlining_benefit);\n       if (node->global.inlined_to)\n \t{\n \t  ref = lto_cgraph_encoder_lookup (encoder, node->global.inlined_to);\n@@ -930,23 +920,9 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      struct cgraph_node *node,\n \t\t      enum LTO_cgraph_tags tag,\n \t\t      struct bitpack_d *bp,\n-\t\t      unsigned int stack_size,\n-\t\t      unsigned int self_time,\n-\t\t      unsigned int time_inlining_benefit,\n-\t\t      unsigned int self_size,\n-\t\t      unsigned int size_inlining_benefit,\n \t\t      enum ld_plugin_symbol_resolution resolution)\n {\n   node->aux = (void *) tag;\n-  node->local.inline_summary.estimated_self_stack_size = stack_size;\n-  node->local.inline_summary.self_time = self_time;\n-  node->local.inline_summary.time_inlining_benefit = time_inlining_benefit;\n-  node->local.inline_summary.self_size = self_size;\n-  node->local.inline_summary.size_inlining_benefit = size_inlining_benefit;\n-  node->global.time = self_time;\n-  node->global.size = self_size;\n-  node->global.estimated_stack_size = stack_size;\n-  node->global.estimated_growth = INT_MIN;\n   node->local.lto_file_data = file_data;\n \n   node->local.local = bp_unpack_value (bp, 1);\n@@ -1023,13 +999,8 @@ input_node (struct lto_file_decl_data *file_data,\n   tree fn_decl;\n   struct cgraph_node *node;\n   struct bitpack_d bp;\n-  int stack_size = 0;\n   unsigned decl_index;\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n-  int self_time = 0;\n-  int self_size = 0;\n-  int time_inlining_benefit = 0;\n-  int size_inlining_benefit = 0;\n   unsigned long same_body_count = 0;\n   int clone_ref;\n   enum ld_plugin_symbol_resolution resolution;\n@@ -1051,15 +1022,7 @@ input_node (struct lto_file_decl_data *file_data,\n   node->count_materialization_scale = lto_input_sleb128 (ib);\n \n   if (tag == LTO_cgraph_analyzed_node)\n-    {\n-      stack_size = lto_input_sleb128 (ib);\n-      self_size = lto_input_sleb128 (ib);\n-      size_inlining_benefit = lto_input_sleb128 (ib);\n-      self_time = lto_input_sleb128 (ib);\n-      time_inlining_benefit = lto_input_sleb128 (ib);\n-\n-      ref = lto_input_sleb128 (ib);\n-    }\n+    ref = lto_input_sleb128 (ib);\n \n   ref2 = lto_input_sleb128 (ib);\n \n@@ -1073,9 +1036,7 @@ input_node (struct lto_file_decl_data *file_data,\n \n   bp = lto_input_bitpack (ib);\n   resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n-  input_overwrite_node (file_data, node, tag, &bp, stack_size, self_time,\n-  \t\t\ttime_inlining_benefit, self_size,\n-\t\t\tsize_inlining_benefit, resolution);\n+  input_overwrite_node (file_data, node, tag, &bp, resolution);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;"}, {"sha": "e7928c4b971fc90c60993b23a543c528569d3bf8", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -58,7 +58,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"reference\",\n   \"symtab\",\n   \"opts\",\n-  \"cgraphopt\"\n+  \"cgraphopt\",\n+  \"inline\"\n };\n \n unsigned char"}, {"sha": "5d1f15a783ee3dc4fd21a3553d73fa83c436902a", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -264,6 +264,7 @@ enum lto_section_type\n   LTO_section_symtab,\n   LTO_section_opts,\n   LTO_section_cgraph_opt_sum,\n+  LTO_section_inline_summary,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "45dd300dedddd27980078cef8256df01257f050b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -1,3 +1,10 @@\n+2011-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c: Include ipa-inline.h\n+\t(add_cgraph_node_to_partition, undo_partition): Use inline_summary accessor.\n+\t(ipa_node_duplication_hook): Fix declaration.\n+\t* Make-lang.in (lto.o): Update dependencies.\n+\n 2011-04-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* lto-tree.h (union lang_tree_node): Check for TS_COMMON before"}, {"sha": "5287c12708885c44e087f0d072c7f49cff3ea46e", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -85,7 +85,8 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n \t$(CGRAPH_H) $(GGC_H) tree-ssa-operands.h $(TREE_PASS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n-\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H)\n+\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H) \\\n+\tipa-inline.h\n lto/lto-object.o: lto/lto-object.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(DIAGNOSTIC_CORE_H) $(LTO_H) $(TM_H) $(LTO_STREAMER_H) \\\n \t../include/simple-object.h"}, {"sha": "9103af45202ab3fb883fbb402d1aaa5f34a2aa20", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"splay-tree.h\"\n #include \"params.h\"\n+#include \"ipa-inline.h\"\n \n static GTY(()) tree first_personality_decl;\n \n@@ -750,7 +751,7 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n \n-  part->insns += node->local.inline_summary.self_size;\n+  part->insns += inline_summary (node)->self_size;\n \n   if (node->aux)\n     {\n@@ -811,7 +812,7 @@ undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n       struct cgraph_node *node = VEC_index (cgraph_node_ptr,\n \t\t\t\t\t    partition->cgraph_set->nodes,\n \t\t\t\t\t    n_cgraph_nodes);\n-      partition->insns -= node->local.inline_summary.self_size;\n+      partition->insns -= inline_summary (node)->self_size;\n       cgraph_node_set_remove (partition->cgraph_set, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }"}]}