{"sha": "7eea64437a974d93e6a99163ecb3d1b97d1c7e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VlYTY0NDM3YTk3NGQ5M2U2YTk5MTYzZWNiM2QxYjk3ZDFjN2UwZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-25T22:58:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-25T22:58:40Z"}, "message": "haifa-sched.c (find_post_sched_live): Use EXECUTE_IF_SET_IN_REG_SET instead of calling REGNO_REG_SET_P for each pseudo.\n\n        * haifa-sched.c (find_post_sched_live): Use EXECUTE_IF_SET_IN_REG_SET\n        instead of calling REGNO_REG_SET_P for each pseudo.\n        (update_reg_usage): Likewise.\n        (compute_block_backward)dependences): Do not call \"free_list\" for\n        an empty list.\nImproves compile times by about 7% on average on my PAs.\n\nFrom-SVN: r18835", "tree": {"sha": "f8ea138a4bb0bdb07c16f9bb76170f286a051b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8ea138a4bb0bdb07c16f9bb76170f286a051b98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d/comments", "author": null, "committer": null, "parents": [{"sha": "b09fa78719a041808a6cdb39517cba95a47cb4a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09fa78719a041808a6cdb39517cba95a47cb4a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b09fa78719a041808a6cdb39517cba95a47cb4a7"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "967e8689a37b48a3877004ec11fc1cb853529c0b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eea64437a974d93e6a99163ecb3d1b97d1c7e0d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7eea64437a974d93e6a99163ecb3d1b97d1c7e0d", "patch": "@@ -5163,9 +5163,10 @@ find_post_sched_live (bb)\n   next_tail = NEXT_INSN (tail);\n   prev_head = PREV_INSN (head);\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (REGNO_REG_SET_P (bb_live_regs, i))\n-      sched_reg_basic_block[i] = REG_BLOCK_GLOBAL;\n+  EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, FIRST_PSEUDO_REGISTER, i,\n+\t\t\t     {\n+\t\t\t       sched_reg_basic_block[i] = REG_BLOCK_GLOBAL;\n+\t\t\t     });\n \n   /* if the block is empty, same regs are alive at its end and its start.\n      since this is not guaranteed after interblock scheduling, make sure they\n@@ -5314,9 +5315,11 @@ update_reg_usage ()\n   int regno;\n \n   if (n_basic_blocks > 0)\n-    for (regno = FIRST_PSEUDO_REGISTER; regno < max_regno; regno++)\n-      if (REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n-\tsched_reg_basic_block[regno] = REG_BLOCK_GLOBAL;\n+    EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, FIRST_PSEUDO_REGISTER, regno,\n+\t\t\t       {\n+\t\t\t\t sched_reg_basic_block[regno]\n+\t\t\t\t   = REG_BLOCK_GLOBAL;\n+\t\t\t       });\n \n   for (regno = 0; regno < max_regno; regno++)\n     if (sched_reg_live_length[regno])\n@@ -7220,11 +7223,19 @@ compute_block_backward_dependences (bb)\n \twhile (e != first_edge);\n     }\n \n-  /* Free up the INSN_LISTs */\n+  /* Free up the INSN_LISTs \n+\n+     Note this loop is executed max_reg * nr_regions times.  It's first \n+     implementation accounted for over 90% of the calls to free_list.\n+     The list was empty for the vast majority of those calls.  On the PA,\n+     not calling free_list in those cases improves -O2 compile times by\n+     3-5% on average.  */\n   for (b = 0; b < max_reg; ++b)\n     {\n-      free_list (&reg_last_sets[b], &unused_insn_list);\n-      free_list (&reg_last_uses[b], &unused_insn_list);\n+      if (reg_last_sets[b])\n+\tfree_list (&reg_last_sets[b], &unused_insn_list);\n+      if (reg_last_uses[b])\n+\tfree_list (&reg_last_uses[b], &unused_insn_list);\n     }\n \n   /* Assert that we won't need bb_reg_last_* for this block anymore.  */"}]}