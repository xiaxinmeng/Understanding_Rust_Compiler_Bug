{"sha": "43e720723ff64cdbed12173248b783938173ab0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlNzIwNzIzZmY2NGNkYmVkMTIxNzMyNDhiNzgzOTM4MTczYWIwYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-04-20T07:56:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-04-20T07:56:50Z"}, "message": "gcse.c (gcse_main): Fix comment typo.\n\n\t* gcse.c (gcse_main): Fix comment typo.\n\t(delete_null_pointer_check): Likewise.\n\t(hash_scan_set): Don't consider sets with REG_EQUIV MEM notes.\n\t* cse.c (cse_insn): Likewise.\n\t* function.c (fixup_var_refs_insns_with_hash): The sequence is\n\ttoplevel.\n\n\t* gcc.c-torture/execute/20010403-1.c: New test.\n\nFrom-SVN: r41444", "tree": {"sha": "4120801b04df0c391df22ca45c74588def05e73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4120801b04df0c391df22ca45c74588def05e73a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e720723ff64cdbed12173248b783938173ab0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e720723ff64cdbed12173248b783938173ab0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e720723ff64cdbed12173248b783938173ab0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e720723ff64cdbed12173248b783938173ab0a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c8378a7a2662941f64ef85e359ee0465c49c712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c8378a7a2662941f64ef85e359ee0465c49c712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c8378a7a2662941f64ef85e359ee0465c49c712"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "6de127a3dccd996a5191e1f9adebd0743fb07380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e720723ff64cdbed12173248b783938173ab0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e720723ff64cdbed12173248b783938173ab0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43e720723ff64cdbed12173248b783938173ab0a", "patch": "@@ -1,3 +1,12 @@\n+2001-04-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcse.c (gcse_main): Fix comment typo.\n+\t(delete_null_pointer_check): Likewise.\n+\t(hash_scan_set): Don't consider sets with REG_EQUIV MEM notes.\n+\t* cse.c (cse_insn): Likewise.\n+\t* function.c (fixup_var_refs_insns_with_hash): The sequence is\n+\ttoplevel.\n+\n 2001-04-19  Zack Weinberg  <zackw@stanford.edu>\n \n \t* toplev.c: Excise all code for the undocumented -dm option."}, {"sha": "652dbf0460b51ee19052c7ee12dbab154e93dc34", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=43e720723ff64cdbed12173248b783938173ab0a", "patch": "@@ -5067,18 +5067,16 @@ cse_insn (insn, libcall_insn)\n       sets[i].src_in_memory = hash_arg_in_memory;\n \n       /* If SRC is a MEM, there is a REG_EQUIV note for SRC, and DEST is\n-\t a pseudo that is set more than once, do not record SRC.  Using\n-\t SRC as a replacement for anything else will be incorrect in that\n-\t situation.  Note that this usually occurs only for stack slots,\n-\t in which case all the RTL would be referring to SRC, so we don't\n-\t lose any optimization opportunities by not having SRC in the\n-\t hash table.  */\n+\t a pseudo, do not record SRC.  Using SRC as a replacement for\n+\t anything else will be incorrect in that situation.  Note that\n+\t this usually occurs only for stack slots, in which case all the\n+\t RTL would be referring to SRC, so we don't lose any optimization\n+\t opportunities by not having SRC in the hash table.  */\n \n       if (GET_CODE (src) == MEM\n-\t  && find_reg_note (insn, REG_EQUIV, src) != 0\n+\t  && find_reg_note (insn, REG_EQUIV, NULL_RTX) != 0\n \t  && GET_CODE (dest) == REG\n-\t  && REGNO (dest) >= FIRST_PSEUDO_REGISTER\n-\t  && REG_N_SETS (REGNO (dest)) != 1)\n+\t  && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n \tsets[i].src_volatile = 1;\n \n #if 0"}, {"sha": "8de57df0ddb5ac548204e3575feefa4d30e8007a", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=43e720723ff64cdbed12173248b783938173ab0a", "patch": "@@ -1682,7 +1682,7 @@ fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n       rtx insn = XEXP (insn_list, 0);\n \t\n       if (INSN_P (insn))\n-\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, 0);\n+\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, 1);\n \n       insn_list = XEXP (insn_list, 1);\n     }"}, {"sha": "dc531c56c7fdf26a8b9e4aba63ba09f2b7a9383d", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=43e720723ff64cdbed12173248b783938173ab0a", "patch": "@@ -756,7 +756,7 @@ gcse_main (f, file)\n      a high connectivity will take a long time and is unlikely to be\n      particularly useful.\n \n-     In normal circumstances a cfg should have about twice has many edges\n+     In normal circumstances a cfg should have about twice as many edges\n      as blocks.  But we do not want to punish small functions which have\n      a couple switch statements.  So we require a relatively large number\n      of basic blocks and the ratio of edges to blocks to be high.  */\n@@ -2208,7 +2208,14 @@ hash_scan_set (pat, insn, set_p)\n \t  /* Is SET_SRC something we want to gcse?  */\n \t  && want_to_gcse_p (src)\n \t  /* Don't CSE a nop.  */\n-\t  && ! set_noop_p (pat))\n+\t  && ! set_noop_p (pat)\n+\t  /* Don't GCSE if it has attached REG_EQUIV note.\n+\t     At this point this only function parameters should have\n+\t     REG_EQUIV notes and if the argument slot is used somewhere\n+\t     explicitely, it means address of parameter has been taken,\n+\t     so we should not extend the lifetime of the pseudo.  */\n+\t  && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n+\t      || GET_CODE (XEXP (note, 0)) != MEM))\n \t{\n \t  /* An expression is not anticipatable if its operands are\n \t     modified before this insn or if this is not the only SET in\n@@ -5541,7 +5548,7 @@ delete_null_pointer_checks (f)\n      a high connectivity will take a long time and is unlikely to be\n      particularly useful.\n \n-     In normal circumstances a cfg should have about twice has many edges\n+     In normal circumstances a cfg should have about twice as many edges\n      as blocks.  But we do not want to punish small functions which have\n      a couple switch statements.  So we require a relatively large number\n      of basic blocks and the ratio of edges to blocks to be high.  */"}, {"sha": "78f191ff07424414509631d832d392c01b7ca105", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e720723ff64cdbed12173248b783938173ab0a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43e720723ff64cdbed12173248b783938173ab0a", "patch": "@@ -1,3 +1,7 @@\n+2001-04-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20010403-1.c: New test.\n+\n 2001-04-19  David Billinghurst <David.Billinghurst@riotinto.com>\n \t    Mark Mitchell  <mark@codesourcery.com>\n "}]}