{"sha": "37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhMTg1ZDc5ZTYzMGZkM2FkNWFjZDdhYzVhMjlhYzA3YTViZTRkNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T18:50:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T18:50:52Z"}, "message": "mn10300: Emit retf instruction\n\nNow that we properly track the life of MDR, we can emit\nthe RETF instruction if MDR has not been modified.  This\ninsn is 3-4 cycles faster since the return address is\nalready loaded.\n\nFrom-SVN: r169013", "tree": {"sha": "066424705d9da85f89031dc6070862c03f1f11cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/066424705d9da85f89031dc6070862c03f1f11cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/comments", "author": null, "committer": null, "parents": [{"sha": "040c57570147b0a05c29339dd778378b8cf15a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040c57570147b0a05c29339dd778378b8cf15a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040c57570147b0a05c29339dd778378b8cf15a56"}], "stats": {"total": 118, "additions": 69, "deletions": 49}, "files": [{"sha": "46cb38358367d8dc8a444a2bf913215504b94ced", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "patch": "@@ -1,5 +1,13 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_can_use_retf_insn): New.\n+\t(mn10300_can_use_rets_insn): Rename from mn10300_can_use_return_insn.\n+\t(mn10300_expand_epilogue): Use it.  Compute REG_SAVE_BYTES once.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\t* config/mn10300/mn10300.md (return): Use mn10300_can_use_retf_insn.\n+\t(return_ret): Likewise.  Rename from return_internal_regs.\n+\t(return_internal): Remove.\n+\n \t* config/mn10300/mn10300.c (mn10300_unspec_int_label_counter): Remove.\n \t(mn10300_asm_output_addr_const_extra): Don't handle UNSPEC_INT_LABEL.\n \t(mn10300_legitimate_constant_p): Likewise."}, {"sha": "058f5df87511bcb5f07a8e8516e3b802fc54dde3", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "patch": "@@ -45,7 +45,8 @@ extern bool  mn10300_match_ccmode (rtx, Mmode);\n #endif /* RTX_CODE */\n \n extern bool  mn10300_regno_in_class_p (unsigned, int, bool);\n-extern int   mn10300_can_use_return_insn (void);\n+extern bool  mn10300_can_use_rets_insn (void);\n+extern bool  mn10300_can_use_retf_insn (void);\n extern void  mn10300_expand_prologue (void);\n extern void  mn10300_expand_epilogue (void);\n extern int   mn10300_initial_offset (int, int);"}, {"sha": "8a042f658a4e3a1f675aa70f7d4c71c065c1f81a", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "patch": "@@ -623,8 +623,33 @@ mn10300_print_reg_list (FILE *file, int mask)\n   fputc (']', file);\n }\n \n-int\n-mn10300_can_use_return_insn (void)\n+/* If the MDR register is never clobbered, we can use the RETF instruction\n+   which takes the address from the MDR register.  This is 3 cycles faster\n+   than having to load the address from the stack.  */\n+\n+bool\n+mn10300_can_use_retf_insn (void)\n+{\n+  /* Don't bother if we're not optimizing.  In this case we won't\n+     have proper access to df_regs_ever_live_p.  */\n+  if (!optimize)\n+    return false;\n+\n+  /* EH returns alter the saved return address; MDR is not current.  */\n+  if (crtl->calls_eh_return)\n+    return false;\n+\n+  /* Obviously not if MDR is ever clobbered.  */\n+  if (df_regs_ever_live_p (MDR_REG))\n+    return false;\n+\n+  /* ??? Careful not to use this during expand_epilogue etc.  */\n+  gcc_assert (!in_sequence_p ());\n+  return leaf_function_p ();\n+}\n+\n+bool\n+mn10300_can_use_rets_insn (void)\n {\n   return !mn10300_initial_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM);\n }\n@@ -995,6 +1020,7 @@ void\n mn10300_expand_epilogue (void)\n {\n   HOST_WIDE_INT size = mn10300_frame_size ();\n+  int reg_save_bytes = REG_SAVE_BYTES;\n   \n   if (TARGET_AM33_2 && fp_regs_to_save ())\n     {\n@@ -1026,14 +1052,14 @@ mn10300_expand_epilogue (void)\n \t  this_strategy_size = SIZE_FMOV_SP (size, num_regs_to_save);\n \t  /* If size is too large, we'll have to adjust SP with an\n \t\t add.  */\n-\t  if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t  if (size + 4 * num_regs_to_save + reg_save_bytes > 255)\n \t    {\n \t      /* Insn: add size + 4 * num_regs_to_save, sp.  */\n \t      this_strategy_size += SIZE_ADD_SP (size + 4 * num_regs_to_save);\n \t    }\n \t  /* If we don't have to restore any non-FP registers,\n \t\t we'll be able to save one byte by using rets.  */\n-\t  if (! REG_SAVE_BYTES)\n+\t  if (! reg_save_bytes)\n \t    this_strategy_size--;\n \n \t  if (this_strategy_size < strategy_size)\n@@ -1060,14 +1086,14 @@ mn10300_expand_epilogue (void)\n \t     When size is close to 32Kb, we may be able to adjust SP\n \t     with an imm16 add instruction while still using fmov\n \t     (d8,sp).  */\n-\t  if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t  if (size + 4 * num_regs_to_save + reg_save_bytes > 255)\n \t    {\n \t      /* Insn: add size + 4 * num_regs_to_save\n-\t\t\t\t+ REG_SAVE_BYTES - 252,sp.  */\n+\t\t\t\t+ reg_save_bytes - 252,sp.  */\n \t      this_strategy_size = SIZE_ADD_SP (size + 4 * num_regs_to_save\n-\t\t\t\t\t\t+ REG_SAVE_BYTES - 252);\n+\t\t\t\t\t\t+ reg_save_bytes - 252);\n \t      /* Insn: fmov (##,sp),fs#, fo each fs# to be restored.  */\n-\t      this_strategy_size += SIZE_FMOV_SP (252 - REG_SAVE_BYTES\n+\t      this_strategy_size += SIZE_FMOV_SP (252 - reg_save_bytes\n \t\t\t\t\t\t  - 4 * num_regs_to_save,\n \t\t\t\t\t\t  num_regs_to_save);\n \t      /* We're going to use ret to release the FP registers\n@@ -1096,14 +1122,14 @@ mn10300_expand_epilogue (void)\n \t      this_strategy_size += 3 * num_regs_to_save;\n \t      /* If size is large enough, we may be able to save a\n \t\t couple of bytes.  */\n-\t      if (size + 4 * num_regs_to_save + REG_SAVE_BYTES > 255)\n+\t      if (size + 4 * num_regs_to_save + reg_save_bytes > 255)\n \t\t{\n \t\t  /* Insn: mov a1,sp.  */\n \t\t  this_strategy_size += 2;\n \t\t}\n \t      /* If we don't have to restore any non-FP registers,\n \t\t we'll be able to save one byte by using rets.  */\n-\t      if (! REG_SAVE_BYTES)\n+\t      if (! reg_save_bytes)\n \t\tthis_strategy_size--;\n \n \t      if (this_strategy_size < strategy_size)\n@@ -1129,8 +1155,8 @@ mn10300_expand_epilogue (void)\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t     stack_pointer_rtx,\n \t\t\t\t     GEN_INT (size + 4 * num_regs_to_save\n-\t\t\t\t\t      + REG_SAVE_BYTES - 252)));\n-\t      size = 252 - REG_SAVE_BYTES - 4 * num_regs_to_save;\n+\t\t\t\t\t      + reg_save_bytes - 252)));\n+\t      size = 252 - reg_save_bytes - 4 * num_regs_to_save;\n \t      break;\n \n \t    case restore_a1:\n@@ -1176,7 +1202,7 @@ mn10300_expand_epilogue (void)\n       /* If we were using the restore_a1 strategy and the number of\n \t bytes to be released won't fit in the `ret' byte, copy `a1'\n \t to `sp', to avoid having to use `add' to adjust it.  */\n-      if (! frame_pointer_needed && reg && size + REG_SAVE_BYTES > 255)\n+      if (! frame_pointer_needed && reg && size + reg_save_bytes > 255)\n \t{\n \t  emit_move_insn (stack_pointer_rtx, XEXP (reg, 0));\n \t  size = 0;\n@@ -1203,7 +1229,7 @@ mn10300_expand_epilogue (void)\n       emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n       size = 0;\n     }\n-  else if (size + REG_SAVE_BYTES > 255)\n+  else if (size + reg_save_bytes > 255)\n     {\n       emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t     stack_pointer_rtx,\n@@ -1212,15 +1238,10 @@ mn10300_expand_epilogue (void)\n     }\n \n   /* Adjust the stack and restore callee-saved registers, if any.  */\n-  if (size || df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n-      || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n-      || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n-      || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n-      || frame_pointer_needed)\n-    emit_jump_insn (gen_return_internal_regs\n-\t\t    (GEN_INT (size + REG_SAVE_BYTES)));\n+  if (mn10300_can_use_rets_insn ())\n+    emit_jump_insn (gen_rtx_RETURN (VOIDmode));\n   else\n-    emit_jump_insn (gen_return_internal ());\n+    emit_jump_insn (gen_return_ret (GEN_INT (size + REG_SAVE_BYTES)));\n }\n \n /* Recognize the PARALLEL rtx generated by mn10300_gen_multiple_store()."}, {"sha": "f3f6baf217a876fcd649ad55215ddaa0187fe46b", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "patch": "@@ -1607,31 +1607,28 @@\n   { mn10300_expand_epilogue (); DONE; }\n )\n \n-(define_insn \"return_internal\"\n-  [(const_int 2)\n-   (return)]\n-  \"\"\n-  \"rets\"\n-  [(set_attr \"timings\" \"66\")]\n-)\n+(define_insn \"return\"\n+  [(return)]\n+  \"mn10300_can_use_rets_insn ()\"\n+{\n+  /* The RETF insn is 4 cycles faster than RETS, though 1 byte larger.  */\n+  if (optimize_insn_for_speed_p () && mn10300_can_use_retf_insn ())\n+    return \"retf [],0\";\n+  else\n+    return \"rets\";\n+})\n \n-;; This insn restores the callee saved registers and does a return, it\n-;; can also deallocate stack space.\n-(define_insn \"return_internal_regs\"\n-  [(const_int 0)\n-   (match_operand:SI 0  \"const_int_operand\" \"i\")\n-   (return)]\n+(define_insn \"return_ret\"\n+  [(return)\n+   (use (match_operand:SI 0 \"const_int_operand\" \"\"))]\n   \"\"\n {\n-  fputs (\"\\tret \", asm_out_file);\n+  /* The RETF insn is up to 3 cycles faster than RET.  */\n+  fputs ((mn10300_can_use_retf_insn () ? \"\\tretf \" : \"\\tret \"), asm_out_file);\n   mn10300_print_reg_list (asm_out_file, mn10300_get_live_callee_saved_regs ());\n   fprintf (asm_out_file, \",%d\\n\", (int) INTVAL (operands[0]));\n   return \"\";\n-}\n-  ;; Assumes that there will be no more than 8 regs to pop\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 1414) (const_int 1313)))]\n-)\n+})\n \n ;; This instruction matches one generated by mn10300_gen_multiple_store()\n (define_insn \"store_movm\"\n@@ -1651,13 +1648,6 @@\n \t\t\t\t       (const_int 99) (const_int 88)))]\n )\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"mn10300_can_use_return_insn ()\"\n-  \"rets\"\n-  [(set_attr \"timings\" \"66\")]\n-)\n-\n (define_expand \"load_pic\"\n   [(const_int 0)]\n   \"flag_pic\""}]}