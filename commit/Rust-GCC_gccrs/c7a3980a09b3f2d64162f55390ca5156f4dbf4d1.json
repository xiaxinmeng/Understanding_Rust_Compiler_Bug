{"sha": "c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhMzk4MGEwOWIzZjJkNjQxNjJmNTUzOTBjYTUxNTZmNGRiZjRkMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-10T08:52:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-10T08:52:36Z"}, "message": "re PR middle-end/41254 (crashed compile Qt4 gui library)\n\n2009-09-10  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/41254\n\t* tree.c (struct free_lang_data_d): Add worklist member.\n\t(find_decls_types_r): Push onto the worklist instead of recursing.\n\tHandle TREE_BINFOs properly.\n\t(find_decls_types): New function wrapped around find_decls_types_r\n\tto process the worklist.\n\t(find_decls_types_in_eh_region): Use it.\n\t(find_decls_types_in_node): Likewise.\n\t(find_decls_types_in_var): Likewise.\n\t(free_lang_data_in_cgraph): Likewise.  Free the worklist.\n\t* tree.h (RECORD_OR_UNION_TYPE_P): New.\n\t(AGGREGATE_TYPE_P): Adjust.\n\nFrom-SVN: r151590", "tree": {"sha": "1fe0e7a8182c821981f72fe98a9bb4fe78627690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe0e7a8182c821981f72fe98a9bb4fe78627690"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7cb4dfec24da6c3a44ca7d20237f2e08cb92d495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb4dfec24da6c3a44ca7d20237f2e08cb92d495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cb4dfec24da6c3a44ca7d20237f2e08cb92d495"}], "stats": {"total": 171, "additions": 106, "deletions": 65}, "files": [{"sha": "2e2d86d1f505d79ffcd079866e5277b5308ce800", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "patch": "@@ -1,3 +1,18 @@\n+2009-09-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/41254\n+\t* tree.c (struct free_lang_data_d): Add worklist member.\n+\t(find_decls_types_r): Push onto the worklist instead of recursing.\n+\tHandle TREE_BINFOs properly.\n+\t(find_decls_types): New function wrapped around find_decls_types_r\n+\tto process the worklist.\n+\t(find_decls_types_in_eh_region): Use it.\n+\t(find_decls_types_in_node): Likewise.\n+\t(find_decls_types_in_var): Likewise.\n+\t(free_lang_data_in_cgraph): Likewise.  Free the worklist.\n+\t* tree.h (RECORD_OR_UNION_TYPE_P): New.\n+\t(AGGREGATE_TYPE_P): Adjust.\n+\n 2009-09-09  Jason Merrill  <jason@redhat.com>\n \n \t* configure.ac: Check glibc version even if we have an in-tree"}, {"sha": "2f0e03c8e2242a5c138c0e4be128f98b6d042278", "filename": "gcc/tree.c", "status": "modified", "additions": 84, "deletions": 63, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "patch": "@@ -4447,6 +4447,9 @@ free_lang_data_in_decl (tree decl)\n \n struct free_lang_data_d\n {\n+  /* Worklist to avoid excessive recursion.  */\n+  VEC(tree,heap) *worklist;\n+\n   /* Set of traversed objects.  Used to avoid duplicate visits.  */\n   struct pointer_set_t *pset;\n \n@@ -4508,6 +4511,9 @@ add_tree_to_fld_list (tree t, struct free_lang_data_d *fld)\n     gcc_unreachable ();\n }\n \n+#define PUSH(t) \\\n+    if (t && !pointer_set_contains (fld->pset, t)) \\\n+      VEC_safe_push (tree, heap, fld->worklist, (t))\n \n /* Operand callback helper for free_lang_data_in_node.  *TP is the\n    subtree operand being considered.  */\n@@ -4518,86 +4524,105 @@ find_decls_types_r (tree *tp, int *ws ATTRIBUTE_UNUSED, void *data)\n   tree t = *tp;\n   struct free_lang_data_d *fld = (struct free_lang_data_d *) data;\n \n+  if (TREE_CODE (t) == TREE_LIST)\n+    return NULL_TREE;\n+\n   if (DECL_P (t))\n     {\n       /* Note that walk_tree does not traverse every possible field in\n \t decls, so we have to do our own traversals here.  */\n       add_tree_to_fld_list (t, fld);\n \n-      walk_tree (&DECL_NAME (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_CONTEXT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_SIZE (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_SIZE_UNIT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_INITIAL (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_ATTRIBUTES (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&DECL_ABSTRACT_ORIGIN (t), find_decls_types_r, fld, fld->pset);\n+      PUSH (DECL_NAME (t));\n+      PUSH (DECL_CONTEXT (t));\n+      PUSH (DECL_SIZE (t));\n+      PUSH (DECL_SIZE_UNIT (t));\n+      PUSH (DECL_INITIAL(t));\n+      PUSH (DECL_ATTRIBUTES (t));\n+      PUSH (DECL_ABSTRACT_ORIGIN (t));\n \n       if (TREE_CODE (t) == FUNCTION_DECL)\n \t{\n-\t  walk_tree (&DECL_ARGUMENTS (t), find_decls_types_r, fld, fld->pset);\n-\t  walk_tree (&DECL_RESULT (t), find_decls_types_r, fld, fld->pset);\n+\t  PUSH (DECL_ARGUMENTS (t));\n+\t  PUSH (DECL_RESULT (t));\n \t}\n       else if (TREE_CODE (t) == TYPE_DECL)\n \t{\n-\t  walk_tree (&DECL_ARGUMENT_FLD (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n-\t  walk_tree (&DECL_VINDEX (t), find_decls_types_r, fld, fld->pset);\n+\t  PUSH (DECL_ARGUMENT_FLD (t));\n+\t  PUSH (DECL_VINDEX (t));\n \t}\n       else if (TREE_CODE (t) == FIELD_DECL)\n \t{\n-\t  walk_tree (&DECL_FIELD_OFFSET (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n-\t  walk_tree (&DECL_BIT_FIELD_TYPE (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n-\t  walk_tree (&DECL_QUALIFIER (t), find_decls_types_r, fld, fld->pset);\n-\t  walk_tree (&DECL_FIELD_BIT_OFFSET (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n-\t  walk_tree (&DECL_FCONTEXT (t), find_decls_types_r, fld, fld->pset);\n+\t  PUSH (DECL_FIELD_OFFSET (t));\n+\t  PUSH (DECL_BIT_FIELD_TYPE (t));\n+\t  PUSH (DECL_QUALIFIER (t));\n+\t  PUSH (DECL_FIELD_BIT_OFFSET (t));\n+\t  PUSH (DECL_FCONTEXT (t));\n \t}\n       else if (TREE_CODE (t) == VAR_DECL)\n \t{\n-\t  walk_tree (&DECL_SECTION_NAME (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n-\t  walk_tree (&DECL_COMDAT_GROUP (t), find_decls_types_r, fld,\n-\t\t     fld->pset);\n+\t  PUSH (DECL_SECTION_NAME (t));\n+\t  PUSH (DECL_COMDAT_GROUP (t));\n \t}\n+\n+      PUSH (TREE_CHAIN (t));\n+      *ws = 0;\n     }\n   else if (TYPE_P (t))\n     {\n       /* Note that walk_tree does not traverse every possible field in\n \t types, so we have to do our own traversals here.  */\n       add_tree_to_fld_list (t, fld);\n \n-      walk_tree (&TYPE_CACHED_VALUES (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_SIZE (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_SIZE_UNIT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_ATTRIBUTES (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_POINTER_TO (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_REFERENCE_TO (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_NAME (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_MINVAL (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_MAXVAL (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_NEXT_VARIANT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_MAIN_VARIANT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_CONTEXT (t), find_decls_types_r, fld, fld->pset);\n-      walk_tree (&TYPE_CANONICAL (t), find_decls_types_r, fld, fld->pset);\n-    }\n-\n-  if (TREE_TYPE (t))\n-    walk_tree (&TREE_TYPE (t), find_decls_types_r, fld, fld->pset);\n+      PUSH (TYPE_CACHED_VALUES (t));\n+      PUSH (TYPE_SIZE (t));\n+      PUSH (TYPE_SIZE_UNIT (t));\n+      PUSH (TYPE_ATTRIBUTES (t));\n+      PUSH (TYPE_POINTER_TO (t));\n+      PUSH (TYPE_REFERENCE_TO (t));\n+      PUSH (TYPE_NAME (t));\n+      PUSH (TYPE_MINVAL (t));\n+      PUSH (TYPE_MAXVAL (t));\n+      PUSH (TYPE_MAIN_VARIANT (t));\n+      PUSH (TYPE_NEXT_VARIANT (t));\n+      PUSH (TYPE_CONTEXT (t));\n+      PUSH (TYPE_CANONICAL (t));\n+\n+      if (RECORD_OR_UNION_TYPE_P (t)\n+\t  && TYPE_BINFO (t))\n+\t{\n+\t  unsigned i;\n+\t  tree tem;\n+\t  for (i = 0; VEC_iterate (tree, BINFO_BASE_BINFOS (TYPE_BINFO (t)),\n+\t\t\t\t   i, tem); ++i)\n+\t    PUSH (TREE_TYPE (tem));\n+\t}\n \n-  /* Do not recurse into TREE_CHAIN to avoid blowing up the stack.  */\n-  for (tp = &TREE_CHAIN (t); *tp; tp = &TREE_CHAIN (*tp))\n-    {\n-      tree saved_chain = TREE_CHAIN (*tp);\n-      TREE_CHAIN (*tp) = NULL_TREE;\n-      walk_tree (tp, find_decls_types_r, fld, fld->pset);\n-      TREE_CHAIN (*tp) = saved_chain;\n+      PUSH (TREE_CHAIN (t));\n+      *ws = 0;\n     }\n \n+  PUSH (TREE_TYPE (t));\n+\n   return NULL_TREE;\n }\n \n+#undef PUSH\n+\n+/* Find decls and types in T.  */\n+\n+static void\n+find_decls_types (tree t, struct free_lang_data_d *fld)\n+{\n+  while (1)\n+    {\n+      if (!pointer_set_contains (fld->pset, t))\n+\twalk_tree (&t, find_decls_types_r, fld, fld->pset);\n+      if (VEC_empty (tree, fld->worklist))\n+\tbreak;\n+      t = VEC_pop (tree, fld->worklist);\n+    }\n+}\n \n /* Translate all the types in LIST with the corresponding runtime\n    types.  */\n@@ -4641,13 +4666,13 @@ find_decls_types_in_eh_region (eh_region r, struct free_lang_data_d *fld)\n     {\n       tree list = r->u.eh_catch.type_list;\n       r->u.eh_catch.type_list = get_eh_types_for_runtime (list);\n-      walk_tree (&r->u.eh_catch.type_list, find_decls_types_r, fld, fld->pset);\n+      find_decls_types (r->u.eh_catch.type_list, fld);\n     }\n   else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n     {\n       tree list = r->u.allowed.type_list;\n       r->u.allowed.type_list = get_eh_types_for_runtime (list);\n-      walk_tree (&r->u.allowed.type_list, find_decls_types_r, fld, fld->pset);\n+      find_decls_types (r->u.allowed.type_list, fld);\n     }\n }\n \n@@ -4665,7 +4690,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n   struct function *fn;\n   tree t;\n \n-  walk_tree (&n->decl, find_decls_types_r, fld, fld->pset);\n+  find_decls_types (n->decl, fld);\n \n   if (!gimple_has_body_p (n->decl))\n     return;\n@@ -4676,13 +4701,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n \n   /* Traverse locals. */\n   for (t = fn->local_decls; t; t = TREE_CHAIN (t))\n-    {\n-      tree *tp = &TREE_VALUE (t);\n-      tree saved_chain = TREE_CHAIN (*tp);\n-      TREE_CHAIN (*tp) = NULL_TREE;\n-      walk_tree (tp, find_decls_types_r, fld, fld->pset);\n-      TREE_CHAIN (*tp) = saved_chain;\n-    }\n+    find_decls_types (TREE_VALUE (t), fld);\n \n   /* Traverse EH regions in FN.  */\n   if (fn->eh->region_array)\n@@ -4707,7 +4726,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {\n \t      tree *arg_p = gimple_phi_arg_def_ptr (phi, i);\n-\t      walk_tree (arg_p, find_decls_types_r, fld, fld->pset);\n+\t      find_decls_types (*arg_p, fld);\n \t    }\n \t}\n \n@@ -4717,8 +4736,8 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n \n \t  for (i = 0; i < gimple_num_ops (stmt); i++)\n \t    {\n-\t      tree *arg_p = gimple_op_ptr (stmt, i);\n-\t      walk_tree (arg_p, find_decls_types_r, fld, fld->pset);\n+\t      tree arg = gimple_op (stmt, i);\n+\t      find_decls_types (arg, fld);\n \t    }\n \t}\n     }\n@@ -4734,7 +4753,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n static void\n find_decls_types_in_var (struct varpool_node *v, struct free_lang_data_d *fld)\n {\n-  walk_tree (&v->decl, find_decls_types_r, fld, fld->pset);\n+  find_decls_types (v->decl, fld);\n }\n \n \n@@ -4767,6 +4786,7 @@ free_lang_data_in_cgraph (void)\n \n   /* Initialize sets and arrays to store referenced decls and types.  */\n   fld.pset = pointer_set_create ();\n+  fld.worklist = NULL;\n   fld.decls = VEC_alloc (tree, heap, 100);\n   fld.types = VEC_alloc (tree, heap, 100);\n \n@@ -4775,7 +4795,7 @@ free_lang_data_in_cgraph (void)\n     find_decls_types_in_node (n, &fld);\n \n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n-    walk_tree (&p->decl, find_decls_types_r, &fld, fld.pset);\n+    find_decls_types (p->decl, &fld);\n \n   /* Find decls and types in every varpool symbol.  */\n   for (v = varpool_nodes_queue; v; v = v->next_needed)\n@@ -4815,6 +4835,7 @@ free_lang_data_in_cgraph (void)\n     free_lang_data_in_type (t);\n \n   pointer_set_destroy (fld.pset);\n+  VEC_free (tree, heap, fld.worklist);\n   VEC_free (tree, heap, fld.decls);\n   VEC_free (tree, heap, fld.types);\n }"}, {"sha": "c44b95b5bbd25a91775062e0adf10656de710731", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a3980a09b3f2d64162f55390ca5156f4dbf4d1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c7a3980a09b3f2d64162f55390ca5156f4dbf4d1", "patch": "@@ -1065,12 +1065,17 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n   (SCALAR_FLOAT_TYPE_P (TYPE)\t\t\t\\\n    && DECIMAL_FLOAT_MODE_P (TYPE_MODE (TYPE)))\n \n+/* Nonzero if TYPE is a record or union type.  */\n+#define RECORD_OR_UNION_TYPE_P(TYPE)\t\t\\\n+  (TREE_CODE (TYPE) == RECORD_TYPE\t\t\\\n+   || TREE_CODE (TYPE) == UNION_TYPE\t\t\\\n+   || TREE_CODE (TYPE) == QUAL_UNION_TYPE)\n+\n /* Nonzero if TYPE represents an aggregate (multi-component) type.\n    Keep these checks in ascending code order.  */\n \n #define AGGREGATE_TYPE_P(TYPE) \\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \\\n-   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE)\n+  (TREE_CODE (TYPE) == ARRAY_TYPE || RECORD_OR_UNION_TYPE_P (TYPE))\n \n /* Nonzero if TYPE represents a pointer or reference type.\n    (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in"}]}