{"sha": "cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmZTA5NmI0MDc4YmIxOGZmOGU5ZmFkOGNmZGNhNWFkMGI0OTE5MQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-05-01T02:33:13Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-05-01T02:33:13Z"}, "message": "Merge from rewrite branch.\n\nFrom-SVN: r66318", "tree": {"sha": "737ec79a7682fc9ba6748959af7ccb8ed03d759d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/737ec79a7682fc9ba6748959af7ccb8ed03d759d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/comments", "author": null, "committer": null, "parents": [{"sha": "6481daa9711df83b9c1a3f37710cf8afbd147a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6481daa9711df83b9c1a3f37710cf8afbd147a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6481daa9711df83b9c1a3f37710cf8afbd147a1c"}], "stats": {"total": 22080, "additions": 13753, "deletions": 8327}, "files": [{"sha": "c8dc55d1ad20f884b8d3f4b7e3b1e4ea191c5ee4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 561, "deletions": 2, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -1,3 +1,562 @@\n+2003-04-30  Eric Christopher  <echristo@redhat.com>\n+\t    Richard Sandiford <rsandifo@redhat.com>\n+\n+\t* configure: Regenerate from patches below.\n+\t* combine.c (gen_lowpart_for_combine): Fix comment and add tests\n+\tfor all symbolic operands.\n+\t* config/mips/mips.c: Migrate RTX_COSTS and CONST_COSTS\n+\tto function.\n+\t* config/mips/linux.h: Fix typo.\n+\t* Merge from mips-3_4-rewrite branch:\n+\n+\t2003-04-07  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (mips_classify_symbol): Add catch-all case for\n+\t        handling local labels when TARGET_ABICALLS.\n+\n+\t2003-04-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips_expand_epilogue): Add an\n+\t        integer argument.\n+\t        (mips_expand_call): Likewise.\n+\t        * config/mips/mips.h (TARGET_SIBCALLS): New macro.\n+\t        (FIXED_REGISTERS): Clear $31 entry.\n+\t        (CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTER): Likewise.\n+\t        (EPILOGUE_USES): Define.\n+\t        * config/mips/mips.c (mips_function_ok_for_sibcall): New function.\n+\t        (TARGET_FUNCTION_OK_FOR_SIBCALL): Use it.\n+\t        (override_options): Add a 'j' register class.\n+\t        (mips_expand_call): Handle sibcalls\n+\t        (mips_expand_epilogue): Handle epilogues for sibcalls.\n+\t        * config/mips/mips.md (epilogue): Adjust call to mips_expand_epilogue.\n+\t        (sibcall_epilogue): New pattern.\n+\t        (call, call_value): Adjust calls to mips_expand_call.\n+\t        (sibcall, sibcall_value): New expanders.\n+\t        (sibcall_internal, sibcall_value_internal): New patterns.\n+\t        (sibcall_value_multiple_internal): New pattern.\n+\n+\t2003-03-25  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.md (extended_mips16): New attribute.\n+\t        (define_attr length): Default to 8 if extended_mips16 == yes.\n+\t        (truncdisi2): Set extended_mips16 to yes for the sll alternative.\n+\t        (truncdihi2, truncdiqi2, *extendsidi2): Likewise.\n+\t        (call_internal): Set extended_mips16 to yes for direct jumps.\n+\t        Remove redundant mode attribute.\n+\t        (call_value_internal, call_value_multiple_internal): Likewise.\n+\t        (call_split): Remove redundant mode attribute.\n+\t        (call_value_split, call_value_multiple_split): Likewise.\n+\n+\t        * config/mips/mips.c (mips_symbol_insns): Rework.  Fix handling\n+\t        of unaligned offsets.\n+\n+\t       \t* config/mips/mips.c (mips_splittable_symbol_p): Fix handling\n+\t        of SYMBOL_GENERAL.\n+\n+\t2003-03-22  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (TARGET_EXPLICIT_RELOCS): Add commentary.\n+\t        * config/mips/mips.c (override_options): Disable -mexplicit-relocs\n+\t        for mips16 code.\n+\n+\t2003-03-22  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (ADDRESS_COST): Define.\n+\n+\t2003-03-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (EXTRA_CONSTRAINT): Give existing meaning of\n+\t        'R' to 'U'.  Make 'R' mean a single-instruction memory reference.\n+\t        * config/mips/mips.md: Replace 'R' constraints with 'U'.\n+\n+\t2003-03-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.md (truncdisi2): Add commentary.  Use sll instead\n+\t        of a two-instruction sequence.  Add register->memory alternative.\n+\t        (truncdihi2, truncdiqi2): Likewise.\n+\t        Rework shift/truncate instructions so that they only handle right\n+\t        shifts of 32 (or more, in the case of arithmetic shifts).\n+\t        Add patterns for truncate/sign-extend.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * configure.in (mips*-*-*): Check for explicit relocation support.\n+\t        * configure: Regenerate.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (TARGET_SWITCHES): Add -mexplicit-relocs\n+\t        and -mno-explicit-relocs.\n+\t        (MASK_EXPLICIT_RELOCS): Define.\n+\t        (TARGET_EXPLICIT_RELOCS): Use it.\n+\t        (mips_split_addresses): Remove declaration.\n+\t        * config/mips/mips.c (override_options): Update comment for\n+\t        mips_split_addresses.  Clear MASK_EXPLICIT_RELOCS for non-PIC n64.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * combine.c (gen_lowpart_for_combine): Treat the lowpart Pmode of\n+\t        a CONST as identity.  Check the return value of gen_lowpart_common.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (mips_legitimize_symbol): Handle small data\n+\t        references for TARGET_EXPLICIT_RELOCS.\n+\t        (mips_reloc_string): Return \"%gp_rel(\" for RELOC_GPREL16 if\n+\t        !TARGET_MIPS16.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.md: Replace 'IQ' mips16 constraints with just 'Q'.\n+\t        (addsi3): Remove redundant constraints.\n+\t        (addsi3_internal): Use separate register & constant alternatives.\n+\t        Use a 'Q' constraint and \"addiu\" insn for the latter.\n+\t        (adddi3_internal_3, addsi3_internal_2): Likewise.\n+\n+\t2003-03-13  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips_expand_unaligned_load): Declare.\n+\t        (mips_expand_unaligned_store): Declare.\n+\t        * config/mips/mips.c (mips_get_unaligned_mem): New fn.\n+\t        (mips_expand_unaligned_load, mips_expand_unaligned_store): New fns.\n+\t        * config/mips/mips.md (UNSPEC_ULW, UNSPEC_USW): Remove.\n+\t        (UNSPEC_ULD, UNSPEC_USD): Remove.\n+\t        (UNSPEC_LWL, UNSPEC_LWR, UNSPEC_SWL, UNSPEC_SWR): New.\n+\t        (UNSPEC_LDL, UNSPEC_LDR, UNSPEC_SDL, UNSPEC_SDR): New.\n+\t        (extv, extzv): Use mips_expand_unaligned_load.\n+\t        (insv): Use mips_expand_unaligned_store.  Use a reg_or_0_operand\n+\t        predicate for operand 3.\n+\t        (movsi_ulw, movsi_usw): Replace with...\n+\t        (mov_lwl, mov_lwr, mov_swl, move_swr): ...these new insns.\n+\t        (movdi_uld, movdi_usd): Likewise replace with...\n+\t        (mov_ldl, mov_ldr, mov_sdl, move_sdr): ...these insns.\n+\n+\t2003-02-26  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips_global_pic_constant_p): Declare.\n+\t        * config/mips/mips.h (LEA_REGS): New register class.\n+\t        (REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add entries for it.\n+\t        (GR_REG_CLASS_P): Include LEA_REGS.\n+\t        (DANGEROUS_FOR_LA25_P): New macro.\n+\t        (EXTRA_CONSTRAINT): Add !DANGEROUS_FOR_LA25_P to R's condition.\n+\t        Add a T constraint for the DANGEROUS_FOR_LA25_P case.\n+\t        * config/mips/mips.c (mips_regno_to_class): Change GR_REGS\n+\t        entries to LEA_REGS.\n+\t        (mips_global_pic_constant_p): New function.\n+\t        (override_options): Add 'e' register constraint.\n+\t        (mips_secondary_reload_class): Return LEA_REGS when reloading\n+\t        a dangerous constant into a class containing $25.\n+\t        * config/mips/mips.md (movdi_internal2): Add an e <- T alternative.\n+\t        (movsi_internal): Likewise.\n+\n+\t2003-02-23  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (TARGET_SPLIT_CALLS): New macro.\n+\t        * config/mips/mips.md (call_split): New insn.\n+\t        (call_value_split, call_value_multiple_split): New insns.\n+\t        (call_internal): Turn into a define_insn_and_split.  Split the\n+\t        instruction into a call and $gp load if TARGET_SPLIT_CALLS.\n+\t        (call_value_internal, call_value_multiple_internal): Likewise.\n+\n+\t2003-02-23  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (mips_reloc_string): Return \"%got(\" for\n+\t        RELOC_GOT_PAGE and RELOC_GOT_DISP if !TARGET_NEWABI.\n+\t        (mips_encode_section_info): Don't take symbol visibility into\n+\t        account if TARGET_ABICALLS.  Add more commentary.\n+\t        * config/mips/mips.md: Add commentary above reloc constants.\n+\n+\t2003-02-12  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (mips_legitimize_const_move): New, extracted\n+\t        from mips_legitimize_move.  Legitimize constant pool references.\n+\t        (mips_legitimize_move): Call mips_legitimize_const_move.  Attach\n+\t        a REG_EQUAL note to the last instruction.\n+\n+\t2003-02-11  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips_simplify_dwarf_addr): Declare.\n+\t        * config/mips/mips.h (TARGET_EXPLICIT_RELOCS, TARGET_NEWABI): New.\n+\t        (ASM_SIMPLIFY_DWARF_ADDR): Define to mips_simplify_dwarf_addr.\n+\t        (EXTRA_CONSTRAINT): Allow symbolic call addresses for TARGET_ABICALLS.\n+\t        * config/mips/mips.md (UNSPEC_HIGH): New constant.\n+\t        (UNSPEC_RELOC_GPREL16): Rename to...\n+\t        (RELOC_GPREL16): ...this.\n+\t        (RELOC_GOT_HI, RELOC_GOT_LO, RELOC_GOT_PAGE, RELOC_GOT_DISP): New.\n+\t        (RELOC_CALL16, RELOC_CALL_HI, RELOC_CALL_LO): New.\n+\t        (macro_calls): New attribute.\n+\t        (length): Use it to set the default length of calls.  Don't allow\n+\t        calls to have delay slots if macro_calls is \"yes\".\n+\t        (luisi, luidi): New patterns.\n+\t        (lowsi, lowdi): Use '%R' to print the relocation.\n+\t        (lowdi_extend): Remove.\n+\t        (loadgp): Remove mode from operand 0.  Use '%0' instead of '%a0'.\n+\t        (call_internal): Merge alternatives.  Always use \"jal\".\n+\t        (call_value_internal, call_value_multiple_internal): Likewise.\n+\t        (reloc_gprel16): Remove.\n+\t        * config/mips/mips.c (mips_got_alias_set): New variable.\n+\t        (mips_classify_constant): Handle the new relocation constants.\n+\t        (mips_classify_symbol): Reverse the sense of SYMBOL_REF_FLAG for PIC.\n+\t        (mips_symbolic_address_p): Return false if generating explicit relocs.\n+\t        Otherwise allow local PIC symbols to have an offset.\n+\t        (mips_splittable_symbol_p): New function.\n+\t        (mips_classify_address): Use it to check whether a LO_SUM is valid.\n+\t        (mips_const_insns): Always accept HIGH.\n+\t        (call_insn_operand): Don't accept global symbols if using explicit\n+\t        relocs.\n+\t        (move_operand): Don't accept HIGH when generating PIC.\n+\t        (mips_reloc, mips_lui_reloc): New functions.\n+\t        (mips_force_temporary): Remove MODE argument.  Expect VALUE to\n+\t        be a valid right-hand-side for a SET pattern.\n+\t        (mips_load_got, mips_load_got16, mips_load_got32): New functions.\n+\t        (mips_emit_high): New function.\n+\t        (mips_legitimize_symbol): Use mips_reloc for the mips16 gp-relative\n+\t        case.  Use mips_splittable_symbol_p to check whether a LO_SUM\n+\t        address should be used.  Use mips_emit_high to generate the\n+\t        high part of such an address.  Adjust the global symbol + offset\n+\t        case to match the change to mips_force_temprorary.\n+\t        (mips_legitimize_move): Shuffle call to mips_legitimize_symbol.\n+\t        If generating explicit-reloc PIC, load the address of global\n+\t        symbols from the GOT.  Use mips_emit_high to emit the high part\n+\t        of an address.\n+\t        (mips_simplify_dwarf_addr): New function.\n+\t        (mips_move_1word): Use lwc1 instead of l.s and swc1 instead of s.s.\n+\t        (mips_move_2words): Likewise ldc1/l.d and sdc1/s.d if TARGET_64BIT.\n+\t        (mips_expand_call): Load the addresses of global functions using\n+\t        %call* relocs if generating explicit-reloc PIC.  Don't generate\n+\t        an exception_receiver pattern.\n+\t        (override_options): Initialize mips_got_alias_set.\n+\t        (print_relocation): Remove in favour of...\n+\t        (mips_reloc_string): ...this new function.\n+\t        (print_operand): Handle '%R'.  Use mips_reloc_string.\n+\t        (print_operand_address): Use print_operand to print the symbolic\n+\t        part of a LO_SUM address.\n+\t        (mips_output_function_prologue): Use .cprestore, reverting last patch.\n+\t        (mips_encode_section_info): Factor out DECL_RTL accesses.  Reverse\n+\t        sense of SYMBOL_REF_FLAG for PIC, using binds_local_p to check\n+\t        for local symbols.\n+\n+\t2003-02-02  Eric Christopher  <echristo@redhat.com>\n+\n+\t       \t* config/mips/mips.c (mips_sign_extend): Remove.\n+\t        * config/mips/mips-protos.h: Ditto.\n+\t        * config/mips/mips.md (movdi_internal2_extend): Remove.\n+\t        (extendsidi2): Fix mode of convert_memory_address.\n+\n+\t2003-01-24  Eric Christopher  <echristo@redhat.com>\n+\n+\t        * config/mips/mips.md: Rewrite zero_extend* and extend*\n+\t        patterns. Use explicit instructions and split after reload\n+\t        for register extensions.\n+\t        (ashlsi3_internal1_extend): New combiner pattern for\n+\t        shift and extend combinations.\n+\t        * config/mips/mips.h: Change Pmode back to ptr_mode\n+\t        for performance enhancement.\n+\t        * combine.c (expand_compound_operation): Make sure\n+\t        that zero_extend operation is profitable.\n+\n+\t2003-01-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (TRAMPOLINE_TEMPLATE): Make size of stored\n+\t        addresses depend on ptr_mode rather than Pmode.\n+\t        (TRAMPOLINE_SIZE, TRAMPOLINE_ALIGNMENT): Update acoordingly.\n+\t        (INITIALIZE_TRAMPOLINE): Rework to handle Pmode != ptr_mode.\n+\t        (CASE_VECTOR_MODE): Use ptr_mode for !TARGET_MIPS16.\n+\t        (ASM_OUTPUT_ADDR_VEC_ELT): Update accordingly.\n+\t        * config/mips/mips.md (tablejump): Likewise.  Remove Pmode\n+\t        condition for selecting cpaddsi or cpadddi: use cpadd instead.\n+\t        (tablejump_internal1): Remove condition.\n+\t        (tablejump_internal2): Change condition to TARGET_64BIT.\n+\t        (cpaddsi): Rename to...\n+\t        (cpadd): ...this.\n+\t        (cpadddi): Remove.\n+\n+\t2003-01-09  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips16_constant_after_function_p,\n+\t        mips_address_cost, mips_check_split, double_memory_operand,\n+\t        mips16_gp_offset, mips16_gp_offset_p, mips16_constant,\n+\t        pic_address_needs_scratch, symbolic_operand): Remove declarations.\n+\t        (mips_legitimate_address_p): Return bool.\n+\t        (mips_address_insns, mips_fetch_insns, mips_const_insns,\n+\t        mips_legitimize_address, mips_legitimize_move,\n+\t        mips_expand_call): Declare.\n+\t        (mips_return_addr): Move outside #ifdef RTX_CODE.\n+\n+\t        * config/mips/mips.h (ABI_HAS_64BIT_SYMBOLS): New macro.\n+\t        (PIC_FN_ADDR_REG): New reg_class.\n+\t        (REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add corresponding entries.\n+\t        (GR_REG_CLASS_P): True for PIC_FN_ADDR_REG.\n+\t        (SMALL_OPERAND, SMALL_OPERAND_UNSIGNED, LUI_OPERAND,\n+\t        CONST_HIGH_PART, CONST_LOW_PART, LUI_INT): New macros.\n+\t        (SMALL_INT, SMALL_INT_UNSIGNED, CONST_OK_FOR_LETTER_P): Use new macros.\n+\t        (EXTRA_CONSTRAINTS): Give new meanings to Q, R and S.\n+\t        (CONSTANT_ADDRESS_P): Use mips_legitimate_address_p.\n+\t        (LEGITIMATE_PIC_OPERAND): Undefine.\n+\t        (LEGITIMATE_CONSTANT_P): Use mips_const_insns.\n+\t        (LEGITIMIZE_ADDRESS): Use mips_legitimize_address.\n+\t        (CONSTANT_AFTER_FUNCTION_P): Remove definition in #if 0 block.\n+\t        (FUNCTION_MODE): Change to SImode.\n+\t        (CONST_COSTS): Use mips_const_insns to calculate the cost of\n+\t        most constants.  Treat const_artih_operands specially if they\n+\t        occur in a PLUS or MINUS.\n+\t        (CONSTANT_POOL_COST): New macro.\n+\t        (RTX_COSTS): Use mips_address_insns for MEMs, with a base cost of 2.\n+\t        Add LO_SUM handling.\n+\t        (ADDRESS_COST): Undefine.\n+\t        (PREDICATE_CODES): Add symbolic_operand and const_arith_operand.\n+\t        Add CONST to the list of codes for arith_operand.  Add LABEL_REF\n+\t        to call_insn_operand and remove CONST_INT.\n+\n+\t        * config/mips/mips.c: Include integrate.h.\n+\t        (SINGLE_WORD_MODE_P): New macro.\n+\t        (mips_constant_type, mips_symbol_type, mips_address_type): New enums.\n+\t        (mips_constant_info, mips_address_info): New structs.\n+\t        (mips_regno_to_class): Map $25 to PIC_FN_ADDR_REG.\n+\t        (mips_classify_constant, mips_classify_symbol,\n+\t        mips_valid_base_register_p, mips_symbolic_address_p,\n+\t        mips_classify_address, mips_symbol_insns,\n+\t        mips16_unextended_reference_p, mips_address_insns, mips_const_insns,\n+\t        mips_fetch_insns, mips_force_temporary, mips_add_offset,\n+\t        mips_legitimize_symbol, mips_legitimize_address, mips_legitimize_move,\n+\t        mips_print_relocation): New functions.\n+\t        (const_arith_operand): New operand predicate.\n+\t        (arith_operand): Use it.\n+\t        (mips_const_double_ok, mips16_simple_memory_operand,\n+\t        simple_memory_operand, double_memory_operand, mips_check_split,\n+\t        mips_address_cost, pic_address_needs_scratch, mips16_gp_offset,\n+\t        mips16_gp_offset_p, mips16_output_gp_offset,\n+\t       \tmips16_constant_after_function_p, mips16_constant): Remove.\n+\t        (call_insn_operand): Be more fussy about symbolic constants.\n+\t        Use register_operand.\n+\t        (move_operand): Use mips_symbolic_address_p to check symbolic\n+\t        operands and general_operand to check the rest.\n+\t        (symbolic_operand): Use mips_classify_constant.\n+\t        (mips_legitimate_address_p): Use mips_classify_address.\n+\t        (mips_move_1word): Combine handling of symbolic addresses.\n+\t        Remove special treatment of gp-relative loads for TARGET_MIPS16.\n+\t        (move_move_2words): Likewise.  Assume addresses are offsettable\n+\t        if they need to refer to more than one word.  Add HIGH handling.\n+\t        (mips_restore_gp): Use ptr_mode for the GP save slot.\n+\t        (mips_expand_call): New function, combining the old mips.md\n+\t        call and call_internal define_expands.  If the address isn't\n+\t        a call_insn_operand, force it into a register.  For SVR4 PIC,\n+\t        emit an exception_receiver instruction after the call.\n+\t        (override_options): Only override flag_pic for TARGET_ABICALLS\n+\t        if it is currently zero.  Allow mips_split_addresses when\n+\t        Pmode == DImode too, except when ABI_HAS_64BIT_SYMBOLS.\n+\t        Add new register class letter, 'c'.\n+\t        (print_operand): Use mips_classify_constant for constant operands.\n+\t        (print_operand_address): Use mips_classify_address.\n+\t        (mips_output_function_prologue): Don't use .cprestore.\n+\t        (mips_expand_epilogue): For TARGET_MIPS16, only adjust the stack\n+\t        via the frame pointer if current_function_calls_eh_return.\n+\t        (mips_encode_section_info): For TARGET_ABICALLS, use SYMBOL_REF_FLAG\n+\t        to mark whether a symbol is local or global.\n+\t        (build_mips16_call_stub): Expect the address of the function rather\n+\t        than a MEM reference to it.  Update call generation sequences.\n+\t        (mips16_optimize_gp): Remove Pmode checks.  Temporarily disable\n+\t        small-data adjustments.\n+\n+\t        * config/mips/mips.md: Remove 'R'/'m' memory distinction.  Use default\n+\t        length for loads and stores.\n+\t        (UNSPEC_CPADD, UNSPEC_RELOC_GPREL16): New constants.\n+\t        (define_attr type): Add const and prefetch.\n+\t        (define_attr length): Use mips_const_insns for const instructions.\n+\t        Use mips_fetch_insns for load and store instructions.\n+\t        (define_attr single_insn): New.\n+\t        (define_attr can_delay): Use it.\n+\t        (define_attr abicalls): Remove.\n+\t        (define_delay): Use can_delay.  Always allow calls to have delay slots.\n+\t        (addsi3_internal_2): Add 'Q' constraint.\n+\t        (movsi_ulw, movsi_usw, movdi_uld, movdi_usd): Set length to 8.\n+\t        (high): Remove.\n+\t        (lowsi): Renamed from low.\n+\t        (lowdi): New pattern.\n+\t        (movdi, movsi): Use mips_legitimize_move.  Remove define_split.\n+\t        (lwxc1, ldxc1, swxc1, sdxc1): Set length to 4.\n+\t        (loadgp): Change operand 0 to an immediate_operand.\n+\t        (tablejump): Use the same patterns for SVR4 PIC but emit a cpadd\n+\t        beforehand.\n+\t        (cpaddsi, cpadddi): New patterns.\n+\t        (tablejump_internal3, tablejump_internal4): Remove define_expands\n+\t        and associated define_splits.\n+\t        (call, call_value): Use mips_expand_call.\n+\t        (call_internal): New, replacing all existing call_internal* insns.\n+\t        (call_value_internal): Likewise call_value_internal*.\n+\t        (call_value_multiple_internal): Likewise call_value_multiple_internal*.\n+\t        (untyped_call): Remove if (operands[0]) magic.\n+\t        (prefetch_si_address, prefetch_si): Change type to \"prefetch\".\n+\t        (prefetch_di_address, prefetch_di): Likewise.\n+\t        (leasi, leadi): Remove.\n+\t        (reloc_gprel16): New.\n+\n+\t        * config/mips/5400.md (ir_vr54_hilo): Include const type.\n+\t        * config/mips/5500.md (ir_vr55_hilo): Likewise.\n+\t        * config/mips/sr71k.md (ir_sr70_hilo): Likewise.\n+\n+\t2003-01-08  Eric Christopher  <echristo@redhat.com>\n+\n+\t        * config.gcc (mipsisa32*): Change ABI_MEABI to ABI_EABI.\n+\t        * config/mips/elf.h (STARTFILE_SPEC): Remove ABI_MEABI references and\n+\t        configure check for libgloss.\n+\t        * config/mips/elf64.h: Ditto.\n+\t        * config/mips/mips.c: Remove ABI_MEABI.\n+\t        * config/mips/mips.h: Ditto.\n+\n+\t2002-11-05  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        Fix merge fallout.\n+\t        * config/mips/mips.md (mul_acc_si): Reapply 2002-10-16 change.\n+\t        (muldi3_internal): Remove outdated comment.\n+\t        (*muls_di, *umuls_di): Fix comment and 64-bitness.\n+\t        (*smsac_di, *umsac_di): Likewise.  Reformat.\n+\t        (umulsi3_highpart): Minor formatting tweaks.\n+\t        (umulsi3_highpart_internal): Use only if !ISA_HAS_MULHI.  Remove\n+\t        redundant scratch operand.  Minor formatting tweak.\n+\t        (umulsi3_highpart_mulhi_internal): Use for !TARGET_64BIT as well.\n+\t        (umulsi3_highpart_neg_mulhi_internal): Likewise.  Fix asm template.\n+\t        (smulsi3_highpart): As for the unsigned version.\n+\t        (smulsi3_highpart_internal): Likewise.\n+\t        (smulsi3_highpart_mulhi_internal): Likewise.\n+\t        (smulsi3_highpart_neg_mulhi_internal): Likewise.\n+\t        (smuldi3_highpart, umuldi3_highpart): Minor formatting tweaks.\n+\t        (*smul_acc_di): Remove duplicated pattern.\n+\t        (*umul_acc_di, *smul_acc_di): Reapply 2002-10-16 change.\n+\t        (anddi3) [unnamed mips16 pattern]: Remove reintroduced length.\n+\t        (zero_extendsidi2_internal2): Remove new, but commented-out pattern.\n+\n+\t2002-10-22  Eric Christopher  <echristo@redhat.com>\n+\n+\t        * config/mips/mips-protos.h (mips_return_addr): New.\n+\t        * config/mips/mips.c (mips_return_addr): New.\n+\t        (movdi_operand): Remove.\n+\t        (se_register_operand): Ditto.\n+\t        (se_reg_or_0_operand): Ditto.\n+\t        (se_uns_arith_operand): Ditto.\n+\t        (se_arith_operand): Ditto.\n+\t        (se_nonmemory_operand): Ditto.\n+\t        (extend_operator): Ditto.\n+\t        (highpart_shift_operator): Ditto.\n+\t        (mips_initial_elimination_offset): Remove return address pointer\n+\t        elimination.\n+\t        (mips_reg_names): Remove $ra.\n+\t        (mips_regno_to_class): Ditto.\n+\t        * config/mips/mips.h (POINTER_SIZE): Define based on TARGET_LONG64\n+\t        and TARGET_64BIT.\n+\t        (POINTER_BOUNDARY): Remove.\n+\t        (POINTERS_EXTEND_UNSIGNED): Define to 0.\n+\t        (PROMOTE_MODE): Promote to Pmode.\n+\t        (SHORT_IMMEDIATES_SIGN_EXTEND): Define.\n+\t        (Pmode): Define to TARGET_64BIT.\n+\t        (FUNCTION_MODE): Define as Pmode.\n+\t        (mips_args): Remove deleted functions.\n+\t        (SIZE_TYPE): Depend on POINTER_SIZE.\n+\t        (PTRDIFF_TYPE): Ditto.\n+\t        (FIXED_REGISTERS): Fix extra registers.\n+\t        (CALL_USED_REGISTERS): Ditto.\n+\t        (CALL_REALLY_USED_REGISTERS): Ditto.\n+\t        (RAP_REG_NUM): Remove.\n+\t        (RETURN_ADDRESS_POINTER_REGNUM): Ditto.\n+\t        (RETURN_ADDR_RTX): Define to mips_return_addr.\n+\t        (ELIMINABLE_REGS): Remove RETURN_ADDRESS_POINTER_REGNUM.\n+\t        (CAN_ELIMINATE): Ditto.\n+\t        * config/mips/mips.md: For DImode patterns, take into account\n+\t        deletions above. Split mulsidi patterns into sign_extend and\n+\t        zero_extend.\n+\n+\t2002-10-16  Richard Sandiford  <rsandifo@redhat.com>\n+\t            Michael Meissner  <meissner@redhat.com>\n+\n+\t        * config/mips/mips.h (ISA_HAS_MACC): True for normal-mode vr4120 code.\n+\t        * config/mips/mips.md (mulsi3_mult3): Add a define_peephole2 to\n+\t        mop up unnecessarly moves through LO.\n+\t        (*mul_acc_si): Remove vr5400 and vr5500 handling from here.\n+\t        (*macc): New pattern for ISA_HAS_MACC.  Add define_peephole2s to\n+\t        change mtlo/macc sequences into mul/add sequences when a three-\n+\t        address mul is available.\n+\t        (*macc2): New pattern.  Add a define_peephole2 to generate it.\n+\t        (*mul_sub_si): Fix contraint for operand 5.\n+\t        (*muls): Use in 32-bit code as well.\n+\t        (*msac): Likewise.  Use msub instead of msac in vr5500 code\n+\t        if the destination is LO.  Remove duplicate define_split.\n+\t        (*muls_di): Use only in 32-bit code.  Adjust rtl accordingly.\n+\t        (*msac_di): Likewise.  Fix formatting.\n+\t        (smulsi3_highpart, umulsi3_highpart): Use mulhi in 32-bit code too.\n+\t        (*xmulsi3_highpart_internal): Use only if !ISA_HAS_MULHI.\n+\t        (*xmulsi3_highpart_mulhi): Use even if !TARGET_64BIT.\n+\t        (*xmulsi3_neg_highpart_mulhi): Likewise.\n+\t        (*mul_acc_64bit_di): Remove.\n+\t        (*mul_acc_di): Use only in 32-bit code.  Handle ISA_HAS_MACC as well.\n+\n+\t2002-10-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/vr.h (DRIVER_SELF_SPECS): Define.\n+\t        * config/mips/t-vr (MULTILIB_OPTIONS): Remove mlong32.\n+\t        (MULTILIB_DIRNAMES): Remove long32.\n+\t        (MULTILIB_EXCEPTIONS): Don't build -mabi=32 -mgp32 multilibs.\n+\t        (MULTILIB_REDUNDANT_DIRS): Remove.\n+\n+\t2002-10-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * doc/tm.texi (DRIVER_SELF_SPECS): Document.\n+\t        * gcc.c (driver_self_specs): New variable.\n+\t        (do_self_spec): New function.\n+\t        (main): Use it to process driver_self_specs.\n+\n+\t2002-10-09  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.md (one_cmpldi2): Use only if TARGET_64BIT.\n+\t        Remove DImode define_split for !TARGET_64BIT.\n+\t        (anddi3): Remove !TARGET_64BIT support from here as well.\n+\t        Change operand 2's predicate to se_uns_arith_operand.\n+\t        Add constant alternatives to define_insn.\n+\t        (iordi3, xordi3, *nordi3): Likewise.\n+\t        (anddi3_internal1, xordi3_immed): Remove.\n+\n+\t2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.h (PROCESSOR_R4121): Rename to PROCESSOR_R4120.\n+\t        (TARGET_MIPS4121): Rename to TARGET_MIPS4120.\n+\t        * config/mips/mips.c (mips_cpu_info): Rename vr4121 to vr4120.\n+\t        * config/mips/mips.md: Apply same renaming here.\n+\n+\t2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (PROCESSOR_R4320, TARGET_MIPS4320): Remove.\n+\t        (GENERATE_MULT3_SI): Remove use of TARGET_MIPS4320.\n+\t        * config/mips/mips.c (mips_cpu_info): Remove vr4320 entry.\n+\t        * config/mips/mips.md (define_attr cpu): Remove r4320.\n+\t        Remove vr4320 scheduler and uses of TARGET_MIPS4320.\n+\n+\t2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.c (mips16_strings): New variable.\n+\t        (mips_output_function_epilogue): Clear the SYMBOL_REF_FLAG of every\n+\t        symbol in mips16_strings.  Free the list.\n+\t        (mips_encode_section_info): Keep track of local strings.\n+\n+\t2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t        * config/mips/mips.md (bunge, bltgt, bungt): New define_expands.\n+\t        (sordered_df, sordered_sf): Remove.\n+\t        * config/mips/mips.c (get_float_compare_codes): New fn.\n+\t        (gen_int_relational, gen_conditional_move): Use it.\n+\n+\t2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+        \t* config/mips/mips-protos.h (mips_emit_fcc_reload): Declare.\n+        \t* config/mips/mips.h (PREDICATE_CODES): Add fcc_register_operand.\n+        \t* config/mips/mips.c (fcc_register_operand): New function.\n+        \t(mips_emit_fcc_reload): New function, extracted from reload_incc.\n+        \t(override_options): Allow TFmode values in float registers\n+        \tif ISA_HAS_8CC.\n+        \t* cnfig/mips/mips.md (reload_incc): Change destination prediate\n+        \tto fcc_register_operand.  Remove misleading source constraint.\n+        \tUse mips_emit_fcc_reload.\n+       \t\t(reload_outcc): Duplicate reload_incc.\n+\n+\n 2003-04-30  Diego Novillo  <dnovillo@redhat.com>\n \n \t* builtins.def (BUILTIN_CONSTANT_P): Mark as constant.\n@@ -24,7 +583,7 @@\n \n \t* tree.h (DECL_POINTER_DEPTH): Remove.\n \t(struct tree_decl): Remove pointer_depth.\n-\t\n+\n 2003-04-30  Janis Johnson  <janis187@us.ibm.com>\n \n \t* config/rs6000/linux64.h (ASM_OUTPUT_LABELREF): Remove.\n@@ -128,7 +687,7 @@\n 2003-04-29  Jason Merrill  <jason@redhat.com>\n \n \tPR middle-end/10336\n-\t* jump.c (never_reached_warning): Really stop looking if we reach \n+\t* jump.c (never_reached_warning): Really stop looking if we reach\n \tthe beginning of the function.\n \n 2003-04-29  Bob Wilson  <bob.wilson@acm.org>"}, {"sha": "6e3bbb2fb56d0bb59ea5be9cc9ea35c03f884b39", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -1437,7 +1437,7 @@ cant_combine_insn_p (insn)\n \n   /* Never combine loads and stores involving hard regs that are likely\n      to be spilled.  The register allocator can usually handle such\n-     reg-reg moves by tying.  If we allow the combiner to make \n+     reg-reg moves by tying.  If we allow the combiner to make\n      substitutions of likely-spilled regs, we may abort in reload.\n      As an exception, we allow combinations involving fixed regs; these are\n      not available to the register allocator so there's no risk involved.  */\n@@ -10159,6 +10159,14 @@ gen_lowpart_for_combine (mode, x)\n   if (GET_MODE (x) == mode)\n     return x;\n \n+  /* Return identity if this is a CONST or symbolic\n+     reference.  */\n+  if (mode == Pmode\n+      && (GET_CODE (x) == CONST\n+\t  || GET_CODE (x) == SYMBOL_REF\n+\t  || GET_CODE (x) == LABEL_REF))\n+    return x;\n+\n   /* We can only support MODE being wider than a word if X is a\n      constant integer or has a mode the same size.  */\n \n@@ -10242,6 +10250,8 @@ gen_lowpart_for_combine (mode, x)\n \t{\n \t  sub_mode = int_mode_for_mode (mode);\n \t  x = gen_lowpart_common (sub_mode, x);\n+\t  if (x == 0)\n+\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \t}\n       res = simplify_gen_subreg (mode, x, sub_mode, offset);\n       if (res)"}, {"sha": "6934b7433df8d5e3d1c6e62ddf46f5054f4fa77e", "filename": "gcc/config/mips/5400.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2F5400.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2F5400.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F5400.md?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -64,7 +64,7 @@\n \n (define_insn_reservation \"ir_vr54_arith\" 1\n   (and (eq_attr \"cpu\" \"r5400\")\n-       (eq_attr \"type\" \"arith,darith,icmp,nop\"))\n+       (eq_attr \"type\" \"arith,darith,const,icmp,nop\"))\n   \"vr54_dp0|vr54_dp1\")\n \n (define_insn_reservation \"ir_vr54_imul_si\" 3"}, {"sha": "dc85356d98b887c6350fd84c8622eec0b0293d24", "filename": "gcc/config/mips/5500.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2F5500.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2F5500.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F5500.md?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -57,7 +57,7 @@\n \n (define_insn_reservation \"ir_vr55_arith\" 1\n   (and (eq_attr \"cpu\" \"r5500\")\n-       (eq_attr \"type\" \"arith,darith,icmp,nop\"))\n+       (eq_attr \"type\" \"arith,darith,const,icmp,nop\"))\n   \"vr55_dp0|vr55_dp1\")\n \n (define_insn_reservation \"ir_vr55_imul_si\" 3"}, {"sha": "a719d4b815fcaeabaa722aef0b5b75238f74a675", "filename": "gcc/config/mips/elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf.h?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -234,12 +234,7 @@ void FN ()                                                            \\\n #define LIB_SPEC \"\"\n \n #undef  STARTFILE_SPEC\n-#if defined(HAVE_MIPS_LIBGLOSS_STARTUP_DIRECTIVES) \\\n-    || (MIPS_ABI_DEFAULT == ABI_MEABI)\n #define STARTFILE_SPEC \"crti%O%s crtbegin%O%s\"\n-#else\n-#define STARTFILE_SPEC \"crti%O%s crtbegin%O%s %{!mno-crt0:crt0%O%s}\"\n-#endif\n \n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend%O%s crtn%O%s\""}, {"sha": "eb12237a3aeb0473fd7321a56b44533fd76130ef", "filename": "gcc/config/mips/elf64.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Felf64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Felf64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf64.h?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -192,12 +192,7 @@ void FN ()                                                            \\\n #define LIB_SPEC \"\"\n \n #undef  STARTFILE_SPEC\n-#if defined(HAVE_MIPS_LIBGLOSS_STARTUP_DIRECTIVES) \\\n-    || (MIPS_ABI_DEFAULT == ABI_MEABI)\n #define STARTFILE_SPEC \"crti%O%s crtbegin%O%s\"\n-#else\n-#define STARTFILE_SPEC \"crti%O%s crtbegin%O%s %{!mno-crt0:crt0%O%s}\"\n-#endif\n \n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend%O%s crtn%O%s\""}, {"sha": "3663fe14a83e99c958c609018d01164c84d490f8", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -127,7 +127,7 @@ void FN ()\t\t\t\t\t\t\t\\\n \tbuiltin_define_std (\"linux\");\t\t\t\t\\\n \tbuiltin_assert (\"system=linux\");\t\t\t\\\n \t/* The GNU C++ standard library requires this.  */\t\\\n-\tif (c_language = clk_cplusplus)\t\t\t\t\\\n+\tif (c_language == clk_cplusplus)\t\t\t\\\n \t  builtin_define (\"_GNU_SOURCE\");\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       if (mips_abi == ABI_N32)\t\t\t\t\t\\"}, {"sha": "eb6b5e61a00619ee4ef2da485192436feefbc609", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -39,7 +39,7 @@ extern int\t\tmips_can_use_return_insn PARAMS ((void));\n extern void\t\tmips_declare_object PARAMS ((FILE *, const char *,\n \t\t\t\t\t\t     const char *,\n \t\t\t\t\t\t     const char *, int));\n-extern void\t\tmips_expand_epilogue PARAMS ((void));\n+extern void\t\tmips_expand_epilogue PARAMS ((int));\n extern void\t\tmips_expand_prologue PARAMS ((void));\n extern void\t\tmips_output_filename PARAMS ((FILE *, const char *));\n extern void\t\tmips_output_lineno PARAMS ((FILE *, int));\n@@ -81,6 +81,12 @@ extern void\t\tmips_va_start PARAMS ((tree, rtx));\n extern struct rtx_def  *mips_va_arg PARAMS ((tree, tree));\n \n extern void\t\texpand_block_move PARAMS ((rtx *));\n+extern bool\t\tmips_expand_unaligned_load PARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t    unsigned int,\n+\t\t\t\t\t\t\t    int));\n+extern bool\t\tmips_expand_unaligned_store PARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t     unsigned int,\n+\t\t\t\t\t\t\t     int));\n extern void\t\tfinal_prescan_insn PARAMS ((rtx, rtx *, int));\n extern void\t\tinit_cumulative_args PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t      tree, rtx));\n@@ -91,13 +97,11 @@ extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n extern void\t\tmachine_dependent_reorg PARAMS ((rtx));\n extern void\t\tmips_count_memory_refs PARAMS ((rtx, int));\n extern HOST_WIDE_INT\tmips_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n-extern int\t\tmips_check_split PARAMS ((rtx, enum machine_mode));\n extern const char      *mips_fill_delay_slot PARAMS ((const char *,\n \t\t\t\t\t\t      enum delay_type, rtx *,\n \t\t\t\t\t\t      rtx));\n extern const char      *mips_move_1word PARAMS ((rtx *, rtx, int));\n extern const char      *mips_move_2words PARAMS ((rtx *, rtx));\n-extern const char      *mips_sign_extend PARAMS ((rtx, rtx, rtx));\n extern const char      *mips_emit_prefetch PARAMS ((rtx *));\n extern const char      *mips_restore_gp PARAMS ((rtx *, rtx));\n extern const char      *output_block_move PARAMS ((rtx, rtx *, int,\n@@ -106,12 +110,7 @@ extern void\t\toverride_options PARAMS ((void));\n extern void\t\tmips_conditional_register_usage PARAMS ((void));\n extern void\t\tprint_operand_address PARAMS ((FILE *, rtx));\n extern void\t\tprint_operand PARAMS ((FILE *, rtx, int));\n-extern int\t\tdouble_memory_operand PARAMS ((rtx,enum machine_mode));\n extern struct rtx_def *\tembedded_pic_offset PARAMS ((rtx));\n-extern struct rtx_def * mips16_gp_offset PARAMS ((rtx));\n-extern int\t\tmips16_gp_offset_p PARAMS ((rtx));\n-extern int\t\tmips16_constant PARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\t\t int, int));\n extern int\t\tbuild_mips16_call_stub PARAMS ((rtx, rtx, rtx, int));\n extern const char       *mips_output_conditional_branch PARAMS ((rtx, rtx *,\n \t\t\t\t\t\t\t\t int, int, int,\n@@ -120,7 +119,7 @@ extern int              mips_adjust_insn_length PARAMS ((rtx, int));\n extern enum reg_class\tmips_secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t\t\t     rtx, int));\n-extern bool\t\tmips_cannot_change_mode_class \n+extern bool     \tmips_cannot_change_mode_class\n \t\t\t  PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t   enum reg_class));\n extern int              mips_class_max_nregs PARAMS ((enum reg_class,\n@@ -129,13 +128,21 @@ extern int              mips_register_move_cost PARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t enum reg_class,\n \t\t\t\t\t\t\t enum reg_class));\n \n-extern int\t\tpic_address_needs_scratch PARAMS ((rtx));\n extern int\t\tse_arith_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tcoprocessor_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tcoprocessor2_operand PARAMS ((rtx, enum machine_mode));\n-extern int\t\tsymbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int              mips_legitimate_address_p PARAMS ((enum machine_mode,\n+extern int\t\tmips_address_insns PARAMS ((rtx, enum machine_mode));\n+extern int\t\tmips_fetch_insns PARAMS ((rtx));\n+extern int\t\tmips_const_insns PARAMS ((rtx));\n+extern bool\t\tmips_global_pic_constant_p PARAMS ((rtx));\n+extern bool\t\tmips_legitimate_address_p PARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t   rtx, int));\n+extern bool\t\tmips_legitimize_address PARAMS ((rtx *,\n+\t\t\t\t\t\t\t enum machine_mode));\n+extern bool\t\tmips_legitimize_move PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t      rtx, rtx));\n+extern rtx\t\tmips_simplify_dwarf_addr PARAMS ((rtx));\n+extern void\t\tmips_expand_call PARAMS ((rtx, rtx, rtx, rtx, int));\n extern int              mips_reg_mode_ok_for_base_p PARAMS ((rtx,\n \t\t\t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t\t\t     int));\n@@ -165,5 +172,6 @@ extern rtx\t\tgen_int_relational PARAMS ((enum rtx_code, rtx, rtx,\n \t\t\t\t\t\t    rtx,int *));\n extern void\t\tgen_conditional_branch PARAMS ((rtx *, enum rtx_code));\n #endif\n+extern rtx              mips_return_addr PARAMS ((int, rtx));\n \n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "84f07fc61db1891e77bb1d9f9ea9a4d4ea749075", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1928, "deletions": 1674, "changes": 3602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191"}, {"sha": "5477b20497e0104c2e6dad9947eab1d40312dd49", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 221, "deletions": 319, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -92,17 +92,6 @@ enum processor_type {\n #define ABI_64  2\n #define ABI_EABI 3\n #define ABI_O64  4\n-/* MEABI is gcc's internal name for MIPS' new EABI (defined by MIPS)\n-   which is not the same as the above EABI (defined by Cygnus,\n-   Greenhills, and Toshiba?).  MEABI is not yet complete or published,\n-   but at this point it looks like N32 as far as calling conventions go,\n-   but allows for either 32 or 64 bit registers.\n-\n-   Currently MIPS is calling their EABI \"the\" MIPS EABI, and Cygnus'\n-   EABI the legacy EABI.  In the end we may end up calling both ABI's\n-   EABI but give them different version numbers, but for now I'm going\n-   with different names.  */\n-#define ABI_MEABI 5\n \n /* Whether to emit abicalls code sequences or not.  */\n \n@@ -175,7 +164,6 @@ extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n extern const char *mips_entry_string;\t/* for -mentry */\n extern const char *mips_no_mips16_string;/* for -mno-mips16 */\n extern const char *mips_cache_flush_func;/* for -mflush-func= and -mno-flush-func */\n-extern int mips_split_addresses;\t/* perform high/lo_sum support */\n extern int dslots_load_total;\t\t/* total # load related delay slots */\n extern int dslots_load_filled;\t\t/* # filled load delay slots */\n extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n@@ -240,6 +228,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t   multiply-add operations.  */\n #define MASK_BRANCHLIKELY  0x02000000   /* Generate Branch Likely\n \t\t\t\t\t   instructions.  */\n+#define MASK_EXPLICIT_RELOCS 0x04000000 /* Use relocation operators.  */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n@@ -332,12 +321,50 @@ extern void\t\tsbss_section PARAMS ((void));\n \n #define TARGET_BRANCHLIKELY\t(target_flags & MASK_BRANCHLIKELY)\n \n+\n+/* True if we should use NewABI-style relocation operators for\n+   symbolic addresses.  This is never true for mips16 code,\n+   which has its own conventions.  */\n+\n+#define TARGET_EXPLICIT_RELOCS\t(target_flags & MASK_EXPLICIT_RELOCS)\n+\n+\n /* This is true if we must enable the assembly language file switching\n    code.  */\n \n #define TARGET_FILE_SWITCHING \\\n   (TARGET_GP_OPT && ! TARGET_GAS && ! TARGET_MIPS16)\n \n+/* True if the call patterns should be split into a jalr followed by\n+   an instruction to restore $gp.  This is only ever true for SVR4 PIC,\n+   in which $gp is call-clobbered.  It is only safe to split the load\n+   from the call when every use of $gp is explicit.  */\n+\n+#define TARGET_SPLIT_CALLS \\\n+  (TARGET_EXPLICIT_RELOCS && TARGET_ABICALLS && !TARGET_NEWABI)\n+\n+/* True if we can optimize sibling calls.  For simplicity, we only\n+   handle cases in which call_insn_operand will reject invalid\n+   sibcall addresses.  There are two cases in which this isn't true:\n+\n+      - TARGET_MIPS16.  call_insn_operand accepts constant addresses\n+\tbut there is no direct jump instruction.  It isn't worth\n+\tusing sibling calls in this case anyway; they would usually\n+\tbe longer than normal calls.\n+\n+      - TARGET_ABICALLS && !TARGET_EXPLICIT_RELOCS.  call_insn_operand\n+\taccepts global constants, but \"jr $25\" is the only allowed\n+\tsibcall.  */\n+\n+#define TARGET_SIBCALLS \\\n+  (!TARGET_MIPS16 && (!TARGET_ABICALLS || TARGET_EXPLICIT_RELOCS))\n+\n+/* True if .gpword or .gpdword should be used for switch tables.\n+   Not all SGI assemblers support this.  */\n+\n+#define TARGET_GPWORD (TARGET_ABICALLS && (!TARGET_NEWABI || TARGET_GAS))\n+\n+\n /* We must disable the function end stabs when doing the file switching trick,\n    because the Lscope stabs end up in the wrong place, making it impossible\n    to debug the resulting code.  */\n@@ -379,6 +406,8 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TUNE_SB1                    (mips_tune == PROCESSOR_SB1)\n #define TUNE_SR71K                  (mips_tune == PROCESSOR_SR71000)\n \n+#define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n+\n /* Define preprocessor macros for the -march and -mtune options.\n    PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected\n    processor.  If INFO's canonical name is \"foo\", define PREFIX to\n@@ -534,9 +563,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  SUBTARGET_TARGET_SWITCHES\t\t\t\t\t\t\\\n-  {\"no-crt0\",          0,                                               \\\n-     N_(\"No default crt0.o\") },\t\t\t\t\t \t\\\n+  SUBTARGET_TARGET_SWITCHES                                             \\\n   {\"int64\",\t\t  MASK_INT64 | MASK_LONG64,\t\t\t\\\n      N_(\"Use 64-bit int type\")},\t\t\t\t\t\\\n   {\"long64\",\t\t  MASK_LONG64,\t\t\t\t\t\\\n@@ -639,6 +666,10 @@ extern void\t\tsbss_section PARAMS ((void));\n       N_(\"Use Branch Likely instructions, overriding default for arch\")}, \\\n   { \"no-branch-likely\",  -MASK_BRANCHLIKELY,\t\t\t\t\\\n       N_(\"Don't use Branch Likely instructions, overriding default for arch\")}, \\\n+  {\"explicit-relocs\",\t  MASK_EXPLICIT_RELOCS,\t\t\t\t\\\n+     N_(\"Use NewABI-style %reloc() assembly operators\")},\t\t\\\n+  {\"no-explicit-relocs\", -MASK_EXPLICIT_RELOCS,\t\t\t\t\\\n+     N_(\"Use assembler macros instead of relocation operators\")},\t\\\n   {\"debug\",\t\t  MASK_DEBUG,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"debuga\",\t\t  MASK_DEBUG_A,\t\t\t\t\t\\\n@@ -808,6 +839,10 @@ extern void\t\tsbss_section PARAMS ((void));\n /* Likewise for 32-bit regs.  */\n #define ABI_NEEDS_32BIT_REGS\t(mips_abi == ABI_32)\n \n+/* True if symbols are 64 bits wide.  At present, n64 is the only\n+   ABI for which this is true.  */\n+#define ABI_HAS_64BIT_SYMBOLS\t(mips_abi == ABI_64)\n+\n /* ISA has instructions for managing 64 bit fp and gp regs (eg. mips3).  */\n #define ISA_HAS_64BIT_REGS\t(ISA_MIPS3\t\t\t\t\\\n \t\t\t\t || ISA_MIPS4\t\t\t\t\\\n@@ -893,7 +928,8 @@ extern void\t\tsbss_section PARAMS ((void));\n                                  )\n /* ISA has three operand multiply instructions that  the result\n    from a 4th operand and puts the result in an accumulator.  */\n-#define ISA_HAS_MACC            (TARGET_MIPS5400                        \\\n+#define ISA_HAS_MACC            ((TARGET_MIPS4120 && !TARGET_MIPS16)\t\\\n+                                 || TARGET_MIPS5400                     \\\n                                  || TARGET_MIPS5500                     \\\n                                  || TARGET_SR71K                        \\\n                                  )\n@@ -1029,12 +1065,6 @@ extern int mips_abi;\n #define ASM_ABI_DEFAULT_SPEC \"-mabi=eabi\"\n #endif\n \n-#if MIPS_ABI_DEFAULT == ABI_MEABI\n-/* Most GAS don't know about MEABI.  */\n-#define MULTILIB_ABI_DEFAULT \"mabi=meabi\"\n-#define ASM_ABI_DEFAULT_SPEC \"\"\n-#endif\n-\n /* Only ELF targets can switch the ABI.  */\n #ifndef OBJECT_FORMAT_ELF\n #undef ASM_ABI_DEFAULT_SPEC\n@@ -1318,6 +1348,8 @@ extern int mips_abi;\n    SFmode register saves.  */\n #define DWARF_CIE_DATA_ALIGNMENT 4\n \n+#define ASM_SIMPLIFY_DWARF_ADDR mips_simplify_dwarf_addr\n+\n /* Overrides for the COFF debug format.  */\n #define PUT_SDB_SCL(a)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\\\n@@ -1587,20 +1619,19 @@ do {\t\t\t\t\t\t\t\\\n # endif\n #endif\n \n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n+/* Width in bits of a pointer.  */\n #ifndef POINTER_SIZE\n-#define POINTER_SIZE (Pmode == DImode ? 64 : 32)\n+#define POINTER_SIZE ((TARGET_LONG64 && TARGET_64BIT) ? 64 : 32)\n #endif\n \n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY (Pmode == DImode ? 64 : 32)\n+#define POINTERS_EXTEND_UNSIGNED 0\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY ((mips_abi == ABI_O64 || mips_abi == ABI_N32 \\\n \t\t\t|| mips_abi == ABI_64 \\\n \t\t\t|| (mips_abi == ABI_EABI && TARGET_64BIT)) ? 64 : 32)\n \n+\n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n \n@@ -1678,9 +1709,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* Force right-alignment for small varargs in 32 bit little_endian mode */\n \n-#define PAD_VARARGS_DOWN (TARGET_64BIT                                  \\\n-\t\t\t  || mips_abi == ABI_MEABI                      \\\n-\t\t\t     ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n+#define PAD_VARARGS_DOWN (TARGET_64BIT ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n \n /* Define this macro if an argument declared as `char' or `short' in a\n    prototype should actually be passed as an `int'.  In addition to\n@@ -1708,26 +1737,28 @@ do {\t\t\t\t\t\t\t\\\n    in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.\n-\n-   We promote any value smaller than SImode up to SImode.  We don't\n-   want to promote to DImode when in 64 bit mode, because that would\n-   prevent us from using the faster SImode multiply and divide\n-   instructions.  */\n+   extension may differ from that of the type.  */\n \n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n-    (MODE) = SImode;\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    {                                           \\\n+      if ((MODE) == SImode)                     \\\n+        (UNSIGNEDP) = 0;                        \\\n+      (MODE) = Pmode;                           \\\n+    }\n+\n+/* Define if loading short immediate values into registers sign extends.  */\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n \n /* Define this if function arguments should also be promoted using the above\n    procedure.  */\n-\n #define PROMOTE_FUNCTION_ARGS\n \n /* Likewise, if the function return value is promoted.  */\n-\n #define PROMOTE_FUNCTION_RETURN\n+\n \f\n /* Standard register usage.  */\n \n@@ -1764,10 +1795,10 @@ do {\t\t\t\t\t\t\t\\\n #define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP0 registers */\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n@@ -1780,20 +1811,22 @@ do {\t\t\t\t\t\t\t\\\n }\n \n \n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n+/* Don't mark $31 as a call-clobbered register.  The idea is that\n+   it's really the call instructions themselves which clobber $31.\n+   We don't care what the called function does with it afterwards.\n+\n+   This approach makes it easier to implement sibcalls.  Unlike normal\n+   calls, sibcalls don't clobber $31, so the register reaches the\n+   called function in tact.  EPILOGUE_USES says that $31 is useful\n+   to the called function.  */\n \n #define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP0 registers */\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n@@ -1817,12 +1850,12 @@ do {\t\t\t\t\t\t\t\\\n #define CALL_REALLY_USED_REGISTERS                                      \\\n { /* General registers.  */                                             \\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                       \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1,                       \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0,                       \\\n   /* Floating-point registers.  */                                      \\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* Others.  */                                                        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP0 registers */\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n@@ -1857,8 +1890,8 @@ do {\t\t\t\t\t\t\t\\\n #define ST_REG_LAST  74\n #define ST_REG_NUM   (ST_REG_LAST - ST_REG_FIRST + 1)\n \n-#define RAP_REG_NUM   75\n \n+/* FIXME: renumber.  */\n #define COP0_REG_FIRST 80\n #define COP0_REG_LAST 111\n #define COP0_REG_NUM (COP0_REG_LAST - COP0_REG_FIRST + 1)\n@@ -1978,10 +2011,6 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM GP_REG_FIRST\n \n-/* Fake register that holds the address on the stack of the\n-   current function's return address.  */\n-#define RETURN_ADDRESS_POINTER_REGNUM RAP_REG_NUM\n-\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n \n@@ -2052,6 +2081,8 @@ enum reg_class\n   M16_REGS,\t\t\t/* mips16 directly accessible registers */\n   T_REG,\t\t\t/* mips16 T register ($24) */\n   M16_T_REGS,\t\t\t/* mips16 registers plus T register */\n+  PIC_FN_ADDR_REG,\t\t/* SVR4 PIC function address register */\n+  LEA_REGS,\t\t\t/* Every GPR except $25 */\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating point registers */\n   HI_REG,\t\t\t/* hi register */\n@@ -2090,6 +2121,8 @@ enum reg_class\n   \"M16_REGS\",\t\t\t\t\t\t\t\t\\\n   \"T_REG\",\t\t\t\t\t\t\t\t\\\n   \"M16_T_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"PIC_FN_ADDR_REG\",\t\t\t\t\t\t\t\\\n+  \"LEA_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_REG\",\t\t\t\t\t\t\t\t\\\n@@ -2131,6 +2164,8 @@ enum reg_class\n   { 0x000300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n   { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n   { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n+  { 0x02000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* SVR4 PIC function address register */ \\\n+  { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* Every other GPR */ \\\n   { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* hi register */\t\\\n@@ -2187,7 +2222,8 @@ extern const enum reg_class mips_regno_to_class[];\n /* This macro is used later on in the file.  */\n #define GR_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n   ((CLASS) == GR_REGS || (CLASS) == M16_REGS || (CLASS) == T_REG\t\\\n-   || (CLASS) == M16_T_REGS || (CLASS) == M16_NA_REGS)\n+   || (CLASS) == M16_T_REGS || (CLASS) == M16_NA_REGS\t\t\t\\\n+   || (CLASS) == PIC_FN_ADDR_REG || (CLASS) == LEA_REGS)\n \n /* This macro is also used later on in the file.  */\n #define COP_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n@@ -2246,6 +2282,35 @@ extern enum reg_class mips_char_to_class[256];\n \n #define REG_CLASS_FROM_LETTER(C) mips_char_to_class[(unsigned char)(C)]\n \n+/* True if VALUE is a signed 16-bit number.  */\n+\n+#define SMALL_OPERAND(VALUE) \\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + 0x8000 < 0x10000)\n+\n+/* True if VALUE is an unsigned 16-bit number.  */\n+\n+#define SMALL_OPERAND_UNSIGNED(VALUE) \\\n+  (((VALUE) & ~(unsigned HOST_WIDE_INT) 0xffff) == 0)\n+\n+/* True if VALUE can be loaded into a register using LUI.  */\n+\n+#define LUI_OPERAND(VALUE)\t\t\t\t\t\\\n+  (((VALUE) | 0x7fff0000) == 0x7fff0000\t\t\t\t\\\n+   || ((VALUE) | 0x7fff0000) + 0x10000 == 0)\n+\n+/* Return a value X with the low 16 bits clear, and such that\n+   VALUE - X is a signed 16-bit value.  */\n+\n+#define CONST_HIGH_PART(VALUE) \\\n+  (((VALUE) + 0x8000) & ~(unsigned HOST_WIDE_INT) 0xffff)\n+\n+#define CONST_LOW_PART(VALUE) \\\n+  ((VALUE) - CONST_HIGH_PART (VALUE))\n+\n+#define SMALL_INT(X) SMALL_OPERAND (INTVAL (X))\n+#define SMALL_INT_UNSIGNED(X) SMALL_OPERAND_UNSIGNED (INTVAL (X))\n+#define LUI_INT(X) LUI_OPERAND (INTVAL (X))\n+\n /* The letters I, J, K, L, M, N, O, and P in a register constraint\n    string can be used to stand for particular ranges of immediate\n    operands.  This macro defines what the ranges are.  C is the\n@@ -2274,21 +2339,14 @@ extern enum reg_class mips_char_to_class[256];\n \n    `P'\tis used for positive 16 bit constants.  */\n \n-#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n-#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)\n-\n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n+  ((C) == 'I' ? SMALL_OPERAND (VALUE)\t\t\t\t\t\\\n    : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n-   : (C) == 'K' ? ((unsigned HOST_WIDE_INT) (VALUE) < 0x10000)\t\t\\\n-   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n-\t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n-\t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n-   : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\\\n-\t\t   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\\\n-\t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n-\t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n-\t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n+   : (C) == 'K' ? SMALL_OPERAND_UNSIGNED (VALUE)\t\t\t\\\n+   : (C) == 'L' ? LUI_OPERAND (VALUE)\t\t\t\t\t\\\n+   : (C) == 'M' ? (!SMALL_OPERAND (VALUE)\t\t\t\t\\\n+\t\t   && !SMALL_OPERAND_UNSIGNED (VALUE)\t\t\t\\\n+\t\t   && !LUI_OPERAND (VALUE))\t\t\t\t\\\n    : (C) == 'N' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0xffff) < 0xffff) \\\n    : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x4000) < 0x8000) \\\n    : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))\t\\\n@@ -2305,22 +2363,40 @@ extern enum reg_class mips_char_to_class[256];\n   ((C) == 'G'\t\t\t\t\t\t\t\t\\\n    && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n \n+/* True if OP is a constant that should not be moved into $25.\n+   We need this because many versions of gas treat 'la $25,foo' as\n+   part of a call sequence and allow a global 'foo' to be lazily bound.  */\n+\n+#define DANGEROUS_FOR_LA25_P(OP)\t\t\t\t\t\\\n+  (TARGET_ABICALLS\t\t\t\t\t\t\t\\\n+   && !TARGET_EXPLICIT_RELOCS\t\t\t\t\t\t\\\n+   && mips_global_pic_constant_p (OP))\n+\n /* Letters in the range `Q' through `U' may be defined in a\n    machine-dependent fashion to stand for arbitrary operand types.\n    The machine description macro `EXTRA_CONSTRAINT' is passed the\n    operand as its first argument and the constraint letter as its\n    second operand.\n \n-   `Q'\tis for mips16 GP relative constants\n-   `R'\tis for memory references which take 1 word for the instruction.\n-   `T'\tis for memory addresses that can be used to load two words.  */\n+   `Q' is for signed 16-bit constants.\n+   `R' is for single-instruction memory references.  Note that this\n+\t constraint has often been used in linux and glibc code.\n+   `S' is for legitimate constant call addresses.\n+   `T' is for constant move_operands that cannot be safely loaded into $25.\n+   `U' is for constant move_operands that can be safely loaded into $25.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n-  (((CODE) == 'T')\t  ? double_memory_operand (OP, GET_MODE (OP))\t\\\n-   : ((CODE) == 'Q')\t  ? (GET_CODE (OP) == CONST\t\t\t\\\n-\t\t\t     && mips16_gp_offset_p (OP))\t\t\\\n-   : (GET_CODE (OP) != MEM) ? FALSE\t\t\t\t\t\\\n-   : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n+  (((CODE) == 'Q')\t  ? const_arith_operand (OP, VOIDmode)\t\t\\\n+   : ((CODE) == 'R')\t  ? (GET_CODE (OP) == MEM\t\t\t\\\n+\t\t\t     && mips_fetch_insns (OP) == 1)\t\t\\\n+   : ((CODE) == 'S')\t  ? (CONSTANT_P (OP)\t\t\t\t\\\n+\t\t\t     && call_insn_operand (OP, VOIDmode))\t\\\n+   : ((CODE) == 'T')\t  ? (CONSTANT_P (OP)\t\t\t\t\\\n+\t\t\t     && move_operand (OP, VOIDmode)\t\t\\\n+\t\t\t     && DANGEROUS_FOR_LA25_P (OP))\t\t\\\n+   : ((CODE) == 'U')\t  ? (CONSTANT_P (OP)\t\t\t\t\\\n+\t\t\t     && move_operand (OP, VOIDmode)\t\t\\\n+\t\t\t     && !DANGEROUS_FOR_LA25_P (OP))\t\t\\\n    : FALSE)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -2430,27 +2506,15 @@ extern enum reg_class mips_char_to_class[256];\n    during reload to be either the frame pointer or the stack pointer plus\n    an offset.  */\n \n-/* ??? This definition fails for leaf functions.  There is currently no\n-   general solution for this problem.  */\n-\n-/* ??? There appears to be no way to get the return address of any previous\n-   frame except by disassembling instructions in the prologue/epilogue.\n-   So currently we support only the current frame.  */\n-\n-#define RETURN_ADDR_RTX(count, frame)\t\t\t\t\t\\\n-  (((count) == 0)\t\t\t\t\t\t\t\\\n-   ? (leaf_function_p ()\t\t\t\t\t\t\\\n-      ? gen_rtx_REG (Pmode, GP_REG_FIRST + 31)\t\t\t\t\\\n-      : gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode,\t\t\t\t\\\n-\t\t\t\t\t RETURN_ADDRESS_POINTER_REGNUM))) \\\n-   : (rtx) 0)\n+#define RETURN_ADDR_RTX mips_return_addr\n \n /* Since the mips16 ISA mode is encoded in the least-significant bit\n    of the address, mask it off return addresses for purposes of\n    finding exception handling regions.  */\n \n #define MASK_RETURN_ADDR GEN_INT (-2)\n \n+\n /* Similarly, don't use the least-significant bit to tell pointers to\n    code from vtable index.  */\n \n@@ -2489,9 +2553,6 @@ extern enum reg_class mips_char_to_class[256];\n {{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n  { ARG_POINTER_REGNUM,   GP_REG_FIRST + 30},\t\t\t\t\\\n  { ARG_POINTER_REGNUM,   GP_REG_FIRST + 17},\t\t\t\t\\\n- { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\\\n- { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 17},\t\t\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n@@ -2517,15 +2578,11 @@ extern enum reg_class mips_char_to_class[256];\n    */\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n-  (((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n-    && (((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed)\t\\\n- \t|| (TO) == HARD_FRAME_POINTER_REGNUM))\t\t\t\t\\\n-   || ((FROM) != RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n-      && ((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t\\\n+   (((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t        \\\n \t  || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed\t\\\n \t      && ! (TARGET_MIPS16 && TARGET_64BIT)\t\t\t\\\n \t      && (! TARGET_MIPS16\t\t\t\t\t\\\n-\t          || compute_frame_size (get_frame_size ()) < 32768)))))\n+\t          || compute_frame_size (get_frame_size ()) < 32768))))\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n \t(OFFSET) = mips_initial_elimination_offset ((FROM), (TO))\n@@ -2892,6 +2949,11 @@ typedef struct mips_args {\n   || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n   || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n \n+/* Say that the epilogue uses the return address register.  Note that\n+   in the case of sibcalls, the values \"used by the epilogue\" are\n+   considered live at the start of the called function.  */\n+#define EPILOGUE_USES(REGNO) ((REGNO) == 31)\n+\n /* Treat LOC as a byte offset from the stack pointer and round it up\n    to the next fully-aligned offset.  */\n #define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\t\\\n@@ -2959,7 +3021,7 @@ typedef struct mips_args {\n   fprintf (STREAM, \"\\t.word\\t0x03e00821\\t\\t# move   $1,$31\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x04110001\\t\\t# bgezal $0,.+8\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# nop\\n\");\t\t\t\\\n-  if (Pmode == DImode)\t\t\t\t\t\t\t\\\n+  if (ptr_mode == DImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       fprintf (STREAM, \"\\t.word\\t0xdfe30014\\t\\t# ld     $3,20($31)\\n\");\t\\\n       fprintf (STREAM, \"\\t.word\\t0xdfe2001c\\t\\t# ld     $2,28($31)\\n\");\t\\\n@@ -2972,7 +3034,7 @@ typedef struct mips_args {\n   fprintf (STREAM, \"\\t.word\\t0x0060c821\\t\\t# move   $25,$3 (abicalls)\\n\"); \\\n   fprintf (STREAM, \"\\t.word\\t0x00600008\\t\\t# jr     $3\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x0020f821\\t\\t# move   $31,$1\\n\");\t\t\\\n-  if (Pmode == DImode)\t\t\t\t\t\t\t\\\n+  if (ptr_mode == DImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       fprintf (STREAM, \"\\t.dword\\t0x00000000\\t\\t# <function address>\\n\"); \\\n       fprintf (STREAM, \"\\t.dword\\t0x00000000\\t\\t# <static chain value>\\n\"); \\\n@@ -2987,11 +3049,11 @@ typedef struct mips_args {\n /* A C expression for the size in bytes of the trampoline, as an\n    integer.  */\n \n-#define TRAMPOLINE_SIZE (32 + (Pmode == DImode ? 16 : 8))\n+#define TRAMPOLINE_SIZE (32 + GET_MODE_SIZE (ptr_mode) * 2)\n \n /* Alignment required for trampolines, in bits.  */\n \n-#define TRAMPOLINE_ALIGNMENT (Pmode == DImode ? 64 : 32)\n+#define TRAMPOLINE_ALIGNMENT GET_MODE_BITSIZE (ptr_mode)\n \n /* INITIALIZE_TRAMPOLINE calls this library function to flush\n    program and data caches.  */\n@@ -3008,24 +3070,21 @@ typedef struct mips_args {\n \n #define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t    \\\n {\t\t\t\t\t\t\t\t\t    \\\n-  rtx addr = ADDR;\t\t\t\t\t\t\t    \\\n-  if (Pmode == DImode)\t\t\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (addr, 32)), FUNC); \\\n-      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (addr, 40)), CHAIN);\\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  else\t\t\t\t\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 32)), FUNC); \\\n-      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 36)), CHAIN);\\\n-    }\t\t\t\t\t\t\t\t\t    \\\n+  rtx func_addr, chain_addr;\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  func_addr = plus_constant (ADDR, 32);\t\t\t\t\t    \\\n+  chain_addr = plus_constant (func_addr, GET_MODE_SIZE (ptr_mode));\t    \\\n+  emit_move_insn (gen_rtx_MEM (ptr_mode, func_addr),\t\t\t    \\\n+\t\t  gen_lowpart (ptr_mode, force_reg (Pmode, FUNC)));\t    \\\n+  emit_move_insn (gen_rtx_MEM (ptr_mode, chain_addr),\t\t\t    \\\n+\t\t  gen_lowpart (ptr_mode, force_reg (Pmode, CHAIN)));\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n   /* Flush both caches.  We need to flush the data cache in case\t    \\\n      the system has a write-back cache.  */\t\t\t\t    \\\n   /* ??? Should check the return value for errors.  */\t\t\t    \\\n   if (mips_cache_flush_func && mips_cache_flush_func[0])\t\t    \\\n     emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mips_cache_flush_func),   \\\n-\t\t       0, VOIDmode, 3, addr, Pmode,\t\t\t    \\\n+\t\t       0, VOIDmode, 3, ADDR, Pmode,\t\t\t    \\\n \t\t       GEN_INT (TRAMPOLINE_SIZE), TYPE_MODE (integer_type_node),\\\n \t\t       GEN_INT (3), TYPE_MODE (integer_type_node));\t    \\\n }\n@@ -3113,32 +3172,12 @@ typedef struct mips_args {\n }\n #endif\n \n-/* A C expression that is 1 if the RTX X is a constant which is a\n-   valid address.  This is defined to be the same as `CONSTANT_P (X)',\n-   but rejecting CONST_DOUBLE.  */\n-/* When pic, we must reject addresses of the form symbol+large int.\n-   This is because an instruction `sw $4,s+70000' needs to be converted\n-   by the assembler to `lw $at,s($gp);sw $4,70000($at)'.  Normally the\n-   assembler would use $at as a temp to load in the large offset.  In this\n-   case $at is already in use.  We convert such problem addresses to\n-   `la $5,s;sw $4,70000($5)' via LEGITIMIZE_ADDRESS.  */\n-/* ??? SGI Irix 6 assembler fails for CONST address, so reject them\n-   when !TARGET_GAS.  */\n-/* We should be rejecting everything but const addresses.  */\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n-    || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t&& ! (flag_pic && pic_address_needs_scratch (X))\t\t\\\n-\t&& (TARGET_GAS)\t\t\t\t\t\t\t\\\n-\t&& (mips_abi != ABI_N32 \t\t\t\t\t\\\n-\t    && mips_abi != ABI_64)))\n-\n-\n-/* Define this, so that when PIC, reload won't try to reload invalid\n-   addresses which require two reload registers.  */\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))\n+/* Check for constness inline but use mips_legitimate_address_p\n+   to check whether a constant really is an address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) \\\n+  (CONSTANT_P (X) && mips_legitimate_address_p (SImode, X, 0))\n+\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n@@ -3153,130 +3192,13 @@ typedef struct mips_args {\n    gp pseudo reg (see mips16_gp_pseudo_reg) deciding it is not\n    a LEGITIMATE_CONSTANT.  If we ever want mips16 and ABI_N32 or\n    ABI_64 to work together, we'll need to fix this.  */\n-#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n-  ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n-    || mips_const_double_ok (X, GET_MODE (X)))\t\t\t\t\\\n-   && ! (GET_CODE (X) == CONST \t\t\t\t\t\t\\\n-\t && ! TARGET_GAS\t\t\t\t\t\t\\\n-\t && (mips_abi == ABI_N32 \t\t\t\t\t\\\n-\t     || mips_abi == ABI_64))\t\t\t\t\t\\\n-   && (! TARGET_MIPS16 || mips16_constant (X, GET_MODE (X), 0, 0)))\n-\n-/* A C compound statement that attempts to replace X with a valid\n-   memory address for an operand of mode MODE.  WIN will be a C\n-   statement label elsewhere in the code; the macro definition may\n-   use\n-\n-          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n-\n-   to avoid further processing if the address has become legitimate.\n-\n-   X will always be the result of a call to `break_out_memory_refs',\n-   and OLDX will be the operand that was given to that function to\n-   produce X.\n-\n-   The code generated by this macro should not alter the\n-   substructure of X.  If it transforms X into a more legitimate\n-   form, it should assign X (which will always be a C variable) a\n-   new value.\n-\n-   It is not necessary for this macro to come up with a legitimate\n-   address.  The compiler has standard ways of doing so in all\n-   cases.  In fact, it is safe for this macro to do nothing.  But\n-   often a machine-dependent strategy can generate better code.\n-\n-   For the MIPS, transform:\n-\n-\tmemory(X + <large int>)\n-\n-   into:\n-\n-\tY = <large int> & ~0x7fff;\n-\tZ = X + Y\n-\tmemory (Z + (<large int> & 0x7fff));\n+#define LEGITIMATE_CONSTANT_P(X) (mips_const_insns (X) > 0)\n \n-   This is for CSE to find several similar references, and only use one Z.\n-\n-   When PIC, convert addresses of the form memory (symbol+large int) to\n-   memory (reg+large int).  */\n-\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  register rtx xinsn = (X);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      GO_PRINTF (\"\\n========== LEGITIMIZE_ADDRESS\\n\");\t\t\t\\\n-      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (mips_split_addresses && mips_check_split (X, MODE))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* ??? Is this ever executed?  */\t\t\t\t\t\\\n-      X = gen_rtx_LO_SUM (Pmode,\t\t\t\t\t\\\n-\t\t\t  copy_to_mode_reg (Pmode,\t\t\t\\\n-\t\t\t\t\t    gen_rtx (HIGH, Pmode, X)),\t\\\n-\t\t\t  X);\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == CONST\t\t\t\t\t\t\\\n-      && ((flag_pic && pic_address_needs_scratch (xinsn))\t\t\\\n-\t  /* ??? SGI's Irix 6 assembler can't handle CONST.  */\t\t\\\n-\t  || (!TARGET_GAS\t\t\t\t\t\t\\\n-\t      && (mips_abi == ABI_N32 \t\t\t\t\t\\\n-\t          || mips_abi == ABI_64))))    \t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-      rtx constant = XEXP (XEXP (xinsn, 0), 1);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx_PLUS (Pmode, ptr_reg, constant);\t\t\t\\\n-      if (SMALL_INT (constant))\t\t\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      /* Otherwise we fall through so the code below will fix the\t\\\n-\t constant.  */\t\t\t\t\t\t\t\\\n-      xinsn = X;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n-      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\\\n-      register enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\\\n-      register enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (code0 != REG && code1 == REG)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\t  xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\t  code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n-\t  code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE)\t\t\\\n-\t  && code1 == CONST_INT && !SMALL_INT (xplus1))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx int_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t  rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  emit_move_insn (int_reg,\t\t\t\t\t\\\n-\t\t\t  GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  emit_insn (gen_rtx_SET (VOIDmode,\t\t\t\t\\\n-\t\t\t\t  ptr_reg,\t\t\t\t\\\n-\t\t\t\t  gen_rtx_PLUS (Pmode, xplus0, int_reg))); \\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  X = plus_constant (ptr_reg, INTVAL (xplus1) & 0x7fff);\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n-}\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (mips_legitimize_address (&(X), MODE))\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+  } while (0)\n \n \n /* A C statement or compound statement with a conditional `goto\n@@ -3311,15 +3233,14 @@ typedef struct mips_args {\n \n #define ASM_OUTPUT_POOL_EPILOGUE(FILE, FNNAME, FNDECL, SIZE)\t\\\n   mips_string_length = 0;\n-\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.\n    ??? Using HImode in mips16 mode can cause overflow.  However, the\n    overflow is no more likely than the overflow in a branch\n    instruction.  Large functions can currently break in both ways.  */\n #define CASE_VECTOR_MODE \\\n-  (TARGET_MIPS16 ? HImode : Pmode == DImode ? DImode : SImode)\n+  (TARGET_MIPS16 ? HImode : ptr_mode)\n \n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n@@ -3358,32 +3279,29 @@ typedef struct mips_args {\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n    is done just by pretending it is already truncated.  */\n-/* In 64 bit mode, 32 bit instructions require that register values be properly\n-   sign-extended to 64 bits.  As a result, a truncate is not a no-op if it\n-   converts a value >32 bits to a value <32 bits.  */\n-/* ??? This results in inefficient code for 64 bit to 32 conversions.\n-   Something needs to be done about this.  Perhaps not use any 32 bit\n-   instructions?  Perhaps use PROMOTE_MODE?  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) \\\n   (TARGET_64BIT ? ((INPREC) <= 32 || (OUTPREC) > 32) : 1)\n \n+\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.\n-\n-   For MIPS we make pointers are the smaller of longs and gp-registers.  */\n+   between pointers and any other objects of this machine mode.  */\n \n #ifndef Pmode\n-#define Pmode ((TARGET_LONG64 && TARGET_64BIT) ? DImode : SImode)\n+#define Pmode (TARGET_64BIT && TARGET_LONG64 ? DImode : SImode)\n #endif\n \n-/* A function address in a call instruction\n-   is a word address (for indexing purposes)\n-   so give the MEM rtx a words's mode.  */\n+/* Give call MEMs SImode since it is the \"most permissive\" mode\n+   for both 32-bit and 64-bit targets.  */\n \n-#define FUNCTION_MODE (Pmode == DImode ? DImode : SImode)\n+#define FUNCTION_MODE SImode\n \n \f\n+/* The cost of loading values from the constant pool.  It should be\n+   larger than the cost of any constant we want to synthesise in-line.  */\n+\n+#define CONSTANT_POOL_COST COSTS_N_INSNS (8)\n+\n /* A C expression for the cost of moving data from a register in\n    class FROM to one in class TO.  The classes are expressed using\n    the enumeration values such as `GENERAL_REGS'.  A value of 2 is\n@@ -3456,12 +3374,12 @@ typedef struct mips_args {\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\\\n-  {\"arith_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\\\n-  {\"arith32_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\\\n-  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG,\t\\\n-\t\t\t\t  ADDRESSOF }},\t\t\t\t\\\n-  {\"true_reg_or_0_operand\",\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG,\t\\\n-\t\t\t\t  ADDRESSOF }},\t\t\t\t\\\n+  {\"symbolic_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n+  {\"const_arith_operand\",\t{ CONST, CONST_INT }},\t\t\t\\\n+  {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG, ADDRESSOF }},\t\\\n+  {\"arith32_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\t\\\n+  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n+  {\"true_reg_or_0_operand\",\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n@@ -3472,29 +3390,13 @@ typedef struct mips_args {\n \t\t\t\t  LTU, LEU }},\t\t\t\t\\\n   {\"trap_cmp_op\",\t\t{ EQ, NE, GE, GEU, LT, LTU }},\t\t\\\n   {\"pc_or_label_operand\",\t{ PC, LABEL_REF }},\t\t\t\\\n-  {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG}},\t\\\n+  {\"call_insn_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF, REG }},\t\\\n   {\"move_operand\", \t\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n \t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n-\t\t\t\t  REG, MEM, ADDRESSOF }},\t\t\\\n-  {\"movdi_operand\",\t\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n-\t\t\t\t  REG, MEM, ADDRESSOF, SIGN_EXTEND }},\t\\\n-  {\"se_register_operand\",\t{ SUBREG, REG, ADDRESSOF,\t\t\\\n-\t\t\t\t  SIGN_EXTEND }},\t\t\t\\\n-  {\"se_reg_or_0_operand\",\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG,\t\\\n-\t\t\t\t  ADDRESSOF, SIGN_EXTEND }},\t\t\\\n-  {\"se_uns_arith_operand\",\t{ REG, CONST_INT, SUBREG,\t\t\\\n-\t\t\t\t  ADDRESSOF, SIGN_EXTEND }},\t\t\\\n-  {\"se_arith_operand\",\t\t{ REG, CONST_INT, SUBREG,\t\t\\\n-\t\t\t\t  ADDRESSOF, SIGN_EXTEND }},\t\t\\\n-  {\"se_nonmemory_operand\",\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n-\t\t\t\t  REG, ADDRESSOF, SIGN_EXTEND }},\t\\\n+\t\t\t\t  REG, MEM}},\t\t\t\t\\\n   {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n \t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n-  {\"fcc_register_operand\",\t{ REG, SUBREG }},\t\t\t\\\n-  {\"extend_operator\",           { SIGN_EXTEND, ZERO_EXTEND }},          \\\n-  {\"highpart_shift_operator\",   { ASHIFTRT, LSHIFTRT, ROTATERT, ROTATE }},\n+  {\"fcc_register_operand\",\t{ REG, SUBREG }},\n \n /* A list of predicates that do special things with modes, and so\n    should not elicit warnings for VOIDmode match_operand.  */\n@@ -4068,7 +3970,7 @@ do {\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n   fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n-\t   Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t   ptr_mode == DImode ? \".dword\" : \".word\",\t\t\t\\\n \t   LOCAL_LABEL_PREFIX,\t\t\t\t\t\t\\\n \t   VALUE)\n \n@@ -4083,17 +3985,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n   else if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d-%sLS%d\\n\",\t\t\t\t\\\n-\t     Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t     ptr_mode == DImode ? \".dword\" : \".word\",\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n-  else if (mips_abi == ABI_32 || mips_abi == ABI_O64\t\t\t\\\n-\t   || (TARGET_GAS && mips_abi == ABI_N32)\t\t\t\\\n-\t   || (TARGET_GAS && mips_abi == ABI_64))\t\t\t\\\n+  else if (TARGET_GPWORD)\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n-\t     Pmode == DImode ? \".gpdword\" : \".gpword\",\t\t\t\\\n+\t     ptr_mode == DImode ? \".gpdword\" : \".gpword\",\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n-\t     Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n+\t     ptr_mode == DImode ? \".dword\" : \".word\",\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n } while (0)\n \n@@ -4244,11 +4144,13 @@ while (0)\n /* Default definitions for size_t and ptrdiff_t.  We must override the\n    definitions from ../svr4.h on mips-*-linux-gnu.  */\n \n-#undef SIZE_TYPE\n-#define SIZE_TYPE (Pmode == DImode ? \"long unsigned int\" : \"unsigned int\")\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE (POINTER_SIZE == 64 ? \"long unsigned int\" : \"unsigned int\")\n+#endif\n \n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE (Pmode == DImode ? \"long int\" : \"int\")\n+#ifndef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n+#endif\n \n /* See mips_expand_prologue's use of loadgp for when this should be\n    true.  */"}, {"sha": "c42c9d893a8f81423222c8c13786e982aa1ae4c5", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1582, "deletions": 2244, "changes": 3826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191"}, {"sha": "76417b620f810fc91783a70d531a4ea858dc4ec6", "filename": "gcc/config/mips/sr71k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fsr71k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Fsr71k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsr71k.md?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -206,7 +206,7 @@\n (define_insn_reservation \"ir_sr70_arith\"\n                                1\n                           (and (eq_attr \"cpu\" \"sr71000\")\n-                               (eq_attr \"type\" \"arith,darith\"))\n+                               (eq_attr \"type\" \"arith,darith,const\"))\n                          \"ri_insns\")\n \n ;; emulate repeat (dispatch stall) by spending extra cycle(s) in"}, {"sha": "dba6aded0214058f29fc6218c882e0ee55d86ce2", "filename": "gcc/config/mips/t-elf", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfig%2Fmips%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-elf?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -31,9 +31,9 @@ TARGET_LIBGCC2_CFLAGS = -G 0\n \n # Build the libraries for both hard and soft floating point\n \n-MULTILIB_OPTIONS = msoft-float EL/EB\n-MULTILIB_DIRNAMES = soft-float el eb\n-MULTILIB_MATCHES = EL=mel EB=meb\n+#MULTILIB_OPTIONS = msoft-float EL/EB\n+#MULTILIB_DIRNAMES = soft-float el eb\n+#MULTILIB_MATCHES = EL=mel EB=meb\n #MULTILIB_MATCHES = msingle-float=m4650\n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n "}, {"sha": "c879102eb5be1b2048358dffedb28b119f3d1dc1", "filename": "gcc/configure", "status": "modified", "additions": 9406, "deletions": 4058, "changes": 13464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191"}, {"sha": "dc8ebedf0a9aa84edc4a819dbfbf878d40fcd0a5", "filename": "gcc/configure.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafe096b4078bb18ff8e9fad8cfdca5ad0b49191/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=cafe096b4078bb18ff8e9fad8cfdca5ad0b49191", "patch": "@@ -2600,6 +2600,23 @@ case \"$target\" in\n         [Define if your MIPS libgloss linker scripts consistently include STARTUP directives.])\n     fi\n     AC_MSG_RESULT($gcc_cv_mips_libgloss_startup)\n+\n+    AC_MSG_CHECKING(whether the assembler has explicit relocation support)\n+    if test x$gcc_cv_mips_explicit_relocs = x; then\n+      gcc_cv_mips_explicit_relocs=no\n+      if test x$gcc_cv_as != x; then\n+\techo '  lw $4,%gp_rel(foo)($4)' > conftest.s\n+\tif $gcc_cv_as conftest.s -o conftest.o > /dev/null 2>&1; then\n+\t  gcc_cv_mips_explicit_relocs=yes\n+\tfi\n+\trm -f conftest.s conftest.o\n+      fi\n+    fi\n+    if test $gcc_cv_mips_explicit_relocs = yes; then\n+      test x$target_cpu_default != x || target_cpu_default=0\n+      target_cpu_default=\"(${target_cpu_default}|MASK_EXPLICIT_RELOCS)\"\n+    fi\n+    AC_MSG_RESULT($gcc_cv_mips_explicit_relocs)\n     ;;\n esac\n "}]}