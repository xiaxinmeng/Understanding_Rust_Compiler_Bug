{"sha": "2483ad581a25b4e7aad16c11fce6757b6af36d8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4M2FkNTgxYTI1YjRlN2FhZDE2YzExZmNlNjc1N2I2YWYzNmQ4Yw==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2005-08-18T20:01:54Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2005-08-18T20:01:54Z"}, "message": "Fix FreeBSD failure with recursive malloc call.\n\n* mf-hooks1.c (malloc, calloc, realloc, free,\n__mf_wrap_alloca_indirect): Call BEGIN_MALLOC_PROTECT before calling\nthe real routines, and END_MALLOC_PROTECT afterwards.\n* mf-impl.h (enum __mf_state_enum): Expand comment.  Add in_malloc.\n(BEGIN_PROTECT): Handle in_malloc state.\n(BEGIN_MALLOC_PROTECT, END_MALLOC_PROTECT): New.\n* testsuite/libmudflap.c/hook2-allocstuff.c: New.\n\nFrom-SVN: r103256", "tree": {"sha": "e892f1756c7f014246b880abc4d6a071e49ab659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e892f1756c7f014246b880abc4d6a071e49ab659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2483ad581a25b4e7aad16c11fce6757b6af36d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2483ad581a25b4e7aad16c11fce6757b6af36d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2483ad581a25b4e7aad16c11fce6757b6af36d8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2483ad581a25b4e7aad16c11fce6757b6af36d8c/comments", "author": null, "committer": null, "parents": [{"sha": "9ed8fb9bbc80c980055f9520237c7ab99ac2e660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed8fb9bbc80c980055f9520237c7ab99ac2e660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ed8fb9bbc80c980055f9520237c7ab99ac2e660"}], "stats": {"total": 61, "additions": 59, "deletions": 2}, "files": [{"sha": "717be4f7be62ef8ab98a1207d56cc4c0800ad0c3", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=2483ad581a25b4e7aad16c11fce6757b6af36d8c", "patch": "@@ -1,3 +1,13 @@\n+2005-08-17  Jim Wilson  <wilson@specifix.com>\n+\n+\t* mf-hooks1.c (malloc, calloc, realloc, free,\n+\t__mf_wrap_alloca_indirect): Call BEGIN_MALLOC_PROTECT before calling\n+\tthe real routines, and END_MALLOC_PROTECT afterwards.\n+\t* mf-impl.h (enum __mf_state_enum): Expand comment.  Add in_malloc.\n+\t(BEGIN_PROTECT): Handle in_malloc state.\n+\t(BEGIN_MALLOC_PROTECT, END_MALLOC_PROTECT): New.\n+\t* testsuite/libmudflap.c/hook2-allocstuff.c: New.\n+\n 2005-08-17  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* All files: Update FSF address."}, {"sha": "a99d7726e9da119cdd222bfcd283577cc71c64e3", "filename": "libmudflap/mf-hooks1.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Fmf-hooks1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Fmf-hooks1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks1.c?ref=2483ad581a25b4e7aad16c11fce6757b6af36d8c", "patch": "@@ -108,7 +108,9 @@ WRAPPER(void *, malloc, size_t c)\n   size_with_crumple_zones =\n     CLAMPADD(c,CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t__mf_opts.crumple_zone));\n+  BEGIN_MALLOC_PROTECT ();\n   result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n+  END_MALLOC_PROTECT ();\n \n   if (LIKELY(result))\n     {\n@@ -145,7 +147,9 @@ WRAPPER(void *, calloc, size_t c, size_t n)\n     CLAMPADD((c * n), /* XXX: CLAMPMUL */\n \t     CLAMPADD(__mf_opts.crumple_zone,\n \t\t      __mf_opts.crumple_zone));\n+  BEGIN_MALLOC_PROTECT ();\n   result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n+  END_MALLOC_PROTECT ();\n \n   if (LIKELY(result))\n     memset (result, 0, size_with_crumple_zones);\n@@ -187,7 +191,9 @@ WRAPPER(void *, realloc, void *buf, size_t c)\n   size_with_crumple_zones =\n     CLAMPADD(c, CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t __mf_opts.crumple_zone));\n+  BEGIN_MALLOC_PROTECT ();\n   result = (char *) CALL_REAL (realloc, base, size_with_crumple_zones);\n+  END_MALLOC_PROTECT ();\n \n   /* Ensure heap wiping doesn't occur during this peculiar\n      unregister/reregister pair.  */\n@@ -272,7 +278,9 @@ WRAPPER(void, free, void *buf)\n \t\t\t     (void *) freeme,\n \t\t\t     __mf_opts.crumple_zone);\n \t    }\n+\t  BEGIN_MALLOC_PROTECT ();\n \t  CALL_REAL (free, freeme);\n+\t  END_MALLOC_PROTECT ();\n \t}\n     }\n   else\n@@ -287,7 +295,9 @@ WRAPPER(void, free, void *buf)\n \t\t\t (void *) buf,\n \t\t\t __mf_opts.crumple_zone);\n \t}\n+      BEGIN_MALLOC_PROTECT ();\n       CALL_REAL (free, base);\n+      END_MALLOC_PROTECT ();\n     }\n }\n \n@@ -420,23 +430,31 @@ __mf_wrap_alloca_indirect (size_t c)\n     {\n       struct alloca_tracking *next = alloca_history->next;\n       __mf_unregister (alloca_history->ptr, 0, __MF_TYPE_HEAP);\n+      BEGIN_MALLOC_PROTECT ();\n       CALL_REAL (free, alloca_history->ptr);\n       CALL_REAL (free, alloca_history);\n+      END_MALLOC_PROTECT ();\n       alloca_history = next;\n     }\n \n   /* Allocate new block.  */\n   result = NULL;\n   if (LIKELY (c > 0)) /* alloca(0) causes no allocation.  */\n     {\n+      BEGIN_MALLOC_PROTECT ();\n       track = (struct alloca_tracking *) CALL_REAL (malloc,\n \t\t\t\t\t\t    sizeof (struct alloca_tracking));\n+      END_MALLOC_PROTECT ();\n       if (LIKELY (track != NULL))\n \t{\n+\t  BEGIN_MALLOC_PROTECT ();\n \t  result = CALL_REAL (malloc, c);\n+\t  END_MALLOC_PROTECT ();\n \t  if (UNLIKELY (result == NULL))\n \t    {\n+\t      BEGIN_MALLOC_PROTECT ();\n \t      CALL_REAL (free, track);\n+\t      END_MALLOC_PROTECT ();\n \t      /* Too bad.  XXX: What about errno?  */\n \t    }\n \t  else"}, {"sha": "e61f4b7a85ad1a7097182cee1c06270e0cf5608f", "filename": "libmudflap/mf-impl.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Fmf-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Fmf-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-impl.h?ref=2483ad581a25b4e7aad16c11fce6757b6af36d8c", "patch": "@@ -94,9 +94,17 @@ extern int __mf_heuristic_check (uintptr_t, uintptr_t);\n /* Type definitions. */\n /* ------------------------------------------------------------------------ */\n \n-/* The mf_state type codes describe recursion and initialization order. */\n+/* The mf_state type codes describe recursion and initialization order.\n \n-enum __mf_state_enum { active, reentrant };\n+   reentrant means we are inside a mf-runtime support routine, such as\n+   __mf_register, and thus there should be no calls to any wrapped functions,\n+   such as the wrapped malloc.  This indicates a bug if it occurs.\n+   in_malloc means we are inside a real malloc call inside a wrapped malloc\n+   call, and thus there should be no calls to any wrapped functions like the\n+   wrapped mmap.  This happens on some systems due to how the system libraries\n+   are constructed.  */\n+\n+enum __mf_state_enum { active, reentrant, in_malloc }; \n \n /* The __mf_options structure records optional or tunable aspects of the\n  mudflap library's behavior. There is a single global instance of this\n@@ -379,11 +387,23 @@ ret __mfwrap_ ## fname (__VA_ARGS__)\n     __mf_reentrancy ++; \\\n     return CALL_REAL(fname, __VA_ARGS__);   \\\n   }                                         \\\n+  else if (UNLIKELY (__mf_get_state () == in_malloc))   \\\n+  {                                         \\\n+    return CALL_REAL(fname, __VA_ARGS__);   \\\n+  }                                         \\\n   else                                      \\\n   {                                         \\\n     TRACE (\"%s\\n\", __PRETTY_FUNCTION__); \\\n   }\n \n+/* There is an assumption here that these will only be called in routines\n+   that call BEGIN_PROTECT at the start, and hence the state must always\n+   be active when BEGIN_MALLOC_PROTECT is called.  */\n+#define BEGIN_MALLOC_PROTECT() \\\n+  __mf_set_state (in_malloc)\n+\n+#define END_MALLOC_PROTECT() \\\n+  __mf_set_state (active)\n \n /* Unlocked variants of main entry points from mf-runtime.h.  */\n extern void __mfu_check (void *ptr, size_t sz, int type, const char *location);"}, {"sha": "d8fbec4676da55c4d04111800a8222591357171c", "filename": "libmudflap/testsuite/libmudflap.c/hook2-allocstuff.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2483ad581a25b4e7aad16c11fce6757b6af36d8c/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c?ref=2483ad581a25b4e7aad16c11fce6757b6af36d8c", "patch": "@@ -0,0 +1,9 @@\n+/* Generates recursive malloc call on i386-freebsd4.10 with -fmudflap.  */\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  char *p = malloc (1<<24);\n+  return 0;\n+}"}]}