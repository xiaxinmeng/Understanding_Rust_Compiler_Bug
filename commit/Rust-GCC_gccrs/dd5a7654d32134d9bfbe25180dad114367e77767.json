{"sha": "dd5a7654d32134d9bfbe25180dad114367e77767", "node_id": "C_kwDOANBUbNoAKGRkNWE3NjU0ZDMyMTM0ZDliZmJlMjUxODBkYWQxMTQzNjdlNzc3Njc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-09T10:40:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-09T10:40:43Z"}, "message": "Merge #1222 #1223 #1225\n\n1222: Destructure our generics, placeholers or projections during coercion r=philberty a=philberty\n\nWhen we coerce types we need to destructure from the generics in order to\r\napply these coercion rules correctly or we end up returning a bad\r\nerror_mark_node.\r\n\r\nThis was found while fixing https://github.com/Rust-GCC/gccrs/pull/1220\n\n1223: Add new monomorphize_clone interface r=philberty a=philberty\n\nThis interface is required when we monomorphize since types might be\r\n\r\n placeholder -> projection -> param -> actual-type\r\n\r\nThis gives us a clean clone interface to destructure this into its actual\r\ntype. This is important so for example if we have a generic trait function\r\nand resolve the function for a specific set of generics we update the\r\nassociated types. This works, then when we go to substitute the same\r\ngeneric trait again the placeholders are again updated throwing off the\r\ntyping for the first type.\r\n\r\nThere is more cleanup we can do once this PR is in to make this part of\r\nthe general monomorphization path so that we sort out these as part\r\nof the fntype\r\n\r\nFixes #1133\r\n\n\n1225: macros: Error out when repeating metavars which refer to repetitions r=CohenArthur a=CohenArthur\n\nIn the case were a repeting metavar was used as a regular metavar ($var\r\ninstead of $($var)* for example), the compiler would crash on an\r\nassertion that $var was only repeating once. We should instead error out\r\nand point to the user that this is probably not what they intended to\r\ndo.\r\n\r\nSome spurious errors are emitted, but improving them requires a major refactor of the SubstitutionContext file to report error states before.\r\n\r\nCloses #1224 \r\n\r\nThanks to `@bjorn3` for pointing this out.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>", "tree": {"sha": "7e12b48420f98b819e567ef478d189db58853aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e12b48420f98b819e567ef478d189db58853aed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd5a7654d32134d9bfbe25180dad114367e77767", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJieO+rCRBK7hj4Ov3rIwAANWAIAEPLhuBmdk9LlPCMZ60nmUHj\nXVxptuxAmwjC93oF114VN1OjQ9AQ7nL9zVP+ZwdaxqkbSdFktDyjZNyMAdskHDl6\nDHC6ajrp9Tp61zk/9A5PuK5LzJOYySiBk3s/fLcTCsPbGXI2SYvqEZo7+WG3HkPX\nHtwW4sooFDtwSaOLojBFVtWUpW70PQLj65SIqNhhjNlaVXVovKxyWLz2Vuu6wUXC\nbhTs1lFfT75KaJ6cTAx3r2+mKy2P5cMHSIWgdp+BX+EQogtwNVgwKW4nuQjIrUjQ\nmT5/cqFpoSyLBzlapNaQhay+vZhc9kYoSniTgjVKaJMWerHsjWdKrrOYr/w49H4=\n=RBek\n-----END PGP SIGNATURE-----\n", "payload": "tree 7e12b48420f98b819e567ef478d189db58853aed\nparent 3b8f3e61394f27100fb788a839e61f8b753f502b\nparent 55346cc59b766266202a0ba2114275eb2fc53dda\nparent cb4d935508def8b250345ba5205a90ad9e177ab4\nparent 16da547c6de0957d4dd697c53260a6bb9a087163\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1652092843 +0000\ncommitter GitHub <noreply@github.com> 1652092843 +0000\n\nMerge #1222 #1223 #1225\n\n1222: Destructure our generics, placeholers or projections during coercion r=philberty a=philberty\n\nWhen we coerce types we need to destructure from the generics in order to\r\napply these coercion rules correctly or we end up returning a bad\r\nerror_mark_node.\r\n\r\nThis was found while fixing https://github.com/Rust-GCC/gccrs/pull/1220\n\n1223: Add new monomorphize_clone interface r=philberty a=philberty\n\nThis interface is required when we monomorphize since types might be\r\n\r\n placeholder -> projection -> param -> actual-type\r\n\r\nThis gives us a clean clone interface to destructure this into its actual\r\ntype. This is important so for example if we have a generic trait function\r\nand resolve the function for a specific set of generics we update the\r\nassociated types. This works, then when we go to substitute the same\r\ngeneric trait again the placeholders are again updated throwing off the\r\ntyping for the first type.\r\n\r\nThere is more cleanup we can do once this PR is in to make this part of\r\nthe general monomorphization path so that we sort out these as part\r\nof the fntype\r\n\r\nFixes #1133\r\n\n\n1225: macros: Error out when repeating metavars which refer to repetitions r=CohenArthur a=CohenArthur\n\nIn the case were a repeting metavar was used as a regular metavar ($var\r\ninstead of $($var)* for example), the compiler would crash on an\r\nassertion that $var was only repeating once. We should instead error out\r\nand point to the user that this is probably not what they intended to\r\ndo.\r\n\r\nSome spurious errors are emitted, but improving them requires a major refactor of the SubstitutionContext file to report error states before.\r\n\r\nCloses #1224 \r\n\r\nThanks to `@bjorn3` for pointing this out.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5a7654d32134d9bfbe25180dad114367e77767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5a7654d32134d9bfbe25180dad114367e77767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5a7654d32134d9bfbe25180dad114367e77767/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8f3e61394f27100fb788a839e61f8b753f502b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8f3e61394f27100fb788a839e61f8b753f502b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8f3e61394f27100fb788a839e61f8b753f502b"}, {"sha": "55346cc59b766266202a0ba2114275eb2fc53dda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55346cc59b766266202a0ba2114275eb2fc53dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55346cc59b766266202a0ba2114275eb2fc53dda"}, {"sha": "cb4d935508def8b250345ba5205a90ad9e177ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4d935508def8b250345ba5205a90ad9e177ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4d935508def8b250345ba5205a90ad9e177ab4"}, {"sha": "16da547c6de0957d4dd697c53260a6bb9a087163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16da547c6de0957d4dd697c53260a6bb9a087163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16da547c6de0957d4dd697c53260a6bb9a087163"}], "stats": {"total": 517, "additions": 496, "deletions": 21}, "files": [{"sha": "52e0568c88e4c31140c75e78beaac010e5a10168", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -40,8 +40,8 @@ class HIRCompileBase\n protected:\n   Context *get_context () { return ctx; }\n \n-  tree coercion_site (tree rvalue, TyTy::BaseType *actual,\n-\t\t      TyTy::BaseType *expected, Location lvalue_locus,\n+  tree coercion_site (tree rvalue, const TyTy::BaseType *actual,\n+\t\t      const TyTy::BaseType *expected, Location lvalue_locus,\n \t\t      Location rvalue_locus);\n \n   tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,"}, {"sha": "d9349d5a07bdf94895cdfbcc3f42b3bd197f394f", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -198,21 +198,26 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n // Shared methods in compilation\n \n tree\n-HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n-\t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n-\t\t\t       Location rvalue_locus)\n+HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n+\t\t\t       const TyTy::BaseType *lval,\n+\t\t\t       Location lvalue_locus, Location rvalue_locus)\n {\n   if (rvalue == error_mark_node)\n     return error_mark_node;\n \n+  const TyTy::BaseType *actual = rval->destructure ();\n+  const TyTy::BaseType *expected = lval->destructure ();\n+\n   if (expected->get_kind () == TyTy::TypeKind::REF)\n     {\n       // bad coercion... of something to a reference\n       if (actual->get_kind () != TyTy::TypeKind::REF)\n \treturn error_mark_node;\n \n-      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n-      TyTy::ReferenceType *act = static_cast<TyTy::ReferenceType *> (actual);\n+      const TyTy::ReferenceType *exp\n+\t= static_cast<const TyTy::ReferenceType *> (expected);\n+      const TyTy::ReferenceType *act\n+\t= static_cast<const TyTy::ReferenceType *> (actual);\n \n       tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n       tree deref_rvalue\n@@ -235,20 +240,22 @@ HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n       if (!valid_coercion)\n \treturn error_mark_node;\n \n-      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n+      const TyTy::ReferenceType *exp\n+\t= static_cast<const TyTy::ReferenceType *> (expected);\n \n       TyTy::BaseType *actual_base = nullptr;\n       tree expected_type = error_mark_node;\n       if (actual->get_kind () == TyTy::TypeKind::REF)\n \t{\n-\t  TyTy::ReferenceType *act\n-\t    = static_cast<TyTy::ReferenceType *> (actual);\n+\t  const TyTy::ReferenceType *act\n+\t    = static_cast<const TyTy::ReferenceType *> (actual);\n \t  actual_base = act->get_base ();\n \t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n \t{\n-\t  TyTy::PointerType *act = static_cast<TyTy::PointerType *> (actual);\n+\t  const TyTy::PointerType *act\n+\t    = static_cast<const TyTy::PointerType *> (actual);\n \t  actual_base = act->get_base ();\n \t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}"}, {"sha": "b7ab3abc0d9273df2e31b374ed8370be9b0eb817", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -16,6 +16,21 @@ SubstituteCtx::substitute_metavar (std::unique_ptr<AST::Token> &metavar)\n     }\n   else\n     {\n+      // If we are expanding a metavar which has a lof of matches, we are\n+      // currently expanding a repetition metavar - not a simple metavar. We\n+      // need to error out and inform the user.\n+      // Associated test case for an example: compile/macro-issue1224.rs\n+      if (it->second.get_match_amount () != 1)\n+\t{\n+\t  rust_error_at (metavar->get_locus (),\n+\t\t\t \"metavariable is still repeating at this depth\");\n+\t  rust_inform (\n+\t    metavar->get_locus (),\n+\t    \"you probably forgot the repetition operator: %<%s%s%s%>\", \"$(\",\n+\t    metavar->as_string ().c_str (), \")*\");\n+\t  return expanded;\n+\t}\n+\n       // We only care about the vector when expanding repetitions.\n       // Just access the first element of the vector.\n       auto &frag = it->second.get_single_fragment ();"}, {"sha": "c499204a40c9cbcab76cf2b1cb6a0e7b8f79c2c8", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -469,7 +469,8 @@ TypeCheckExpr::resolve_operator_overload (\n   fn->monomorphize ();\n \n   // get the return type\n-  TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n+  TyTy::BaseType *function_ret_tyty\n+    = type->get_return_type ()->monomorphized_clone ();\n \n   // store the expected fntype\n   context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);"}, {"sha": "6b034ea63a7e6762c48899ca98973c4ca0556116", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 258, "deletions": 9, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -229,6 +229,38 @@ BaseType::get_root () const\n   return root;\n }\n \n+const BaseType *\n+BaseType::destructure () const\n+{\n+  switch (get_kind ())\n+    {\n+      case TyTy::TypeKind::PARAM: {\n+\tconst TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (this);\n+\treturn p->resolve ();\n+      }\n+      break;\n+\n+      case TyTy::TypeKind::PLACEHOLDER: {\n+\tconst TyTy::PlaceholderType *p\n+\t  = static_cast<const TyTy::PlaceholderType *> (this);\n+\trust_assert (p->can_resolve ());\n+\treturn p->resolve ();\n+      }\n+      break;\n+\n+      case TyTy::TypeKind::PROJECTION: {\n+\tconst TyTy::ProjectionType *p\n+\t  = static_cast<const TyTy::ProjectionType *> (this);\n+\treturn p->get ();\n+      }\n+\n+    default:\n+      return this;\n+    }\n+\n+  return this;\n+}\n+\n TyVar::TyVar (HirId ref) : ref (ref)\n {\n   // ensure this reference is defined within the context\n@@ -284,6 +316,32 @@ TyVar::subst_covariant_var (TyTy::BaseType *orig, TyTy::BaseType *subst)\n   return TyVar (subst->get_ref ());\n }\n \n+TyVar\n+TyVar::clone () const\n+{\n+  TyTy::BaseType *c = get_tyty ()->clone ();\n+  return TyVar (c->get_ref ());\n+}\n+\n+TyVar\n+TyVar::monomorphized_clone () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  // this needs a new hirid\n+  TyTy::BaseType *c = get_tyty ()->monomorphized_clone ();\n+  c->set_ref (mappings->get_next_hir_id ());\n+\n+  // insert it\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID, c->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tc);\n+\n+  return TyVar (c->get_ref ());\n+}\n+\n void\n InferType::accept_vis (TyVisitor &vis)\n {\n@@ -372,6 +430,12 @@ InferType::clone () const\n   return clone;\n }\n \n+BaseType *\n+InferType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n bool\n InferType::default_type (BaseType **type) const\n {\n@@ -445,6 +509,12 @@ ErrorType::clone () const\n   return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+ErrorType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n std::string\n StructFieldType::as_string () const\n {\n@@ -475,6 +545,13 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n+StructFieldType *\n+StructFieldType::monomorphized_clone () const\n+{\n+  return new StructFieldType (get_ref (), get_name (),\n+\t\t\t      get_field_type ()->monomorphized_clone ());\n+}\n+\n bool\n SubstitutionParamMapping::need_substitution () const\n {\n@@ -965,6 +1042,19 @@ ADTType::clone () const\n \t\t      get_combined_refs ());\n }\n \n+BaseType *\n+ADTType::monomorphized_clone () const\n+{\n+  std::vector<VariantDef *> cloned_variants;\n+  for (auto &variant : variants)\n+    cloned_variants.push_back (variant->monomorphized_clone ());\n+\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, ident,\n+\t\t      get_adt_kind (), cloned_variants, clone_substs (),\n+\t\t      get_repr_options (), used_arguments,\n+\t\t      get_combined_refs ());\n+}\n+\n static bool\n handle_substitions (SubstitutionArgumentMappings &subst_mappings,\n \t\t    StructFieldType *field)\n@@ -1127,8 +1217,23 @@ TupleType::is_equal (const BaseType &other) const\n BaseType *\n TupleType::clone () const\n {\n-  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus, fields,\n-\t\t\tget_combined_refs ());\n+  std::vector<TyVar> cloned_fields;\n+  for (const auto &f : fields)\n+    cloned_fields.push_back (f.clone ());\n+\n+  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus,\n+\t\t\tcloned_fields, get_combined_refs ());\n+}\n+\n+BaseType *\n+TupleType::monomorphized_clone () const\n+{\n+  std::vector<TyVar> cloned_fields;\n+  for (const auto &f : fields)\n+    cloned_fields.push_back (f.monomorphized_clone ());\n+\n+  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus,\n+\t\t\tcloned_fields, get_combined_refs ());\n }\n \n TupleType *\n@@ -1265,8 +1370,20 @@ FnType::clone () const\n {\n   std::vector<std::pair<HIR::Pattern *, BaseType *>> cloned_params;\n   for (auto &p : params)\n-    cloned_params.push_back (\n-      std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n+    cloned_params.push_back ({p.first, p.second->clone ()});\n+\n+  return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n+\t\t     ident, flags, abi, std::move (cloned_params),\n+\t\t     get_return_type ()->clone (), clone_substs (),\n+\t\t     get_combined_refs ());\n+}\n+\n+BaseType *\n+FnType::monomorphized_clone () const\n+{\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back ({p.first, p.second->monomorphized_clone ()});\n \n   return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n \t\t     ident, flags, abi, std::move (cloned_params),\n@@ -1480,6 +1597,18 @@ FnPtr::clone () const\n \t\t    get_combined_refs ());\n }\n \n+BaseType *\n+FnPtr::monomorphized_clone () const\n+{\n+  std::vector<TyVar> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back (p.monomorphized_clone ());\n+\n+  return new FnPtr (get_ref (), get_ty_ref (), ident.locus,\n+\t\t    std::move (cloned_params), result_type,\n+\t\t    get_combined_refs ());\n+}\n+\n void\n ClosureType::accept_vis (TyVisitor &vis)\n {\n@@ -1540,6 +1669,12 @@ ClosureType::clone () const\n \t\t\t  result_type, clone_substs (), get_combined_refs ());\n }\n \n+BaseType *\n+ClosureType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n ClosureType *\n ClosureType::handle_substitions (SubstitutionArgumentMappings mappings)\n {\n@@ -1620,6 +1755,14 @@ ArrayType::clone () const\n \t\t\telement_type, get_combined_refs ());\n }\n \n+BaseType *\n+ArrayType::monomorphized_clone () const\n+{\n+  return new ArrayType (get_ref (), get_ty_ref (), ident.locus, capacity_expr,\n+\t\t\telement_type.monomorphized_clone (),\n+\t\t\tget_combined_refs ());\n+}\n+\n ArrayType *\n ArrayType::handle_substitions (SubstitutionArgumentMappings mappings)\n {\n@@ -1705,7 +1848,15 @@ SliceType::get_element_type () const\n BaseType *\n SliceType::clone () const\n {\n-  return new SliceType (get_ref (), get_ty_ref (), ident.locus, element_type,\n+  return new SliceType (get_ref (), get_ty_ref (), ident.locus,\n+\t\t\telement_type.clone (), get_combined_refs ());\n+}\n+\n+BaseType *\n+SliceType::monomorphized_clone () const\n+{\n+  return new SliceType (get_ref (), get_ty_ref (), ident.locus,\n+\t\t\telement_type.monomorphized_clone (),\n \t\t\tget_combined_refs ());\n }\n \n@@ -1777,6 +1928,12 @@ BoolType::clone () const\n   return new BoolType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+BoolType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n void\n IntType::accept_vis (TyVisitor &vis)\n {\n@@ -1844,6 +2001,12 @@ IntType::clone () const\n \t\t      get_combined_refs ());\n }\n \n+BaseType *\n+IntType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n bool\n IntType::is_equal (const BaseType &other) const\n {\n@@ -1921,6 +2084,12 @@ UintType::clone () const\n \t\t       get_combined_refs ());\n }\n \n+BaseType *\n+UintType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n bool\n UintType::is_equal (const BaseType &other) const\n {\n@@ -1992,6 +2161,12 @@ FloatType::clone () const\n \t\t\tget_combined_refs ());\n }\n \n+BaseType *\n+FloatType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n bool\n FloatType::is_equal (const BaseType &other) const\n {\n@@ -2054,6 +2229,12 @@ USizeType::clone () const\n   return new USizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+USizeType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n void\n ISizeType::accept_vis (TyVisitor &vis)\n {\n@@ -2106,6 +2287,12 @@ ISizeType::clone () const\n   return new ISizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+ISizeType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n void\n CharType::accept_vis (TyVisitor &vis)\n {\n@@ -2158,6 +2345,12 @@ CharType::clone () const\n   return new CharType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+CharType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n void\n ReferenceType::accept_vis (TyVisitor &vis)\n {\n@@ -2228,6 +2421,14 @@ ReferenceType::clone () const\n \t\t\t    get_combined_refs ());\n }\n \n+BaseType *\n+ReferenceType::monomorphized_clone () const\n+{\n+  return new ReferenceType (get_ref (), get_ty_ref (),\n+\t\t\t    base.monomorphized_clone (), mutability (),\n+\t\t\t    get_combined_refs ());\n+}\n+\n ReferenceType *\n ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n {\n@@ -2314,6 +2515,14 @@ PointerType::clone () const\n \t\t\t  get_combined_refs ());\n }\n \n+BaseType *\n+PointerType::monomorphized_clone () const\n+{\n+  return new PointerType (get_ref (), get_ty_ref (),\n+\t\t\t  base.monomorphized_clone (), mutability (),\n+\t\t\t  get_combined_refs ());\n+}\n+\n PointerType *\n PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n {\n@@ -2398,6 +2607,12 @@ ParamType::clone () const\n \t\t\tparam, get_specified_bounds (), get_combined_refs ());\n }\n \n+BaseType *\n+ParamType::monomorphized_clone () const\n+{\n+  return resolve ()->clone ();\n+}\n+\n std::string\n ParamType::get_symbol () const\n {\n@@ -2479,6 +2694,12 @@ StrType::clone () const\n   return new StrType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+StrType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n void\n StrType::accept_vis (TyVisitor &vis)\n {\n@@ -2583,6 +2804,12 @@ NeverType::clone () const\n   return new NeverType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+BaseType *\n+NeverType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n // placeholder type\n \n void\n@@ -2639,6 +2866,15 @@ PlaceholderType::clone () const\n \t\t\t      get_combined_refs ());\n }\n \n+BaseType *\n+PlaceholderType::monomorphized_clone () const\n+{\n+  if (can_resolve ())\n+    return resolve ()->monomorphized_clone ();\n+\n+  return clone ();\n+}\n+\n void\n PlaceholderType::set_associated_type (HirId ref)\n {\n@@ -2734,11 +2970,17 @@ ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n BaseType *\n ProjectionType::clone () const\n {\n-  return new ProjectionType (get_ref (), get_ty_ref (), base, trait, item,\n-\t\t\t     clone_substs (), used_arguments,\n+  return new ProjectionType (get_ref (), get_ty_ref (), base->clone (), trait,\n+\t\t\t     item, clone_substs (), used_arguments,\n \t\t\t     get_combined_refs ());\n }\n \n+BaseType *\n+ProjectionType::monomorphized_clone () const\n+{\n+  return get ()->monomorphized_clone ();\n+}\n+\n ProjectionType *\n ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n@@ -2864,6 +3106,12 @@ DynamicObjectType::clone () const\n \t\t\t\tspecified_bounds, get_combined_refs ());\n }\n \n+BaseType *\n+DynamicObjectType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n std::string\n DynamicObjectType::get_name () const\n {\n@@ -3087,7 +3335,7 @@ TypeCheckCallExpr::visit (FnPtr &type)\n       return;\n     }\n \n-  resolved = type.get_return_type ()->clone ();\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n }\n \n // method call checker\n@@ -3143,7 +3391,8 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n     }\n \n   type.monomorphize ();\n-  resolved = type.get_return_type ()->clone ();\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n }\n \n } // namespace TyTy"}, {"sha": "5f35c320a5fb5538573600d1636132227d4fc885", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -212,6 +212,9 @@ class BaseType : public TypeBoundsMappings\n    * releasing the memory of the returned ty. */\n   virtual BaseType *clone () const = 0;\n \n+  // TODO\n+  virtual BaseType *monomorphized_clone () const = 0;\n+\n   // get_combined_refs returns the chain of node refs involved in unification\n   std::set<HirId> get_combined_refs () const { return combined; }\n \n@@ -253,8 +256,13 @@ class BaseType : public TypeBoundsMappings\n \t\tdebug_str ().c_str ());\n   }\n \n+  // FIXME this will eventually go away\n   const BaseType *get_root () const;\n \n+  // This will get the monomorphized type from Params, Placeholders or\n+  // Projections if available or error\n+  const BaseType *destructure () const;\n+\n   const RustIdent &get_ident () const { return ident; }\n \n   Location get_locus () const { return ident.locus; }\n@@ -293,6 +301,10 @@ class TyVar\n \n   BaseType *get_tyty () const;\n \n+  TyVar clone () const;\n+\n+  TyVar monomorphized_clone () const;\n+\n   static TyVar get_implicit_infer_var (Location locus);\n \n   static TyVar subst_covariant_var (TyTy::BaseType *orig,\n@@ -339,6 +351,7 @@ class InferType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n \n@@ -378,6 +391,7 @@ class ErrorType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -421,6 +435,7 @@ class ParamType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_symbol () const;\n \n@@ -471,6 +486,8 @@ class StructFieldType\n \n   StructFieldType *clone () const;\n \n+  StructFieldType *monomorphized_clone () const;\n+\n   bool is_concrete () const { return ty->is_concrete (); }\n \n   void debug () const { rust_debug (\"%s\", as_string ().c_str ()); }\n@@ -524,6 +541,7 @@ class TupleType : public BaseType\n   BaseType *get_field (size_t index) const;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const override final\n   {\n@@ -1235,6 +1253,16 @@ class VariantDef\n \t\t\t   cloned_fields);\n   }\n \n+  VariantDef *monomorphized_clone () const\n+  {\n+    std::vector<StructFieldType *> cloned_fields;\n+    for (auto &f : fields)\n+      cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+\n+    return new VariantDef (id, identifier, ident, type, discriminant,\n+\t\t\t   cloned_fields);\n+  }\n+\n   const RustIdent &get_ident () const { return ident; }\n \n private:\n@@ -1358,6 +1386,7 @@ class ADTType : public BaseType, public SubstitutionRef\n   }\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool needs_generic_substitutions () const override final\n   {\n@@ -1530,6 +1559,7 @@ class FnType : public BaseType, public SubstitutionRef\n   BaseType *get_return_type () const { return type; }\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool needs_generic_substitutions () const override final\n   {\n@@ -1595,6 +1625,7 @@ class FnPtr : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   void iterate_params (std::function<bool (BaseType *)> cb) const\n   {\n@@ -1668,6 +1699,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const override final\n   {\n@@ -1735,6 +1767,7 @@ class ArrayType : public BaseType\n   BaseType *get_element_type () const;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const final override\n   {\n@@ -1784,6 +1817,7 @@ class SliceType : public BaseType\n   BaseType *get_element_type () const;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const final override\n   {\n@@ -1826,6 +1860,7 @@ class BoolType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n };\n \n@@ -1873,6 +1908,7 @@ class IntType : public BaseType\n   IntKind get_int_kind () const { return int_kind; }\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n   bool is_concrete () const override final { return true; }\n@@ -1925,6 +1961,7 @@ class UintType : public BaseType\n   UintKind get_uint_kind () const { return uint_kind; }\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n   bool is_concrete () const override final { return true; }\n@@ -1975,6 +2012,7 @@ class FloatType : public BaseType\n   FloatKind get_float_kind () const { return float_kind; }\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n   bool is_concrete () const override final { return true; }\n@@ -2013,6 +2051,7 @@ class USizeType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n };\n \n@@ -2046,6 +2085,7 @@ class ISizeType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n };\n \n@@ -2079,6 +2119,7 @@ class CharType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n };\n \n@@ -2123,6 +2164,7 @@ class ReferenceType : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const override final\n   {\n@@ -2181,6 +2223,7 @@ class PointerType : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   bool is_concrete () const override final\n   {\n@@ -2232,6 +2275,7 @@ class StrType : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n };\n \n@@ -2273,6 +2317,7 @@ class NeverType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -2314,6 +2359,7 @@ class PlaceholderType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -2389,6 +2435,7 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -2447,6 +2494,7 @@ class DynamicObjectType : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n   std::string get_name () const override final;\n "}, {"sha": "003bbcd5067052ff279cae25af105a18b9287f71", "filename": "gcc/testsuite/rust/compile/macro-issue1224.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro-issue1224.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro-issue1224.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro-issue1224.rs?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -0,0 +1,9 @@\n+macro_rules! impl_uint {\n+    ($($ty:ident),*) => {\n+        impl $ty {} // { dg-error \"metavariable is still repeating at this depth\" }\n+                    // { dg-error \"unrecognised token\" \"\" { target *-*-* } .-1 } // Spurious\n+                    // { dg-error \"could not parse type\" \"\" { target *-*-* } .-2 } // Spurious\n+    };\n+}\n+\n+impl_uint!(u8, u16, u32, u64, u128);"}, {"sha": "19d66904d154d2cd4f8289c7802711fb919362cf", "filename": "gcc/testsuite/rust/execute/torture/issue-1133.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1133.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a7654d32134d9bfbe25180dad114367e77767/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1133.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1133.rs?ref=dd5a7654d32134d9bfbe25180dad114367e77767", "patch": "@@ -0,0 +1,146 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+pub union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+pub enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub unsafe trait SliceIndex<T> {\n+    type Output;\n+\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n+\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    fn index(self, slice: &T) -> &Self::Output;\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for usize {\n+    type Output = T;\n+\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &T {\n+        // N.B., use intrinsic indexing\n+        // &(*slice)[self]\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for Range<usize> {\n+    type Output = [T];\n+\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end\n+        /* || self.end > slice.len() */\n+        {\n+            Option::None\n+        } else {\n+            unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+        }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        unsafe {\n+            let a: *const T = slice.as_ptr();\n+            let b: *const T = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &[T] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = [1, 2, 3, 4, 5];\n+    let b = &a[1..3];\n+    let c = b[1];\n+\n+    0\n+}"}]}