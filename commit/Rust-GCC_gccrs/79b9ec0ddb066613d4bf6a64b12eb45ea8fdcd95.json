{"sha": "79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzliOWVjMGRkYjA2NjYxM2Q0YmY2YTY0YjEyZWI0NWVhOGZkY2Q5NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-01-19T18:09:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-01-19T18:09:17Z"}, "message": "regclass.c (max_set_parallel): New variable.\n\n\t* regclass.c (max_set_parallel): New variable.\n\t(reg_scan): Take it into account in computation of max_parallel.\n\t(reg_scan_mark_refs, case SET): Compute it.\n\nFrom-SVN: r39140", "tree": {"sha": "e95fda7cd177d5b8d02647555d806813f68adc9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e95fda7cd177d5b8d02647555d806813f68adc9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95/comments", "author": null, "committer": null, "parents": [{"sha": "831ecbd460cd8f553e5938c7c4956840405020fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831ecbd460cd8f553e5938c7c4956840405020fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/831ecbd460cd8f553e5938c7c4956840405020fd"}], "stats": {"total": 21, "additions": 20, "deletions": 1}, "files": [{"sha": "6b5271f5195a26a79d95e006eee8531645a268b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "patch": "@@ -1,5 +1,9 @@\n Fri Jan 19 13:02:56 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* regclass.c (max_set_parallel): New variable.\n+\t(reg_scan): Take it into account in computation of max_parallel.\n+\t(reg_scan_mark_refs, case SET): Compute it.\n+\n \t* alias.c (rtx_equal_for_memref_p, case ADDRESSOF): Don't assume\n \targs are REG.\n \t* expr.c (store_constructor): Don't look at MEM_ALIAS_SET unless MEM."}, {"sha": "610de28f1b4dd4033470360c25da04b68bcdd179", "filename": "gcc/regclass.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "patch": "@@ -2188,10 +2188,17 @@ free_reg_info ()\n \n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n    Always at least 3, since the combiner could put that many together\n-   and we want this to remain correct for all the remaining passes.  */\n+   and we want this to remain correct for all the remaining passes.\n+   This corresponds to the maximum number of times note_stores will call\n+   a function for any insn.  */\n \n int max_parallel;\n \n+/* Used as a temporary to record the largest number of registers in \n+   PARALLEL in a SET_DEST.  This is added to max_parallel.  */\n+\n+static int max_set_parallel;\n+\n void\n reg_scan (f, nregs, repeat)\n      rtx f;\n@@ -2202,6 +2209,7 @@ reg_scan (f, nregs, repeat)\n \n   allocate_reg_info (nregs, TRUE, FALSE);\n   max_parallel = 3;\n+  max_set_parallel = 0;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == INSN\n@@ -2216,6 +2224,8 @@ reg_scan (f, nregs, repeat)\n \tif (REG_NOTES (insn))\n \t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, 0);\n       }\n+\n+  max_parallel += max_set_parallel;\n }\n \n /* Update 'regscan' information by looking at the insns\n@@ -2313,6 +2323,11 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t   dest = XEXP (dest, 0))\n \t;\n \n+      /* For a PARALLEL, record the number of things (less the usual one for a\n+\t SET) that are set.  */\n+      if (GET_CODE (dest) == PARALLEL)\n+\tmax_set_parallel = MAX (max_set_parallel, XVECLEN (dest, 0) - 1);\n+\n       if (GET_CODE (dest) == REG\n \t  && REGNO (dest) >= min_regno)\n \tREG_N_SETS (REGNO (dest))++;"}]}