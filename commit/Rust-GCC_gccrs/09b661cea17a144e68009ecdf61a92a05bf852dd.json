{"sha": "09b661cea17a144e68009ecdf61a92a05bf852dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDliNjYxY2VhMTdhMTQ0ZTY4MDA5ZWNkZjYxYTkyYTA1YmY4NTJkZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-12-10T20:10:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-12-10T20:10:59Z"}, "message": "Fix C++20 structural type vs. private base.\n\nIn my patch to implement C++20 \"structural type\" I tried to set the access\nflags on the artificial base fields appropriately, but failed.  I was\ncopying TREE_PRIVATE from the binfo, but TREE_PRIVATE on binfo is just a\ntemporary cache for dfs_access_in_type; we really need to get the\ninheritance access information from BINFO_BASE_ACCESSES.\n\n\t* class.c (build_base_field_1): Take access parameter.\n\t(build_base_field): Likewise.\n\t(build_base_fields, layout_virtual_bases): Pass it.\n\t* tree.c (structural_type_p): Improve private base diagnostic.\n\nFrom-SVN: r279184", "tree": {"sha": "1b9cad92725bcc9fdcbf79f2494fde214906af93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b9cad92725bcc9fdcbf79f2494fde214906af93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09b661cea17a144e68009ecdf61a92a05bf852dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b661cea17a144e68009ecdf61a92a05bf852dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b661cea17a144e68009ecdf61a92a05bf852dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b661cea17a144e68009ecdf61a92a05bf852dd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fb81d83a8857770be56df19c8a3b4e0ca87c71c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb81d83a8857770be56df19c8a3b4e0ca87c71c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb81d83a8857770be56df19c8a3b4e0ca87c71c"}], "stats": {"total": 74, "additions": 55, "deletions": 19}, "files": [{"sha": "6b15fc306e29926d97bcf9a2fe50a558f4da2811", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=09b661cea17a144e68009ecdf61a92a05bf852dd", "patch": "@@ -1,5 +1,11 @@\n 2019-12-10  Jason Merrill  <jason@redhat.com>\n \n+\tFix C++20 structural type vs. private base.\n+\t* class.c (build_base_field_1): Take access parameter.\n+\t(build_base_field): Likewise.\n+\t(build_base_fields, layout_virtual_bases): Pass it.\n+\t* tree.c (structural_type_p): Improve private base diagnostic.\n+\n \tPR c++/92560 - ICE with decltype and rewritten operator.\n \t* call.c (build_new_op_1): Clear tf_decltype on inner call.\n "}, {"sha": "a8c6b1cb01c78fb707488505a4d1dad6f9edf87b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=09b661cea17a144e68009ecdf61a92a05bf852dd", "patch": "@@ -134,7 +134,6 @@ static void build_vtbl_initializer (tree, tree, tree, tree, int *,\n static bool check_bitfield_decl (tree);\n static bool check_field_decl (tree, tree, int *, int *);\n static void check_field_decls (tree, tree *, int *, int *);\n-static tree *build_base_field (record_layout_info, tree, splay_tree, tree *);\n static void build_base_fields (record_layout_info, splay_tree, tree *);\n static void check_methods (tree);\n static void remove_zero_width_bit_fields (tree);\n@@ -4407,7 +4406,7 @@ layout_empty_base_or_field (record_layout_info rli, tree binfo_or_decl,\n    fields at NEXT_FIELD, and return it.  */\n \n static tree\n-build_base_field_1 (tree t, tree binfo, tree *&next_field)\n+build_base_field_1 (tree t, tree binfo, tree access, tree *&next_field)\n {\n   /* Create the FIELD_DECL.  */\n   tree basetype = BINFO_TYPE (binfo);\n@@ -4417,8 +4416,6 @@ build_base_field_1 (tree t, tree binfo, tree *&next_field)\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   DECL_FIELD_CONTEXT (decl) = t;\n-  TREE_PRIVATE (decl) = TREE_PRIVATE (binfo);\n-  TREE_PROTECTED (decl) = TREE_PROTECTED (binfo);\n   if (is_empty_class (basetype))\n     /* CLASSTYPE_SIZE is one byte, but the field needs to have size zero.  */\n     DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = size_zero_node;\n@@ -4432,6 +4429,11 @@ build_base_field_1 (tree t, tree binfo, tree *&next_field)\n   SET_DECL_MODE (decl, TYPE_MODE (basetype));\n   DECL_FIELD_IS_BASE (decl) = 1;\n \n+  if (access == access_private_node)\n+    TREE_PRIVATE (decl) = true;\n+  else if (access == access_protected_node)\n+    TREE_PROTECTED (decl) = true;\n+\n   /* Add the new FIELD_DECL to the list of fields for T.  */\n   DECL_CHAIN (decl) = *next_field;\n   *next_field = decl;\n@@ -4450,7 +4452,7 @@ build_base_field_1 (tree t, tree binfo, tree *&next_field)\n    Returns the location at which the next field should be inserted.  */\n \n static tree *\n-build_base_field (record_layout_info rli, tree binfo,\n+build_base_field (record_layout_info rli, tree binfo, tree access,\n \t\t  splay_tree offsets, tree *next_field)\n {\n   tree t = rli->t;\n@@ -4471,7 +4473,7 @@ build_base_field (record_layout_info rli, tree binfo,\n       CLASSTYPE_EMPTY_P (t) = 0;\n \n       /* Create the FIELD_DECL.  */\n-      decl = build_base_field_1 (t, binfo, next_field);\n+      decl = build_base_field_1 (t, binfo, access, next_field);\n \n       /* Try to place the field.  It may take more than one try if we\n \t have a hard time placing the field without putting two\n@@ -4505,7 +4507,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t aggregate bases.  */\n       if (cxx_dialect >= cxx17 && !BINFO_VIRTUAL_P (binfo))\n \t{\n-\t  tree decl = build_base_field_1 (t, binfo, next_field);\n+\t  tree decl = build_base_field_1 (t, binfo, access, next_field);\n \t  DECL_FIELD_OFFSET (decl) = BINFO_OFFSET (binfo);\n \t  DECL_FIELD_BIT_OFFSET (decl) = bitsize_zero_node;\n \t  SET_DECL_OFFSET_ALIGN (decl, BITS_PER_UNIT);\n@@ -4536,32 +4538,47 @@ build_base_fields (record_layout_info rli,\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n   tree t = rli->t;\n-  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n-  int i;\n+  tree binfo = TYPE_BINFO (t);\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (binfo);\n \n   /* The primary base class is always allocated first.  */\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    next_field = build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (t),\n-\t\t\t\t   offsets, next_field);\n+  const tree primary_binfo = CLASSTYPE_PRIMARY_BINFO (t);\n+  if (primary_binfo)\n+    {\n+      /* We need to walk BINFO_BASE_BINFO to find the access of the primary\n+\t base, if it is direct.  Indirect base fields are private.  */\n+      tree primary_access = access_private_node;\n+      for (int i = 0; i < n_baseclasses; ++i)\n+\t{\n+\t  tree base_binfo = BINFO_BASE_BINFO (binfo, i);\n+\t  if (base_binfo == primary_binfo)\n+\t    {\n+\t      primary_access = BINFO_BASE_ACCESS (binfo, i);\n+\t      break;\n+\t    }\n+\t}\n+      next_field = build_base_field (rli, primary_binfo,\n+\t\t\t\t     primary_access,\n+\t\t\t\t     offsets, next_field);\n+    }\n \n   /* Now allocate the rest of the bases.  */\n-  for (i = 0; i < n_baseclasses; ++i)\n+  for (int i = 0; i < n_baseclasses; ++i)\n     {\n-      tree base_binfo;\n-\n-      base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n+      tree base_binfo = BINFO_BASE_BINFO (binfo, i);\n \n       /* The primary base was already allocated above, so we don't\n \t need to allocate it again here.  */\n-      if (base_binfo == CLASSTYPE_PRIMARY_BINFO (t))\n-\tcontinue;\n+      if (base_binfo == primary_binfo)\n+       continue;\n \n       /* Virtual bases are added at the end (a primary virtual base\n \t will have already been added).  */\n       if (BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n \n       next_field = build_base_field (rli, base_binfo,\n+\t\t\t\t     BINFO_BASE_ACCESS (binfo, i),\n \t\t\t\t     offsets, next_field);\n     }\n }\n@@ -6141,6 +6158,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n \t  next_field = build_base_field (rli, vbase,\n+\t\t\t\t\t access_private_node,\n \t\t\t\t\t offsets, next_field);\n \t}\n     }"}, {"sha": "7b5a3e423f9fd2b429a52c9c19bfc40a594eae6a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=09b661cea17a144e68009ecdf61a92a05bf852dd", "patch": "@@ -4447,7 +4447,13 @@ structural_type_p (tree t, bool explain)\n       if (TREE_PRIVATE (m) || TREE_PROTECTED (m))\n \t{\n \t  if (explain)\n-\t    inform (location_of (m), \"%qD is not public\", m);\n+\t    {\n+\t      if (DECL_FIELD_IS_BASE (m))\n+\t\tinform (location_of (m), \"base class %qT is not public\",\n+\t\t\tTREE_TYPE (m));\n+\t      else\n+\t\tinform (location_of (m), \"%qD is not public\", m);\n+\t    }\n \t  return false;\n \t}\n       if (!structural_type_p (TREE_TYPE (m)))"}, {"sha": "67d6f0949684437a9c5dd4a8e4e7009600881436", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class25.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b661cea17a144e68009ecdf61a92a05bf852dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class25.C?ref=09b661cea17a144e68009ecdf61a92a05bf852dd", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct base { int i{}; };\n+struct derived : private base {};\n+template <derived> struct has_nttp_param{}; // { dg-error \"non-type\" }\n+has_nttp_param<{}> v;"}]}