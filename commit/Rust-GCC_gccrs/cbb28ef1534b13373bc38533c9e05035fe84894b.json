{"sha": "cbb28ef1534b13373bc38533c9e05035fe84894b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiMjhlZjE1MzRiMTMzNzNiYzM4NTMzYzllMDUwMzVmZTg0ODk0Yg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2019-10-23T20:09:27Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2019-10-23T20:09:27Z"}, "message": "Reformat some code; Add support for generating PLWA with offsets whose bottom 2 bits are non-zero.\n\n2019-10-23  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.md (mov<mode>_64bit_dm): Reformat.\n\t(movtd_64bit_nodm): Reformat.\n\t(mov<mode>_32bit): Reformat.\n\t(mov<mode>_softfloat): Reformat.\n\t(FMOVE128_GPR splitter): Reformat.\n\t(DIFD splitter): Reformat.\n\t(TI2 splitter): Reformat.\n\t* config/rs6000/predicates.md (lwa_operand): If the bottom two\n\tbits of the offset for the memory address are non-zero, use PLWA\n\tif prefixed instructions are available.\n\nFrom-SVN: r277349", "tree": {"sha": "6ec07369415c12cd4b3be645b58b4b74d1ce8f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ec07369415c12cd4b3be645b58b4b74d1ce8f78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb28ef1534b13373bc38533c9e05035fe84894b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb28ef1534b13373bc38533c9e05035fe84894b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb28ef1534b13373bc38533c9e05035fe84894b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb28ef1534b13373bc38533c9e05035fe84894b/comments", "author": null, "committer": null, "parents": [{"sha": "7c1bc95a48ba184da800007a5eb123f8ca81c509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1bc95a48ba184da800007a5eb123f8ca81c509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1bc95a48ba184da800007a5eb123f8ca81c509"}], "stats": {"total": 56, "additions": 49, "deletions": 7}, "files": [{"sha": "b3f874ba9cab5eaf19a6ebcabe087a99037831ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbb28ef1534b13373bc38533c9e05035fe84894b", "patch": "@@ -1,3 +1,16 @@\n+2019-10-23  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (mov<mode>_64bit_dm): Reformat.\n+\t(movtd_64bit_nodm): Reformat.\n+\t(mov<mode>_32bit): Reformat.\n+\t(mov<mode>_softfloat): Reformat.\n+\t(FMOVE128_GPR splitter): Reformat.\n+\t(DIFD splitter): Reformat.\n+\t(TI2 splitter): Reformat.\n+\t* config/rs6000/predicates.md (lwa_operand): If the bottom two\n+\tbits of the offset for the memory address are non-zero, use PLWA\n+\tif prefixed instructions are available.\n+\n 2019-10-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-streamer-out.c (cmp_symbol_files): Watch for overflow."}, {"sha": "5ef505bb1c4f105f94b198f089eb132d6bd04e14", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=cbb28ef1534b13373bc38533c9e05035fe84894b", "patch": "@@ -932,6 +932,14 @@\n     return false;\n \n   addr = XEXP (inner, 0);\n+\n+  /* The LWA instruction uses the DS-form instruction format which requires\n+     that the bottom two bits of the offset must be 0.  The prefixed PLWA does\n+     not have this restriction.  While the actual load from memory is 32-bits,\n+     we pass in DImode here to test for using a DS instruction.  */\n+  if (address_is_prefixed (addr, DImode, NON_PREFIXED_DS))\n+    return true;\n+\n   if (GET_CODE (addr) == PRE_INC\n       || GET_CODE (addr) == PRE_DEC\n       || (GET_CODE (addr) == PRE_MODIFY"}, {"sha": "60b8b8ce568ee94ecbb13acf0306b41a7149b848", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb28ef1534b13373bc38533c9e05035fe84894b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=cbb28ef1534b13373bc38533c9e05035fe84894b", "patch": "@@ -7761,7 +7761,10 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"isa\" \"*,*,*,*,*,*,*,*,p8v,p8v\")])\n \n@@ -7774,7 +7777,10 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n   [(set_attr \"length\" \"8,8,8,12,12,8\")])\n \n (define_insn_and_split \"*mov<mode>_32bit\"\n@@ -7789,7 +7795,10 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n   [(set_attr \"length\" \"8,8,8,8,20,20,16\")])\n \n (define_insn_and_split \"*mov<mode>_softfloat\"\n@@ -7801,7 +7810,10 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n   [(set_attr_alternative \"length\"\n        [(if_then_else (match_test \"TARGET_POWERPC64\")\n \t    (const_string \"8\")\n@@ -8593,7 +8605,10 @@\n        || (!vsx_register_operand (operands[0], <MODE>mode)\n            && !vsx_register_operand (operands[1], <MODE>mode)))\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+})\n \n ;; Move SFmode to a VSX from a GPR register.  Because scalar floating point\n ;; type is stored internally as double precision in the VSX registers, we have\n@@ -8783,7 +8798,10 @@\n    && gpr_or_gpr_p (operands[0], operands[1])\n    && !direct_move_p (operands[0], operands[1])\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+})\n \n ;;              GPR store  GPR load   GPR move   GPR li     GPR lis     GPR #\n ;;              FPR store  FPR load   FPR move   AVX store  AVX store   AVX load\n@@ -9009,7 +9027,10 @@\n    && !direct_move_p (operands[0], operands[1])\n    && !quad_load_store_p (operands[0], operands[1])\"\n   [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+})\n \f\n (define_expand \"setmemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\")"}]}