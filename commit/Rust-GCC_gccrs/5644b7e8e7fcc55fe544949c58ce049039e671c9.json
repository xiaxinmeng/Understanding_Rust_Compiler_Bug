{"sha": "5644b7e8e7fcc55fe544949c58ce049039e671c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY0NGI3ZThlN2ZjYzU1ZmU1NDQ5NDljNThjZTA0OTAzOWU2NzFjOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:29:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:29:23Z"}, "message": "[multiple changes]\n\n2013-10-14  Vincent Celier  <celier@adacore.com>\n\n\t* snames.ads-tmpl: Add new standard name Library_Rpath_Options.\n\n2013-10-14  Tristan Gingold  <gingold@adacore.com>\n\n\t* sem_prag.adb (Process_Import_Or_Interface): Allow importing\n\tof exception using convention Cpp.\n\t* exp_prag.adb (Expand_Pragma_Import_Or_Interface): Expand cpp\n\timported exceptions.\n\t* raise-gcc.c (is_handled_by): Filter C++ exception occurrences.\n\t* gnat_rm.texi: Document how to import C++ exceptions.\n\n2013-10-14  Jose Ruiz  <ruiz@adacore.com>\n\n\t* sem_ch13.adb (Sem_Ch13.Analyze_Aspect_Specification): For\n\tPriority and CPU aspects, when checking, issue a warning only\n\tif it is obviously not a main program.\n\n2013-10-14  Tristan Gingold  <gingold@adacore.com>\n\n\t* adaint.c: Fix condition for AIX. Minor reformatting.\n\nFrom-SVN: r203549", "tree": {"sha": "e84bb877232a8e1517bc69224d07162ff4e174dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e84bb877232a8e1517bc69224d07162ff4e174dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5644b7e8e7fcc55fe544949c58ce049039e671c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5644b7e8e7fcc55fe544949c58ce049039e671c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5644b7e8e7fcc55fe544949c58ce049039e671c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5644b7e8e7fcc55fe544949c58ce049039e671c9/comments", "author": null, "committer": null, "parents": [{"sha": "0895ac082ac9f48ab62051696ac3a61a5fe52939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0895ac082ac9f48ab62051696ac3a61a5fe52939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0895ac082ac9f48ab62051696ac3a61a5fe52939"}], "stats": {"total": 513, "additions": 355, "deletions": 158}, "files": [{"sha": "261885cf1a47eba5788153be3bb33ca63e917d7d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -1,3 +1,26 @@\n+2013-10-14  Vincent Celier  <celier@adacore.com>\n+\n+\t* snames.ads-tmpl: Add new standard name Library_Rpath_Options.\n+\n+2013-10-14  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sem_prag.adb (Process_Import_Or_Interface): Allow importing\n+\tof exception using convention Cpp.\n+\t* exp_prag.adb (Expand_Pragma_Import_Or_Interface): Expand cpp\n+\timported exceptions.\n+\t* raise-gcc.c (is_handled_by): Filter C++ exception occurrences.\n+\t* gnat_rm.texi: Document how to import C++ exceptions.\n+\n+2013-10-14  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* sem_ch13.adb (Sem_Ch13.Analyze_Aspect_Specification): For\n+\tPriority and CPU aspects, when checking, issue a warning only\n+\tif it is obviously not a main program.\n+\n+2013-10-14  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* adaint.c: Fix condition for AIX. Minor reformatting.\n+\n 2013-10-14  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_prag.adb, prj.ads: Minor reformatting."}, {"sha": "e5a50a866cd9b24c6f472d901784aa1b35908394", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 171, "deletions": 149, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -158,9 +158,9 @@ UINT CurrentCodePage;\n #define GCC_RESOURCE_H\n #include <sys/wait.h>\n #elif defined (__nucleus__)\n-/* No wait() or waitpid() calls available */\n+/* No wait() or waitpid() calls available.  */\n #else\n-/* Default case */\n+/* Default case.  */\n #include <sys/wait.h>\n #endif\n \n@@ -182,10 +182,12 @@ UINT CurrentCodePage;\n \n /* Use native 64-bit arithmetic.  */\n #define unix_time_to_vms(X,Y) \\\n-  { unsigned long long reftime, tmptime = (X); \\\n+  {                                                 \\\n+    unsigned long long reftime, tmptime = (X);      \\\n     $DESCRIPTOR (unixtime,\"1-JAN-1970 0:00:00.00\"); \\\n-    SYS$BINTIM (&unixtime, &reftime); \\\n-    Y = tmptime * 10000000 + reftime; }\n+    SYS$BINTIM (&unixtime, &reftime);               \\\n+    Y = tmptime * 10000000 + reftime;               \\\n+  }\n \n /* descrip.h doesn't have everything ... */\n typedef struct fibdef* __fibdef_ptr32 __attribute__ (( mode (SI) ));\n@@ -213,8 +215,8 @@ struct vstring\n \n #define SYI$_ACTIVECPU_CNT 0x111e\n extern int LIB$GETSYI (int *, unsigned int *);\n-extern unsigned int LIB$CALLG_64\n- ( unsigned long long argument_list [], int (*user_procedure)(void));\n+extern unsigned int LIB$CALLG_64 (unsigned long long argument_list [],\n+\t\t\t\t  int (*user_procedure)(void));\n \n #else\n #include <utime.h>\n@@ -266,7 +268,7 @@ extern unsigned int LIB$CALLG_64\n #define DIR_SEPARATOR '/'\n #endif\n \n-/* Check for cross-compilation */\n+/* Check for cross-compilation.  */\n #if defined (CROSS_COMPILE) || defined (CROSS_DIRECTORY_STRUCTURE)\n #define IS_CROSS 1\n int __gnat_is_cross_compiler = 1;\n@@ -382,13 +384,14 @@ to_ptr32 (char **ptr64)\n   int argc;\n   __char_ptr_char_ptr32 short_argv;\n \n-  for (argc=0; ptr64[argc]; argc++);\n+  for (argc = 0; ptr64[argc]; argc++)\n+    ;\n \n-  /* Reallocate argv with 32 bit pointers. */\n+  /* Reallocate argv with 32 bit pointers.  */\n   short_argv = (__char_ptr_char_ptr32) decc$malloc\n     (sizeof (__char_ptr32) * (argc + 1));\n \n-  for (argc=0; ptr64[argc]; argc++)\n+  for (argc = 0; ptr64[argc]; argc++)\n     short_argv[argc] = (__char_ptr32) decc$strdup (ptr64[argc]);\n \n   short_argv[argc] = (__char_ptr32) 0;\n@@ -405,8 +408,7 @@ static const char ATTR_UNSET = 127;\n /* Reset the file attributes as if no system call had been performed */\n \n void\n-__gnat_reset_attributes\n-  (struct file_attributes* attr)\n+__gnat_reset_attributes (struct file_attributes* attr)\n {\n   attr->exists     = ATTR_UNSET;\n \n@@ -423,8 +425,7 @@ __gnat_reset_attributes\n }\n \n OS_Time\n-__gnat_current_time\n-  (void)\n+__gnat_current_time (void)\n {\n   time_t res = time (NULL);\n   return (OS_Time) res;\n@@ -435,8 +436,7 @@ __gnat_current_time\n    long. */\n \n void\n-__gnat_current_time_string\n-  (char *result)\n+__gnat_current_time_string (char *result)\n {\n   const char *format = \"%Y-%m-%d %H:%M:%S\";\n   /* Format string necessary to describe the ISO 8601 format */\n@@ -455,14 +455,8 @@ __gnat_current_time_string\n }\n \n void\n-__gnat_to_gm_time\n-  (OS_Time *p_time,\n-   int *p_year,\n-   int *p_month,\n-   int *p_day,\n-   int *p_hours,\n-   int *p_mins,\n-   int *p_secs)\n+__gnat_to_gm_time (OS_Time *p_time, int *p_year, int *p_month, int *p_day,\n+\t\t   int *p_hours, int *p_mins, int *p_secs)\n {\n   struct tm *res;\n   time_t time = (time_t) *p_time;\n@@ -1877,9 +1871,8 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n int\n __gnat_file_exists_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->exists == ATTR_UNSET) {\n-      __gnat_stat_to_attr (-1, name, attr);\n-   }\n+   if (attr->exists == ATTR_UNSET)\n+     __gnat_stat_to_attr (-1, name, attr);\n \n    return attr->exists;\n }\n@@ -1934,9 +1927,8 @@ __gnat_is_absolute_path (char *name, int length)\n int\n __gnat_is_regular_file_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->regular == ATTR_UNSET) {\n-      __gnat_stat_to_attr (-1, name, attr);\n-   }\n+   if (attr->regular == ATTR_UNSET)\n+     __gnat_stat_to_attr (-1, name, attr);\n \n    return attr->regular;\n }\n@@ -1945,16 +1937,16 @@ int\n __gnat_is_regular_file (char *name)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_regular_file_attr (name, &attr);\n }\n \n int\n __gnat_is_directory_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->directory == ATTR_UNSET) {\n-      __gnat_stat_to_attr (-1, name, attr);\n-   }\n+   if (attr->directory == ATTR_UNSET)\n+     __gnat_stat_to_attr (-1, name, attr);\n \n    return attr->directory;\n }\n@@ -1963,6 +1955,7 @@ int\n __gnat_is_directory (char *name)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_directory_attr (name, &attr);\n }\n@@ -1994,7 +1987,8 @@ GetDriveTypeFromPath (TCHAR *wfullpath)\n \n       /* Is this a relative path, if so get current drive type. */\n       if (wpath[0] != _T('\\\\') ||\n-\t  (_tcslen (wpath) > 2 && wpath[0] == _T('\\\\') && wpath[1] != _T('\\\\')))\n+\t  (_tcslen (wpath) > 2 && wpath[0] == _T('\\\\')\n+\t   && wpath[1] != _T('\\\\')))\n \treturn GetDriveType (NULL);\n \n       UINT result = GetDriveType (wpath);\n@@ -2012,7 +2006,8 @@ GetDriveTypeFromPath (TCHAR *wfullpath)\n \t  LPTSTR b = _tcschr (p, _T('\\\\'));\n \n \t  if (b != NULL)\n-\t    { /* logical drive \\\\.\\c\\dir\\file */\n+\t    {\n+\t      /* logical drive \\\\.\\c\\dir\\file */\n \t      *b++ = _T(':');\n \t      *b++ = _T('\\\\');\n \t      *b = _T('\\0');\n@@ -2027,12 +2022,11 @@ GetDriveTypeFromPath (TCHAR *wfullpath)\n     }\n }\n \n-/*  This MingW section contains code to work with ACL. */\n+/*  This MingW section contains code to work with ACL.  */\n static int\n-__gnat_check_OWNER_ACL\n-(TCHAR *wname,\n- DWORD CheckAccessDesired,\n- GENERIC_MAPPING CheckGenericMapping)\n+__gnat_check_OWNER_ACL (TCHAR *wname,\n+\t\t\tDWORD CheckAccessDesired,\n+\t\t\tGENERIC_MAPPING CheckGenericMapping)\n {\n   DWORD dwAccessDesired, dwAccessAllowed;\n   PRIVILEGE_SET PrivilegeSet;\n@@ -2051,7 +2045,7 @@ __gnat_check_OWNER_ACL\n        (GetProcessHeap (), HEAP_ZERO_MEMORY, nLength)) == NULL)\n     return 0;\n \n-  /* Obtain the security descriptor. */\n+  /* Obtain the security descriptor.  */\n \n   if (!GetFileSecurity\n       (wname, OWNER_SECURITY_INFORMATION |\n@@ -2099,10 +2093,9 @@ __gnat_check_OWNER_ACL\n }\n \n static void\n-__gnat_set_OWNER_ACL\n-(TCHAR *wname,\n- DWORD AccessMode,\n- DWORD AccessPermissions)\n+__gnat_set_OWNER_ACL (TCHAR *wname,\n+\t\t      DWORD AccessMode,\n+\t\t      DWORD AccessPermissions)\n {\n   PACL pOldDACL = NULL;\n   PACL pNewDACL = NULL;\n@@ -2160,26 +2153,27 @@ __gnat_can_use_acl (TCHAR *wname)\n int\n __gnat_is_readable_file_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->readable == ATTR_UNSET) {\n+   if (attr->readable == ATTR_UNSET)\n+     {\n #if defined (_WIN32) && !defined (RTX)\n-     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-     GENERIC_MAPPING GenericMapping;\n+       TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+       GENERIC_MAPPING GenericMapping;\n \n-     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+       S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-     if (__gnat_can_use_acl (wname))\n-     {\n-        ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-        GenericMapping.GenericRead = GENERIC_READ;\n-\tattr->readable =\n-\t  __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n-     }\n-     else\n-        attr->readable = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n+       if (__gnat_can_use_acl (wname))\n+\t {\n+\t   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+\t   GenericMapping.GenericRead = GENERIC_READ;\n+\t   attr->readable =\n+\t     __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n+\t }\n+       else\n+\t attr->readable = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n #else\n-     __gnat_stat_to_attr (-1, name, attr);\n+       __gnat_stat_to_attr (-1, name, attr);\n #endif\n-   }\n+     }\n \n    return attr->readable;\n }\n@@ -2188,36 +2182,39 @@ int\n __gnat_is_readable_file (char *name)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_readable_file_attr (name, &attr);\n }\n \n int\n __gnat_is_writable_file_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->writable == ATTR_UNSET) {\n+   if (attr->writable == ATTR_UNSET)\n+     {\n #if defined (_WIN32) && !defined (RTX)\n-     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-     GENERIC_MAPPING GenericMapping;\n+       TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+       GENERIC_MAPPING GenericMapping;\n \n-     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+       S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-     if (__gnat_can_use_acl (wname))\n-       {\n-         ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-         GenericMapping.GenericWrite = GENERIC_WRITE;\n+       if (__gnat_can_use_acl (wname))\n+\t {\n+\t   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+\t   GenericMapping.GenericWrite = GENERIC_WRITE;\n \n-         attr->writable = __gnat_check_OWNER_ACL\n+\t   attr->writable = __gnat_check_OWNER_ACL\n    \t     (wname, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping)\n    \t     && !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n-       }\n-     else\n-       attr->writable = !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n+\t }\n+       else\n+\t attr->writable =\n+\t   !(GetFileAttributes (wname) & FILE_ATTRIBUTE_READONLY);\n \n #else\n-     __gnat_stat_to_attr (-1, name, attr);\n+       __gnat_stat_to_attr (-1, name, attr);\n #endif\n-   }\n+     }\n \n    return attr->writable;\n }\n@@ -2226,43 +2223,47 @@ int\n __gnat_is_writable_file (char *name)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_writable_file_attr (name, &attr);\n }\n \n int\n __gnat_is_executable_file_attr (char* name, struct file_attributes* attr)\n {\n-   if (attr->executable == ATTR_UNSET) {\n+   if (attr->executable == ATTR_UNSET)\n+     {\n #if defined (_WIN32) && !defined (RTX)\n-     TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-     GENERIC_MAPPING GenericMapping;\n+       TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+       GENERIC_MAPPING GenericMapping;\n \n-     S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+       S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-     if (__gnat_can_use_acl (wname))\n-       {\n-         ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n-         GenericMapping.GenericExecute = GENERIC_EXECUTE;\n+       if (__gnat_can_use_acl (wname))\n+\t {\n+\t   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+\t   GenericMapping.GenericExecute = GENERIC_EXECUTE;\n \n-         attr->executable =\n-           __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n-       }\n-     else\n-       {\n-\t TCHAR *l, *last = _tcsstr(wname, _T(\".exe\"));\n+\t   attr->executable =\n+\t     __gnat_check_OWNER_ACL (wname, FILE_EXECUTE, GenericMapping);\n+\t }\n+       else\n+\t {\n+\t   TCHAR *l, *last = _tcsstr(wname, _T(\".exe\"));\n \n-\t /* look for last .exe */\n-\t if (last)\n-\t   while ((l = _tcsstr(last+1, _T(\".exe\")))) last = l;\n+\t   /* look for last .exe */\n+\t   if (last)\n+\t     while ((l = _tcsstr(last+1, _T(\".exe\"))))\n+\t       last = l;\n \n-\t attr->executable = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n-\t   && (last - wname) == (int) (_tcslen (wname) - 4);\n-       }\n+\t   attr->executable =\n+\t     GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n+\t     && (last - wname) == (int) (_tcslen (wname) - 4);\n+\t }\n #else\n-     __gnat_stat_to_attr (-1, name, attr);\n+       __gnat_stat_to_attr (-1, name, attr);\n #endif\n-   }\n+     }\n \n    return attr->regular && attr->executable;\n }\n@@ -2271,6 +2272,7 @@ int\n __gnat_is_executable_file (char *name)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_executable_file_attr (name, &attr);\n }\n@@ -2399,29 +2401,30 @@ int\n __gnat_is_symbolic_link_attr (char* name ATTRIBUTE_UNUSED,\n                               struct file_attributes* attr)\n {\n-   if (attr->symbolic_link == ATTR_UNSET) {\n+   if (attr->symbolic_link == ATTR_UNSET)\n+     {\n #if defined (__vxworks) || defined (__nucleus__)\n-      attr->symbolic_link = 0;\n+       attr->symbolic_link = 0;\n \n #elif defined (_AIX) || defined (__APPLE__) || defined (__unix__)\n-      int ret;\n-      GNAT_STRUCT_STAT statbuf;\n-      ret = GNAT_LSTAT (name, &statbuf);\n-      attr->symbolic_link = (!ret && S_ISLNK (statbuf.st_mode));\n+       int ret;\n+       GNAT_STRUCT_STAT statbuf;\n+       ret = GNAT_LSTAT (name, &statbuf);\n+       attr->symbolic_link = (!ret && S_ISLNK (statbuf.st_mode));\n #else\n-      attr->symbolic_link = 0;\n+       attr->symbolic_link = 0;\n #endif\n-   }\n+     }\n    return attr->symbolic_link;\n }\n \n int\n __gnat_is_symbolic_link (char *name ATTRIBUTE_UNUSED)\n {\n    struct file_attributes attr;\n+\n    __gnat_reset_attributes (&attr);\n    return __gnat_is_symbolic_link_attr (name, &attr);\n-\n }\n \n #if defined (sun) && defined (__SVR4)\n@@ -2576,7 +2579,9 @@ __gnat_number_of_cpus (void)\n    for locking and unlocking tasks since we do not support multiple\n    threads on this configuration (Cert run time on native Windows). */\n \n-void dummy (void) {}\n+static void dummy (void)\n+{\n+}\n \n void (*Lock_Task) ()   = &dummy;\n void (*Unlock_Task) () = &dummy;\n@@ -2836,8 +2841,8 @@ __gnat_os_exit (int status)\n /* Locate file on path, that matches a predicate */\n \n char *\n-__gnat_locate_file_with_predicate\n-   (char *file_name, char *path_val, int (*predicate)(char*))\n+__gnat_locate_file_with_predicate (char *file_name, char *path_val,\n+\t\t\t\t   int (*predicate)(char *))\n {\n   char *ptr;\n   char *file_path = (char *) alloca (strlen (file_name) + 1);\n@@ -3118,15 +3123,15 @@ __gnat_to_canonical_file_list_init (char *filespec, int onlydirs)\n /* Return the next filespec in the list.  */\n \n char *\n-__gnat_to_canonical_file_list_next ()\n+__gnat_to_canonical_file_list_next (void)\n {\n   return new_canonical_filelist[new_canonical_filelist_index++];\n }\n \n /* Free storage used in the wildcard expansion.  */\n \n void\n-__gnat_to_canonical_file_list_free ()\n+__gnat_to_canonical_file_list_free (void)\n {\n   int i;\n \n@@ -3144,7 +3149,7 @@ __gnat_to_canonical_file_list_free ()\n /* The functional equivalent of decc$translate_vms routine.\n    Designed to produce the same output, but is protected against\n    malformed paths (original version ACCVIOs in this case) and\n-   does not require VMS-specific DECC RTL */\n+   does not require VMS-specific DECC RTL.  */\n \n #define NAM$C_MAXRSS 1024\n \n@@ -3161,13 +3166,13 @@ __gnat_translate_vms (char *src)\n   srcendpos = strchr (src, '\\0');\n   retpos = retbuf;\n \n-  /* Look for the node and/or device in front of the path */\n+  /* Look for the node and/or device in front of the path.  */\n   pos1 = src;\n   pos2 = strchr (pos1, ':');\n \n   if (pos2 && (pos2 < srcendpos) && (*(pos2 + 1) == ':'))\n     {\n-      /* There is a node name. \"node_name::\" becomes \"node_name!\" */\n+      /* There is a node name. \"node_name::\" becomes \"node_name!\".  */\n       disp = pos2 - pos1;\n       strncpy (retbuf, pos1, disp);\n       retpos [disp] = '!';\n@@ -3178,7 +3183,7 @@ __gnat_translate_vms (char *src)\n \n   if (pos2)\n     {\n-      /* There is a device name. \"dev_name:\" becomes \"/dev_name/\" */\n+      /* There is a device name. \"dev_name:\" becomes \"/dev_name/\".  */\n       *(retpos++) = '/';\n       disp = pos2 - pos1;\n       strncpy (retpos, pos1, disp);\n@@ -3188,30 +3193,30 @@ __gnat_translate_vms (char *src)\n     }\n   else\n     /* No explicit device; we must look ahead and prepend /sys$disk/ if\n-       the path is absolute */\n+       the path is absolute.  */\n     if ((*pos1 == '[' || *pos1 == '<') && (pos1 < srcendpos)\n         && !strchr (\".-]>\", *(pos1 + 1)))\n       {\n         strncpy (retpos, \"/sys$disk/\", 10);\n         retpos += 10;\n       }\n \n-  /* Process the path part */\n+  /* Process the path part.  */\n   while (*pos1 == '[' || *pos1 == '<')\n     {\n       path_present++;\n       pos1++;\n       if (*pos1 == ']' || *pos1 == '>')\n         {\n-          /* Special case, [] translates to '.' */\n+          /* Special case, [] translates to '.'.  */\n           *(retpos++) = '.';\n           pos1++;\n         }\n       else\n         {\n           /* '[000000' means root dir. It can be present in the middle of\n              the path due to expansion of logical devices, in which case\n-             we skip it */\n+             we skip it.  */\n           if (!strncmp (pos1, \"000000\", 6) && path_present > 1 &&\n               (*(pos1 + 6) == ']' || *(pos1 + 6) == '>' || *(pos1 + 6) == '.'))\n             {\n@@ -3220,33 +3225,36 @@ __gnat_translate_vms (char *src)\n             }\n           else if (*pos1 == '.')\n             {\n-              /* Relative path */\n+              /* Relative path.  */\n               *(retpos++) = '.';\n             }\n \n-          /* There is a qualified path */\n+          /* There is a qualified path.  */\n           while (*pos1 && *pos1 != ']' && *pos1 != '>')\n             {\n               switch (*pos1)\n                 {\n                 case '.':\n-                  /* '.' is used to separate directories. Replace it with '/' but\n-                     only if there isn't already '/' just before */\n+                  /* '.' is used to separate directories. Replace it with '/'\n+\t\t     but only if there isn't already '/' just before.  */\n                   if (*(retpos - 1) != '/')\n                     *(retpos++) = '/';\n                   pos1++;\n-                  if (pos1 + 1 < srcendpos && *pos1 == '.' && *(pos1 + 1) == '.')\n+                  if (pos1 + 1 < srcendpos\n+\t\t      && *pos1 == '.'\n+\t\t      && *(pos1 + 1) == '.')\n                     {\n-                      /* ellipsis refers to entire subtree; replace with '**' */\n+                      /* Ellipsis refers to entire subtree; replace\n+\t\t\t with '**'.  */\n                       *(retpos++) = '*';\n                       *(retpos++) = '*';\n                       *(retpos++) = '/';\n                       pos1 += 2;\n                     }\n                   break;\n                 case '-' :\n-                  /* When after '.' '[' '<' is equivalent to Unix \"..\" but there\n-                     may be several in a row */\n+                  /* When after '.' '[' '<' is equivalent to Unix \"..\" but\n+\t\t     there may be several in a row.  */\n                   if (*(pos1 - 1) == '.' || *(pos1 - 1) == '[' ||\n                       *(pos1 - 1) == '<')\n                     {\n@@ -3260,7 +3268,7 @@ __gnat_translate_vms (char *src)\n                       retpos--;\n                       break;\n                     }\n-                  /* otherwise fall through to default */\n+                  /* Otherwise fall through to default.  */\n                 default:\n                   *(retpos++) = *(pos1++);\n                 }\n@@ -3500,7 +3508,7 @@ __gnat_to_host_file_spec (char *filespec)\n }\n \n void\n-__gnat_adjust_os_resource_limits ()\n+__gnat_adjust_os_resource_limits (void)\n {\n   SYS$ADJWSL (131072, 0);\n }\n@@ -3510,8 +3518,8 @@ __gnat_adjust_os_resource_limits ()\n /* Dummy functions for Osint import for non-VMS systems.  */\n \n int\n-__gnat_to_canonical_file_list_init\n-  (char *dirspec ATTRIBUTE_UNUSED, int onlydirs ATTRIBUTE_UNUSED)\n+__gnat_to_canonical_file_list_init (char *dirspec ATTRIBUTE_UNUSED,\n+\t\t\t\t    int onlydirs ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -3567,7 +3575,7 @@ __gnat_adjust_os_resource_limits (void)\n \n #if defined (__mips_vxworks)\n int\n-_flush_cache()\n+_flush_cache (void)\n {\n    CACHE_USER_FLUSH (0, ENTIRE_CACHE);\n }\n@@ -3811,9 +3819,9 @@ __gnat_sals_init_using_constructors (void)\n    we introduce an intermediate procedure to link against the corresponding\n    one in each situation. */\n \n-extern void GetTimeAsFileTime(LPFILETIME pTime);\n+extern void GetTimeAsFileTime (LPFILETIME pTime);\n \n-void GetTimeAsFileTime(LPFILETIME pTime)\n+void GetTimeAsFileTime (LPFILETIME pTime)\n {\n #ifdef RTSS\n   RtGetRtssTimeAsFileTime (pTime); /* RTSS interface */\n@@ -3829,15 +3837,18 @@ void GetTimeAsFileTime(LPFILETIME pTime)\n \n extern void __main (void);\n \n-void __main (void) {}\n+void __main (void)\n+{\n+}\n #endif /* RTSS */\n #endif /* RTX */\n \n #if defined (__ANDROID__)\n \n #include <pthread.h>\n \n-void *__gnat_lwp_self (void)\n+void *\n+__gnat_lwp_self (void)\n {\n    return (void *) pthread_self ();\n }\n@@ -3847,7 +3858,8 @@ void *__gnat_lwp_self (void)\n    thread. We need to do a system call in order to retrieve this\n    information. */\n #include <sys/syscall.h>\n-void *__gnat_lwp_self (void)\n+void *\n+__gnat_lwp_self (void)\n {\n    return (void *) syscall (__NR_gettid);\n }\n@@ -3862,27 +3874,32 @@ void *__gnat_lwp_self (void)\n \n /* Dynamic cpu sets */\n \n-cpu_set_t *__gnat_cpu_alloc (size_t count)\n+cpu_set_t *\n+__gnat_cpu_alloc (size_t count)\n {\n   return CPU_ALLOC (count);\n }\n \n-size_t __gnat_cpu_alloc_size (size_t count)\n+size_t\n+__gnat_cpu_alloc_size (size_t count)\n {\n   return CPU_ALLOC_SIZE (count);\n }\n \n-void __gnat_cpu_free (cpu_set_t *set)\n+void\n+__gnat_cpu_free (cpu_set_t *set)\n {\n   CPU_FREE (set);\n }\n \n-void __gnat_cpu_zero (size_t count, cpu_set_t *set)\n+void\n+__gnat_cpu_zero (size_t count, cpu_set_t *set)\n {\n   CPU_ZERO_S (count, set);\n }\n \n-void __gnat_cpu_set (int cpu, size_t count, cpu_set_t *set)\n+void\n+__gnat_cpu_set (int cpu, size_t count, cpu_set_t *set)\n {\n   /* Ada handles CPU numbers starting from 1, while C identifies the first\n      CPU by a 0, so we need to adjust. */\n@@ -3893,27 +3910,32 @@ void __gnat_cpu_set (int cpu, size_t count, cpu_set_t *set)\n \n /* Static cpu sets */\n \n-cpu_set_t *__gnat_cpu_alloc (size_t count ATTRIBUTE_UNUSED)\n+cpu_set_t *\n+__gnat_cpu_alloc (size_t count ATTRIBUTE_UNUSED)\n {\n   return (cpu_set_t *) xmalloc (sizeof (cpu_set_t));\n }\n \n-size_t __gnat_cpu_alloc_size (size_t count ATTRIBUTE_UNUSED)\n+size_t\n+__gnat_cpu_alloc_size (size_t count ATTRIBUTE_UNUSED)\n {\n   return sizeof (cpu_set_t);\n }\n \n-void __gnat_cpu_free (cpu_set_t *set)\n+void\n+__gnat_cpu_free (cpu_set_t *set)\n {\n   free (set);\n }\n \n-void __gnat_cpu_zero (size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n+void\n+__gnat_cpu_zero (size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n {\n   CPU_ZERO (set);\n }\n \n-void __gnat_cpu_set (int cpu, size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n+void\n+__gnat_cpu_set (int cpu, size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n {\n   /* Ada handles CPU numbers starting from 1, while C identifies the first\n      CPU by a 0, so we need to adjust. */\n@@ -3931,7 +3953,7 @@ void __gnat_cpu_set (int cpu, size_t count ATTRIBUTE_UNUSED, cpu_set_t *set)\n #include <mach-o/dyld.h>\n #elif 0 && defined (__linux__)\n #include <link.h>\n-#elif defined (__AIX__)\n+#elif defined (_AIX)\n #include <sys/ldr.h>\n #endif\n \n@@ -3947,7 +3969,7 @@ __gnat_get_executable_load_address (void)\n \n   return (const void *)map->l_addr;\n \n-#elif defined (__AIX__)\n+#elif defined (_AIX)\n   /* Unfortunately, AIX wants to return the info for all loaded objects,\n      so we need to increase the buffer if too small.  */\n   size_t blen = 4096;"}, {"sha": "f47ed1ab927e7c9cae2378df71ffa62449144364", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -575,6 +575,64 @@ package body Exp_Prag is\n          if No (Init_Call) and then Present (Expression (Parent (Def_Id))) then\n             Set_Expression (Parent (Def_Id), Empty);\n          end if;\n+      elsif Ekind (Def_Id) = E_Exception\n+        and then Convention (Def_Id) = Convention_CPP\n+      then\n+\n+         --  Import a C++ convention\n+\n+         declare\n+            Loc            : constant Source_Ptr := Sloc (N);\n+            Exdata         : List_Id;\n+            Lang_Char      : Node_Id;\n+            Foreign_Data   : Node_Id;\n+            Rtti_Name      : constant Node_Id := Arg3 (N);\n+            Dum            : constant Entity_Id  := Make_Temporary (Loc, 'D');\n+\n+         begin\n+            Exdata := Component_Associations (Expression (Parent (Def_Id)));\n+\n+            Lang_Char := Next (First (Exdata));\n+\n+            --  Change the one-character language designator to 'C'\n+\n+            Rewrite (Expression (Lang_Char),\n+              Make_Character_Literal (Loc,\n+                Chars => Name_uC,\n+                Char_Literal_Value =>\n+                  UI_From_Int (Character'Pos ('C'))));\n+            Analyze (Expression (Lang_Char));\n+\n+            --  Change the value of Foreign_Data\n+\n+            Foreign_Data := Next (Next (Next (Next (Lang_Char))));\n+\n+            Insert_Actions (Def_Id, New_List (\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Dum,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Character, Loc)),\n+\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Import,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name_Ada)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Chars (Dum))),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars => Name_Link_Name,\n+                    Expression => Relocate_Node (Rtti_Name))))));\n+\n+            Rewrite (Expression (Foreign_Data),\n+              Unchecked_Convert_To (Standard_A_Char,\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => Make_Identifier (Loc, Chars (Dum)),\n+                  Attribute_Name => Name_Address)));\n+            Analyze (Expression (Foreign_Data));\n+         end;\n       end if;\n    end Expand_Pragma_Import_Or_Interface;\n "}, {"sha": "68a29699ad54e498bcd5d386594d9caf70387e0f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -11963,6 +11963,7 @@ where @var{nnn} is an integer.\n @emph{Exception_Name:} nnnnn\n @emph{Message:} mmmmm\n @emph{PID:} ppp\n+@emph{Load address:} 0xhhhh\n @emph{Call stack traceback locations:}\n 0xhhhh 0xhhhh 0xhhhh ... 0xhhh\n @end smallexample\n@@ -11984,10 +11985,12 @@ present only if the Process Id is nonzero). Currently we are\n not making use of this field.\n \n @item\n-The Call stack traceback locations line and the following values\n-are present only if at least one traceback location was recorded.\n-The values are given in C style format, with lower case letters\n-for a-f, and only as many digits present as are necessary.\n+The Load address line, the Call stack traceback locations line and the\n+following values are present only if at least one traceback location was\n+recorded. The Load address indicates the address at which the main executable\n+was loaded; this line may not be present if operating system hasn't relocated\n+the main executable. The values are given in C style format, with lower case\n+letters for a-f, and only as many digits present as are necessary.\n @end itemize\n \n @noindent\n@@ -18874,6 +18877,19 @@ occurrence has no message, and the simple name of the exception identity\n contains @samp{Foreign_Exception}. Finalization and awaiting dependent\n tasks works properly when such foreign exceptions are propagated.\n \n+It is also possible to import a C++ exception using the following syntax:\n+\n+@smallexample @c ada\n+LOCAL_NAME : exception;\n+pragma Import (Cpp,\n+  [Entity =>] LOCAL_NAME,\n+  [External_Name =>] static_string_EXPRESSION);\n+@end smallexample\n+\n+@noident\n+The @code{External_Name} is the name of the C++ RTTI symbol. You can then\n+cover a specific C++ exception in an exception handler.\n+\n @node Interfacing to COBOL\n @section Interfacing to COBOL\n "}, {"sha": "5d3216775167412bd231dfaeea92abf0395e213b", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -87,6 +87,36 @@ extern void __gnat_unhandled_except_handler (_Unwind_Exception *);\n #define CXX_EXCEPTION_CLASS 0x474e5543432b2b00ULL\n #define GNAT_EXCEPTION_CLASS 0x474e552d41646100ULL\n \n+/* Structure of a C++ exception, represented as a C structure...  See\n+   unwind-cxx.h for the full definition.  */\n+\n+struct __cxa_exception\n+{\n+  void *exceptionType;\n+  void (*exceptionDestructor)(void *);\n+\n+  void (*unexpectedHandler)();\n+  void (*terminateHandler)();\n+\n+  struct __cxa_exception *nextException;\n+\n+  int handlerCount;\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+  struct __cxa_exception* nextPropagatingException;\n+\n+  int propagationCount;\n+#else\n+  int handlerSwitchValue;\n+  const unsigned char *actionRecord;\n+  const unsigned char *languageSpecificData;\n+  _Unwind_Ptr catchTemp;\n+  void *adjustedPtr;\n+#endif\n+\n+  _Unwind_Exception unwindHeader;\n+};\n+\n /* --------------------------------------------------------------\n    -- The DB stuff below is there for debugging purposes only. --\n    -------------------------------------------------------------- */\n@@ -882,6 +912,22 @@ is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n       || choice == (_Unwind_Ptr) &Foreign_Exception)\n     return handler;\n \n+  /* C++ exception occurrences.  */\n+  if (propagated_exception->common.exception_class == CXX_EXCEPTION_CLASS\n+      && Language_For (choice) == 'C')\n+    {\n+      void *choice_typeinfo = Foreign_Data_For (choice);\n+      void *except_typeinfo =\n+\t(((struct __cxa_exception *)\n+\t  ((_Unwind_Exception *)propagated_exception + 1)) - 1)->exceptionType;\n+\n+      /* Typeinfo are directly compared, which might not be correct if they\n+\t aren't merged.  ??? We should call the == operator if this module is\n+\t compiled in C++.  */\n+      if (choice_typeinfo == except_typeinfo)\n+\treturn handler;\n+    }\n+\n   return nothing;\n }\n "}, {"sha": "aacb84c729e6fc457134b7e4d939512125001587", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -1834,11 +1834,14 @@ package body Sem_Ch13 is\n                         Flag_Non_Static_Expr\n                           (\"aspect requires static expression!\", Expr);\n \n-                     --  Check whether this is the main subprogram\n-\n-                     elsif Current_Sem_Unit /= Main_Unit\n-                       and then\n-                         Cunit_Entity (Current_Sem_Unit) /= Main_Unit_Entity\n+                     --  Check whether this is the main subprogram. Issue a\n+                     --  warning only if it is obviously not a main program\n+                     --  (when it has parameters or when the subprogram is\n+                     --  within a package).\n+\n+                     elsif Present (Parameter_Specifications\n+                                      (Specification (N)))\n+                       or else not Is_Compilation_Unit (Defining_Entity (N))\n                      then\n                         --  See ARM D.1 (14/3) and D.16 (12/3)\n "}, {"sha": "133ee6affb9c155fcb336540e3daa3a0ab469d42", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -7126,6 +7126,34 @@ package body Sem_Prag is\n                Check_CPP_Type_Has_No_Defaults (Def_Id);\n             end if;\n \n+         --  Import a CPP exception\n+\n+         elsif C = Convention_CPP\n+           and then Ekind (Def_Id) = E_Exception\n+         then\n+            if No (Arg3) then\n+               Error_Pragma_Arg\n+                 (\"'External_'Name arguments is required for 'Cpp exception\",\n+                  Arg3);\n+            else\n+               --  As only a string is allowed, Check_Arg_Is_External_Name\n+               --  isn't called.\n+               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+            end if;\n+\n+            if Present (Arg4) then\n+               Error_Pragma_Arg\n+                 (\"Link_Name argument not allowed for imported Cpp exception\",\n+                  Arg4);\n+            end if;\n+\n+            --  Do not call Set_Interface_Name as the name of the exception\n+            --  shouldn't be modified (and in particular it shouldn't be\n+            --  the External_Name). For exceptions, the External_Name is the\n+            --  name of the RTTI structure.\n+\n+            --  ??? Emit an error if pragma Import/Export_Exception is present\n+\n          elsif Nkind (Parent (Def_Id)) = N_Incomplete_Type_Declaration then\n             Check_No_Link_Name;\n             Check_Arg_Count (3);"}, {"sha": "74702f819e9a27efe9215849819fbce740b918e0", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5644b7e8e7fcc55fe544949c58ce049039e671c9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=5644b7e8e7fcc55fe544949c58ce049039e671c9", "patch": "@@ -1302,6 +1302,7 @@ package Snames is\n    Name_Library_Options                    : constant Name_Id := N + $;\n    Name_Library_Partial_Linker             : constant Name_Id := N + $;\n    Name_Library_Reference_Symbol_File      : constant Name_Id := N + $;\n+   Name_Library_Rpath_Options              : constant Name_Id := N + $; -- GB\n    Name_Library_Standalone                 : constant Name_Id := N + $;\n    Name_Library_Encapsulated_Options       : constant Name_Id := N + $; -- GB\n    Name_Library_Encapsulated_Supported     : constant Name_Id := N + $; -- GB"}]}