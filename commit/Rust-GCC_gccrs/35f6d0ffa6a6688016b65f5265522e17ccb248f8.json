{"sha": "35f6d0ffa6a6688016b65f5265522e17ccb248f8", "node_id": "C_kwDOANBUbNoAKDM1ZjZkMGZmYTZhNjY4ODAxNmI2NWY1MjY1NTIyZTE3Y2NiMjQ4Zjg", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-10-17T16:03:45Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-10-17T16:05:46Z"}, "message": "v0-mangling: Add base functions for mangling scheme", "tree": {"sha": "cb7ee16b76a83e7c219e2e8f2253c0f3d40c1dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb7ee16b76a83e7c219e2e8f2253c0f3d40c1dce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35f6d0ffa6a6688016b65f5265522e17ccb248f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f6d0ffa6a6688016b65f5265522e17ccb248f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35f6d0ffa6a6688016b65f5265522e17ccb248f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f6d0ffa6a6688016b65f5265522e17ccb248f8/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2484d5101c7519632dee308def201d3503ab1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2484d5101c7519632dee308def201d3503ab1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2484d5101c7519632dee308def201d3503ab1bf"}], "stats": {"total": 87, "additions": 65, "deletions": 22}, "files": [{"sha": "b1f9115140191d362504d7c868f093f5ec31dd9b", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 65, "deletions": 22, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35f6d0ffa6a6688016b65f5265522e17ccb248f8/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35f6d0ffa6a6688016b65f5265522e17ccb248f8/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=35f6d0ffa6a6688016b65f5265522e17ccb248f8", "patch": "@@ -157,41 +157,82 @@ v0_simple_type_prefix (const TyTy::BaseType *ty)\n \n // FIXME: Is this present somewhere in libbiberty already?\n static std::string\n-v0_base62_integer(uint64_t x)\n+v0_base62_integer (uint64_t x)\n {\n   const static std::string base_64\n     = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n-  std::string buffer(128, '\\0');\n+  std::string buffer (128, '\\0');\n   size_t idx = 0;\n   size_t base = 62;\n \n   do\n     {\n       buffer[idx] = base_64[(x % base)];\n       idx++;\n-      x /= base;\n-  } while (x != 0);\n+      x = x / base;\n+    }\n+  while (x != 0);\n \n-  std::reverse(buffer.begin(), buffer.begin() + idx);\n-  return buffer.substr(0, idx);\n+  std::reverse (buffer.begin (), buffer.begin () + idx);\n+  return buffer.substr (0, idx);\n }\n \n-static std::string\n-v0_add_integer_62 (std::string mangled, std::string tag, uint64_t x)\n+// Add an underscore-terminated base62 integer to the mangling string.\n+// This corresponds to the `<base-62-number>` grammar in the v0 mangling RFC:\n+//  - 0 is encoded as \"_\"\n+//  - any other value is encoded as itself minus one in base 62, followed by \"_\"\n+static void\n+v0_add_integer_62 (std::string &mangled, uint64_t x)\n {\n-    // /// Push a `_`-terminated base 62 integer, using the format\n-    // /// specified in the RFC as `<base-62-number>`, that is:\n-    // /// * `x = 0` is encoded as just the `\"_\"` terminator\n-    // /// * `x > 0` is encoded as `x - 1` in base 62, followed by `\"_\"`,\n-    // ///   e.g. `1` becomes `\"0_\"`, `62` becomes `\"Z_\"`, etc.\n-    // fn push_integer_62(&mut self, x: u64) {\n-    //     if let Some(x) = x.checked_sub(1) {\n-    //         base_n::push_str(x as u128, 62, &mut self.out);\n-    //     }\n-    //     self.push(\"_\");\n-    // }\n+  if (x > 0)\n+    mangled.append (v0_base62_integer (x - 1));\n+\n+  mangled.append (\"_\");\n }\n \n+// Add a tag-prefixed base62 integer to the mangling string when the\n+// integer is greater than 0:\n+//  - 0 is encoded as \"\" (nothing)\n+//  - any other value is encoded as <tag> + v0_add_integer_62(itself), that is\n+//  <tag> + base62(itself - 1) + '_'\n+static void\n+v0_add_opt_integer_62 (std::string &mangled, std::string tag, uint64_t x)\n+{\n+  if (x > 0)\n+    {\n+      mangled.append (tag);\n+      v0_add_integer_62 (mangled, x);\n+    }\n+}\n+\n+static void\n+v0_add_disambiguator (std::string &mangled, uint64_t dis)\n+{\n+  v0_add_opt_integer_62 (mangled, \"s\", dis);\n+}\n+\n+// Add an identifier to the mangled string. This corresponds to the\n+// `<identifier>` grammar in the v0 mangling RFC.\n+static void\n+v0_add_identifier (std::string &mangled, const std::string &identifier)\n+{\n+  // FIXME: gccrs cannot handle unicode identifiers yet, so we never have to\n+  // create mangling for unicode values for now. However, this is handled\n+  // by the v0 mangling scheme. The grammar for unicode identifier is contained\n+  // in <undisambiguated-identifier>, right under the <identifier> one. If the\n+  // identifier contains unicode values, then an extra \"u\" needs to be added\n+  // to the mangling string and `punycode` must be used to encode the\n+  // characters.\n+\n+  mangled += std::to_string (identifier.size ());\n+\n+  // If the first character of the identifier is a digit or an underscore, we\n+  // add an extra underscore\n+  if (identifier[0] == '_')\n+    mangled.append (\"_\");\n+\n+  mangled.append (identifier);\n+}\n \n static std::string\n v0_type_prefix (const TyTy::BaseType *ty)\n@@ -233,10 +274,12 @@ static std::string\n v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n \t\tconst std::string &crate_name)\n {\n-  auto def_id = ty->get_ref();\n-  auto ty_prefix = v0_type_prefix (ty);\n-  auto prefix = \"_R\";\n+  std::string mangled;\n \n+  // FIXME: Add real algorithm once all pieces are implemented\n+  auto ty_prefix = v0_type_prefix (ty);\n+  v0_add_identifier (mangled, crate_name);\n+  v0_add_disambiguator (mangled, 62);\n \n   gcc_unreachable ();\n }"}]}