{"sha": "180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwYTM3M2QwZDVkNDUzNGQ3MzkzYjFhZDU1MzdkOWY5YWI3ZTc5ZQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2004-10-14T15:21:13Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-10-14T15:21:13Z"}, "message": "interpret.cc (_Jv_InterpMethod::run): Initialize _Jv_StartOfInterpreter.\n\n2004-10-13  Andrew Haley  <aph@redhat.com>\n\n        * interpret.cc (_Jv_InterpMethod::run): Initialize\n        _Jv_StartOfInterpreter.\n        (_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): Functions removed.\n        (_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): New variables.\n        * gnu/gcj/runtime/natStackTrace.cc (fillInStackTrace): Use\n        _Unwind_FindEnclosingFunction to discover whether PC is within the\n        interpreter.\n\nFrom-SVN: r89037", "tree": {"sha": "f9e1b10a90a60b5918f10b2519f9520b57f64915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9e1b10a90a60b5918f10b2519f9520b57f64915"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b79187bb541c3d842f2a3aee554b4b3f2e63f804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b79187bb541c3d842f2a3aee554b4b3f2e63f804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b79187bb541c3d842f2a3aee554b4b3f2e63f804"}], "stats": {"total": 84, "additions": 62, "deletions": 22}, "files": [{"sha": "980490d1b06710f963d5d875d5aa5d16eae5edb6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "patch": "@@ -1,3 +1,13 @@\n+2004-10-13  Andrew Haley  <aph@redhat.com>\n+\n+\t* interpret.cc (_Jv_InterpMethod::run): Initialize\n+\t_Jv_StartOfInterpreter.\n+\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): Functions removed.\n+\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): New variables.\n+\t* gnu/gcj/runtime/natStackTrace.cc (fillInStackTrace): Use\n+\t_Unwind_FindEnclosingFunction to discover whether PC is within the\n+\tinterpreter.\n+\n 2004-10-12  Rutger Ovidius  <ovidr@users.sourceforge.net>\n \n \tPR libgcj/17903:"}, {"sha": "fbe403a17efea64378cdb170f8bb7fafb286097e", "filename": "libjava/gnu/gcj/runtime/natStackTrace.cc", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc?ref=180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "patch": "@@ -45,6 +45,11 @@ details.  */\n #include <unwind.h>\n \n \n+#ifdef INTERPRETER\n+extern \"C\" void *_Unwind_FindEnclosingFunction (void *pc)\n+  __attribute__((pure));\n+#endif // INTERPRETER\n+\n // Fill in this stack trace with MAXLEN elements starting at offset.\n void\n gnu::gcj::runtime::StackTrace::fillInStackTrace (jint maxlen, jint offset)\n@@ -58,9 +63,9 @@ gnu::gcj::runtime::StackTrace::fillInStackTrace (jint maxlen, jint offset)\n   if (len > 0)\n     {\n #ifdef INTERPRETER\n-      extern void _Jv_StartOfInterpreter (void);\n-      extern void _Jv_EndOfInterpreter (void);\n-\n+      extern void *const _Jv_StartOfInterpreter;\n+      extern void * _Jv_EndOfInterpreter;\n+      \n       java::lang::Thread *thread = java::lang::Thread::currentThread();\n       _Jv_MethodChain *interp_frame\n \t= (thread ? reinterpret_cast<_Jv_MethodChain *> (thread->interp_frame)\n@@ -70,16 +75,41 @@ gnu::gcj::runtime::StackTrace::fillInStackTrace (jint maxlen, jint offset)\n       frame = (_Jv_frame_info *) _Jv_Malloc (len * sizeof (_Jv_frame_info));\n       for (int n = 0; n < len; n++)\n \t{\n-\t  frame[n].addr = p[n];\n+\t  void *pc = p[n];\n+\t  frame[n].addr = pc;\n+\n #ifdef INTERPRETER\n-\t  if (p[n] >= &_Jv_StartOfInterpreter && p[n] <= &_Jv_EndOfInterpreter)\n+\t  frame[n].interp = 0;\n+\n+\t  // If _Jv_StartOfInterpreter is NULL either we've never\n+\t  // entered the intepreter or _Unwind_FindEnclosingFunction\n+\t  // is broken.\n+\t  if (__builtin_expect (_Jv_StartOfInterpreter != NULL, false))\n \t    {\n-\t      frame[n].interp = (void *) interp_frame->self;\n-\t      interp_frame = interp_frame->next;\n+\t      // _Jv_StartOfInterpreter marks the very first\n+\t      // instruction in the interpreter, but\n+\t      // _Jv_EndOfInterpreter is an upper bound.  If PC is\n+\t      // less than _Jv_EndOfInterpreter it might be in the\n+\t      // interpreter: we call _Unwind_FindEnclosingFunction to\n+\t      // find out.\n+\t      if ((_Jv_EndOfInterpreter == NULL || pc < _Jv_EndOfInterpreter)\n+\t\t  && (_Unwind_FindEnclosingFunction (pc) \n+\t\t      == _Jv_StartOfInterpreter))\n+\t\t{\n+\t\t  frame[n].interp = (void *) interp_frame->self;\n+\t\t  interp_frame = interp_frame->next;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // We've found an address that we know is not within\n+\t\t  // the interpreter.  We use that to refine our upper\n+\t\t  // bound on where the interpreter ends.\n+\t\t  if (_Jv_EndOfInterpreter == NULL || pc < _Jv_EndOfInterpreter)\n+\t\t    _Jv_EndOfInterpreter = pc;\n+\t\t}\n \t    }\n-\t  else\n-\t    frame[n].interp = 0;\n #endif // INTERPRETER\n+\n \t}\n     }\n   else"}, {"sha": "0446c729623713ee3f459e7eb92f59227af31934", "filename": "libjava/interpret.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180a373d0d5d4534d7393b1ad5537d9f9ab7e79e/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=180a373d0d5d4534d7393b1ad5537d9f9ab7e79e", "patch": "@@ -774,18 +774,25 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n }\n #endif /* DIRECT_THREADED */\n \n-// This function exists so that the stack-tracing code can find the\n-// boundaries of the interpreter.\n-void\n-_Jv_StartOfInterpreter (void)\n-{\n-}\n+// These exist so that the stack-tracing code can find the boundaries\n+// of the interpreter.\n+void *_Jv_StartOfInterpreter;\n+void *_Jv_EndOfInterpreter;\n+extern \"C\" void *_Unwind_FindEnclosingFunction (void *pc);\n \n void\n _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n {\n   using namespace java::lang::reflect;\n \n+  // Record the address of the start of this member function in\n+  // _Jv_StartOfInterpreter.  Such a write to a global variable\n+  // without acquiring a lock is correct iff reads and writes of words\n+  // in memory are atomic, but Java requires that anyway.\n+ foo:\n+  if (_Jv_StartOfInterpreter == NULL)\n+    _Jv_StartOfInterpreter = _Unwind_FindEnclosingFunction (&&foo);\n+\n   // FRAME_DESC registers this particular invocation as the top-most\n   // interpreter frame.  This lets the stack tracing code (for\n   // Throwable) print information about the method being interpreted\n@@ -3219,13 +3226,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     }\n }\n \n-// This function exists so that the stack-tracing code can find the\n-// boundaries of the interpreter.\n-void\n-_Jv_EndOfInterpreter (void)\n-{\n-}\n-\n static void\n throw_internal_error (char *msg)\n {"}]}