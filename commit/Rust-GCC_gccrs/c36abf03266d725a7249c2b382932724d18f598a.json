{"sha": "c36abf03266d725a7249c2b382932724d18f598a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM2YWJmMDMyNjZkNzI1YTcyNDljMmIzODI5MzI3MjRkMThmNTk4YQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-11-03T00:47:48Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-11-03T00:47:48Z"}, "message": "future: Use base class with nested types.\n\n2009-11-02  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/std/future: Use base class with nested types.\n\t(__future_base): New.\n\t(__future_base::_Result_base): From _Future_result_base.\n\t(__future_base::_Result): From _Future_result.\n\t(__future_base::_Move_result): From _Move_future_result.\n\t(__future_base::_Ptr): From _Future_ptr.\n\t(__future_base::_State): From _Future_state.\n\t(__basic_future): From _Future_impl.\n\t* testsuite/30_threads/packaged_task/cons/assign_neg.cc: Adjust line\n\tnumbers.\n\t* testsuite/30_threads/packaged_task/cons/copy_neg.cc: Same.\n\t* testsuite/30_threads/shared_future/cons/assign_neg.cc: Same.\n\t* testsuite/30_threads/unique_future/cons/assign_neg.cc: Same.\n\t* testsuite/30_threads/unique_future/cons/copy_neg.cc: Same.\n\t* testsuite/30_threads/promise/cons/assign_neg.cc: Same.\n\t* testsuite/30_threads/promise/cons/copy_neg.cc: Same.\n\nFrom-SVN: r153834", "tree": {"sha": "c654e0ab06b931548a732abc1309e98b6cc75d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c654e0ab06b931548a732abc1309e98b6cc75d0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c36abf03266d725a7249c2b382932724d18f598a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36abf03266d725a7249c2b382932724d18f598a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36abf03266d725a7249c2b382932724d18f598a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36abf03266d725a7249c2b382932724d18f598a/comments", "author": null, "committer": null, "parents": [{"sha": "c393f5594131f1ed250ab61e776b6e8d60d8a5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c393f5594131f1ed250ab61e776b6e8d60d8a5bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c393f5594131f1ed250ab61e776b6e8d60d8a5bb"}], "stats": {"total": 735, "additions": 399, "deletions": 336}, "files": [{"sha": "589671b470b5a0938d488b83fa99ee5bd4e21261", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -1,3 +1,22 @@\n+2009-11-02  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/std/future: Use base class with nested types.\n+\t(__future_base): New.\n+\t(__future_base::_Result_base): From _Future_result_base.\n+\t(__future_base::_Result): From _Future_result.\n+\t(__future_base::_Move_result): From _Move_future_result.\n+\t(__future_base::_Ptr): From _Future_ptr.\n+\t(__future_base::_State): From _Future_state.\n+\t(__basic_future): From _Future_impl.\n+\t* testsuite/30_threads/packaged_task/cons/assign_neg.cc: Adjust line\n+\tnumbers.\n+\t* testsuite/30_threads/packaged_task/cons/copy_neg.cc: Same.\n+\t* testsuite/30_threads/shared_future/cons/assign_neg.cc: Same.\n+\t* testsuite/30_threads/unique_future/cons/assign_neg.cc: Same.\n+\t* testsuite/30_threads/unique_future/cons/copy_neg.cc: Same.\n+\t* testsuite/30_threads/promise/cons/assign_neg.cc: Same.\n+\t* testsuite/30_threads/promise/cons/copy_neg.cc: Same.\n+\n 2009-10-31  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/std/chrono (struct __common_rep_type): New.\n@@ -9,7 +28,7 @@\n \toperator/(const duration<>&, const _Rep2&),\n \ttime_point_cast(const time_point<>&)): Implement resolution of\n \tDR 1177 ([Ready] in Santa Cruz), change to not participate to\n-\toverload resolution if the constraints are not met. \n+\toverload resolution if the constraints are not met.\n \t* testsuite/20_util/duration/cons/1_neg.cc: Adjust dg-errors.\n \t* testsuite/20_util/duration/cons/dr974.cc: Likewise.\n \t* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust"}, {"sha": "b8c54b6075f782395d8da5b1746415e24de3e5ea", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 372, "deletions": 328, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -79,7 +79,7 @@ namespace std\n    */\n   class future_error : public logic_error\n   {\n-    error_code _M_code;\n+    error_code \t\t\t_M_code;\n \n   public:\n     explicit future_error(future_errc __ec)\n@@ -96,252 +96,286 @@ namespace std\n   };\n \n   // Forward declarations.\n-  template<typename _Result>\n+  template<typename _Res>\n     class unique_future;\n \n-  template<typename _Result>\n+  template<typename _Res>\n     class shared_future;\n \n   template<typename> \n     class packaged_task;\n \n-  template<typename _Result>\n+  template<typename _Res>\n     class promise;\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1) \\\n   && defined(_GLIBCXX_ATOMIC_BUILTINS_4)\n \n-  // Holds the result of a future\n-  struct _Future_result_base\n+  /// Base class and enclosing scope.\n+  struct __future_base\n   {\n-    _Future_result_base() = default;\n-    _Future_result_base(const _Future_result_base&) = delete;\n-    _Future_result_base& operator=(const _Future_result_base&) = delete;\n+    /// Base class for results.\n+    struct _Result_base\n+    {\n+      exception_ptr\t\t_M_error;\n \n-    exception_ptr _M_error;\n+      _Result_base() = default;\n+      _Result_base(const _Result_base&) = delete;\n+      _Result_base& operator=(const _Result_base&) = delete;\n \n-    // _M_destroy() allows derived classes to control deallocation,\n-    // which will be needed when allocator support is added to promise.\n-    // See http://gcc.gnu.org/ml/libstdc++/2009-06/msg00032.html\n-    virtual void _M_destroy() = 0;\n-    struct _Deleter\n-    {\n-      void operator()(_Future_result_base* __fr) const { __fr->_M_destroy(); }\n-    };\n+      // _M_destroy() allows derived classes to control deallocation,\n+      // which will be needed when allocator support is added to promise.\n+      // See http://gcc.gnu.org/ml/libstdc++/2009-06/msg00032.html\n+      virtual void _M_destroy() = 0;\n \n-  protected:\n-    ~_Future_result_base();\n-  };\n+      struct _Deleter\n+      {\n+\tvoid operator()(_Result_base* __fr) const { __fr->_M_destroy(); }\n+      };\n \n-  inline _Future_result_base::~_Future_result_base() = default;\n+    protected:\n+      ~_Result_base();\n+    };\n \n-  // TODO: use template alias when available\n-  /*\n-   template<typename _Res>\n-     using _Future_ptr = unique_ptr<_Res, _Future_result_base::_Deleter>;\n-   */\n-  template<typename _Res>\n-    struct _Future_ptr\n-    {\n-      typedef unique_ptr<_Res, _Future_result_base::_Deleter> type;\n+    /// Result.\n+    template<typename _Res>\n+      struct _Result : _Result_base\n+      {\n+      private:\n+\ttypedef alignment_of<_Res>\t\t\t\t__a_of;\n+\ttypedef aligned_storage<sizeof(_Res), __a_of::value>\t__align_storage;\n+\ttypedef typename __align_storage::type\t\t\t__align_type;\n+\n+\t__align_type\t\t_M_storage;\n+\tbool \t\t\t_M_initialized;\n+\n+      public:\n+\t_Result() : _M_initialized() { }\n+\t\n+\t~_Result()\n+\t{\n+\t  if (_M_initialized)\n+\t    _M_value().~_Res();\n+\t}\n+\n+\t// Return lvalue, future will add const or rvalue-reference\n+\t_Res& \n+\t_M_value() { return *static_cast<_Res*>(_M_addr()); }\n+\n+\tvoid\n+\t_M_set(const _Res& __res)\n+\t{\n+\t  ::new (_M_addr()) _Res(__res);\n+\t  _M_initialized = true;\n+\t}\n+\n+\tvoid\n+\t_M_set(_Res&& __res)\n+\t{\n+\t  ::new (_M_addr()) _Res(_Move_result<_Res>::_S_move(__res));\n+\t  _M_initialized = true;\n+\t}\n+\n+      private:\n+\tvoid _M_destroy() { delete this; }\n+\n+\tvoid* _M_addr() { return static_cast<void*>(&_M_storage); }\n     };\n \n-  // State shared between a promise and one or more associated futures.\n-  class _Future_state\n-  {\n-    typedef _Future_ptr<_Future_result_base>::type _Future_ptr_type;\n \n-  public:\n-    _Future_state() : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT) { }\n+    /// Workaround for CWG issue 664 and c++/34022\n+    template<typename _Res, bool = is_scalar<_Res>::value>\n+      struct _Move_result;\n \n-    _Future_state(const _Future_state&) = delete;\n-    _Future_state& operator=(const _Future_state&) = delete;\n+     /// Specialization for scalar types returns rvalue not rvalue-reference.\n+    template<typename _Res>\n+      struct _Move_result<_Res, true>\n+      {\n+\ttypedef _Res __rval_type;\n+\tstatic _Res _S_move(_Res __res) { return __res; }\n+      };\n+    \n+    /// Specialization for non-scalar types returns rvalue-reference.\n+    template<typename _Res>\n+      struct _Move_result<_Res, false>\n+      {\n+\ttypedef _Res&& __rval_type;\n+\tstatic _Res&& _S_move(_Res& __res) { return std::move(__res); }\n+      };\n+\n+\n+    // TODO: use template alias when available\n+    /*\n+      template<typename _Res>\n+      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;\n+    */\n+    /// A unique_ptr based on the instantiating type.\n+    template<typename _Res>\n+      struct _Ptr\n+      {\n+\ttypedef unique_ptr<_Res, _Result_base::_Deleter> type;\n+      };\n \n-    bool\n-    is_ready()\n-    { return _M_get() != 0; }\n \n-    bool\n-    has_exception()\n+    /// Shared state between a promise and one or more associated futures.\n+    class _State\n     {\n-      _Future_result_base* const __res = _M_get();\n-      return __res && !(__res->_M_error == 0);\n-    }\n+      typedef _Ptr<_Result_base>::type _Ptr_type;\n \n-    bool\n-    has_value()\n-    {\n-      _Future_result_base* const __res = _M_get();\n-      return __res && (__res->_M_error == 0);\n-    }\n+      _Ptr_type\t\t\t_M_result;\n+      mutex               \t_M_mutex;\n+      condition_variable  \t_M_cond;\n+      atomic_flag         \t_M_retrieved;\n \n-    _Future_result_base&\n-    wait()\n-    {\n-      unique_lock<mutex> __lock(_M_mutex);\n-      if (!_M_ready())\n-        _M_cond.wait(__lock, std::bind(&_Future_state::_M_ready, this));\n-      return *_M_result;\n-    }\n+    public:\n+      _State() : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT) { }\n+\n+      _State(const _State&) = delete;\n+      _State& operator=(const _State&) = delete;\n \n-    template<typename _Rep, typename _Period>\n       bool\n-      wait_for(const chrono::duration<_Rep, _Period>& __rel)\n-      {\n-        unique_lock<mutex> __lock(_M_mutex);\n-        return _M_ready() || _M_cond.wait_for(__lock, __rel,\n-            std::bind(&_Future_state::_M_ready, this));\n-      }\n+      is_ready()\n+      { return _M_get() != 0; }\n \n-    template<typename _Clock, typename _Duration>\n       bool\n-      wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n+      has_exception()\n       {\n-        unique_lock<mutex> __lock(_M_mutex);\n-        return _M_ready() || _M_cond.wait_until(__lock, __abs,\n-            std::bind(&_Future_state::_M_ready, this));\n+\t_Result_base* const __res = _M_get();\n+\treturn __res && !(__res->_M_error == 0);\n       }\n \n-    void\n-    _M_set_result(_Future_ptr_type __res)\n-    {\n+      bool\n+      has_value()\n       {\n-        lock_guard<mutex> __lock(_M_mutex);\n-        if (_M_ready())\n-\t  __throw_future_error(int(future_errc::promise_already_satisfied));\n-        _M_result.swap(__res);\n+\t_Result_base* const __res = _M_get();\n+\treturn __res && (__res->_M_error == 0);\n       }\n-      _M_cond.notify_all();\n-    }\n \n-    void\n-    _M_break_promise(_Future_ptr_type __res)\n-    {\n-      if (static_cast<bool>(__res))\n+      _Result_base&\n+      wait()\n       {\n-        __res->_M_error\n-          = std::copy_exception(future_error(future_errc::broken_promise));\n-        {\n-          lock_guard<mutex> __lock(_M_mutex);\n-          _M_result.swap(__res);\n-        }\n-        _M_cond.notify_all();\n+\tunique_lock<mutex> __lock(_M_mutex);\n+\tif (!_M_ready())\n+\t  _M_cond.wait(__lock, std::bind(&_State::_M_ready, this));\n+\treturn *_M_result;\n       }\n-    }\n-\n-    // called when this object is passed to a unique_future\n-    void\n-    _M_set_retrieved_flag()\n-    {\n-      if (_M_retrieved.test_and_set())\n-        __throw_future_error(int(future_errc::future_already_retrieved));\n-    }\n-\n-  private:\n-    _Future_result_base*\n-    _M_get()\n-    {\n-      lock_guard<mutex> __lock(_M_mutex);\n-      return _M_result.get();\n-    }\n \n-    bool _M_ready() const { return static_cast<bool>(_M_result); }\n-\n-    _Future_ptr_type    _M_result;\n-    mutex               _M_mutex;\n-    condition_variable  _M_cond;\n-    atomic_flag         _M_retrieved;\n-  };\n-\n-  // workaround for CWG issue 664 and c++/34022\n-  template<typename _Result, bool = is_scalar<_Result>::value>\n-    struct _Move_future_result\n-    {\n-      typedef _Result&& __rval_type;\n-      static _Result&& _S_move(_Result& __res) { return std::move(__res); }\n-    };\n-\n-  // specialization for scalar types returns rvalue not rvalue-reference\n-  template<typename _Result>\n-    struct _Move_future_result<_Result, true>\n-    {\n-      typedef _Result __rval_type;\n-      static _Result _S_move(_Result __res) { return __res; }\n-    };\n+      template<typename _Rep, typename _Period>\n+        bool\n+        wait_for(const chrono::duration<_Rep, _Period>& __rel)\n+        {\n+\t  unique_lock<mutex> __lock(_M_mutex);\n+\t  auto __bound = std::bind(&_State::_M_ready, this);\n+\t  return _M_ready() || _M_cond.wait_for(__lock, __rel, __bound);\n+\t}\n \n-  template<typename _Result>\n-    struct _Future_result : _Future_result_base\n-    {\n-      _Future_result() : _M_initialized() { }\n+      template<typename _Clock, typename _Duration>\n+        bool\n+        wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n+        {\n+\t  unique_lock<mutex> __lock(_M_mutex);\n+\t  auto __bound = std::bind(&_State::_M_ready, this);\n+\t  return _M_ready() || _M_cond.wait_until(__lock, __abs, __bound);\n+\t}\n \n-      ~_Future_result()\n+      void\n+      _M_set_result(_Ptr_type __res)\n       {\n-        if (_M_initialized)\n-          _M_value().~_Result();\n+\t{\n+\t  lock_guard<mutex> __lock(_M_mutex);\n+\t  if (_M_ready())\n+\t    __throw_future_error(int(future_errc::promise_already_satisfied));\n+\t  _M_result.swap(__res);\n+\t}\n+\t_M_cond.notify_all();\n       }\n \n-      // return lvalue, future will add const or rvalue-reference\n-      _Result& _M_value()\n-      { return *static_cast<_Result*>(_M_addr()); }\n-\n       void\n-      _M_set(const _Result& __res)\n+      _M_break_promise(_Ptr_type __res)\n       {\n-        ::new (_M_addr()) _Result(__res);\n-        _M_initialized = true;\n+\tif (static_cast<bool>(__res))\n+\t  {\n+\t    future_errc __ec(future_errc::broken_promise); // XXX\n+\t    __res->_M_error = copy_exception(future_error(__ec));\n+\t    {\n+\t      lock_guard<mutex> __lock(_M_mutex);\n+\t      _M_result.swap(__res);\n+\t    }\n+\t    _M_cond.notify_all();\n+\t  }\n       }\n \n+      // Called when this object is passed to a unique_future.\n       void\n-      _M_set(_Result&& __res)\n+      _M_set_retrieved_flag()\n       {\n-        typedef _Move_future_result<_Result> _Mover;\n-        ::new (_M_addr()) _Result(_Mover::_S_move(__res));\n-        _M_initialized = true;\n+\tif (_M_retrieved.test_and_set())\n+\t  __throw_future_error(int(future_errc::future_already_retrieved));\n       }\n \n     private:\n-      void _M_destroy() { delete this; }\n-\n-      void* _M_addr() { return static_cast<void*>(&_M_storage); }\n+      _Result_base*\n+      _M_get()\n+      {\n+\tlock_guard<mutex> __lock(_M_mutex);\n+\treturn _M_result.get();\n+      }\n \n-      typename aligned_storage<sizeof(_Result),\n-               alignment_of<_Result>::value>::type _M_storage;\n-      bool _M_initialized;\n+      bool _M_ready() const { return static_cast<bool>(_M_result); }\n     };\n+  };\n \n-  template<typename _Result>\n-    struct _Future_result<_Result&> : _Future_result_base\n-    {\n-      _Future_result() : _M_value_ptr() { }\n+  inline __future_base::_Result_base::~_Result_base() = default;\n \n-      _Result* _M_value_ptr;\n+  /// Partial specialization for reference types.\n+  template<typename _Res>\n+    struct __future_base::_Result<_Res&> : __future_base::_Result_base\n+    {\n+      _Result() : _M_value_ptr() { }\n \n+      _Res* \t\t\t_M_value_ptr;\n+      \n+    private:\n       void _M_destroy() { delete this; }\n     };\n \n+  /// Explicit specialization for void.\n   template<>\n-    struct _Future_result<void> : _Future_result_base\n+    struct __future_base::_Result<void> : __future_base::_Result_base\n     {\n+    private:\n       void _M_destroy() { delete this; }\n     };\n \n-  // common implementation for unique_future and shared_future\n-  template<typename _Result>\n-    class _Future_impl\n+\n+  /// Common implementation for unique_future and shared_future.\n+  template<typename _Res>\n+    class __basic_future : public __future_base\n     {\n+    protected:\n+      typedef shared_ptr<_State>\t\t__state_type;\n+      typedef __future_base::_Result<_Res>&\t__result_type;\n+\n+    private:\n+      __state_type \t\t_M_state;\n+\n     public:\n-      // disable copying\n-      _Future_impl(const _Future_impl&) = delete;\n-      _Future_impl& operator=(const _Future_impl&) = delete;\n+      // Disable copying.\n+      __basic_future(const __basic_future&) = delete;\n+      __basic_future& operator=(const __basic_future&) = delete;\n \n-      // functions to check state and wait for ready\n-      bool is_ready() const { return this->_M_state->is_ready(); }\n+      // Functions to check state and wait for ready.\n+      bool \n+      is_ready() const { return this->_M_state->is_ready(); }\n \n-      bool has_exception() const { return this->_M_state->has_exception(); }\n+      bool \n+      has_exception() const { return this->_M_state->has_exception(); }\n \n-      bool has_value() const { return this->_M_state->has_value(); }\n+      bool \n+      has_value() const { return this->_M_state->has_value(); }\n \n-      void wait() const { this->_M_state->wait(); }\n+      void \n+      wait() const { this->_M_state->wait(); }\n \n       template<typename _Rep, typename _Period>\n         bool\n@@ -354,169 +388,169 @@ namespace std\n         { return this->_M_state->wait_until(__abs); }\n \n     protected:\n-      // wait for the state to be ready and rethrow any stored exception\n-      _Future_result<_Result>&\n+      /// Wait for the state to be ready and rethrow any stored exception\n+      __result_type\n       _M_get_result()\n       {\n-        _Future_result_base& __res = this->_M_state->wait();\n+        _Result_base& __res = this->_M_state->wait();\n         if (!(__res._M_error == 0))\n           rethrow_exception(__res._M_error);\n-        return static_cast<_Future_result<_Result>&>(__res);\n+        return static_cast<__result_type>(__res);\n       }\n \n-      typedef shared_ptr<_Future_state> _State_ptr;\n-\n-      // construction of a unique_future by promise::get_future()\n+      // Construction of a unique_future by promise::get_future()\n       explicit\n-      _Future_impl(const _State_ptr& __state)\n-      : _M_state(__state)\n+      __basic_future(const __state_type& __state) : _M_state(__state)\n       {\n         if (static_cast<bool>(this->_M_state))\n           this->_M_state->_M_set_retrieved_flag();\n         else\n           __throw_future_error(int(future_errc::future_already_retrieved));\n       }\n \n-      // copy construction from a shared_future\n+      // Copy construction from a shared_future\n       explicit\n-      _Future_impl(const shared_future<_Result>&);\n+      __basic_future(const shared_future<_Res>&);\n \n-      // move construction from a unique_future\n+      // Move construction from a unique_future\n       explicit\n-      _Future_impl(unique_future<_Result>&&);\n-\n-      _State_ptr _M_state;\n+      __basic_future(unique_future<_Res>&&);\n     };\n \n-  /// primary template for unique_future\n-  template<typename _Result>\n-    class unique_future : public _Future_impl<_Result>\n+\n+  /// Primary template for unique_future.\n+  template<typename _Res>\n+    class unique_future : public __basic_future<_Res>\n     {\n-      typedef _Move_future_result<_Result> _Mover;\n+      friend class promise<_Res>;\n+\n+      typedef __basic_future<_Res> _Base_type;\n+      typedef typename _Base_type::__state_type __state_type;\n+      typedef __future_base::_Move_result<_Res> _Mover;\n+\n+      explicit\n+      unique_future(const __state_type& __state) : _Base_type(__state) { }\n \n     public:\n       /// Move constructor\n       unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n \n-      // disable copying\n+      // Disable copying\n       unique_future(const unique_future&) = delete;\n       unique_future& operator=(const unique_future&) = delete;\n \n-      // retrieving the value\n+      /// Retrieving the value\n       typename _Mover::__rval_type\n       get()\n       { return _Mover::_S_move(this->_M_get_result()._M_value()); }\n-\n-    private:\n-      typedef _Future_impl<_Result> _Base_type;\n-      typedef typename _Base_type::_State_ptr _State_ptr;\n-\n-      friend class promise<_Result>;\n-\n-      explicit\n-      unique_future(const _State_ptr& __state) : _Base_type(__state) { }\n     };\n  \n-  // partial specialization for unique_future<R&>\n-  template<typename _Result>\n-    class unique_future<_Result&> : public _Future_impl<_Result&>\n+  /// Partial specialization for unique_future<R&>\n+  template<typename _Res>\n+    class unique_future<_Res&> : public __basic_future<_Res&>\n     {\n+      friend class promise<_Res&>;\n+\n+      typedef __basic_future<_Res&> _Base_type;\n+      typedef typename _Base_type::__state_type __state_type;\n+\n+      explicit\n+      unique_future(const __state_type& __state) : _Base_type(__state) { }\n+\n     public:\n       /// Move constructor\n       unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n \n-      // disable copying\n+      // Disable copying\n       unique_future(const unique_future&) = delete;\n       unique_future& operator=(const unique_future&) = delete;\n \n-      // retrieving the value\n-      _Result& get() { return *this->_M_get_result()._M_value_ptr; }\n+      /// Retrieving the value\n+      _Res& \n+      get() { return *this->_M_get_result()._M_value_ptr; }\n+    };\n \n-    private:\n-      typedef _Future_impl<_Result&>           _Base_type;\n-      typedef typename _Base_type::_State_ptr _State_ptr;\n+  /// Explicit specialization for unique_future<void>\n+  template<>\n+    class unique_future<void> : public __basic_future<void>\n+    {\n+      friend class promise<void>;\n \n-      friend class promise<_Result&>;\n+      typedef __basic_future<void> _Base_type;\n+      typedef typename _Base_type::__state_type __state_type;\n \n       explicit\n-      unique_future(const _State_ptr& __state) : _Base_type(__state) { }\n-    };\n+      unique_future(const __state_type& __state) : _Base_type(__state) { }\n \n-  // specialization for unique_future<void>\n-  template<>\n-    class unique_future<void> : public _Future_impl<void>\n-    {\n     public:\n       /// Move constructor\n       unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n \n-      // disable copying\n+      // Disable copying\n       unique_future(const unique_future&) = delete;\n       unique_future& operator=(const unique_future&) = delete;\n \n-      // retrieving the value\n-      void get() { this->_M_get_result(); }\n-\n-    private:\n-      typedef _Future_impl<void> _Base_type;\n-      typedef _Base_type::_State_ptr _State_ptr;\n-\n-      friend class promise<void>;\n-\n-      explicit\n-      unique_future(const _State_ptr& __state) : _Base_type(__state) { }\n+      /// Retrieving the value\n+      void \n+      get() { this->_M_get_result(); }\n     };\n \n-  /// primary template for shared_future\n-  template<typename _Result>\n-    class shared_future : public _Future_impl<_Result>\n+\n+  /// Primary template for shared_future.\n+  template<typename _Res>\n+    class shared_future : public __basic_future<_Res>\n     {\n+      typedef __basic_future<_Res> _Base_type;\n+\n     public:\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n \n       /// Construct from a unique_future rvalue\n-      shared_future(unique_future<_Result>&& __uf)\n+      shared_future(unique_future<_Res>&& __uf)\n       : _Base_type(std::move(__uf))\n       { }\n \n       shared_future& operator=(const shared_future&) = delete;\n \n-      // retrieving the value\n-      const _Result&\n+      /// Retrieving the value\n+      const _Res&\n       get()\n-      { return this->_M_get_result()._M_value(); }\n-\n-    private:\n-      typedef _Future_impl<_Result> _Base_type;\n+      { \n+\ttypename _Base_type::__result_type __r = this->_M_get_result();\n+\t_Res& __rs(__r._M_value());\n+\treturn __rs;\n+      }\n     };\n  \n-  // partial specialization for shared_future<R&>\n-  template<typename _Result>\n-    class shared_future<_Result&> : public _Future_impl<_Result&>\n+  /// Partial specialization for shared_future<R&>\n+  template<typename _Res>\n+    class shared_future<_Res&> : public __basic_future<_Res&>\n     {\n+      typedef __basic_future<_Res&>           _Base_type;\n+\n     public:\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n \n       /// Construct from a unique_future rvalue\n-      shared_future(unique_future<_Result&>&& __uf)\n+      shared_future(unique_future<_Res&>&& __uf)\n       : _Base_type(std::move(__uf))\n       { }\n \n       shared_future& operator=(const shared_future&) = delete;\n \n-      // retrieving the value\n-      _Result& get() { return *this->_M_get_result()._M_value_ptr; }\n-\n-    private:\n-      typedef _Future_impl<_Result&>           _Base_type;\n+      /// Retrieving the value\n+      _Res& \n+      get() { return *this->_M_get_result()._M_value_ptr; }\n     };\n \n-  // specialization for shared_future<void>\n+  /// Explicit specialization for shared_future<void>\n   template<>\n-    class shared_future<void> : public _Future_impl<void>\n+    class shared_future<void> : public __basic_future<void>\n     {\n+      typedef __basic_future<void> _Base_type;\n+\n     public:\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n@@ -528,33 +562,39 @@ namespace std\n \n       shared_future& operator=(const shared_future&) = delete;\n \n-      // retrieving the value\n-      void get() { this->_M_get_result(); }\n-\n-    private:\n-      typedef _Future_impl<void> _Base_type;\n+      // Retrieving the value\n+      void \n+      get() { this->_M_get_result(); }\n     };\n \n-  // now we can define the protected _Future_impl constructors\n-\n-  template<typename _Result>\n-    _Future_impl<_Result>::_Future_impl(const shared_future<_Result>& __sf)\n+  // Now we can define the protected __basic_future constructors.\n+  template<typename _Res>\n+    __basic_future<_Res>::__basic_future(const shared_future<_Res>& __sf)\n     : _M_state(__sf._M_state)\n     { }\n \n-  template<typename _Result>\n-    _Future_impl<_Result>::_Future_impl(unique_future<_Result>&& __uf)\n+  template<typename _Res>\n+    __basic_future<_Res>::__basic_future(unique_future<_Res>&& __uf)\n     : _M_state(std::move(__uf._M_state))\n     { }\n \n-  /// primary template for promise\n-  template<typename _Result>\n+\n+  /// Primary template for promise\n+  template<typename _Res>\n     class promise\n     {\n+      template<typename> friend class packaged_task;\n+\n+      typedef __future_base::_State \t\t_State;\n+      typedef __future_base::_Move_result<_Res>\t_Mover;\n+      typedef __future_base::_Result<_Res>\tresult_type;\n+      \n+      shared_ptr<_State>                        _M_future;\n+      typename __future_base::_Ptr<result_type>::type\t_M_storage;\n+\n     public:\n       promise()\n-      : _M_future(std::make_shared<_Future_state>()),\n-      _M_storage(new _Future_result<_Result>())\n+      : _M_future(std::make_shared<_State>()), _M_storage(new result_type())\n       { }\n \n       promise(promise&& __rhs)\n@@ -579,7 +619,7 @@ namespace std\n           _M_future->_M_break_promise(std::move(_M_storage));\n       }\n \n-      // assignment\n+      // Assignment\n       promise&\n       operator=(promise&& __rhs)\n       {\n@@ -596,22 +636,22 @@ namespace std\n         _M_storage.swap(__rhs._M_storage);\n       }\n \n-      // retrieving the result\n-      unique_future<_Result>\n+      // Retrieving the result\n+      unique_future<_Res>\n       get_future()\n-      { return unique_future<_Result>(_M_future); }\n+      { return unique_future<_Res>(_M_future); }\n \n-      // setting the result\n+      // Setting the result\n       void\n-      set_value(const _Result& __r)\n+      set_value(const _Res& __r)\n       {\n         if (!_M_satisfied())\n           _M_storage->_M_set(__r);\n         _M_future->_M_set_result(std::move(_M_storage));\n       }\n \n       void\n-      set_value(_Result&& __r)\n+      set_value(_Res&& __r)\n       {\n         if (!_M_satisfied())\n           _M_storage->_M_set(_Mover::_S_move(__r));\n@@ -627,26 +667,29 @@ namespace std\n       }\n \n     private:\n-      template<typename> friend class packaged_task;\n-      typedef _Move_future_result<_Result> _Mover;\n       bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n-      shared_ptr<_Future_state>                           _M_future;\n-      typename _Future_ptr<_Future_result<_Result>>::type _M_storage;\n     };\n \n-  // partial specialization for promise<R&>\n-  template<typename _Result>\n-    class promise<_Result&>\n+  /// Partial specialization for promise<R&>\n+  template<typename _Res>\n+    class promise<_Res&>\n     {\n+      template<typename> friend class packaged_task;\n+      typedef __future_base::_State \t\t_State;\n+ \n+      typedef __future_base::_Result<_Res&> result_type;\n+\n+      shared_ptr<_State>                        _M_future;\n+      typename __future_base::_Ptr<result_type>::type  _M_storage;\n+\n     public:\n       promise()\n-      : _M_future(std::make_shared<_Future_state>()),\n-      _M_storage(new _Future_result<_Result&>())\n+      : _M_future(std::make_shared<_State>()), _M_storage(new result_type())\n       { }\n \n       promise(promise&& __rhs)\n-      : _M_future(std::move(__rhs._M_future)),\n-      _M_storage(std::move(__rhs._M_storage))\n+      : _M_future(std::move(__rhs._M_future)), \n+\t_M_storage(std::move(__rhs._M_storage))\n       { }\n \n       // TODO: requires allocator concepts\n@@ -666,7 +709,7 @@ namespace std\n           _M_future->_M_break_promise(std::move(_M_storage));\n       }\n \n-      // assignment\n+      // Assignment\n       promise&\n       operator=(promise&& __rhs)\n       {\n@@ -683,14 +726,14 @@ namespace std\n         _M_storage.swap(__rhs._M_storage);\n       }\n \n-      // retrieving the result\n-      unique_future<_Result&>\n+      // Retrieving the result\n+      unique_future<_Res&>\n       get_future()\n-      { return unique_future<_Result&>(_M_future); }\n+      { return unique_future<_Res&>(_M_future); }\n \n-      // setting the result\n+      // Setting the result\n       void\n-      set_value(_Result& __r)\n+      set_value(_Res& __r)\n       {\n         if (!_M_satisfied())\n           _M_storage->_M_value_ptr = &__r;\n@@ -706,20 +749,24 @@ namespace std\n       }\n \n     private:\n-      template<typename> friend class packaged_task;\n       bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n-      shared_ptr<_Future_state>                             _M_future;\n-      typename _Future_ptr<_Future_result<_Result&>>::type  _M_storage;\n     };\n \n-  // specialization for promise<void>\n+  /// Explicit specialization for promise<void>\n   template<>\n     class promise<void>\n     {\n+      template<typename> friend class packaged_task;\n+      typedef __future_base::_State \t\t_State;\n+      typedef __future_base::_Result<void>\tresult_type;\n+\n+      shared_ptr<__future_base::_State>                 _M_future;\n+      typename __future_base::_Ptr<result_type>::type   _M_storage;\n+\n     public:\n       promise()\n-      : _M_future(std::make_shared<_Future_state>()),\n-      _M_storage(new _Future_result<void>())\n+      : _M_future(std::make_shared<_State>()),\n+\t_M_storage(new result_type())\n       { }\n \n       promise(promise&& __rhs)\n@@ -744,7 +791,7 @@ namespace std\n           _M_future->_M_break_promise(std::move(_M_storage));\n       }\n \n-      // assignment\n+      // Assignment\n       promise&\n       operator=(promise&& __rhs)\n       {\n@@ -761,12 +808,12 @@ namespace std\n         _M_storage.swap(__rhs._M_storage);\n       }\n \n-      // retrieving the result\n+      // Retrieving the result\n       unique_future<void>\n       get_future()\n       { return unique_future<void>(_M_future); }\n \n-      // setting the result\n+      // Setting the result\n       void\n       set_value()\n       {\n@@ -782,53 +829,54 @@ namespace std\n       }\n \n     private:\n-      template<typename> friend class packaged_task;\n       bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n-      shared_ptr<_Future_state>                 _M_future;\n-      _Future_ptr<_Future_result<void>>::type   _M_storage;\n     };\n \n   // TODO: requires allocator concepts\n   /*\n-  template<typename _Result, class Alloc>\n-    concept_map UsesAllocator<promise<_Result>, Alloc>\n+  template<typename _Res, class Alloc>\n+    concept_map UsesAllocator<promise<_Res>, Alloc>\n     {\n       typedef Alloc allocator_type;\n     }\n    */\n-\n-  template<typename _Result, typename... _ArgTypes>\n+  /// Primary template.\n+  template<typename _Res, typename... _ArgTypes>\n     struct _Run_task\n     {\n       static void\n-      _S_run(promise<_Result>& __p, function<_Result(_ArgTypes...)>& __f,\n-          _ArgTypes... __args)\n+      _S_run(promise<_Res>& __p, function<_Res(_ArgTypes...)>& __f,\n+\t     _ArgTypes... __args)\n       {\n         __p.set_value(__f(std::forward<_ArgTypes>(__args)...));\n       }\n     };\n \n-  // specialization used by packaged_task<void(...)>\n+  /// Specialization used by packaged_task<void(...)>\n   template<typename... _ArgTypes>\n     struct _Run_task<void, _ArgTypes...>\n     {\n       static void\n       _S_run(promise<void>& __p, function<void(_ArgTypes...)>& __f,\n-          _ArgTypes... __args)\n+\t     _ArgTypes... __args)\n       {\n         __f(std::forward<_ArgTypes>(__args)...);\n         __p.set_value();\n       }\n     };\n \n+\n   /// packaged_task\n-  template<typename _Result, typename... _ArgTypes>\n-    class packaged_task<_Result(_ArgTypes...)>\n+  template<typename _Res, typename... _ArgTypes>\n+    class packaged_task<_Res(_ArgTypes...)>\n     {\n+      function<_Res(_ArgTypes...)>   _M_task;\n+      promise<_Res>                  _M_promise;\n+\n     public:\n-      typedef _Result result_type;\n+      typedef _Res result_type;\n \n-      // construction and destruction\n+      // Construction and destruction\n       packaged_task() { }\n \n       template<typename _Fn>\n@@ -840,7 +888,7 @@ namespace std\n         packaged_task(_Fn&& __fn) : _M_task(std::move(__fn)) { }\n \n       explicit\n-      packaged_task(_Result(*__fn)(_ArgTypes...)) : _M_task(__fn) { }\n+      packaged_task(_Res(*__fn)(_ArgTypes...)) : _M_task(__fn) { }\n \n       // TODO: requires allocator concepts\n       /*\n@@ -859,11 +907,11 @@ namespace std\n \n       ~packaged_task() = default;\n \n-      // no copy\n+      // No copy\n       packaged_task(packaged_task&) = delete;\n       packaged_task& operator=(packaged_task&) = delete;\n \n-      // move support\n+      // Move support\n       packaged_task(packaged_task&& __other)\n       { this->swap(__other); }\n \n@@ -882,8 +930,8 @@ namespace std\n \n       explicit operator bool() const { return static_cast<bool>(_M_task); }\n \n-      // result retrieval\n-      unique_future<_Result>\n+      // Result retrieval\n+      unique_future<_Res>\n       get_future()\n       {\n         __try\n@@ -900,7 +948,7 @@ namespace std\n         }\n       }\n \n-      // execution\n+      // Execution\n       void\n       operator()(_ArgTypes... __args)\n       {\n@@ -915,7 +963,7 @@ namespace std\n \n         __try\n         {\n-          _Run_task<_Result, _ArgTypes...>::_S_run(_M_promise, _M_task,\n+          _Run_task<_Res, _ArgTypes...>::_S_run(_M_promise, _M_task,\n               std::forward<_ArgTypes>(__args)...);\n         }\n         __catch (...)\n@@ -924,11 +972,7 @@ namespace std\n         }\n       }\n \n-      void reset() { promise<_Result>().swap(_M_promise); }\n-\n-    private:\n-      function<_Result(_ArgTypes...)>   _M_task;\n-      promise<_Result>                  _M_promise;\n+      void reset() { promise<_Res>().swap(_M_promise); }\n     };\n \n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "db3baf357727cb0bd905b37a7a4314f5dd70b3f4", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -33,4 +33,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 32 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 864 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 912 }"}, {"sha": "8e57d3198f458ec130b84f4cb55fcb076df37598", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -32,4 +32,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 31 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 863 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 911 }"}, {"sha": "5e16d145ccc53f86afbbaf6e5df98d95923890d6", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -33,4 +33,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 32 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 590 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 630 }"}, {"sha": "1e857977927f665c8eac3a118f001d60f5106d78", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -32,4 +32,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 31 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 574 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 614 }"}, {"sha": "26211fe1c7629eaeb0ccea5e6d40deb1a9610a24", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -35,4 +35,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 34 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 483 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 514 }"}, {"sha": "e29148ee78588829a95abc75cf22001571143a57", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -35,4 +35,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 34 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 403 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 440 }"}, {"sha": "8134c7d9219d99e718ccabed07688856f486e5f8", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36abf03266d725a7249c2b382932724d18f598a/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc?ref=c36abf03266d725a7249c2b382932724d18f598a", "patch": "@@ -34,4 +34,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 33 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 402 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 439 }"}]}