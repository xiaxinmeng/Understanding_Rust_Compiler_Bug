{"sha": "c5b1ea2558cf65ccb6996d7571ee64460164546f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViMWVhMjU1OGNmNjVjY2I2OTk2ZDc1NzFlZTY0NDYwMTY0NTQ2Zg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-12-17T11:05:46Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-12-17T11:05:46Z"}, "message": "i386.md (*tzcnt<mode>_1): Merge *tzcnt<mode>_1_falsedep_1 and *tzcnt<mode>_1 to define_insn_and_split pattern.\n\n\t* config/i386/i386.md (*tzcnt<mode>_1): Merge *tzcnt<mode>_1_falsedep_1\n\tand *tzcnt<mode>_1 to define_insn_and_split pattern.  Adjust split\n\tcondition to split after epilogue_completed.\n\t(ctz<mode>2): Remove expander.\n\t(ctz<mode>2): Merge *ctz<mode>2_falsedep_1 and *ctz<mode>2 to\n\tdefine_insn_and_split pattern.  Adjust split condition to split\n\tafter epilogue_completed.\n\t(clz<mode>2_lznct): Remove expander.\n\t(clz<mode>2_lzcnt): Merge *clz<mode>2_lzcnt_falsedep_1 and\n\t*clz<mode>2 to define_insn_and_split pattern.  Adjust split\n\tcondition to split after epilogue_completed.\n\t(<lt_zcnt>_<mode>): Remove expander.\n\t(<lt_zcnt>_<mode>): Merge *<lt_zcnt>_<mode>_falsedep_1 and\n\t*<lt_zcnt>_<mode> to define_insn_and_split pattern.  Adjust split\n\tcondition to split after epilogue_completed.\n\t(<lt_zcnt>_hi): New insn pattern.\n\t(popcount<mode>2): Remove expander.\n\t(popcount<mode>2): Merge *popcount<mode>2_falsedep_1 and\n\t*popcount<mode>2 to define_insn_and_split pattern.  Adjust split\n\tcondition to split after epilogue_completed.\n\t(popcounthi2): New insn pattern.\n\nFrom-SVN: r243772", "tree": {"sha": "e3cd4b5466286f8b51bf480d7104215b0d4268ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3cd4b5466286f8b51bf480d7104215b0d4268ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5b1ea2558cf65ccb6996d7571ee64460164546f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b1ea2558cf65ccb6996d7571ee64460164546f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b1ea2558cf65ccb6996d7571ee64460164546f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b1ea2558cf65ccb6996d7571ee64460164546f/comments", "author": null, "committer": null, "parents": [{"sha": "6040f6d49773e67d9a847e920bbbb3b1d62f2560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6040f6d49773e67d9a847e920bbbb3b1d62f2560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6040f6d49773e67d9a847e920bbbb3b1d62f2560"}], "stats": {"total": 285, "additions": 134, "deletions": 151}, "files": [{"sha": "d272a19481fa9f871ecaf5b0c7d92d9b9f6d1315", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b1ea2558cf65ccb6996d7571ee64460164546f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b1ea2558cf65ccb6996d7571ee64460164546f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5b1ea2558cf65ccb6996d7571ee64460164546f", "patch": "@@ -1,3 +1,27 @@\n+2016-12-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*tzcnt<mode>_1): Merge *tzcnt<mode>_1_falsedep_1\n+\tand *tzcnt<mode>_1 to define_insn_and_split pattern.  Adjust split\n+\tcondition to split after epilogue_completed.\n+\t(ctz<mode>2): Remove expander.\n+\t(ctz<mode>2): Merge *ctz<mode>2_falsedep_1 and *ctz<mode>2 to\n+\tdefine_insn_and_split pattern.  Adjust split condition to split\n+\tafter epilogue_completed.\n+\t(clz<mode>2_lznct): Remove expander.\n+\t(clz<mode>2_lzcnt): Merge *clz<mode>2_lzcnt_falsedep_1 and\n+\t*clz<mode>2 to define_insn_and_split pattern.  Adjust split\n+\tcondition to split after epilogue_completed.\n+\t(<lt_zcnt>_<mode>): Remove expander.\n+\t(<lt_zcnt>_<mode>): Merge *<lt_zcnt>_<mode>_falsedep_1 and\n+\t*<lt_zcnt>_<mode> to define_insn_and_split pattern.  Adjust split\n+\tcondition to split after epilogue_completed.\n+\t(<lt_zcnt>_hi): New insn pattern.\n+\t(popcount<mode>2): Remove expander.\n+\t(popcount<mode>2): Merge *popcount<mode>2_falsedep_1 and\n+\t*popcount<mode>2 to define_insn_and_split pattern.  Adjust split\n+\tcondition to split after epilogue_completed.\n+\t(popcounthi2): New insn pattern.\n+\n 2016-12-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/altivec.md (UNSPEC_CMPRB): New unspec value.\n@@ -20,7 +44,7 @@\n \t(CMPRB2): Add overload support for byte-in-either-range function.\n \t(CMPEQB): Add overload support for byte-in-set built-in function.\n \t* config/rs6000/rs6000-c.c (P9_BUILTIN_CMPRB): Macro expansion to\n-\tdefine argument types for new builtin. \n+\tdefine argument types for new builtin.\n \t(P9_BUILTIN_CMPRB2): Likewise.\n \t(P9_BUILTIN_CMPEQB): Likewise.\n \t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Rearrange\n@@ -421,9 +445,9 @@\n \n \t* arm-opts.h (struct arm_arch_core_flag): Add new field ISA.\n \tInitialize it.\n-   \t(arm_arch_core_flag): Delete flags field.\n-    \t(arm_arch_core_flags): Don't initialize flags field.\n- \t* common/config/arm/arm-common.c (check_isa_bits_for): New function.\n+\t(arm_arch_core_flag): Delete flags field.\n+\t(arm_arch_core_flags): Don't initialize flags field.\n+\t* common/config/arm/arm-common.c (check_isa_bits_for): New function.\n \t(arm_target_thumb_only): Use new isa bits arrays.\n \n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>"}, {"sha": "2123914bef9e8cac330ece7ff74247ee0c7b8605", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 106, "deletions": 147, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b1ea2558cf65ccb6996d7571ee64460164546f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b1ea2558cf65ccb6996d7571ee64460164546f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c5b1ea2558cf65ccb6996d7571ee64460164546f", "patch": "@@ -5174,9 +5174,8 @@\n (define_split\n   [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n \t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n-   && epilogue_completed\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\"\n   [(set (match_dup 0)\n@@ -5201,9 +5200,8 @@\n   [(set (match_operand:SF 0 \"sse_reg_operand\")\n         (float_truncate:SF\n \t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n-   && epilogue_completed\n    && (!REG_P (operands[1])\n        || REGNO (operands[0]) != REGNO (operands[1]))\n    && (!EXT_REX_SSE_REG_P (operands[0])\n@@ -5228,9 +5226,8 @@\n   [(set (match_operand:DF 0 \"sse_reg_operand\")\n         (float_extend:DF\n           (match_operand:SF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n-   && epilogue_completed\n    && (!REG_P (operands[1])\n        || REGNO (operands[0]) != REGNO (operands[1]))\n    && (!EXT_REX_SSE_REG_P (operands[0])\n@@ -12569,54 +12566,43 @@\n   ix86_expand_clear (operands[2]);\n })\n \n-; False dependency happens when destination is only updated by tzcnt,\n-; lzcnt or popcnt.  There is no false dependency when destination is\n-; also used in source.\n-(define_insn_and_split \"*tzcnt<mode>_1_falsedep_1\"\n+(define_insn_and_split \"*tzcnt<mode>_1\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")\n \t\t     (const_int 0)))\n    (set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(ctz:SWI48 (match_dup 1)))]\n-  \"TARGET_BMI\n-   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"TARGET_BMI\"\n+  \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n   [(parallel\n     [(set (reg:CCC FLAGS_REG)\n \t  (compare:CCC (match_dup 1) (const_int 0)))\n      (set (match_dup 0)\n \t  (ctz:SWI48 (match_dup 1)))\n      (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)])]\n-{\n-  if (!reg_mentioned_p (operands[0], operands[1]))\n-    ix86_expand_clear (operands[0]);\n-})\n-\n-(define_insn \"*tzcnt<mode>_1_falsedep\"\n-  [(set (reg:CCC FLAGS_REG)\n-\t(compare:CCC (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")\n-\t\t     (const_int 0)))\n-   (set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(ctz:SWI48 (match_dup 1)))\n-   (unspec [(match_operand:SWI48 2 \"register_operand\" \"0\")]\n-\t   UNSPEC_INSN_FALSE_DEP)]\n-  \"TARGET_BMI\"\n-  \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  \"ix86_expand_clear (operands[0]);\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"prefix_rep\" \"1\")\n    (set_attr \"btver2_decode\" \"double\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*tzcnt<mode>_1\"\n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n+(define_insn \"*tzcnt<mode>_1_falsedep\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")\n \t\t     (const_int 0)))\n    (set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(ctz:SWI48 (match_dup 1)))]\n+\t(ctz:SWI48 (match_dup 1)))\n+   (unspec [(match_operand:SWI48 2 \"register_operand\" \"0\")]\n+\t   UNSPEC_INSN_FALSE_DEP)]\n   \"TARGET_BMI\"\n-  \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -12637,13 +12623,6 @@\n    (set_attr \"znver1_decode\" \"vector\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_expand \"ctz<mode>2\"\n-  [(parallel\n-    [(set (match_operand:SWI48 0 \"register_operand\")\n-\t  (ctz:SWI48\n-\t    (match_operand:SWI48 1 \"nonimmediate_operand\")))\n-     (clobber (reg:CC FLAGS_REG))])])\n-\n (define_insn_and_split \"*ctzhi2\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(ctz:SI\n@@ -12662,28 +12641,47 @@\n   DONE;\n })\n \n-; False dependency happens when destination is only updated by tzcnt,\n-; lzcnt or popcnt.  There is no false dependency when destination is\n-; also used in source.\n-(define_insn_and_split \"*ctz<mode>2_falsedep_1\"\n+(define_insn_and_split \"ctz<mode>2\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(ctz:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n    (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+{\n+  if (TARGET_BMI)\n+    return \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  else if (optimize_function_for_size_p (cfun))\n+    ;\n+  else if (TARGET_GENERIC)\n+    /* tzcnt expands to 'rep bsf' and we can use it even if !TARGET_BMI.  */\n+    return \"rep%; bsf{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+\n+  return \"bsf{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+}\n   \"(TARGET_BMI || TARGET_GENERIC)\n-   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n   [(parallel\n     [(set (match_dup 0)\n \t  (ctz:SWI48 (match_dup 1)))\n      (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!reg_mentioned_p (operands[0], operands[1]))\n-    ix86_expand_clear (operands[0]);\n-})\n+  \"ix86_expand_clear (operands[0]);\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set (attr \"prefix_rep\")\n+     (if_then_else\n+       (ior (match_test \"TARGET_BMI\")\n+\t    (and (not (match_test \"optimize_function_for_size_p (cfun)\"))\n+\t\t (match_test \"TARGET_GENERIC\")))\n+       (const_string \"1\")\n+       (const_string \"0\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n (define_insn \"*ctz<mode>2_falsedep\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(ctz:SWI48\n@@ -12706,33 +12704,6 @@\n    (set_attr \"prefix_rep\" \"1\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*ctz<mode>2\"\n-  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(ctz:SWI48 (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-{\n-  if (TARGET_BMI)\n-    return \"tzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n-  else if (optimize_function_for_size_p (cfun))\n-    ;\n-  else if (TARGET_GENERIC)\n-    /* tzcnt expands to 'rep bsf' and we can use it even if !TARGET_BMI.  */\n-    return \"rep%; bsf{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n-\n-  return \"bsf{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n-}\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"prefix_0f\" \"1\")\n-   (set (attr \"prefix_rep\")\n-     (if_then_else\n-       (ior (match_test \"TARGET_BMI\")\n-\t    (and (not (match_test \"optimize_function_for_size_p (cfun)\"))\n-\t\t (match_test \"TARGET_GENERIC\")))\n-       (const_string \"1\")\n-       (const_string \"0\")))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"bsr_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (const_int 63)\n@@ -12807,45 +12778,35 @@\n   DONE;\n })\n \n-; False dependency happens when destination is only updated by tzcnt,\n-; lzcnt or popcnt.  There is no false dependency when destination is\n-; also used in source.\n-(define_insn_and_split \"*clz<mode>2_lzcnt_falsedep_1\"\n+(define_insn_and_split \"clz<mode>2_lzcnt\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(clz:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_LZCNT\n-   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"TARGET_LZCNT\"\n+  \"lzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n   [(parallel\n     [(set (match_dup 0)\n \t  (clz:SWI48 (match_dup 1)))\n      (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!reg_mentioned_p (operands[0], operands[1]))\n-    ix86_expand_clear (operands[0]);\n-})\n-\n-(define_insn \"*clz<mode>2_lzcnt_falsedep\"\n-  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(clz:SWI48\n-\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n-   (unspec [(match_operand:SWI48 2 \"register_operand\" \"0\")]\n-\t   UNSPEC_INSN_FALSE_DEP)\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_LZCNT\"\n-  \"lzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  \"ix86_expand_clear (operands[0]);\"\n   [(set_attr \"prefix_rep\" \"1\")\n    (set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"clz<mode>2_lzcnt\"\n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n+(define_insn \"*clz<mode>2_lzcnt_falsedep\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(clz:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n+   (unspec [(match_operand:SWI48 2 \"register_operand\" \"0\")]\n+\t   UNSPEC_INSN_FALSE_DEP)\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_LZCNT\"\n   \"lzcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n@@ -12868,34 +12829,30 @@\n ;; Version of lzcnt/tzcnt that is expanded from intrinsics.  This version\n ;; provides operand size as output when source operand is zero. \n \n-(define_expand \"<lt_zcnt>_<mode>\"\n-  [(parallel\n-    [(set (match_operand:SWI248 0 \"register_operand\")\n-\t  (unspec:SWI248\n-\t    [(match_operand:SWI248 1 \"nonimmediate_operand\")] LT_ZCNT))\n-     (clobber (reg:CC FLAGS_REG))])])\n-\n-; False dependency happens when destination is only updated by tzcnt,\n-; lzcnt or popcnt.  There is no false dependency when destination is\n-; also used in source.\n-(define_insn_and_split \"*<lt_zcnt>_<mode>_falsedep_1\"\n+(define_insn_and_split \"<lt_zcnt>_<mode>\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(unspec:SWI48\n \t  [(match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")] LT_ZCNT))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"\"\n+  \"<lt_zcnt>{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n   [(parallel\n     [(set (match_dup 0)\n \t  (unspec:SWI48 [(match_dup 1)] LT_ZCNT))\n      (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!reg_mentioned_p (operands[0], operands[1]))\n-    ix86_expand_clear (operands[0]);\n-})\n+  \"ix86_expand_clear (operands[0]);\"\n+  [(set_attr \"type\" \"<lt_zcnt_type>\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n (define_insn \"*<lt_zcnt>_<mode>_falsedep\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(unspec:SWI48\n@@ -12910,17 +12867,17 @@\n    (set_attr \"prefix_rep\" \"1\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*<lt_zcnt>_<mode>\"\n-  [(set (match_operand:SWI248 0 \"register_operand\" \"=r\")\n-\t(unspec:SWI248\n-\t  [(match_operand:SWI248 1 \"nonimmediate_operand\" \"rm\")] LT_ZCNT))\n+(define_insn \"<lt_zcnt>_hi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(unspec:HI\n+\t  [(match_operand:HI 1 \"nonimmediate_operand\" \"rm\")] LT_ZCNT))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"<lt_zcnt>{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  \"<lt_zcnt>{w}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"<lt_zcnt_type>\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"prefix_rep\" \"1\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"HI\")])\n \n ;; BMI instructions.\n \n@@ -13216,33 +13173,35 @@\n   [(set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_expand \"popcount<mode>2\"\n-  [(parallel\n-    [(set (match_operand:SWI248 0 \"register_operand\")\n-\t  (popcount:SWI248\n-\t    (match_operand:SWI248 1 \"nonimmediate_operand\")))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_POPCNT\")\n-\n-(define_insn_and_split \"*popcount<mode>2_falsedep_1\"\n+(define_insn_and_split \"popcount<mode>2\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(popcount:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_POPCNT\n-   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  \"&& reload_completed\"\n+  \"TARGET_POPCNT\"\n+{\n+#if TARGET_MACHO\n+  return \"popcnt\\t{%1, %0|%0, %1}\";\n+#else\n+  return \"popcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+#endif\n+}\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n   [(parallel\n     [(set (match_dup 0)\n \t  (popcount:SWI48 (match_dup 1)))\n      (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!reg_mentioned_p (operands[0], operands[1]))\n-    ix86_expand_clear (operands[0]);\n-})\n+  \"ix86_expand_clear (operands[0]);\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n (define_insn \"*popcount<mode>2_falsedep\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(popcount:SWI48\n@@ -13262,22 +13221,22 @@\n    (set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*popcount<mode>2\"\n-  [(set (match_operand:SWI248 0 \"register_operand\" \"=r\")\n-\t(popcount:SWI248\n-\t  (match_operand:SWI248 1 \"nonimmediate_operand\" \"rm\")))\n+(define_insn \"popcounthi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(popcount:HI\n+\t  (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_POPCNT\"\n {\n #if TARGET_MACHO\n   return \"popcnt\\t{%1, %0|%0, %1}\";\n #else\n-  return \"popcnt{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+  return \"popcnt{w}\\t{%1, %0|%0, %1}\";\n #endif\n }\n   [(set_attr \"prefix_rep\" \"1\")\n    (set_attr \"type\" \"bitmanip\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"HI\")])\n \n (define_expand \"bswapdi2\"\n   [(set (match_operand:DI 0 \"register_operand\")"}]}