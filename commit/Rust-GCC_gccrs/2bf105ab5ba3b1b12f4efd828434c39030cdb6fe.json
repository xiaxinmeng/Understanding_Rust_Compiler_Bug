{"sha": "2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmMTA1YWI1YmEzYjFiMTJmNGVmZDgyODQzNGMzOTAzMGNkYjZmZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-06-03T01:57:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-06-03T01:57:46Z"}, "message": "alias.c (struct alias_set_entry): New field has_zero_child.\n\n\t* alias.c (struct alias_set_entry): New field has_zero_child.\n\t(mem_in_disjoint_alias_sets_p): Return 0 if set in either ase.\n\t(get_alias_set): If language-dependent routine set TYPE_ALIAS_SET,\n\tdo nothing.\n\tCall record_component_aliases for aggregate types.\n\t(record_alias_subset): Set has_zero_child.\n\t(record_component_aliases, case ARRAY_TYPE): Do nothing if\n\tTYPE_NONALIASES_COMPONENT.\n\t(record_component_aliases, case RECORD_TYPE): Test\n\tDECL_NONADDRESSABLE_P.\n\t* c-decl.c (grokdeclarator): Set DECL_NONADDRESSABLE_P instead\n\tof TREE_ADDRESSABLE.\n\t* calls.c (initialize_argument_information): Only test\n\tTYPE_TRANSPARENT_UNION for UNION_TYPE.\n\t* function.c (assign_parms): Likewise.\n\t* integrate.c (function_cannot_inline_p): Likewise.\n\t* stor-layout.c (finish_record_layout): Don't call\n\trecord_component_aliases.\n\t* tree.h (struct tree_int_cst): Use struct tree_common.\n\t(struct tree_real_cst, struct tree_string): Likewise.\n\t(struct tree_complex, struct tree_identifier): Likewise.\n\t(struct tree_list, struct tree_vec, struct tree_exp): Likewise.\n\t(struct tree_block, struct tree_type, struct tree_decl): Likewise.\n\t(TYPE_TRANSPARENT_UNION): Use UNION_TYPE_CHECK.\n\t(TYPE_NONALIASES_COMPONENT): New macro.\n\t(TYPE_AMBIENT_BOUNDEDNESS): Use FUNCTION_TYPE_CHECK.\n\t(DECL_NONADDRESSABLE_P): New macro.\n\t(struct tree_decl): Reorder bits for clarity of how many left;\n\tadd non_adressable.\n\t* cp/cp-tree.h: Use struct tree_common instead of a char array.\n\t* cp/decl.c (grokdeclarator): Set DECL_NONADDRESSABLE_P instead\n\tof TREE_ADDRESSABLE.\n\nFrom-SVN: r34373", "tree": {"sha": "08e18810256295f8a740aab217825918008b48b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08e18810256295f8a740aab217825918008b48b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/comments", "author": null, "committer": null, "parents": [{"sha": "0e13506e499502b91699f089465bc50532e8c65f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e13506e499502b91699f089465bc50532e8c65f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e13506e499502b91699f089465bc50532e8c65f"}], "stats": {"total": 183, "additions": 129, "deletions": 54}, "files": [{"sha": "2ba178cc1ab7a1e60044eb4286072380bffe0988", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -1,3 +1,35 @@\n+Fri Jun  2 19:31:03 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (struct alias_set_entry): New field has_zero_child.\n+\t(mem_in_disjoint_alias_sets_p): Return 0 if set in either ase.\n+\t(get_alias_set): If language-dependent routine set TYPE_ALIAS_SET,\n+\tdo nothing.\n+\tCall record_component_aliases for aggregate types.\n+\t(record_alias_subset): Set has_zero_child.\n+\t(record_component_aliases, case ARRAY_TYPE): Do nothing if\n+\tTYPE_NONALIASES_COMPONENT.\n+\t(record_component_aliases, case RECORD_TYPE): Test\n+\tDECL_NONADDRESSABLE_P.\n+\t* c-decl.c (grokdeclarator): Set DECL_NONADDRESSABLE_P instead\n+\tof TREE_ADDRESSABLE.\n+\t* calls.c (initialize_argument_information): Only test\n+\tTYPE_TRANSPARENT_UNION for UNION_TYPE.\n+\t* function.c (assign_parms): Likewise.\n+\t* integrate.c (function_cannot_inline_p): Likewise.\n+\t* stor-layout.c (finish_record_layout): Don't call\n+\trecord_component_aliases.\n+\t* tree.h (struct tree_int_cst): Use struct tree_common.\n+\t(struct tree_real_cst, struct tree_string): Likewise.\n+\t(struct tree_complex, struct tree_identifier): Likewise.\n+\t(struct tree_list, struct tree_vec, struct tree_exp): Likewise.\n+\t(struct tree_block, struct tree_type, struct tree_decl): Likewise.\n+\t(TYPE_TRANSPARENT_UNION): Use UNION_TYPE_CHECK.\n+\t(TYPE_NONALIASES_COMPONENT): New macro.\n+\t(TYPE_AMBIENT_BOUNDEDNESS): Use FUNCTION_TYPE_CHECK.\n+\t(DECL_NONADDRESSABLE_P): New macro.\n+\t(struct tree_decl): Reorder bits for clarity of how many left;\n+\tadd non_adressable.\n+\n 2000-06-02  Jason Merrill  <jason@casey.soma.redhat.com>\n \n \t* Makefile.in (libgcc.a): Also depend on $(LIB2ADD)."}, {"sha": "c0aa2b7aeee94b34ac72dec8bd02d6787859818e", "filename": "gcc/alias.c", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -79,6 +79,10 @@ typedef struct alias_set_entry\n      continuing our example above, the children here will be all of\n      `int', `double', `float', and `struct S'.  */\n   splay_tree children;\n+\n+  /* Nonzero if would have a child of zero: this effectively makes this\n+     alias set the same as alias set zero.  */\n+  int has_zero_child;\n } *alias_set_entry;\n \n static int rtx_equal_for_memref_p\tPARAMS ((rtx, rtx));\n@@ -239,14 +243,18 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n \n   /* See if the first alias set is a subset of the second.  */\n   ase = get_alias_set_entry (MEM_ALIAS_SET (mem1));\n-  if (ase != 0 && splay_tree_lookup (ase->children,\n-\t\t\t\t     (splay_tree_key) MEM_ALIAS_SET (mem2)))\n+  if (ase != 0\n+      && (ase->has_zero_child\n+\t  || splay_tree_lookup (ase->children,\n+\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem2))))\n     return  0;\n \n   /* Now do the same, but with the alias sets reversed.  */\n   ase = get_alias_set_entry (MEM_ALIAS_SET (mem2));\n-  if (ase != 0 && splay_tree_lookup (ase->children,\n-\t\t\t\t     (splay_tree_key) MEM_ALIAS_SET (mem1)))\n+  if (ase != 0\n+      && (ase->has_zero_child\n+\t  || splay_tree_lookup (ase->children,\n+\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem1))))\n     return  0;\n \n   /* The two MEMs are in distinct alias sets, and neither one is the\n@@ -406,7 +414,12 @@ get_alias_set (t)\n \n   /* See if the language has special handling for this type.  */\n   if ((set = lang_get_alias_set (t)) != -1)\n-    ;\n+    {\n+      /* If the alias set is now known, we are done.  */\n+      if (TYPE_ALIAS_SET_KNOWN_P (t))\n+\treturn TYPE_ALIAS_SET (t);\n+    }\n+\n   /* There are no objects of FUNCTION_TYPE, so there's no point in\n      using up an alias set for them.  (There are, of course, pointers\n      and references to functions, but that's different.)  */\n@@ -417,6 +430,12 @@ get_alias_set (t)\n     set = new_alias_set ();\n \n   TYPE_ALIAS_SET (t) = set;\n+\n+  /* If this is an aggregate type, we must record any component aliasing\n+     information.  */\n+  if (AGGREGATE_TYPE_P (t))\n+    record_component_aliases (t);\n+\n   return set;\n }\n \n@@ -468,18 +487,26 @@ record_alias_subset (superset, subset)\n \n     }\n \n-  subset_entry = get_alias_set_entry (subset);\n+  if (subset == 0)\n+    superset_entry->has_zero_child = 1;\n+  else\n+    {\n+      subset_entry = get_alias_set_entry (subset);\n+      /* If there is an entry for the subset, enter all of its children\n+\t (if they are not already present) as children of the SUPERSET.  */\n+      if (subset_entry) \n+\t{\n+\t  if (subset_entry->has_zero_child)\n+\t    superset_entry->has_zero_child = 1;\n \n-  /* If there is an entry for the subset, enter all of its children\n-     (if they are not already present) as children of the SUPERSET.  */\n-  if (subset_entry) \n-    splay_tree_foreach (subset_entry->children,\n-\t\t\tinsert_subset_children,\n-\t\t\tsuperset_entry->children);\n+\t  splay_tree_foreach (subset_entry->children, insert_subset_children,\n+\t\t\t      superset_entry->children);\n+\t}\n \n-  /* Enter the SUBSET itself as a child of the SUPERSET.  */\n-  splay_tree_insert (superset_entry->children, \n-\t\t     (splay_tree_key) subset, 0);\n+      /* Enter the SUBSET itself as a child of the SUPERSET.  */\n+      splay_tree_insert (superset_entry->children, \n+\t\t\t (splay_tree_key) subset, 0);\n+    }\n }\n \n /* Record that component types of TYPE, if any, are part of that type for\n@@ -493,7 +520,6 @@ record_component_aliases (type)\n      tree type;\n {\n   HOST_WIDE_INT superset = get_alias_set (type);\n-  HOST_WIDE_INT subset;\n   tree field;\n \n   if (superset == 0)\n@@ -502,20 +528,16 @@ record_component_aliases (type)\n   switch (TREE_CODE (type))\n     {\n     case ARRAY_TYPE:\n-      subset = get_alias_set (TREE_TYPE (type));\n-      if (subset != 0)\n-\trecord_alias_subset (superset, subset);\n+      if (! TYPE_NONALIASED_COMPONENT (type))\n+\trecord_alias_subset (superset, get_alias_set (TREE_TYPE (type)));\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n-\t{\n-\t  subset = get_alias_set (TREE_TYPE (field));\n-\t  if (TREE_ADDRESSABLE (field) && subset != 0 && subset != superset)\n-\t    record_alias_subset (superset, subset);\n-\t}\n+\tif (! DECL_NONADDRESSABLE_P (field))\n+\t  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));\n       break;\n \n     default:"}, {"sha": "0efffabeb559a4c250dd97a16d250a0b6aba9226", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -4697,7 +4697,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n-\tTREE_ADDRESSABLE (decl) = ! bitfield;\n+\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n+\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n       }"}, {"sha": "3d49d3e60ec347b1043a642fd453cbded500ee74", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -1109,7 +1109,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n       /* If TYPE is a transparent union, pass things the way we would\n \t pass the first field of the union.  We have already verified that\n \t the modes are the same.  */\n-      if (TYPE_TRANSPARENT_UNION (type))\n+      if (TREE_CODE (type) == UNION_TYPE && TYPE_TRANSPARENT_UNION (type))\n \ttype = TREE_TYPE (TYPE_FIELDS (type));\n \n       /* Decide where to pass this arg."}, {"sha": "fc78de7f6185ee050e6d1378e8fbdf11ae78cc30", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -1,3 +1,9 @@\n+Fri Jun  2 19:38:57 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cp-tree.h: Use struct tree_common instead of a char array.\n+\t* decl.c (grokdeclarator): Set DECL_NONADDRESSABLE_P instead\n+\tof TREE_ADDRESSABLE.\n+\n 2000-06-02  Richard Henderson  <rth@cygnus.com>\n \n \t* decl.c (init_decl_processing): Don't set lang_get_alias_set."}, {"sha": "888e73ebc43211b0c5778a09079aa3c054d440f4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -299,7 +299,7 @@ typedef struct\n \n typedef struct \n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   HOST_WIDE_INT index;\n   HOST_WIDE_INT level;\n   HOST_WIDE_INT orig_level;\n@@ -308,7 +308,7 @@ typedef struct\n \n typedef struct ptrmem_cst\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   /* This isn't used, but the middle-end expects all constants to have \n      this field.  */\n   struct rtx_def *rtl;\n@@ -351,7 +351,7 @@ typedef struct ptrmem_cst\n \n struct tree_binding\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   union {\n     tree scope;\n     struct binding_level *level;\n@@ -374,7 +374,7 @@ struct tree_binding\n \n struct tree_overload\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   tree function;\n };\n \n@@ -391,7 +391,7 @@ struct tree_overload\n \n struct tree_wrapper\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   union {\n     void *ptr;\n     int i;\n@@ -402,7 +402,7 @@ struct tree_wrapper\n #define SRCLOC_LINE(NODE) (((struct tree_srcloc*)SRCLOC_CHECK (NODE))->linenum)\n struct tree_srcloc\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   const char *filename;\n   int linenum;\n };"}, {"sha": "2c83225d7a8e6950468a69313a7b71a8071e6304", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -11594,7 +11594,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    else\n \t      {\n \t\tdecl = build_decl (FIELD_DECL, declarator, type);\n-\t\tTREE_ADDRESSABLE (decl) = ! bitfield;\n+\t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;"}, {"sha": "31b71c68d2c19d83aecf9312ee8a98453665c192", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -4231,7 +4231,8 @@ assign_parms (fndecl)\n \t type of the first field for the tests below.  We have already\n \t verified that the modes are the same.  */\n       if (DECL_TRANSPARENT_UNION (parm)\n-\t  || TYPE_TRANSPARENT_UNION (passed_type))\n+\t  || (TREE_CODE (passed_type) == UNION_TYPE\n+\t      && TYPE_TRANSPARENT_UNION (passed_type)))\n \tpassed_type = TREE_TYPE (TYPE_FIELDS (passed_type));\n \n       /* See if this arg was passed by invisible reference.  It is if"}, {"sha": "eba94c10758ce3f04fe63be227f3a078a6476c40", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -201,7 +201,8 @@ function_cannot_inline_p (fndecl)\n     {\n       if (int_size_in_bytes (TREE_TYPE (parms)) < 0)\n \treturn N_(\"function with varying-size parameter cannot be inline\");\n-      else if (TYPE_TRANSPARENT_UNION (TREE_TYPE (parms)))\n+      else if (TREE_CODE (TREE_TYPE (parms)) == UNION_TYPE\n+\t       && TYPE_TRANSPARENT_UNION (TREE_TYPE (parms)))\n \treturn N_(\"function with transparent unit parameter cannot be inline\");\n     }\n "}, {"sha": "b28432bd848a20feb40c833fdce152c81221eeea", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -1173,9 +1173,6 @@ finish_record_layout (rli)\n       rli->pending_statics = TREE_CHAIN (rli->pending_statics);\n     }\n \n-  /* Show any alias subsetting we need.  */\n-  record_component_aliases (rli->t);\n-\n   /* Clean up.  */\n   free (rli);\n }"}, {"sha": "6990ec22b2553639e33a6ab5122f0fb9a211c977", "filename": "gcc/tree.h", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf105ab5ba3b1b12f4efd828434c39030cdb6fe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2bf105ab5ba3b1b12f4efd828434c39030cdb6fe", "patch": "@@ -671,7 +671,7 @@ extern void tree_class_check_failed PARAMS ((const tree, char,\n \n struct tree_int_cst\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t   (rtl) info */\n   unsigned HOST_WIDE_INT int_cst_low;\n@@ -695,7 +695,7 @@ struct tree_int_cst\n \n struct tree_real_cst\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   REAL_VALUE_TYPE real_cst;\n@@ -707,7 +707,7 @@ struct tree_real_cst\n \n struct tree_string\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   int length;\n@@ -720,7 +720,7 @@ struct tree_string\n \n struct tree_complex\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   union tree_node *real;\n@@ -734,7 +734,7 @@ struct tree_complex\n \n struct tree_identifier\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   int length;\n   char *pointer;\n };\n@@ -745,7 +745,7 @@ struct tree_identifier\n \n struct tree_list\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   union tree_node *purpose;\n   union tree_node *value;\n };\n@@ -757,7 +757,7 @@ struct tree_list\n \n struct tree_vec\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   int length;\n   union tree_node *a[1];\n };\n@@ -813,7 +813,7 @@ struct tree_vec\n \n struct tree_exp\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   int complexity;\n   union tree_node *operands[1];\n };\n@@ -839,7 +839,7 @@ struct tree_exp\n \n struct tree_block\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n \n   unsigned handler_block_flag : 1;\n   unsigned abstract_flag : 1;\n@@ -1007,11 +1007,18 @@ struct tree_block\n \n /* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n-#define TYPE_NEEDS_CONSTRUCTING(NODE) (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n+#define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n+  (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n \n /* Indicates that objects of this type (a UNION_TYPE), should be passed\n    the same way that the first union alternative would be passed.  */\n-#define TYPE_TRANSPARENT_UNION(NODE) (TYPE_CHECK (NODE)->type.transparent_union_flag)\n+#define TYPE_TRANSPARENT_UNION(NODE)  \\\n+  (UNION_TYPE_CHECK (NODE)->type.transparent_union_flag)\n+\n+/* For an ARRAY_TYPE, indicates that it is not permitted to\n+   take the address of a component of the type.  */\n+#define TYPE_NONALIASED_COMPONENT(NODE) \\\n+  (ARRAY_TYPE_CHECK (NODE)->type.transparent_union_flag)\n \n /* Indicated that objects of this type should be laid out in as\n    compact a way as possible.  */\n@@ -1070,15 +1077,15 @@ struct tree_block\n    default_pointer_boundedness at the time TYPE was created.  It is\n    useful for choosing default boundedness of function arguments for\n    non-prototype function decls and for varargs/stdarg lists.  */\n-\n-#define TYPE_AMBIENT_BOUNDEDNESS(TYPE) (TYPE_CHECK (TYPE)->type.transparent_union_flag)\n+#define TYPE_AMBIENT_BOUNDEDNESS(TYPE) \\\n+  (FUNCTION_TYPE_CHECK (TYPE)->type.transparent_union_flag)\n \n #define MAX_POINTER_DEPTH 2\n #define VA_LIST_POINTER_DEPTH 3\n \n struct tree_type\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   union tree_node *values;\n   union tree_node *size;\n   union tree_node *size_unit;\n@@ -1522,6 +1529,11 @@ struct tree_type\n    an address constant.  */\n #define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n \n+/* Used in a FIELD_DECL to indicate that we cannot form the address of\n+   this component.  */\n+#define DECL_NONADDRESSABLE_P(NODE) \\\n+  (FIELD_DECL_CHECK (NODE)->decl.non_addressable)\n+\n /* Used to indicate an alias set for the memory pointed to by this\n    particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n    pointer (or reference) type.  */\n@@ -1544,7 +1556,7 @@ struct tree_type\n \n struct tree_decl\n {\n-  char common[sizeof (struct tree_common)];\n+  struct tree_common common;\n   const char *filename;\n   int linenum;\n   unsigned int uid;\n@@ -1575,9 +1587,12 @@ struct tree_decl\n   unsigned comdat_flag : 1;\n   unsigned malloc_flag : 1;\n   unsigned no_limit_stack : 1;\n-  unsigned pure_flag : 1;\n   ENUM_BITFIELD(built_in_class) built_in_class : 2;\n+\n+  unsigned pure_flag : 1;\n   unsigned pointer_depth : 2;\n+  unsigned non_addressable : 1;\n+  /* Four unused bits.  */\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;"}]}