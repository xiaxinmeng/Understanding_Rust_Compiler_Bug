{"sha": "1b7b352a8379dbdd74c962d11951982e21e20f13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI3YjM1MmE4Mzc5ZGJkZDc0Yzk2MmQxMTk1MTk4MmUyMWUyMGYxMw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-24T06:35:58Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-25T15:02:47Z"}, "message": "d: Merge upstream dmd 4be011355.\n\nFixes self-assignment warnings seen when compiling with clang.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11315\n\ngcc/d/ChangeLog:\n\n\tPR d/95075\n\t* dmd/MERGE: Merge upstream dmd 4be011355.", "tree": {"sha": "c970f8b3a33d694ea0fc0739646fc00e81fa7391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c970f8b3a33d694ea0fc0739646fc00e81fa7391"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b7b352a8379dbdd74c962d11951982e21e20f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7b352a8379dbdd74c962d11951982e21e20f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b7b352a8379dbdd74c962d11951982e21e20f13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7b352a8379dbdd74c962d11951982e21e20f13/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d19c9cd3dd99ba8885c0fc93223918399f73939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d19c9cd3dd99ba8885c0fc93223918399f73939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d19c9cd3dd99ba8885c0fc93223918399f73939"}], "stats": {"total": 100, "additions": 55, "deletions": 45}, "files": [{"sha": "7de89351482cd1a4accc3af904fcb7b33c8c1e16", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b7b352a8379dbdd74c962d11951982e21e20f13/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b7b352a8379dbdd74c962d11951982e21e20f13/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=1b7b352a8379dbdd74c962d11951982e21e20f13", "patch": "@@ -1,4 +1,4 @@\n-90450f3ef6ab8551b5f383d8c6190f80034dbf93\n+4be011355dd2c5e2e54b99f9369d5faeabca2ca5\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "32caf7d24097dd3e24acabca75e4f4dccf5b248e", "filename": "gcc/d/dmd/dscope.c", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b7b352a8379dbdd74c962d11951982e21e20f13/gcc%2Fd%2Fdmd%2Fdscope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b7b352a8379dbdd74c962d11951982e21e20f13/gcc%2Fd%2Fdmd%2Fdscope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.c?ref=1b7b352a8379dbdd74c962d11951982e21e20f13", "patch": "@@ -291,54 +291,64 @@ unsigned *Scope::saveFieldInit()\n     return fi;\n }\n \n-static bool mergeFieldInit(unsigned &fieldInit, unsigned fi, bool mustInit)\n+/****************************************\n+ * Merge `b` flow analysis results into `a`.\n+ * Params:\n+ *      a = the path to merge fi into\n+ *      b = the other path\n+ * Returns:\n+ *      false means either `a` or `b` skips initialization\n+ */\n+static bool mergeFieldInit(unsigned &a, const unsigned b)\n {\n-    if (fi != fieldInit)\n-    {\n-        // Have any branches returned?\n-        bool aRet = (fi        & CSXreturn) != 0;\n-        bool bRet = (fieldInit & CSXreturn) != 0;\n+    if (b == a)\n+        return true;\n \n-        // Have any branches halted?\n-        bool aHalt = (fi        & CSXhalt) != 0;\n-        bool bHalt = (fieldInit & CSXhalt) != 0;\n+    // Have any branches returned?\n+    bool aRet = (a & CSXreturn) != 0;\n+    bool bRet = (b & CSXreturn) != 0;\n \n-        bool ok;\n+    // Have any branches halted?\n+    bool aHalt = (a & CSXhalt) != 0;\n+    bool bHalt = (b & CSXhalt) != 0;\n \n-        if (aHalt && bHalt)\n-        {\n-            ok = true;\n-            fieldInit = CSXhalt;\n-        }\n-        else if (!aHalt && aRet)\n-        {\n-            ok = !mustInit || (fi & CSXthis_ctor);\n-            fieldInit = fieldInit;\n-        }\n-        else if (!bHalt && bRet)\n-        {\n-            ok = !mustInit || (fieldInit & CSXthis_ctor);\n-            fieldInit = fi;\n-        }\n-        else if (aHalt)\n-        {\n-            ok = !mustInit || (fieldInit & CSXthis_ctor);\n-            fieldInit = fieldInit;\n-        }\n-        else if (bHalt)\n-        {\n-            ok = !mustInit || (fi & CSXthis_ctor);\n-            fieldInit = fi;\n-        }\n-        else\n-        {\n-            ok = !mustInit || !((fieldInit ^ fi) & CSXthis_ctor);\n-            fieldInit |= fi;\n-        }\n+    if (aHalt && bHalt)\n+    {\n+        a = CSXhalt;\n+        return true;\n+    }\n \n-        return ok;\n+    // The logic here is to prefer the branch that neither halts nor returns.\n+    bool ok;\n+    if (!bHalt && bRet)\n+    {\n+        // Branch b returns, no merging required.\n+        ok = (b & CSXthis_ctor);\n+    }\n+    else if (!aHalt && aRet)\n+    {\n+        // Branch a returns, but b doesn't, b takes precedence.\n+        ok = (a & CSXthis_ctor);\n+        a = b;\n+    }\n+    else if (bHalt)\n+    {\n+        // Branch b halts, no merging required.\n+        ok = (a & CSXthis_ctor);\n+    }\n+    else if (aHalt)\n+    {\n+        // Branch a halts, but b doesn't, b takes precedence\n+        ok = (b & CSXthis_ctor);\n+        a = b;\n+    }\n+    else\n+    {\n+        // Neither branch returns nor halts, merge flags\n+        ok = !((a ^ b) & CSXthis_ctor);\n+        a |= b;\n     }\n-    return true;\n+    return ok;\n }\n \n void Scope::mergeFieldInit(Loc loc, unsigned *fies)\n@@ -356,9 +366,9 @@ void Scope::mergeFieldInit(Loc loc, unsigned *fies)\n             bool mustInit = (v->storage_class & STCnodefaultctor ||\n                              v->type->needsNested());\n \n-            if (!::mergeFieldInit(fieldinit[i], fies[i], mustInit))\n+            if (!::mergeFieldInit(fieldinit[i], fies[i]) && mustInit)\n             {\n-                ::error(loc, \"one path skips field %s\", ad->fields[i]->toChars());\n+                ::error(loc, \"one path skips field %s\", v->toChars());\n             }\n         }\n     }"}]}