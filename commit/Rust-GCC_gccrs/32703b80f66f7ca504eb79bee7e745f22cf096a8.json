{"sha": "32703b80f66f7ca504eb79bee7e745f22cf096a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI3MDNiODBmNjZmN2NhNTA0ZWI3OWJlZTdlNzQ1ZjIyY2YwOTZhOA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-08T14:11:16Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-10T13:02:07Z"}, "message": "libphobos: Add section support code for MACHO and PE/COFF\n\nThis replaces the original and untested support for Windows and OSX, and\nis the 90% of the work needed to support libphobos on those targets.\n\nThe core.thread interface has been updated to accomodate for the same\nfunction might be implemented by any of the platform-dependent modules.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Removed\n\tgcc/sections/android.d, elf_shared.d, osx.d, win32.d, and win64.d.\n\tAdded gcc/sections/common.d, elf.d macho.d, and pecoff.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* libdruntime/core/thread/osthread.d: Update externDFunc FQDN names to\n\tuse platform independant section function names.\n\t* libdruntime/gcc/sections/elf_shared.d: Renamed to...\n\t* libdruntime/gcc/sections/elf.d: ...this.  Mangle functions for\n\tcore.thread interface as if they come from the gcc.sections module.\n\t* libdruntime/gcc/sections/package.d: Update public imports, declare\n\tfunctions for core.thread interface.\n\t* libdruntime/gcc/sections/android.d: Removed.\n\t* libdruntime/gcc/sections/osx.d: Removed.\n\t* libdruntime/gcc/sections/win32.d: Removed.\n\t* libdruntime/gcc/sections/win64.d: Removed.\n\t* libdruntime/gcc/sections/common.d: New file.\n\t* libdruntime/gcc/sections/macho.d: New file.\n\t* libdruntime/gcc/sections/pecoff.d: New file.", "tree": {"sha": "1954456b1d2e6a84ccc6a9846f2211f4fb60d596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1954456b1d2e6a84ccc6a9846f2211f4fb60d596"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32703b80f66f7ca504eb79bee7e745f22cf096a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32703b80f66f7ca504eb79bee7e745f22cf096a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32703b80f66f7ca504eb79bee7e745f22cf096a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32703b80f66f7ca504eb79bee7e745f22cf096a8/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "385ee099eeae53bff5dd5adf673ad4f4b8d22981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385ee099eeae53bff5dd5adf673ad4f4b8d22981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385ee099eeae53bff5dd5adf673ad4f4b8d22981"}], "stats": {"total": 2765, "additions": 1673, "deletions": 1092}, "files": [{"sha": "74a0f006036b765e6efd13fa208f287de1fbe8e9", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -186,18 +186,17 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n \tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n-\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n-\tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n-\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n-\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n-\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n-\trt/switch_.d rt/tlsgc.d rt/util/array.d rt/util/container/array.d \\\n-\trt/util/container/common.d rt/util/container/hashtab.d \\\n-\trt/util/container/treap.d rt/util/random.d rt/util/typeinfo.d \\\n-\trt/util/utf.d\n+\tgcc/sections/common.d gcc/sections/elf.d gcc/sections/macho.d \\\n+\tgcc/sections/package.d gcc/sections/pecoff.d gcc/unwind/arm.d \\\n+\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n+\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n+\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycast.d rt/arraycat.d \\\n+\trt/cast_.d rt/config.d rt/critical_.d rt/deh.d rt/dmain2.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/obj.d rt/qsort.d rt/sections.d rt/switch_.d rt/tlsgc.d \\\n+\trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n+\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n+\trt/util/typeinfo.d rt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d"}, {"sha": "63b2133e69c170b33888ee490985040ae48ffece", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -211,10 +211,9 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tgc/impl/conservative/gc.lo gc/impl/manual/gc.lo gc/os.lo \\\n \tgc/pooltable.lo gc/proxy.lo gcc/attribute.lo gcc/attributes.lo \\\n \tgcc/backtrace.lo gcc/builtins.lo gcc/deh.lo gcc/emutls.lo \\\n-\tgcc/gthread.lo gcc/sections/android.lo \\\n-\tgcc/sections/elf_shared.lo gcc/sections/osx.lo \\\n-\tgcc/sections/package.lo gcc/sections/win32.lo \\\n-\tgcc/sections/win64.lo gcc/unwind/arm.lo \\\n+\tgcc/gthread.lo gcc/sections/common.lo gcc/sections/elf.lo \\\n+\tgcc/sections/macho.lo gcc/sections/package.lo \\\n+\tgcc/sections/pecoff.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n@@ -819,18 +818,17 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n \tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n-\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n-\tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n-\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n-\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n-\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n-\trt/switch_.d rt/tlsgc.d rt/util/array.d rt/util/container/array.d \\\n-\trt/util/container/common.d rt/util/container/hashtab.d \\\n-\trt/util/container/treap.d rt/util/random.d rt/util/typeinfo.d \\\n-\trt/util/utf.d\n+\tgcc/sections/common.d gcc/sections/elf.d gcc/sections/macho.d \\\n+\tgcc/sections/package.d gcc/sections/pecoff.d gcc/unwind/arm.d \\\n+\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n+\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n+\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycast.d rt/arraycat.d \\\n+\trt/cast_.d rt/config.d rt/critical_.d rt/deh.d rt/dmain2.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/obj.d rt/qsort.d rt/sections.d rt/switch_.d rt/tlsgc.d \\\n+\trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n+\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n+\trt/util/typeinfo.d rt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d\n@@ -1219,12 +1217,11 @@ gcc/gthread.lo: gcc/$(am__dirstamp)\n gcc/sections/$(am__dirstamp):\n \t@$(MKDIR_P) gcc/sections\n \t@: > gcc/sections/$(am__dirstamp)\n-gcc/sections/android.lo: gcc/sections/$(am__dirstamp)\n-gcc/sections/elf_shared.lo: gcc/sections/$(am__dirstamp)\n-gcc/sections/osx.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/common.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/elf.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/macho.lo: gcc/sections/$(am__dirstamp)\n gcc/sections/package.lo: gcc/sections/$(am__dirstamp)\n-gcc/sections/win32.lo: gcc/sections/$(am__dirstamp)\n-gcc/sections/win64.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/pecoff.lo: gcc/sections/$(am__dirstamp)\n gcc/unwind/$(am__dirstamp):\n \t@$(MKDIR_P) gcc/unwind\n \t@: > gcc/unwind/$(am__dirstamp)"}, {"sha": "880836e3a2503a53db2144f6a9f3806f1d77c0e8", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -510,7 +510,7 @@ class Thread : ThreadBase\n                 {\n                     version (GNU)\n                     {\n-                        auto libs = externDFunc!(\"gcc.sections.elf_shared.pinLoadedLibraries\",\n+                        auto libs = externDFunc!(\"gcc.sections.pinLoadedLibraries\",\n                                                  void* function() @nogc nothrow)();\n                     }\n                     else\n@@ -527,7 +527,7 @@ class Thread : ThreadBase\n                     {\n                         version (GNU)\n                         {\n-                            externDFunc!(\"gcc.sections.elf_shared.unpinLoadedLibraries\",\n+                            externDFunc!(\"gcc.sections.unpinLoadedLibraries\",\n                                          void function(void*) @nogc nothrow)(libs);\n                         }\n                         else\n@@ -2196,7 +2196,7 @@ else version (Posix)\n             // before initilizing GC for TLS (rt_tlsgc_init)\n             version (GNUShared)\n             {\n-                externDFunc!(\"gcc.sections.elf_shared.inheritLoadedLibraries\",\n+                externDFunc!(\"gcc.sections.inheritLoadedLibraries\",\n                              void function(void*) @nogc nothrow)(loadedLibraries);\n             }\n             else version (Shared)\n@@ -2287,7 +2287,7 @@ else version (Posix)\n                 rt_moduleTlsDtor();\n                 version (GNUShared)\n                 {\n-                    externDFunc!(\"gcc.sections.elf_shared.cleanupLoadedLibraries\",\n+                    externDFunc!(\"gcc.sections.cleanupLoadedLibraries\",\n                                  void function() @nogc nothrow)();\n                 }\n                 else version (Shared)\n@@ -2786,7 +2786,7 @@ private size_t adjustStackSize(size_t sz) nothrow @nogc\n         // On glibc, TLS uses the top of the stack, so add its size to the requested size\n         version (GNU)\n         {\n-            sz += externDFunc!(\"gcc.sections.elf_shared.sizeOfTLS\",\n+            sz += externDFunc!(\"gcc.sections.elf.sizeOfTLS\",\n                                size_t function() @nogc nothrow)();\n         }\n         else"}, {"sha": "4af26b42ffc75d86eb2e9c0f05bb7da4c22dbc5e", "filename": "libphobos/libdruntime/gcc/sections/android.d", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d?ref=385ee099eeae53bff5dd5adf673ad4f4b8d22981", "patch": "@@ -1,184 +0,0 @@\n-// Bionic-specific support for sections.\n-// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-module gcc.sections.android;\n-\n-version (CRuntime_Bionic):\n-\n-// debug = PRINTF;\n-debug(PRINTF) import core.stdc.stdio;\n-import core.stdc.stdlib : malloc, free;\n-import rt.deh, rt.minfo;\n-import core.sys.posix.pthread;\n-import core.stdc.stdlib : calloc;\n-import core.stdc.string : memcpy;\n-\n-struct SectionGroup\n-{\n-    static int opApply(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    static int opApplyReverse(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n-    {\n-        return _moduleGroup.modules;\n-    }\n-\n-    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n-    {\n-        return _moduleGroup;\n-    }\n-\n-    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n-    {\n-        auto pbeg = cast(immutable(FuncTable)*)&__start_deh;\n-        auto pend = cast(immutable(FuncTable)*)&__stop_deh;\n-        return pbeg[0 .. pend - pbeg];\n-    }\n-\n-    @property inout(void[])[] gcRanges() inout nothrow @nogc\n-    {\n-        return _gcRanges[];\n-    }\n-\n-private:\n-    ModuleGroup _moduleGroup;\n-    void[][1] _gcRanges;\n-}\n-\n-void initSections() nothrow @nogc\n-{\n-    pthread_key_create(&_tlsKey, null);\n-\n-    auto mbeg = cast(immutable ModuleInfo**)&__start_minfo;\n-    auto mend = cast(immutable ModuleInfo**)&__stop_minfo;\n-    _sections.moduleGroup = ModuleGroup(mbeg[0 .. mend - mbeg]);\n-\n-    auto pbeg = cast(void*)&_tlsend;\n-    auto pend = cast(void*)&__bss_end__;\n-    // _tlsend is a 32-bit int and may not be 64-bit void*-aligned, so align pbeg.\n-    version (D_LP64) pbeg = cast(void*)(cast(size_t)(pbeg + 7) & ~cast(size_t)7);\n-    _sections._gcRanges[0] = pbeg[0 .. pend - pbeg];\n-}\n-\n-void finiSections() nothrow @nogc\n-{\n-    pthread_key_delete(_tlsKey);\n-}\n-\n-void[]* initTLSRanges() nothrow @nogc\n-{\n-    return &getTLSBlock();\n-}\n-\n-void finiTLSRanges(void[]* rng) nothrow @nogc\n-{\n-    .free(rng.ptr);\n-    .free(rng);\n-}\n-\n-void scanTLSRanges(void[]* rng, scope void delegate(void* pbeg, void* pend) nothrow dg) nothrow\n-{\n-    dg(rng.ptr, rng.ptr + rng.length);\n-}\n-\n-/* NOTE: The Bionic C library ignores thread-local data stored in the normal\n- *       .tbss/.tdata ELF sections, which are marked with the SHF_TLS/STT_TLS\n- *       flags.  So instead we roll our own by keeping TLS data in the\n- *       .tdata/.tbss sections but removing the SHF_TLS/STT_TLS flags, and\n- *       access the TLS data using this function and the _tlsstart/_tlsend\n- *       symbols as delimiters.\n- *\n- *       This function is called by the code emitted by the compiler.  It\n- *       is expected to translate an address in the TLS static data to\n- *       the corresponding address in the TLS dynamic per-thread data.\n- */\n-\n-extern(C) void* __tls_get_addr( void* p ) nothrow @nogc\n-{\n-    debug(PRINTF) printf(\"  __tls_get_addr input - %p\\n\", p);\n-    immutable offset = cast(size_t)(p - cast(void*)&_tlsstart);\n-    auto tls = getTLSBlockAlloc();\n-    assert(offset < tls.length);\n-    return tls.ptr + offset;\n-}\n-\n-private:\n-\n-__gshared pthread_key_t _tlsKey;\n-\n-ref void[] getTLSBlock() nothrow @nogc\n-{\n-    auto pary = cast(void[]*)pthread_getspecific(_tlsKey);\n-    if (pary is null)\n-    {\n-        pary = cast(void[]*).calloc(1, (void[]).sizeof);\n-        if (pthread_setspecific(_tlsKey, pary) != 0)\n-        {\n-            import core.stdc.stdio;\n-            perror(\"pthread_setspecific failed with\");\n-            assert(0);\n-        }\n-    }\n-    return *pary;\n-}\n-\n-ref void[] getTLSBlockAlloc() nothrow @nogc\n-{\n-    auto pary = &getTLSBlock();\n-    if (!pary.length)\n-    {\n-        auto pbeg = cast(void*)&_tlsstart;\n-        auto pend = cast(void*)&_tlsend;\n-        auto p = .malloc(pend - pbeg);\n-        memcpy(p, pbeg, pend - pbeg);\n-        *pary = p[0 .. pend - pbeg];\n-    }\n-    return *pary;\n-}\n-\n-__gshared SectionGroup _sections;\n-\n-extern(C)\n-{\n-    /* Symbols created by the compiler/linker and inserted into the\n-     * object file that 'bracket' sections.\n-     */\n-    extern __gshared\n-    {\n-        void* __start_deh;\n-        void* __stop_deh;\n-        void* __start_minfo;\n-        void* __stop_minfo;\n-\n-        size_t __bss_end__;\n-\n-        int _tlsstart;\n-        int _tlsend;\n-    }\n-}"}, {"sha": "85fdc0efd48ae074898c12c50645465b6d46e71e", "filename": "libphobos/libdruntime/gcc/sections/common.d", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fcommon.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fcommon.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fcommon.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -0,0 +1,39 @@\n+// Contains various utility functions used by the runtime implementation.\n+// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.common;\n+\n+/**\n+ * Asserts that the given condition is `true`.\n+ *\n+ * The assertion is independent from -release, by abort()ing. Regular assertions\n+ * throw an AssertError and thus require an initialized GC, which might not be\n+ * the case (yet or anymore) for the startup/shutdown code in this package\n+ * (called by CRT ctors/dtors etc.).\n+ */\n+package(gcc) void safeAssert(\n+    bool condition, scope string msg, scope string file = __FILE__, size_t line = __LINE__\n+) nothrow @nogc @safe\n+{\n+    import core.internal.abort;\n+    condition || abort(msg, file, line);\n+}"}, {"sha": "8450aecb239feb6c22de415e659b9f868938c7b6", "filename": "libphobos/libdruntime/gcc/sections/elf.d", "status": "renamed", "additions": 11, "deletions": 60, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -20,7 +20,7 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-module gcc.sections.elf_shared;\n+module gcc.sections.elf;\n \n version (MIPS32)  version = MIPS_Any;\n version (MIPS64)  version = MIPS_Any;\n@@ -39,7 +39,6 @@ else version (Solaris) enum SharedELF = true;\n else enum SharedELF = false;\n static if (SharedELF):\n \n-// debug = PRINTF;\n import core.memory;\n import core.stdc.config;\n import core.stdc.stdio;\n@@ -81,25 +80,14 @@ else\n     static assert(0, \"unimplemented\");\n }\n import core.sys.posix.pthread;\n-import gcc.builtins;\n-import gcc.config;\n import rt.deh;\n import rt.dmain2;\n import rt.minfo;\n import rt.util.container.array;\n import rt.util.container.hashtab;\n-\n-/****\n- * Asserts the specified condition, independent from -release, by abort()ing.\n- * Regular assertions throw an AssertError and thus require an initialized\n- * GC, which isn't the case (yet or anymore) for the startup/shutdown code in\n- * this module (called by CRT ctors/dtors etc.).\n- */\n-private void safeAssert(bool condition, scope string msg, size_t line = __LINE__) @nogc nothrow @safe\n-{\n-    import core.internal.abort;\n-    condition || abort(msg, __FILE__, line);\n-}\n+import gcc.builtins;\n+import gcc.config;\n+import gcc.sections.common;\n \n alias DSO SectionGroup;\n struct DSO\n@@ -134,11 +122,6 @@ struct DSO\n         return _moduleGroup;\n     }\n \n-    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n-    {\n-        return null;\n-    }\n-\n     @property inout(void[])[] gcRanges() inout nothrow @nogc\n     {\n         return _gcRanges[];\n@@ -177,22 +160,12 @@ private:\n __gshared bool _isRuntimeInitialized;\n \n \n-version (FreeBSD) private __gshared void* dummy_ref;\n-version (DragonFlyBSD) private __gshared void* dummy_ref;\n-version (NetBSD) private __gshared void* dummy_ref;\n-version (Solaris) private __gshared void* dummy_ref;\n-\n /****\n  * Gets called on program startup just before GC is initialized.\n  */\n void initSections() nothrow @nogc\n {\n     _isRuntimeInitialized = true;\n-    // reference symbol to support weak linkage\n-    version (FreeBSD) dummy_ref = &_d_dso_registry;\n-    version (DragonFlyBSD) dummy_ref = &_d_dso_registry;\n-    version (NetBSD) dummy_ref = &_d_dso_registry;\n-    version (Solaris) dummy_ref = &_d_dso_registry;\n }\n \n \n@@ -208,6 +181,9 @@ alias ScanDG = void delegate(void* pbeg, void* pend) nothrow;\n \n version (Shared)\n {\n+    import gcc.sections : pinLoadedLibraries, unpinLoadedLibraries,\n+           inheritLoadedLibraries, cleanupLoadedLibraries;\n+\n     /***\n      * Called once per thread; returns array of thread local storage ranges\n      */\n@@ -248,6 +224,7 @@ version (Shared)\n     }\n \n     // interface for core.thread to inherit loaded libraries\n+    pragma(mangle, gcc.sections.pinLoadedLibraries.mangleof)\n     void* pinLoadedLibraries() nothrow @nogc\n     {\n         auto res = cast(Array!(ThreadDSO)*)calloc(1, Array!(ThreadDSO).sizeof);\n@@ -266,6 +243,7 @@ version (Shared)\n         return res;\n     }\n \n+    pragma(mangle, gcc.sections.unpinLoadedLibraries.mangleof)\n     void unpinLoadedLibraries(void* p) nothrow @nogc\n     {\n         auto pary = cast(Array!(ThreadDSO)*)p;\n@@ -285,6 +263,7 @@ version (Shared)\n \n     // Called before TLS ctors are ran, copy over the loaded libraries\n     // of the parent thread.\n+    pragma(mangle, gcc.sections.inheritLoadedLibraries.mangleof)\n     void inheritLoadedLibraries(void* p) nothrow @nogc\n     {\n         safeAssert(_loadedDSOs.empty, \"DSOs have already been registered for this thread.\");\n@@ -298,6 +277,7 @@ version (Shared)\n     }\n \n     // Called after all TLS dtors ran, decrements all remaining dlopen refs.\n+    pragma(mangle, gcc.sections.cleanupLoadedLibraries.mangleof)\n     void cleanupLoadedLibraries() nothrow @nogc\n     {\n         foreach (ref tdso; _loadedDSOs)\n@@ -403,12 +383,6 @@ version (Shared)\n      */\n     __gshared pthread_mutex_t _handleToDSOMutex;\n     @property ref HashTab!(void*, DSO*) _handleToDSO() @nogc nothrow { __gshared HashTab!(void*, DSO*) x; return x; }\n-\n-    /*\n-     * Section in executable that contains copy relocations.\n-     * Might be null when druntime is dynamically loaded by a C host.\n-     */\n-    __gshared const(void)[] _copyRelocSection;\n }\n else\n {\n@@ -976,29 +950,6 @@ bool findSegmentForAddr(in ref dl_phdr_info info, in void* addr, ElfW!\"Phdr\"* re\n     return false;\n }\n \n-version (linux) import core.sys.linux.errno : program_invocation_name;\n-// should be in core.sys.freebsd.stdlib\n-version (FreeBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n-version (DragonFlyBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n-version (NetBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n-version (Solaris) extern(C) const(char)* getprogname() nothrow @nogc;\n-\n-@property const(char)* progname() nothrow @nogc\n-{\n-    version (linux) return program_invocation_name;\n-    version (FreeBSD) return getprogname();\n-    version (DragonFlyBSD) return getprogname();\n-    version (NetBSD) return getprogname();\n-    version (Solaris) return getprogname();\n-}\n-\n-const(char)[] dsoName(const char* dlpi_name) nothrow @nogc\n-{\n-    // the main executable doesn't have a name in its dlpi_name field\n-    const char* p = dlpi_name[0] != 0 ? dlpi_name : progname;\n-    return p[0 .. strlen(p)];\n-}\n-\n /**************************\n  * Input:\n  *      addr  an internal address of a DSO", "previous_filename": "libphobos/libdruntime/gcc/sections/elf_shared.d"}, {"sha": "3ce58a533c372fc9b5accbbcfe643b3ad1d38c69", "filename": "libphobos/libdruntime/gcc/sections/macho.d", "status": "added", "additions": 738, "deletions": 0, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fmacho.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fmacho.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fmacho.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -0,0 +1,738 @@\n+// MACHO-specific support for sections.\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.macho;\n+\n+version (OSX):\n+\n+import core.memory;\n+import core.stdc.stdlib;\n+import core.sys.darwin.dlfcn;\n+import core.sys.darwin.mach.dyld;\n+import core.sys.darwin.mach.getsect;\n+import core.sys.posix.pthread;\n+import rt.minfo;\n+import rt.util.container.array;\n+import rt.util.container.hashtab;\n+import gcc.sections.common;\n+\n+version (GNU_EMUTLS)\n+    import gcc.emutls;\n+\n+alias DSO SectionGroup;\n+struct DSO\n+{\n+    static int opApply(scope int delegate(ref DSO) dg)\n+    {\n+        foreach (dso; _loadedDSOs)\n+        {\n+            if (auto res = dg(*dso))\n+                return res;\n+        }\n+        return 0;\n+    }\n+\n+    static int opApplyReverse(scope int delegate(ref DSO) dg)\n+    {\n+        foreach_reverse (dso; _loadedDSOs)\n+        {\n+            if (auto res = dg(*dso))\n+                return res;\n+        }\n+        return 0;\n+    }\n+\n+    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n+    {\n+        return _moduleGroup.modules;\n+    }\n+\n+    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n+    {\n+        return _moduleGroup;\n+    }\n+\n+    @property inout(void[])[] gcRanges() inout nothrow @nogc\n+    {\n+        return _gcRanges[];\n+    }\n+\n+private:\n+\n+    invariant()\n+    {\n+        safeAssert(_moduleGroup.modules.length > 0, \"No modules for DSO.\");\n+    }\n+\n+    void** _slot;\n+    ModuleGroup _moduleGroup;\n+    Array!(void[]) _gcRanges;\n+\n+    version (Shared)\n+    {\n+        Array!(void[]) _codeSegments; // array of code segments\n+        Array!(DSO*) _deps; // D libraries needed by this DSO\n+        void* _handle; // corresponding handle\n+    }\n+}\n+\n+/****\n+ * Boolean flag set to true while the runtime is initialized.\n+ */\n+__gshared bool _isRuntimeInitialized;\n+\n+/****\n+ * Gets called on program startup just before GC is initialized.\n+ */\n+void initSections() nothrow @nogc\n+{\n+    _isRuntimeInitialized = true;\n+}\n+\n+/***\n+ * Gets called on program shutdown just after GC is terminated.\n+ */\n+void finiSections() nothrow @nogc\n+{\n+    _isRuntimeInitialized = false;\n+}\n+\n+alias ScanDG = void delegate(void* pbeg, void* pend) nothrow;\n+\n+version (Shared)\n+{\n+    import gcc.sections : pinLoadedLibraries, unpinLoadedLibraries,\n+           inheritLoadedLibraries, cleanupLoadedLibraries;\n+\n+    /***\n+     * Called once per thread; returns array of thread local storage ranges\n+     */\n+    Array!(ThreadDSO)* initTLSRanges() @nogc nothrow\n+    {\n+        return &_loadedDSOs();\n+    }\n+\n+    void finiTLSRanges(Array!(ThreadDSO)* tdsos) @nogc nothrow\n+    {\n+        // Nothing to do here. tdsos used to point to the _loadedDSOs instance\n+        // in the dying thread's TLS segment and as such is not valid anymore.\n+        // The memory for the array contents was already reclaimed in\n+        // cleanupLoadedLibraries().\n+    }\n+\n+    void scanTLSRanges(Array!(ThreadDSO)* tdsos, scope ScanDG dg) nothrow\n+    {\n+        version (GNU_EMUTLS)\n+            _d_emutls_scan(dg);\n+        else\n+            static assert(0, \"Native TLS unimplemented\");\n+    }\n+\n+    // interface for core.thread to inherit loaded libraries\n+    pragma(mangle, gcc.sections.pinLoadedLibraries.mangleof)\n+    void* pinLoadedLibraries() nothrow @nogc\n+    {\n+        auto res = cast(Array!(ThreadDSO)*)calloc(1, Array!(ThreadDSO).sizeof);\n+        res.length = _loadedDSOs.length;\n+        foreach (i, ref tdso; _loadedDSOs)\n+        {\n+            (*res)[i] = tdso;\n+            if (tdso._addCnt)\n+            {\n+                // Increment the dlopen ref for explicitly loaded libraries to pin them.\n+                const success = .dlopen(nameForDSO(tdso._pdso), RTLD_LAZY) !is null;\n+                safeAssert(success, \"Failed to increment dlopen ref.\");\n+                (*res)[i]._addCnt = 1; // new array takes over the additional ref count\n+            }\n+        }\n+        return res;\n+    }\n+\n+    pragma(mangle, gcc.sections.unpinLoadedLibraries.mangleof)\n+    void unpinLoadedLibraries(void* p) nothrow @nogc\n+    {\n+        auto pary = cast(Array!(ThreadDSO)*)p;\n+        // In case something failed we need to undo the pinning.\n+        foreach (ref tdso; *pary)\n+        {\n+            if (tdso._addCnt)\n+            {\n+                auto handle = tdso._pdso._handle;\n+                safeAssert(handle !is null, \"Invalid library handle.\");\n+                .dlclose(handle);\n+            }\n+        }\n+        pary.reset();\n+        .free(pary);\n+    }\n+\n+    // Called before TLS ctors are ran, copy over the loaded libraries\n+    // of the parent thread.\n+    pragma(mangle, gcc.sections.inheritLoadedLibraries.mangleof)\n+    void inheritLoadedLibraries(void* p) nothrow @nogc\n+    {\n+        safeAssert(_loadedDSOs.empty, \"DSOs have already been registered for this thread.\");\n+        _loadedDSOs.swap(*cast(Array!(ThreadDSO)*)p);\n+        .free(p);\n+    }\n+\n+    // Called after all TLS dtors ran, decrements all remaining dlopen refs.\n+    pragma(mangle, gcc.sections.cleanupLoadedLibraries.mangleof)\n+    void cleanupLoadedLibraries() nothrow @nogc\n+    {\n+        foreach (ref tdso; _loadedDSOs)\n+        {\n+            if (tdso._addCnt == 0) continue;\n+\n+            auto handle = tdso._pdso._handle;\n+            safeAssert(handle !is null, \"Invalid DSO handle.\");\n+            for (; tdso._addCnt > 0; --tdso._addCnt)\n+                .dlclose(handle);\n+        }\n+\n+        // Free the memory for the array contents.\n+        _loadedDSOs.reset();\n+    }\n+}\n+else\n+{\n+    /***\n+     * Called once per thread; returns array of thread local storage ranges\n+     */\n+    Array!(void[])* initTLSRanges() nothrow @nogc\n+    {\n+        return null;\n+    }\n+\n+    void finiTLSRanges(Array!(void[])* rngs) nothrow @nogc\n+    {\n+    }\n+\n+    void scanTLSRanges(Array!(void[])* rngs, scope ScanDG dg) nothrow\n+    {\n+        version (GNU_EMUTLS)\n+            _d_emutls_scan(dg);\n+        else\n+            static assert(0, \"Native TLS unimplemented\");\n+    }\n+}\n+\n+private:\n+\n+version (Shared)\n+{\n+    /*\n+     * Array of thread local DSO metadata for all libraries loaded and\n+     * initialized in this thread.\n+     *\n+     * Note:\n+     *     A newly spawned thread will inherit these libraries.\n+     * Note:\n+     *     We use an array here to preserve the order of\n+     *     initialization.  If that became a performance issue, we\n+     *     could use a hash table and enumerate the DSOs during\n+     *     loading so that the hash table values could be sorted when\n+     *     necessary.\n+     */\n+    struct ThreadDSO\n+    {\n+        DSO* _pdso;\n+        static if (_pdso.sizeof == 8) uint _refCnt, _addCnt;\n+        else static if (_pdso.sizeof == 4) ushort _refCnt, _addCnt;\n+        else static assert(0, \"unimplemented\");\n+        alias _pdso this;\n+    }\n+\n+    @property ref Array!(ThreadDSO) _loadedDSOs() @nogc nothrow\n+    {\n+        static Array!(ThreadDSO) x;\n+        return x;\n+    }\n+\n+    /*\n+     * Set to true during rt_loadLibrary/rt_unloadLibrary calls.\n+     */\n+    bool _rtLoading;\n+\n+    /*\n+     * Hash table to map the native handle (as returned by dlopen)\n+     * to the corresponding DSO*, protected by a mutex.\n+     */\n+    __gshared pthread_mutex_t _handleToDSOMutex;\n+    @property ref HashTab!(void*, DSO*) _handleToDSO() @nogc nothrow\n+    {\n+        __gshared HashTab!(void*, DSO*) x;\n+        return x;\n+    }\n+}\n+else\n+{\n+    /*\n+     * Static DSOs loaded by the runtime linker. This includes the\n+     * executable. These can't be unloaded.\n+     */\n+    @property ref Array!(DSO*) _loadedDSOs() @nogc nothrow\n+    {\n+        __gshared Array!(DSO*) x;\n+        return x;\n+    }\n+\n+    enum _rtLoading = false;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Compiler to runtime interface.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct MachHeader\n+{\n+    const(mach_header)* header; // the mach header of the image\n+    intptr_t slide;             // virtural memory address slide amount\n+}\n+\n+/****\n+ * This data structure is generated by the compiler, and then passed to\n+ * _d_dso_registry().\n+ */\n+struct CompilerDSOData\n+{\n+    size_t _version;                                       // currently 1\n+    void** _slot;                                          // can be used to store runtime data\n+    immutable(object.ModuleInfo*)* _minfo_beg, _minfo_end; // array of modules in this object file\n+}\n+\n+T[] toRange(T)(T* beg, T* end) { return beg[0 .. end - beg]; }\n+\n+/* For each shared library and executable, the compiler generates code that\n+ * sets up CompilerDSOData and calls _d_dso_registry().\n+ * A pointer to that code is inserted into both the .ctors and .dtors\n+ * segment so it gets called by the loader on startup and shutdown.\n+ */\n+extern(C) void _d_dso_registry(CompilerDSOData* data)\n+{\n+    // only one supported currently\n+    safeAssert(data._version >= 1, \"Incompatible compiler-generated DSO data version.\");\n+\n+    // no backlink => register\n+    if (*data._slot is null)\n+    {\n+        immutable firstDSO = _loadedDSOs.empty;\n+        if (firstDSO) initLocks();\n+\n+        DSO* pdso = cast(DSO*).calloc(1, DSO.sizeof);\n+        assert(typeid(DSO).initializer().ptr is null);\n+        pdso._slot = data._slot;\n+        *data._slot = pdso; // store backlink in library record\n+\n+        pdso._moduleGroup = ModuleGroup(toRange(data._minfo_beg, data._minfo_end));\n+\n+        MachHeader header = void;\n+        const headerFound = findImageHeaderForAddr(data._slot, header);\n+        safeAssert(headerFound, \"Failed to find image header.\");\n+\n+        scanSegments(header, pdso);\n+\n+        version (Shared)\n+        {\n+            auto handle = handleForAddr(data._slot);\n+\n+            getDependencies(header, pdso._deps);\n+            pdso._handle = handle;\n+            setDSOForHandle(pdso, pdso._handle);\n+\n+            if (!_rtLoading)\n+            {\n+                /* This DSO was not loaded by rt_loadLibrary which\n+                 * happens for all dependencies of an executable or\n+                 * the first dlopen call from a C program.\n+                 * In this case we add the DSO to the _loadedDSOs of this\n+                 * thread with a refCnt of 1 and call the TlsCtors.\n+                 */\n+                immutable ushort refCnt = 1, addCnt = 0;\n+                _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt));\n+            }\n+        }\n+        else\n+        {\n+            foreach (p; _loadedDSOs)\n+                safeAssert(p !is pdso, \"DSO already registered.\");\n+            _loadedDSOs.insertBack(pdso);\n+        }\n+\n+        // don't initialize modules before rt_init was called\n+        if (_isRuntimeInitialized)\n+        {\n+            registerGCRanges(pdso);\n+            // rt_loadLibrary will run tls ctors, so do this only for dlopen\n+            immutable runTlsCtors = !_rtLoading;\n+            runModuleConstructors(pdso, runTlsCtors);\n+        }\n+    }\n+    // has backlink => unregister\n+    else\n+    {\n+        DSO* pdso = cast(DSO*)*data._slot;\n+        *data._slot = null;\n+\n+        // don't finalizes modules after rt_term was called (see Bugzilla 11378)\n+        if (_isRuntimeInitialized)\n+        {\n+            // rt_unloadLibrary already ran tls dtors, so do this only for dlclose\n+            immutable runTlsDtors = !_rtLoading;\n+            runModuleDestructors(pdso, runTlsDtors);\n+            unregisterGCRanges(pdso);\n+            // run finalizers after module dtors (same order as in rt_term)\n+            version (Shared) runFinalizers(pdso);\n+        }\n+\n+        version (Shared)\n+        {\n+            if (!_rtLoading)\n+            {\n+                /* This DSO was not unloaded by rt_unloadLibrary so we\n+                 * have to remove it from _loadedDSOs here.\n+                 */\n+                foreach (i, ref tdso; _loadedDSOs)\n+                {\n+                    if (tdso._pdso == pdso)\n+                    {\n+                        _loadedDSOs.remove(i);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            unsetDSOForHandle(pdso, pdso._handle);\n+        }\n+        else\n+        {\n+            // static DSOs are unloaded in reverse order\n+            safeAssert(pdso == _loadedDSOs.back, \"DSO being unregistered isn't current last one.\");\n+            _loadedDSOs.popBack();\n+        }\n+\n+        freeDSO(pdso);\n+\n+        // last DSO being unloaded => shutdown registry\n+        if (_loadedDSOs.empty)\n+        {\n+            version (GNU_EMUTLS)\n+                _d_emutls_destroy();\n+            version (Shared)\n+            {\n+                safeAssert(_handleToDSO.empty, \"_handleToDSO not in sync with _loadedDSOs.\");\n+                _handleToDSO.reset();\n+            }\n+            finiLocks();\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// dynamic loading\n+///////////////////////////////////////////////////////////////////////////////\n+\n+// Shared D libraries are only supported when linking against a shared druntime library.\n+\n+version (Shared)\n+{\n+    ThreadDSO* findThreadDSO(DSO* pdso) nothrow @nogc\n+    {\n+        foreach (ref tdata; _loadedDSOs)\n+            if (tdata._pdso == pdso) return &tdata;\n+        return null;\n+    }\n+\n+    void incThreadRef(DSO* pdso, bool incAdd)\n+    {\n+        if (auto tdata = findThreadDSO(pdso)) // already initialized\n+        {\n+            if (incAdd && ++tdata._addCnt > 1) return;\n+            ++tdata._refCnt;\n+        }\n+        else\n+        {\n+            foreach (dep; pdso._deps)\n+                incThreadRef(dep, false);\n+            immutable ushort refCnt = 1, addCnt = incAdd ? 1 : 0;\n+            _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt));\n+            pdso._moduleGroup.runTlsCtors();\n+        }\n+    }\n+\n+    void decThreadRef(DSO* pdso, bool decAdd)\n+    {\n+        auto tdata = findThreadDSO(pdso);\n+        safeAssert(tdata !is null, \"Failed to find thread DSO.\");\n+        safeAssert(!decAdd || tdata._addCnt > 0, \"Mismatching rt_unloadLibrary call.\");\n+\n+        if (decAdd && --tdata._addCnt > 0) return;\n+        if (--tdata._refCnt > 0) return;\n+\n+        pdso._moduleGroup.runTlsDtors();\n+        foreach (i, ref td; _loadedDSOs)\n+            if (td._pdso == pdso) _loadedDSOs.remove(i);\n+        foreach (dep; pdso._deps)\n+            decThreadRef(dep, false);\n+    }\n+\n+    extern(C) void* rt_loadLibrary(const char* name)\n+    {\n+        immutable save = _rtLoading;\n+        _rtLoading = true;\n+        scope (exit) _rtLoading = save;\n+\n+        auto handle = .dlopen(name, RTLD_LAZY);\n+        if (handle is null) return null;\n+\n+        // if it's a D library\n+        if (auto pdso = dsoForHandle(handle))\n+            incThreadRef(pdso, true);\n+        return handle;\n+    }\n+\n+    extern(C) int rt_unloadLibrary(void* handle)\n+    {\n+        if (handle is null) return false;\n+\n+        immutable save = _rtLoading;\n+        _rtLoading = true;\n+        scope (exit) _rtLoading = save;\n+\n+        // if it's a D library\n+        if (auto pdso = dsoForHandle(handle))\n+            decThreadRef(pdso, true);\n+        return .dlclose(handle) == 0;\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// helper functions\n+///////////////////////////////////////////////////////////////////////////////\n+\n+void initLocks() nothrow @nogc\n+{\n+    version (Shared)\n+        !pthread_mutex_init(&_handleToDSOMutex, null) || assert(0);\n+}\n+\n+void finiLocks() nothrow @nogc\n+{\n+    version (Shared)\n+        !pthread_mutex_destroy(&_handleToDSOMutex) || assert(0);\n+}\n+\n+void runModuleConstructors(DSO* pdso, bool runTlsCtors)\n+{\n+    pdso._moduleGroup.sortCtors();\n+    pdso._moduleGroup.runCtors();\n+    if (runTlsCtors) pdso._moduleGroup.runTlsCtors();\n+}\n+\n+void runModuleDestructors(DSO* pdso, bool runTlsDtors)\n+{\n+    if (runTlsDtors) pdso._moduleGroup.runTlsDtors();\n+    pdso._moduleGroup.runDtors();\n+}\n+\n+void registerGCRanges(DSO* pdso) nothrow @nogc\n+{\n+    foreach (rng; pdso._gcRanges)\n+        GC.addRange(rng.ptr, rng.length);\n+}\n+\n+void unregisterGCRanges(DSO* pdso) nothrow @nogc\n+{\n+    foreach (rng; pdso._gcRanges)\n+        GC.removeRange(rng.ptr);\n+}\n+\n+version (Shared) void runFinalizers(DSO* pdso)\n+{\n+    foreach (seg; pdso._codeSegments)\n+        GC.runFinalizers(seg);\n+}\n+\n+void freeDSO(DSO* pdso) nothrow @nogc\n+{\n+    pdso._gcRanges.reset();\n+    version (Shared)\n+    {\n+        pdso._codeSegments.reset();\n+        pdso._deps.reset();\n+        pdso._handle = null;\n+    }\n+    .free(pdso);\n+}\n+\n+version (Shared)\n+{\n+@nogc nothrow:\n+    const(char)* nameForDSO(in DSO* pdso)\n+    {\n+        Dl_info info = void;\n+        const success = dladdr(pdso._slot, &info) != 0;\n+        safeAssert(success, \"Failed to get DSO info.\");\n+        return info.dli_fname;\n+    }\n+\n+    DSO* dsoForHandle(void* handle)\n+    {\n+        DSO* pdso;\n+        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n+        if (auto ppdso = handle in _handleToDSO)\n+            pdso = *ppdso;\n+        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n+        return pdso;\n+    }\n+\n+    void setDSOForHandle(DSO* pdso, void* handle)\n+    {\n+        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n+        safeAssert(handle !in _handleToDSO, \"DSO already registered.\");\n+        _handleToDSO[handle] = pdso;\n+        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n+    }\n+\n+    void unsetDSOForHandle(DSO* pdso, void* handle)\n+    {\n+        !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n+        safeAssert(_handleToDSO[handle] == pdso, \"Handle doesn't match registered DSO.\");\n+        _handleToDSO.remove(handle);\n+        !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n+    }\n+\n+    void getDependencies(in MachHeader info, ref Array!(DSO*) deps)\n+    {\n+        // FIXME: Not implemented yet.\n+    }\n+\n+    void* handleForName(const char* name)\n+    {\n+        auto handle = .dlopen(name, RTLD_NOLOAD | RTLD_LAZY);\n+        if (handle !is null) .dlclose(handle); // drop reference count\n+        return handle;\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Mach-O program header iteration\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/************\n+ * Scan segments in the image header and store\n+ * the writeable data segments in *pdso.\n+ */\n+\n+void scanSegments(in MachHeader info, DSO* pdso)\n+{\n+    foreach (e; dataSegs)\n+    {\n+        auto sect = getSection(info.header, info.slide, e.seg.ptr, e.sect.ptr);\n+        if (sect != null)\n+            pdso._gcRanges.insertBack((cast(void*)sect.ptr)[0 .. sect.length]);\n+    }\n+\n+    version (Shared)\n+    {\n+        void[] text = getSection(info.header, info.slide, \"__TEXT\", \"__text\");\n+        if (!text)\n+            assert(0, \"Failed to get text section.\");\n+        pdso._codeSegments.insertBack(text);\n+    }\n+}\n+\n+/**************************\n+ * Input:\n+ *      result where the output is to be written\n+ * Returns:\n+ *      true if found, and *result is filled in\n+ */\n+\n+bool findImageHeaderForAddr(in void* addr, out MachHeader result)\n+{\n+    Dl_info info;\n+    if (dladdr(addr, &info) == 0)\n+        return false;\n+\n+    foreach (i; 0 .. _dyld_image_count())\n+    {\n+        if (info.dli_fbase == _dyld_get_image_header(i))\n+        {\n+            result.header = cast(const(mach_header)*)info.dli_fbase;\n+            result.slide = _dyld_get_image_vmaddr_slide(i);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**************************\n+ * Input:\n+ *      addr  an internal address of a DSO\n+ * Returns:\n+ *      the dlopen handle for that DSO or null if addr is not within a loaded DSO\n+ */\n+version (Shared) void* handleForAddr(void* addr) nothrow @nogc\n+{\n+    Dl_info info = void;\n+    if (dladdr(addr, &info) != 0)\n+        return handleForName(info.dli_fname);\n+    return null;\n+}\n+\n+struct SegRef\n+{\n+    string seg;\n+    string sect;\n+}\n+\n+static immutable SegRef[] dataSegs = [{SEG_DATA, SECT_DATA},\n+                                      {SEG_DATA, SECT_BSS},\n+                                      {SEG_DATA, SECT_COMMON}];\n+\n+/**\n+ * Returns the section for the named section in the named segment\n+ * for the mach_header pointer passed, or null if not found.\n+ */\n+ubyte[] getSection(in mach_header* header, intptr_t slide,\n+                   in char* segmentName, in char* sectionName)\n+{\n+    version (D_LP64)\n+    {\n+        assert(header.magic == MH_MAGIC_64);\n+        auto sect = getsectbynamefromheader_64(cast(mach_header_64*)header,\n+                                            segmentName,\n+                                            sectionName);\n+    }\n+    else\n+    {\n+        assert(header.magic == MH_MAGIC);\n+        auto sect = getsectbynamefromheader(header,\n+                                            segmentName,\n+                                            sectionName);\n+    }\n+\n+    if (sect !is null && sect.size > 0)\n+        return (cast(ubyte*)sect.addr + slide)[0 .. cast(size_t)sect.size];\n+    return null;\n+}"}, {"sha": "3e3db70e4b8a2483043bf59fac5bd50cb7520578", "filename": "libphobos/libdruntime/gcc/sections/osx.d", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d?ref=385ee099eeae53bff5dd5adf673ad4f4b8d22981", "patch": "@@ -1,284 +0,0 @@\n-// OSX-specific support for sections.\n-// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-module gcc.sections.osx;\n-\n-version (OSX):\n-\n-// debug = PRINTF;\n-import core.stdc.stdio;\n-import core.stdc.string, core.stdc.stdlib;\n-import core.sys.posix.pthread;\n-import core.sys.darwin.mach.dyld;\n-import core.sys.darwin.mach.getsect;\n-import rt.deh, rt.minfo;\n-import rt.util.container.array;\n-\n-struct SectionGroup\n-{\n-    static int opApply(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    static int opApplyReverse(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n-    {\n-        return _moduleGroup.modules;\n-    }\n-\n-    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n-    {\n-        return _moduleGroup;\n-    }\n-\n-    @property inout(void[])[] gcRanges() inout nothrow @nogc\n-    {\n-        return _gcRanges[];\n-    }\n-\n-    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n-    {\n-        return _ehTables[];\n-    }\n-\n-private:\n-    immutable(FuncTable)[] _ehTables;\n-    ModuleGroup _moduleGroup;\n-    Array!(void[]) _gcRanges;\n-    immutable(void)[][2] _tlsImage;\n-}\n-\n-/****\n- * Boolean flag set to true while the runtime is initialized.\n- */\n-__gshared bool _isRuntimeInitialized;\n-\n-/****\n- * Gets called on program startup just before GC is initialized.\n- */\n-void initSections() nothrow @nogc\n-{\n-    pthread_key_create(&_tlsKey, null);\n-    _dyld_register_func_for_add_image(&sections_osx_onAddImage);\n-    _isRuntimeInitialized = true;\n-}\n-\n-/***\n- * Gets called on program shutdown just after GC is terminated.\n- */\n-void finiSections() nothrow @nogc\n-{\n-    _sections._gcRanges.reset();\n-    pthread_key_delete(_tlsKey);\n-    _isRuntimeInitialized = false;\n-}\n-\n-void[]* initTLSRanges() nothrow @nogc\n-{\n-    return &getTLSBlock();\n-}\n-\n-void finiTLSRanges(void[]* rng) nothrow @nogc\n-{\n-    .free(rng.ptr);\n-    .free(rng);\n-}\n-\n-void scanTLSRanges(void[]* rng, scope void delegate(void* pbeg, void* pend) nothrow dg) nothrow\n-{\n-    dg(rng.ptr, rng.ptr + rng.length);\n-}\n-\n-// NOTE: The Mach-O object file format does not allow for thread local\n-//       storage declarations. So instead we roll our own by putting tls\n-//       into the __tls_data and the __tlscoal_nt sections.\n-//\n-//       This function is called by the code emitted by the compiler.  It\n-//       is expected to translate an address into the TLS static data to\n-//       the corresponding address in the TLS dynamic per-thread data.\n-\n-// NB: the compiler mangles this function as '___tls_get_addr' even though it is extern(D)\n-extern(D) void* ___tls_get_addr( void* p )\n-{\n-    immutable off = tlsOffset(p);\n-    auto tls = getTLSBlockAlloc();\n-    assert(off < tls.length);\n-    return tls.ptr + off;\n-}\n-\n-private:\n-\n-__gshared pthread_key_t _tlsKey;\n-\n-size_t tlsOffset(void* p)\n-in\n-{\n-    assert(_sections._tlsImage[0].ptr !is null ||\n-           _sections._tlsImage[1].ptr !is null);\n-}\n-body\n-{\n-    // NOTE: p is an address in the TLS static data emitted by the\n-    //       compiler.  If it isn't, something is disastrously wrong.\n-    immutable off0 = cast(size_t)(p - _sections._tlsImage[0].ptr);\n-    if (off0 < _sections._tlsImage[0].length)\n-    {\n-        return off0;\n-    }\n-    immutable off1 = cast(size_t)(p - _sections._tlsImage[1].ptr);\n-    if (off1 < _sections._tlsImage[1].length)\n-    {\n-        size_t sz = (_sections._tlsImage[0].length + 15) & ~cast(size_t)15;\n-        return sz + off1;\n-    }\n-    assert(0);\n-}\n-\n-ref void[] getTLSBlock() nothrow @nogc\n-{\n-    auto pary = cast(void[]*)pthread_getspecific(_tlsKey);\n-    if (pary is null)\n-    {\n-        pary = cast(void[]*).calloc(1, (void[]).sizeof);\n-        if (pthread_setspecific(_tlsKey, pary) != 0)\n-        {\n-            import core.stdc.stdio;\n-            perror(\"pthread_setspecific failed with\");\n-            assert(0);\n-        }\n-    }\n-    return *pary;\n-}\n-\n-ref void[] getTLSBlockAlloc()\n-{\n-    auto pary = &getTLSBlock();\n-    if (!pary.length)\n-    {\n-        auto imgs = _sections._tlsImage;\n-        immutable sz0 = (imgs[0].length + 15) & ~cast(size_t)15;\n-        immutable sz2 = sz0 + imgs[1].length;\n-        auto p = .malloc(sz2);\n-        memcpy(p, imgs[0].ptr, imgs[0].length);\n-        memcpy(p + sz0, imgs[1].ptr, imgs[1].length);\n-        *pary = p[0 .. sz2];\n-    }\n-    return *pary;\n-}\n-\n-__gshared SectionGroup _sections;\n-\n-extern (C) void sections_osx_onAddImage(in mach_header* h, intptr_t slide)\n-{\n-    foreach (e; dataSegs)\n-    {\n-        auto sect = getSection(h, slide, e.seg.ptr, e.sect.ptr);\n-        if (sect != null)\n-            _sections._gcRanges.insertBack((cast(void*)sect.ptr)[0 .. sect.length]);\n-    }\n-\n-    auto minfosect = getSection(h, slide, \"__DATA\", \"__minfodata\");\n-    if (minfosect != null)\n-    {\n-        // no support for multiple images yet\n-        // take the sections from the last static image which is the executable\n-        if (_isRuntimeInitialized)\n-        {\n-            fprintf(stderr, \"Loading shared libraries isn't yet supported on OSX.\\n\");\n-            return;\n-        }\n-        else if (_sections.modules.ptr !is null)\n-        {\n-            fprintf(stderr, \"Shared libraries are not yet supported on OSX.\\n\");\n-        }\n-\n-        debug(PRINTF) printf(\"  minfodata\\n\");\n-        auto p = cast(immutable(ModuleInfo*)*)minfosect.ptr;\n-        immutable len = minfosect.length / (*p).sizeof;\n-\n-        _sections._moduleGroup = ModuleGroup(p[0 .. len]);\n-    }\n-\n-    auto ehsect = getSection(h, slide, \"__DATA\", \"__deh_eh\");\n-    if (ehsect != null)\n-    {\n-        debug(PRINTF) printf(\"  deh_eh\\n\");\n-        auto p = cast(immutable(FuncTable)*)ehsect.ptr;\n-        immutable len = ehsect.length / (*p).sizeof;\n-\n-        _sections._ehTables = p[0 .. len];\n-    }\n-\n-    auto tlssect = getSection(h, slide, \"__DATA\", \"__tls_data\");\n-    if (tlssect != null)\n-    {\n-        debug(PRINTF) printf(\"  tls_data %p %p\\n\", tlssect.ptr, tlssect.ptr + tlssect.length);\n-        _sections._tlsImage[0] = (cast(immutable(void)*)tlssect.ptr)[0 .. tlssect.length];\n-    }\n-\n-    auto tlssect2 = getSection(h, slide, \"__DATA\", \"__tlscoal_nt\");\n-    if (tlssect2 != null)\n-    {\n-        debug(PRINTF) printf(\"  tlscoal_nt %p %p\\n\", tlssect2.ptr, tlssect2.ptr + tlssect2.length);\n-        _sections._tlsImage[1] = (cast(immutable(void)*)tlssect2.ptr)[0 .. tlssect2.length];\n-    }\n-}\n-\n-struct SegRef\n-{\n-    string seg;\n-    string sect;\n-}\n-\n-static immutable SegRef[] dataSegs = [{SEG_DATA, SECT_DATA},\n-                                      {SEG_DATA, SECT_BSS},\n-                                      {SEG_DATA, SECT_COMMON}];\n-\n-ubyte[] getSection(in mach_header* header, intptr_t slide,\n-                   in char* segmentName, in char* sectionName)\n-{\n-    version (X86)\n-    {\n-        assert(header.magic == MH_MAGIC);\n-        auto sect = getsectbynamefromheader(header,\n-                                            segmentName,\n-                                            sectionName);\n-    }\n-    else version (X86_64)\n-    {\n-        assert(header.magic == MH_MAGIC_64);\n-        auto sect = getsectbynamefromheader_64(cast(mach_header_64*)header,\n-                                            segmentName,\n-                                            sectionName);\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-\n-    if (sect !is null && sect.size > 0)\n-        return (cast(ubyte*)sect.addr + slide)[0 .. cast(size_t)sect.size];\n-    return null;\n-}"}, {"sha": "4c2b542df2386d00eceb44ddb34b34aba355ba0d", "filename": "libphobos/libdruntime/gcc/sections/package.d", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -22,27 +22,30 @@\n \n module gcc.sections;\n \n-version (CRuntime_Glibc)\n-    public import gcc.sections.elf_shared;\n-else version (CRuntime_Musl)\n-    public import gcc.sections.elf_shared;\n-else version (CRuntime_UClibc)\n-    public import gcc.sections.elf_shared;\n-else version (FreeBSD)\n-    public import gcc.sections.elf_shared;\n-else version (NetBSD)\n-    public import gcc.sections.elf_shared;\n-else version (DragonFlyBSD)\n-    public import gcc.sections.elf_shared;\n-else version (Solaris)\n-    public import gcc.sections.elf_shared;\n-else version (OSX)\n-    public import gcc.sections.osx;\n-else version (CRuntime_DigitalMars)\n-    public import gcc.sections.win32;\n-else version (CRuntime_Microsoft)\n-    public import gcc.sections.win64;\n-else version (CRuntime_Bionic)\n-    public import gcc.sections.android;\n+version (CRuntime_Glibc)  version = SectionsElf;\n+version (CRuntime_Musl)   version = SectionsElf;\n+version (CRuntime_UClibc) version = SectionsElf;\n+version (FreeBSD)         version = SectionsElf;\n+version (NetBSD)          version = SectionsElf;\n+version (DragonFlyBSD)    version = SectionsElf;\n+version (Solaris)         version = SectionsElf;\n+version (OSX)             version = SectionsMacho;\n+version (Windows)         version = SectionsPeCoff;\n+\n+version (SectionsElf)\n+    public import gcc.sections.elf;\n+else version (SectionsMacho)\n+    public import gcc.sections.macho;\n+else version (SectionsPeCoff)\n+    public import gcc.sections.pecoff;\n else\n     static assert(0, \"unimplemented\");\n+\n+version (Shared)\n+{\n+    // interface for core.thread to inherit loaded libraries\n+    void* pinLoadedLibraries() nothrow @nogc;\n+    void unpinLoadedLibraries(void* p) nothrow @nogc;\n+    void inheritLoadedLibraries(void* p) nothrow @nogc;\n+    void cleanupLoadedLibraries() nothrow @nogc;\n+}"}, {"sha": "ed0340e0311862ba943786d87e9c95d5408c2e5d", "filename": "libphobos/libdruntime/gcc/sections/pecoff.d", "status": "added", "additions": 826, "deletions": 0, "changes": 826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpecoff.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32703b80f66f7ca504eb79bee7e745f22cf096a8/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpecoff.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpecoff.d?ref=32703b80f66f7ca504eb79bee7e745f22cf096a8", "patch": "@@ -0,0 +1,826 @@\n+// PE/COFF-specific support for sections.\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.pecoff;\n+\n+version (Windows):\n+\n+import core.memory;\n+import core.stdc.stdlib;\n+import core.sys.windows.winbase;\n+import core.sys.windows.windef;\n+import core.sys.windows.winnt;\n+import rt.minfo;\n+import rt.util.container.array;\n+import rt.util.container.hashtab;\n+import gcc.sections.common;\n+\n+version (GNU_EMUTLS)\n+    import gcc.emutls;\n+\n+alias DSO SectionGroup;\n+struct DSO\n+{\n+    static int opApply(scope int delegate(ref DSO) dg)\n+    {\n+        foreach (dso; _loadedDSOs)\n+        {\n+            if (auto res = dg(*dso))\n+                return res;\n+        }\n+        return 0;\n+    }\n+\n+    static int opApplyReverse(scope int delegate(ref DSO) dg)\n+    {\n+        foreach_reverse (dso; _loadedDSOs)\n+        {\n+            if (auto res = dg(*dso))\n+                return res;\n+        }\n+        return 0;\n+    }\n+\n+    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n+    {\n+        return _moduleGroup.modules;\n+    }\n+\n+    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n+    {\n+        return _moduleGroup;\n+    }\n+\n+    @property inout(void[])[] gcRanges() inout nothrow @nogc\n+    {\n+        return _gcRanges[];\n+    }\n+\n+private:\n+\n+    invariant()\n+    {\n+        safeAssert(_moduleGroup.modules.length > 0, \"No modules for DSO.\");\n+    }\n+\n+    void** _slot;\n+    ModuleGroup _moduleGroup;\n+    Array!(void[]) _gcRanges;\n+\n+    version (Shared)\n+    {\n+        Array!(void[]) _codeSegments; // array of code segments\n+        Array!(DSO*) _deps; // D libraries needed by this DSO\n+        void* _handle; // corresponding handle\n+    }\n+}\n+\n+/****\n+ * Boolean flag set to true while the runtime is initialized.\n+ */\n+__gshared bool _isRuntimeInitialized;\n+\n+/****\n+ * Gets called on program startup just before GC is initialized.\n+ */\n+void initSections() nothrow @nogc\n+{\n+    _isRuntimeInitialized = true;\n+}\n+\n+/***\n+ * Gets called on program shutdown just after GC is terminated.\n+ */\n+void finiSections() nothrow @nogc\n+{\n+    _isRuntimeInitialized = false;\n+}\n+\n+alias ScanDG = void delegate(void* pbeg, void* pend) nothrow;\n+\n+version (Shared)\n+{\n+    import gcc.sections : pinLoadedLibraries, unpinLoadedLibraries,\n+           inheritLoadedLibraries, cleanupLoadedLibraries;\n+\n+    /***\n+     * Called once per thread; returns array of thread local storage ranges\n+     */\n+    Array!(ThreadDSO)* initTLSRanges() @nogc nothrow\n+    {\n+        return &_loadedDSOs();\n+    }\n+\n+    void finiTLSRanges(Array!(ThreadDSO)* tdsos) @nogc nothrow\n+    {\n+        // Nothing to do here. tdsos used to point to the _loadedDSOs instance\n+        // in the dying thread's TLS segment and as such is not valid anymore.\n+        // The memory for the array contents was already reclaimed in\n+        // cleanupLoadedLibraries().\n+    }\n+\n+    void scanTLSRanges(Array!(ThreadDSO)* tdsos, scope ScanDG dg) nothrow\n+    {\n+        version (GNU_EMUTLS)\n+            _d_emutls_scan(dg);\n+        else\n+            static assert(0, \"Native TLS unimplemented\");\n+    }\n+\n+    // interface for core.thread to inherit loaded libraries\n+    pragma(mangle, gcc.sections.pinLoadedLibraries.mangleof)\n+    void* pinLoadedLibraries() nothrow @nogc\n+    {\n+        auto res = cast(Array!(ThreadDSO)*)calloc(1, Array!(ThreadDSO).sizeof);\n+        res.length = _loadedDSOs.length;\n+        foreach (i, ref tdso; _loadedDSOs)\n+        {\n+            (*res)[i] = tdso;\n+            if (tdso._addCnt)\n+            {\n+                // Increment the DLL ref for explicitly loaded libraries to pin them.\n+                char[MAX_PATH] buf;\n+                char[] buffer = buf[];\n+                const success = .LoadLibraryA(nameForDSO(tdso._pdso, buffer)) !is null;\n+                safeAssert(success, \"Failed to increment DLL ref.\");\n+                (*res)[i]._addCnt = 1; // new array takes over the additional ref count\n+            }\n+        }\n+        return res;\n+    }\n+\n+    pragma(mangle, gcc.sections.unpinLoadedLibraries.mangleof)\n+    void unpinLoadedLibraries(void* p) nothrow @nogc\n+    {\n+        auto pary = cast(Array!(ThreadDSO)*)p;\n+        // In case something failed we need to undo the pinning.\n+        foreach (ref tdso; *pary)\n+        {\n+            if (tdso._addCnt)\n+            {\n+                auto handle = tdso._pdso._handle;\n+                safeAssert(handle !is null, \"Invalid library handle.\");\n+                .FreeLibrary(handle);\n+            }\n+        }\n+        pary.reset();\n+        .free(pary);\n+    }\n+\n+    // Called before TLS ctors are ran, copy over the loaded libraries\n+    // of the parent thread.\n+    pragma(mangle, gcc.sections.inheritLoadedLibraries.mangleof)\n+    void inheritLoadedLibraries(void* p) nothrow @nogc\n+    {\n+        safeAssert(_loadedDSOs.empty, \"DSOs have already been registered for this thread.\");\n+        _loadedDSOs.swap(*cast(Array!(ThreadDSO)*)p);\n+        .free(p);\n+    }\n+\n+    // Called after all TLS dtors ran, decrements all remaining DLL refs.\n+    pragma(mangle, gcc.sections.cleanupLoadedLibraries.mangleof)\n+    void cleanupLoadedLibraries() nothrow @nogc\n+    {\n+        foreach (ref tdso; _loadedDSOs)\n+        {\n+            if (tdso._addCnt == 0) continue;\n+\n+            auto handle = tdso._pdso._handle;\n+            safeAssert(handle !is null, \"Invalid DSO handle.\");\n+            for (; tdso._addCnt > 0; --tdso._addCnt)\n+                .FreeLibrary(handle);\n+        }\n+\n+        // Free the memory for the array contents.\n+        _loadedDSOs.reset();\n+    }\n+}\n+else\n+{\n+    /***\n+     * Called once per thread; returns array of thread local storage ranges\n+     */\n+    Array!(void[])* initTLSRanges() nothrow @nogc\n+    {\n+        return null;\n+    }\n+\n+    void finiTLSRanges(Array!(void[])* rngs) nothrow @nogc\n+    {\n+    }\n+\n+    void scanTLSRanges(Array!(void[])* rngs, scope ScanDG dg) nothrow\n+    {\n+        version (GNU_EMUTLS)\n+            _d_emutls_scan(dg);\n+        else\n+            static assert(0, \"Native TLS unimplemented\");\n+    }\n+}\n+\n+private:\n+\n+version (Shared)\n+{\n+    /*\n+     * Array of thread local DSO metadata for all libraries loaded and\n+     * initialized in this thread.\n+     *\n+     * Note:\n+     *     A newly spawned thread will inherit these libraries.\n+     * Note:\n+     *     We use an array here to preserve the order of\n+     *     initialization.  If that became a performance issue, we\n+     *     could use a hash table and enumerate the DSOs during\n+     *     loading so that the hash table values could be sorted when\n+     *     necessary.\n+     */\n+    struct ThreadDSO\n+    {\n+        DSO* _pdso;\n+        static if (_pdso.sizeof == 8) uint _refCnt, _addCnt;\n+        else static if (_pdso.sizeof == 4) ushort _refCnt, _addCnt;\n+        else static assert(0, \"unimplemented\");\n+        alias _pdso this;\n+    }\n+\n+    @property ref Array!(ThreadDSO) _loadedDSOs() @nogc nothrow\n+    {\n+        static Array!(ThreadDSO) x;\n+        return x;\n+    }\n+\n+    /*\n+     * Set to true during rt_loadLibrary/rt_unloadLibrary calls.\n+     */\n+    bool _rtLoading;\n+\n+    /*\n+     * Hash table to map the native handle (as returned by dlopen)\n+     * to the corresponding DSO*, protected by a mutex.\n+     */\n+    __gshared CRITICAL_SECTION _handleToDSOMutex;\n+    @property ref HashTab!(void*, DSO*) _handleToDSO() @nogc nothrow\n+    {\n+        __gshared HashTab!(void*, DSO*) x;\n+        return x;\n+    }\n+}\n+else\n+{\n+    /*\n+     * Static DSOs loaded by the runtime linker. This includes the\n+     * executable. These can't be unloaded.\n+     */\n+    @property ref Array!(DSO*) _loadedDSOs() @nogc nothrow\n+    {\n+        __gshared Array!(DSO*) x;\n+        return x;\n+    }\n+\n+    enum _rtLoading = false;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Compiler to runtime interface.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/****\n+ * This data structure is generated by the compiler, and then passed to\n+ * _d_dso_registry().\n+ */\n+struct CompilerDSOData\n+{\n+    size_t _version;                                       // currently 1\n+    void** _slot;                                          // can be used to store runtime data\n+    immutable(object.ModuleInfo*)* _minfo_beg, _minfo_end; // array of modules in this object file\n+}\n+\n+T[] toRange(T)(T* beg, T* end) { return beg[0 .. end - beg]; }\n+\n+/* For each shared library and executable, the compiler generates code that\n+ * sets up CompilerDSOData and calls _d_dso_registry().\n+ * A pointer to that code is inserted into both the .ctors and .dtors\n+ * segment so it gets called by the loader on startup and shutdown.\n+ */\n+extern(C) void _d_dso_registry(CompilerDSOData* data)\n+{\n+    // only one supported currently\n+    safeAssert(data._version >= 1, \"Incompatible compiler-generated DSO data version.\");\n+\n+    // no backlink => register\n+    if (*data._slot is null)\n+    {\n+        immutable firstDSO = _loadedDSOs.empty;\n+        if (firstDSO) initLocks();\n+\n+        DSO* pdso = cast(DSO*).calloc(1, DSO.sizeof);\n+        assert(typeid(DSO).initializer().ptr is null);\n+        pdso._slot = data._slot;\n+        *data._slot = pdso; // store backlink in library record\n+\n+        pdso._moduleGroup = ModuleGroup(toRange(data._minfo_beg, data._minfo_end));\n+\n+        HMODULE handle = void;\n+        const moduleFound = findModuleHandleForAddr(data._slot, handle);\n+        safeAssert(moduleFound, \"Failed to find image header.\");\n+\n+        scanSegments(handle, pdso);\n+\n+        version (Shared)\n+        {\n+            getDependencies(handle, pdso._deps);\n+            pdso._handle = handle;\n+            setDSOForHandle(pdso, pdso._handle);\n+\n+            if (!_rtLoading)\n+            {\n+                /* This DSO was not loaded by rt_loadLibrary which\n+                 * happens for all dependencies of an executable or\n+                 * the first dlopen call from a C program.\n+                 * In this case we add the DSO to the _loadedDSOs of this\n+                 * thread with a refCnt of 1 and call the TlsCtors.\n+                 */\n+                immutable ushort refCnt = 1, addCnt = 0;\n+                _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt));\n+            }\n+        }\n+        else\n+        {\n+            foreach (p; _loadedDSOs)\n+                safeAssert(p !is pdso, \"DSO already registered.\");\n+            _loadedDSOs.insertBack(pdso);\n+        }\n+\n+        // don't initialize modules before rt_init was called\n+        if (_isRuntimeInitialized)\n+        {\n+            registerGCRanges(pdso);\n+            // rt_loadLibrary will run tls ctors, so do this only for dlopen\n+            immutable runTlsCtors = !_rtLoading;\n+            runModuleConstructors(pdso, runTlsCtors);\n+        }\n+    }\n+    // has backlink => unregister\n+    else\n+    {\n+        DSO* pdso = cast(DSO*)*data._slot;\n+        *data._slot = null;\n+\n+        // don't finalizes modules after rt_term was called (see Bugzilla 11378)\n+        if (_isRuntimeInitialized)\n+        {\n+            // rt_unloadLibrary already ran tls dtors, so do this only for dlclose\n+            immutable runTlsDtors = !_rtLoading;\n+            runModuleDestructors(pdso, runTlsDtors);\n+            unregisterGCRanges(pdso);\n+            // run finalizers after module dtors (same order as in rt_term)\n+            version (Shared) runFinalizers(pdso);\n+        }\n+\n+        version (Shared)\n+        {\n+            if (!_rtLoading)\n+            {\n+                /* This DSO was not unloaded by rt_unloadLibrary so we\n+                 * have to remove it from _loadedDSOs here.\n+                 */\n+                foreach (i, ref tdso; _loadedDSOs)\n+                {\n+                    if (tdso._pdso == pdso)\n+                    {\n+                        _loadedDSOs.remove(i);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            unsetDSOForHandle(pdso, pdso._handle);\n+        }\n+        else\n+        {\n+            // static DSOs are unloaded in reverse order\n+            safeAssert(pdso == _loadedDSOs.back, \"DSO being unregistered isn't current last one.\");\n+            _loadedDSOs.popBack();\n+        }\n+\n+        freeDSO(pdso);\n+\n+        // last DSO being unloaded => shutdown registry\n+        if (_loadedDSOs.empty)\n+        {\n+            version (GNU_EMUTLS)\n+                _d_emutls_destroy();\n+            version (Shared)\n+            {\n+                safeAssert(_handleToDSO.empty, \"_handleToDSO not in sync with _loadedDSOs.\");\n+                _handleToDSO.reset();\n+            }\n+            finiLocks();\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// dynamic loading\n+///////////////////////////////////////////////////////////////////////////////\n+\n+// Shared D libraries are only supported when linking against a shared druntime library.\n+\n+version (Shared)\n+{\n+    ThreadDSO* findThreadDSO(DSO* pdso) nothrow @nogc\n+    {\n+        foreach (ref tdata; _loadedDSOs)\n+            if (tdata._pdso == pdso) return &tdata;\n+        return null;\n+    }\n+\n+    void incThreadRef(DSO* pdso, bool incAdd)\n+    {\n+        if (auto tdata = findThreadDSO(pdso)) // already initialized\n+        {\n+            if (incAdd && ++tdata._addCnt > 1) return;\n+            ++tdata._refCnt;\n+        }\n+        else\n+        {\n+            foreach (dep; pdso._deps)\n+                incThreadRef(dep, false);\n+            immutable ushort refCnt = 1, addCnt = incAdd ? 1 : 0;\n+            _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt));\n+            pdso._moduleGroup.runTlsCtors();\n+        }\n+    }\n+\n+    void decThreadRef(DSO* pdso, bool decAdd)\n+    {\n+        auto tdata = findThreadDSO(pdso);\n+        safeAssert(tdata !is null, \"Failed to find thread DSO.\");\n+        safeAssert(!decAdd || tdata._addCnt > 0, \"Mismatching rt_unloadLibrary call.\");\n+\n+        if (decAdd && --tdata._addCnt > 0) return;\n+        if (--tdata._refCnt > 0) return;\n+\n+        pdso._moduleGroup.runTlsDtors();\n+        foreach (i, ref td; _loadedDSOs)\n+            if (td._pdso == pdso) _loadedDSOs.remove(i);\n+        foreach (dep; pdso._deps)\n+            decThreadRef(dep, false);\n+    }\n+}\n+\n+/***********************************\n+ * These are a temporary means of providing a GC hook for DLL use.  They may be\n+ * replaced with some other similar functionality later.\n+ */\n+extern (C)\n+{\n+    void* gc_getProxy();\n+    void  gc_setProxy(void* p);\n+    void  gc_clrProxy();\n+\n+    alias void  function(void*) gcSetFn;\n+    alias void  function()      gcClrFn;\n+}\n+\n+/*******************************************\n+ * Loads a DLL written in D with the name 'name'.\n+ * Returns:\n+ *      opaque handle to the DLL if successfully loaded\n+ *      null if failure\n+ */\n+extern(C) void* rt_loadLibrary(const char* name)\n+{\n+    version (Shared)\n+    {\n+        immutable save = _rtLoading;\n+        _rtLoading = true;\n+        scope (exit) _rtLoading = save;\n+    }\n+    return initLibrary(.LoadLibraryA(name));\n+}\n+\n+extern (C) void* rt_loadLibraryW(const wchar_t* name)\n+{\n+    version (Shared)\n+    {\n+        immutable save = _rtLoading;\n+        _rtLoading = true;\n+        scope (exit) _rtLoading = save;\n+    }\n+    return initLibrary(.LoadLibraryW(name));\n+}\n+\n+void* initLibrary(void* handle)\n+{\n+    if (handle is null)\n+        return null;\n+\n+    version (Shared)\n+    {\n+        // if it's a D library\n+        if (auto pdso = dsoForHandle(handle))\n+            incThreadRef(pdso, true);\n+    }\n+    gcSetFn gcSet = cast(gcSetFn) GetProcAddress(handle, \"gc_setProxy\");\n+    if (gcSet !is null)\n+    {\n+        // BUG: Set proxy, but too late\n+        gcSet(gc_getProxy());\n+    }\n+    return handle;\n+}\n+\n+/*************************************\n+ * Unloads DLL that was previously loaded by rt_loadLibrary().\n+ * Input:\n+ *      handle  the handle returned by rt_loadLibrary()\n+ * Returns:\n+ *      1   succeeded\n+ *      0   some failure happened\n+ */\n+extern(C) int rt_unloadLibrary(void* handle)\n+{\n+    if (handle is null)\n+        return false;\n+\n+    version (Shared)\n+    {\n+        immutable save = _rtLoading;\n+        _rtLoading = true;\n+        scope (exit) _rtLoading = save;\n+\n+        // if it's a D library\n+        if (auto pdso = dsoForHandle(handle))\n+            decThreadRef(pdso, true);\n+    }\n+    gcClrFn gcClr  = cast(gcClrFn) GetProcAddress(handle, \"gc_clrProxy\");\n+    if (gcClr !is null)\n+        gcClr();\n+    return .FreeLibrary(handle) != 0;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// helper functions\n+///////////////////////////////////////////////////////////////////////////////\n+\n+void initLocks() nothrow @nogc\n+{\n+    version (Shared)\n+        InitializeCriticalSection(&_handleToDSOMutex);\n+}\n+\n+void finiLocks() nothrow @nogc\n+{\n+    version (Shared)\n+        DeleteCriticalSection(&_handleToDSOMutex);\n+}\n+\n+void runModuleConstructors(DSO* pdso, bool runTlsCtors)\n+{\n+    pdso._moduleGroup.sortCtors();\n+    pdso._moduleGroup.runCtors();\n+    if (runTlsCtors) pdso._moduleGroup.runTlsCtors();\n+}\n+\n+void runModuleDestructors(DSO* pdso, bool runTlsDtors)\n+{\n+    if (runTlsDtors) pdso._moduleGroup.runTlsDtors();\n+    pdso._moduleGroup.runDtors();\n+}\n+\n+void registerGCRanges(DSO* pdso) nothrow @nogc\n+{\n+    foreach (rng; pdso._gcRanges)\n+        GC.addRange(rng.ptr, rng.length);\n+}\n+\n+void unregisterGCRanges(DSO* pdso) nothrow @nogc\n+{\n+    foreach (rng; pdso._gcRanges)\n+        GC.removeRange(rng.ptr);\n+}\n+\n+version (Shared) void runFinalizers(DSO* pdso)\n+{\n+    foreach (seg; pdso._codeSegments)\n+        GC.runFinalizers(seg);\n+}\n+\n+void freeDSO(DSO* pdso) nothrow @nogc\n+{\n+    pdso._gcRanges.reset();\n+    version (Shared)\n+    {\n+        pdso._codeSegments.reset();\n+        pdso._deps.reset();\n+        pdso._handle = null;\n+    }\n+    .free(pdso);\n+}\n+\n+version (Shared)\n+{\n+@nogc nothrow:\n+    const(char)* nameForDSO(DSO* pdso, ref char[] buffer)\n+    {\n+        const success = GetModuleFileNameA(pdso._handle, buffer.ptr, cast(DWORD)buffer.length) != 0;\n+        safeAssert(success, \"Failed to get DLL name.\");\n+        return buffer.ptr;\n+    }\n+\n+    DSO* dsoForHandle(in void* handle)\n+    {\n+        DSO* pdso;\n+        .EnterCriticalSection(&_handleToDSOMutex);\n+        if (auto ppdso = handle in _handleToDSO)\n+            pdso = *ppdso;\n+        .LeaveCriticalSection(&_handleToDSOMutex);\n+        return pdso;\n+    }\n+\n+    void setDSOForHandle(DSO* pdso, void* handle)\n+    {\n+        .EnterCriticalSection(&_handleToDSOMutex);\n+        safeAssert(handle !in _handleToDSO, \"DSO already registered.\");\n+        _handleToDSO[handle] = pdso;\n+        .LeaveCriticalSection(&_handleToDSOMutex);\n+    }\n+\n+    void unsetDSOForHandle(DSO* pdso, void* handle)\n+    {\n+        .EnterCriticalSection(&_handleToDSOMutex);\n+        safeAssert(_handleToDSO[handle] == pdso, \"Handle doesn't match registered DSO.\");\n+        _handleToDSO.remove(handle);\n+        .LeaveCriticalSection(&_handleToDSOMutex);\n+    }\n+\n+    void getDependencies(in HMODULE handle, ref Array!(DSO*) deps)\n+    {\n+        auto nthdr = getNTHeader(handle);\n+        auto import_entry = nthdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n+        auto addr = import_entry.VirtualAddress;\n+        auto datasize = import_entry.Size;\n+\n+        if (addr == 0 && datasize == 0)\n+        {\n+            // Maybe the optional header isn't there, look for the section.\n+            foreach (section; getSectionHeader(handle))\n+            {\n+                if (!compareSectionName(section, \".idata\"))\n+                    continue;\n+                addr = section.VirtualAddress;\n+                datasize = section.Misc.VirtualSize;\n+                break;\n+            }\n+            if (datasize == 0)\n+                return;\n+        }\n+        else\n+        {\n+            bool foundSection = false;\n+            foreach (section; getSectionHeader(handle))\n+            {\n+                if (!compareSectionName(section, \".idata\"))\n+                    continue;\n+                // Section containing import table has no contents.\n+                if (section.Misc.VirtualSize == 0)\n+                    return;\n+                foundSection = true;\n+                break;\n+            }\n+            // There is an import table, but the section containing it could not be found\n+            if (!foundSection)\n+                return;\n+        }\n+\n+        // Get the names of each DLL\n+        for (uint i = 0; i + IMAGE_IMPORT_DESCRIPTOR.sizeof <= datasize;\n+             i += IMAGE_IMPORT_DESCRIPTOR.sizeof)\n+        {\n+            const data = cast(PIMAGE_IMPORT_DESCRIPTOR)(handle + addr + i);\n+            if (data.Name == 0)\n+                break;\n+\n+            // dll name of dependency\n+            auto name = cast(char*)(handle + data.Name);\n+            // get handle without loading the library\n+            auto libhandle = handleForName(name);\n+            // the runtime linker has already loaded all dependencies\n+            safeAssert(handle !is null, \"Failed to get library handle.\");\n+            // if it's a D library\n+            if (auto pdso = dsoForHandle(handle))\n+                deps.insertBack(pdso); // append it to the dependencies\n+        }\n+    }\n+\n+    void* handleForName(const char* name)\n+    {\n+        return GetModuleHandleA(name);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// PE/COFF program header iteration\n+///////////////////////////////////////////////////////////////////////////////\n+\n+bool compareSectionName(ref IMAGE_SECTION_HEADER section, string name) nothrow @nogc\n+{\n+    if (name[] != cast(char[])section.Name[0 .. name.length])\n+        return false;\n+    return name.length == 8 || section.Name[name.length] == 0;\n+}\n+\n+/************\n+ * Scan segments in the image header and store\n+ * the writeable data segments in *pdso.\n+ */\n+\n+void scanSegments(in HMODULE handle, DSO* pdso) nothrow @nogc\n+{\n+    foreach (section; getSectionHeader(handle))\n+    {\n+        // the \".data\" image section includes both object file sections \".data\" and \".bss\"\n+        if (compareSectionName(section, \".data\"))\n+        {\n+            auto data = cast(void*)handle + section.VirtualAddress;\n+            pdso._gcRanges.insertBack(data[0 .. section.Misc.VirtualSize]);\n+            continue;\n+        }\n+\n+        version (Shared)\n+        {\n+            if (compareSectionName(section, \".text\"))\n+            {\n+                auto text = cast(void*)handle + section.VirtualAddress;\n+                pdso._codeSegments.insertBack(text[0 .. section.Misc.VirtualSize]);\n+                continue;\n+            }\n+        }\n+    }\n+}\n+\n+/**************************\n+ * Input:\n+ *      handle  where the output is to be written\n+ * Returns:\n+ *      true if found, and *handle is filled in\n+ */\n+\n+bool findModuleHandleForAddr(in void* addr, out HMODULE handle) nothrow @nogc\n+{\n+    if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+                           cast(const(wchar)*) addr, &handle))\n+        return true;\n+\n+    return false;\n+}\n+\n+/**\n+ * Returns the image NT header for the HMODULE handle passed,\n+ * or null if not found.\n+ */\n+PIMAGE_NT_HEADERS getNTHeader(in HMODULE handle) nothrow @nogc\n+{\n+    auto doshdr = cast(PIMAGE_DOS_HEADER)handle;\n+    if (doshdr.e_magic != IMAGE_DOS_SIGNATURE)\n+        return null;\n+\n+    return cast(typeof(return))(cast(void*)doshdr + doshdr.e_lfanew);\n+}\n+\n+/**\n+ * Returns the image section header for the HMODULE handle passed,\n+ * or null if not found.\n+ */\n+IMAGE_SECTION_HEADER[] getSectionHeader(in HMODULE handle) nothrow @nogc\n+{\n+    if (auto nthdr = getNTHeader(handle))\n+    {\n+        const void* opthdr = &nthdr.OptionalHeader;\n+        const offset = nthdr.FileHeader.SizeOfOptionalHeader;\n+        const length = nthdr.FileHeader.NumberOfSections;\n+        return (cast(PIMAGE_SECTION_HEADER)(opthdr + offset))[0 .. length];\n+    }\n+    return null;\n+}"}, {"sha": "b355dfc506878e50e9c073d1214d58ce4b4ac32e", "filename": "libphobos/libdruntime/gcc/sections/win32.d", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d?ref=385ee099eeae53bff5dd5adf673ad4f4b8d22981", "patch": "@@ -1,183 +0,0 @@\n-// Win32-specific support for sections.\n-// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-module gcc.sections.win32;\n-\n-version (CRuntime_DigitalMars):\n-\n-// debug = PRINTF;\n-debug(PRINTF) import core.stdc.stdio;\n-import rt.minfo;\n-import core.stdc.stdlib : malloc, free;\n-\n-struct SectionGroup\n-{\n-    static int opApply(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    static int opApplyReverse(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n-    {\n-        return _moduleGroup.modules;\n-    }\n-\n-    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n-    {\n-        return _moduleGroup;\n-    }\n-\n-    @property inout(void[])[] gcRanges() inout nothrow @nogc\n-    {\n-        return _gcRanges[];\n-    }\n-\n-private:\n-    ModuleGroup _moduleGroup;\n-    void[][] _gcRanges;\n-}\n-\n-shared(bool) conservative;\n-\n-void initSections() nothrow @nogc\n-{\n-    _sections._moduleGroup = ModuleGroup(getModuleInfos());\n-\n-    import rt.sections;\n-    conservative = !scanDataSegPrecisely();\n-\n-    if (conservative)\n-    {\n-        _sections._gcRanges = (cast(void[]*) malloc(2 * (void[]).sizeof))[0..2];\n-\n-        auto databeg = cast(void*)&_xi_a;\n-        auto dataend = cast(void*)_moduleinfo_array.ptr;\n-        _sections._gcRanges[0] = databeg[0 .. dataend - databeg];\n-\n-        // skip module info and CONST segment\n-        auto bssbeg = cast(void*)&_edata;\n-        auto bssend = cast(void*)&_end;\n-        _sections._gcRanges[1] = bssbeg[0 .. bssend - bssbeg];\n-    }\n-    else\n-    {\n-        size_t count = &_DPend - &_DPbegin;\n-        auto ranges = cast(void[]*) malloc(count * (void[]).sizeof);\n-        size_t r = 0;\n-        void* prev = null;\n-        for (size_t i = 0; i < count; i++)\n-        {\n-            void* addr = (&_DPbegin)[i];\n-            if (prev + (void*).sizeof == addr)\n-                ranges[r-1] = ranges[r-1].ptr[0 .. ranges[r-1].length + (void*).sizeof];\n-            else\n-                ranges[r++] = (cast(void**)addr)[0..1];\n-            prev = addr;\n-        }\n-        _sections._gcRanges = ranges[0..r];\n-    }\n-}\n-\n-void finiSections() nothrow @nogc\n-{\n-    free(_sections._gcRanges.ptr);\n-}\n-\n-void[] initTLSRanges() nothrow @nogc\n-{\n-    auto pbeg = cast(void*)&_tlsstart;\n-    auto pend = cast(void*)&_tlsend;\n-    return pbeg[0 .. pend - pbeg];\n-}\n-\n-void finiTLSRanges(void[] rng) nothrow @nogc\n-{\n-}\n-\n-void scanTLSRanges(void[] rng, scope void delegate(void* pbeg, void* pend) nothrow dg) nothrow\n-{\n-    if (conservative)\n-    {\n-        dg(rng.ptr, rng.ptr + rng.length);\n-    }\n-    else\n-    {\n-        for (auto p = &_TPbegin; p < &_TPend; )\n-        {\n-            uint beg = *p++;\n-            uint end = beg + cast(uint)((void*).sizeof);\n-            while (p < &_TPend && *p == end)\n-            {\n-                end += (void*).sizeof;\n-                p++;\n-            }\n-            dg(rng.ptr + beg, rng.ptr + end);\n-        }\n-    }\n-}\n-\n-private:\n-\n-__gshared SectionGroup _sections;\n-\n-// Windows: this gets initialized by minit.asm\n-extern(C) __gshared immutable(ModuleInfo*)[] _moduleinfo_array;\n-extern(C) void _minit() nothrow @nogc;\n-\n-immutable(ModuleInfo*)[] getModuleInfos() nothrow @nogc\n-out (result)\n-{\n-    foreach (m; result)\n-        assert(m !is null);\n-}\n-body\n-{\n-    // _minit directly alters the global _moduleinfo_array\n-    _minit();\n-    return _moduleinfo_array;\n-}\n-\n-extern(C)\n-{\n-    extern __gshared\n-    {\n-        int _xi_a;      // &_xi_a just happens to be start of data segment\n-        int _edata;     // &_edata is start of BSS segment\n-        int _end;       // &_end is past end of BSS\n-\n-        void* _DPbegin; // first entry in the array of pointers addresses\n-        void* _DPend;   // &_DPend points after last entry of array\n-        uint _TPbegin;  // first entry in the array of TLS offsets of pointers\n-        uint _TPend;    // &_DPend points after last entry of array\n-    }\n-\n-    extern\n-    {\n-        int _tlsstart;\n-        int _tlsend;\n-    }\n-}"}, {"sha": "357940ba8219e3e7174af0fe60681ccdbe7b0f75", "filename": "libphobos/libdruntime/gcc/sections/win64.d", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385ee099eeae53bff5dd5adf673ad4f4b8d22981/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d?ref=385ee099eeae53bff5dd5adf673ad4f4b8d22981", "patch": "@@ -1,321 +0,0 @@\n-// Win64-specific support for sections.\n-// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-module gcc.sections.win64;\n-\n-version (CRuntime_Microsoft):\n-\n-// debug = PRINTF;\n-debug(PRINTF) import core.stdc.stdio;\n-import core.stdc.stdlib : malloc, free;\n-import rt.deh, rt.minfo;\n-\n-struct SectionGroup\n-{\n-    static int opApply(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    static int opApplyReverse(scope int delegate(ref SectionGroup) dg)\n-    {\n-        return dg(_sections);\n-    }\n-\n-    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n-    {\n-        return _moduleGroup.modules;\n-    }\n-\n-    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n-    {\n-        return _moduleGroup;\n-    }\n-\n-    version (Win64)\n-    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n-    {\n-        auto pbeg = cast(immutable(FuncTable)*)&_deh_beg;\n-        auto pend = cast(immutable(FuncTable)*)&_deh_end;\n-        return pbeg[0 .. pend - pbeg];\n-    }\n-\n-    @property inout(void[])[] gcRanges() inout nothrow @nogc\n-    {\n-        return _gcRanges[];\n-    }\n-\n-private:\n-    ModuleGroup _moduleGroup;\n-    void[][] _gcRanges;\n-}\n-\n-shared(bool) conservative;\n-\n-void initSections() nothrow @nogc\n-{\n-    _sections._moduleGroup = ModuleGroup(getModuleInfos());\n-\n-    // the \".data\" image section includes both object file sections \".data\" and \".bss\"\n-    void[] dataSection = findImageSection(\".data\");\n-    debug(PRINTF) printf(\"found .data section: [%p,+%llx]\\n\", dataSection.ptr,\n-                         cast(ulong)dataSection.length);\n-\n-    import rt.sections;\n-    conservative = !scanDataSegPrecisely();\n-\n-    if (conservative)\n-    {\n-        _sections._gcRanges = (cast(void[]*) malloc((void[]).sizeof))[0..1];\n-        _sections._gcRanges[0] = dataSection;\n-    }\n-    else\n-    {\n-        size_t count = &_DP_end - &_DP_beg;\n-        auto ranges = cast(void[]*) malloc(count * (void[]).sizeof);\n-        size_t r = 0;\n-        void* prev = null;\n-        for (size_t i = 0; i < count; i++)\n-        {\n-            auto off = (&_DP_beg)[i];\n-            if (off == 0) // skip zero entries added by incremental linking\n-                continue; // assumes there is no D-pointer at the very beginning of .data\n-            void* addr = dataSection.ptr + off;\n-            debug(PRINTF) printf(\"  scan %p\\n\", addr);\n-            // combine consecutive pointers into single range\n-            if (prev + (void*).sizeof == addr)\n-                ranges[r-1] = ranges[r-1].ptr[0 .. ranges[r-1].length + (void*).sizeof];\n-            else\n-                ranges[r++] = (cast(void**)addr)[0..1];\n-            prev = addr;\n-        }\n-        _sections._gcRanges = ranges[0..r];\n-    }\n-}\n-\n-void finiSections() nothrow @nogc\n-{\n-    .free(cast(void*)_sections.modules.ptr);\n-    .free(_sections._gcRanges.ptr);\n-}\n-\n-void[] initTLSRanges() nothrow @nogc\n-{\n-    void* pbeg;\n-    void* pend;\n-    // with VS2017 15.3.1, the linker no longer puts TLS segments into a\n-    //  separate image section. That way _tls_start and _tls_end no\n-    //  longer generate offsets into .tls, but DATA.\n-    // Use the TEB entry to find the start of TLS instead and read the\n-    //  length from the TLS directory\n-    version (D_InlineAsm_X86)\n-    {\n-        asm @nogc nothrow\n-        {\n-            mov EAX, _tls_index;\n-            mov ECX, FS:[0x2C];     // _tls_array\n-            mov EAX, [ECX+4*EAX];\n-            mov pbeg, EAX;\n-            add EAX, [_tls_used+4]; // end\n-            sub EAX, [_tls_used+0]; // start\n-            mov pend, EAX;\n-        }\n-    }\n-    else version (D_InlineAsm_X86_64)\n-    {\n-        asm @nogc nothrow\n-        {\n-            xor RAX, RAX;\n-            mov EAX, _tls_index;\n-            mov RCX, 0x58;\n-            mov RCX, GS:[RCX];      // _tls_array (immediate value causes fixup)\n-            mov RAX, [RCX+8*RAX];\n-            mov pbeg, RAX;\n-            add RAX, [_tls_used+8]; // end\n-            sub RAX, [_tls_used+0]; // start\n-            mov pend, RAX;\n-        }\n-    }\n-    else\n-        static assert(false, \"Architecture not supported.\");\n-\n-    return pbeg[0 .. pend - pbeg];\n-}\n-\n-void finiTLSRanges(void[] rng) nothrow @nogc\n-{\n-}\n-\n-void scanTLSRanges(void[] rng, scope void delegate(void* pbeg, void* pend) nothrow dg) nothrow\n-{\n-    if (conservative)\n-    {\n-        dg(rng.ptr, rng.ptr + rng.length);\n-    }\n-    else\n-    {\n-        for (auto p = &_TP_beg; p < &_TP_end; )\n-        {\n-            uint beg = *p++;\n-            uint end = beg + cast(uint)((void*).sizeof);\n-            while (p < &_TP_end && *p == end)\n-            {\n-                end += (void*).sizeof;\n-                p++;\n-            }\n-            dg(rng.ptr + beg, rng.ptr + end);\n-        }\n-    }\n-}\n-\n-private:\n-__gshared SectionGroup _sections;\n-\n-extern(C)\n-{\n-    extern __gshared void* _minfo_beg;\n-    extern __gshared void* _minfo_end;\n-}\n-\n-immutable(ModuleInfo*)[] getModuleInfos() nothrow @nogc\n-out (result)\n-{\n-    foreach (m; result)\n-        assert(m !is null);\n-}\n-body\n-{\n-    auto m = (cast(immutable(ModuleInfo*)*)&_minfo_beg)[1 .. &_minfo_end - &_minfo_beg];\n-    /* Because of alignment inserted by the linker, various null pointers\n-     * are there. We need to filter them out.\n-     */\n-    auto p = m.ptr;\n-    auto pend = m.ptr + m.length;\n-\n-    // count non-null pointers\n-    size_t cnt;\n-    for (; p < pend; ++p)\n-    {\n-        if (*p !is null) ++cnt;\n-    }\n-\n-    auto result = (cast(immutable(ModuleInfo)**).malloc(cnt * size_t.sizeof))[0 .. cnt];\n-\n-    p = m.ptr;\n-    cnt = 0;\n-    for (; p < pend; ++p)\n-        if (*p !is null) result[cnt++] = *p;\n-\n-    return cast(immutable)result;\n-}\n-\n-extern(C)\n-{\n-    /* Symbols created by the compiler/linker and inserted into the\n-     * object file that 'bracket' sections.\n-     */\n-    extern __gshared\n-    {\n-        void* __ImageBase;\n-\n-        void* _deh_beg;\n-        void* _deh_end;\n-\n-        uint _DP_beg;\n-        uint _DP_end;\n-        uint _TP_beg;\n-        uint _TP_end;\n-\n-        void*[2] _tls_used; // start, end\n-        int _tls_index;\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////\n-\n-enum IMAGE_DOS_SIGNATURE = 0x5A4D;      // MZ\n-\n-struct IMAGE_DOS_HEADER // DOS .EXE header\n-{\n-    ushort   e_magic;    // Magic number\n-    ushort[29] e_res2;   // Reserved ushorts\n-    int      e_lfanew;   // File address of new exe header\n-}\n-\n-struct IMAGE_FILE_HEADER\n-{\n-    ushort Machine;\n-    ushort NumberOfSections;\n-    uint   TimeDateStamp;\n-    uint   PointerToSymbolTable;\n-    uint   NumberOfSymbols;\n-    ushort SizeOfOptionalHeader;\n-    ushort Characteristics;\n-}\n-\n-struct IMAGE_NT_HEADERS\n-{\n-    uint Signature;\n-    IMAGE_FILE_HEADER FileHeader;\n-    // optional header follows\n-}\n-\n-struct IMAGE_SECTION_HEADER\n-{\n-    char[8] Name = 0;\n-    union {\n-        uint   PhysicalAddress;\n-        uint   VirtualSize;\n-    }\n-    uint   VirtualAddress;\n-    uint   SizeOfRawData;\n-    uint   PointerToRawData;\n-    uint   PointerToRelocations;\n-    uint   PointerToLinenumbers;\n-    ushort NumberOfRelocations;\n-    ushort NumberOfLinenumbers;\n-    uint   Characteristics;\n-}\n-\n-bool compareSectionName(ref IMAGE_SECTION_HEADER section, string name) nothrow @nogc\n-{\n-    if (name[] != section.Name[0 .. name.length])\n-        return false;\n-    return name.length == 8 || section.Name[name.length] == 0;\n-}\n-\n-void[] findImageSection(string name) nothrow @nogc\n-{\n-    if (name.length > 8) // section name from string table not supported\n-        return null;\n-    IMAGE_DOS_HEADER* doshdr = cast(IMAGE_DOS_HEADER*) &__ImageBase;\n-    if (doshdr.e_magic != IMAGE_DOS_SIGNATURE)\n-        return null;\n-\n-    auto nthdr = cast(IMAGE_NT_HEADERS*)(cast(void*)doshdr + doshdr.e_lfanew);\n-    auto sections = cast(IMAGE_SECTION_HEADER*)(cast(void*)nthdr + IMAGE_NT_HEADERS.sizeof + nthdr.FileHeader.SizeOfOptionalHeader);\n-    for (ushort i = 0; i < nthdr.FileHeader.NumberOfSections; i++)\n-        if (compareSectionName (sections[i], name))\n-            return (cast(void*)&__ImageBase + sections[i].VirtualAddress)[0 .. sections[i].VirtualSize];\n-\n-    return null;\n-}"}]}