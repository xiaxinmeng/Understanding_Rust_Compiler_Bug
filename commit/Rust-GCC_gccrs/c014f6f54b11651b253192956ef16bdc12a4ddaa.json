{"sha": "c014f6f54b11651b253192956ef16bdc12a4ddaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxNGY2ZjU0YjExNjUxYjI1MzE5Mjk1NmVmMTZiZGMxMmE0ZGRhYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-04T09:00:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-04T09:00:21Z"}, "message": "tree-data-ref.c (have_similar_memory_accesses_1): Remove.\n\n2012-06-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-data-ref.c (have_similar_memory_accesses_1): Remove.\n\t(ref_base_address_1): Likewise.\n\t(remove_similar_memory_refs): Likewise.\n\t* tree-data-ref.h (remove_similar_memory_refs): Remove.\n\t* tree-loop-distribution.c (classify_partition): Do not classify\n\tas builtin if -ftree-loop-distribute-patterns is not enabled.\n\t(fuse_partitions_with_similar_memory_accesses): Inline ...\n\t(ldist_gen): ... here.  Fuse all non-builtin partitions if\n\t-ftree-loop-distribution is not enabled.  Properly return\n\tthe number of created partitions.  Do not update SSA form here\n\tbut ...\n\t(tree_loop_distribution): ... once here for the whole function.\n\tOnly walk innermost loops, constrain loops we consider here\n\tfurther.  Do not call remove_similar_memory_refs.\n\t(distribute_loop): Do not check number of loop nodes here.\n\n\t* gcc.dg/tree-ssa/ldist-11.c: Enable -ftree-loop-distribute-patterns.\n\t* gcc.dg/tree-ssa/ldist-17.c: Likewise.\n\t* gcc.dg/tree-ssa/ldist-pr45948.c: Likewise.\n\nFrom-SVN: r188168", "tree": {"sha": "c9484b42ae7ecc4f94ed5074f51c6f5dd55b960d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9484b42ae7ecc4f94ed5074f51c6f5dd55b960d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c014f6f54b11651b253192956ef16bdc12a4ddaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c014f6f54b11651b253192956ef16bdc12a4ddaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c014f6f54b11651b253192956ef16bdc12a4ddaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c014f6f54b11651b253192956ef16bdc12a4ddaa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "296f202e8ec694dbbd987aed2b97b04ce895858f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296f202e8ec694dbbd987aed2b97b04ce895858f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296f202e8ec694dbbd987aed2b97b04ce895858f"}], "stats": {"total": 281, "additions": 137, "deletions": 144}, "files": [{"sha": "d79f2a139f48f18074f1ddc8b14d471d047f811d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -1,3 +1,21 @@\n+2012-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (have_similar_memory_accesses_1): Remove.\n+\t(ref_base_address_1): Likewise.\n+\t(remove_similar_memory_refs): Likewise.\n+\t* tree-data-ref.h (remove_similar_memory_refs): Remove.\n+\t* tree-loop-distribution.c (classify_partition): Do not classify\n+\tas builtin if -ftree-loop-distribute-patterns is not enabled.\n+\t(fuse_partitions_with_similar_memory_accesses): Inline ...\n+\t(ldist_gen): ... here.  Fuse all non-builtin partitions if\n+\t-ftree-loop-distribution is not enabled.  Properly return\n+\tthe number of created partitions.  Do not update SSA form here\n+\tbut ...\n+\t(tree_loop_distribution): ... once here for the whole function.\n+\tOnly walk innermost loops, constrain loops we consider here\n+\tfurther.  Do not call remove_similar_memory_refs.\n+\t(distribute_loop): Do not check number of loop nodes here.\n+\n 2012-06-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* Makefile.in (GIMPLE_H): Do not depend on TARGET_H."}, {"sha": "69019bfba5a7f30da0180ac43ebe224c653d8973", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -1,3 +1,9 @@\n+2012-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ldist-11.c: Enable -ftree-loop-distribute-patterns.\n+\t* gcc.dg/tree-ssa/ldist-17.c: Likewise.\n+\t* gcc.dg/tree-ssa/ldist-pr45948.c: Likewise.\n+\n 2012-06-03  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n \n \tPR fortran/48831"}, {"sha": "e55a1b64ecc1ee57110cf345439dcb6bdedd6d03", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-all\" } */\n \n void foo (int * __restrict__ ia,\n \t  int * __restrict__ ib,"}, {"sha": "fe40bed5811c5b5d2c2be88273ba3ddbc33c46b7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n \n typedef int mad_fixed_t;\n struct mad_pcm"}, {"sha": "da3c7b626f9ae0ca818f8683292367c4060dfbd1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-pr45948.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n \n extern void bar(int);\n "}, {"sha": "bbfc32154ef0f1d9da39771004a721e680abec25", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -5403,65 +5403,3 @@ have_similar_memory_accesses (gimple s1, gimple s2)\n   VEC_free (data_ref_loc, heap, refs2);\n   return res;\n }\n-\n-/* Helper function for the hashtab.  */\n-\n-static int\n-have_similar_memory_accesses_1 (const void *s1, const void *s2)\n-{\n-  return have_similar_memory_accesses (CONST_CAST_GIMPLE ((const_gimple) s1),\n-\t\t\t\t       CONST_CAST_GIMPLE ((const_gimple) s2));\n-}\n-\n-/* Helper function for the hashtab.  */\n-\n-static hashval_t\n-ref_base_address_1 (const void *s)\n-{\n-  gimple stmt = CONST_CAST_GIMPLE ((const_gimple) s);\n-  unsigned i;\n-  VEC (data_ref_loc, heap) *refs;\n-  data_ref_loc *ref;\n-  hashval_t res = 0;\n-\n-  get_references_in_stmt (stmt, &refs);\n-\n-  FOR_EACH_VEC_ELT (data_ref_loc, refs, i, ref)\n-    if (!ref->is_read)\n-      {\n-\tres = htab_hash_pointer (ref_base_address (stmt, ref));\n-\tbreak;\n-      }\n-\n-  VEC_free (data_ref_loc, heap, refs);\n-  return res;\n-}\n-\n-/* Try to remove duplicated write data references from STMTS.  */\n-\n-void\n-remove_similar_memory_refs (VEC (gimple, heap) **stmts)\n-{\n-  unsigned i;\n-  gimple stmt;\n-  htab_t seen = htab_create (VEC_length (gimple, *stmts), ref_base_address_1,\n-\t\t\t     have_similar_memory_accesses_1, NULL);\n-\n-  for (i = 0; VEC_iterate (gimple, *stmts, i, stmt); )\n-    {\n-      void **slot;\n-\n-      slot = htab_find_slot (seen, stmt, INSERT);\n-\n-      if (*slot)\n-\tVEC_ordered_remove (gimple, *stmts, i);\n-      else\n-\t{\n-\t  *slot = (void *) stmt;\n-\t  i++;\n-\t}\n-    }\n-\n-  htab_delete (seen);\n-}\n-"}, {"sha": "da4802ef4f2ec5b7e32dc54467017a5cdc3685b0", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -607,7 +607,6 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n \n void stores_from_loop (struct loop *, VEC (gimple, heap) **);\n void stores_zero_from_loop (struct loop *, VEC (gimple, heap) **);\n-void remove_similar_memory_refs (VEC (gimple, heap) **);\n bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n bool have_similar_memory_accesses (gimple, gimple);\n bool stmt_with_adjacent_zero_store_dr_p (gimple);"}, {"sha": "1fc1d8d249b6b39056489cf142523b1554833161", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 110, "deletions": 78, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c014f6f54b11651b253192956ef16bdc12a4ddaa/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=c014f6f54b11651b253192956ef16bdc12a4ddaa", "patch": "@@ -398,7 +398,28 @@ destroy_loop (struct loop *loop)\n   rescan_loop_exit (exit, false, true);\n \n   for (i = 0; i < nbbs; i++)\n-    delete_basic_block (bbs[i]);\n+    {\n+      /* We have made sure to not leave any dangling uses of SSA\n+         names defined in the loop.  With the exception of virtuals.\n+\t Make sure we replace all uses of virtual defs that will remain\n+\t outside of the loop with the bare symbol as delete_basic_block\n+\t will release them.  */\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_phis (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\t  if (!is_gimple_reg (gimple_phi_result (phi)))\n+\t    mark_virtual_phi_result_for_renaming (phi);\n+\t}\n+      for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  tree vdef = gimple_vdef (stmt);\n+\t  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n+\t    mark_virtual_operand_for_renaming (vdef);\n+\t}\n+      delete_basic_block (bbs[i]);\n+    }\n   free (bbs);\n \n   set_immediate_dominator (CDI_DOMINATORS, dest,\n@@ -801,6 +822,9 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n   partition->kind = PKIND_NORMAL;\n   partition->main_stmt = NULL;\n \n+  if (!flag_tree_loop_distribute_patterns)\n+    return;\n+\n   /* Perform general partition disqualification for builtins.  */\n   nb_iter = number_of_exit_cond_executions (loop);\n   if (!nb_iter || nb_iter == chrec_dont_know)\n@@ -876,31 +900,6 @@ similar_memory_accesses (struct graph *rdg, partition_t partition1,\n   return false;\n }\n \n-/* Fuse all the partitions from PARTITIONS that contain similar memory\n-   references, i.e., we're taking care of cache locality.  This\n-   function does not fuse those partitions that contain patterns that\n-   can be code generated with builtins.  */\n-\n-static void\n-fuse_partitions_with_similar_memory_accesses (struct graph *rdg,\n-\t\t\t\t\t      VEC (partition_t, heap) **partitions)\n-{\n-  int p1, p2;\n-  partition_t partition1, partition2;\n-\n-  FOR_EACH_VEC_ELT (partition_t, *partitions, p1, partition1)\n-    if (!partition_builtin_p (partition1))\n-      FOR_EACH_VEC_ELT (partition_t, *partitions, p2, partition2)\n-\tif (p1 != p2\n-\t    && !partition_builtin_p (partition2)\n-\t    && similar_memory_accesses (rdg, partition1, partition2))\n-\t  {\n-\t    bitmap_ior_into (partition1->stmts, partition2->stmts);\n-\t    VEC_ordered_remove (partition_t, *partitions, p2);\n-\t    p2--;\n-\t  }\n-}\n-\n /* Aggregate several components into a useful partition that is\n    registered in the PARTITIONS vector.  Partitions will be\n    distributed in different loops.  */\n@@ -1100,26 +1099,73 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n     classify_partition (loop, rdg, partition);\n \n-  fuse_partitions_with_similar_memory_accesses (rdg, &partitions);\n+  /* If we are only distributing patterns fuse all partitions that\n+     were not properly classified as builtins.  Else fuse partitions\n+     with similar memory accesses.  */\n+  if (!flag_tree_loop_distribution)\n+    {\n+      partition_t into;\n+      for (i = 0; VEC_iterate (partition_t, partitions, i, into); ++i)\n+\tif (!partition_builtin_p (into))\n+\t  break;\n+      for (++i; VEC_iterate (partition_t, partitions, i, partition); ++i)\n+\tif (!partition_builtin_p (partition))\n+\t  {\n+\t    bitmap_ior_into (into->stmts, partition->stmts);\n+\t    VEC_ordered_remove (partition_t, partitions, i);\n+\t    i--;\n+\t  }\n+    }\n+  else\n+    {\n+      partition_t into;\n+      int j;\n+      for (i = 0; VEC_iterate (partition_t, partitions, i, into); ++i)\n+\t{\n+\t  if (partition_builtin_p (into))\n+\t    continue;\n+\t  for (j = i + 1;\n+\t       VEC_iterate (partition_t, partitions, j, partition); ++j)\n+\t    {\n+\t      if (!partition_builtin_p (partition)\n+\t\t  /* ???  The following is horribly inefficient,\n+\t\t     we are re-computing and analyzing data-references\n+\t\t     of the stmts in the partitions all the time.  */\n+\t\t  && similar_memory_accesses (rdg, into, partition))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"fusing partitions\\n\");\n+\t\t      dump_bitmap (dump_file, into->stmts);\n+\t\t      dump_bitmap (dump_file, partition->stmts);\n+\t\t      fprintf (dump_file, \"because they have similar \"\n+\t\t\t       \"memory accesses\\n\");\n+\t\t    }\n+\t\t  bitmap_ior_into (into->stmts, partition->stmts);\n+\t\t  VEC_ordered_remove (partition_t, partitions, j);\n+\t\t  j--;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   nbp = VEC_length (partition_t, partitions);\n   if (nbp == 0\n       || (nbp == 1\n \t  && !partition_builtin_p (VEC_index (partition_t, partitions, 0)))\n       || (nbp > 1\n \t  && partition_contains_all_rw (rdg, partitions)))\n-    goto ldist_done;\n+    {\n+      nbp = 0;\n+      goto ldist_done;\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg_partitions (dump_file, partitions);\n \n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n     generate_code_for_partition (loop, partition, i < nbp - 1);\n \n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-  mark_sym_for_renaming (gimple_vop (cfun));\n-  update_ssa (TODO_update_ssa_only_virtuals);\n-\n  ldist_done:\n \n   BITMAP_FREE (remaining_stmts);\n@@ -1152,16 +1198,6 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n   VEC (data_reference_p, heap) *datarefs;\n   VEC (loop_p, heap) *loop_nest;\n \n-  if (loop->num_nodes > 2)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"FIXME: Loop %d not distributed: it has more than two basic blocks.\\n\",\n-\t\t loop->num);\n-\n-      return res;\n-    }\n-\n   datarefs = VEC_alloc (data_reference_p, heap, 10);\n   dependence_relations = VEC_alloc (ddr_p, heap, 100);\n   loop_nest = VEC_alloc (loop_p, heap, 3);\n@@ -1215,48 +1251,38 @@ tree_loop_distribution (void)\n {\n   struct loop *loop;\n   loop_iterator li;\n-  int nb_generated_loops = 0;\n+  bool changed = false;\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  /* We can at the moment only distribute non-nested loops, thus restrict\n+     walking to innermost loops.  */\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n     {\n       VEC (gimple, heap) *work_list = NULL;\n       int num = loop->num;\n+      int nb_generated_loops = 0;\n \n       /* If the loop doesn't have a single exit we will fail anyway,\n \t so do that early.  */\n       if (!single_exit (loop))\n \tcontinue;\n \n-      /* If both flag_tree_loop_distribute_patterns and\n-\t flag_tree_loop_distribution are set, then only\n-\t distribute_patterns is executed.  */\n-      if (flag_tree_loop_distribute_patterns)\n-\t{\n-\t  /* With the following working list, we're asking\n-\t     distribute_loop to separate from the rest of the loop the\n-\t     stores of the form \"A[i] = 0\".  */\n-\t  stores_zero_from_loop (loop, &work_list);\n-\n-\t  /* Do nothing if there are no patterns to be distributed.  */\n-\t  if (VEC_length (gimple, work_list) > 0)\n-\t    nb_generated_loops = distribute_loop (loop, work_list);\n-\t}\n-      else if (flag_tree_loop_distribution)\n-\t{\n-\t  /* With the following working list, we're asking\n-\t     distribute_loop to separate the stores of the loop: when\n-\t     dependences allow, it will end on having one store per\n-\t     loop.  */\n-\t  stores_from_loop (loop, &work_list);\n-\n-\t  /* A simple heuristic for cache locality is to not split\n-\t     stores to the same array.  Without this call, an unrolled\n-\t     loop would be split into as many loops as unroll factor,\n-\t     each loop storing in the same array.  */\n-\t  remove_similar_memory_refs (&work_list);\n-\n-\t  nb_generated_loops = distribute_loop (loop, work_list);\n-\t}\n+      /* Only distribute loops with a header and latch for now.  */\n+      if (loop->num_nodes > 2)\n+\tcontinue;\n+\n+      /* -ftree-loop-distribution strictly distributes more but also\n+         enables pattern detection.  For now simply distribute all stores\n+\t or memset like stores.  */\n+      if (flag_tree_loop_distribution)\n+\tstores_from_loop (loop, &work_list);\n+      else if (flag_tree_loop_distribute_patterns)\n+\tstores_zero_from_loop (loop, &work_list);\n+\n+      if (VEC_length (gimple, work_list) > 0)\n+\tnb_generated_loops = distribute_loop (loop, work_list);\n+\n+      if (nb_generated_loops > 0)\n+\tchanged = true;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1267,13 +1293,19 @@ tree_loop_distribution (void)\n \t    fprintf (dump_file, \"Loop %d is the same.\\n\", num);\n \t}\n \n-#ifdef ENABLE_CHECKING\n-      verify_loop_structure ();\n-#endif\n-\n       VEC_free (gimple, heap, work_list);\n     }\n \n+  if (changed)\n+    {\n+      mark_sym_for_renaming (gimple_vop (cfun));\n+      rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+#endif\n+\n   return 0;\n }\n "}]}