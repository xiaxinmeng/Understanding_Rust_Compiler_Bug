{"sha": "804a718aac4681c268c0b3a4a713cc5abec1f0cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0YTcxOGFhYzQ2ODFjMjY4YzBiM2E0YTcxM2NjNWFiZWMxZjBjZA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-07T10:03:39Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-07T10:03:39Z"}, "message": "loop.h (loop_insn_hoist): New prototype.\n\n\t* loop.h (loop_insn_hoist): New prototype.\n\t* loop.c (loop_insn_hoist, loop_insn_emit_before): New.\n\t(move_movables, loop_givs_rescan): Use loop_insn_hoist.\n\t(check_dbra_loop, load_mems): Likewise.\n\t* unroll.c (unroll_loop, find_splittable_regs): Likewise.\n\t(find_splittable_givs): Likewise.\n\nFrom-SVN: r38765", "tree": {"sha": "b0482a37f7ddc6077dd117c67263684bb1fa9f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0482a37f7ddc6077dd117c67263684bb1fa9f86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/804a718aac4681c268c0b3a4a713cc5abec1f0cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a718aac4681c268c0b3a4a713cc5abec1f0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804a718aac4681c268c0b3a4a713cc5abec1f0cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a718aac4681c268c0b3a4a713cc5abec1f0cd/comments", "author": null, "committer": null, "parents": [{"sha": "30a1181af5180982e83635b29c4bca55eae25bad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a1181af5180982e83635b29c4bca55eae25bad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a1181af5180982e83635b29c4bca55eae25bad"}], "stats": {"total": 83, "additions": 61, "deletions": 22}, "files": [{"sha": "325811372115404a3aec7c4a3565192bff59ac4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=804a718aac4681c268c0b3a4a713cc5abec1f0cd", "patch": "@@ -1,3 +1,12 @@\n+2001-01-07  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.h (loop_insn_hoist): New prototype.\n+\t* loop.c (loop_insn_hoist, loop_insn_emit_before): New.\n+\t(move_movables, loop_givs_rescan): Use loop_insn_hoist.\n+\t(check_dbra_loop, load_mems): Likewise.\n+\t* unroll.c (unroll_loop, find_splittable_regs): Likewise.\n+\t(find_splittable_givs): Likewise.\n+\n 2001-01-07  Michael Hayes  <mhayes@redhat.com>\n \n \t* loop.c (emit_iv_add_mult): Use single_set to examine new insn."}, {"sha": "d58284fa4735debdb6376c49f520c4ef0dfbac5d", "filename": "gcc/loop.c", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=804a718aac4681c268c0b3a4a713cc5abec1f0cd", "patch": "@@ -246,6 +246,9 @@ static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n \n+static rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block, \n+\t\t\t\t\t rtx, rtx));\n+\n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n void debug_biv PARAMS ((const struct induction *));\n void debug_giv PARAMS ((const struct induction *));\n@@ -1711,7 +1714,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t  for (m1 = m; m1->match; m1 = m1->match);\n \t\t  newpat = gen_move_insn (SET_DEST (PATTERN (m->insn)),\n \t\t\t\t\t  SET_DEST (PATTERN (m1->insn)));\n-\t\t  i1 = emit_insn_before (newpat, loop_start);\n+\t\t  i1 = loop_insn_hoist (loop, newpat);\n \n \t\t  /* Mark the moved, invariant reg as being allowed to\n \t\t     share a hard reg with the other matching invariant.  */\n@@ -1735,7 +1738,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t the move insn before the loop.  */\n \t      else if (m->move_insn)\n \t\t{\n-\t\t  rtx i1, temp;\n+\t\t  rtx i1, temp, seq;\n \n \t\t  for (count = m->consec; count >= 0; count--)\n \t\t    {\n@@ -1772,11 +1775,12 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t  start_sequence ();\n \t\t  emit_move_insn (m->set_dest, m->set_src);\n \t\t  temp = get_insns ();\n+\t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \n \t\t  add_label_notes (m->set_src, temp);\n \n-\t\t  i1 = emit_insns_before (temp, loop_start);\n+\t\t  i1 = loop_insn_hoist (loop, seq);\n \t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n \t\t    REG_NOTES (i1)\n \t\t      = gen_rtx_EXPR_LIST (m->is_equiv ? REG_EQUIV : REG_EQUAL,\n@@ -1877,7 +1881,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t\t      = copy_rtx (CALL_INSN_FUNCTION_USAGE (temp));\n \t\t\t\t}\n \t\t\t      else\n-\t\t\t\ti1 = emit_insn_before (body, loop_start);\n+\t\t\t\ti1 = loop_insn_hoist (loop, body);\n \t\t\t      if (first == 0)\n \t\t\t\tfirst = i1;\n \t\t\t      if (temp == fn_address_insn)\n@@ -1910,7 +1914,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t    emit_move_insn (reg, tem);\n \t\t\t  sequence = gen_sequence ();\n \t\t\t  end_sequence ();\n-\t\t\t  i1 = emit_insn_before (sequence, loop_start);\n+\t\t\t  i1 = loop_insn_hoist (loop, sequence);\n \t\t\t}\n \t\t      else if (GET_CODE (p) == CALL_INSN)\n \t\t\t{\n@@ -1924,24 +1928,26 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t}\n \t\t      else if (count == m->consec && m->move_insn_first)\n \t\t\t{\n+\t\t\t  rtx seq;\n \t\t\t  /* The SET_SRC might not be invariant, so we must\n \t\t\t     use the REG_EQUAL note.  */\n \t\t\t  start_sequence ();\n \t\t\t  emit_move_insn (m->set_dest, m->set_src);\n \t\t\t  temp = get_insns ();\n+\t\t\t  seq = gen_sequence ();\n \t\t\t  end_sequence ();\n \n \t\t\t  add_label_notes (m->set_src, temp);\n \n-\t\t\t  i1 = emit_insns_before (temp, loop_start);\n+\t\t\t  i1 = loop_insn_hoist (loop, seq);\n \t\t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n \t\t\t    REG_NOTES (i1)\n \t\t\t      = gen_rtx_EXPR_LIST ((m->is_equiv ? REG_EQUIV\n \t\t\t\t\t\t    : REG_EQUAL),\n \t\t\t\t\t\t   m->set_src, REG_NOTES (i1));\n \t\t\t}\n \t\t      else\n-\t\t\ti1 = emit_insn_before (PATTERN (p), loop_start);\n+\t\t\ti1 = loop_insn_hoist (loop, PATTERN (p));\n \n \t\t      if (REG_NOTES (i1) == 0)\n \t\t\t{\n@@ -4041,18 +4047,16 @@ loop_givs_rescan (loop, bl, reg_map, end_insert_before)\n \t\t\t  end_insert_before);\n       else if (v->final_value)\n \t{\n-\t  rtx insert_before;\n-\t  \n \t  /* If the loop has multiple exits, emit the insn before the\n \t     loop to ensure that it will always be executed no matter\n \t     how the loop exits.  Otherwise, emit the insn after the loop,\n \t     since this is slightly more efficient.  */\n \t  if (loop->exit_count)\n-\t    insert_before = loop->start;\n+\t    loop_insn_hoist (loop, \n+\t\t\t     gen_move_insn (v->dest_reg, v->final_value));\n \t  else\n-\t    insert_before = end_insert_before;\n-\t  emit_insn_before (gen_move_insn (v->dest_reg, v->final_value),\n-\t\t\t    insert_before);\n+\t    emit_insn_before (gen_move_insn (v->dest_reg, v->final_value),\n+\t\t\t      end_insert_before);\n \t}\n       \n       if (loop_dump_stream)\n@@ -7435,8 +7439,7 @@ check_dbra_loop (loop, insn_count)\n \t\t  && GET_CODE (comparison_value) == CONST_INT)\n \t\t{\n \t\t  start_value = GEN_INT (comparison_val - add_adjust);\n-\t\t  emit_insn_before (gen_move_insn (reg, start_value),\n-\t\t\t\t    loop_start);\n+\t\t  loop_insn_hoist (loop, gen_move_insn (reg, start_value));\n \t\t}\n \t      else if (GET_CODE (initial_value) == CONST_INT)\n \t\t{\n@@ -7453,9 +7456,8 @@ check_dbra_loop (loop, insn_count)\n \t\t    return 0;\n \t\t  start_value\n \t\t    = gen_rtx_PLUS (mode, comparison_value, offset);\n-\t\t  emit_insn_before ((GEN_FCN (icode)\n-\t\t\t\t     (reg, comparison_value, offset)),\n-\t\t\t\t    loop_start);\n+\t\t  loop_insn_hoist (loop, (GEN_FCN (icode)\n+\t\t\t\t\t     (reg, comparison_value, offset)));\n \t\t  if (GET_CODE (comparison) == LE)\n \t\t    final_value = gen_rtx_PLUS (mode, comparison_value,\n \t\t\t\t\t\tGEN_INT (add_val));\n@@ -7473,9 +7475,9 @@ check_dbra_loop (loop, insn_count)\n \t\t    return 0;\n \t\t  start_value\n \t\t    = gen_rtx_MINUS (mode, comparison_value, initial_value);\n-\t\t  emit_insn_before ((GEN_FCN (icode)\n-\t\t\t\t     (reg, comparison_value, initial_value)),\n-\t\t\t\t    loop_start);\n+\t\t  loop_insn_hoist (loop, (GEN_FCN (icode)\n+\t\t\t\t\t     (reg, comparison_value,\n+\t\t\t\t\t      initial_value)));\n \t\t}\n \t      else\n \t\t/* We could handle the other cases too, but it'll be\n@@ -8975,7 +8977,7 @@ load_mems (loop)\n \t\tbest = copy_rtx (best_equiv->loc);\n \t    }\n \t  set = gen_move_insn (reg, best);\n-\t  set = emit_insn_before (set, loop->start);\n+\t  set = loop_insn_hoist (loop, set);\n \t  if (const_equiv)\n \t    REG_NOTES (set) = gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t\t\t\t copy_rtx (const_equiv->loc),\n@@ -9358,6 +9360,33 @@ replace_label (x, data)\n   return 0;\n }\n \f\n+/* If WHERE_INSN is non-zero emit insn for PATTERN before WHERE_INSN\n+   in basic block WHERE_BB (ignored in the interim) within the loop\n+   otherwise hoist PATTERN into the loop pre-header.  */\n+\n+static rtx\n+loop_insn_emit_before (loop, where_bb, where_insn, pattern)\n+     const struct loop *loop;\n+     basic_block where_bb ATTRIBUTE_UNUSED;\n+     rtx where_insn;\n+     rtx pattern;\n+{\n+  if (! where_insn)\n+    return loop_insn_hoist (loop, pattern);\n+  return emit_insn_before (pattern, where_insn);\n+}\n+\n+\n+/* Hoist insn for PATTERN into the loop pre-header.  */\n+\n+rtx\n+loop_insn_hoist (loop, pattern)\n+     const struct loop *loop;\n+     rtx pattern;\n+{\n+  return loop_insn_emit_before (loop, 0, loop->start, pattern);\n+}\n+\f\n static void\n loop_biv_dump (v, file, verbose)\n      const struct induction *v;"}, {"sha": "5a3f295690fc604dcb9408a9fd967e20ebdccf11", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804a718aac4681c268c0b3a4a713cc5abec1f0cd/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=804a718aac4681c268c0b3a4a713cc5abec1f0cd", "patch": "@@ -404,6 +404,7 @@ int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n int loop_insn_first_p PARAMS ((rtx, rtx));\n typedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n+rtx loop_insn_hoist PARAMS((const struct loop *, rtx));\n \n /* Forward declarations for non-static functions declared in doloop.c.  */\n int doloop_optimize PARAMS ((const struct loop *));"}]}