{"sha": "31e632d3e47f22d310f36709f6d983cb1a8dba92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlNjMyZDNlNDdmMjJkMzEwZjM2NzA5ZjZkOTgzY2IxYThkYmE5Mg==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-04-16T18:44:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-04-16T18:44:45Z"}, "message": "[multiple changes]\n\n2004-04-09  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkPanelPeer.java (connectSignals):\n\tRemove method.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c: Remove\n\tunused code.\n\n2004-04-02  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/ImageIcon.java:\n\t(ImageIcon(file)): set description of the icon\n\tto the file name\n\t* javax/swing/JCheckBoxMenuItem.java:\n\tMostly Implemented. Work in progress.\n\t* javax/swing/JRadioButtonMenuItem.java:\n \tReimplement constructors to use JToggleButtonModel.\n\t* javax/swing/plaf/basic/BasicIconFactory.java:\n\t(getCheckBoxMenuItemIcon): return check box\n\ticon.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\tpaint menu item selected only when it is armed and\n\tpressed.\n\n2004-04-02  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkMenuItemPeer.java\n\t(GtkMenuItemPeer): Only connect signals if this isn't a Menu peer.\n\t* java/awt/Component.java\n\t(add): Set the parent of the popup as this component.\n\t* java/awt/PopupMenu.java\n\t(addNotify): Create popup menu when peer is null.\n\t(show): Call addNotify() if peer is null.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkPopupMenuPeer_show): Set the button\n\targument for gtk_menu_popup() as zero. This causes the popup menu to\n\trespond to any mouse button.\n\n2004-03-31  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JRadioButtonMenuItem.java:\n\tImplemented.\n\t* javax/swing/plaf/basic/BasicIconFactory.java:\n\t(getRadioButtonMenuItemIcon): Return\n\tradio button icon.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(getPreferredSize): Add size of checkIcon if it\n\texists.\n\t(installDefaults): Don't initialize checkIcon.\n\tIt's value will be set in subclasses.\n\t(uninstallDefaults): remove uninstallation of\n\tcheckIcon.\n\t(paint): Moved code to paintMenuItem().\n\t(paintMenuItem): Implemented.\n\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java:\n\tUI delegate for JRadioButtonMenuItem.\n\n2004-03-29  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\tCorrected position of the accelerator.\n\n2004-03-29  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JMenuItem.java: Partly\n\timplemented. Work in progress\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tChanged default value of acceleratorDelimiter.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\tNew class. Partly implemented.\n\n2004-03-26  Mark Wielaard  <mark@klomp.org>\n\n\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.c\n\t(item_activate): Declare label before use.\n\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(gtkSetFont): Removed unused variable label.\n\t(addExposeFilter): Declare variables before use.\n\t(removeExposeFilter): Likewise.\n\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n\t(ok_clicked): Declare str_fileName before use.\n\n2004-03-26  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkMenuPeer.java\n\t(addSeparator): Remove.\n\t* java/awt/Menu.java\n\t(separator): Remove static final MenuItem field.\n\t(separatorLabel): New static final String field.\n\t(addSeparator): Do not use peer method; use add(MenuItem) instead.\n\tUse separatorLabel to denote that it is a separator.\n\t(insertSeparator): Create a new MenuItem with separatorLabel, instead\n\tof reusing the static separator instance, because a MenuItem instance\n\tcan't be added more than once without being cloned.\n\t* java/awt/peer/MenuPeer.java\n\t(addSeparator): Remove from interface.\n\n2004-03-26  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkMenuItemPeer.java\n\t(connectSignals): New native method declaration.\n\t(GtkMenuItemPeer): Connect signals if the parent is a Menu.\n\t* java/awt/MenuItem.java\n\t(getActionCommand): Return the label if the action command is not set.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuBarPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkMenuBarPeer_addMenu): Use\n\tgtk_menu_shell_append().\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuItemPeer.c\n\t(item_activate): Fix argument type.\n\t(Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_create): Do not connect\n\tsignal here.\n\t(Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_connectSignals): New\n\tmethod.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkMenuPeer_create): Check if a label is\n\tgiven. Add the menu widget's top-level GtkWindow to the global window\n\tgroup, so it can grab the pointer.\n\t(Java_gnu_java_awt_peer_gtk_GtkMenuPeer_addItem): Use\n\tgtk_menu_shell_append().\n\n2004-03-23  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/text/AttributedString.java\n\t(addAttribute): Fix off-by-one.\n\t(getIterator): Likewise.\n\t* java/text/AttributedStringIterator.java\n\t(getRunLimit): Correct logic.\n\t(getRunStart): Likewise.\n\t(getAttribute): Fix inequality.\n\t(getAttributes): Likewise.\n\t* testsuite/libjava.mauve/xfails: Remove AttributedString xfail.\n\n2004-03-23  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n\t(calculateSizes): Return real width and height.\n\n2004-03-23  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n\t(calculateTabRects): Set the selectedRun before\n\ttrying to rotate tabs.\n\n2004-03-23  Kim Ho  <kho@redhat.com>\n\n\t* Makefile.am: New file\n\t* Makefile.in: Regenerate\n\t* java/awt/Graphics.java: (drawRect):\n\tDraw to the correct point.\n\t* javax/swing/DefaultSingleSelectionModel.java\n\t(isSelected): Return true if the selected index\n\tis not -1.\n\t* javax/swing/JLabel.java: Do not change mnemonic\n\tindex if text is null.\n\t* javax/swing/JProgressBar.java: Use JComponent's\n\tEventListenerList.\n\t* javax/swing/JScrollBar.java: Ditto.\n\t* javax/swing/JSlider.java: Ditto.\n\t* javax/swing/JTabbedPane.java: Reimplement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tAdd defaults for TabbedPane.\n\t* javax/swing/plaf/basic/BasicArrowButton.java:\n\tImplement\n\t* javax/swing/plaf/basic/BasicProgressBarUI.java:\n\t(paintDeterminate): Don't paint String if it's\n\tempty.\n\t(paintIndeterminate): ditto.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n\tReimplement.\n\n2004-03-19  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/image/AffineTransformOp.java\n\t(AffineTransformOp): Made public.\n\t* javax/swing/JComponent.java\n\t(listenerList): Made protected.\n\t(accessibleContext): Likewise.\n\t* javax/swing/JList.java\n\t(valueChanged): Dont use internal fields of ListSelectionEvent.\n\t* javax/swing/JViewport.java\n\t(getView): Dont use internal fields of Component.\n\t(addImpl): Likewise.\n\t* javax/swing/Timer.java\n\t(isRunning): Made public.\n\t(start): Likewise.\n\t(stop): Likewise.\n\t* javax/swing/UIDefaults.java\n\t(getInt): Made public.\n\t* javax/swing/plaf/basic/BasicListUI.java\n\t(mousePressed): Dont use internal fields of MouseEvent.\n\t(propertyChanged): Dont use internal fields of PropertyChangeEvent.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n\t(arrowIcon): Made static.\n\t* javax/swing/plaf/basic/BasicViewportUI.java\n\t(stateChanged): Dont use internal field on ChangeEvent.\n\t* javax/swing/text/JTextComponent.java\n\t(getUI): Call UIManager.getUI().\n\t(updateUI): Use getUI().\n\n2004-03-19  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/JComponent.java: Turn off double buffer by default.\n\t* javax/swing/plaf/basic/BasicViewportUI.java: Clear rects before painting.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c\n\t(Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable):\n\tUse cairo to copy areas.\n\t(Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClip):\n\tInitialize and set clip region.\n\n2004-03-15  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/applet/Applet.java (preferredSize): Override deprecated\n\tvariant of getPreferredSize.\n\t(minimumSize): Override deprecated variant of getMinimumSize.\n\n2004-03-15  Olga Rodimina  <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(drawImage(img,xform,bgcolor,obs)): New Method.\n\tHelper function that every drawImage method will\n\tuse.\n\t(drawRaster): Added new parameter, bgcolor. All\n\ttransparent pixels are changed to bgcolor before\n\timage is drawn.\n\t(drawRenderedImage): Fixed to use changed drawRaster().\n\t(drawImage(image,xform,obs): Fixed to use new helper function\n\t(drawImage(image,op,x,y)): Ditto.\n\t(drawImage (img,x,y,observer)): Ditto.\n\t((PainterThread) bgcolor): New Field.\n\t((PainterThread) (setPixels)): Changed all transparent pixels\n\tto bgcolor.\n\t(drawImage(img,x,y,width,height,bgcolor,observer)):\n\tFixed FIXME - all the transparent pixels are\n\tchanged to the specified bgcolor.\n\t(drawImage(img, x, y, width, height, observer): Changed to\n\tuse function above.\n\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,bgcolor,observer)):\n\tFixed FIXME- changed all transparent pixels to bgcolor.\n\t(drawImage (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer)):\n\tChanged to use function above.\n\n2004-03-14  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/applet/Applet.java (dimensions): New field.\n\t(getDimensions): New method.\n\t(getPreferredSize): Call getDimensions.\n\t(getMinimumSize): Likewise.\n\n2004-03-13  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/classpath/jcl.c: Include stdlib.h, not malloc.h.\n\t* jni/classpath/jnilink.c: Likewise.\n\n\t* java/applet/Applet.java (getPreferredSize): New method.\n\t(getMinimumSize): New method.\n\nFrom-SVN: r80762", "tree": {"sha": "cb7d0902aeb41d7ea4b23d42752c1c7aec6a2729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb7d0902aeb41d7ea4b23d42752c1c7aec6a2729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e632d3e47f22d310f36709f6d983cb1a8dba92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e632d3e47f22d310f36709f6d983cb1a8dba92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e632d3e47f22d310f36709f6d983cb1a8dba92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e632d3e47f22d310f36709f6d983cb1a8dba92/comments", "author": null, "committer": null, "parents": [{"sha": "2d49ce67973aa150ad56b47c7f5dc71fa1e02680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d49ce67973aa150ad56b47c7f5dc71fa1e02680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d49ce67973aa150ad56b47c7f5dc71fa1e02680"}], "stats": {"total": 7874, "additions": 6666, "deletions": 1208}, "files": [{"sha": "b375daa43aee3e91c4af0766a8f678d562411849", "filename": "libjava/ChangeLog", "status": "modified", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1,3 +1,264 @@\n+2004-04-09  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkPanelPeer.java (connectSignals):\n+\tRemove method.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c: Remove\n+\tunused code.\n+\n+2004-04-02  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/ImageIcon.java: \n+\t(ImageIcon(file)): set description of the icon \n+\tto the file name\n+\t* javax/swing/JCheckBoxMenuItem.java:\n+\tMostly Implemented. Work in progress.\n+\t* javax/swing/JRadioButtonMenuItem.java:\n+ \tReimplement constructors to use JToggleButtonModel.\n+\t* javax/swing/plaf/basic/BasicIconFactory.java:\n+\t(getCheckBoxMenuItemIcon): return check box\n+\ticon.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\tpaint menu item selected only when it is armed and \n+\tpressed. \n+ \n+2004-04-02  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkMenuItemPeer.java\n+\t(GtkMenuItemPeer): Only connect signals if this isn't a Menu peer.\n+\t* java/awt/Component.java\n+\t(add): Set the parent of the popup as this component.\n+\t* java/awt/PopupMenu.java\n+\t(addNotify): Create popup menu when peer is null.\n+\t(show): Call addNotify() if peer is null.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkPopupMenuPeer_show): Set the button\n+\targument for gtk_menu_popup() as zero. This causes the popup menu to\n+\trespond to any mouse button.\n+\n+2004-03-31  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JRadioButtonMenuItem.java:\n+\tImplemented.\n+\t* javax/swing/plaf/basic/BasicIconFactory.java:\n+\t(getRadioButtonMenuItemIcon): Return\n+\tradio button icon.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(getPreferredSize): Add size of checkIcon if it\n+\texists.\n+\t(installDefaults): Don't initialize checkIcon.\n+\tIt's value will be set in subclasses. \n+\t(uninstallDefaults): remove uninstallation of \n+\tcheckIcon.\n+\t(paint): Moved code to paintMenuItem().\n+\t(paintMenuItem): Implemented.\n+\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java:\n+\tUI delegate for JRadioButtonMenuItem.\n+\t\n+2004-03-29  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\tCorrected position of the accelerator.\n+\n+2004-03-29  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file. \n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JMenuItem.java: Partly \n+\timplemented. Work in progress\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tChanged default value of acceleratorDelimiter.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\tNew class. Partly implemented.\n+\t\t\n+2004-03-26  Mark Wielaard  <mark@klomp.org>\n+\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.c\n+\t(item_activate): Declare label before use.\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(gtkSetFont): Removed unused variable label.\n+\t(addExposeFilter): Declare variables before use.\n+\t(removeExposeFilter): Likewise.\n+\t* native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n+\t(ok_clicked): Declare str_fileName before use.\n+\n+2004-03-26  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkMenuPeer.java\n+\t(addSeparator): Remove.\n+\t* java/awt/Menu.java\n+\t(separator): Remove static final MenuItem field.\n+\t(separatorLabel): New static final String field.\n+\t(addSeparator): Do not use peer method; use add(MenuItem) instead.\n+\tUse separatorLabel to denote that it is a separator.\n+\t(insertSeparator): Create a new MenuItem with separatorLabel, instead\n+\tof reusing the static separator instance, because a MenuItem instance\n+\tcan't be added more than once without being cloned.\n+\t* java/awt/peer/MenuPeer.java\n+\t(addSeparator): Remove from interface.\n+\n+2004-03-26  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkMenuItemPeer.java\n+\t(connectSignals): New native method declaration.\n+\t(GtkMenuItemPeer): Connect signals if the parent is a Menu.\n+\t* java/awt/MenuItem.java\n+\t(getActionCommand): Return the label if the action command is not set.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuBarPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkMenuBarPeer_addMenu): Use\n+\tgtk_menu_shell_append().\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuItemPeer.c\n+\t(item_activate): Fix argument type.\n+\t(Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_create): Do not connect\n+\tsignal here.\n+\t(Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_connectSignals): New\n+\tmethod.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkMenuPeer_create): Check if a label is\n+\tgiven. Add the menu widget's top-level GtkWindow to the global window\n+\tgroup, so it can grab the pointer.\n+\t(Java_gnu_java_awt_peer_gtk_GtkMenuPeer_addItem): Use\n+\tgtk_menu_shell_append().\n+\n+2004-03-23  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/text/AttributedString.java \n+\t(addAttribute): Fix off-by-one.\n+\t(getIterator): Likewise.\t\n+\t* java/text/AttributedStringIterator.java \n+\t(getRunLimit): Correct logic.\n+\t(getRunStart): Likewise.\n+\t(getAttribute): Fix inequality.\n+\t(getAttributes): Likewise.\n+\t* testsuite/libjava.mauve/xfails: Remove AttributedString xfail.\n+\n+2004-03-23  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n+\t(calculateSizes): Return real width and height.\n+\n+2004-03-23  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n+\t(calculateTabRects): Set the selectedRun before\n+\ttrying to rotate tabs.\n+\n+2004-03-23  Kim Ho  <kho@redhat.com>\n+\n+\t* Makefile.am: New file\n+\t* Makefile.in: Regenerate\n+\t* java/awt/Graphics.java: (drawRect):\n+\tDraw to the correct point.\n+\t* javax/swing/DefaultSingleSelectionModel.java\n+\t(isSelected): Return true if the selected index\n+\tis not -1.\n+\t* javax/swing/JLabel.java: Do not change mnemonic\n+\tindex if text is null.\n+\t* javax/swing/JProgressBar.java: Use JComponent's\n+\tEventListenerList.\n+\t* javax/swing/JScrollBar.java: Ditto.\n+\t* javax/swing/JSlider.java: Ditto.\n+\t* javax/swing/JTabbedPane.java: Reimplement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tAdd defaults for TabbedPane.\n+\t* javax/swing/plaf/basic/BasicArrowButton.java:\n+\tImplement\n+\t* javax/swing/plaf/basic/BasicProgressBarUI.java:\n+\t(paintDeterminate): Don't paint String if it's\n+\tempty.\n+\t(paintIndeterminate): ditto.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n+\tReimplement.\n+\n+2004-03-19  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/image/AffineTransformOp.java\n+\t(AffineTransformOp): Made public.\n+\t* javax/swing/JComponent.java\n+\t(listenerList): Made protected.\n+\t(accessibleContext): Likewise.\n+\t* javax/swing/JList.java\n+\t(valueChanged): Dont use internal fields of ListSelectionEvent.\n+\t* javax/swing/JViewport.java\n+\t(getView): Dont use internal fields of Component.\n+\t(addImpl): Likewise.\n+\t* javax/swing/Timer.java\n+\t(isRunning): Made public.\n+\t(start): Likewise.\n+\t(stop): Likewise.\n+\t* javax/swing/UIDefaults.java\n+\t(getInt): Made public.\n+\t* javax/swing/plaf/basic/BasicListUI.java\n+\t(mousePressed): Dont use internal fields of MouseEvent.\n+\t(propertyChanged): Dont use internal fields of PropertyChangeEvent.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java\n+\t(arrowIcon): Made static.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java\n+\t(stateChanged): Dont use internal field on ChangeEvent.\n+\t* javax/swing/text/JTextComponent.java\n+\t(getUI): Call UIManager.getUI().\n+\t(updateUI): Use getUI().\n+\n+2004-03-19  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/JComponent.java: Turn off double buffer by default.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java: Clear rects before painting.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c\n+\t(Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable): \n+\tUse cairo to copy areas.\n+\t(Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClip):\n+\tInitialize and set clip region.\n+\n+2004-03-15  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/applet/Applet.java (preferredSize): Override deprecated\n+\tvariant of getPreferredSize.\n+\t(minimumSize): Override deprecated variant of getMinimumSize.\n+\n+2004-03-15  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(drawImage(img,xform,bgcolor,obs)): New Method.\n+\tHelper function that every drawImage method will\n+\tuse.\n+\t(drawRaster): Added new parameter, bgcolor. All\n+\ttransparent pixels are changed to bgcolor before \n+\timage is drawn.\n+\t(drawRenderedImage): Fixed to use changed drawRaster().\n+\t(drawImage(image,xform,obs): Fixed to use new helper function \n+\t(drawImage(image,op,x,y)): Ditto.\n+\t(drawImage (img,x,y,observer)): Ditto.\n+\t((PainterThread) bgcolor): New Field.\n+\t((PainterThread) (setPixels)): Changed all transparent pixels \n+\tto bgcolor.\t\n+\t(drawImage(img,x,y,width,height,bgcolor,observer)): \n+\tFixed FIXME - all the transparent pixels are \n+\tchanged to the specified bgcolor. \n+\t(drawImage(img, x, y, width, height, observer): Changed to \n+\tuse function above.\n+\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,bgcolor,observer)): \n+\tFixed FIXME- changed all transparent pixels to bgcolor.\n+\t(drawImage (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer)):\n+\tChanged to use function above. \n+\n+2004-03-14  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/applet/Applet.java (dimensions): New field.\n+\t(getDimensions): New method.\n+\t(getPreferredSize): Call getDimensions.\n+\t(getMinimumSize): Likewise.\n+\n+2004-03-13  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/classpath/jcl.c: Include stdlib.h, not malloc.h.\n+\t* jni/classpath/jnilink.c: Likewise.\n+\n+\t* java/applet/Applet.java (getPreferredSize): New method.\n+\t(getMinimumSize): New method.\n+\n 2004-04-15  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* prims.cc (_Jv_AllocObject): Remove `size' argument."}, {"sha": "f6047b88a3f46a0de821349eeade9bff655af18f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1326,17 +1326,21 @@ javax/swing/border/TitledBorder.java \\\n javax/swing/GrayFilter.java \\\n javax/swing/AbstractAction.java \\\n javax/swing/AbstractButton.java \\\n+javax/swing/plaf/basic/BasicArrowButton.java \\\n javax/swing/plaf/basic/BasicButtonListener.java \\\n javax/swing/plaf/basic/BasicButtonUI.java \\\n javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n+javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n+javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java \\\n+javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java \\\n javax/swing/plaf/basic/BasicScrollBarUI.java \\\n javax/swing/plaf/basic/BasicScrollPaneUI.java \\\n javax/swing/plaf/basic/BasicSeparatorUI.java \\"}, {"sha": "a496ae772c6a684e2b74a787b93837584e666869", "filename": "libjava/Makefile.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1008,17 +1008,21 @@ javax/swing/border/TitledBorder.java \\\n javax/swing/GrayFilter.java \\\n javax/swing/AbstractAction.java \\\n javax/swing/AbstractButton.java \\\n+javax/swing/plaf/basic/BasicArrowButton.java \\\n javax/swing/plaf/basic/BasicButtonListener.java \\\n javax/swing/plaf/basic/BasicButtonUI.java \\\n javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n+javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n+javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java \\\n+javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java \\\n javax/swing/plaf/basic/BasicScrollBarUI.java \\\n javax/swing/plaf/basic/BasicScrollPaneUI.java \\\n javax/swing/plaf/basic/BasicSeparatorUI.java \\\n@@ -4533,18 +4537,22 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/TextUI.P .deps/javax/swing/plaf/ToolBarUI.P \\\n .deps/javax/swing/plaf/ToolTipUI.P .deps/javax/swing/plaf/TreeUI.P \\\n .deps/javax/swing/plaf/UIResource.P .deps/javax/swing/plaf/ViewportUI.P \\\n+.deps/javax/swing/plaf/basic/BasicArrowButton.P \\\n .deps/javax/swing/plaf/basic/BasicBorders.P \\\n .deps/javax/swing/plaf/basic/BasicButtonListener.P \\\n .deps/javax/swing/plaf/basic/BasicButtonUI.P \\\n+.deps/javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.P \\\n .deps/javax/swing/plaf/basic/BasicCheckBoxUI.P \\\n .deps/javax/swing/plaf/basic/BasicGraphicsUtils.P \\\n .deps/javax/swing/plaf/basic/BasicIconFactory.P \\\n .deps/javax/swing/plaf/basic/BasicLabelUI.P \\\n .deps/javax/swing/plaf/basic/BasicListUI.P \\\n .deps/javax/swing/plaf/basic/BasicLookAndFeel.P \\\n+.deps/javax/swing/plaf/basic/BasicMenuItemUI.P \\\n .deps/javax/swing/plaf/basic/BasicOptionPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicPanelUI.P \\\n .deps/javax/swing/plaf/basic/BasicProgressBarUI.P \\\n+.deps/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.P \\\n .deps/javax/swing/plaf/basic/BasicRadioButtonUI.P \\\n .deps/javax/swing/plaf/basic/BasicRootPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicScrollBarUI.P \\"}, {"sha": "633eb096483209c1be457d92d016cb1087a727a2", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 117, "deletions": 82, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -201,7 +201,7 @@ public Graphics create (int x, int y, int width, int height)\n     // draw current buffered image to the pixmap associated \n     // with it.\n     \n-    drawImage (bimage, new AffineTransform (1,0,0,1,0,0), null);\n+    drawImage (bimage, new AffineTransform (1,0,0,1,0,0), bg, null);\n   }\n \n \n@@ -440,6 +440,69 @@ private void updateImagePixels (int[] pixels)\n   }\n \n \n+  private boolean drawImage(Image img, \n+                            AffineTransform xform,\n+                            Color bgcolor,\t\t\t    \n+                            ImageObserver obs)\n+  {\n+    if (img instanceof GtkOffScreenImage &&\n+        img.getGraphics () instanceof GdkGraphics2D &&            \n+        (xform == null \n+         || xform.getType () == AffineTransform.TYPE_IDENTITY \n+         || xform.getType () == AffineTransform.TYPE_TRANSLATION)\n+        ) \n+      {\n+        // we are being asked to flush a double buffer from Gdk\n+        GdkGraphics2D g2 = (GdkGraphics2D) img.getGraphics ();\n+        gdkDrawDrawable (g2, (int)xform.getTranslateX(), (int)xform.getTranslateY());\n+        \n+        if (isBufferedImageGraphics ()) \n+          updateBufferedImage();   \n+\t \n+        return true;\n+      }\n+    else\n+      {\n+      \n+        // In this case, xform is an AffineTransform that transforms bounding\n+        // box of the specified image from image space to user space. However\n+        // when we pass this transform to cairo, cairo will use this transform\n+        // to map \"user coordinates\" to \"pixel\" coordinates, which is the \n+        // other way around. Therefore to get the \"user -> pixel\" transform \n+        // that cairo wants from \"image -> user\" transform that we currently\n+        // have, we will need to invert the transformation matrix.\n+\t\n+        AffineTransform invertedXform = new AffineTransform();\n+\n+        try\n+          {             \n+\t      invertedXform = xform.createInverse();\n+             if (img instanceof BufferedImage)\n+               {\n+                   // draw an image which has actually been loaded \n+                   // into memory fully\n+                   \n+\t\t     BufferedImage b = (BufferedImage) img;\n+                   return drawRaster (b.getColorModel (), \n+                                      b.getData (), \n+                                      invertedXform,\n+                                      bgcolor);\n+               }\n+             else\n+               {\n+                   // begin progressive loading in a separate thread\n+                   new PainterThread (this, img, invertedXform, bgcolor);\n+                   return false;\n+               }\t       \n+          }\n+        catch (NoninvertibleTransformException e)\n+          {\n+              throw new ImagingOpException(\"Unable to invert transform \" \n+                                           + xform.toString());\n+          } \t      \n+      }\n+  }\n+\n \n   //////////////////////////////////////////////////\n   ////// Implementation of Graphics2D Methods //////\n@@ -965,7 +1028,8 @@ public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n   }\n \n   private boolean drawRaster (ColorModel cm, Raster r, \n-                              AffineTransform imageToUser)\n+                              AffineTransform imageToUser, \n+                              Color bgcolor)\n   {\n     if (r == null)\n       return false;\n@@ -1012,6 +1076,18 @@ private boolean drawRaster (ColorModel cm, Raster r,\n         pixels = pixels2;\n       }\n     \n+    // change all transparent pixels in the image to the \n+    // specified bgcolor\n+            \n+    if (bgcolor != null) \n+      {\n+        for (int i = 0; i < pixels.length; i++) \n+          {\n+            if (cm.getAlpha (pixels[i]) == 0) \n+              pixels[i] = bgcolor.getRGB ();\t    \n+          }\n+      } \n+\n     stateSave ();\n     translate (x, y);\n     drawPixels (pixels, r.getWidth (), r.getHeight (), r.getWidth (), i2u);\n@@ -1026,7 +1102,7 @@ private boolean drawRaster (ColorModel cm, Raster r,\n   public void drawRenderedImage(RenderedImage image,\n                                 AffineTransform xform)\n   {\n-    drawRaster (image.getColorModel(), image.getData(), xform);\n+    drawRaster (image.getColorModel(), image.getData(), xform, bg);\n   }\n   \n   public void drawRenderableImage(RenderableImage image,\n@@ -1039,60 +1115,7 @@ public boolean drawImage(Image img,\n                            AffineTransform xform,\n                            ImageObserver obs)\n   {\n-    if (img instanceof GtkOffScreenImage &&\n-        img.getGraphics () instanceof GdkGraphics2D &&            \n-        (xform == null \n-         || xform.getType () == AffineTransform.TYPE_IDENTITY \n-         || xform.getType () == AffineTransform.TYPE_TRANSLATION)\n-        ) \n-      {\n-        // we are being asked to flush a double buffer from Gdk\n-        GdkGraphics2D g2 = (GdkGraphics2D) img.getGraphics ();\n-        gdkDrawDrawable (g2, (int)xform.getTranslateX(), (int)xform.getTranslateY());\n-        \n-        if (isBufferedImageGraphics ()) \n-          updateBufferedImage();   \n-\t \n-        return true;\n-      }\n-    else\n-      {\n-      \n-        // In this case, xform is an AffineTransform that transforms bounding\n-        // box of the specified image from image space to user space. However\n-        // when we pass this transform to cairo, cairo will use this transform\n-        // to map \"user coordinates\" to \"pixel\" coordinates, which is the \n-        // other way around. Therefore to get the \"user -> pixel\" transform \n-        // that cairo wants from \"image -> user\" transform that we currently\n-        // have, we will need to invert the transformation matrix.\n-\t\n-        AffineTransform invertedXform = new AffineTransform();\n-\n-        try\n-          {             \n-\t      invertedXform = xform.createInverse();\n-             if (img instanceof BufferedImage)\n-               {\n-                   // draw an image which has actually been loaded \n-                   // into memory fully\n-                   BufferedImage b = (BufferedImage) img;\n-                   return drawRaster (b.getColorModel (), \n-                                      b.getData (), \n-                                      invertedXform);\n-               }\n-             else\n-               {\n-                   // begin progressive loading in a separate thread\n-                   new PainterThread (this, img, invertedXform);\n-                   return false;\n-               }\t       \n-          }\n-        catch (NoninvertibleTransformException e)\n-          {\n-              throw new ImagingOpException(\"Unable to invert transform \" \n-                                           + xform.toString());\n-          } \t      \n-      }\n+    return drawImage(img, xform, bg, obs); \n   }\n \n   public void drawImage(BufferedImage image,\n@@ -1101,13 +1124,13 @@ public void drawImage(BufferedImage image,\n                         int y)\n   {\n     Image filtered = op.filter(image, null);\n-    drawImage(filtered, new AffineTransform(1f,0f,0f,1f,x,y), null);\n+    drawImage(filtered, new AffineTransform(1f,0f,0f,1f,x,y), bg, null);\n   }\n \n   public boolean drawImage (Image img, int x, int y, \n                             ImageObserver observer)\n   {\n-    return drawImage(img, new AffineTransform(1f,0f,0f,1f,x,y), observer);    \n+    return drawImage(img, new AffineTransform(1f,0f,0f,1f,x,y), bg, observer);    \n   }\n \n \n@@ -1130,11 +1153,14 @@ private class PainterThread implements Runnable, ImageConsumer\n     Image image;\n     ColorModel defaultModel;\n     AffineTransform xform;\n+    Color bgcolor;\n \n-    public PainterThread (GdkGraphics2D g, Image im, AffineTransform xf)\n+    public PainterThread (GdkGraphics2D g, Image im, \n+                          AffineTransform xf, Color bg)\n     {\n       image = im;\n       xform = xf;\n+      bgcolor = bg;\n       this.gr = (GdkGraphics2D) g.create ();\n       new Thread (this).start ();\n     }\n@@ -1184,6 +1210,18 @@ public void setPixels (int x, int y, int w, int h, ColorModel model,\n         else\n           pixels2 = pixels;\n \n+        // change all transparent pixels in the image to the \n+        // specified bgcolor\n+            \n+        if (bgcolor != null) \n+          {\n+            for (int i = 0; i < pixels2.length; i++) \n+              {\n+                if (model.getAlpha (pixels2[i]) == 0) \n+                pixels2[i] = bgcolor.getRGB ();\t    \n+              }\n+          } \n+\n         double[] xf = new double[6];\n         xform.getMatrix(xf);        \n         gr.drawPixels (pixels2, w, h, scansize, xf);\n@@ -1347,40 +1385,27 @@ public boolean drawImage (Image img, int x, int y, int width, int height,\n                             Color bgcolor, ImageObserver observer)\n   {\n    \n-    // FIXME: change all the transparent pixels in the image to\n-    // bgcolor.\n-\n-    return drawImage (img, x, y, width, height, observer);\n-  }\n-\n-  public boolean drawImage (Image img, int x, int y, int width, int height, \n-                            ImageObserver observer)\n-  {\n-\n     double scaleX =  width / (double) img.getWidth (observer);           \n     double scaleY =  height / (double) img.getHeight (observer);\n \n     return drawImage (img, \n                       new AffineTransform(scaleX, 0f, 0f, scaleY, x, y),\n+                      bgcolor,\n                       observer);\n \n   }\n \n-  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n-                            int sx1, int sy1, int sx2, int sy2, \n-                            Color bgcolor, ImageObserver observer)\n+  public boolean drawImage (Image img, int x, int y, int width, int height, \n+                            ImageObserver observer)\n   {\n-  \n-    // FIXME: change all transparent pixels in the image to \n-    // bgcolor\n-       \n-    return drawImage (img, dx1, dy1, dx2, dy2, \n-                      sx1, sy1, sx2, sy2, observer);\t\n+\n+    return drawImage (img, x, y, width, height, bg, observer);\n+\n   }\n \n   public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n                             int sx1, int sy1, int sx2, int sy2, \n-                            ImageObserver observer) \n+                            Color bgcolor, ImageObserver observer)\n   {\n   \n     Image subImage;\t\n@@ -1420,8 +1445,18 @@ public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2,\n       }\n \n     return drawImage(subImage, new AffineTransform(scaleX, 0, 0,\n-                                                  scaleY, dx1, dy1), \n-                                                  observer);\n+                                                   scaleY, dx1, dy1), \n+                                                   bgcolor,\n+                                                   observer);\n+  }\n+\n+  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n+                            int sx1, int sy1, int sx2, int sy2, \n+                            ImageObserver observer) \n+  {\n+\n+    return drawImage (img, dx1, dy1, dx2, dy2, \n+                      sx1, sy1, sx2, sy2, bg, observer);\t  \n   }\n \n   public void drawOval(int x, int y, int width, int height)"}, {"sha": "55581d1c64ed81f5cce2a5bc48d903dc102db52f", "filename": "libjava/gnu/java/awt/peer/gtk/GtkMenuItemPeer.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuItemPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuItemPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuItemPeer.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -50,13 +50,17 @@ public class GtkMenuItemPeer extends GtkMenuComponentPeer\n   implements MenuItemPeer\n {\n   native void create (String label);\n+  public native void connectSignals ();\n \n   public GtkMenuItemPeer (MenuItem item)\n   {\n     super (item);\n     create (item.getLabel ());\n     setEnabled (item.isEnabled ());\n     setParent (item);\n+\n+    if (item.getParent() instanceof Menu && ! (item instanceof Menu))\n+      connectSignals();\n   }\n \n   void setParent (MenuItem item)"}, {"sha": "9b3f678856e8b530e6b881ae43266a6996b3ee10", "filename": "libjava/gnu/java/awt/peer/gtk/GtkMenuPeer.java", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkMenuPeer.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -95,10 +95,5 @@ public void addItem (MenuItemPeer item, MenuShortcut ms)\n     addItem (item, key, shiftModifier);\n   }\n \n-  public void addSeparator ()\n-  {\n-    addItem (new MenuItem (\"-\"));\n-  }\n-\n   native public void delItem (int index);\n }"}, {"sha": "70aab2ca59db6ffd24c1ec73c5916d14afd54807", "filename": "libjava/gnu/java/awt/peer/gtk/GtkPanelPeer.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -46,7 +46,6 @@ public class GtkPanelPeer extends GtkContainerPeer\n {\n   native void create ();\n   native void connectJObject ();\n-  native void connectSignals ();\n \n   public GtkPanelPeer (Panel p)\n   {"}, {"sha": "27c8aafb7fb9eb66b26163cb2769cd12b3c1fd72", "filename": "libjava/java/applet/Applet.java", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fapplet%2FApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fapplet%2FApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fapplet%2FApplet.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -77,6 +77,11 @@ public class Applet extends Panel\n   /** The applet stub for this applet. */\n   private transient AppletStub stub;\n \n+  /**\n+   * The dimensions passed to this applet through its HTML tag.\n+   */\n+  private transient Dimension dimensions;\n+\n   /**\n    * The accessibility context for this applet.\n    *\n@@ -457,6 +462,41 @@ private void readObject(ObjectInputStream s)\n     s.defaultReadObject();\n   }\n \n+  private Dimension getDimensions ()\n+  {\n+    if (dimensions == null)\n+      {\n+\tint width = Integer.parseInt(stub.getParameter(\"width\"));\n+\tint height = Integer.parseInt(stub.getParameter(\"height\"));\n+\n+\tdimensions = new Dimension(width, height);\n+      }\n+\n+    return dimensions;\n+  }\n+\n+  /**\n+   * Returns an instance of {@link Dimension} representing the\n+   * applet's width and height parameters.\n+   *\n+   * @return the applet's preferred size\n+   */\n+  public Dimension preferredSize()\n+  {\n+    return getDimensions ();\n+  }\n+\n+  /**\n+   * Returns an instance of {@link Dimension} representing the\n+   * applet's width and height parameters.\n+   *\n+   * @return the applet's minimum size\n+   */\n+  public Dimension minimumSize()\n+  {\n+    return getDimensions ();\n+  }\n+\n   /**\n    * This class provides accessibility support for Applets, and is the\n    * runtime type returned by {@link #getAccessibleContext()}."}, {"sha": "bfd4e080f78222e8b1e11d773261a2159f50d867", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -3816,6 +3816,12 @@ public synchronized void add(PopupMenu popup)\n     if (popups == null)\n       popups = new Vector();\n     popups.add(popup);\n+\n+    if (popup.parent != null)\n+      popup.parent.remove(popup);\n+    popup.parent = this;\n+    if (peer != null)\n+      popup.addNotify();\n   }\n \n   /**"}, {"sha": "0d551b2081f738ebb298d04055807c2dd4ab2b76", "filename": "libjava/java/awt/Graphics.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGraphics.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -417,7 +417,7 @@\n   drawLine(x1, y2, x1, y1);\n   setColor(br);\n   drawLine(x2, y1, x2, y2);\n-  drawLine(x2, y1, x1, y2);\n+  drawLine(x2, y2, x1, y2);\n   setColor(color);\n }\n "}, {"sha": "c6c4f214dce3e7311ca6e12c95c8fca79f2483eb", "filename": "libjava/java/awt/Menu.java", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenu.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -82,7 +82,7 @@ public class Menu extends MenuItem implements MenuContainer, Serializable\n // From the serialization spec.  FIXME: what should it be?\n private int menuSerializedDataVersion;\n \n-static final MenuItem separator = new MenuItem(\"-\");\n+static final String separatorLabel = \"-\";\n \n /*************************************************************************/\n \n@@ -295,8 +295,7 @@ public int countItems ()\n public void\n addSeparator()\n {\n-  if (peer != null)\n-    ((MenuPeer) peer).addSeparator();\n+  add(new MenuItem(separatorLabel));\n }\n \n /*************************************************************************/\n@@ -314,7 +313,7 @@ public int countItems ()\n public void\n insertSeparator(int index)\n {\n-  insert(separator, index);\n+  insert(new MenuItem(separatorLabel), index);\n }\n \n /*************************************************************************/"}, {"sha": "4defc38279ecc51bbd53adb89dd21d88d2aeff80", "filename": "libjava/java/awt/MenuItem.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenuItem.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -310,7 +310,10 @@ public class MenuItem extends MenuComponent\n public String\n getActionCommand()\n {\n-  return(actionCommand);\n+  if (actionCommand == null)\n+    return label;\n+  else\n+    return actionCommand;\n }\n \n /*************************************************************************/"}, {"sha": "83ffb35a85e2c56c8ba27dbef4fe45cf928eeb61", "filename": "libjava/java/awt/PopupMenu.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FPopupMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2FPopupMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPopupMenu.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -105,7 +105,7 @@ public class PopupMenu extends Menu\n public void\n addNotify()\n {\n-  if (peer != null)\n+  if (peer == null)\n     peer = getToolkit ().createPopupMenu (this);\n   super.addNotify ();\n }\n@@ -123,6 +123,8 @@ public class PopupMenu extends Menu\n public void\n show(Component component, int x, int y)\n {\n+  if (getPeer() == null)\n+    this.addNotify();\n   PopupMenuPeer pmp = (PopupMenuPeer)getPeer();\n   if (pmp != null)\n     {"}, {"sha": "0b15914d05b8e3e59c4d8fae62f4051a0bdf97c5", "filename": "libjava/java/awt/peer/MenuPeer.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2Fpeer%2FMenuPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Fawt%2Fpeer%2FMenuPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fpeer%2FMenuPeer.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -43,7 +43,6 @@\n public interface MenuPeer extends MenuItemPeer\n {\n   void addItem (MenuItem item);\n-  void addSeparator ();\n   void delItem (int index);\n }\n "}, {"sha": "46cbf92d52683c78bcef3700beb3eebb7ea827e8", "filename": "libjava/java/text/AttributedString.java", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Ftext%2FAttributedString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Ftext%2FAttributedString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAttributedString.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -38,6 +38,7 @@\n \n package java.text;\n \n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.HashMap;\n import java.util.Hashtable;\n@@ -219,26 +220,7 @@\n   // Get the valid attribute list\n   Set all_attribs = aci.getAllAttributeKeys();\n   if (attributes != null)\n-    {\n-      Set valid_attribs = new HashSet();\n-      Iterator iter = all_attribs.iterator();\n-      while (iter.hasNext())\n-        {\n-          Object obj = iter.next();\n-\n-          int i;\n-          for (i = 0; i < attributes.length; i++)\n-            if (obj.equals(attributes[0]))\n-              break;\n-\n-          if (i == attributes.length)\n-            continue;\n-\n-          valid_attribs.add(obj);\n-        }\n-\n-      all_attribs = valid_attribs;\n-    } \n+    all_attribs.retainAll(Arrays.asList(attributes));\n \n   // Loop through and extract the attributes\n   char c = aci.setIndex(begin_index);\n@@ -320,7 +302,7 @@\n public void\n addAttribute(AttributedCharacterIterator.Attribute attrib, Object value)\n {\n-  addAttribute(attrib, value, 0, sci.getEndIndex() - 1);\n+  addAttribute(attrib, value, 0, sci.getEndIndex());\n }\n \n /*************************************************************************/\n@@ -389,8 +371,7 @@\n public AttributedCharacterIterator\n getIterator()\n {\n-  return(new AttributedStringIterator(sci, attribs, 0, sci.getEndIndex() - 1,\n-                                      null));\n+  return(new AttributedStringIterator(sci, attribs, 0, sci.getEndIndex(), null));\n }\n \n /*************************************************************************/\n@@ -409,7 +390,7 @@\n public AttributedCharacterIterator\n getIterator(AttributedCharacterIterator.Attribute[] attributes)\n {\n-  return(getIterator(attributes, 0, sci.getEndIndex() - 1));\n+  return(getIterator(attributes, 0, sci.getEndIndex()));\n }\n \n /*************************************************************************/"}, {"sha": "98204574c86797c9867ae2fb74dd093726596c78", "filename": "libjava/java/text/AttributedStringIterator.java", "status": "modified", "additions": 38, "deletions": 56, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FAttributedStringIterator.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -221,39 +221,28 @@ class AttributedStringIterator implements AttributedCharacterIterator\n public synchronized int\n getRunLimit(Set attribute_set)\n {\n-  int orig_index = ci.getIndex();\n-  int run_limit;\n+  boolean hit = false;\n+  int runLimit = ci.getEndIndex ();\n+  int pos = ci.getIndex ();\n \n-  do  \n+  for (int i = 0; i < attribs.length; ++i)\n     {\n-      run_limit = ci.getIndex();\n-\n-      Map attribute_map = getAttributes();\n-\n-      boolean found = false;\n-      Iterator iter = attribute_set.iterator();\n-      while(iter.hasNext()) \n-        if (!attribute_map.containsKey(iter.next()))\n-          {\n-            found = true;\n-            break;\n-          }\n-\n-      if (found)\n-        break;\n+      if (pos >= attribs[i].begin_index &&\n+          pos <= attribs[i].end_index)\n+        {\n+          Iterator iter = attribute_set.iterator();\n+          while(iter.hasNext()) \n+            if (attribs[i].attribs.containsKey(iter.next()))\n+              {\n+                hit = true;\n+                runLimit = Math.min(runLimit, attribs[i].end_index);\n+              }\n+        }\n     }\n-  while (ci.next() != CharacterIterator.DONE);\n-\n-  boolean hit_end = (ci.previous() == CharacterIterator.DONE);\n-\n-  ci.setIndex(orig_index);\n-\n-  if (run_limit == orig_index)\n-    return(-1); // No characters match the given attributes\n-//  else if (!hit_end)\n-//    --run_limit;\n-\n-  return(run_limit); \n+  if (hit)\n+    return runLimit;\n+  else\n+    return -1;\n }\n \n /*************************************************************************/\n@@ -281,35 +270,28 @@ class AttributedStringIterator implements AttributedCharacterIterator\n public int\n getRunStart(Set attribute_set)\n {\n-  int orig_index = ci.getIndex();\n-  int run_start;\n+  boolean hit = false;\n+  int runBegin = 0;\n+  int pos = ci.getIndex ();\n \n-  do  \n+  for (int i = 0; i < attribs.length; ++i)\n     {\n-      run_start = ci.getIndex();\n-\n-      Map attribute_map = getAttributes();\n-\n-      Iterator iter = attribute_set.iterator();\n-      while(iter.hasNext())\n-        if (!attribute_map.containsKey(iter.next()))\n-          break;\n-\n-      if (iter.hasNext())\n-        break;\n+      if (pos >= attribs[i].begin_index &&\n+          pos <= attribs[i].end_index)\n+        {\n+          Iterator iter = attribute_set.iterator();\n+          while(iter.hasNext()) \n+            if (attribs[i].attribs.containsKey(iter.next()))\n+              {\n+                hit = true;\n+                runBegin = Math.max(runBegin, attribs[i].begin_index);\n+              }\n+        }\n     }\n-  while (ci.previous() != CharacterIterator.DONE);\n-\n-  boolean hit_beginning = (ci.previous() == CharacterIterator.DONE);\n-\n-  ci.setIndex(orig_index);\n-\n-  if (run_start == orig_index)\n-    return(-1); // No characters match the given attributes\n-  else if (!hit_beginning)\n-    ++run_start;\n-\n-  return(run_start); \n+  if (hit)\n+    return runBegin;\n+  else\n+    return -1;\n }\n \n /*************************************************************************/"}, {"sha": "e3f990d2f8848391b89d28bcebaf884e929a37d8", "filename": "libjava/javax/swing/DefaultSingleSelectionModel.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FDefaultSingleSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FDefaultSingleSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultSingleSelectionModel.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -115,7 +115,7 @@ public void clearSelection ()\n    */\n   public boolean isSelected ()\n   {\n-    return (index == -1);\n+    return (index != -1);\n   }\n \n   /**"}, {"sha": "e68d4538ee5f613e176bed0f156baac06e1f6d7f", "filename": "libjava/javax/swing/ImageIcon.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FImageIcon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FImageIcon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FImageIcon.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -56,7 +56,10 @@ public class ImageIcon implements Icon\n \n   public ImageIcon(String s)\n     {\n-\tthis(s, \"\");\n+    \t// if description is not specified, then file name becomes\n+\t// desciption for this icon\n+\t\n+\tthis(s, s);\n     }\n \n   public ImageIcon(String file,"}, {"sha": "968b25e9d41fb5c3a481b402b92d75b098e3f40f", "filename": "libjava/javax/swing/JCheckBoxMenuItem.java", "status": "modified", "additions": 126, "deletions": 197, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -39,206 +39,135 @@\n \n import java.io.IOException;\n import java.io.ObjectOutputStream;\n+\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n \n-/**\n- * JCheckBoxMenuItem\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n- */\n-public class JCheckBoxMenuItem extends JMenuItem implements SwingConstants, Accessible\n-{\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJCheckBoxMenuItem\n-\t */\n-\tprotected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJCheckBoxMenuItem\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJCheckBoxMenuItem(JCheckBoxMenuItem component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJCheckBoxMenuItem()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.CHECK_BOX;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJCheckBoxMenuItem\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"CheckBoxMenuItemUI\";\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t */\n-\tpublic JCheckBoxMenuItem() {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param icon TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(Icon icon) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param text TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(String text) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param action TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(Action action) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(String text, Icon icon) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param text TODO\n-\t * @param state TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(String text, boolean state) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\t/**\n-\t * Constructor JCheckBoxMenuItem\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t * @param state TODO\n-\t */\n-\tpublic JCheckBoxMenuItem(String text, Icon icon, boolean state) {\n-\t\t// TODO\n-\t} // JCheckBoxMenuItem()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * getState\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getState() {\n-\t\treturn false; // TODO\n-\t} // getState()\n-\n-\t/**\n-\t * setState\n-\t * @param state TODO\n-\t */\n-\tpublic synchronized void setState(boolean state) {\n-\t\t// TODO\n-\t} // setState()\n-\n-\t/**\n-\t * getSelectedObjects\n-\t * @returns Object[]\n-\t */\n-\tpublic Object[] getSelectedObjects() {\n-\t\treturn null; // TODO\n-\t} // getSelectedObjects()\n-\n-\t/**\n-\t * requestFocus\n-\t */\n-\tpublic void requestFocus() {\n-\t\t// TODO\n-\t} // requestFocus()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJCheckBoxMenuItem(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n \n+public class JCheckBoxMenuItem extends JMenuItem implements SwingConstants,\n+                                                            Accessible\n+{\n+  //-------------------------------------------------------------\n+  // Variables --------------------------------------------------\n+  //-------------------------------------------------------------\n+  private static final String uiClassID = \"CheckBoxMenuItemUI\";\n+  private boolean state;\n+  private Object[] selectedObjects;\n+\n+  //-------------------------------------------------------------\n+  // Initialization ---------------------------------------------\n+  //-------------------------------------------------------------\n+  public JCheckBoxMenuItem()\n+  {\n+    this(null, null);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(Icon icon)\n+  {\n+    this(null, icon);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(String text)\n+  {\n+    this(text, null);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(Action action)\n+  {\n+    this();\n+    setAction(action);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(String text, Icon icon)\n+  {\n+    this(text, icon, false);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(String text, boolean state)\n+  {\n+    this(text, null, state);\n+  } // JCheckBoxMenuItem()\n+\n+  public JCheckBoxMenuItem(String text, Icon icon, boolean state)\n+  {\n+    super(text, icon);\n+    setModel(new JToggleButton.ToggleButtonModel());\n+    this.state = state;\n+  } // JCheckBoxMenuItem()\n+\n+  //-------------------------------------------------------------\n+  // Methods ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+    // TODO\n+  } // writeObject()\n+\n+  public String getUIClassID()\n+  {\n+    return uiClassID;\n+  } // getUIClassID()\n+\n+  public boolean getState()\n+  {\n+    return state;\n+  } // getState()\n+\n+  public synchronized void setState(boolean state)\n+  {\n+    this.state = state;\n+  } // setState()\n+\n+  public Object[] getSelectedObjects()\n+  {\n+    return selectedObjects;\n+  } // getSelectedObjects()\n+\n+  public void requestFocus()\n+  {\n+    // TODO\n+  } // requestFocus()\n+\n+  protected String paramString()\n+  {\n+    return \"JCheckBoxMenuItem\";\n+  } // paramString()\n+\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      {\n+        accessibleContext = new AccessibleJCheckBoxMenuItem(this);\n+      }\n+\n+    return accessibleContext;\n+  } // getAccessibleContext()\n+\n+  //-------------------------------------------------------------\n+  // Classes ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem\n+  {\n+    //-------------------------------------------------------------\n+    // Variables --------------------------------------------------\n+    //-------------------------------------------------------------\n+    //-------------------------------------------------------------\n+    // Initialization ---------------------------------------------\n+    //-------------------------------------------------------------\n+    protected AccessibleJCheckBoxMenuItem(JCheckBoxMenuItem component)\n+    {\n+      super(component);\n+\n+      // TODO\n+    } // AccessibleJCheckBoxMenuItem()\n+\n+    //-------------------------------------------------------------\n+    // Methods ----------------------------------------------------\n+    //-------------------------------------------------------------\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.CHECK_BOX;\n+    } // getAccessibleRole()\n+  } // AccessibleJCheckBoxMenuItem\n } // JCheckBoxMenuItem"}, {"sha": "633ce6647327e739adcbd3ec478b10aeb583c09c", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -100,7 +100,7 @@ public abstract class JComponent extends Container implements Serializable\n   Border border;\n   JToolTip tooltip;\n   String tool_tip_text;\n-  boolean use_double_buffer, opaque;\n+  boolean use_double_buffer = false, opaque;\n   Image doubleBuffer;\n   int doubleBufferWidth = -1;\n   int doubleBufferHeight = -1;"}, {"sha": "c6bc1bd3ca8dc1d1295cfbf6f0c9bb137e47ad1b", "filename": "libjava/javax/swing/JLabel.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJLabel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJLabel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLabel.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -289,7 +289,7 @@ public void setText(String text)\n \tString oldText = labelText;\n \tlabelText = text;\n \tfirePropertyChange(TEXT_CHANGED_PROPERTY, oldText, labelText);\n-\tif (labelText.length() <= underlinedChar)\n+\tif (labelText != null && labelText.length() <= underlinedChar)\n \t  setDisplayedMnemonicIndex(labelText.length() - 1);\n       }\n   }"}, {"sha": "68e8bfeacfcbaf844c00e535baff9309215d6537", "filename": "libjava/javax/swing/JMenuItem.java", "status": "modified", "additions": 257, "deletions": 414, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuItem.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -41,13 +41,15 @@\n import java.awt.Component;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.swing.UIManager;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.MenuDragMouseEvent;\n@@ -56,418 +58,259 @@\n import javax.swing.event.MenuKeyListener;\n import javax.swing.plaf.MenuItemUI;\n \n-/**\n- * JMenuItem\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n- */\n-public class JMenuItem extends AbstractButton implements Accessible, MenuElement {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJMenuItem\n-\t */\n-\tprotected class AccessibleJMenuItem extends AccessibleAbstractButton \n-\t\t\timplements ChangeListener {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJMenuItem\n-\t\t * @param component TODO\n-\t\t */\n-\t\tAccessibleJMenuItem(JMenuItem component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJMenuItem()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * stateChanged\n-\t\t * @param event TODO\n-\t\t */\n-\t\tpublic void stateChanged(ChangeEvent event) {\n-\t\t\t// TODO\n-\t\t} // stateChanged()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.MENU_ITEM;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJMenuItem\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"MenuItemUI\";\n-\n-\t/**\n-\t * accelerator\n-\t */\n-\tprivate KeyStroke accelerator;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t */\n-\tpublic JMenuItem() {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t * @param icon TODO\n-\t */\n-\tpublic JMenuItem(Icon icon) {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t * @param text TODO\n-\t */\n-\tpublic JMenuItem(String text) {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t * @param action TODO\n-\t */\n-\tpublic JMenuItem(Action action) {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t */\n-\tpublic JMenuItem(String text, Icon icon) {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\t/**\n-\t * Constructor JMenuItem\n-\t * @param text TODO\n-\t * @param mnemonic TODO\n-\t */\n-\tpublic JMenuItem(String text, int mnemonic) {\n-\t\t// TODO\n-\t} // JMenuItem()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * readObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t * @exception ClassNotFoundException TODO\n-\t */\n-\tprivate void readObject(ObjectInputStream stream) \n-\t\t\tthrows IOException, ClassNotFoundException {\n-\t\t// TODO\n-\t} // readObject()\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * init\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t */\n-\tprotected void init(String text, Icon icon) {\n-\t\t// TODO\n-\t} // init()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(MenuItemUI ui) {\n-\t\tsuper.setUI(ui);\n-\t\t// TODO\n-\t} // setUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((MenuItemUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * isArmed\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isArmed() {\n-\t\treturn false; // TODO\n-\t} // isArmed()\n-\n-\t/**\n-\t * setArmed\n-\t * @param armed TODO\n-\t */\n-\tpublic void setArmed(boolean armed) {\n-\t\t// TODO\n-\t} // setArmed()\n-\n-\t/**\n-\t * setEnabled\n-\t * @param enabled TODO\n-\t */\n-\tpublic void setEnabled(boolean enabled) {\n-\t\t// TODO\n-\t} // setEnabled()\n-\n-\t/**\n-\t * getAccelerator\n-\t * @returns KeyStroke\n-\t */\n-\tpublic KeyStroke getAccelerator() {\n-\t\treturn null; // TODO\n-\t} // getAccelerator()\n-\n-\t/**\n-\t * setAccelerator\n-\t * @param keystroke TODO\n-\t */\n-\tpublic void setAccelerator(KeyStroke keystroke) {\n-\t\t// TODO\n-\t} // setAccelerator()\n-\n-\t/**\n-\t * configurePropertiesFromAction\n-\t * @param action TODO\n-\t */\n-\tprotected void configurePropertiesFromAction(Action action) {\n-\t\t// TODO\n-\t} // configurePropertiesFromAction()\n-\n-\t/**\n-\t * createActionPropertyChangeListener\n-\t * @param action TODO\n-\t * @returns PropertyChangeListener\n-\t */\n-\tprotected PropertyChangeListener createActionPropertyChangeListener(Action action) {\n-\t\treturn null; // TODO\n-\t} // createActionPropertyChangeListener()\n-\n-\t/**\n-\t * processMouseEvent\n-\t * @param event TODO\n-\t * @param path TODO\n-\t * @param manager TODO\n-\t */\n-\tpublic void processMouseEvent(MouseEvent event, MenuElement[] path,\n-\t\t\tMenuSelectionManager manager) {\n-\t\t// TODO\n-\t} // processMouseEvent()\n-\n-\t/**\n-\t * processKeyEvent\n-\t * @param event TODO\n-\t * @param path TODO\n-\t * @param manager TODO\n-\t */\n-\tpublic void processKeyEvent(KeyEvent event, MenuElement[] path,\n-\t\t\tMenuSelectionManager manager) {\n-\t\t// TODO\n-\t} // processKeyEvent()\n-\n-\t/**\n-\t * processMenuDragMouseEvent\n-\t * @param event TODO\n-\t */\n-\tpublic void processMenuDragMouseEvent(MenuDragMouseEvent event) {\n-\t\t// TODO\n-\t} // processMenuDragMouseEvent()\n-\n-\t/**\n-\t * processMenuKeyEvent\n-\t * @param event TODO\n-\t */\n-\tpublic void processMenuKeyEvent(MenuKeyEvent event) {\n-\t\t// TODO\n-\t} // processMenuKeyEvent()\n-\n-\t/**\n-\t * fireMenuDragMouseEntered\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuDragMouseEntered(MenuDragMouseEvent event) {\n-\t\t// TODO\n-\t} // fireMenuDragMouseEntered()\n-\n-\t/**\n-\t * fireMenuDragMouseExited\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuDragMouseExited(MenuDragMouseEvent event) {\n-\t\t// TODO\n-\t} // fireMenuDragMouseExited()\n-\n-\t/**\n-\t * fireMenuDragMouseDragged\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuDragMouseDragged(MenuDragMouseEvent event) {\n-\t\t// TODO\n-\t} // fireMenuDragMouseDragged()\n-\n-\t/**\n-\t * fireMenuDragMouseReleased\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuDragMouseReleased(MenuDragMouseEvent event) {\n-\t\t// TODO\n-\t} // fireMenuDragMouseReleased()\n-\n-\t/**\n-\t * fireMenuKeyPressed\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuKeyPressed(MenuKeyEvent event) {\n-\t\t// TODO\n-\t} // fireMenuKeyPressed()\n-\n-\t/**\n-\t * fireMenuKeyReleased\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuKeyReleased(MenuKeyEvent event) {\n-\t\t// TODO\n-\t} // fireMenuKeyReleased()\n-\n-\t/**\n-\t * fireMenuKeyTyped\n-\t * @param event TODO\n-\t */\n-\tprotected void fireMenuKeyTyped(MenuKeyEvent event) {\n-\t\t// TODO\n-\t} // fireMenuKeyTyped()\n-\n-\t/**\n-\t * menuSelectionChanged\n-\t * @param changed TODO\n-\t */\n-\tpublic void menuSelectionChanged(boolean changed) {\n-\t\t// TODO\n-\t} // menuSelectionChanged()\n-\n-\t/**\n-\t * getSubElements\n-\t * @returns MenuElement[]\n-\t */\n-\tpublic MenuElement[] getSubElements() {\n-\t\treturn null; // TODO\n-\t} // getSubElements()\n-\n-\t/**\n-\t * getComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getComponent() {\n-\t\treturn null; // TODO\n-\t} // getComponent()\n-\n-\t/**\n-\t * addMenuDragMouseListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addMenuDragMouseListener(MenuDragMouseListener listener) {\n-\t\t// TODO\n-\t} // addMenuDragMouseListener()\n-\n-\t/**\n-\t * removeMenuDragMouseListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeMenuDragMouseListener(MenuDragMouseListener listener) {\n-\t\t// TODO\n-\t} // removeMenuDragMouseListener()\n-\n-\t/**\n-\t * addMenuKeyListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addMenuKeyListener(MenuKeyListener listener) {\n-\t\t// TODO\n-\t} // addMenuKeyListener()\n-\n-\t/**\n-\t * removeMenuKeyListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeMenuKeyListener(MenuKeyListener listener) {\n-\t\t// TODO\n-\t} // removeMenuKeyListener()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJMenuItem(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n+public class JMenuItem extends AbstractButton implements Accessible,\n+                                                         MenuElement\n+{\n+  //-------------------------------------------------------------\n+  // Variables --------------------------------------------------\n+  //-------------------------------------------------------------\n+  private static final String uiClassID = \"MenuItemUI\";\n+  private KeyStroke accelerator;\n+\n+  //-------------------------------------------------------------\n+  // Initialization ---------------------------------------------\n+  //-------------------------------------------------------------\n+  public JMenuItem()\n+  {\n+    this(null, null);\n+  } // JMenuItem()\n+\n+  public JMenuItem(Icon icon)\n+  {\n+    this(null, icon);\n+  } // JMenuItem()\n+\n+  public JMenuItem(String text)\n+  {\n+    this(text, null);\n+  } // JMenuItem()\n+\n+  public JMenuItem(Action action)\n+  {\n+    // TODO\t\t\n+  } // JMenuItem()\n+\n+  public JMenuItem(String text, Icon icon)\n+  {\n+    super(text, icon);\n+  } // JMenuItem()\n+\n+  public JMenuItem(String text, int mnemonic)\n+  {\n+    super(text, null);\n+    setMnemonic(mnemonic);\n+  } // JMenuItem()\n+\n+  //-------------------------------------------------------------\n+  // Methods ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  private void readObject(ObjectInputStream stream)\n+                   throws IOException, ClassNotFoundException\n+  {\n+    // TODO\n+  } // readObject()\n+\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+    // TODO\n+  } // writeObject()\n+\n+  protected void init(String text, Icon icon)\n+  {\n+    // TODO\n+  } // init()\n+\n+  public void setUI(MenuItemUI ui)\n+  {\n+    super.setUI(ui);\n+  } // setUI()\n+\n+  public void updateUI()\n+  {\n+    MenuItemUI mi = ((MenuItemUI) UIManager.getUI(this));\n+    setUI(mi);\n+    invalidate();\n+  } // updateUI()\n+\n+  public String getUIClassID()\n+  {\n+    return uiClassID;\n+  } // getUIClassID()\n+\n+  public boolean isArmed()\n+  {\n+    return getModel().isArmed();\n+  } // isArmed()\n+\n+  public void setArmed(boolean armed)\n+  {\n+    getModel().setArmed(armed);\n+  } // setArmed()\n+\n+  public void setEnabled(boolean enabled)\n+  {\n+    setEnabled(enabled);\n+  } // setEnabled()\n+\n+  public KeyStroke getAccelerator()\n+  {\n+    return accelerator;\n+  } // getAccelerator()\n+\n+  public void setAccelerator(KeyStroke keystroke)\n+  {\n+    this.accelerator = keystroke;\n+  } // setAccelerator()\n+\n+  protected void configurePropertiesFromAction(Action action)\n+  {\n+    super.configurePropertiesFromAction(action);\n+\n+    if (action == null)\n+      setAccelerator(null);\n+    else\n+      setAccelerator((KeyStroke) (action.getValue(Action.ACCELERATOR_KEY)));\n+  \n+  } // configurePropertiesFromAction()\n+\n+  protected PropertyChangeListener createActionPropertyChangeListener(Action action)\n+  {\n+    return null;\n+  } // createActionPropertyChangeListener()\n+\n+  public void processMouseEvent(MouseEvent event, MenuElement[] path,\n+                                MenuSelectionManager manager)\n+  {\n+    // TODO\n+  } // processMouseEvent()\n+\n+  public void processKeyEvent(KeyEvent event, MenuElement[] path,\n+                              MenuSelectionManager manager)\n+  {\n+    // TODO\n+  } // processKeyEvent()\n+\n+  public void processMenuDragMouseEvent(MenuDragMouseEvent event)\n+  {\n+  } // processMenuDragMouseEvent()\n+\n+  public void processMenuKeyEvent(MenuKeyEvent event)\n+  {\n+    // TODO\n+  } // processMenuKeyEvent()\n+\n+  protected void fireMenuDragMouseEntered(MenuDragMouseEvent event)\n+  {\n+    // TODO\n+  } // fireMenuDragMouseEntered()\n+\n+  protected void fireMenuDragMouseExited(MenuDragMouseEvent event)\n+  {\n+    // TODO\n+  } // fireMenuDragMouseExited()\n+\n+  protected void fireMenuDragMouseDragged(MenuDragMouseEvent event)\n+  {\n+    // TODO\n+  } // fireMenuDragMouseDragged()\n+\n+  protected void fireMenuDragMouseReleased(MenuDragMouseEvent event)\n+  {\n+    // TODO\n+  } // fireMenuDragMouseReleased()\n+\n+  protected void fireMenuKeyPressed(MenuKeyEvent event)\n+  {\n+    // TODO\n+  } // fireMenuKeyPressed()\n+\n+  protected void fireMenuKeyReleased(MenuKeyEvent event)\n+  {\n+    // TODO\n+  } // fireMenuKeyReleased()\n+\n+  protected void fireMenuKeyTyped(MenuKeyEvent event)\n+  {\n+    // TODO\n+  } // fireMenuKeyTyped()\n+\n+  public void menuSelectionChanged(boolean changed)\n+  {\n+    // TODO\n+  } // menuSelectionChanged()\n+\n+  public MenuElement[] getSubElements()\n+  {\n+    return null; // TODO\n+  } // getSubElements()\n+\n+  public Component getComponent()\n+  {\n+    return null; // TODO\n+  } // getComponent()\n+\n+  public void addMenuDragMouseListener(MenuDragMouseListener listener)\n+  {\n+    // TODO\n+  } // addMenuDragMouseListener()\n+\n+  public void removeMenuDragMouseListener(MenuDragMouseListener listener)\n+  {\n+  } // removeMenuDragMouseListener()\n+\n+  public void addMenuKeyListener(MenuKeyListener listener)\n+  {\n+  } // addMenuKeyListener()\n+\n+  public void removeMenuKeyListener(MenuKeyListener listener)\n+  {\n+  } // removeMenuKeyListener()\n+\n+  protected String paramString()\n+  {\n+    return \"JMenuItem\";\n+  } // paramString()\n+\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      {\n+        accessibleContext = new AccessibleJMenuItem(this);\n+      }\n+\n+    return accessibleContext;\n+  } // getAccessibleContext()\n+\n+  //-------------------------------------------------------------\n+  // Classes ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  protected class AccessibleJMenuItem extends AccessibleAbstractButton\n+    implements ChangeListener\n+  {\n+    //-------------------------------------------------------------\n+    // Variables --------------------------------------------------\n+    //-------------------------------------------------------------\n+    //-------------------------------------------------------------\n+    // Initialization ---------------------------------------------\n+    //-------------------------------------------------------------\n+    AccessibleJMenuItem(JMenuItem component)\n+    {\n+      super(component);\n+\n+      // TODO\n+    } // AccessibleJMenuItem()\n+\n+    //-------------------------------------------------------------\n+    // Methods ----------------------------------------------------\n+    //-------------------------------------------------------------\n+    public void stateChanged(ChangeEvent event)\n+    {\n+      // TODO\n+    } // stateChanged()\n+\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.MENU_ITEM;\n+    } // getAccessibleRole()\n+  } // AccessibleJMenuItem\n } // JMenuItem"}, {"sha": "6ee29334c5aebb9381969eda185b997aa0355843", "filename": "libjava/javax/swing/JProgressBar.java", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJProgressBar.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -185,9 +185,6 @@ public Number getMaximumAccessibleValue()\n   /** Fired in a PropertyChangeEvent when the \"indeterminate\" property changes. */\n   public static final String INDETERMINATE_CHANGED_PROPERTY = \"indeterminate\";\n \n-  /** A list of ChangeListeners registered with this ProgressBar. */\n-  private transient EventListenerList changeListenerList;\n-\n   /** Whether the ProgressBar is determinate. */\n   private transient boolean indeterminate = false;\n \n@@ -260,7 +257,6 @@ public JProgressBar(int minimum, int maximum, int orientation)\n     this.orientation = orientation;\n     changeListener = createChangeListener();\n     model.addChangeListener(changeListener);\n-    changeListenerList = new EventListenerList();\n     updateUI();\n   }\n \n@@ -275,7 +271,6 @@ public JProgressBar(BoundedRangeModel model)\n     this.model = model;\n     changeListener = createChangeListener();\n     model.addChangeListener(changeListener);\n-    changeListenerList = new EventListenerList();\n     updateUI();    \n   }\n \n@@ -511,7 +506,7 @@ public void stateChanged(ChangeEvent ce)\n    */\n   public void addChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.add(ChangeListener.class, listener);\n+    listenerList.add(ChangeListener.class, listener);\n   }\n \n   /**\n@@ -521,7 +516,7 @@ public void addChangeListener(ChangeListener listener)\n    */\n   public void removeChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.remove(ChangeListener.class, listener);\n+    listenerList.remove(ChangeListener.class, listener);\n   }\n   \n   /**\n@@ -532,7 +527,7 @@ public void removeChangeListener(ChangeListener listener)\n    */\n   public ChangeListener[] getChangeListeners()\n   {\n-    return (ChangeListener[]) changeListenerList.getListenerList();\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n   }  \n \n   /**\n@@ -542,7 +537,7 @@ public ChangeListener[] getChangeListeners()\n    */\n   protected void fireStateChanged()\n   {\n-    Object[] changeListeners = changeListenerList.getListenerList();\n+    Object[] changeListeners = listenerList.getListenerList();\n     if (changeEvent == null)\n       changeEvent = new ChangeEvent(this);\n     for (int i = changeListeners.length - 2; i >= 0; i -= 2)"}, {"sha": "cbaf7633d10a693828f93d7cb015b1eef20d844f", "filename": "libjava/javax/swing/JRadioButtonMenuItem.java", "status": "modified", "additions": 108, "deletions": 176, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -39,186 +39,118 @@\n \n import java.io.IOException;\n import java.io.ObjectOutputStream;\n+\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n \n-/**\n- * JRadioButtonMenuItem\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n- */\n+\n public class JRadioButtonMenuItem extends JMenuItem implements Accessible\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJRadioButtonMenuItem\n-\t */\n-\tprotected class AccessibleJRadioButtonMenuItem extends AccessibleJMenuItem {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJRadioButtonMenuItem\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJRadioButtonMenuItem(JRadioButtonMenuItem component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJRadioButtonMenuItem()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.RADIO_BUTTON;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJRadioButtonMenuItem\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"RadioButtonMenuItemUI\";\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t */\n-\tpublic JRadioButtonMenuItem() {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param icon TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(Icon icon) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param text TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(String text) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param action TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(Action action) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(String text, Icon icon) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param text TODO\n-\t * @param selected TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(String text, boolean selected) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param icon TODO\n-\t * @param selected TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(Icon icon, boolean selected) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\t/**\n-\t * Constructor JRadioButtonMenuItem\n-\t * @param text TODO\n-\t * @param icon TODO\n-\t * @param selected TODO\n-\t */\n-\tpublic JRadioButtonMenuItem(String text, Icon icon, boolean selected) {\n-\t\t// TODO\n-\t} // JRadioButtonMenuItem()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * requestFocus\n-\t */\n-\tpublic void requestFocus() {\n-\t\t// TODO\n-\t} // requestFocus()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJRadioButtonMenuItem(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n+  //-------------------------------------------------------------\n+  // Variables --------------------------------------------------\n+  //-------------------------------------------------------------\n+  private static final String uiClassID = \"RadioButtonMenuItemUI\";\n+\n+  //-------------------------------------------------------------\n+  // Initialization ---------------------------------------------\n+  //-------------------------------------------------------------\n+  public JRadioButtonMenuItem()\n+  {\n+    this(null, null);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(Icon icon)\n+  {\n+    this(null, icon);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(String text)\n+  {\n+    this(text, null);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(Action action)\n+  {\n+    this();\n+    setAction(action);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(String text, Icon icon)\n+  {\n+    this(text, icon, false);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(String text, boolean selected)\n+  {\n+    this(text, null, selected);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(Icon icon, boolean selected)\n+  {\n+    this(null, icon, selected);\n+  } // JRadioButtonMenuItem()\n+\n+  public JRadioButtonMenuItem(String text, Icon icon, boolean selected)\n+  {\n+    super(text, icon);  \n+    setModel(new JToggleButton.ToggleButtonModel());\t\n+    model.setSelected(selected);\n+  } // JRadioButtonMenuItem()\n+\n+  //-------------------------------------------------------------\n+  // Methods ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+    // TODO\n+  } // writeObject()\n+\n+  public String getUIClassID()\n+  {\n+    return uiClassID;\n+  } // getUIClassID()\n+\n+  public void requestFocus()\n+  {\n+    // TODO\n+  } // requestFocus()\n+\n+  protected String paramString()\n+  {\n+    return \"JRadioButtonMenuItem\";\n+  } // paramString()\n+\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      {\n+        accessibleContext = new AccessibleJRadioButtonMenuItem(this);\n+      }\n+    return accessibleContext;\n+  } // getAccessibleContext()\n+\n+  //-------------------------------------------------------------\n+  // Classes ----------------------------------------------------\n+  //-------------------------------------------------------------\n+  protected class AccessibleJRadioButtonMenuItem extends AccessibleJMenuItem\n+  {\n+    //-------------------------------------------------------------\n+    // Initialization ---------------------------------------------\n+    //-------------------------------------------------------------\n+    protected AccessibleJRadioButtonMenuItem(JRadioButtonMenuItem component)\n+    {\n+      super(component);\n+\n+      // TODO\n+    } // AccessibleJRadioButtonMenuItem()\n+\n+    //-------------------------------------------------------------\n+    // Methods ----------------------------------------------------\n+    //-------------------------------------------------------------\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.RADIO_BUTTON;\n+    } // getAccessibleRole()\n+  } // AccessibleJRadioButtonMenuItem\n } // JRadioButtonMenuItem"}, {"sha": "ee7e3eba985a17bd1b5ed4d677f5b6e6e9a35235", "filename": "libjava/javax/swing/JScrollBar.java", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollBar.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -176,12 +176,6 @@ public Number getMaximumAccessibleValue()\n   /** How much the thumb moves when moving in a unit. */\n   protected int unitIncrement = 1;\n \n-  /** A list of all ChangeListeners attached to the scroll bar. */\n-  private transient EventListenerList changeListenerList;\n-\n-  /** A list of all AdjustmentListeners attached to the scroll bar. */\n-  private transient EventListenerList adjustmentListenerList;\n-\n   /** The ChangeListener that listens to the model. */\n   private transient ChangeListener changeListener;\n \n@@ -228,8 +222,6 @@ public JScrollBar(int orientation, int value, int extent, int min, int max)\n                                          + \" is not a legal orientation\");\n     this.orientation = orientation;\n     changeListener = createChangeListener();\n-    changeListenerList = new EventListenerList();\n-    adjustmentListenerList = new EventListenerList();\n     model.addChangeListener(changeListener);\n     updateUI();\n   }\n@@ -586,7 +578,7 @@ public void stateChanged(ChangeEvent e)\n    */\n   private void fireStateChanged()\n   {\n-    Object[] changeListeners = changeListenerList.getListenerList();\n+    Object[] changeListeners = listenerList.getListenerList();\n     if (changeEvent == null)\n       changeEvent = new ChangeEvent(this);\n     for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n@@ -603,7 +595,7 @@ private void fireStateChanged()\n    */\n   public void addChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.add(ChangeListener.class, listener);\n+    listenerList.add(ChangeListener.class, listener);\n   }\n \n   /**\n@@ -613,7 +605,7 @@ public void addChangeListener(ChangeListener listener)\n    */\n   public void removeChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.remove(ChangeListener.class, listener);\n+    listenerList.remove(ChangeListener.class, listener);\n   }\n \n   /**\n@@ -624,7 +616,7 @@ public void removeChangeListener(ChangeListener listener)\n    */\n   public ChangeListener[] getChangeListeners()\n   {\n-    return (ChangeListener[]) changeListenerList.getListenerList();\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n   }\n \n   /**\n@@ -634,7 +626,7 @@ public ChangeListener[] getChangeListeners()\n    */\n   public void addAdjustmentListener(AdjustmentListener listener)\n   {\n-    adjustmentListenerList.add(AdjustmentListener.class, listener);\n+    listenerList.add(AdjustmentListener.class, listener);\n   }\n \n   /**\n@@ -644,7 +636,7 @@ public void addAdjustmentListener(AdjustmentListener listener)\n    */\n   public void removeAdjustmentListener(AdjustmentListener listener)\n   {\n-    adjustmentListenerList.remove(AdjustmentListener.class, listener);\n+    listenerList.remove(AdjustmentListener.class, listener);\n   }\n \n   /**\n@@ -655,7 +647,7 @@ public void removeAdjustmentListener(AdjustmentListener listener)\n    */\n   public AdjustmentListener[] getAdjustmentListeners()\n   {\n-    return (AdjustmentListener[]) adjustmentListenerList.getListenerList();\n+    return (AdjustmentListener[]) listenerList.getListeners(AdjustmentListener.class);\n   }\n \n   /**\n@@ -670,7 +662,7 @@ public AdjustmentListener[] getAdjustmentListeners()\n    */\n   protected void fireAdjustmentValueChanged(int id, int type, int value)\n   {\n-    Object[] adjustmentListeners = adjustmentListenerList.getListenerList();\n+    Object[] adjustmentListeners = listenerList.getListenerList();\n     AdjustmentEvent adjustmentEvent = new AdjustmentEvent(this, \n                                             AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n \t\t\t\t\t    AdjustmentEvent.TRACK,"}, {"sha": "f677f8fb4cb68c47a3ac233fc383ec4f64505356", "filename": "libjava/javax/swing/JSlider.java", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJSlider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJSlider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSlider.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -253,9 +253,6 @@ public Number getMaximumAccessibleValue()\n    */\n   private transient Dictionary labelTable;\n \n-  /** A list of all ChangeListeners listening to this slider. */\n-  private transient EventListenerList changeListenerList;\n-\n   /** The model used to describe the slider. */\n   protected BoundedRangeModel sliderModel;\n \n@@ -342,7 +339,6 @@ public JSlider(int orientation, int minimum, int maximum, int value)\n       throw new IllegalArgumentException(orientation + \" is not a legal orientation\");\n     this.orientation = orientation;\n     changeListener = createChangeListener();\n-    changeListenerList = new EventListenerList();\n     sliderModel.addChangeListener(changeListener);\n     updateUI();\n   }\n@@ -359,7 +355,6 @@ public JSlider(BoundedRangeModel model)\n     else\n       sliderModel = model;\n     changeListener = createChangeListener();\n-    changeListenerList = new EventListenerList();\n     sliderModel.addChangeListener(changeListener);\n     updateUI();\n   }\n@@ -453,7 +448,7 @@ public void stateChanged(ChangeEvent ce)\n    */\n   public void addChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.add(ChangeListener.class, listener);\n+    listenerList.add(ChangeListener.class, listener);\n   }\n \n   /**\n@@ -463,7 +458,7 @@ public void addChangeListener(ChangeListener listener)\n    */\n   public void removeChangeListener(ChangeListener listener)\n   {\n-    changeListenerList.remove(ChangeListener.class, listener);\n+    listenerList.remove(ChangeListener.class, listener);\n   }\n \n   /**\n@@ -473,7 +468,7 @@ public void removeChangeListener(ChangeListener listener)\n    */\n   protected void fireStateChanged()\n   {\n-    Object[] changeListeners = changeListenerList.getListenerList();\n+    Object[] changeListeners = listenerList.getListenerList();\n     if (changeEvent == null)\n       changeEvent = new ChangeEvent(this);\n     for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n@@ -491,7 +486,7 @@ protected void fireStateChanged()\n    */\n   public ChangeListener[] getChangeListeners()\n   {\n-    return (ChangeListener[]) changeListenerList.getListenerList();\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n   }\n \n   /**"}, {"sha": "c8af0729f441b0ef15a767312ca0c3c965e5f3c3", "filename": "libjava/javax/swing/JTabbedPane.java", "status": "modified", "additions": 1405, "deletions": 55, "changes": 1460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTabbedPane.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1,5 +1,5 @@\n-/* JTabbedPane.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* JTabbedPane.java --\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,98 +35,1448 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.Color;\n import java.awt.Component;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.MouseEvent;\n+import java.io.Serializable;\n import java.util.Vector;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import javax.accessibility.AccessibleSelection;\n+import javax.accessibility.AccessibleStateSet;\n+import javax.accessibility.AccessibleValue;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n import javax.swing.plaf.TabbedPaneUI;\n+import javax.swing.plaf.UIResource;\n+\n \n-public class JTabbedPane extends JComponent implements Accessible, SwingConstants\n+/**\n+ * <p>\n+ * This is a container for components. One component is displayed at a time.\n+ * Users can switch between components by clicking on tabs.\n+ * </p>\n+ * \n+ * <p>\n+ * Tabs can be oriented in several ways. They can be above, below, left and\n+ * right of the component. Tabs can either wrap around (by creating multiple\n+ * rows of tabs) or they can be scrolled (where only a subset of the  tabs\n+ * can be seen at once). More tabs can be added by calling the\n+ * add/addTab/insertTab methods.\n+ * </p>\n+ */\n+public class JTabbedPane extends JComponent implements Serializable,\n+                                                       Accessible,\n+                                                       SwingConstants\n {\n-    class Tab\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJTabbedPane extends JComponent.AccessibleJComponent\n+    implements AccessibleSelection, ChangeListener\n+  {\n+    /**\n+     * Creates a new AccessibleJTabbedPane object.\n+     *\n+     * @param c DOCUMENT ME!\n+     */\n+    public AccessibleJTabbedPane(JTabbedPane c)\n+    {\n+      super(c);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n     {\n-\tIcon icon;\n-\tString name, descr;\n-\tComponent tab;\n+      return null;\n+    }\n \n-\tTab(String name,\n-\t    Icon icon,\n-\t    Component tab,\n-\t    String descr)\n-\t{\n-\t    this.name = name;\n-\t    this.icon = icon;\n-\t    this.tab  = tab;\n-\t    this.descr = descr;\n-\t}\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public int getAccessibleChildrenCount()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param i DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Accessible getAccessibleChild(int i)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleSelection getAccessibleSelection()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param p DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Accessible getAccessibleAt(Point p)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public int getAccessibleSelectionCount()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param i DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Accessible getAccessibleSelection(int i)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param i DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public boolean isAccessibleChildSelected(int i)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param i DOCUMENT ME!\n+     */\n+    public void addAccessibleSelection(int i)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param i DOCUMENT ME!\n+     */\n+    public void removeAccessibleSelection(int i)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void clearAccessibleSelection()\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void selectAllAccessibleSelection()\n+    {\n+    }\n+  }\n+\n+  /**\n+   * A helper class that listens for changes to the model.\n+   */\n+  protected class ModelListener implements ChangeListener, Serializable\n+  {\n+    /**\n+     * This method is called whenever the model  is changed.\n+     *\n+     * @param e The ChangeEvent that is passed from the model.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      // Propagate to our listeners.\n+      fireStateChanged();\n+    }\n+  }\n+\n+  /**\n+   * A private class that holds all the information  for each tab.\n+   */\n+  private class Page\n+  {\n+    /** The tooltip string. */\n+    private String tip;\n+\n+    /** The component associated with the tab. */\n+    private Component component;\n+\n+    /** The active icon associated with the tab. */\n+    private transient Icon icon;\n+\n+    /** The disabled icon associated with the tab. */\n+    private transient Icon disabledIcon;\n+\n+    /** The tab's enabled status. */\n+    private transient boolean enabled = true;\n+\n+    /** The string painted on the tab. */\n+    private transient String title;\n+\n+    /** The background color of the tab. */\n+    private transient Color bg;\n+\n+    /** The foreground color of the tab. */\n+    private transient Color fg;\n+\n+    /** The mnemonic associated with the tab. */\n+    private transient int mnemonicKey;\n+\n+    /** The index of the underlined character in the string. */\n+    private transient int underlinedChar = -1;\n+\n+    /**\n+     * Creates a new data storage for the tab.\n+     *\n+     * @param title The string displayed on the tab.\n+     * @param icon The active icon displayed on the tab.\n+     * @param component The component associated with the tab.\n+     * @param tip The tooltip associated with the tab.\n+     */\n+    protected Page(String title, Icon icon, Component component, String tip)\n+    {\n+      this.title = title;\n+      this.icon = icon;\n+      this.component = component;\n+      this.tip = tip;\n+    }\n+\n+    /**\n+     * This method returns the component associated with the tab.\n+     *\n+     * @return The component associated with the tab.\n+     */\n+    public Component getComponent()\n+    {\n+      return component;\n+    }\n+\n+    /**\n+     * This method sets the component associated with the tab.\n+     *\n+     * @param c The component associated with the tab.\n+     */\n+    public void setComponent(Component c)\n+    {\n+      this.component = c;\n+    }\n+\n+    /**\n+     * This method returns the tooltip string.\n+     *\n+     * @return The tooltip string.\n+     */\n+    public String getTip()\n+    {\n+      return tip;\n+    }\n+\n+    /**\n+     * This method sets the tooltip string.\n+     *\n+     * @param tip The tooltip string.\n+     */\n+    public void setTip(String tip)\n+    {\n+      this.tip = tip;\n+    }\n+\n+    /**\n+     * This method returns the background color.\n+     *\n+     * @return The background color.\n+     */\n+    public Color getBackground()\n+    {\n+      return bg;\n+    }\n+\n+    /**\n+     * This method sets the background color.\n+     *\n+     * @param background The background color.\n+     */\n+    public void setBackground(Color background)\n+    {\n+      bg = background;\n+    }\n+\n+    /**\n+     * This method returns the foreground color.\n+     *\n+     * @return The foreground color.\n+     */\n+    public Color getForeground()\n+    {\n+      return fg;\n+    }\n+\n+    /**\n+     * This method sets the foreground color.\n+     *\n+     * @param foreground The foreground color.\n+     */\n+    public void setForeground(Color foreground)\n+    {\n+      fg = foreground;\n+    }\n+\n+    /**\n+     * This method returns the title associated with the tab.\n+     *\n+     * @return The title of the tab.\n+     */\n+    public String getTitle()\n+    {\n+      return title;\n     }\n \n   private static final long serialVersionUID = 1614381073220130939L;\n-    \n-    private Vector tabs = new Vector();\n \n-    public JTabbedPane()\n+    /**\n+     * This method sets the title of the tab.\n+     *\n+     * @param text The title of the tab.\n+     */\n+    public void setTitle(String text)\n     {\n+      title = text;\n+      if (title != null && title.length() <= underlinedChar)\n+        setDisplayedMnemonicIndex(title.length() - 1);      \n     }\n \n-    public void addTab(String name,\n-\t\tComponent panel)\t\t\n+    /**\n+     * This method returns the active icon.\n+     *\n+     * @return The active icon.\n+     */\n+    public Icon getIcon()\n     {\n-\taddTab(name, null, panel, null);\n+      return icon;\n     }\n-    public void addTab(String name,\n-\t\tIcon icon,\n-\t\tComponent panel)\t\t\n+\n+    /**\n+     * This method sets the active icon.\n+     *\n+     * @param icon The active icon.\n+     */\n+    public void setIcon(Icon icon)\n     {\n-\taddTab(name, icon, panel, null);\n+      this.icon = icon;\n     }\n-    public void addTab(String name,\n-\t\tIcon icon,\n-\t\tComponent panel,\n-\t\tString descr)\n+\n+    /**\n+     * This method returns the disabled icon.\n+     *\n+     * @return The disabled icon.\n+     */\n+    public Icon getDisabledIcon()\n     {\n-\ttabs.addElement(new Tab(name, icon, panel, descr));\n+      if (disabledIcon == null && icon instanceof ImageIcon)\n+\tsetDisabledIcon(icon);\n+      return disabledIcon;\n     }\n \n-    public int getTabCount()\n+    /**\n+     * This method sets the disabled icon.\n+     *\n+     * @param disabledIcon The disabled icon.\n+     */\n+    public void setDisabledIcon(Icon disabledIcon)\n     {\n-\treturn tabs.size();\n+      this.disabledIcon = disabledIcon;\n     }\n-    public Component getComponentAt(int i)\n+\n+    /**\n+     * This method returns whether the tab is enabled.\n+     *\n+     * @return Whether the tab is enabled.\n+     */\n+    public boolean isEnabled()\n     {\n-\tTab t = (Tab) tabs.elementAt(i);\n-\treturn t.tab;\n+      return enabled;\n     }\n-    \n-    public String getUIClassID()\n-    {\treturn \"TabbedPaneUI\";    }\n \n+    /**\n+     * This method sets whether the tab is enabled.\n+     *\n+     * @param enabled Whether this tab is enabled.\n+     */\n+    public void setEnabled(boolean enabled)\n+    {\n+      this.enabled = enabled;\n+    }\n \n-    public void setUI(TabbedPaneUI ui) {\n-        super.setUI(ui);\n+    /**\n+     * This method returns the mnemonic.\n+     *\n+     * @return The mnemonic.\n+     */\n+    public int getMnemonic()\n+    {\n+      return (int) mnemonicKey;\n     }\n-    \n-    public TabbedPaneUI getUI() {\n-        return (TabbedPaneUI)ui;\n+\n+    /**\n+     * This method sets the mnemonic. If the title is set, it will update the\n+     * mnemonicIndex.\n+     *\n+     * @param key The mnemonic.\n+     */\n+    public void setMnemonic(int key)\n+    {\n+      setMnemonic((char) key);\n     }\n-    \n-    public void updateUI()\n+\n+    /**\n+     * This method sets the mnemonic. If the title is set, it will update the\n+     * mnemonicIndex.\n+     *\n+     * @param aChar The mnemonic.\n+     */\n+    public void setMnemonic(char aChar)\n     {\n-        setUI((TabbedPaneUI)UIManager.getUI(this));\n+      mnemonicKey = aChar;\n+      if (title != null)\n+\tsetDisplayedMnemonicIndex(title.indexOf(mnemonicKey));\n     }\n-    \n-    public AccessibleContext getAccessibleContext()\n+\n+    /**\n+     * This method returns the mnemonicIndex.\n+     *\n+     * @return The mnemonicIndex.\n+     */\n+    public int getDisplayedMnemonicIndex()\n     {\n-\treturn null;\n+      return underlinedChar;\n     }\n-    \n-   protected  String paramString()\n+\n+    /**\n+     * This method sets the mnemonicIndex.\n+     *\n+     * @param index The mnemonicIndex.\n+     *\n+     * @throws IllegalArgumentException If index less than -1 || index greater\n+     *         or equal to title.length.\n+     */\n+    public void setDisplayedMnemonicIndex(int index)\n+                                   throws IllegalArgumentException\n     {\n-\treturn \"JTabbedPane\";\n+      if (index < -1 || title != null && index >= title.length())\n+\tthrow new IllegalArgumentException();\n+\n+      if (title == null || title.charAt(index) != mnemonicKey)\n+\tindex = -1;\n+\n+      underlinedChar = index;\n     }\n+  }\n+\n+  /** Fired in a PropertyChangeEvent when the \"model\" property changes. */\n+  public static final String MODEL_CHANGED_PROPERTY = \"model\";\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"tabPlacement\" property changes.\n+   */\n+  public static final String TAB_PLACEMENT_CHANGED_PROPERTY = \"tabPlacement\";\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"tabLayoutPolicy\" property\n+   * changes.\n+   */\n+  public static final String TAB_LAYOUT_POLICY_CHANGED_PROPERTY = \"tabLayoutPolicy\";\n+\n+  /** The changeEvent used to fire changes to listeners. */\n+  protected ChangeEvent changeEvent;\n+\n+  /** The listener that listens to the model. */\n+  protected ChangeListener changeListener;\n+\n+  /** The model that describes this JTabbedPane. */\n+  protected SingleSelectionModel model;\n+\n+  /** Indicates that the TabbedPane is in scrolling mode. */\n+  static int SCROLL_TAB_LAYOUT = 0;\n+\n+  /** Indicates that the TabbedPane is in wrap mode. */\n+  static int WRAP_TAB_LAYOUT = 1;\n+\n+  /** The current tabPlacement of the TabbedPane. */\n+  protected int tabPlacement = SwingConstants.TOP;\n+\n+  /** The current tabLayoutPolicy of the TabbedPane. */\n+  private transient int layoutPolicy;\n+\n+  /** The list of tabs associated with the TabbedPane. */\n+  transient Vector tabs = new Vector();\n+\n+  /**\n+   * Creates a new JTabbedPane object with tabs on top and using wrap tab\n+   * layout.\n+   */\n+  public JTabbedPane()\n+  {\n+    this(SwingConstants.TOP, WRAP_TAB_LAYOUT);\n+  }\n+\n+  /**\n+   * Creates a new JTabbedPane object using wrap tab layout  and the given\n+   * tabPlacement.\n+   *\n+   * @param tabPlacement Where the tabs will be placed.\n+   */\n+  public JTabbedPane(int tabPlacement)\n+  {\n+    this(tabPlacement, WRAP_TAB_LAYOUT);\n+  }\n+\n+  /**\n+   * Creates a new JTabbedPane object with the given tabPlacement and\n+   * tabLayoutPolicy.\n+   *\n+   * @param tabPlacement Where the tabs will be placed.\n+   * @param tabLayoutPolicy The way tabs will be placed.\n+   *\n+   * @throws IllegalArgumentException If tabLayoutPolicy or tabPlacement are\n+   *         not valid.\n+   */\n+  public JTabbedPane(int tabPlacement, int tabLayoutPolicy)\n+  {\n+    if (tabPlacement != TOP && tabPlacement != BOTTOM && tabPlacement != RIGHT\n+        && tabPlacement != LEFT)\n+      throw new IllegalArgumentException(\"tabPlacement is not valid.\");\n+    if (tabLayoutPolicy != SCROLL_TAB_LAYOUT\n+        && tabLayoutPolicy != WRAP_TAB_LAYOUT)\n+      throw new IllegalArgumentException(\"tabLayoutPolicy is not valid.\");\n+    this.tabPlacement = tabPlacement;\n+    layoutPolicy = tabLayoutPolicy;\n+\n+    changeEvent = new ChangeEvent(this);\n+    changeListener = createChangeListener();\n+\n+    model = new DefaultSingleSelectionModel();\n+    model.addChangeListener(changeListener);\n+\n+    updateUI();\n+  }\n+\n+  /**\n+   * This method returns the UI used to display the JTabbedPane.\n+   *\n+   * @return The UI used to display the JTabbedPane.\n+   */\n+  public TabbedPaneUI getUI()\n+  {\n+    return (TabbedPaneUI) ui;\n+  }\n+\n+  /**\n+   * This method sets the UI used to display the JTabbedPane.\n+   *\n+   * @param ui The UI used to display the JTabbedPane.\n+   */\n+  public void setUI(TabbedPaneUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method restores the UI to the defaults given by the UIManager.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((TabbedPaneUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * This method returns a string identifier that  is used to determine which\n+   * UI will be used with  the JTabbedPane.\n+   *\n+   * @return A string identifier for the UI.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"TabbedPaneUI\";\n+  }\n+\n+  /**\n+   * This method creates a ChangeListener that is used to  listen to the model\n+   * for events.\n+   *\n+   * @return A ChangeListener to listen to the model.\n+   */\n+  protected ChangeListener createChangeListener()\n+  {\n+    return new ModelListener();\n+  }\n+\n+  /**\n+   * This method adds a ChangeListener to the JTabbedPane.\n+   *\n+   * @param l The ChangeListener to add.\n+   */\n+  public void addChangeListener(ChangeListener l)\n+  {\n+    listenerList.add(ChangeListener.class, l);\n+  }\n+\n+  /**\n+   * This method removes a ChangeListener to the JTabbedPane.\n+   *\n+   * @param l The ChangeListener to remove.\n+   */\n+  public void removeChangeListener(ChangeListener l)\n+  {\n+    listenerList.remove(ChangeListener.class, l);\n+  }\n+\n+  /**\n+   * This method fires a ChangeEvent to all the JTabbedPane's ChangeListeners.\n+   */\n+  protected void fireStateChanged()\n+  {\n+    Object[] changeListeners = listenerList.getListenerList();\n+    if (changeEvent == null)\n+      changeEvent = new ChangeEvent(this);\n+    for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n+      {\n+\tif (changeListeners[i] == ChangeListener.class)\n+\t  ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n+      }\n+  }\n+\n+  /**\n+   * This method returns all ChangeListeners registered with the JTabbedPane.\n+   *\n+   * @return The ChangeListeners registered with the JTabbedPane.\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) super.getListeners(ChangeListener.class);\n+  }\n+\n+  /**\n+   * This method returns the model used with the JTabbedPane.\n+   *\n+   * @return The JTabbedPane's model.\n+   */\n+  public SingleSelectionModel getModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * This method changes the model property of the JTabbedPane.\n+   *\n+   * @param model The new model to use with the JTabbedPane.\n+   */\n+  public void setModel(SingleSelectionModel model)\n+  {\n+    if (model != this.model)\n+      {\n+\tSingleSelectionModel oldModel = this.model;\n+\tthis.model.removeChangeListener(changeListener);\n+\tthis.model = model;\n+\tthis.model.addChangeListener(changeListener);\n+\tfirePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, this.model);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the tabPlacement.\n+   *\n+   * @return The tabPlacement used with the JTabbedPane.\n+   */\n+  public int getTabPlacement()\n+  {\n+    return tabPlacement;\n+  }\n+\n+  /**\n+   * This method changes the tabPlacement property of the JTabbedPane.\n+   *\n+   * @param tabPlacement The tabPlacement to use.\n+   *\n+   * @throws IllegalArgumentException If tabPlacement is not one of TOP,\n+   *         BOTTOM, LEFT, or RIGHT.\n+   */\n+  public void setTabPlacement(int tabPlacement)\n+  {\n+    if (tabPlacement != TOP && tabPlacement != BOTTOM && tabPlacement != RIGHT\n+        && tabPlacement != LEFT)\n+      throw new IllegalArgumentException(\"tabPlacement is not valid.\");\n+    if (tabPlacement != this.tabPlacement)\n+      {\n+\tint oldPlacement = this.tabPlacement;\n+\tthis.tabPlacement = tabPlacement;\n+\tfirePropertyChange(TAB_PLACEMENT_CHANGED_PROPERTY, oldPlacement,\n+\t                   this.tabPlacement);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the tabLayoutPolicy.\n+   *\n+   * @return The tabLayoutPolicy.\n+   */\n+  public int getTabLayoutPolicy()\n+  {\n+    return layoutPolicy;\n+  }\n+\n+  /**\n+   * This method changes the tabLayoutPolicy property of the JTabbedPane.\n+   *\n+   * @param tabLayoutPolicy The tabLayoutPolicy to use.\n+   *\n+   * @throws IllegalArgumentException If tabLayoutPolicy is not one of\n+   *         SCROLL_TAB_LAYOUT or WRAP_TAB_LAYOUT.\n+   */\n+  public void setTabLayoutPolicy(int tabLayoutPolicy)\n+  {\n+    if (tabLayoutPolicy != SCROLL_TAB_LAYOUT\n+        && tabLayoutPolicy != WRAP_TAB_LAYOUT)\n+      throw new IllegalArgumentException(\"tabLayoutPolicy is not valid.\");\n+    if (tabLayoutPolicy != layoutPolicy)\n+      {\n+\tint oldPolicy = layoutPolicy;\n+\tlayoutPolicy = tabLayoutPolicy;\n+\tfirePropertyChange(TAB_LAYOUT_POLICY_CHANGED_PROPERTY, oldPolicy,\n+\t                   layoutPolicy);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the index of the tab that is currently selected.\n+   *\n+   * @return The index of the selected tab.\n+   */\n+  public int getSelectedIndex()\n+  {\n+    return model.getSelectedIndex();\n+  }\n+\n+  /**\n+   * This method checks the index.\n+   *\n+   * @param index The index to check.\n+   */\n+  private void checkIndex(int index, int start, int end)\n+  {\n+    if (index < start || index >= end)\n+      throw new IndexOutOfBoundsException(\"Index < \" + start + \" || Index >= \" + end);\n+  }\n+\n+  /**\n+   * This method sets the selected index. This method\n+   * will hide the old component and show the new component.\n+   *\n+   * @param index The index to set it at.\n+   */\n+  public void setSelectedIndex(int index)\n+  {\n+    checkIndex(index, -1, tabs.size());\n+    if (index != getSelectedIndex())\n+      {\n+\tif (getSelectedIndex() != -1)\n+\t  getSelectedComponent().hide();\n+\tif (index != -1)\n+\t  getComponentAt(index).show();\n+      }\n+    model.setSelectedIndex(index);\n+  }\n+\n+  /**\n+   * This method returns the component at the selected index.\n+   *\n+   * @return The component at the selected index.\n+   */\n+  public Component getSelectedComponent()\n+  {\n+    return getComponentAt(getSelectedIndex());\n+  }\n+\n+  /**\n+   * This method sets the component at the selected index.\n+   *\n+   * @param c The component associated with the selected index.\n+   */\n+  public void setSelectedComponent(Component c)\n+  {\n+    if (c.getParent() == this)\n+      setSelectedIndex(indexOfComponent(c));\n+    else\n+      setComponentAt(getSelectedIndex(), c);\n+  }\n+\n+  /**\n+   * This method inserts tabs into JTabbedPane. This includes\n+   * adding the component to the JTabbedPane and hiding it.\n+   *\n+   * @param title The title of the tab.\n+   * @param icon The tab's icon.\n+   * @param component The component associated with the tab.\n+   * @param tip The tooltip for the tab.\n+   * @param index The index to insert the tab at.\n+   */\n+  public void insertTab(String title, Icon icon, Component component,\n+                        String tip, int index)\n+  {\n+    Page p = new Page(title, icon, component, tip);\n+    tabs.insertElementAt(p, index);\n+\n+    // Hide the component so we don't see it. Do it before we parent it\n+    // so we don't trigger a repaint.\n+    component.hide();\n+    super.add(component);\n+  \n+    if (getSelectedIndex() == -1)\n+      setSelectedIndex(0);\n+\n+    layout();\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   *\n+   * @param title The title of the tab.\n+   * @param icon The icon for the tab.\n+   * @param component The associated component.\n+   * @param tip The associated tooltip.\n+   */\n+  public void addTab(String title, Icon icon, Component component, String tip)\n+  {\n+    insertTab(title, icon, component, tip, tabs.size());\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   *\n+   * @param title The title of the tab.\n+   * @param icon The icon for the tab.\n+   * @param component The associated component.\n+   */\n+  public void addTab(String title, Icon icon, Component component)\n+  {\n+    insertTab(title, icon, component, null, tabs.size());\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   *\n+   * @param title The title of the tab.\n+   * @param component The associated component.\n+   */\n+  public void addTab(String title, Component component)\n+  {\n+    insertTab(title, null, component, null, tabs.size());\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   * The title of the tab is the Component's name.\n+   * If the Component is an instance of UIResource, it doesn't\n+   * add the tab and instead add the component directly to the\n+   * JTabbedPane.\n+   *\n+   * @param component The associated component.\n+   *\n+   * @return The Component that was added.  \n+   */\n+  public Component add(Component component)\n+  {\n+    if (component instanceof UIResource)\n+      super.add(component);\n+    else\n+      insertTab(component.getName(), null, component, null, tabs.size());\n+    return component;\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   * If the Component is an instance of UIResource, it doesn't\n+   * add the tab and instead add the component directly to the\n+   * JTabbedPane.\n+   *\n+   * @param title The title of the tab.\n+   * @param component The associated component.\n+   *\n+   * @return The Component that was added.\n+   */\n+   public Component add(String title, Component component)\n+  {\n+    if (component instanceof UIResource)\n+      super.add(component);\n+    else\n+      insertTab(title, null, component, null, tabs.size());\n+    return component;\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   * If the Component is an instance of UIResource, it doesn't\n+   * add the tab and instead add the component directly to the\n+   * JTabbedPane.\n+   *\n+   * @param component The associated component.\n+   * @param index The index to insert the tab at.\n+   *\n+   * @return The Component that was added.\n+   */\n+  public Component add(Component component, int index)\n+  {\n+    if (component instanceof UIResource)\n+      super.add(component);\n+    else\n+      insertTab(component.getName(), null, component, null, index);\n+    return component;\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   * If the Component is an instance of UIResource, it doesn't\n+   * add the tab and instead add the component directly to the\n+   * JTabbedPane. If the constraints object is an icon, it\n+   * will be used as the tab's icon. If the constraints object\n+   * is a string, we will use it as the title.\n+   *\n+   * @param component The associated component.\n+   * @param constraints The constraints object.\n+   */\n+  public void add(Component component, Object constraints)\n+  {\n+    add(component, constraints, tabs.size());\n+  }\n+\n+  /**\n+   * This method adds a tab to the JTabbedPane.\n+   * If the Component is an instance of UIResource, it doesn't\n+   * add the tab and instead add the component directly to the\n+   * JTabbedPane. If the constraints object is an icon, it\n+   * will be used as the tab's icon. If the constraints object\n+   * is a string, we will use it as the title.\n+   *\n+   * @param component The associated component.\n+   * @param constraints The constraints object.\n+   * @param index The index to insert the tab at.\n+   */\n+  public void add(Component component, Object constraints, int index)\n+  {\n+    if (component instanceof UIResource)\n+      super.add(component);\n+    else\n+      {\n+\tif (constraints instanceof String)\n+\t  insertTab((String) constraints, null, component, null, index);\n+\telse\n+\t  insertTab(component.getName(),\n+\t            (constraints instanceof Icon) ? (Icon) constraints : null,\n+\t            component, null, index);\n+      }\n+  }\n+\n+  /**\n+   * The tab and it's associated component are removed. After\n+   * the component has been removed from the JTabbedPane, it's\n+   * set visible to ensure that it can be seen.\n+   *\n+   * @param index The index of the tab to remove.\n+   *\n+   * @throws IndexOutOfBoundsException If the index is not in range.\n+   */\n+  public void removeTabAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    Component c = getComponentAt(index);\n+    super.remove(c);\n+    c.show();\n+    tabs.remove(index);\n+  }\n+\n+  /**\n+   * This method removes the component from the JTabbedPane. After\n+   * the component has been removed from the JTabbedPane, it's \n+   * set visible to ensure that it can be seen.\n+   *\n+   * @param component The Component to remove.\n+   */\n+  public void remove(Component component)\n+  {\n+    // This simply removes the component.\n+    int index = indexOfComponent(component);\n+    super.remove(component);\n+    component.show();\n+    setComponentAt(index, null);\n+  }\n+\n+  /**\n+   * This method removes the tab and component from the JTabbedPane.\n+   * It simply calls removeTabAt(int index).\n+   *\n+   * @param index The index of the tab to remove.\n+   */\n+  public void remove(int index)\n+  {\n+    removeTabAt(index);\n+  }\n+\n+  /**\n+   * This method removes all tabs and associated components\n+   * from the JTabbedPane.\n+   */\n+  public void removeAll()\n+  {\n+    for (int i = tabs.size() - 1; i >= 0; i--)\n+      removeTabAt(i);\n+  }\n+\n+  /**\n+   * This method returns how many tabs are in the JTabbedPane.\n+   *\n+   * @return The number of tabs in the JTabbedPane.\n+   */\n+  public int getTabCount()\n+  {\n+    return tabs.size();\n+  }\n+\n+  /**\n+   * This method returns the number of runs used \n+   * to paint the JTabbedPane.\n+   *\n+   * @return The number of runs.\n+   */\n+  public int getTabRunCount()\n+  {\n+    return ((TabbedPaneUI) ui).getTabRunCount(this);\n+  }\n+\n+  /**\n+   * This method returns the tab title given the index.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The title for the tab.\n+   */\n+  public String getTitleAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getTitle();\n+  }\n+\n+  /**\n+   * This method returns the active icon given the index.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The active icon for the tab.\n+   */\n+  public Icon getIconAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getIcon();\n+  }\n+\n+  /**\n+   * This method returns the disabled icon given the index.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The disabled icon for the tab.\n+   */\n+  public Icon getDisabledIconAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getDisabledIcon();\n+  }\n+\n+  /**\n+   * This method returns the tooltip string for the tab.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The tooltip string for the tab.\n+   */\n+  public String getToolTipTextAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getTip();\n+  }\n+\n+  /**\n+   * This method returns the foreground color for the tab.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The foreground color for the tab.\n+   */\n+  public Color getForegroundAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getForeground();\n+  }\n+\n+  /**\n+   * This method returns the background color for the tab.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The background color for the tab.\n+   */\n+  public Color getBackgroundAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getBackground();\n+  }\n+\n+  /**\n+   * This method returns the component associated with the tab.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return The component associated with the tab.\n+   */\n+  public Component getComponentAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).getComponent();\n+  }\n+\n+  /**\n+   * This method returns whether this tab is enabled.\n+   * Disabled tabs cannot be selected.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return Whether the tab is enabled.\n+   */\n+  public boolean isEnabledAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((Page) tabs.elementAt(index)).isEnabled();\n+  }\n+\n+  /**\n+   * This method returns the mnemonic for the tab.\n+   *\n+   * @param tabIndex The index of the tab.\n+   *\n+   * @return The mnemonic for the tab.\n+   */\n+  public int getMnemonicAt(int tabIndex)\n+  {\n+    checkIndex(tabIndex, 0, tabs.size());\n+    return ((Page) tabs.elementAt(tabIndex)).getMnemonic();\n+  }\n+\n+  /**\n+   * This method returns the mnemonic index for the tab.\n+   *\n+   * @param tabIndex The index of the tab.\n+   *\n+   * @return The mnemonic index for the tab.\n+   */\n+  public int getDisplayedMnemonicIndexAt(int tabIndex)\n+  {\n+    checkIndex(tabIndex, 0, tabs.size());\n+    return ((Page) tabs.elementAt(tabIndex)).getDisplayedMnemonicIndex();\n+  }\n+\n+  /**\n+   * This method returns the bounds of the tab given\n+   * the index.\n+   *\n+   * @param index The index of the tab.\n+   *\n+   * @return A rectangle describing the bounds of the tab.\n+   */\n+  public Rectangle getBoundsAt(int index)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    return ((TabbedPaneUI) ui).getTabBounds(this, index);\n+  }\n+\n+  /**\n+   * This method sets the title of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param title The new title.\n+   */\n+  public void setTitleAt(int index, String title)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setTitle(title);\n+  }\n+\n+  /**\n+   * This method sets the icon of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param icon The new icon.\n+   */\n+  public void setIconAt(int index, Icon icon)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setIcon(icon);\n+  }\n+\n+  /**\n+   * This method sets the disabled icon of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param disabledIcon The new disabled icon.\n+   */\n+  public void setDisabledIconAt(int index, Icon disabledIcon)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setDisabledIcon(disabledIcon);\n+  }\n+\n+  /**\n+   * This method sets the tooltip text of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param toolTipText The tooltip text.\n+   */\n+  public void setToolTipTextAt(int index, String toolTipText)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setTip(toolTipText);\n+  }\n+\n+  /**\n+   * This method sets the background color of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param background The background color of the tab.\n+   */\n+  public void setBackgroundAt(int index, Color background)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setBackground(background);\n+  }\n+\n+  /**\n+   * This method sets the foreground color of the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param foreground The foreground color of the tab.\n+   */\n+  public void setForegroundAt(int index, Color foreground)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setForeground(foreground);\n+  }\n+\n+  /**\n+   * This method sets whether the tab is enabled.\n+   *\n+   * @param index The index of the tab.\n+   * @param enabled Whether the tab is enabled.\n+   */\n+  public void setEnabledAt(int index, boolean enabled)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setEnabled(enabled);\n+  }\n+\n+  /**\n+   * This method sets the component associated with the tab.\n+   *\n+   * @param index The index of the tab.\n+   * @param component The component associated with the tab.\n+   */\n+  public void setComponentAt(int index, Component component)\n+  {\n+    checkIndex(index, 0, tabs.size());\n+    ((Page) tabs.elementAt(index)).setEnabled(enabled);\n+  }\n+\n+  /**\n+   * This method sets the displayed mnemonic index of the tab.\n+   *\n+   * @param tabIndex The index of the tab.\n+   * @param mnemonicIndex The mnemonic index.\n+   */\n+  public void setDisplayedMnemonicIndexAt(int tabIndex, int mnemonicIndex)\n+  {\n+    checkIndex(tabIndex, 0, tabs.size());\n+    ((Page) tabs.elementAt(tabIndex)).setDisplayedMnemonicIndex(mnemonicIndex);\n+  }\n+\n+  /**\n+   * This method sets the mnemonic for the tab.\n+   *\n+   * @param tabIndex The index of the tab.\n+   * @param mnemonic The mnemonic.\n+   */\n+  public void setMnemonicAt(int tabIndex, int mnemonic)\n+  {\n+    checkIndex(tabIndex, 0, tabs.size());\n+    ((Page) tabs.elementAt(tabIndex)).setMnemonic(mnemonic);\n+  }\n+\n+  /**\n+   * This method finds the index of a tab given the title.\n+   *\n+   * @param title The title that belongs to a tab.\n+   *\n+   * @return The index of the tab that has the title or -1 if not found.\n+   */\n+  public int indexOfTab(String title)\n+  {\n+    int index = -1;\n+    for (int i = 0; i < tabs.size(); i++)\n+      {\n+\tif (((Page) tabs.elementAt(i)).getTitle().equals(title))\n+\t  {\n+\t    index = i;\n+\t    break;\n+\t  }\n+      }\n+    return index;\n+  }\n+\n+  /**\n+   * This method finds the index of a tab given the icon.\n+   *\n+   * @param icon The icon that belongs to a tab.\n+   *\n+   * @return The index of the tab that has the icon or -1 if not found.\n+   */\n+  public int indexOfTab(Icon icon)\n+  {\n+    int index = -1;\n+    for (int i = 0; i < tabs.size(); i++)\n+      {\n+\tif (((Page) tabs.elementAt(i)).getIcon() == icon)\n+\t  {\n+\t    index = i;\n+\t    break;\n+\t  }\n+      }\n+    return index;\n+  }\n+\n+  /**\n+   * This method finds the index of a tab given the component.\n+   *\n+   * @param component A component associated with a tab.\n+   *\n+   * @return The index of the tab that has this component or -1 if not found.\n+   */\n+  public int indexOfComponent(Component component)\n+  {\n+    int index = -1;\n+    for (int i = 0; i < tabs.size(); i++)\n+      {\n+\tif (((Page) tabs.elementAt(i)).getComponent() == component)\n+\t  {\n+\t    index = i;\n+\t    break;\n+\t  }\n+      }\n+    return index;\n+  }\n+\n+  /**\n+   * This method returns a tab index given an (x,y) location. The origin\n+   * of the (x,y) pair will be the JTabbedPane's top left position. The \n+   * tab returned will be the one that contains the point. This method is \n+   * delegated to the UI.\n+   *\n+   * @param x The x coordinate of the point.\n+   * @param y The y coordinate of the point.\n+   *\n+   * @return The index of the tab that contains the point.\n+   */\n+  public int indexAtLocation(int x, int y)\n+  {\n+    return ((TabbedPaneUI) ui).tabForCoordinate(this, x, y);\n+  }\n+\n+  /**\n+   * This method returns the tooltip text given a mouse event.\n+   *\n+   * @param event The mouse event.\n+   *\n+   * @return The tool tip text that is associated with this mouse event.\n+   */\n+  public String getToolTipText(MouseEvent event)\n+  {\n+    int index = indexAtLocation(event.getX(), event.getY());\n+    return ((Page) tabs.elementAt(index)).getTip();\n+  }\n+\n+  /**\n+   * This method returns a string representation of this JTabbedPane. It\n+   * is mainly used for debugging purposes.\n+   *\n+   * @return A string representation of this JTabbedPane.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JTabbedPane\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJTabbedPane(this);\n+    return accessibleContext;\n+  }\n }"}, {"sha": "e778c5bffa304923b71ac0f57878449306a86e2f", "filename": "libjava/javax/swing/plaf/basic/BasicArrowButton.java", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -0,0 +1,363 @@\n+/* BasicArrowButton.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.SwingConstants;\n+\n+\n+/**\n+ * This class draws simple arrow buttons for the Basic Look and Feel.\n+ */\n+public class BasicArrowButton extends JButton implements SwingConstants\n+{\n+  /**\n+   * A private helper class that draws icons.\n+   */\n+  private class arrowIcon implements Icon\n+  {\n+    /** The polygon that describes the icon. */\n+    private Polygon arrow;\n+\n+    /** The size of the icon. */\n+    private int size = 10;\n+\n+    /**\n+     * Creates a new arrowIcon object using the given arrow polygon.\n+     *\n+     * @param arrow The polygon that describes the arrow.\n+     */\n+    public arrowIcon(Polygon arrow)\n+    {\n+      this.arrow = arrow;\n+    }\n+\n+    /**\n+     * Returns the height of the icon.\n+     *\n+     * @return The height of the icon.\n+     */\n+    public int getIconHeight()\n+    {\n+      return size;\n+    }\n+\n+    /**\n+     * Returns the width of the icon.\n+     *\n+     * @return The width of the icon.\n+     */\n+    public int getIconWidth()\n+    {\n+      return size;\n+    }\n+\n+    /**\n+     * Sets the size of the icon.\n+     *\n+     * @param size The size of the icon.\n+     */\n+    public void setSize(int size)\n+    {\n+      this.size = size;\n+    }\n+\n+    /**\n+     * Sets the arrow polygon.\n+     *\n+     * @param arrow The arrow polygon.\n+     */\n+    public void setArrow(Polygon arrow)\n+    {\n+      this.arrow = arrow;\n+    }\n+\n+    /**\n+     * Paints the icon.\n+     *\n+     * @param c The Component to paint for.\n+     * @param g The Graphics object to draw with.\n+     * @param x The X coordinate to draw at.\n+     * @param y The Y coordinate to draw at.\n+     */\n+    public void paintIcon(Component c, Graphics g, int x, int y)\n+    {\n+      Color arrowColor;\n+      if (c.isEnabled())\n+\tarrowColor = darkShadow;\n+      else\n+\tarrowColor = shadow;\n+\n+      paintIconImpl(g, x, y, arrowColor);\n+    }\n+\n+    /**\n+     * This method does the actual painting work.\n+     *\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate to paint at.\n+     * @param y The y coordinate to paint at.\n+     * @param arrowColor The color to paint the arrow with.\n+     */\n+    public void paintIconImpl(Graphics g, int x, int y, Color arrowColor)\n+    {\n+      g.translate(x, y);\n+\n+      Color saved = g.getColor();\n+\n+      g.setColor(arrowColor);\n+\n+      g.fillPolygon(arrow);\n+\n+      g.setColor(saved);\n+      g.translate(-x, -y);\n+    }\n+  }\n+\n+  /** The direction to point in. */\n+  protected int direction;\n+\n+  /** The color the arrow is painted in if disabled and the bottom and\n+   * right edges of the button. */\n+  private transient Color shadow = Color.BLACK;\n+\n+  /** The color the arrow is painted in if enabled and the bottom and\n+   * right edges of the button. */\n+  private transient Color darkShadow = Color.BLACK;\n+\n+  /** The top and left edges of the button. */\n+  private transient Color highlight = Color.BLACK;\n+\n+  /**\n+   * Creates a new BasicArrowButton object.\n+   *\n+   * @param direction The direction the arrow points in.\n+   */\n+  public BasicArrowButton(int direction)\n+  {\n+    super();\n+    setDirection(direction);\n+  }\n+\n+  /**\n+   * Creates a new BasicArrowButton object with the given colors and \n+   * direction.\n+   *\n+   * @param direction The direction to point in.\n+   * @param background The background color.\n+   * @param shadow The shadow color.\n+   * @param darkShadow The dark shadow color.\n+   * @param highlight The highlight color.\n+   */\n+  public BasicArrowButton(int direction, Color background, Color shadow,\n+                          Color darkShadow, Color highlight)\n+  {\n+    this(direction);\n+    setBackground(background);\n+    this.shadow = shadow;\n+    this.darkShadow = darkShadow;\n+    this.highlight = highlight;\n+  }\n+\n+  /**\n+   * This method returns the direction of the arrow.\n+   *\n+   * @return The direction of the arrow.\n+   */\n+  public int getDirection()\n+  {\n+    return direction;\n+  }\n+\n+  /**\n+   * This method changes the direction of the arrow.\n+   *\n+   * @param dir The new direction of the arrow.\n+   */\n+  public void setDirection(int dir)\n+  {\n+    Polygon arrow = getArrow(dir, 10);\n+    if (getIcon() == null)\n+      setIcon(new arrowIcon(arrow));\n+    else\n+      ((arrowIcon) getIcon()).setArrow(arrow);\n+    this.direction = direction;\n+  }\n+\n+  /**\n+   * This method paints the arrow button.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    super.paint(g);\n+    Rectangle bounds = getBounds();\n+\n+    Color saved = g.getColor();\n+    g.setColor(highlight);\n+\n+    g.drawLine(bounds.x, bounds.y, bounds.x, bounds.y + bounds.height);\n+    g.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);\n+\n+    g.setColor(shadow);\n+\n+    g.drawLine(bounds.x + 1, bounds.y + bounds.height - 1,\n+               bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n+    g.drawLine(bounds.x + bounds.width - 1, bounds.y + 1,\n+               bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n+\n+    g.setColor(darkShadow);\n+\n+    g.drawLine(bounds.x, bounds.y + bounds.height, bounds.x + bounds.width,\n+               bounds.y + bounds.height);\n+    g.drawLine(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width,\n+               bounds.y + bounds.height);\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the arrow button.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    return new Dimension(getIcon().getIconWidth(), getIcon().getIconHeight());\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the arrow button.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize()\n+  {\n+    return getPreferredSize();\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the arrow button.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize()\n+  {\n+    return getPreferredSize();\n+  }\n+\n+  /**\n+   * The method paints a triangle with the given size and direction at\n+   * the given x and y coordinates.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param x The x coordinate to paint at.\n+   * @param y The y coordinate to paint at.\n+   * @param size The size of the icon.\n+   * @param direction The direction of the icon.\n+   * @param isEnabled Whether it is enabled.\n+   */\n+  public void paintTriangle(Graphics g, int x, int y, int size, int direction,\n+                            boolean isEnabled)\n+  {\n+    Polygon arrow = getArrow(direction, size);\n+    arrowIcon arrowI = new arrowIcon(arrow);\n+    arrowI.setSize(size);\n+\n+    Color arrowColor;\n+    if (isEnabled())\n+      arrowColor = darkShadow;\n+    else\n+      arrowColor = shadow;\n+\n+    arrowI.paintIconImpl(g, x, y, arrowColor);\n+  }\n+\n+  /**\n+   * This is a private helper that creates polygons for a given size \n+   * and direction.\n+   *\n+   * @param direction The direction of the arrow.\n+   * @param size The size of the arrow.\n+   *\n+   * @return A new arrow polygon.\n+   */\n+  private Polygon getArrow(int direction, int size)\n+  {\n+    Polygon arrow;\n+    double dsize = (double) size;\n+\n+    int two = (int) (dsize * 2 / 10);\n+    int three = (int) (dsize * 3 / 10);\n+    int five = (int) (dsize * 5 / 10);\n+    int seven = (int) (dsize * 7 / 10);\n+    int eight = (int) (dsize * 8 / 10);\n+    switch (direction)\n+      {\n+      case NORTH:\n+\tarrow = new Polygon(new int[] { two, five, eight },\n+\t                    new int[] { seven, three, seven }, 3);\n+\tbreak;\n+      case SOUTH:\n+\tarrow = new Polygon(new int[] { two, five, eight },\n+\t                    new int[] { three, seven, three }, 3);\n+\tbreak;\n+      case EAST:\n+      case RIGHT:\n+\tarrow = new Polygon(new int[] { three, seven, three },\n+\t                    new int[] { two, five, eight }, 3);\n+\tbreak;\n+      case WEST:\n+      case LEFT:\n+\tarrow = new Polygon(new int[] { seven, three, seven },\n+\t                    new int[] { two, five, eight }, 3);\n+\tbreak;\n+      default:\n+\tthrow new IllegalArgumentException(\"Invalid direction given.\");\n+      }\n+    return arrow;\n+  }\n+}"}, {"sha": "752b14481837b663a57d3ea96dd689df2d303939", "filename": "libjava/javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -0,0 +1,77 @@\n+/* BasicCheckBoxMenuItemUI.java\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.event.MouseEvent;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.Icon;\n+import javax.swing.JComponent;\n+import javax.swing.JMenuItem;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.ComponentUI;\n+\n+\n+public class BasicCheckBoxMenuItemUI extends BasicMenuItemUI\n+{\n+  public static ComponentUI createUI(final JComponent c)\n+  {\n+    return new BasicCheckBoxMenuItemUI();\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return null; // TODO\n+  }\n+\n+  protected void installDefaults()\n+  {\n+    super.installDefaults();\n+\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    checkIcon = defaults.getIcon(\"CheckBoxMenuItem.checkIcon\");\n+  }\n+\n+  void processMouseEvent(JMenuItem item, MouseEvent e, MenuElement[] path,\n+                         MenuSelectionManager manager)\n+  {\n+  }\n+}"}, {"sha": "ef071aa0b773585e7538c2fbc9df7b803dc79439", "filename": "libjava/javax/swing/plaf/basic/BasicIconFactory.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -196,11 +196,11 @@ public void paintIcon(Component c, Graphics g, int x, int y)\n   }\n   public static Icon getCheckBoxMenuItemIcon()\n   {\n-    return new DummyIcon();\n+    return getCheckBoxIcon();\n   }\n   public static Icon getRadioButtonMenuItemIcon()\n   {\n-    return new DummyIcon();\n+    return getRadioButtonIcon();\n   }\n   public static Icon createEmptyFrameIcon()\n   {"}, {"sha": "7a60c8e9336dd86bff8787d2a90aafa30ebc6a68", "filename": "libjava/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -501,7 +501,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"MenuBar.windowBindings\", new Object[] {\n         \"F10\", \"takeFocus\"\n       },\n-      \"MenuItem.acceleratorDelimiter\", \"+\",\n+      \"MenuItem.acceleratorDelimiter\", \"-\",\n       \"MenuItem.acceleratorFont\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"MenuItem.acceleratorForeground\", new ColorUIResource(Color.black),\n       \"MenuItem.acceleratorSelectionForeground\", new ColorUIResource(Color.white),\n@@ -703,9 +703,9 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"ctrl UP\", \"requestFocus\",\n         \"ctrl KP_UP\", \"requestFocus\"\n       }),\n-      \"TabbedPane.background\", new ColorUIResource(Color.lightGray),\n+      \"TabbedPane.background\", new ColorUIResource(Color.GRAY),\n       \"TabbedPane.contentBorderInsets\", new InsetsUIResource(2, 2, 3, 3),\n-      \"TabbedPane.darkShadow\", new ColorUIResource(Color.black),\n+      \"TabbedPane.darkShadow\", new ColorUIResource(Color.darkGray),\n       \"TabbedPane.focus\", new ColorUIResource(Color.black),\n       \"TabbedPane.focusInputMap\", new UIDefaults.LazyInputMap(new Object[] {\n         \"LEFT\",  \"navigateLeft\",\n@@ -725,8 +725,10 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"TabbedPane.lightHighlight\", new ColorUIResource(Color.white),\n       \"TabbedPane.selectedTabPadInsets\", new InsetsUIResource(2, 2, 2, 1),\n       \"TabbedPane.shadow\", new ColorUIResource(Color.gray),\n-      \"TabbedPane.tabAreaInsets\", new InsetsUIResource(3, 2, 0, 2),\n-      \"TabbedPane.tabInsets\", new InsetsUIResource(0, 4, 1, 4),\n+      \"TabbedPane.tabbedPaneTabAreaInsets\", new InsetsUIResource(3, 2, 1, 2),\n+      \"TabbedPane.tabbedPaneTabInsets\", new InsetsUIResource(1, 4, 1, 4),\n+      \"TabbedPane.tabbedPaneContentBorderInsets\", new InsetsUIResource(3, 2, 1, 2),\n+      \"TabbedPane.tabbedPaneTabPadInsets\", new InsetsUIResource(1, 1, 1, 1),\n       \"TabbedPane.tabRunOverlay\", new Integer(2),\n       \"TabbedPane.textIconGap\", new Integer(4),\n       \"Table.ancestorInputMap\", new UIDefaults.LazyInputMap(new Object[] {"}, {"sha": "fd21728be0ad3db702b0a712dab2e59b6ae2ec0e", "filename": "libjava/javax/swing/plaf/basic/BasicMenuItemUI.java", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -0,0 +1,647 @@\n+/* BasicMenuItemUI.java\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.AWTKeyStroke;\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.Stroke;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.JComponent;\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JMenuItem;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.KeyStroke;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.MenuDragMouseEvent;\n+import javax.swing.event.MenuDragMouseListener;\n+import javax.swing.event.MenuKeyEvent;\n+import javax.swing.event.MenuKeyListener;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.MenuItemUI;\n+\n+\n+public class BasicMenuItemUI extends MenuItemUI\n+{\n+  /** Font to be used when displaying menu item's accelerator. */\n+  protected Font acceleratorFont;\n+\n+  /** Color to be used when displaying menu item's accelerator. */  \n+  protected Color acceleratorForeground;\n+\n+  /** Color to be used when displaying menu item's accelerator\n+   * when menu item is selected.\n+   */ \n+  protected Color acceleratorSelectionForeground;\n+  \n+  /**\n+   * Icon that is displayed after the text to indicated that this menu\n+   * contains submenu.\n+   */\n+  protected Icon arrowIcon;\n+  \n+  /**\n+   * Icon that is displayed before the text. This icon is only used in\n+   * JCheckBoxMenuItem or JRadioBoxMenuItem.\n+   */\n+  protected Icon checkIcon;\n+\n+  /** Number of spaces between icon and text. */  \n+  protected int defaultTextIconGap = 4;\n+  \n+  /** Color of the text when menu item is disabled*/\n+  protected Color disabledForeground;\n+  \n+  /** The menu Drag mouse listener listening to the menu item. */\n+  protected MenuDragMouseListener menuDragMouseListener;\n+  \n+  /** The menu item itself*/\n+  protected JMenuItem menuItem;\n+  \n+  /** Menu Key listener listening to the menu item. */\n+  protected MenuKeyListener menuKeyListener;\n+  \n+  /** mouse input listener listening to menu item. */\n+  protected MouseInputListener mouseInputListener;\n+  \n+  /** Indicates if border should be painted  */\n+  protected boolean oldBorderPainted;\n+\n+  /** Color of text that is used when menu item is selected */\n+  protected Color selectionBackground;\n+  \n+  /** Color of the background that is used when menu item is selected.*/ \n+  protected Color selectionForeground;\n+\n+  /** String that separates description of the modifiers and the key*/  \n+  private String acceleratorDelimiter;\n+  \n+  /** Number of spaces between accelerator and menu item's label. */\n+  private int defaultAcceleratorLabelGap = 4;\n+\n+  // Constructor Summary\n+  BasicMenuItemUI()\n+  {\n+    mouseInputListener = createMouseInputListener(menuItem);\n+    menuDragMouseListener = createMenuDragMouseListener(menuItem);\n+    menuKeyListener = createMenuKeyListener(menuItem);\n+  }\n+\n+  // Method Summary\n+  protected MenuDragMouseListener createMenuDragMouseListener(JComponent c)\n+  {\n+    return new MenuDragMouseHandler();\n+  }\n+\n+  protected MenuKeyListener createMenuKeyListener(JComponent c)\n+  {\n+    return new MenuKeyHandler();\n+  }\n+\n+  protected MouseInputListener createMouseInputListener(JComponent c)\n+  {\n+    return new MouseInputHandler();\n+  }\n+\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicMenuItemUI();\n+  }\n+\n+  protected void doClick(MenuSelectionManager msm)\n+  {\n+    // TODO\n+  }\n+\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    // TODO    \n+    return null;\n+  }\n+\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    // TODO\n+    return null;\n+  }\n+\n+  public MenuElement[] getPath()\n+  {\n+    // TODO\n+    return null;\n+  }\n+\n+  protected Dimension getPreferredMenuItemSize(JComponent c, Icon checkIcon,\n+                                               Icon arrowIcon,\n+                                               int defaultTextIconGap)\n+  {\n+    // TODO\n+    return null;\n+  }\n+\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    AbstractButton b = (AbstractButton) c;\n+    Dimension d = BasicGraphicsUtils.getPreferredButtonSize(b,\n+                                                            defaultTextIconGap);\n+    \n+    // if menu item has accelerator then take accelerator's size into account\n+    // when calculating preferred size.\n+    \n+    KeyStroke accelerator = ((JMenuItem) c).getAccelerator();\n+    Rectangle rect;\n+    if (accelerator != null)\n+      {\n+        rect = getAcceleratorRect(accelerator,\n+                                  b.getToolkit().getFontMetrics(acceleratorFont));\n+        \n+        // add width of accelerator's text\n+        d.width = d.width + rect.width + defaultAcceleratorLabelGap;\n+\n+        // adjust the heigth of the preferred size if necessary\n+        if (d.height < rect.height)\n+          d.height = rect.height;\n+      }\n+\n+    if (checkIcon != null)\n+      {\n+        d.width = d.width + checkIcon.getIconWidth() + defaultTextIconGap;\n+        if (checkIcon.getIconHeight() > d.height)\n+          d.height = checkIcon.getIconHeight();\n+      }\n+      \n+    return d;\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    // TODO\n+    return null;\n+  }\n+\n+  protected void installComponents(JMenuItem menuItem)\n+  {\n+    // TODO\n+  }\n+\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    menuItem.setBackground(defaults.getColor(\"MenuItem.background\"));\n+    menuItem.setBorder(defaults.getBorder(\"MenuItem.border\"));\n+    menuItem.setFont(defaults.getFont(\"MenuItem.font\"));\n+    menuItem.setForeground(defaults.getColor(\"MenuItem.foreground\"));\n+    menuItem.setMargin(defaults.getInsets(\"MenuItem.margin\"));\n+    acceleratorFont = defaults.getFont(\"MenuItem.acceleratorFont\");\n+    acceleratorForeground = defaults.getColor(\"MenuItem.acceleratorForeground\");\n+    acceleratorSelectionForeground = defaults.getColor(\"MenuItem.acceleratorSelectionForeground\");\n+    arrowIcon = defaults.getIcon(\"MenuItem.arrowIcon\");\n+    selectionBackground = defaults.getColor(\"MenuItem.selectionBackground\");\n+    selectionForeground = defaults.getColor(\"MenuItem.selectionForeground\");\n+    acceleratorDelimiter = defaults.getString(\"MenuItem.acceleratorDelimiter\");\n+  }\n+\n+  protected void installKeyboardActions()\n+  {\n+    // TODO\n+  }\n+\n+  protected void installListeners()\n+  {\n+    menuItem.addMouseListener(mouseInputListener);\n+    menuItem.addMenuDragMouseListener(menuDragMouseListener);\n+    menuItem.addMenuKeyListener(menuKeyListener);\n+  }\n+\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    menuItem = (JMenuItem) c;\n+    installDefaults();\n+    installListeners();\n+  }\n+\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    paintMenuItem(g, c, checkIcon, arrowIcon, c.getBackground(), \n+                  c.getForeground(), defaultTextIconGap);\n+  }\n+\n+  protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n+  {\n+    Dimension size = getPreferredSize(menuItem);\n+    Color foreground = g.getColor();\n+    g.setColor(bgColor);\n+    g.drawRect(0, 0, size.width, size.height);\n+    g.setColor(foreground);\n+  }\n+\n+  protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n+                               Icon arrowIcon, Color background,\n+                               Color foreground, int defaultTextIconGap)\n+  {\n+    AbstractButton b = (AbstractButton) c;\n+    Rectangle tr = new Rectangle(); // text rectangle\n+    Rectangle ir = new Rectangle(); // icon rectangle\n+    Rectangle vr = new Rectangle(); // view rectangle\n+    Rectangle br = new Rectangle(); // border rectangle\n+    Rectangle ar = new Rectangle(); // accelerator rectangle\n+    Rectangle cr = new Rectangle(); // checkIcon rectangle\n+    \n+    int vertAlign = b.getVerticalAlignment();\n+    int horAlign = b.getHorizontalAlignment();\n+    int vertTextPos = b.getVerticalTextPosition();\n+    int horTextPos = b.getHorizontalTextPosition();\n+\n+    Font f = c.getFont();\n+    g.setFont(f);\n+    FontMetrics fm = g.getFontMetrics(f);    \n+    SwingUtilities.calculateInnerArea(b, br);\n+    SwingUtilities.calculateInsetArea(br, b.getMargin(), vr);        \n+    paintBackground(g, (JMenuItem) c, c.getBackground());\n+    \n+    if ((b.getModel().isArmed() && b.getModel().isPressed()))\n+      {\n+        if (((AbstractButton) b).isContentAreaFilled())\n+          {\n+            g.setColor(b.getBackground().darker());\n+            g.fillRect(br.x, br.y, br.width, br.height);\n+          }\n+      }\n+    else\n+      {\n+        if (((AbstractButton) b).isContentAreaFilled())\n+          {\n+            g.setColor(b.getBackground());\n+            g.fillRect(br.x, br.y, br.width, br.height);\n+          }\n+      }\n+    \n+    \n+    if (checkIcon != null)\n+      {\n+        SwingUtilities.layoutCompoundLabel(c, fm, null, checkIcon, vertAlign,\n+                                           horAlign, vertTextPos, horTextPos,\n+                                           vr, cr, tr, defaultTextIconGap);\n+        checkIcon.paintIcon(c, g, cr.x, cr.y);\n+\n+        // We need to calculate position of the menu text and position of\n+        // user menu icon if there exists one relative to the check icon.\n+\t// So we need to adjust view rectangle s.t. its starting point is at\n+\t// checkIcon.width + defaultTextIconGap. \n+\t \n+\t vr.x = cr.x + cr.width + defaultTextIconGap;\n+      }\n+\n+    if (arrowIcon != null)\n+      {\n+        // FIXME: if this menu contains a submenu, we need to draw arrow icon \n+        // here as well\n+      }\n+\n+\n+    // paint text and user menu icon if it exists\t     \n+    SwingUtilities.layoutCompoundLabel(c, fm, b.getText(), b.getIcon(),\n+                                       vertAlign, horAlign, vertTextPos,\n+                                       horTextPos, vr, ir, tr,\n+                                       defaultTextIconGap);\n+\n+    paintText(g, (JMenuItem) c, tr, b.getText());   \n+    \n+    // paint icon\n+    // FIXME: should paint different icon at different button state's.\n+    // i.e disabled icon when button is disabled.. etc.\n+    \n+    /*  \n+    Icon i = b.getIcon();\n+    if (i != null)\n+      {\n+         int x = ir.x;\n+         int y = ir.y;\n+         i.paintIcon(c, g, x, y);\n+      }\n+    */\n+        \n+    // paint accelerator    \n+    String acceleratorText = \"\";\n+    if (((JMenuItem) c).getAccelerator() != null)\n+      {\n+        acceleratorText = getAcceleratorText(((JMenuItem) c).getAccelerator());\n+        fm = g.getFontMetrics(acceleratorFont);\n+        ar.width = fm.stringWidth(acceleratorText);\n+        ar.x = br.width - ar.width;      \n+        vr.x = br.width - ar.width;\n+\t\n+        SwingUtilities.layoutCompoundLabel(c, fm, acceleratorText, null,\n+                                          vertAlign, horAlign, vertTextPos,\n+                                          horTextPos, vr, ir, ar,\n+                                          defaultTextIconGap); \n+\t\n+        paintAccelerator(g, (JMenuItem) c, ar, acceleratorText);\n+\t\n+      }          \n+\n+  }\n+\n+  protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n+                           String text)\n+  {\n+    Font f = menuItem.getFont();\n+    g.setFont(f);\n+    FontMetrics fm = g.getFontMetrics(f);\n+    g.setColor(menuItem.getForeground());\n+\n+    BasicGraphicsUtils.drawString(g, text, 0, textRect.x,\n+                                 textRect.y + fm.getAscent());\n+  }\n+\n+  protected void uninstallComponents(JMenuItem menuItem)\n+  {\n+    // TODO\n+  }\n+\n+  protected void uninstallDefaults()\n+  {\n+    menuItem.setForeground(null);\n+    menuItem.setBackground(null);\n+    menuItem.setBorder(null);\n+    menuItem.setMargin(null);\n+    menuItem.setBackground(null);\n+    menuItem.setBorder(null);\n+    menuItem.setFont(null);\n+    menuItem.setForeground(null);\n+    menuItem.setMargin(null);\n+    acceleratorFont = null;\n+    acceleratorForeground = null;\n+    acceleratorSelectionForeground = null;\n+    arrowIcon = null;\n+    selectionBackground = null;\n+    selectionForeground = null;\n+    acceleratorDelimiter = null;\n+  }\n+\n+  protected void uninstallKeyboardActions()\n+  {\n+    // TODO\n+  }\n+\n+  protected void uninstallListeners()\n+  {\n+    menuItem.removeMouseListener(mouseInputListener);\n+    menuItem.removeMenuDragMouseListener(menuDragMouseListener);\n+    menuItem.removeMenuKeyListener(menuKeyListener);\n+  }\n+\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallListeners();\n+    uninstallDefaults();\n+    menuItem = null;\n+  }\n+\n+  public void update(Graphics g, JComponent c)\n+  {\n+    // TODO\n+  }\n+\n+  private String getAcceleratorText(KeyStroke accelerator)\n+  {\n+    \n+    // convert keystroke into string format\n+    \n+    String modifiersText = \"\";\n+    int modifiers = accelerator.getModifiers();\n+    char keyChar = accelerator.getKeyChar();\n+    int keyCode = accelerator.getKeyCode();\n+\n+    if (modifiers != 0)\n+      modifiersText = KeyEvent.getKeyModifiersText(modifiers) +\n+                      acceleratorDelimiter;\n+\n+    if (keyCode == KeyEvent.VK_UNDEFINED)\n+      return modifiersText + keyChar;\n+    else\n+      return modifiersText + KeyEvent.getKeyText(keyCode);\n+  }\n+\n+  private Rectangle getAcceleratorRect(KeyStroke accelerator, FontMetrics fm)\n+  {    \n+    int width = fm.stringWidth(getAcceleratorText(accelerator));\n+    int height = fm.getHeight();\n+    return new Rectangle(0, 0, width, height);\n+  }\n+\n+  private void paintAccelerator(Graphics g, JMenuItem menuItem, Rectangle acceleratorRect,\n+                           String acceleratorText)\n+  {\n+    g.setFont(acceleratorFont);\n+    FontMetrics fm = g.getFontMetrics(acceleratorFont);\n+    g.setColor(acceleratorForeground);\n+    BasicGraphicsUtils.drawString(g, acceleratorText, 0, acceleratorRect.x,\n+                                 acceleratorRect.y + fm.getAscent());\n+  }\n+\n+  protected class MouseInputHandler implements MouseInputListener\n+  {\n+    protected MouseInputHandler()\n+    {\n+    }\n+\n+    public void mouseClicked(MouseEvent e)\n+    {\n+    }\n+\n+    public void mouseDragged(MouseEvent e)\n+    {\n+    }\n+\n+    public void mouseEntered(MouseEvent e)\n+    {\n+      if (e.getSource() instanceof AbstractButton)\n+        {\n+          AbstractButton button = (AbstractButton) e.getSource();\n+          ButtonModel model = button.getModel();\n+\n+          if (button.isRolloverEnabled())\n+            {\n+              model.setRollover(true);\n+            }\n+\n+          if (model.isPressed() &&\n+              ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0))\n+            {\n+              model.setArmed(true);\n+            }\n+          else\n+            {\n+              model.setArmed(false);\n+            }\n+        }\n+    }\n+\n+    public void mouseExited(MouseEvent e)\n+    {\n+      if (e.getSource() instanceof AbstractButton)\n+        {\n+          AbstractButton button = (AbstractButton) e.getSource();\n+          ButtonModel model = button.getModel();\n+\n+          if (button.isRolloverEnabled())\n+            {\n+              model.setRollover(false);\n+            }\n+\n+          model.setArmed(false);\n+        }\n+    }\n+\n+    public void mouseMoved(MouseEvent e)\n+    {\n+    }\n+\n+    public void mousePressed(MouseEvent e)\n+    {\n+      if (e.getSource() instanceof AbstractButton)\n+        {\n+          AbstractButton button = (AbstractButton) e.getSource();\n+          ButtonModel model = button.getModel();\n+\n+          if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+            {\n+              // It is important that these transitions happen in this order.\n+              model.setArmed(true);\n+              model.setPressed(true);\n+            }\n+        }\n+    }\n+\n+    public void mouseReleased(MouseEvent e)\n+    {\n+\n+      if (e.getSource() instanceof AbstractButton)\n+        {\n+          AbstractButton button = (AbstractButton) e.getSource();\n+          ButtonModel model = button.getModel();\n+\n+          if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+            {\n+              // It is important that these transitions happen in this order.\n+              model.setPressed(false);\n+              model.setArmed(false);\n+            }\n+        }\n+    }\n+  }\n+\n+  protected class MenuDragMouseHandler implements MenuDragMouseListener\n+  {\n+    public void menuDragMouseDragged(MenuDragMouseEvent e)\n+    {\n+      // TODO        \n+    }\n+\n+    public void menuDragMouseEntered(MenuDragMouseEvent e)\n+    {\n+      // TODO        \n+    }\n+\n+    public void menuDragMouseExited(MenuDragMouseEvent e)\n+    {\n+      // TODO        \n+    }\n+\n+    public void menuDragMouseReleased(MenuDragMouseEvent e)\n+    {\n+      // TODO        \n+    }\n+  }\n+\n+  protected class MenuKeyHandler implements MenuKeyListener\n+  {\n+    public void menuKeyPressed(MenuKeyEvent e)\n+    {\n+      // TODO        \n+    }\n+\n+    public void menuKeyReleased(MenuKeyEvent e)\n+    {\n+      // TODO        \n+    }\n+\n+    public void menuKeyTyped(MenuKeyEvent e)\n+    {\n+      // TODO    \n+    }\n+  }\n+\n+  protected class PropertyChangeHandler\n+  {\n+    public void propertyChange(PropertyChangeEvent evt)\n+    {\n+      // TODO        \n+    }\n+  }\n+}"}, {"sha": "673c502a547b74040cda73a6c6cfac4a34862e55", "filename": "libjava/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -573,7 +573,7 @@ protected void paintDeterminate(Graphics g, JComponent c)\n \t  }\n       }\n \n-    if (progressBar.isStringPainted())\n+    if (progressBar.isStringPainted() && !progressBar.getString().equals(\"\"))\n       paintString(g, 0, 0, or.width, or.height, amountFull, insets);\n     g.setColor(saved);\n   }\n@@ -605,7 +605,7 @@ protected void paintIndeterminate(Graphics g, JComponent c)\n     g.setColor(c.getForeground());\n     g.fill3DRect(box.x, box.y, box.width, box.height, true);\n \n-    if (progressBar.isStringPainted())\n+    if (progressBar.isStringPainted() && !progressBar.getString().equals(\"\"))\n       paintString(g, 0, 0, or.width, or.height,\n                   getAmountFull(insets, or.width, or.height), insets);\n "}, {"sha": "93d070e0aa3b528711edcf89714adfaaf3514740", "filename": "libjava/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -0,0 +1,78 @@\n+/* BasicRadioButtonMenuItemUI.java\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.event.MouseEvent;\n+import javax.swing.AbstractButton;\n+import javax.swing.Icon;\n+import javax.swing.JComponent;\n+import javax.swing.JMenuItem;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+\n+import javax.swing.plaf.ComponentUI;\n+\n+\n+public class BasicRadioButtonMenuItemUI extends BasicMenuItemUI\n+{\n+\n+  public BasicRadioButtonMenuItemUI()\n+  {    \n+    super();\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    checkIcon = defaults.getIcon(\"RadioButtonMenuItem.checkIcon\");\n+  }\n+\n+  public static ComponentUI createUI(JComponent b)\n+  {\n+    return new BasicRadioButtonMenuItemUI();\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return null;\n+    // TODO\n+  }\n+\n+  void processMouseEvent(JMenuItem item, MouseEvent e, MenuElement[] path,\n+                         MenuSelectionManager manager)\n+  {\n+  }\n+}"}, {"sha": "89e0ae8be208be009577d782a31fbb2c30c39c6f", "filename": "libjava/javax/swing/plaf/basic/BasicTabbedPaneUI.java", "status": "modified", "additions": 2968, "deletions": 38, "changes": 3006, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92"}, {"sha": "463865c5be94e87623c4e2740e2b97d2741da1ef", "filename": "libjava/javax/swing/plaf/basic/BasicViewportUI.java", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -127,6 +127,7 @@ public void paint(Graphics g, JComponent c)\n \n     Point pos = v.getViewPosition();\n     Rectangle viewBounds = view.getBounds();\n+    Rectangle portBounds = v.getBounds();\n \n     if (backingStoreImage == null \n         || backingStoreWidth != viewBounds.width\n@@ -138,6 +139,32 @@ public void paint(Graphics g, JComponent c)\n       }\n \n     Graphics g2 = backingStoreImage.getGraphics();\n+\n+\n+    if (c.getBackground() != null)\n+      {\n+        // fill the backing store background\n+        java.awt.Color save = g2.getColor();\n+        g2.setColor(c.getBackground());\n+        g2.fillRect (0, 0, backingStoreWidth, backingStoreHeight);\n+        g2.setColor(save);\n+\n+        // fill the viewport background\n+        save = g.getColor();\n+        g.setColor(c.getBackground());\n+        g.fillRect (0, 0, portBounds.width, portBounds.height);\n+        g.setColor(save);\n+\n+      }\n+    else\n+      {\n+        // clear the backing store background\n+        g2.clearRect(0, 0, backingStoreWidth, backingStoreHeight);\n+\n+        // clear the viewport background\n+        g.clearRect(0, 0, portBounds.width, portBounds.height);\n+      }\n+\n     view.paint(g2);\n     g2 = null;\n     g.drawImage(backingStoreImage, "}, {"sha": "8cb132e3f32f9c96ae8dafbdbc2a8f832af08617", "filename": "libjava/jni/classpath/jcl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fclasspath%2Fjcl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fclasspath%2Fjcl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fclasspath%2Fjcl.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1,5 +1,5 @@\n /* jcl.c\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,7 +37,7 @@ exception statement from your version. */\n \n #include <stdio.h>\n #include <jcl.h>\n-#include <malloc.h>\n+#include <stdlib.h>\n \n #ifndef __GNUC__\n #define __attribute__(x) /* nothing */"}, {"sha": "d92654161c869f4deb8ac2e7574a00b03c9114c2", "filename": "libjava/jni/classpath/jnilink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fclasspath%2Fjnilink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fclasspath%2Fjnilink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fclasspath%2Fjnilink.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -1,5 +1,5 @@\n /* JNILINK 1.1: JNI version.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,7 +40,7 @@ exception statement from your version. */\n #include <string.h>\n #include <jcl.h>\n \n-#include <malloc.h>\n+#include <stdlib.h>\n \n #define GETCLASS(c) *(jclass*)(c)\n "}, {"sha": "a161ba49992f6761b227e8dfdf49132f254dd6ff", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -145,7 +145,7 @@ grab_current_drawable (GtkWidget *widget, GdkDrawable **draw, GdkWindow **win)\n     }\n \n   *draw = *win;\n-  gdk_window_get_internal_paint_info (*win, draw, 0, 0);\n+  gdk_window_get_internal_paint_info (*win, draw, 0, 0); \n   g_object_ref (*draw);\n }\n \n@@ -349,7 +349,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_initState__II\n \n   if (gr->debug) printf (\"constructing offscreen drawable of size (%d,%d)\\n\",\n \t\t\t width, height);\n-  \n+\n   gr->drawable = (GdkDrawable *) gdk_pixmap_new (NULL, width, height, \n \t\t\t\t\t\t gdk_rgb_get_visual ()->depth);\n   g_assert (gr->drawable != NULL);\n@@ -371,9 +371,12 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_initState__II\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable\n   (JNIEnv *env, jobject self, jobject other, jint x, jint y)\n {\n+  GdkRectangle clipRect;\n   struct graphics2d *src = NULL, *dst = NULL;\n   gint s_height, s_width, d_height, d_width, height, width;\n+  cairo_matrix_t *matrix;\n   GdkGC *gc;\n+  cairo_operator_t tmp_op;\n \n   src = (struct graphics2d *)NSA_GET_G2D_PTR (env, other);\n   dst = (struct graphics2d *)NSA_GET_G2D_PTR (env, self);\n@@ -386,19 +389,33 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable\n   gdk_drawable_get_size (src->drawable, &s_width, &s_height);\n   gdk_drawable_get_size (dst->drawable, &d_width, &d_height);\n   width = min (s_width, d_width);\n-  height = min (s_width, d_height);\n+  height = min (s_height, d_height);\n+  gdk_threads_leave ();  \n \n-  gc = gdk_gc_new (dst->drawable);\n-  g_assert (gc != NULL);\n+  begin_drawing_operation(dst); \n \n-  gdk_draw_drawable(dst->drawable, gc, src->drawable, \n- \t\t    0, 0, x, y, width, height); \n-  gdk_flush ();\n+  matrix = cairo_matrix_create ();\n+  cairo_surface_get_matrix (src->surface, matrix);\n+  cairo_matrix_translate (matrix, (double)-x, (double)-y);\n+  cairo_surface_set_matrix (src->surface, matrix);\n \n-  g_object_unref (gc);\n+  tmp_op = cairo_current_operator (dst->cr); \n+  cairo_set_operator(dst->cr, CAIRO_OPERATOR_SRC); \n+  cairo_show_surface (dst->cr, src->surface, width, height);\n+  cairo_set_operator(dst->cr, tmp_op);\n \n-  if (src->debug) printf (\"copied %d x %d pixels from offscreen drawable\\n\", width, height);\n+  cairo_matrix_translate (matrix, (double)x, (double)y);\n+  cairo_surface_set_matrix (src->surface, matrix);\n+  cairo_matrix_destroy (matrix);\n+\n+  end_drawing_operation(dst);\n+\n+  gdk_threads_enter ();  \n+  gdk_flush ();\n   gdk_threads_leave ();  \n+\n+  if (src->debug) printf (\"copied %d x %d pixels from offscreen drawable\\n\", width, height);\n+\n }\n \n static jintArray\n@@ -1215,7 +1232,8 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClip\n   gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n   g_assert (gr != NULL);\n   if (gr->debug) printf (\"cairo_clip\\n\");\n-  cairo_clip (gr->cr);\n+  cairo_init_clip (gr->cr); \n+  cairo_clip (gr->cr); \n }\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSurfaceSetFilter"}, {"sha": "9b262d33d7d88ec3ba483aa6a6faab54e1f4b031", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkChoicePeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkChoicePeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkChoicePeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -249,9 +249,10 @@ static void\n item_activate (GtkItem *item __attribute__((unused)),\n \t       struct item_event_hook_info *ie)\n {\n+  jstring label;\n   gdk_threads_leave ();\n \n-  jstring label = (*gdk_env)->NewStringUTF (gdk_env, ie->label);\n+  label = (*gdk_env)->NewStringUTF (gdk_env, ie->label);\n   (*gdk_env)->CallVoidMethod (gdk_env, ie->peer_obj,\n \t\t\t      choicePostItemEventID,\n \t\t\t      label,"}, {"sha": "62866d5d5bdc4859b16b06d5c79f1bc68b6c1dae", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -136,7 +136,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_requestFocus\n   ptr = NSA_GET_PTR (env, obj);\n   \n   gdk_threads_enter ();\n-  gtk_widget_grab_focus (GTK_WIDGET (ptr));\n+  // gtk_widget_grab_focus (GTK_WIDGET (ptr));\n   gdk_threads_leave ();\n }\n \n@@ -386,7 +386,6 @@ Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkSetFont\n {\n   const char *font_name;\n   void *ptr;\n-  GtkWidget *label;\n   PangoFontDescription *font_desc;\n \n   ptr = NSA_GET_PTR (env, obj);\n@@ -632,12 +631,13 @@ filter_expose_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter\n   (JNIEnv *env, jobject obj)\n {\n-  void *ptr = NSA_GET_PTR (env, obj);\n-  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n-  g_assert (gref);\n   GtkObject *filterobj;\n   GtkWidget *vbox, *layout;\n   GList *children;\n+  void *ptr = NSA_GET_PTR (env, obj);\n+  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+\n+  g_assert (gref);\n \n   gdk_threads_enter ();\n \n@@ -675,12 +675,13 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilt\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter\n   (JNIEnv *env, jobject obj)\n {\n-  void *ptr = NSA_GET_PTR (env, obj);\n-  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n-  g_assert (gref);\n   GtkObject *filterobj;\n   GtkWidget *vbox, *layout;\n   GList *children;\n+  void *ptr = NSA_GET_PTR (env, obj);\n+  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+\n+  g_assert (gref);\n \n   gdk_threads_enter ();\n "}, {"sha": "9b9a3dd931aeb4a165e4b03609398f9ae39266db", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -186,6 +186,7 @@ ok_clicked (GtkButton *button __attribute__((unused)),\n   static jmethodID hideID;\n   void *ptr;\n   G_CONST_RETURN gchar *fileName;\n+  jstring str_fileName;\n \n   ptr = NSA_GET_PTR (gdk_env, peer_obj);\n   \n@@ -204,7 +205,7 @@ ok_clicked (GtkButton *button __attribute__((unused)),\n   gdk_threads_leave ();\n   \n   /* Set the Java object field 'file' with this value. */\n-  jstring str_fileName = (*gdk_env)->NewStringUTF (gdk_env, fileName);\n+  str_fileName = (*gdk_env)->NewStringUTF (gdk_env, fileName);\n   (*gdk_env)->CallVoidMethod (gdk_env, peer_obj, gtkSetFilenameID, str_fileName);\n \n   /* We can hide the dialog now (and unblock show) */"}, {"sha": "8034f64730073792abf1210ed1ef06fd071fad78", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuBarPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuBarPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuBarPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuBarPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -66,7 +66,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuBarPeer_addMenu\n   menu = NSA_GET_PTR (env, menupeer);\n \n   gdk_threads_enter ();\n-  gtk_menu_bar_append (GTK_MENU_BAR (mbar), GTK_WIDGET (menu));\n+  gtk_menu_shell_append (GTK_MENU_SHELL (mbar), GTK_WIDGET (menu));\n   gdk_threads_leave ();\n }\n "}, {"sha": "70fc809551995c202f071439de5b9dcb418747a8", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuItemPeer.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuItemPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuItemPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuItemPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -41,18 +41,16 @@ exception statement from your version. */\n #include \"gnu_java_awt_peer_gtk_GtkComponentPeer.h\"\n \n static void item_activate (GtkMenuItem *item __attribute__((unused)),\n-                           jobject *peer_obj);\n+                           jobject peer_obj);\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_create\n   (JNIEnv *env, jobject obj, jstring label)\n {\n   GtkWidget *widget;\n   const char *str;\n-  jobject *gref;\n \n   /* Create global reference and save it for future use */\n   NSA_SET_GLOBAL_REF (env, obj);\n-  gref = NSA_GET_GLOBAL_REF (env, obj);\n \n   str = (*env)->GetStringUTFChars (env, label, NULL);\n \n@@ -63,10 +61,6 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_create\n   else\n     widget = gtk_menu_item_new_with_label (str);\n \n-  /* Connect activate hook */\n-  g_signal_connect (G_OBJECT (widget), \"activate\", \n-\t\t      GTK_SIGNAL_FUNC (item_activate), *gref);\n-\n   gtk_widget_show (widget);\n \n   gdk_threads_leave ();\n@@ -76,6 +70,22 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_create\n   NSA_SET_PTR (env, obj, widget);\n }\n \n+JNIEXPORT void JNICALL\n+Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_connectSignals\n+  (JNIEnv *env, jobject obj)\n+{\n+  void *ptr = NSA_GET_PTR (env, obj);\n+  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+  g_assert (gref);\n+  \n+  gdk_threads_enter ();\n+  \n+  g_signal_connect (G_OBJECT (ptr), \"activate\",\n+                    G_CALLBACK (item_activate), *gref);\n+\n+  gdk_threads_leave ();\n+}\n+\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_setLabel\n   (JNIEnv *env, jobject obj, jstring label)\n {\n@@ -104,9 +114,9 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuItemPeer_setLabel\n }\n \n static void\n-item_activate (GtkMenuItem *item __attribute__((unused)), jobject *peer_obj)\n+item_activate (GtkMenuItem *item __attribute__((unused)), jobject peer_obj)\n {\n-  (*gdk_env)->CallVoidMethod (gdk_env, *peer_obj,\n+  (*gdk_env)->CallVoidMethod (gdk_env, peer_obj,\n \t\t\t      postMenuActionEventID);\n }\n "}, {"sha": "94ebc7f1cfa94c1879b6e5b9e69e915b15f03db1", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -101,10 +101,21 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuPeer_create\n   \n   menu = gtk_menu_new ();\n   \n-  menu_title = gtk_menu_item_new_with_label (str);\n+  if (str != NULL)\n+    menu_title = gtk_menu_item_new_with_label (str);\n+  else\n+    menu_title = gtk_menu_item_new();\n+\n   gtk_menu_item_set_submenu (GTK_MENU_ITEM (menu_title), menu);\n \n-  gtk_widget_show (menu);\n+  // Allow this menu to grab the pointer.\n+  GtkWidget *toplevel = gtk_widget_get_toplevel (menu);\n+  if (GTK_IS_WINDOW (toplevel))\n+    {\n+      gtk_window_group_add_window (global_gtk_window_group,\n+                                   GTK_WINDOW(toplevel));\n+    }\n+\n   gtk_widget_show (menu_title);\n \n   NSA_SET_PTR (env, obj, menu_title);\n@@ -125,8 +136,8 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkMenuPeer_addItem\n \n   gdk_threads_enter ();\n \n-  menu = GTK_MENU (GTK_MENU_ITEM (ptr1)->submenu);\n-  gtk_menu_append (menu, GTK_WIDGET (ptr2));\n+  menu = gtk_menu_item_get_submenu(GTK_MENU_ITEM(ptr1));\n+  gtk_menu_shell_append (GTK_MENU_SHELL(menu), GTK_WIDGET (ptr2));\n \n   if (key)\n     {"}, {"sha": "ca576437f04b3dff380adf3fa6fab0b01b5f6687", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -58,14 +58,6 @@ Java_gnu_java_awt_peer_gtk_GtkPanelPeer_create\n   NSA_SET_PTR (env, obj, widget);\n }\n \n-typedef struct _GtkLayoutChild   GtkLayoutChild;\n-\n-struct _GtkLayoutChild {\n-  GtkWidget *widget;\n-  gint x;\n-  gint y;\n-};\n-\n JNIEXPORT void JNICALL \n Java_gnu_java_awt_peer_gtk_GtkPanelPeer_connectJObject\n   (JNIEnv *env, jobject obj)\n@@ -80,59 +72,3 @@ Java_gnu_java_awt_peer_gtk_GtkPanelPeer_connectJObject\n \n   gdk_threads_leave ();\n }\n-\n-JNIEXPORT void JNICALL \n-Java_gnu_java_awt_peer_gtk_GtkPanelPeer_connectSignals\n-  (JNIEnv *env, jobject obj)\n-{\n-  void *ptr = NSA_GET_PTR (env, obj);\n-  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n-  g_assert (gref);\n-\n-  gdk_threads_enter ();\n-  gtk_widget_realize (GTK_WIDGET (ptr));\n-\n-  /* FIXME: If we don't need this then remove this method. */\n-/*    g_signal_connect (G_OBJECT (ptr), \"size_request\", GTK_SIGNAL_FUNC (sr), */\n-/*  \t\t      NULL); */\n-  gdk_threads_leave ();\n-\n-  /* Connect the superclass signals.  */\n-  Java_gnu_java_awt_peer_gtk_GtkComponentPeer_connectSignals (env, obj);\n-}\n-\n-/* FIXME: The following doesn't seem to be used.\n-   Is not declared as a native function in GtkPanelPeer.java */\n-/*\n- * Make a new panel.\n- */\n-JNIEXPORT void JNICALL \n-Java_gnu_java_awt_peer_gtk_GtkPanelPeer_gtkPanelNew\n-    (JNIEnv *env, jobject obj, jobject parent_obj)\n-{\n-  GtkWidget *layout;\n-  void *parent;\n-\n-  /* Create global reference and save it for future use */\n-  NSA_SET_GLOBAL_REF (env, obj);\n-\n-  parent = NSA_GET_PTR (env, parent_obj);\n-\n-  gdk_threads_enter ();\n-\n-  layout = gtk_layout_new (NULL, NULL);\n-  \n-  set_parent (layout, GTK_CONTAINER (parent));\n-\n-  gtk_widget_realize (layout);\n-\n-  connect_awt_hook (env, obj, 1, GTK_LAYOUT (layout)->bin_window);\n-\n-  set_visible (layout, 1);\n-\n-  gdk_threads_leave ();\n-\n-  NSA_SET_PTR (env, obj, layout);\n-}\n-\n-"}, {"sha": "4bc697320ddad3730e594f874ed34bc7abef1927", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -72,7 +72,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkPopupMenuPeer_show\n   \n   gdk_threads_enter ();\n   gtk_menu_popup (GTK_MENU (GTK_MENU_ITEM (ptr)->submenu), \n-\t\t  NULL, NULL, menu_pos, p, 3, time);\n+\t\t  NULL, NULL, menu_pos, p, 0, time);\n   gdk_threads_leave ();\n \n   g_free (p);"}, {"sha": "304a2ce34a0d89ea078a175f0ed4c03d6a0b0bbe", "filename": "libjava/testsuite/libjava.mauve/xfails", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e632d3e47f22d310f36709f6d983cb1a8dba92/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails?ref=31e632d3e47f22d310f36709f6d983cb1a8dba92", "patch": "@@ -32,7 +32,6 @@ FAIL: gnu.testlet.java.lang.String.getBytes13: String.getBytes(\"UnicodeLittleUnm\n FAIL: gnu.testlet.java.lang.String.getBytes14: String.getBytes(\"ISO8859_15\") (number 1)\n FAIL: gnu.testlet.java.lang.String.getBytes14: String.getBytes(\"UTF-16BE\") (number 1)\n FAIL: gnu.testlet.java.lang.String.getBytes14: String.getBytes(\"UTF-16LE\") (number 1)\n-FAIL: gnu.testlet.java.text.AttributedString.Test: Attribute key count (number 1)\n FAIL: gnu.testlet.java.text.DateFormatSymbols.Test: patterns (number 2)\n FAIL: gnu.testlet.java.text.SimpleDateFormat.getAndSet2DigitYearStart: get2DigitYearStart() initial (number 1)\n FAIL: gnu.testlet.java.text.DateFormatSymbols.Test: invalid locale (number 1)"}]}