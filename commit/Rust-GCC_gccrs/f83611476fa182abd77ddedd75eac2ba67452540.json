{"sha": "f83611476fa182abd77ddedd75eac2ba67452540", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzNjExNDc2ZmExODJhYmQ3N2RkZWRkNzVlYWMyYmE2NzQ1MjU0MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-16T17:38:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-16T17:38:06Z"}, "message": "class.c (build_vbase_pointer): Relocate.\n\n\t* class.c (build_vbase_pointer): Relocate.\n\t(build_vbase_pointer_fields): Likewise.\n\t(dfs_build_vbase_offset_vtbl_entries): Likewise.\n\t(build_vbase_offset_vtbl_entries): Likewise.\n\nFrom-SVN: r31442", "tree": {"sha": "e704e42467630b915211a422f75b73d90647f032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e704e42467630b915211a422f75b73d90647f032"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f83611476fa182abd77ddedd75eac2ba67452540", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83611476fa182abd77ddedd75eac2ba67452540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83611476fa182abd77ddedd75eac2ba67452540", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83611476fa182abd77ddedd75eac2ba67452540/comments", "author": null, "committer": null, "parents": [{"sha": "5bb2a29215a030947f7c9fc03b9ad8af9e6280e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb2a29215a030947f7c9fc03b9ad8af9e6280e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb2a29215a030947f7c9fc03b9ad8af9e6280e2"}], "stats": {"total": 411, "additions": 190, "deletions": 221}, "files": [{"sha": "99147e2aae4a781b4e75c5171e07bb0d85915810", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83611476fa182abd77ddedd75eac2ba67452540/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83611476fa182abd77ddedd75eac2ba67452540/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f83611476fa182abd77ddedd75eac2ba67452540", "patch": "@@ -1,5 +1,10 @@\n 2000-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (build_vbase_pointer): Relocate.\n+\t(build_vbase_pointer_fields): Likewise.\n+\t(dfs_build_vbase_offset_vtbl_entries): Likewise.\n+\t(build_vbase_offset_vtbl_entries): Likewise.\n+\n \t* decl.c (init_decl_processing): Complain if -fnew-abi\n \t-fno-vtable-thunks is used.\n "}, {"sha": "a557292757d307b5bae8f2954e157437ed30c14f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 185, "deletions": 221, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83611476fa182abd77ddedd75eac2ba67452540/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83611476fa182abd77ddedd75eac2ba67452540/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f83611476fa182abd77ddedd75eac2ba67452540", "patch": "@@ -160,65 +160,201 @@ int n_build_method_call = 0;\n int n_inner_fields_searched = 0;\n #endif\n \n-/* Virtual baseclass things.  */\n+/* Virtual base class layout.  */\n+\n+/* Returns a list of virtual base class pointers as a chain of\n+   FIELD_DECLS.  */\n \n static tree\n-build_vbase_pointer (exp, type)\n-     tree exp, type;\n+build_vbase_pointer_fields (rec, empty_p)\n+     tree rec;\n+     int *empty_p;\n {\n-  char *name;\n-  FORMAT_VBASE_NAME (name, type);\n+  /* Chain to hold all the new FIELD_DECLs which point at virtual\n+     base classes.  */\n+  tree vbase_decls = NULL_TREE;\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n+  tree decl;\n+  int i;\n \n-  return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n+  /* Handle basetypes almost like fields, but record their\n+     offsets differently.  */\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n+\n+      if (TYPE_SIZE (basetype) == 0)\n+\t/* This error is now reported in xref_tag, thus giving better\n+\t   location information.  */\n+\tcontinue;\n+\n+      /* All basetypes are recorded in the association list of the\n+\t derived type.  */\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  int j;\n+\t  const char *name;\n+\n+\t  /* The offset for a virtual base class is only used in computing\n+\t     virtual function tables and for initializing virtual base\n+\t     pointers.  It is built once `get_vbase_types' is called.  */\n+\n+\t  /* If this basetype can come from another vbase pointer\n+\t     without an additional indirection, we will share\n+\t     that pointer.  If an indirection is involved, we\n+\t     make our own pointer.  */\n+\t  for (j = 0; j < n_baseclasses; j++)\n+\t    {\n+\t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n+\t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n+\t\t  && BINFO_FOR_VBASE (basetype, BINFO_TYPE (other_base_binfo)))\n+\t\tgoto got_it;\n+\t    }\n+\t  FORMAT_VBASE_NAME (name, basetype);\n+\t  decl = build_vtbl_or_vbase_field (get_identifier (name), \n+\t\t\t\t\t    get_identifier (VTABLE_BASE),\n+\t\t\t\t\t    build_pointer_type (basetype),\n+\t\t\t\t\t    rec,\n+\t\t\t\t\t    empty_p);\n+\t  BINFO_VPTR_FIELD (base_binfo) = decl;\n+\t  TREE_CHAIN (decl) = vbase_decls;\n+\t  vbase_decls = decl;\n+\t  *empty_p = 0;\n+\n+\tgot_it:\n+\t  /* The space this decl occupies has already been accounted for.  */\n+\t  ;\n+\t}\n+    }\n+\n+  return vbase_decls;\n }\n \n-#if 0\n-/* Is the type of the EXPR, the complete type of the object?\n-   If we are going to be wrong, we must be conservative, and return 0.  */\n+/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n \n-static int\n-complete_type_p (expr)\n-     tree expr;\n+static tree\n+dfs_build_vbase_offset_vtbl_entries (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n-  while (1)\n+  tree list = (tree) data;\n+\n+  if (TREE_TYPE (list) == binfo)\n+    /* The TREE_TYPE of LIST is the base class from which we started\n+       walking.  If that BINFO is virtual it's not a virtual baseclass\n+       of itself.  */\n+    ;\n+  else if (TREE_VIA_VIRTUAL (binfo))\n     {\n-      switch (TREE_CODE (expr))\n-\t{\n-\tcase SAVE_EXPR:\n-\tcase INDIRECT_REF:\n-\tcase ADDR_EXPR:\n-\tcase NOP_EXPR:\n-\tcase CONVERT_EXPR:\n-\t  expr = TREE_OPERAND (expr, 0);\n-\t  continue;\n+      tree init;\n \n-\tcase CALL_EXPR: \n-\t  if (! TREE_HAS_CONSTRUCTOR (expr))\n-\t    break;\n-\t  /* fall through...  */\n-\tcase VAR_DECL:\n-\tcase FIELD_DECL:\n-\t  if (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t      && IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (expr)))\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type)\n-\t    return 1;\n-\t  /* fall through...  */\n-\tcase TARGET_EXPR:\n-\tcase PARM_DECL:\n-\t  if (IS_AGGR_TYPE (TREE_TYPE (expr))\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type)\n-\t    return 1;\n-\t  /* fall through...  */\n-\tcase PLUS_EXPR:\n-\tdefault:\n-\t  break;\n+      init = BINFO_OFFSET (binfo);\n+      init = build1 (NOP_EXPR, vtable_entry_type, init);\n+      TREE_VALUE (list) = tree_cons (NULL_TREE, init, TREE_VALUE (list));\n+    }\n+\n+  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Returns the initializers for the vbase offset entries in the\n+   vtable, in reverse order.  */\n+\n+static tree\n+build_vbase_offset_vtbl_entries (binfo)\n+     tree binfo;\n+{\n+  tree type;\n+  tree inits;\n+  tree init;\n+\n+  /* Under the old ABI, pointers to virtual bases are stored in each\n+     object.  */\n+  if (!flag_new_abi)\n+    return NULL_TREE;\n+\n+  /* If there are no virtual baseclasses, then there is nothing to\n+     do.  */\n+  type = BINFO_TYPE (binfo);\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (type))\n+    return NULL_TREE;\n+\n+  inits = NULL_TREE;\n+\n+  /* Under the new ABI, the vtable contains offsets to all virtual\n+     bases.  The ABI specifies different layouts depending on whether\n+     or not *all* of the bases of this type are virtual.  */\n+  if (CLASSTYPE_N_BASECLASSES (type) \n+      == list_length (CLASSTYPE_VBASECLASSES (type)))\n+    {\n+      /* In this case, the offsets are allocated from right to left of\n+\t the declaration order in which the virtual bases appear.  */\n+      int i;\n+\n+      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+\t{\n+\t  tree vbase = BINFO_BASETYPE (binfo, i);\n+\t  init = BINFO_OFFSET (vbase);\n+\t  init = build1 (NOP_EXPR, vtable_entry_type, init);\n+\t  inits = tree_cons (NULL_TREE, init, inits);\n \t}\n-      break;\n     }\n-  return 0;\n+  else\n+    {\n+      tree list;\n+\n+      /* While in this case, the offsets are allocated in the reverse\n+\t order of a depth-first left-to-right traversal of the\n+\t hierarchy.  We use BINFO_VTABLE_PATH_MARKED because we are\n+\t ourselves during a dfs_walk, and so BINFO_MARKED is already\n+\t in use.  */\n+      list = build_tree_list (type, NULL_TREE);\n+      TREE_TYPE (list) = binfo;\n+      dfs_walk (binfo,\n+\t\tdfs_build_vbase_offset_vtbl_entries,\n+\t\tdfs_vtable_path_unmarked_real_bases_queue_p,\n+\t\tlist);\n+      dfs_walk (binfo,\n+\t\tdfs_vtable_path_unmark,\n+\t\tdfs_vtable_path_marked_real_bases_queue_p,\n+\t\tlist);\n+      inits = nreverse (TREE_VALUE (list));\n+    }\n+\n+  /* We've now got offsets in the right oder.  However, the offsets\n+     we've stored are offsets from the beginning of the complete\n+     object, and we need offsets from this BINFO.  */\n+  for (init = inits; init; init = TREE_CHAIN (init))\n+    {\n+      tree exp = TREE_VALUE (init);\n+\n+      exp = ssize_binop (MINUS_EXPR, exp, BINFO_OFFSET (binfo));\n+      exp = build1 (NOP_EXPR, vtable_entry_type, TREE_VALUE (init));\n+      exp = fold (exp);\n+      TREE_CONSTANT (exp) = 1;\n+      TREE_VALUE (init) = exp;\n+    }\n+\n+  return inits;\n+}\n+\n+/* Returns a pointer to the virtual base class of EXP that has the\n+   indicated TYPE.  */\n+\n+static tree\n+build_vbase_pointer (exp, type)\n+     tree exp, type;\n+{\n+  char *name;\n+  FORMAT_VBASE_NAME (name, type);\n+\n+  return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n }\n-#endif\n \n /* Build multi-level access to EXPR using hierarchy path PATH.\n    CODE is PLUS_EXPR if we are going with the grain,\n@@ -377,6 +513,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n     return build1 (NOP_EXPR, type, expr);\n }\n \n+\f\n /* Virtual function things.  */\n \n /* Build an entry in the virtual function table.\n@@ -2180,108 +2317,6 @@ size_extra_vtbl_entries (binfo)\n   return fold (offset);\n }\n \n-/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n-\n-static tree\n-dfs_build_vbase_offset_vtbl_entries (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  tree list = (tree) data;\n-\n-  if (TREE_TYPE (list) == binfo)\n-    /* The TREE_TYPE of LIST is the base class from which we started\n-       walking.  If that BINFO is virtual it's not a virtual baseclass\n-       of itself.  */\n-    ;\n-  else if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree init;\n-\n-      init = BINFO_OFFSET (binfo);\n-      init = build1 (NOP_EXPR, vtable_entry_type, init);\n-      TREE_VALUE (list) = tree_cons (NULL_TREE, init, TREE_VALUE (list));\n-    }\n-\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-  \n-  return NULL_TREE;\n-}\n-\n-/* Returns the initializers for the vbase offset entries in the\n-   vtable, in reverse order.  */\n-\n-static tree\n-build_vbase_offset_vtbl_entries (binfo)\n-     tree binfo;\n-{\n-  tree type;\n-  tree inits;\n-  tree init;\n-\n-  type = BINFO_TYPE (binfo);\n-  if (!TYPE_USES_VIRTUAL_BASECLASSES (type))\n-    return NULL_TREE;\n-\n-  inits = NULL_TREE;\n-\n-  /* Under the new ABI, the vtable contains offsets to all virtual\n-     bases.  The ABI specifies different layouts depending on whether\n-     or not *all* of the bases of this type are virtual.  */\n-  if (CLASSTYPE_N_BASECLASSES (type) \n-      == list_length (CLASSTYPE_VBASECLASSES (type)))\n-    {\n-      /* In this case, the offsets are allocated from right to left of\n-\t the declaration order in which the virtual bases appear.  */\n-      int i;\n-\n-      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-\t{\n-\t  tree vbase = BINFO_BASETYPE (binfo, i);\n-\t  init = BINFO_OFFSET (vbase);\n-\t  init = build1 (NOP_EXPR, vtable_entry_type, init);\n-\t  inits = tree_cons (NULL_TREE, init, inits);\n-\t}\n-    }\n-  else\n-    {\n-      tree list;\n-\n-      /* While in this case, the offsets are allocated in the reverse\n-\t order of a depth-first left-to-right traversal of the\n-\t hierarchy.  We use BINFO_VTABLE_PATH_MARKED because we are\n-\t ourselves during a dfs_walk, and so BINFO_MARKED is already\n-\t in use.  */\n-      list = build_tree_list (type, NULL_TREE);\n-      TREE_TYPE (list) = binfo;\n-      dfs_walk (binfo,\n-\t\tdfs_build_vbase_offset_vtbl_entries,\n-\t\tdfs_vtable_path_unmarked_real_bases_queue_p,\n-\t\tlist);\n-      dfs_walk (binfo,\n-\t\tdfs_vtable_path_unmark,\n-\t\tdfs_vtable_path_marked_real_bases_queue_p,\n-\t\tlist);\n-      inits = nreverse (TREE_VALUE (list));\n-    }\n-\n-  /* We've now got offsets in the right oder.  However, the offsets\n-     we've stored are offsets from the beginning of the complete\n-     object, and we need offsets from this BINFO.  */\n-  for (init = inits; init; init = TREE_CHAIN (init))\n-    {\n-      tree exp = TREE_VALUE (init);\n-\n-      exp = ssize_binop (MINUS_EXPR, exp, BINFO_OFFSET (binfo));\n-      exp = build1 (NOP_EXPR, vtable_entry_type, TREE_VALUE (init));\n-      exp = fold (exp);\n-      TREE_CONSTANT (exp) = 1;\n-      TREE_VALUE (init) = exp;\n-    }\n-\n-  return inits;\n-}\n-\n /* Construct the initializer for BINFOs virtual function table.  */\n \n static tree\n@@ -2292,8 +2327,8 @@ build_vtbl_initializer (binfo)\n   tree inits = NULL_TREE;\n   tree type = BINFO_TYPE (binfo);\n \n-  if (flag_new_abi)\n-    inits = build_vbase_offset_vtbl_entries (binfo);\n+  /* Add entries to the vtable for offsets to our virtual bases.  */\n+  inits = build_vbase_offset_vtbl_entries (binfo);\n \n   /* Process the RTTI stuff at the head of the list.  If we're not\n      using vtable thunks, then the RTTI entry is just an ordinary\n@@ -3799,77 +3834,6 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type,\n   return field;\n }\n \n-/* Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n-\n-static tree\n-build_vbase_pointer_fields (rec, empty_p)\n-     tree rec;\n-     int *empty_p;\n-{\n-  /* Chain to hold all the new FIELD_DECLs which point at virtual\n-     base classes.  */\n-  tree vbase_decls = NULL_TREE;\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n-  tree decl;\n-  int i;\n-\n-  /* Handle basetypes almost like fields, but record their\n-     offsets differently.  */\n-\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (TYPE_SIZE (basetype) == 0)\n-\t/* This error is now reported in xref_tag, thus giving better\n-\t   location information.  */\n-\tcontinue;\n-\n-      /* All basetypes are recorded in the association list of the\n-\t derived type.  */\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  int j;\n-\t  const char *name;\n-\n-\t  /* The offset for a virtual base class is only used in computing\n-\t     virtual function tables and for initializing virtual base\n-\t     pointers.  It is built once `get_vbase_types' is called.  */\n-\n-\t  /* If this basetype can come from another vbase pointer\n-\t     without an additional indirection, we will share\n-\t     that pointer.  If an indirection is involved, we\n-\t     make our own pointer.  */\n-\t  for (j = 0; j < n_baseclasses; j++)\n-\t    {\n-\t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n-\t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n-\t\t  && BINFO_FOR_VBASE (basetype, BINFO_TYPE (other_base_binfo)))\n-\t\tgoto got_it;\n-\t    }\n-\t  FORMAT_VBASE_NAME (name, basetype);\n-\t  decl = build_vtbl_or_vbase_field (get_identifier (name), \n-\t\t\t\t\t    get_identifier (VTABLE_BASE),\n-\t\t\t\t\t    build_pointer_type (basetype),\n-\t\t\t\t\t    rec,\n-\t\t\t\t\t    empty_p);\n-\t  BINFO_VPTR_FIELD (base_binfo) = decl;\n-\t  TREE_CHAIN (decl) = vbase_decls;\n-\t  vbase_decls = decl;\n-\t  *empty_p = 0;\n-\n-\tgot_it:\n-\t  /* The space this decl occupies has already been accounted for.  */\n-\t  ;\n-\t}\n-    }\n-\n-  return vbase_decls;\n-}\n-\n /* If the empty base field in DECL overlaps with a base of the same type in\n    NEWDECL, which is either another base field or the first data field of\n    the class, pad the base just before NEWDECL and return 1.  Otherwise,"}]}