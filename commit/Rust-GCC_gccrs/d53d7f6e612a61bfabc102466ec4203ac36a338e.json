{"sha": "d53d7f6e612a61bfabc102466ec4203ac36a338e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzZDdmNmU2MTJhNjFiZmFiYzEwMjQ2NmVjNDIwM2FjMzZhMzM4ZQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-03-04T21:34:02Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-03-04T21:34:02Z"}, "message": "algo.h: Use std not __STD.\n\n2001-03-04  Phil Edwards  <pme@sources.redhat.com>\n\n\thttp://gcc.gnu.org/ml/libstdc++/2001-03/msg00015.html\n\t* include/backward/algo.h:  Use std not __STD.  Remove unneeded\n\tmacros and \"never happens\" code.  Adjust to C++STYLE guidelines.\n\t* include/backward/algobase.h:  Likewise.\n\t* include/backward/alloc.h:  Likewise.\n\t* include/backward/bvector.h:  Likewise.\n\t* include/backward/deque.h:  Likewise.\n\t* include/backward/function.h:  Likewise.\n\t* include/backward/hash_map.h:  Likewise.\n\t* include/backward/hash_set.h:  Likewise.\n\t* include/backward/hashtable.h:  Likewise.\n\t* include/backward/heap.h:  Likewise.\n\t* include/backward/iterator.h:  Likewise.\n\t* include/backward/list.h:  Likewise.\n\t* include/backward/map.h:  Likewise.\n\t* include/backward/multimap.h:  Likewise.\n\t* include/backward/multiset.h:  Likewise.\n\t* include/backward/pair.h:  Likewise.\n\t* include/backward/rope.h:  Likewise.\n\t* include/backward/set.h:  Likewise.\n\t* include/backward/slist.h:  Likewise.\n\t* include/backward/stack.h:  Likewise.\n\t* include/backward/strstream:  Likewise.\n\t* include/backward/tempbuf.h:  Likewise.\n\t* include/backward/tree.h:  Likewise.\n\t* include/backward/vector.h:  Likewise.\n\t* include/bits/basic_ios.h:  Likewise.\n\t* include/bits/basic_ios.tcc:  Likewise.\n\t* include/bits/basic_string.h:  Likewise.\n\t* include/bits/c++config:  Likewise.\n\t* include/bits/concept_checks.h:  Likewise.\n\t* include/bits/fpos.h:  Likewise.\n\t* include/bits/fstream.tcc:  Likewise.\n\t* include/bits/functexcept.h:  Likewise.\n\t* include/bits/ios_base.h:  Likewise.\n\t* include/bits/istream.tcc:  Likewise.\n\t* include/bits/mask_array.h:  Likewise.\n\t* include/bits/ostream.tcc:  Likewise.\n\t* include/bits/pthread_allocimpl.h:  Likewise.\n\t* include/bits/sbuf_iter.h:  Likewise.\n\t* include/bits/slice.h:  Likewise.\n\t* include/bits/slice_array.h:  Likewise.\n\t* include/bits/sstream.tcc:  Likewise.\n\t* include/bits/std_bitset.h:  Likewise.\n\t* include/bits/std_fstream.h:  Likewise.\n\t* include/bits/std_iomanip.h:  Likewise.\n\t* include/bits/std_ios.h:  Likewise.\n\t* include/bits/std_istream.h:  Likewise.\n\t* include/bits/std_iterator.h:  Likewise.\n\t* include/bits/std_memory.h:  Likewise.\n\t* include/bits/std_ostream.h:  Likewise.\n\t* include/bits/std_sstream.h:  Likewise.\n\t* include/bits/std_streambuf.h:  Likewise.\n\t* include/bits/std_string.h:  Likewise.\n\t* include/bits/std_valarray.h:  Likewise.\n\t* include/bits/stl_algo.h:  Likewise.\n\t* include/bits/stl_algobase.h:  Likewise.\n\t* include/bits/stl_alloc.h:  Likewise.\n\t* include/bits/stl_construct.h:  Likewise.\n\t* include/bits/stl_deque.h:  Likewise.\n\t* include/bits/stl_function.h:  Likewise.\n\t* include/bits/stl_heap.h:  Likewise.\n\t* include/bits/stl_iterator.h:  Likewise.\n\t* include/bits/stl_iterator_base.h:  Likewise.\n\t* include/bits/stl_list.h:  Likewise.\n\t* include/bits/stl_map.h:  Likewise.\n\t* include/bits/stl_multimap.h:  Likewise.\n\t* include/bits/stl_multiset.h:  Likewise.\n\t* include/bits/stl_numeric.h:  Likewise.\n\t* include/bits/stl_pair.h:  Likewise.\n\t* include/bits/stl_pthread_alloc.h:  Likewise.\n\t* include/bits/stl_queue.h:  Likewise.\n\t* include/bits/stl_raw_storage_iter.h:  Likewise.\n\t* include/bits/stl_relops.h:  Likewise.\n\t* include/bits/stl_set.h:  Likewise.\n\t* include/bits/stl_stack.h:  Likewise.\n\t* include/bits/stl_tempbuf.h:  Likewise.\n\t* include/bits/stl_threads.h:  Likewise.\n\t* include/bits/stl_tree.h:  Likewise.\n\t* include/bits/stl_uninitialized.h:  Likewise.\n\t* include/bits/stl_vector.h:  Likewise.\n\t* include/bits/streambuf.tcc:  Likewise.\n\t* include/bits/type_traits.h:  Likewise.\n\t* include/bits/valarray_meta.h:  Likewise.\n\t* include/ext/bvector:  Likewise.\n\t* include/ext/hash_map:  Likewise.\n\t* include/ext/hash_set:  Likewise.\n\t* include/ext/ropeimpl.h:  Likewise.\n\t* include/ext/slist:  Likewise.\n\t* include/ext/stl_bvector.h:  Likewise.\n\t* include/ext/stl_hash_fun.h:  Likewise.\n\t* include/ext/stl_hashtable.h:  Likewise.\n\t* include/ext/stl_rope.h:  Likewise.\n\t* src/complex_io.cc:  Likewise.\n\t* src/ios.cc:  Likewise.\n\t* src/locale-inst.cc:  Likewise.\n\t* src/locale.cc:  Likewise.\n\t* src/localename.cc:  Likewise.\n\t* src/misc-inst.cc:  Likewise.\n\t* src/stdexcept.cc:  Likewise.\n\t* src/stl-inst.cc:  Likewise.\n\t* src/strstream.cc:  Likewise.\n\t* src/valarray-inst.cc:  Likewise.\n\nFrom-SVN: r40239", "tree": {"sha": "d2e695fe4cb50daaed8d2ce7ac4ff5ff70c9ce1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2e695fe4cb50daaed8d2ce7ac4ff5ff70c9ce1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d53d7f6e612a61bfabc102466ec4203ac36a338e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d53d7f6e612a61bfabc102466ec4203ac36a338e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d53d7f6e612a61bfabc102466ec4203ac36a338e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d53d7f6e612a61bfabc102466ec4203ac36a338e/comments", "author": null, "committer": null, "parents": [{"sha": "04c8d9b90a16788a17fa495cbafe1f592f97a875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c8d9b90a16788a17fa495cbafe1f592f97a875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c8d9b90a16788a17fa495cbafe1f592f97a875"}], "stats": {"total": 5297, "additions": 1046, "deletions": 4251}, "files": [{"sha": "dd9ef01469730589229eb01bde44173439f370b3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,3 +1,109 @@\n+2001-03-04  Phil Edwards  <pme@sources.redhat.com>\n+\n+\thttp://gcc.gnu.org/ml/libstdc++/2001-03/msg00015.html\n+\t* include/backward/algo.h:  Use std not __STD.  Remove unneeded\n+\tmacros and \"never happens\" code.  Adjust to C++STYLE guidelines.\n+\t* include/backward/algobase.h:  Likewise.\n+\t* include/backward/alloc.h:  Likewise.\n+\t* include/backward/bvector.h:  Likewise.\n+\t* include/backward/deque.h:  Likewise.\n+\t* include/backward/function.h:  Likewise.\n+\t* include/backward/hash_map.h:  Likewise.\n+\t* include/backward/hash_set.h:  Likewise.\n+\t* include/backward/hashtable.h:  Likewise.\n+\t* include/backward/heap.h:  Likewise.\n+\t* include/backward/iterator.h:  Likewise.\n+\t* include/backward/list.h:  Likewise.\n+\t* include/backward/map.h:  Likewise.\n+\t* include/backward/multimap.h:  Likewise.\n+\t* include/backward/multiset.h:  Likewise.\n+\t* include/backward/pair.h:  Likewise.\n+\t* include/backward/rope.h:  Likewise.\n+\t* include/backward/set.h:  Likewise.\n+\t* include/backward/slist.h:  Likewise.\n+\t* include/backward/stack.h:  Likewise.\n+\t* include/backward/strstream:  Likewise.\n+\t* include/backward/tempbuf.h:  Likewise.\n+\t* include/backward/tree.h:  Likewise.\n+\t* include/backward/vector.h:  Likewise.\n+\t* include/bits/basic_ios.h:  Likewise.\n+\t* include/bits/basic_ios.tcc:  Likewise.\n+\t* include/bits/basic_string.h:  Likewise.\n+\t* include/bits/c++config:  Likewise.\n+\t* include/bits/concept_checks.h:  Likewise.\n+\t* include/bits/fpos.h:  Likewise.\n+\t* include/bits/fstream.tcc:  Likewise.\n+\t* include/bits/functexcept.h:  Likewise.\n+\t* include/bits/ios_base.h:  Likewise.\n+\t* include/bits/istream.tcc:  Likewise.\n+\t* include/bits/mask_array.h:  Likewise.\n+\t* include/bits/ostream.tcc:  Likewise.\n+\t* include/bits/pthread_allocimpl.h:  Likewise.\n+\t* include/bits/sbuf_iter.h:  Likewise.\n+\t* include/bits/slice.h:  Likewise.\n+\t* include/bits/slice_array.h:  Likewise.\n+\t* include/bits/sstream.tcc:  Likewise.\n+\t* include/bits/std_bitset.h:  Likewise.\n+\t* include/bits/std_fstream.h:  Likewise.\n+\t* include/bits/std_iomanip.h:  Likewise.\n+\t* include/bits/std_ios.h:  Likewise.\n+\t* include/bits/std_istream.h:  Likewise.\n+\t* include/bits/std_iterator.h:  Likewise.\n+\t* include/bits/std_memory.h:  Likewise.\n+\t* include/bits/std_ostream.h:  Likewise.\n+\t* include/bits/std_sstream.h:  Likewise.\n+\t* include/bits/std_streambuf.h:  Likewise.\n+\t* include/bits/std_string.h:  Likewise.\n+\t* include/bits/std_valarray.h:  Likewise.\n+\t* include/bits/stl_algo.h:  Likewise.\n+\t* include/bits/stl_algobase.h:  Likewise.\n+\t* include/bits/stl_alloc.h:  Likewise.\n+\t* include/bits/stl_construct.h:  Likewise.\n+\t* include/bits/stl_deque.h:  Likewise.\n+\t* include/bits/stl_function.h:  Likewise.\n+\t* include/bits/stl_heap.h:  Likewise.\n+\t* include/bits/stl_iterator.h:  Likewise.\n+\t* include/bits/stl_iterator_base.h:  Likewise.\n+\t* include/bits/stl_list.h:  Likewise.\n+\t* include/bits/stl_map.h:  Likewise.\n+\t* include/bits/stl_multimap.h:  Likewise.\n+\t* include/bits/stl_multiset.h:  Likewise.\n+\t* include/bits/stl_numeric.h:  Likewise.\n+\t* include/bits/stl_pair.h:  Likewise.\n+\t* include/bits/stl_pthread_alloc.h:  Likewise.\n+\t* include/bits/stl_queue.h:  Likewise.\n+\t* include/bits/stl_raw_storage_iter.h:  Likewise.\n+\t* include/bits/stl_relops.h:  Likewise.\n+\t* include/bits/stl_set.h:  Likewise.\n+\t* include/bits/stl_stack.h:  Likewise.\n+\t* include/bits/stl_tempbuf.h:  Likewise.\n+\t* include/bits/stl_threads.h:  Likewise.\n+\t* include/bits/stl_tree.h:  Likewise.\n+\t* include/bits/stl_uninitialized.h:  Likewise.\n+\t* include/bits/stl_vector.h:  Likewise.\n+\t* include/bits/streambuf.tcc:  Likewise.\n+\t* include/bits/type_traits.h:  Likewise.\n+\t* include/bits/valarray_meta.h:  Likewise.\n+\t* include/ext/bvector:  Likewise.\n+\t* include/ext/hash_map:  Likewise.\n+\t* include/ext/hash_set:  Likewise.\n+\t* include/ext/ropeimpl.h:  Likewise.\n+\t* include/ext/slist:  Likewise.\n+\t* include/ext/stl_bvector.h:  Likewise.\n+\t* include/ext/stl_hash_fun.h:  Likewise.\n+\t* include/ext/stl_hashtable.h:  Likewise.\n+\t* include/ext/stl_rope.h:  Likewise.\n+\t* src/complex_io.cc:  Likewise.\n+\t* src/ios.cc:  Likewise.\n+\t* src/locale-inst.cc:  Likewise.\n+\t* src/locale.cc:  Likewise.\n+\t* src/localename.cc:  Likewise.\n+\t* src/misc-inst.cc:  Likewise.\n+\t* src/stdexcept.cc:  Likewise.\n+\t* src/stl-inst.cc:  Likewise.\n+\t* src/strstream.cc:  Likewise.\n+\t* src/valarray-inst.cc:  Likewise.\n+\n 2001-03-03  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* src/misc-inst.cc (__copy_streambufs): Fix typo for alpha."}, {"sha": "f93a80323936fccebaa0a5a8013dcb4b6071eac7", "filename": "libstdc++-v3/include/backward/algo.h", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -32,80 +32,76 @@\n #include <bits/stl_algo.h>\n #include <bits/stl_numeric.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n // Names from <stl_algo.h>\n-using __STD::for_each; \n-using __STD::find; \n-using __STD::find_if; \n-using __STD::adjacent_find; \n-using __STD::count; \n-using __STD::count_if; \n-using __STD::search; \n-using __STD::search_n; \n-using __STD::swap_ranges; \n-using __STD::transform; \n-using __STD::replace; \n-using __STD::replace_if; \n-using __STD::replace_copy; \n-using __STD::replace_copy_if; \n-using __STD::generate; \n-using __STD::generate_n; \n-using __STD::remove; \n-using __STD::remove_if; \n-using __STD::remove_copy; \n-using __STD::remove_copy_if; \n-using __STD::unique; \n-using __STD::unique_copy; \n-using __STD::reverse; \n-using __STD::reverse_copy; \n-using __STD::rotate; \n-using __STD::rotate_copy; \n-using __STD::random_shuffle; \n-using __STD::random_sample; \n-using __STD::random_sample_n; \n-using __STD::partition; \n-using __STD::stable_partition; \n-using __STD::sort; \n-using __STD::stable_sort; \n-using __STD::partial_sort; \n-using __STD::partial_sort_copy; \n-using __STD::nth_element; \n-using __STD::lower_bound; \n-using __STD::upper_bound; \n-using __STD::equal_range; \n-using __STD::binary_search; \n-using __STD::merge; \n-using __STD::inplace_merge; \n-using __STD::includes; \n-using __STD::set_union; \n-using __STD::set_intersection; \n-using __STD::set_difference; \n-using __STD::set_symmetric_difference; \n-using __STD::min_element; \n-using __STD::max_element; \n-using __STD::next_permutation; \n-using __STD::prev_permutation; \n-using __STD::find_first_of; \n-using __STD::find_end; \n-using __STD::is_sorted; \n-using __STD::is_heap; \n+using std::for_each; \n+using std::find; \n+using std::find_if; \n+using std::adjacent_find; \n+using std::count; \n+using std::count_if; \n+using std::search; \n+using std::search_n; \n+using std::swap_ranges; \n+using std::transform; \n+using std::replace; \n+using std::replace_if; \n+using std::replace_copy; \n+using std::replace_copy_if; \n+using std::generate; \n+using std::generate_n; \n+using std::remove; \n+using std::remove_if; \n+using std::remove_copy; \n+using std::remove_copy_if; \n+using std::unique; \n+using std::unique_copy; \n+using std::reverse; \n+using std::reverse_copy; \n+using std::rotate; \n+using std::rotate_copy; \n+using std::random_shuffle; \n+using std::random_sample; \n+using std::random_sample_n; \n+using std::partition; \n+using std::stable_partition; \n+using std::sort; \n+using std::stable_sort; \n+using std::partial_sort; \n+using std::partial_sort_copy; \n+using std::nth_element; \n+using std::lower_bound; \n+using std::upper_bound; \n+using std::equal_range; \n+using std::binary_search; \n+using std::merge; \n+using std::inplace_merge; \n+using std::includes; \n+using std::set_union; \n+using std::set_intersection; \n+using std::set_difference; \n+using std::set_symmetric_difference; \n+using std::min_element; \n+using std::max_element; \n+using std::next_permutation; \n+using std::prev_permutation; \n+using std::find_first_of; \n+using std::find_end; \n+using std::is_sorted; \n+using std::is_heap; \n \n // Names from stl_heap.h\n-using __STD::push_heap;\n-using __STD::pop_heap;\n-using __STD::make_heap;\n-using __STD::sort_heap;\n+using std::push_heap;\n+using std::pop_heap;\n+using std::make_heap;\n+using std::sort_heap;\n \n // Names from stl_numeric.h\n-using __STD::accumulate; \n-using __STD::inner_product; \n-using __STD::partial_sum; \n-using __STD::adjacent_difference; \n-using __STD::power; \n-using __STD::iota; \n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::accumulate; \n+using std::inner_product; \n+using std::partial_sum; \n+using std::adjacent_difference; \n+using std::power; \n+using std::iota; \n \n #endif /* _CPP_BACKWARD_ALGO_H */\n "}, {"sha": "88e857ea31471d8b56997716ef0f2e7d2b199909", "filename": "libstdc++-v3/include/backward/algobase.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -39,30 +39,26 @@\n #include <bits/stl_uninitialized.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n // Names from stl_algobase.h\n-using __STD::iter_swap; \n-using __STD::swap; \n-using __STD::min; \n-using __STD::max; \n-using __STD::copy; \n-using __STD::copy_backward; \n-using __STD::copy_n; \n-using __STD::fill; \n-using __STD::fill_n; \n-using __STD::mismatch; \n-using __STD::equal; \n-using __STD::lexicographical_compare; \n-using __STD::lexicographical_compare_3way; \n+using std::iter_swap; \n+using std::swap; \n+using std::min; \n+using std::max; \n+using std::copy; \n+using std::copy_backward; \n+using std::copy_n; \n+using std::fill; \n+using std::fill_n; \n+using std::mismatch; \n+using std::equal; \n+using std::lexicographical_compare; \n+using std::lexicographical_compare_3way; \n \n // Names from stl_uninitialized.h\n-using __STD::uninitialized_copy;\n-using __STD::uninitialized_copy_n;\n-using __STD::uninitialized_fill;\n-using __STD::uninitialized_fill_n;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::uninitialized_copy;\n+using std::uninitialized_copy_n;\n+using std::uninitialized_fill;\n+using std::uninitialized_fill_n;\n \n #endif /* _CPP_BACKWARD_ALGOBASE_H */\n "}, {"sha": "a90f41fe5f30a08205e7a226f19a26ca8fa5a4aa", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -19,25 +19,16 @@\n #include <bits/stl_alloc.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::__malloc_alloc_template; \n-using __STD::malloc_alloc; \n-using __STD::simple_alloc; \n-using __STD::debug_alloc; \n+using std::__malloc_alloc_template; \n+using std::malloc_alloc; \n+using std::simple_alloc; \n+using std::debug_alloc; \n #ifndef __USE_MALLOC\n-using __STD::__default_alloc_template; \n+using std::__default_alloc_template; \n #endif\n-using __STD::alloc; \n-using __STD::single_client_alloc; \n-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-using __STD::__malloc_alloc_oom_handler; \n-#endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n-#ifdef __STL_USE_STD_ALLOCATORS \n-using __STD::allocator;\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::alloc; \n+using std::single_client_alloc; \n+using std::allocator;\n \n #endif /* _CPP_BACKWARD_ALLOC_H */\n "}, {"sha": "60a9ed6378fd56c4b6b57326bdf30d9debba09cc", "filename": "libstdc++-v3/include/backward/bvector.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -27,20 +27,11 @@\n #ifndef _CPP_BACKWARD_BVECTOR_H\n #define _CPP_BACKWARD_BVECTOR_H 1\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n #include \"vector.h\"\n-#else\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#endif \n \n #include <bits/stl_bvector.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::bit_vector;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::bit_vector;\n \n #endif /* _CPP_BACKWARD_BVECTOR_H */\n "}, {"sha": "65d85bfef5c495dac1f99b1250b4c79926ca3f58", "filename": "libstdc++-v3/include/backward/deque.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,9 +31,7 @@\n #include \"alloc.h\"\n #include <bits/std_deque.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::deque;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::deque;\n \n #endif /* _CPP_BACKWARD_DEQUE_H */\n "}, {"sha": "d4f4489b4463b806597a0840c5df270a7327adef", "filename": "libstdc++-v3/include/backward/function.h", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,68 +33,64 @@\n #include <bits/stl_function.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n // Names from stl_function.h\n-using __STD::unary_function; \n-using __STD::binary_function; \n-using __STD::plus; \n-using __STD::minus; \n-using __STD::multiplies; \n-using __STD::divides; \n-using __STD::identity_element; \n-using __STD::modulus; \n-using __STD::negate; \n-using __STD::equal_to; \n-using __STD::not_equal_to; \n-using __STD::greater; \n-using __STD::less; \n-using __STD::greater_equal; \n-using __STD::less_equal; \n-using __STD::logical_and; \n-using __STD::logical_or; \n-using __STD::logical_not; \n-using __STD::unary_negate; \n-using __STD::binary_negate; \n-using __STD::not1; \n-using __STD::not2; \n-using __STD::binder1st; \n-using __STD::binder2nd; \n-using __STD::bind1st; \n-using __STD::bind2nd; \n-using __STD::unary_compose; \n-using __STD::binary_compose; \n-using __STD::compose1; \n-using __STD::compose2; \n-using __STD::pointer_to_unary_function; \n-using __STD::pointer_to_binary_function; \n-using __STD::ptr_fun; \n-using __STD::identity; \n-using __STD::select1st; \n-using __STD::select2nd; \n-using __STD::project1st; \n-using __STD::project2nd; \n-using __STD::constant_void_fun; \n-using __STD::constant_unary_fun; \n-using __STD::constant_binary_fun; \n-using __STD::constant0; \n-using __STD::constant1; \n-using __STD::constant2; \n-using __STD::subtractive_rng; \n-using __STD::mem_fun_t; \n-using __STD::const_mem_fun_t; \n-using __STD::mem_fun_ref_t; \n-using __STD::const_mem_fun_ref_t; \n-using __STD::mem_fun1_t; \n-using __STD::const_mem_fun1_t; \n-using __STD::mem_fun1_ref_t; \n-using __STD::const_mem_fun1_ref_t; \n-using __STD::mem_fun; \n-using __STD::mem_fun_ref; \n-using __STD::mem_fun1; \n-using __STD::mem_fun1_ref; \n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::unary_function; \n+using std::binary_function; \n+using std::plus; \n+using std::minus; \n+using std::multiplies; \n+using std::divides; \n+using std::identity_element; \n+using std::modulus; \n+using std::negate; \n+using std::equal_to; \n+using std::not_equal_to; \n+using std::greater; \n+using std::less; \n+using std::greater_equal; \n+using std::less_equal; \n+using std::logical_and; \n+using std::logical_or; \n+using std::logical_not; \n+using std::unary_negate; \n+using std::binary_negate; \n+using std::not1; \n+using std::not2; \n+using std::binder1st; \n+using std::binder2nd; \n+using std::bind1st; \n+using std::bind2nd; \n+using std::unary_compose; \n+using std::binary_compose; \n+using std::compose1; \n+using std::compose2; \n+using std::pointer_to_unary_function; \n+using std::pointer_to_binary_function; \n+using std::ptr_fun; \n+using std::identity; \n+using std::select1st; \n+using std::select2nd; \n+using std::project1st; \n+using std::project2nd; \n+using std::constant_void_fun; \n+using std::constant_unary_fun; \n+using std::constant_binary_fun; \n+using std::constant0; \n+using std::constant1; \n+using std::constant2; \n+using std::subtractive_rng; \n+using std::mem_fun_t; \n+using std::const_mem_fun_t; \n+using std::mem_fun_ref_t; \n+using std::const_mem_fun_ref_t; \n+using std::mem_fun1_t; \n+using std::const_mem_fun1_t; \n+using std::mem_fun1_ref_t; \n+using std::const_mem_fun1_ref_t; \n+using std::mem_fun; \n+using std::mem_fun_ref; \n+using std::mem_fun1; \n+using std::mem_fun1_ref; \n \n #endif /* _CPP_BACKWARD_FUNCTION_H */\n "}, {"sha": "29ba8d5d1000ca623318cc4af6357ff11784232e", "filename": "libstdc++-v3/include/backward/hash_map.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -34,13 +34,10 @@\n #include \"algobase.h\"\n #include <bits/stl_hash_map.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-using __STD::hash_map;\n-using __STD::hash_multimap;\n-#endif /* __STL_USE_NAMESPACES */\n-\n+using std::hash;\n+using std::hashtable;\n+using std::hash_map;\n+using std::hash_multimap;\n \n #endif /* _CPP_BACKWARD_HASH_MAP_H */\n "}, {"sha": "728d7c0d851d198a3eb993b3b16e8b22457ce4f0", "filename": "libstdc++-v3/include/backward/hash_set.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -34,11 +34,9 @@\n #include \"algobase.h\"\n #include <bits/stl_hash_set.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-using __STD::hash_set;\n-using __STD::hash_multiset;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::hash;\n+using std::hashtable;\n+using std::hash_set;\n+using std::hash_multiset;\n \n #endif /* _CPP_BACKWARD_HASH_SET_H */"}, {"sha": "9ab61a3819dff0655211c7b827893e8ba0d92930", "filename": "libstdc++-v3/include/backward/hashtable.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -36,10 +36,8 @@\n #include \"alloc.h\"\n #include \"vector.h\"\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::hash;\n+using std::hashtable;\n \n #endif /* _CPP_BACKWARD_HASHTABLE_H */\n "}, {"sha": "8c73b3d1c260551d18784e03621c2b5e8caa0d76", "filename": "libstdc++-v3/include/backward/heap.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -29,15 +29,10 @@\n #include <bits/c++config.h>\n #include <bits/stl_heap.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::push_heap;\n-using __STD::pop_heap;\n-using __STD::make_heap;\n-using __STD::sort_heap;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n+using std::push_heap;\n+using std::pop_heap;\n+using std::make_heap;\n+using std::sort_heap;\n \n #endif /* _CPP_BACKWARD_HEAP_H */\n "}, {"sha": "e2b6ef58cddd4825521519a0172352d1b4f2eb78", "filename": "libstdc++-v3/include/backward/iterator.h", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -45,57 +45,51 @@\n #include <bits/stl_raw_storage_iter.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n // Names from stl_iterator.h\n \n-using __STD::input_iterator_tag;\n-using __STD::output_iterator_tag;\n-using __STD::forward_iterator_tag;\n-using __STD::bidirectional_iterator_tag;\n-using __STD::random_access_iterator_tag;\n+using std::input_iterator_tag;\n+using std::output_iterator_tag;\n+using std::forward_iterator_tag;\n+using std::bidirectional_iterator_tag;\n+using std::random_access_iterator_tag;\n \n #if 0\n-using __STD::iterator;\n+using std::iterator;\n #endif\n-using __STD::input_iterator;\n-using __STD::output_iterator;\n-using __STD::forward_iterator;\n-using __STD::bidirectional_iterator;\n-using __STD::random_access_iterator;\n+using std::input_iterator;\n+using std::output_iterator;\n+using std::forward_iterator;\n+using std::bidirectional_iterator;\n+using std::random_access_iterator;\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-using __STD::iterator_traits;\n-#endif\n+using std::iterator_traits;\n \n-using __STD::iterator_category;\n-using __STD::distance_type;\n-using __STD::value_type;\n+using std::iterator_category;\n+using std::distance_type;\n+using std::value_type;\n \n-using __STD::distance; \n-using __STD::advance; \n+using std::distance; \n+using std::advance; \n \n-using __STD::insert_iterator;\n-using __STD::front_insert_iterator;\n-using __STD::back_insert_iterator;\n-using __STD::inserter;\n-using __STD::front_inserter;\n-using __STD::back_inserter;\n+using std::insert_iterator;\n+using std::front_insert_iterator;\n+using std::back_insert_iterator;\n+using std::inserter;\n+using std::front_inserter;\n+using std::back_inserter;\n \n-using __STD::reverse_iterator;\n-using __STD::reverse_bidirectional_iterator;\n+using std::reverse_iterator;\n+using std::reverse_bidirectional_iterator;\n \n-using __STD::istream_iterator;\n-using __STD::ostream_iterator;\n+using std::istream_iterator;\n+using std::ostream_iterator;\n \n // Names from stl_construct.h\n-using __STD::construct;\n-using __STD::destroy;\n+using std::construct;\n+using std::destroy;\n \n // Names from stl_raw_storage_iter.h\n-using __STD::raw_storage_iterator;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::raw_storage_iterator;\n \n #endif /* _CPP_BACKWARD_ITERATOR_H */\n "}, {"sha": "22b5e7a8c1c5714148996358a6bf0e269d8fbf31", "filename": "libstdc++-v3/include/backward/list.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,9 +31,7 @@\n #include \"alloc.h\"\n #include <bits/std_list.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::list;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::list;\n \n #endif /* _CPP_BACKWARD_LIST_H */\n "}, {"sha": "e38a307371381bc86f8af2469faa1ad66e06beed", "filename": "libstdc++-v3/include/backward/map.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -30,9 +30,7 @@\n #include \"tree.h\"\n #include <bits/stl_map.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::map;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::map;\n \n #endif /* _CPP_BACKWARD_MAP_H */\n "}, {"sha": "b6bfec220371fbb1cea6beb502e35feb31f609fd", "filename": "libstdc++-v3/include/backward/multimap.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -30,9 +30,7 @@\n #include \"tree.h\"\n #include <bits/stl_multimap.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::multimap;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::multimap;\n \n #endif /* _CPP_BACKWARD_MULTIMAP_H */\n "}, {"sha": "f5f53abf4fa5f8fb3a91400b8451cb0b318c3f33", "filename": "libstdc++-v3/include/backward/multiset.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -30,9 +30,7 @@\n #include \"tree.h\"\n #include <bits/stl_multiset.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::multiset;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::multiset;\n \n #endif /* _CPP_BACKWARD_MULTISET_H */\n "}, {"sha": "c8f2fa3dea210db091371796ec0a49ed2af33969", "filename": "libstdc++-v3/include/backward/pair.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -32,12 +32,8 @@\n #include <bits/stl_pair.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::pair;\n-using __STD::make_pair;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::pair;\n+using std::make_pair;\n \n #endif /* _CPP_BACKWARD_PAIR_H */\n "}, {"sha": "4efa4eefc521cb5fcd1c81a6fcc4da96c2401fe4", "filename": "libstdc++-v3/include/backward/rope.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -17,15 +17,11 @@\n #include \"hashtable.h\"   \n #include <bits/stl_rope.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::char_producer; \n-using __STD::sequence_buffer; \n-using __STD::rope; \n-using __STD::crope; \n-using __STD::wrope; \n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::char_producer; \n+using std::sequence_buffer; \n+using std::rope; \n+using std::crope; \n+using std::wrope; \n \n #endif /* _CPP_BACKWARD_ROPE_H */\n "}, {"sha": "4fad9154ba0cc615539d500273bd323637c53d77", "filename": "libstdc++-v3/include/backward/set.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -30,9 +30,7 @@\n #include \"tree.h\"\n #include <bits/stl_set.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::set;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::set;\n \n #endif /* _CPP_BACKWARD_SET_H */\n "}, {"sha": "d979829328d2a3cb8381b2e18a506f9c4714b8fc", "filename": "libstdc++-v3/include/backward/slist.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -17,9 +17,7 @@\n \n #include <ext/slist>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::slist;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::slist;\n \n #endif /* _CPP_BACKWARD_SLIST_H */\n "}, {"sha": "85387e1b0c24023315ff8e17e9e7b3c04062752d", "filename": "libstdc++-v3/include/backward/stack.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,11 +33,9 @@\n #include <bits/stl_stack.h>\n #include <bits/stl_queue.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::stack;\n-using __STD::queue;\n-using __STD::priority_queue;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::stack;\n+using std::queue;\n+using std::priority_queue;\n \n #endif /* _CPP_BACKWARD_STACK_H */\n "}, {"sha": "51db6b5c91fa3d104b8489bd260adb3650ca5809", "filename": "libstdc++-v3/include/backward/strstream", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -29,7 +29,8 @@\n #include <bits/std_ostream.h>\n #include <bits/std_string.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n //----------------------------------------------------------------------\n // Class strstreambuf, a streambuf class that manages an array of char.\n@@ -150,7 +151,7 @@ private:\n   strstreambuf _M_buf;\n };\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_STRSTREAM */\n "}, {"sha": "b8d36d7937387658b5e5e08da8f15c4bd84078ee", "filename": "libstdc++-v3/include/backward/tempbuf.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -47,13 +47,9 @@\n #include <bits/stl_tempbuf.h>\n #endif\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::get_temporary_buffer;\n-using __STD::return_temporary_buffer;\n-using __STD::_Temporary_buffer;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::get_temporary_buffer;\n+using std::return_temporary_buffer;\n+using std::_Temporary_buffer;\n \n #endif /* _CPP_BACKWARD_TEMPBUF_H */\n "}, {"sha": "bca51de6f51fa12bfbfa59cf13cc82b67da22070", "filename": "libstdc++-v3/include/backward/tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -35,9 +35,7 @@\n #include \"algobase.h\" \n #include \"alloc.h\"\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::rb_tree;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::rb_tree;\n \n #endif /* _CPP_BACKWARD_TREE_H */\n "}, {"sha": "23aa5370495546086ab61d395ecb821eb14f2e06", "filename": "libstdc++-v3/include/backward/vector.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,9 +31,7 @@\n #include \"alloc.h\"  \n #include <bits/stl_vector.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-using __STD::vector;\n-#endif /* __STL_USE_NAMESPACES */\n+using std::vector;\n \n #endif /* _CPP_BACKWARD_VECTOR_H */\n "}, {"sha": "efaf2c7e0ac51f6a248dce672f0c6b620da6ba32", "filename": "libstdc++-v3/include/bits/basic_ios.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -214,9 +214,3 @@ namespace std {\n #endif /* _CPP_BITS_BASICIOS_H */\n \n \n-\n-\n-\n-\n-\n-"}, {"sha": "d561b3bcbe0f61598f8cd86992839c4bd944ee68", "filename": "libstdc++-v3/include/bits/basic_ios.tcc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -135,6 +135,3 @@ namespace std {\n #endif /* _CPP_BITS_BASICIOS_TCC */\n \n \n-\n-\n-"}, {"sha": "4067396311d17f8e433a92d7d27e56f3989c643a", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -38,7 +38,8 @@\n \n #include <bits/atomicity.h>\n \n-namespace std {\n+namespace std\n+{\n \n   // Documentation?  What's that? \n   // Nathan Myers <ncm@cantrip.org>."}, {"sha": "63c9762b9a368700c9231050db3166aa1ed15cc5", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 30, "deletions": 49, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -55,7 +55,6 @@\n // Use corrected code from the committee library group's issues list.\n #define _GLIBCPP_RESOLVE_LIB_DEFECTS 1\n \n-\n // From SGI's stl_config.h; generic settings and user hooks (_NOTHREADS).\n #if defined(_PTHREADS) && !defined(_NOTHREADS)\n #    define __STL_PTHREADS\n@@ -64,18 +63,13 @@\n #    define __STL_UITHREADS\n #endif\n \n-// Also from SGI's stl_config.h; settings for GCC.\n-#define __STL_HAS_WCHAR_T\n-#define __STL_MEMBER_TEMPLATES\n-#define __STL_MEMBER_TEMPLATE_CLASSES\n-#define __STL_TEMPLATE_FRIENDS\n-#define __STL_CLASS_PARTIAL_SPECIALIZATION \n-#define __STL_PARTIAL_SPECIALIZATION_SYNTAX \n-#define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-#define __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n-#define __SGI_STL_USE_AUTO_PTR_CONVERSIONS\n-#define __STL_HAS_NAMESPACES\n-#define __STL_USE_NAMESPACES\n+// Concept-checking code is on by default unless users define\n+// the _STL_NO_CONCEPT_CHECKS hook.\n+#if !defined(_STL_NO_CONCEPT_CHECKS)\n+#  define __STL_USE_CONCEPT_CHECKS\n+#endif\n+\n+// This is also a user hook, but via -f[no-]exceptions, not direct #defines.\n #ifdef __EXCEPTIONS\n #  define __STL_USE_EXCEPTIONS\n #  define __STL_TRY try\n@@ -92,57 +86,49 @@\n #  define __STL_NOTHROW \n #  define __STL_UNWIND(action) \n #endif\n-#define __STL_THROW_RANGE_ERRORS \n-#define __STL_CAN_THROW_RANGE_ERRORS \n-#define __STL_USE_STD_ALLOCATORS \n-#define __USE_MALLOC // As the \"underlying allocator\"\n-//#define __STL_USE_NEW_IOSTREAMS //990209 bkoz--use standard .h includes.\n+\n+// This is the \"underlying allocator\"\n+#define __USE_MALLOC\n+\n+// Define this to permit user-level control of the expansion of string\n+// buffers (via a fn pointer), see basic_string.* for more.\n+//#define _GLIBCPP_ALLOC_CONTROL\n+\n+// The remainder of the prewritten config is mostly automatic; all the\n+// user hooks are listed above.\n+\n #ifdef _REENTRANT\n #  define __STL_THREADS\n #endif\n #ifdef _PTHREADS\n #  define __STL_PTHREADS\n #endif\n-#ifndef __STRICT_ANSI__\n-#  define __STL_LONG_LONG\n-#endif\n+//#ifndef __STRICT_ANSI__\n+//#  define __STL_LONG_LONG\n+//#endif\n+\n+// 20010302 pme -- this is only used in bits/concept_checks.h\n //#if (__GNUC__ < 2) || (__GNUC__ == 2 && __GNUC_MINOR__ < 95)\n #  define __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE\n //#endif\n \n-// Also from SGI's stl_config.h; settings for GCC.\n-// Mingw32, GCC compiler using the Microsoft C runtime\n+// Mingw32, GCC compiler using the Microsoft C runtime (settings taken from\n+// SGI's stl_config.h)\n #if defined(__MINGW32__)\n #  define __STL_NO_DRAND48\n #  ifdef _MT\n #    define __STL_WIN32THREADS\n #  endif\n #endif\n \n-// Cygwin32, GCC compiler on MS Windows\n+// Cygwin32, GCC compiler on MS Windows (settings taken from SGI's\n+// stl_config.h)\n #if defined(__CYGWIN__)\n #  define __STL_NO_DRAND48\n #endif\n \n-// The old stl_config.h would use the above settings in chains of\n-// if/then/else tests to define the following.\n-#define __STL_DEPENDENT_DEFAULT_TMPL(_Tp) = _Tp\n-#define __STL_TEMPLATE\n-#define __STL_NULL_TMPL_ARGS <>\n-#define __STL_TEMPLATE_NULL template<>\n-#define __STL_DEFAULT_ALLOCATOR(T) allocator< T >\n-\n-#define __STL_USE_NAMESPACES\n-#define __STD std\n-#define __STL_BEGIN_NAMESPACE namespace std {\n-#define __STL_END_NAMESPACE }\n-#define __STL_USE_NAMESPACE_FOR_RELOPS\n-#define __STL_BEGIN_RELOPS_NAMESPACE namespace std { namespace rel_ops {\n-#define __STL_END_RELOPS_NAMESPACE } }\n-#define __STD_RELOPS std::rel_ops\n-#define __STD_QUALIFIER std::\n-\n-\n+// XXX Only used in the SGI rope extensions; this is from stl_config.h and\n+// should be cleaned up.\n #ifdef __STL_ASSERTIONS\n # include <stdio.h>\n # define __stl_assert(expr) \\\n@@ -152,6 +138,7 @@\n # define __stl_assert(expr)\n #endif\n \n+\n #if defined(__STL_WIN32THREADS) || defined(__STL_SGI_THREADS) \\\n     || defined(__STL_PTHREADS)  || defined(__STL_UITHREADS)\n #   define __STL_THREADS\n@@ -160,12 +147,6 @@\n #   define __STL_VOLATILE\n #endif\n \n-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \\\n-    && defined(__STL_MEMBER_TEMPLATES) \\\n-    && !defined(_STL_NO_CONCEPT_CHECKS)\n-#  define __STL_USE_CONCEPT_CHECKS\n-#endif\n-\n \n // End of prewritten config; the discovered settings follow.\n "}, {"sha": "aa77d9af06307974f383e32d342822aa40960772", "filename": "libstdc++-v3/include/bits/concept_checks.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -490,34 +490,35 @@ struct _STL_ERROR {\n \n /* Associated Type Requirements */\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n template <class _Iterator> struct iterator_traits;\n-__STL_END_NAMESPACE\n+} // namespace std\n \n template <class _Iter> \n struct __value_type_type_definition_requirement_violation {\n-  typedef typename __STD::iterator_traits<_Iter>::value_type value_type;\n+  typedef typename std::iterator_traits<_Iter>::value_type value_type;\n };\n \n template <class _Iter> \n struct __difference_type_type_definition_requirement_violation {\n-  typedef typename __STD::iterator_traits<_Iter>::difference_type\n+  typedef typename std::iterator_traits<_Iter>::difference_type\n           difference_type;\n };\n \n template <class _Iter> \n struct __reference_type_definition_requirement_violation {\n-  typedef typename __STD::iterator_traits<_Iter>::reference reference;\n+  typedef typename std::iterator_traits<_Iter>::reference reference;\n };\n \n template <class _Iter> \n struct __pointer_type_definition_requirement_violation {\n-  typedef typename __STD::iterator_traits<_Iter>::pointer pointer;\n+  typedef typename std::iterator_traits<_Iter>::pointer pointer;\n };\n \n template <class _Iter> \n struct __iterator_category_type_definition_requirement_violation {\n-  typedef typename __STD::iterator_traits<_Iter>::iterator_category \n+  typedef typename std::iterator_traits<_Iter>::iterator_category \n           iterator_category;\n };\n \n@@ -797,8 +798,7 @@ _Allocator_requirement_violation(_Alloc __a) {\n   __pointer__typedef_requirement_violation<_Alloc>();\n   __const_pointer__typedef_requirement_violation<_Alloc>();\n   typedef typename _Alloc::value_type _Tp;\n-  //__STL_REQUIRES_SAME_TYPE(typename _Alloc::__STL_TEMPLATE rebind<_Tp>::other,\n-  //                         _Alloc);\n+//  __STL_REQUIRES_SAME_TYPE(typename _Alloc::template rebind<_Tp>::other, _Alloc);\n }\n };\n "}, {"sha": "9dc8decd77cf3dae63ccee04f39f96f38f847346", "filename": "libstdc++-v3/include/bits/fpos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -41,7 +41,8 @@\n // not have included the std_ios file.\n #include <bits/c++io.h>\n \n-namespace std {\n+namespace std\n+{\n \n   // 27.4.1  Types\n "}, {"sha": "3969dcd566ed8ee300a1a3698e4f2a0775c8276a", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -580,11 +580,3 @@ namespace std\n #endif // _CPP_BITS_FSTREAM_TCC\n \n \n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "eac2c95b4327a73ba2764d39daf82433cdebeed8", "filename": "libstdc++-v3/include/bits/functexcept.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -82,3 +82,4 @@ namespace std\n   void\n   __throw_ios_failure(const char* __s);\n } // namespace std\n+"}, {"sha": "ce68bf188edb22f1e4676e9fe87e86882bb2d337", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -36,7 +36,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n+namespace std\n+{\n \n   // The following definitions of bitmask types are enums, not ints,\n   // as permitted (but not required) in the standard, in order to provide\n@@ -568,11 +569,3 @@ namespace std {\n \n #endif /* _CPP_BITS_IOSBASE_H */\n \n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "121dee279b57610a32594fabb0b999693819ec83", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1207,16 +1207,3 @@ namespace std {\n // mode:C++\n // End:\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "b2399ba1fa79ef9045ba4a1e2795e2411c6fef40", "filename": "libstdc++-v3/include/bits/mask_array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- mask_array class.\n \n-// Copyright (C) 1997-2001, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997-2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the"}, {"sha": "50f3b9b38e174662e72b719b02708363778f8598", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -672,12 +672,3 @@ namespace std {\n // mode:C++\n // End:\n \n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "195905a3acea9559da982f3eb2e0124b81048468", "filename": "libstdc++-v3/include/bits/pthread_allocimpl.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -34,11 +34,10 @@\n #  define __RESTRICT\n #endif\n \n-#ifndef __STL_NO_BAD_ALLOC\n-#  include <new>\n-#endif\n+#include <new>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n #define __STL_DATA_ALIGNMENT 8\n \n@@ -213,15 +212,15 @@ _Pthread_alloc_template<_Max_size>::_S_get_per_thread_state()\n     _Pthread_alloc_per_thread_state<_Max_size> * __result;\n     if (!_S_key_initialized) {\n         if (pthread_key_create(&_S_key, _S_destructor)) {\n-\t    __THROW_BAD_ALLOC;  // defined in stl_alloc.h\n+\t    std::__throw_bad_alloc();  // defined in funcexcept.h\n         }\n         _S_key_initialized = true;\n     }\n     __result = _S_new_per_thread_state();\n     __ret_code = pthread_setspecific(_S_key, __result);\n     if (__ret_code) {\n       if (__ret_code == ENOMEM) {\n-\t__THROW_BAD_ALLOC;\n+\tstd::__throw_bad_alloc();\n       } else {\n \t// EINVAL\n \tabort();\n@@ -377,7 +376,6 @@ template <size_t _Max_size>\n size_t _Pthread_alloc_template<_Max_size>\n ::_S_heap_size = 0;\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n \n template <class _Tp>\n class pthread_allocator {\n@@ -484,9 +482,7 @@ struct _Alloc_traits<_Tp, pthread_allocator<_Atype> >\n };\n \n \n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_PTHREAD_ALLOCIMPL_H */\n "}, {"sha": "2b2a1915eee3042c343a770597dd47beb2f1bcf0", "filename": "libstdc++-v3/include/bits/sbuf_iter.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -250,17 +250,3 @@ namespace std\n \n #endif /* _CPP_BITS_SBUF_ITER_H */\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "5efb6e8cf4c288d1cbd0b6853c8f33c198fef2af", "filename": "libstdc++-v3/include/bits/slice.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- slice class.\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,7 +34,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n+namespace std\n+{\n \n class slice\n {"}, {"sha": "a38da2a837c08877694f82ca90342ac4129ed67f", "filename": "libstdc++-v3/include/bits/slice_array.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- slice_array class.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,7 +34,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n+namespace std\n+{\n     \n     template<typename _Tp>\n     class slice_array"}, {"sha": "b2c5703f8b4b5bd1618a07a90451d3d701fcb28a", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // String based streams -*- C++ -*-\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,7 +36,8 @@\n \n #include <bits/std_sstream.h>\n \n-namespace std {\n+namespace std\n+{\n \n   template <class _CharT, class _Traits, class _Alloc>\n     basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n@@ -210,11 +211,3 @@ namespace std {\n \n #endif\t/* _CPP_BITS_SSTREAM_TCC */\n \n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "9ea657fc9d158090003d4d756f3d6c6476d6deb6", "filename": "libstdc++-v3/include/bits/std_bitset.h", "status": "modified", "additions": 6, "deletions": 123, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -38,21 +38,14 @@\n #include <bits/std_stdexcept.h>   // for invalid_argument, out_of_range, \n \t\t\t\t  // overflow_error\n \n-#ifdef __STL_USE_NEW_IOSTREAMS \n-#include <iostream>\n-#else\n #include <bits/std_iostream.h>   // for istream, ostream\n-#endif\n \n #define _GLIBCPP_BITSET_BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))\n #define __BITSET_WORDS(__n) \\\n  ((__n) < 1 ? 1 : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1209\n-#endif\n+namespace std\n+{\n \n // structure to aid in counting bits\n template<bool __dummy> \n@@ -315,7 +308,7 @@ _Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n // Base class: specialization for a single word.\n //\n \n-__STL_TEMPLATE_NULL struct _Base_bitset<1> {\n+template<> struct _Base_bitset<1> {\n   typedef unsigned long _WordT;\n   _WordT _M_w;\n \n@@ -381,7 +374,7 @@ template <size_t _Extrabits> struct _Sanitize {\n     { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n };\n \n-__STL_TEMPLATE_NULL struct _Sanitize<0> {\n+template<> struct _Sanitize<0> {\n   static void _M_do_sanitize(unsigned long) {}\n };\n \n@@ -466,7 +459,6 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n   bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n     { _M_do_sanitize(); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template<class _CharT, class _Traits, class _Alloc>\n   explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n                   size_t __pos = 0)\n@@ -487,17 +479,6 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n       __STL_THROW(out_of_range(\"bitset\"));\n     _M_copy_from_string(__s, __pos, __n);\n   }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  explicit bitset(const basic_string<char>& __s,\n-                  size_t __pos = 0,\n-                  size_t __n = basic_string<char>::npos) \n-    : _Base() \n-  {\n-    if (__pos > __s.size()) \n-      __STL_THROW(out_of_range(\"bitset\"));\n-    _M_copy_from_string(__s, __pos, __n);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   // 23.3.5.2 bitset operations:\n   bitset<_Nb>& operator&=(const bitset<_Nb>& __rhs) {\n@@ -619,29 +600,21 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n \n   unsigned long to_ulong() const { return this->_M_do_to_ulong(); }\n \n-#if defined(__STL_MEMBER_TEMPLATES) && \\\n-    defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)\n   template <class _CharT, class _Traits, class _Alloc>\n   basic_string<_CharT, _Traits, _Alloc> to_string() const {\n     basic_string<_CharT, _Traits, _Alloc> __result;\n     _M_copy_to_string(__result);\n     return __result;\n   }\n-#endif /* member templates and explicit function template args */\n \n   // Helper functions for string operations.\n-#ifdef __STL_MEMBER_TEMPLATES\n   template<class _CharT, class _Traits, class _Alloc>\n   void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n                           size_t,\n                           size_t);\n \n   template<class _CharT, class _Traits, class _Alloc>\n   void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void _M_copy_from_string(const basic_string<char>&, size_t, size_t);\n-  void _M_copy_to_string(basic_string<char>&) const;\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   size_t count() const { return this->_M_do_count(); }\n \n@@ -689,8 +662,6 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n // Definitions of non-inline member functions.\n //\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <size_t _Nb>\n template<class _CharT, class _Traits, class _Alloc>\n void bitset<_Nb>\n@@ -725,40 +696,6 @@ void bitset<_Nb>\n       __s[_Nb - 1 - __i] = '1';\n }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <size_t _Nb>\n-void bitset<_Nb>::_M_copy_from_string(const basic_string<char>& __s,\n-                                      size_t __pos, size_t __n)\n-{\n-  reset();\n-  size_t __tmp = _Nb;\n-  const size_t __nbits = min(__tmp, min(__n, __s.size() - __pos));\n-  for (size_t __i = 0; __i < __nbits; ++__i) {\n-    switch(__s[__pos + __nbits - __i - 1]) {\n-    case '0':\n-      break;\n-    case '1':\n-      set(__i);\n-      break;\n-    default:\n-      __STL_THROW(invalid_argument(\"bitset\"));\n-    }\n-  }\n-}\n-\n-template <size_t _Nb>\n-void bitset<_Nb>::_M_copy_to_string(basic_string<char>& __s) const\n-{\n-  __s.assign(_Nb, '0');\n-  \n-  for (size_t __i = 0; __i < _Nb; ++__i) \n-    if (_Unchecked_test(__i))\n-      __s[_Nb - 1 - __i] = '1';\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n // ------------------------------------------------------------\n \n //\n@@ -787,8 +724,6 @@ inline bitset<_Nb> operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n   return __result;\n }\n \n-#ifdef __STL_USE_NEW_IOSTREAMS\n-\n template <class _CharT, class _Traits, size_t _Nb>\n basic_istream<_CharT, _Traits>&\n operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n@@ -802,7 +737,7 @@ operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n   if (__sentry) {\n     basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n     for (size_t __i = 0; __i < _Nb; ++__i) {\n-      static _Traits::int_type __eof = _Traits::eof();\n+      static typename _Traits::int_type __eof = _Traits::eof();\n \n       typename _Traits::int_type __c1 = __buf->sbumpc();\n       if (_Traits::eq_int_type(__c1, __eof)) {\n@@ -840,59 +775,7 @@ operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)\n   return __os << __tmp;\n }\n \n-#else /* __STL_USE_NEW_IOSTREAMS */\n-\n-template <size_t _Nb>\n-istream& operator>>(istream& __is, bitset<_Nb>& __x) {\n-  string __tmp;\n-  __tmp.reserve(_Nb);\n-\n-  if (__is.flags() & ios::skipws) {\n-    char __c;\n-    do \n-      __is.get(__c);\n-    while (__is && isspace(__c));\n-    if (__is)\n-      __is.putback(__c);\n-  }\n-\n-  for (size_t __i = 0; __i < _Nb; ++__i) {\n-    char __c;\n-    __is.get(__c);\n-\n-    if (!__is)\n-      break;\n-    else if (__c != '0' && __c != '1') {\n-      __is.putback(__c);\n-      break;\n-    }\n-    else\n-      __tmp.push_back(__c);\n-  }\n-\n-  if (__tmp.empty()) \n-    __is.clear(__is.rdstate() | ios::failbit);\n-  else\n-    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n-\n-  return __is;\n-}\n-\n-template <size_t _Nb>\n-ostream& operator<<(ostream& __os, const bitset<_Nb>& __x) {\n-  string __tmp;\n-  __x._M_copy_to_string(__tmp);\n-  return __os << __tmp;\n-}\n-\n-#endif /* __STL_USE_NEW_IOSTREAMS */\n-\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1209\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #undef __BITSET_WORDS\n "}, {"sha": "4516f1b7f72c795fe36a7fc2b7558d95f443026a", "filename": "libstdc++-v3/include/bits/std_fstream.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -416,8 +416,3 @@ namespace std {\n \n #endif\t/* _CPP_FSTREAM */\n \n-\n-\n-\n-\n-"}, {"sha": "5e0cb91bdc1f5f798beda55b6c20fd8ab4534290", "filename": "libstdc++-v3/include/bits/std_iomanip.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // Standard stream manipulators -*- C++ -*-\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -40,7 +40,8 @@\n #include <bits/std_istream.h>\n #include <bits/std_functional.h>\n \n-namespace std {\n+namespace std\n+{\n \n   struct _Resetiosflags { ios_base::fmtflags _M_mask; };\n \n@@ -215,7 +216,3 @@ namespace std {\n \n #endif\t/* __IOMANIP */\n \n-\n-\n-\n-"}, {"sha": "abedfe6abc45877d19e4a4a5927339d285e1846e", "filename": "libstdc++-v3/include/bits/std_ios.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -47,7 +47,3 @@\n \n #endif\t/* _CPP_IOS */\n \n-\n-\n-\n-"}, {"sha": "bfaec7033c6b3381089bffc80fb3abd34a223454", "filename": "libstdc++-v3/include/bits/std_istream.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // Input streams -*- C++ -*-\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,7 +39,8 @@\n #include <bits/std_ios.h>\n #include <bits/std_limits.h> // For numeric_limits\n \n-namespace std {\n+namespace std\n+{\n \n   // 27.6.1.1 Template class basic_istream\n   template<typename _CharT, typename _Traits>\n@@ -300,10 +301,3 @@ namespace std {\n \n #endif\t/* _CPP_ISTREAM */\n \n-\n-\n-\n-\n-\n-\n-"}, {"sha": "f45771572792e61c948bfe3f8d36965fd0909e22", "filename": "libstdc++-v3/include/bits/std_iterator.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -40,7 +40,3 @@\n // mode:C++\n // End:\n \n-\n-\n-\n-"}, {"sha": "0f58c08b43612ea78f1e7b33a335fd67e6c2905a", "filename": "libstdc++-v3/include/bits/std_memory.h", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -25,18 +25,14 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_raw_storage_iter.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n-#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \\\n-     defined(__STL_MEMBER_TEMPLATES)\n- \n  template<class _Tp1> struct auto_ptr_ref {\n    _Tp1* _M_ptr;\n    auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}\n };\n \n-#endif\n-\n template <class _Tp> class auto_ptr {\n private:\n   _Tp* _M_ptr;\n@@ -47,23 +43,19 @@ template <class _Tp> class auto_ptr {\n   explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) {}\n   auto_ptr(auto_ptr& __a) __STL_NOTHROW : _M_ptr(__a.release()) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW\n     : _M_ptr(__a.release()) {}\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   auto_ptr& operator=(auto_ptr& __a) __STL_NOTHROW {\n     reset(__a.release());\n     return *this;\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Tp1>\n   auto_ptr& operator=(auto_ptr<_Tp1>& __a) __STL_NOTHROW {\n     reset(__a.release());\n     return *this;\n   }\n-#endif /* __STL_MEMBER_TEMPLATES */\n   \n   // Note: The C++ standard says there is supposed to be an empty throw\n   // specification here, but omitting it is standard conforming.  Its \n@@ -96,10 +88,6 @@ template <class _Tp> class auto_ptr {\n   // present-day compilers, however, do not enforce that requirement---and, \n   // in fact, most present-day compilers do not support the language \n   // features that these conversions rely on.\n-  \n-#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \\\n-    defined(__STL_MEMBER_TEMPLATES)\n-\n public:\n   auto_ptr(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW\n     : _M_ptr(__ref._M_ptr) {}\n@@ -116,11 +104,9 @@ template <class _Tp> class auto_ptr {\n     { return auto_ptr_ref<_Tp>(this->release()); }\n   template <class _Tp1> operator auto_ptr<_Tp1>() __STL_NOTHROW\n     { return auto_ptr<_Tp1>(this->release()); }\n-\n-#endif /* auto ptr conversions && member templates */\n };\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_MEMORY */\n "}, {"sha": "6cd64b8d7c7f4f3ed20fc0471004cb7dbcd1b974", "filename": "libstdc++-v3/include/bits/std_ostream.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -38,8 +38,8 @@\n \n #include <bits/std_ios.h>\n \n-namespace std {\n-  \n+namespace std\n+{\n   // 27.6.2.1 Template class basic_ostream\n   template<typename _CharT, typename _Traits>\n     class basic_ostream : virtual public basic_ios<_CharT, _Traits>"}, {"sha": "9a1e75a2118629769931fd9c51f00f2b22238ea7", "filename": "libstdc++-v3/include/bits/std_sstream.h", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -39,8 +39,8 @@\n #include <bits/std_istream.h>\n #include <bits/std_ostream.h>\n \n-namespace std {\n-\n+namespace std\n+{\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>\n     {\n@@ -350,19 +350,5 @@ namespace std {\n #endif\n #endif\n \n-\n #endif\t/* _CPP_SSTREAM */\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "304beeea7b7ebbff0df3521b11611ec59b169744", "filename": "libstdc++-v3/include/bits/std_streambuf.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -42,8 +42,8 @@\n #include <bits/localefwd.h>\n #include <bits/ios_base.h>\n \n-namespace std {\n-\n+namespace std\n+{\n   template<typename _CharT, typename _Traits>\n     streamsize\n     __copy_streambufs(basic_ios<_CharT, _Traits>& _ios,\n@@ -537,13 +537,3 @@ namespace std {\n \n #endif\t/* _CPP_STREAMBUF */\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "b781b43a64ab585177742a035df3c862db1304db", "filename": "libstdc++-v3/include/bits/std_string.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -52,15 +52,3 @@\n \n #endif /* _CPP_STRING */\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "99f17e482b6b883aa01ad3470a1decd74c28b972", "filename": "libstdc++-v3/include/bits/std_valarray.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- valarray class.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -42,8 +42,8 @@\n #include <bits/std_functional.h>\n #include <bits/std_algorithm.h>\n \n-namespace std {\n-\n+namespace std\n+{\n     template<class _Clos, typename _Tp> class _Expr;\n \n     template<typename _Tp1, typename _Tp2> class _ValArray;    \n@@ -82,13 +82,13 @@ namespace std {\n     template<class _Tp> class mask_array;     // masked array\n     template<class _Tp> class indirect_array; // indirected array\n \n-}\n+} // namespace std\n \n #include <bits/valarray_array.h>\n #include <bits/valarray_meta.h>\n   \n-namespace std {\n-\n+namespace std\n+{\n   template<class _Tp> class valarray\n   {\n   public:\n@@ -254,8 +254,8 @@ namespace std {\n #include <bits/mask_array.h>\n #include <bits/indirect_array.h>\n \n-namespace std {\n-\n+namespace std\n+{\n   template<typename _Tp>\n   inline valarray<_Tp>::valarray () : _M_size (0), _M_data (0) {}\n \n@@ -627,7 +627,8 @@ _DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(>>, shift_right)\n } // std::\n   \n \n-namespace std {\n+namespace std\n+{\n \n #define _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(_Op, _Name)          \\\n   template<class _Tp> template<class _Dom>\t\t\t\t\\"}, {"sha": "090f0d6720eb20e892f3729cfd814b1328073cca", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -36,12 +36,8 @@\n // See concept_checks.h for the concept-checking macros \n // __STL_REQUIRES, __STL_CONVERTIBLE, etc.\n \n-\n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1209\n-#endif\n+namespace std\n+{\n \n // __median (an extension, not present in the C++ standard).\n \n@@ -113,8 +109,6 @@ inline _InputIter find_if(_InputIter __first, _InputIter __last,\n   return __first;\n }\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _RandomAccessIter, class _Tp>\n _RandomAccessIter find(_RandomAccessIter __first, _RandomAccessIter __last,\n                        const _Tp& __val,\n@@ -191,8 +185,6 @@ _RandomAccessIter find_if(_RandomAccessIter __first, _RandomAccessIter __last,\n   }\n }\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _InputIter, class _Tp>\n inline _InputIter find(_InputIter __first, _InputIter __last,\n                        const _Tp& __val)\n@@ -277,8 +269,6 @@ void count_if(_InputIter __first, _InputIter __last, _Predicate __pred,\n       ++__n;\n }\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _InputIter, class _Tp>\n typename iterator_traits<_InputIter>::difference_type\n count(_InputIter __first, _InputIter __last, const _Tp& __value) {\n@@ -307,8 +297,6 @@ count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {\n }\n \n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n // search.\n \n template <class _ForwardIter1, class _ForwardIter2>\n@@ -3098,8 +3086,6 @@ _ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n }\n \n // find_end for bidirectional iterators.  Requires partial specialization.\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _BidirectionalIter1, class _BidirectionalIter2>\n _BidirectionalIter1\n __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n@@ -3152,7 +3138,6 @@ __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n     return __result;\n   }\n }\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // Dispatching functions for find_end.\n \n@@ -3284,11 +3269,7 @@ bool is_sorted(_ForwardIter __first, _ForwardIter __last,\n   return true;\n }\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1209\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_ALGO_H */\n "}, {"sha": "c4620c1c6a3682446f4784433836f070b409b32c", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 3, "deletions": 112, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -45,18 +45,14 @@\n #include <bits/std_cstddef.h>\n #include <new>\n \n-#ifdef __STL_USE_NEW_IOSTREAMS \n-#include <iosfwd>\n-#else /* __STL_USE_NEW_IOSTREAMS */\n #include <bits/std_iosfwd.h>\n-#endif /* __STL_USE_NEW_IOSTREAMS */\n-\n #include <bits/stl_iterator_base.h>\n #include <bits/stl_iterator.h>\n \n // We pick up concept_checks.h from stl_iterator_base.h.\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // swap and iter_swap\n \n@@ -89,8 +85,6 @@ inline void swap(_Tp& __a, _Tp& __b) {\n //--------------------------------------------------\n // min and max\n \n-#if !defined(__BORLANDC__) || __BORLANDC__ >= 0x540 /* C++ Builder 4.0 */\n-\n #undef min\n #undef max\n \n@@ -108,8 +102,6 @@ inline const _Tp& max(const _Tp& __a, const _Tp& __b) {\n   if (__a < __b) return __b; return __a;\n }\n \n-#endif /* __BORLANDC__ */\n-\n template <class _Tp, class _Compare>\n inline const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp) {\n   //return __comp(__b, __a) ? __b : __a;\n@@ -161,7 +153,6 @@ __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n   return __result + (__last - __first);\n }\n \n-#if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)\n \n template <class _InputIter, class _OutputIter>\n inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,\n@@ -240,91 +231,6 @@ inline _OutputIter copy(_InputIter __first, _InputIter __last,\n    return __copy_ni1(__first, __last, __result, __Normal());\n }\n \n-// Hack for compilers that don't have partial ordering of function templates\n-// but do have partial specialization of class templates.\n-#elif defined(__STL_CLASS_PARTIAL_SPECIALIZATION)\n-\n-template <class _InputIter, class _OutputIter, class _BoolType>\n-struct __copy_dispatch {\n-  static _OutputIter copy(_InputIter __first, _InputIter __last,\n-                          _OutputIter __result) {\n-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n-    typedef typename iterator_traits<_InputIter>::difference_type _Distance;\n-    return __copy(__first, __last, __result, _Category(), (_Distance*) 0);\n-  }\n-};\n-\n-template <class _Tp>\n-struct __copy_dispatch<_Tp*, _Tp*, __true_type>\n-{\n-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n-    return __copy_trivial(__first, __last, __result);\n-  }\n-};\n-\n-template <class _Tp>\n-struct __copy_dispatch<const _Tp*, _Tp*, __true_type>\n-{\n-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n-    return __copy_trivial(__first, __last, __result);\n-  }\n-};\n-\n-template <class _InputIter, class _OutputIter>\n-inline _OutputIter copy(_InputIter __first, _InputIter __last,\n-                        _OutputIter __result) {\n-  __STL_REQUIRES(_InputIter, _InputIterator);\n-  __STL_REQUIRES(_OutputIter, _OutputIterator);\n-  typedef typename iterator_traits<_InputIter>::value_type _Tp;\n-  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator\n-          _Trivial;\n-  return __copy_dispatch<_InputIter, _OutputIter, _Trivial>\n-    ::copy(__first, __last, __result);\n-}\n-\n-// Fallback for compilers with neither partial ordering nor partial\n-// specialization.  Define the faster version for the basic builtin\n-// types.\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class _InputIter, class _OutputIter>\n-inline _OutputIter copy(_InputIter __first, _InputIter __last,\n-                        _OutputIter __result)\n-{\n-  return __copy(__first, __last, __result,\n-                __ITERATOR_CATEGORY(__first),\n-                __DISTANCE_TYPE(__first));\n-}\n-\n-#define __SGI_STL_DECLARE_COPY_TRIVIAL(_Tp)                                \\\n-  inline _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) { \\\n-    memmove(__result, __first, sizeof(_Tp) * (__last - __first));          \\\n-    return __result + (__last - __first);                                  \\\n-  }\n-\n-__SGI_STL_DECLARE_COPY_TRIVIAL(char)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(signed char)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned char)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(short)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned short)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(int)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned int)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(long)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long)\n-#ifdef __STL_HAS_WCHAR_T\n-__SGI_STL_DECLARE_COPY_TRIVIAL(wchar_t)\n-#endif\n-#ifdef _STL_LONG_LONG\n-__SGI_STL_DECLARE_COPY_TRIVIAL(long long)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long long)\n-#endif \n-__SGI_STL_DECLARE_COPY_TRIVIAL(float)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(double)\n-__SGI_STL_DECLARE_COPY_TRIVIAL(long double)\n-\n-#undef __SGI_STL_DECLARE_COPY_TRIVIAL\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n //--------------------------------------------------\n // copy_backward\n \n@@ -353,7 +259,6 @@ inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,\n   return __result;\n }\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n \n // This dispatch class is a workaround for compilers that do not \n // have partial ordering of function templates.  All we're doing is\n@@ -443,17 +348,6 @@ inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {\n                                                __Normal());\n }\n \n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class _BI1, class _BI2>\n-inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {\n-  return __copy_backward(__first, __last, __result,\n-                         __ITERATOR_CATEGORY(__first),\n-                         __DISTANCE_TYPE(__first));\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n //--------------------------------------------------\n // copy_n (not part of the C++ standard)\n \n@@ -531,8 +425,6 @@ inline void fill(char* __first, char* __last, const char& __c) {\n   memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Size>\n inline unsigned char* fill_n(unsigned char* __first, _Size __n,\n                              const unsigned char& __c) {\n@@ -553,7 +445,6 @@ inline char* fill_n(char* __first, _Size __n, const char& __c) {\n   return __first + __n;\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n //--------------------------------------------------\n // equal and mismatch\n@@ -746,7 +637,7 @@ int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n   return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_ALGOBASE_H */\n "}, {"sha": "9a0ef07e604482c997861089a1a4917b451074e7", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 12, "deletions": 90, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -18,37 +18,14 @@\n #ifndef __SGI_STL_INTERNAL_ALLOC_H\n #define __SGI_STL_INTERNAL_ALLOC_H\n \n-#ifdef __SUNPRO_CC\n-#  define __PRIVATE public\n-   // Extra access restrictions prevent us from really making some things\n-   // private.\n-#else\n-#  define __PRIVATE private\n-#endif\n-\n-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-#  define __USE_MALLOC\n-#endif\n-\n-\n // This implements some standard node allocators.  These are\n // NOT the same as the allocators in the C++ draft standard or in\n // in the original STL.  They do not encapsulate different pointer\n // types; indeed we assume that there is only one pointer type.\n // The allocation primitives are intended to allocate individual objects,\n // not larger arenas as with the original STL allocators.\n \n-#ifndef __THROW_BAD_ALLOC\n-#  if defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)\n-#    include <bits/std_cstdio.h>\n-#    include <bits/std_cstdlib.h>\n-#    define __THROW_BAD_ALLOC fprintf(stderr, \"out of memory\\n\"); exit(1)\n-#  else /* Standard conforming out-of-memory handling */\n-#    include <new>\n-#    define __THROW_BAD_ALLOC throw std::bad_alloc()\n-#  endif\n-#endif\n-\n+#include <bits/functexcept.h>   // for __throw_bad_alloc\n #include <bits/std_cstddef.h>\n #include <bits/std_cstdlib.h>\n #include <bits/std_cstring.h>\n@@ -88,34 +65,19 @@\n #   define __NODE_ALLOCATOR_THREADS false\n #endif\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#endif\n+namespace std\n+{\n \n // Malloc-based allocator.  Typically slower than default alloc below.\n // Typically thread-safe and more storage efficient.\n-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-# ifdef __DECLARE_GLOBALS_HERE\n-    void (* __malloc_alloc_oom_handler)() = 0;\n-    // g++ 2.7.2 does not handle static template data members.\n-# else\n-    extern void (* __malloc_alloc_oom_handler)();\n-# endif\n-#endif\n-\n template <int __inst>\n class __malloc_alloc_template {\n \n private:\n \n   static void* _S_oom_malloc(size_t);\n   static void* _S_oom_realloc(void*, size_t);\n-\n-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n   static void (* __malloc_alloc_oom_handler)();\n-#endif\n \n public:\n \n@@ -149,10 +111,8 @@ class __malloc_alloc_template {\n \n // malloc_alloc out-of-memory handling\n \n-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n template <int __inst>\n void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;\n-#endif\n \n template <int __inst>\n void*\n@@ -163,7 +123,7 @@ __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n \n     for (;;) {\n         __my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        if (0 == __my_malloc_handler) { std::__throw_bad_alloc(); }\n         (*__my_malloc_handler)();\n         __result = malloc(__n);\n         if (__result) return(__result);\n@@ -178,7 +138,7 @@ void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)\n \n     for (;;) {\n         __my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        if (0 == __my_malloc_handler) { std::__throw_bad_alloc(); }\n         (*__my_malloc_handler)();\n         __result = realloc(__p, __n);\n         if (__result) return(__result);\n@@ -278,40 +238,26 @@ typedef malloc_alloc single_client_alloc;\n // Node that containers built on different allocator instances have\n // different types, limiting the utility of this approach.\n \n-#if defined(__SUNPRO_CC) || defined(__GNUC__)\n-// breaks if we make these template class members:\n-  enum {_ALIGN = 8};\n-  enum {_MAX_BYTES = 128};\n-  enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN\n-#endif\n-\n template <bool threads, int inst>\n class __default_alloc_template {\n \n private:\n   // Really we should use static const int x = N\n   // instead of enum { x = N }, but few compilers accept the former.\n-#if ! (defined(__SUNPRO_CC) || defined(__GNUC__))\n-    enum {_ALIGN = 8};\n-    enum {_MAX_BYTES = 128};\n-    enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN\n-# endif\n+  enum {_ALIGN = 8};\n+  enum {_MAX_BYTES = 128};\n+  enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN\n   static size_t\n   _S_round_up(size_t __bytes) \n     { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }\n \n-__PRIVATE:\n   union _Obj {\n         union _Obj* _M_free_list_link;\n         char _M_client_data[1];    /* The client sees this.        */\n   };\n-private:\n-# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)\n-    static _Obj* __STL_VOLATILE _S_free_list[]; \n+\n+  static _Obj* __STL_VOLATILE _S_free_list[]; \n         // Specifying a size results in duplicate def for 4.1\n-# else\n-    static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; \n-# endif\n   static  size_t _S_freelist_index(size_t __bytes) {\n         return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);\n   }\n@@ -409,14 +355,12 @@ inline bool operator==(const __default_alloc_template<__threads, __inst>&,\n   return true;\n }\n \n-# ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n template <bool __threads, int __inst>\n inline bool operator!=(const __default_alloc_template<__threads, __inst>&,\n                        const __default_alloc_template<__threads, __inst>&)\n {\n   return false;\n }\n-# endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n \n \n@@ -563,11 +507,7 @@ size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n template <bool __threads, int __inst>\n typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE\n __default_alloc_template<__threads, __inst> ::_S_free_list[\n-# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)\n-    _NFREELISTS\n-# else\n     __default_alloc_template<__threads, __inst>::_NFREELISTS\n-# endif\n ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n // The 16 zeros are necessary to make version 4.1 of the SunPro\n // compiler happy.  Otherwise it appears to allocate too little\n@@ -583,8 +523,6 @@ __default_alloc_template<__threads, __inst> ::_S_free_list[\n // templates, the typename keyword, and the use of the template keyword\n // to refer to a template member of a dependent type.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n template <class _Tp>\n class allocator {\n   typedef alloc _Alloc;          // The underlying allocator.\n@@ -726,14 +664,12 @@ inline bool operator==(const __allocator<_Tp, _Alloc>& __a1,\n   return __a1.__underlying_alloc == __a2.__underlying_alloc;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n template <class _Tp, class _Alloc>\n inline bool operator!=(const __allocator<_Tp, _Alloc>& __a1,\n                        const __allocator<_Tp, _Alloc>& __a2)\n {\n   return __a1.__underlying_alloc != __a2.__underlying_alloc;\n }\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n // Comparison operators for all of the predifined SGI-style allocators.\n // This ensures that __allocator<malloc_alloc> (for example) will\n@@ -746,28 +682,24 @@ inline bool operator==(const __malloc_alloc_template<inst>&,\n   return true;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n template <int __inst>\n inline bool operator!=(const __malloc_alloc_template<__inst>&,\n                        const __malloc_alloc_template<__inst>&)\n {\n   return false;\n }\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n template <class _Alloc>\n inline bool operator==(const debug_alloc<_Alloc>&,\n                        const debug_alloc<_Alloc>&) {\n   return true;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n template <class _Alloc>\n inline bool operator!=(const debug_alloc<_Alloc>&,\n                        const debug_alloc<_Alloc>&) {\n   return false;\n }\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n // Another allocator adaptor: _Alloc_traits.  This serves two\n // purposes.  First, make it possible to write containers that can use\n@@ -801,8 +733,7 @@ template <class _Tp, class _Allocator>\n struct _Alloc_traits\n {\n   static const bool _S_instanceless = false;\n-  typedef typename _Allocator::__STL_TEMPLATE rebind<_Tp>::other \n-          allocator_type;\n+  typedef typename _Allocator::template rebind<_Tp>::other allocator_type;\n };\n \n template <class _Tp, class _Allocator>\n@@ -882,16 +813,7 @@ struct _Alloc_traits<_Tp, __allocator<_Tp1, debug_alloc<_Alloc> > >\n   typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;\n };\n \n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#endif\n-\n-__STL_END_NAMESPACE\n-\n-#undef __PRIVATE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_ALLOC_H */\n "}, {"sha": "e423bdd3a77452ce2114713dfd689c22e07c7aec", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,7 +33,8 @@\n \n #include <new>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // construct and destroy.  These functions are not part of the C++ standard,\n // and are provided for backward compatibility with the HP STL. We also\n@@ -88,9 +89,7 @@ inline void _Destroy(int*, int*) {}\n inline void _Destroy(long*, long*) {}\n inline void _Destroy(float*, float*) {}\n inline void _Destroy(double*, double*) {}\n-#ifdef __STL_HAS_WCHAR_T\n inline void _Destroy(wchar_t*, wchar_t*) {}\n-#endif /* __STL_HAS_WCHAR_T */\n \n // --------------------------------------------------\n // Old names from the HP STL.\n@@ -115,7 +114,7 @@ inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {\n   _Destroy(__first, __last);\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_CONSTRUCT_H */\n "}, {"sha": "040152d9da1dccfb9e4f08639e425125cf77ecc1", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 8, "deletions": 339, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -67,12 +67,8 @@\n  * template template parameters), and it has been removed.\n  */\n \n-__STL_BEGIN_NAMESPACE \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{ \n \n // Note: this function is simply a kludge to work around several compilers'\n //  bugs in handling constant expressions.\n@@ -110,9 +106,7 @@ struct _Deque_iterator {\n       _M_last(__x._M_last), _M_node(__x._M_node) {}\n \n   reference operator*() const { return *_M_cur; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return _M_cur; }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   difference_type operator-(const _Self& __x) const {\n     return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +\n@@ -202,33 +196,13 @@ operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n   return __x + __n;\n }\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-inline random_access_iterator_tag\n-iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr>&)\n-{\n-  return random_access_iterator_tag();\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-inline _Tp* value_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) { return 0; }\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-inline ptrdiff_t* distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // Deque base class.  It has two purposes.  First, its constructor\n //  and destructor allocate (but don't initialize) storage.  This makes\n //  exception safety easier.  Second, the base class encapsulates all of\n //  the differences between SGI-style allocators and standard-conforming\n //  allocators.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // Base class for ordinary allocators.\n template <class _Tp, class _Alloc, bool __is_static>\n class _Deque_alloc_base {\n@@ -323,52 +297,6 @@ class _Deque_base\n   iterator _M_finish;\n };\n \n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc>\n-class _Deque_base {\n-public:\n-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Deque_base(const allocator_type&, size_t __num_elements)\n-    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {\n-    _M_initialize_map(__num_elements);\n-  }\n-  _Deque_base(const allocator_type&)\n-    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {}\n-  ~_Deque_base();    \n-\n-protected:\n-  void _M_initialize_map(size_t);\n-  void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n-  void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n-  enum { _S_initial_map_size = 8 };\n-\n-protected:\n-  _Tp** _M_map;\n-  size_t _M_map_size;  \n-  iterator _M_start;\n-  iterator _M_finish;\n-\n-  typedef simple_alloc<_Tp, _Alloc>  _Node_alloc_type;\n-  typedef simple_alloc<_Tp*, _Alloc> _Map_alloc_type;\n-\n-  _Tp* _M_allocate_node()\n-    { return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); }\n-  void _M_deallocate_node(_Tp* __p)\n-    { _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n-  _Tp** _M_allocate_map(size_t __n) \n-    { return _Map_alloc_type::allocate(__n); }\n-  void _M_deallocate_map(_Tp** __p, size_t __n) \n-    { _Map_alloc_type::deallocate(__p, __n); }\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n // Non-inline member functions from _Deque_base.\n \n template <class _Tp, class _Alloc>\n@@ -423,7 +351,7 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n     _M_deallocate_node(*__n);\n }\n \n-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n+template <class _Tp, class _Alloc = allocator<_Tp> >\n class deque : protected _Deque_base<_Tp, _Alloc> {\n \n   // requirements:\n@@ -447,23 +375,14 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   typedef typename _Base::iterator       iterator;\n   typedef typename _Base::const_iterator const_iterator;\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n   typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                           difference_type>  \n-          const_reverse_iterator;\n-  typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-          reverse_iterator; \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:                      // Internal typedefs\n   typedef pointer* _Map_pointer;\n   static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n protected:\n-#ifdef __STL_USE_NAMESPACES\n   using _Base::_M_initialize_map;\n   using _Base::_M_create_nodes;\n   using _Base::_M_destroy_nodes;\n@@ -476,7 +395,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   using _Base::_M_map_size;\n   using _Base::_M_start;\n   using _Base::_M_finish;\n-#endif /* __STL_USE_NAMESPACES */\n \n public:                         // Basic accessors\n   iterator begin() { return _M_start; }\n@@ -496,7 +414,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   const_reference operator[](size_type __n) const \n     { return _M_start[difference_type(__n)]; }\n \n-#ifdef __STL_THROW_RANGE_ERRORS\n   void _M_range_check(size_type __n) const {\n     if (__n >= this->size())\n       __throw_range_error(\"deque\");\n@@ -506,7 +423,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     { _M_range_check(__n); return (*this)[__n]; }\n   const_reference at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n-#endif /* __STL_THROW_RANGE_ERRORS */\n \n   reference front() { return *_M_start; }\n   reference back() {\n@@ -536,8 +452,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   explicit deque(size_type __n) : _Base(allocator_type(), __n)\n     { _M_fill_initialize(value_type()); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InputIterator>\n   deque(_InputIterator __first, _InputIterator __last,\n@@ -558,19 +472,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  deque(const value_type* __first, const value_type* __last,\n-        const allocator_type& __a = allocator_type()) \n-    : _Base(__a, __last - __first)\n-    { uninitialized_copy(__first, __last, _M_start); }\n-  deque(const_iterator __first, const_iterator __last,\n-        const allocator_type& __a = allocator_type()) \n-    : _Base(__a, __last - __first)\n-    { uninitialized_copy(__first, __last, _M_start); }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   ~deque() { destroy(_M_start, _M_finish); }\n \n   deque& operator= (const deque& __x) {\n@@ -588,10 +489,10 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   }        \n \n   void swap(deque& __x) {\n-    __STD::swap(_M_start, __x._M_start);\n-    __STD::swap(_M_finish, __x._M_finish);\n-    __STD::swap(_M_map, __x._M_map);\n-    __STD::swap(_M_map_size, __x._M_map_size);\n+    std::swap(_M_start, __x._M_start);\n+    std::swap(_M_finish, __x._M_finish);\n+    std::swap(_M_map, __x._M_map);\n+    std::swap(_M_map_size, __x._M_map_size);\n   }\n \n public: \n@@ -615,8 +516,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     _M_fill_assign(__n, __val);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   template <class _InputIterator>\n   void assign(_InputIterator __first, _InputIterator __last) {\n     typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -654,8 +553,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n       erase(copy(__first, __last, begin()), end());\n   }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:                         // push_* and pop_*\n   \n   void push_back(const value_type& __t) {\n@@ -739,8 +636,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n   void _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InputIterator>\n   void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n@@ -761,15 +656,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     insert(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert(iterator __pos,\n-              const value_type* __first, const value_type* __last);\n-  void insert(iterator __pos,\n-              const_iterator __first, const_iterator __last);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   void resize(size_type __new_size, const value_type& __x) {\n     const size_type __len = size();\n     if (__new_size < __len) \n@@ -803,8 +689,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n   void _M_fill_initialize(const value_type& __value);\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n   template <class _InputIterator>\n   void _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                         input_iterator_tag);\n@@ -813,8 +697,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                         forward_iterator_tag);\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n protected:                        // Internal push_* and pop_*\n \n   void _M_push_back_aux(const value_type&);\n@@ -826,8 +708,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n protected:                        // Internal insert functions\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n   template <class _InputIterator>\n   void insert(iterator __pos, _InputIterator __first, _InputIterator __last,\n               input_iterator_tag);\n@@ -837,31 +717,15 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n               _ForwardIterator __first, _ForwardIterator __last,\n               forward_iterator_tag);\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   iterator _M_insert_aux(iterator __pos, const value_type& __x);\n   iterator _M_insert_aux(iterator __pos);\n   void _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n   template <class _ForwardIterator>\n   void _M_insert_aux(iterator __pos, \n                      _ForwardIterator __first, _ForwardIterator __last,\n                      size_type __n);\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-  \n-  void _M_insert_aux(iterator __pos,\n-                     const value_type* __first, const value_type* __last,\n-                     size_type __n);\n-\n-  void _M_insert_aux(iterator __pos, \n-                     const_iterator __first, const_iterator __last,\n-                     size_type __n);\n- \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   iterator _M_reserve_elements_at_front(size_type __n) {\n     size_type __vacancies = _M_start._M_cur - _M_start._M_first;\n     if (__n > __vacancies) \n@@ -900,8 +764,6 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n // Non-inline member functions\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc>\n template <class _InputIter>\n void deque<_Tp, _Alloc>\n@@ -916,8 +778,6 @@ void deque<_Tp, _Alloc>\n     insert(end(), __first, __last);\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n                                         size_type __n, const value_type& __x)\n@@ -943,62 +803,6 @@ void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n     _M_insert_aux(__pos, __n, __x);\n }\n \n-#ifndef __STL_MEMBER_TEMPLATES  \n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp, _Alloc>::insert(iterator __pos,\n-                                const value_type* __first,\n-                                const value_type* __last) {\n-  size_type __n = __last - __first;\n-  if (__pos._M_cur == _M_start._M_cur) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    __STL_TRY {\n-      uninitialized_copy(__first, __last, __new_start);\n-      _M_start = __new_start;\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n-  }\n-  else if (__pos._M_cur == _M_finish._M_cur) {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    __STL_TRY {\n-      uninitialized_copy(__first, __last, _M_finish);\n-      _M_finish = __new_finish;\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));\n-  }\n-  else\n-    _M_insert_aux(__pos, __first, __last, __n);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::insert(iterator __pos,\n-                               const_iterator __first, const_iterator __last)\n-{\n-  size_type __n = __last - __first;\n-  if (__pos._M_cur == _M_start._M_cur) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    __STL_TRY {\n-      uninitialized_copy(__first, __last, __new_start);\n-      _M_start = __new_start;\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n-  }\n-  else if (__pos._M_cur == _M_finish._M_cur) {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    __STL_TRY {\n-      uninitialized_copy(__first, __last, _M_finish);\n-      _M_finish = __new_finish;\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                 __new_finish._M_node + 1));\n-  }\n-  else\n-    _M_insert_aux(__pos, __first, __last, __n);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n typename deque<_Tp,_Alloc>::iterator \n deque<_Tp,_Alloc>::erase(iterator __first, iterator __last)\n@@ -1062,8 +866,6 @@ void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n   __STL_UNWIND(destroy(_M_start, iterator(*__cur, __cur)));\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n template <class _Tp, class _Alloc> template <class _InputIterator>\n void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,\n                                             _InputIterator __last,\n@@ -1101,8 +903,6 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n   __STL_UNWIND(destroy(_M_start, iterator(*__cur_node, __cur_node)));\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n@@ -1184,8 +984,6 @@ void deque<_Tp,_Alloc>::_M_pop_front_aux()\n   _M_start._M_cur = _M_start._M_first;\n }      \n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n template <class _Tp, class _Alloc> template <class _InputIterator>\n void deque<_Tp,_Alloc>::insert(iterator __pos,\n                                _InputIterator __first, _InputIterator __last,\n@@ -1222,8 +1020,6 @@ deque<_Tp,_Alloc>::insert(iterator __pos,\n     _M_insert_aux(__pos, __first, __last, __n);\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n typename deque<_Tp, _Alloc>::iterator\n deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)\n@@ -1338,8 +1134,6 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n   }\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n template <class _Tp, class _Alloc> template <class _ForwardIterator>\n void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n                                       _ForwardIterator __first,\n@@ -1398,122 +1192,6 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n   }\n }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n-                                      const value_type* __first,\n-                                      const value_type* __last,\n-                                      size_type __n)\n-{\n-  const difference_type __elemsbefore = __pos - _M_start;\n-  size_type __length = size();\n-  if (__elemsbefore < __length / 2) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    iterator __old_start = _M_start;\n-    __pos = _M_start + __elemsbefore;\n-    __STL_TRY {\n-      if (__elemsbefore >= difference_type(__n)) {\n-        iterator __start_n = _M_start + difference_type(__n);\n-        uninitialized_copy(_M_start, __start_n, __new_start);\n-        _M_start = __new_start;\n-        copy(__start_n, __pos, __old_start);\n-        copy(__first, __last, __pos - difference_type(__n));\n-      }\n-      else {\n-        const value_type* __mid = \n-          __first + (difference_type(__n) - __elemsbefore);\n-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n-                                  __new_start);\n-        _M_start = __new_start;\n-        copy(__mid, __last, __old_start);\n-      }\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n-  }\n-  else {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    iterator __old_finish = _M_finish;\n-    const difference_type __elemsafter = \n-      difference_type(__length) - __elemsbefore;\n-    __pos = _M_finish - __elemsafter;\n-    __STL_TRY {\n-      if (__elemsafter > difference_type(__n)) {\n-        iterator __finish_n = _M_finish - difference_type(__n);\n-        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy_backward(__pos, __finish_n, __old_finish);\n-        copy(__first, __last, __pos);\n-      }\n-      else {\n-        const value_type* __mid = __first + __elemsafter;\n-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy(__first, __mid, __pos);\n-      }\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n-                                      const_iterator __first,\n-                                      const_iterator __last,\n-                                      size_type __n)\n-{\n-  const difference_type __elemsbefore = __pos - _M_start;\n-  size_type __length = size();\n-  if (__elemsbefore < __length / 2) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    iterator __old_start = _M_start;\n-    __pos = _M_start + __elemsbefore;\n-    __STL_TRY {\n-      if (__elemsbefore >= __n) {\n-        iterator __start_n = _M_start + __n;\n-        uninitialized_copy(_M_start, __start_n, __new_start);\n-        _M_start = __new_start;\n-        copy(__start_n, __pos, __old_start);\n-        copy(__first, __last, __pos - difference_type(__n));\n-      }\n-      else {\n-        const_iterator __mid = __first + (__n - __elemsbefore);\n-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n-                                  __new_start);\n-        _M_start = __new_start;\n-        copy(__mid, __last, __old_start);\n-      }\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n-  }\n-  else {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    iterator __old_finish = _M_finish;\n-    const difference_type __elemsafter = __length - __elemsbefore;\n-    __pos = _M_finish - __elemsafter;\n-    __STL_TRY {\n-      if (__elemsafter > __n) {\n-        iterator __finish_n = _M_finish - difference_type(__n);\n-        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy_backward(__pos, __finish_n, __old_finish);\n-        copy(__first, __last, __pos);\n-      }\n-      else {\n-        const_iterator __mid = __first + __elemsafter;\n-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy(__first, __mid, __pos);\n-      }\n-    }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                 __new_finish._M_node + 1));\n-  }\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_new_elements_at_front(size_type __new_elems)\n {\n@@ -1606,8 +1284,6 @@ inline bool operator<(const deque<_Tp, _Alloc>& __x,\n                                  __y.begin(), __y.end());\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Alloc>\n inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n@@ -1636,14 +1312,7 @@ inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y) {\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-          \n-__STL_END_NAMESPACE \n+} // namespace std \n   \n #endif /* __SGI_STL_INTERNAL_DEQUE_H */\n "}, {"sha": "6c26193dd814677b0a996a38fe9e93b9ffb9c6d0", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,7 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_FUNCTION_H\n #define __SGI_STL_INTERNAL_FUNCTION_H\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _Arg, class _Result>\n struct unary_function {\n@@ -589,8 +590,6 @@ class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {\n   _Ret (_Tp::*_M_f)(_Arg) const;\n };\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _Tp>\n class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {\n public:\n@@ -666,7 +665,6 @@ class const_mem_fun1_ref_t<void, _Tp, _Arg>\n   void (_Tp::*_M_f)(_Arg) const;\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // Mem_fun adaptor helper functions.  There are only two:\n //  mem_fun and mem_fun_ref.  (mem_fun1 and mem_fun1_ref \n@@ -723,7 +721,7 @@ inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n   { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_FUNCTION_H */\n "}, {"sha": "a6003c8f43fdf91d04646d6974940207c513b717", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -30,11 +30,8 @@\n #ifndef _CPP_BITS_STL_HEAP_H\n #define _CPP_BITS_STL_HEAP_H 1\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1209\n-#endif\n+namespace std\n+{\n \n // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n \n@@ -284,11 +281,7 @@ sort_heap(_RandomAccessIterator __first,\n     pop_heap(__first, __last--, __comp);\n }\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1209\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_HEAP_H */\n "}, {"sha": "a062d4dcb016a23ccfc42830f494a01b9d40bdc8", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 3, "deletions": 541, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,8 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_ITERATOR_H\n #define __SGI_STL_INTERNAL_ITERATOR_H\n \n-__STL_BEGIN_NAMESPACE\n-\n+namespace std\n+{\n \n template <class _Container>\n class back_insert_iterator {\n@@ -57,17 +57,6 @@ class back_insert_iterator {\n   back_insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Container>\n-inline output_iterator_tag\n-iterator_category(const back_insert_iterator<_Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _Container>\n inline back_insert_iterator<_Container> back_inserter(_Container& __x) {\n   return back_insert_iterator<_Container>(__x);\n@@ -96,17 +85,6 @@ class front_insert_iterator {\n   front_insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Container>\n-inline output_iterator_tag\n-iterator_category(const front_insert_iterator<_Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _Container>\n inline front_insert_iterator<_Container> front_inserter(_Container& __x) {\n   return front_insert_iterator<_Container>(__x);\n@@ -138,17 +116,6 @@ class insert_iterator {\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Container>\n-inline output_iterator_tag\n-iterator_category(const insert_iterator<_Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _Container, class _Iterator>\n inline \n insert_iterator<_Container> inserter(_Container& __x, _Iterator __i)\n@@ -179,9 +146,7 @@ class reverse_bidirectional_iterator {\n     _BidirectionalIterator __tmp = current;\n     return *--__tmp;\n   }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   _Self& operator++() {\n     --current;\n     return *this;\n@@ -202,39 +167,6 @@ class reverse_bidirectional_iterator {\n   }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _BidirectionalIterator, class _Tp, class _Reference, \n-          class _Distance>\n-inline bidirectional_iterator_tag\n-iterator_category(const reverse_bidirectional_iterator<_BidirectionalIterator,\n-                                                       _Tp, _Reference, \n-                                                       _Distance>&) \n-{\n-  return bidirectional_iterator_tag();\n-}\n-\n-template <class _BidirectionalIterator, class _Tp, class _Reference, \n-          class _Distance>\n-inline _Tp*\n-value_type(const reverse_bidirectional_iterator<_BidirectionalIterator, _Tp,\n-                                               _Reference, _Distance>&)\n-{\n-  return (_Tp*) 0;\n-}\n-\n-template <class _BidirectionalIterator, class _Tp, class _Reference, \n-          class _Distance>\n-inline _Distance*\n-distance_type(const reverse_bidirectional_iterator<_BidirectionalIterator, \n-                                                   _Tp,\n-                                                   _Reference, _Distance>&)\n-{\n-  return (_Distance*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _BiIter, class _Tp, class _Ref, class _Distance>\n inline bool operator==(\n     const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, \n@@ -243,8 +175,6 @@ inline bool operator==(\n   return __x.base() == __y.base();\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _BiIter, class _Tp, class _Ref, class _Distance>\n inline bool operator!=(\n     const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, \n@@ -253,10 +183,6 @@ inline bool operator!=(\n   return !(__x == __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n // This is the new version of reverse_iterator, as defined in the\n //  draft C++ standard.  It relies on the iterator_traits template,\n@@ -289,20 +215,16 @@ class reverse_iterator\n   explicit reverse_iterator(iterator_type __x) : current(__x) {}\n \n   reverse_iterator(const _Self& __x) : current(__x.current) {}\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Iter>\n   reverse_iterator(const reverse_iterator<_Iter>& __x)\n     : current(__x.base()) {}\n-#endif /* __STL_MEMBER_TEMPLATES */\n     \n   iterator_type base() const { return current; }\n   reference operator*() const {\n     _Iterator __tmp = current;\n     return *--__tmp;\n   }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   _Self& operator++() {\n     --current;\n@@ -352,8 +274,6 @@ inline bool operator<(const reverse_iterator<_Iterator>& __x,\n   return __y.base() < __x.base();\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Iterator>\n inline bool operator!=(const reverse_iterator<_Iterator>& __x, \n                        const reverse_iterator<_Iterator>& __y) {\n@@ -378,8 +298,6 @@ inline bool operator>=(const reverse_iterator<_Iterator>& __x,\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _Iterator>\n inline typename reverse_iterator<_Iterator>::difference_type\n operator-(const reverse_iterator<_Iterator>& __x, \n@@ -394,186 +312,6 @@ operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n   return reverse_iterator<_Iterator>(__x.base() - __n);\n }\n \n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// This is the old version of reverse_iterator, as found in the original\n-//  HP STL.  It does not use partial specialization.\n-\n-template <class _RandomAccessIterator, class _Tp, class _Reference = _Tp&,\n-          class _Distance = ptrdiff_t> \n-class reverse_iterator {\n-  typedef reverse_iterator<_RandomAccessIterator, _Tp, _Reference, _Distance>\n-        _Self;\n-protected:\n-  _RandomAccessIterator current;\n-public:\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef _Tp                        value_type;\n-  typedef _Distance                  difference_type;\n-  typedef _Tp*                       pointer;\n-  typedef _Reference                 reference;\n-\n-  reverse_iterator() {}\n-  explicit reverse_iterator(_RandomAccessIterator __x) : current(__x) {}\n-  _RandomAccessIterator base() const { return current; }\n-  _Reference operator*() const { return *(current - 1); }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  _Self& operator++() {\n-    --current;\n-    return *this;\n-  }\n-  _Self operator++(int) {\n-    _Self __tmp = *this;\n-    --current;\n-    return __tmp;\n-  }\n-  _Self& operator--() {\n-    ++current;\n-    return *this;\n-  }\n-  _Self operator--(int) {\n-    _Self __tmp = *this;\n-    ++current;\n-    return __tmp;\n-  }\n-  _Self operator+(_Distance __n) const {\n-    return _Self(current - __n);\n-  }\n-  _Self& operator+=(_Distance __n) {\n-    current -= __n;\n-    return *this;\n-  }\n-  _Self operator-(_Distance __n) const {\n-    return _Self(current + __n);\n-  }\n-  _Self& operator-=(_Distance __n) {\n-    current += __n;\n-    return *this;\n-  }\n-  _Reference operator[](_Distance __n) const { return *(*this + __n); }\n-};\n-\n-template <class _RandomAccessIterator, class _Tp, \n-          class _Reference, class _Distance>\n-inline random_access_iterator_tag\n-iterator_category(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                         _Reference, _Distance>&)\n-{\n-  return random_access_iterator_tag();\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline _Tp* value_type(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                              _Reference, _Distance>&)\n-{\n-  return (_Tp*) 0;\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline _Distance* \n-distance_type(const reverse_iterator<_RandomAccessIterator, \n-                                     _Tp, _Reference, _Distance>&)\n-{\n-  return (_Distance*) 0;\n-}\n-\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator==(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __x, \n-           const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __y)\n-{\n-  return __x.base() == __y.base();\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator<(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __x, \n-          const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __y)\n-{\n-  return __y.base() < __x.base();\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator!=(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __x, \n-           const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator>(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __x, \n-          const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator<=(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __x, \n-           const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline bool \n-operator>=(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __x, \n-           const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                  _Reference, _Distance>& __y) {\n-  return !(__x < __y);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-template <class _RandomAccessIterator, class _Tp,\n-          class _Reference, class _Distance>\n-inline _Distance \n-operator-(const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __x, \n-          const reverse_iterator<_RandomAccessIterator, _Tp,\n-                                 _Reference, _Distance>& __y)\n-{\n-  return __y.base() - __x.base();\n-}\n-\n-template <class _RandAccIter, class _Tp, class _Ref, class _Dist>\n-inline reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist> \n-operator+(_Dist __n,\n-          const reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>& __x)\n-{\n-  return reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>(__x.base() - __n);\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// istream_iterator and ostream_iterator look very different if we're\n-// using new, templatized iostreams than if we're using the old cfront\n-// version.\n-\n-#ifdef __STL_USE_NEW_IOSTREAMS\n \n template <class _Tp, \n           class _CharT = char, class _Traits = char_traits<_CharT>,\n@@ -630,16 +368,13 @@ operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n   return __x._M_equal(__y);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _CharT, class _Traits, class _Dist>\n inline bool \n operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n            const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) {\n   return !__x._M_equal(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n template <class _Tp,\n           class _CharT = char, class _Traits = char_traits<_CharT> >\n@@ -671,279 +406,6 @@ class ostream_iterator {\n   const _CharT* _M_string;\n };\n \n-// The default template argument is declared in iosfwd\n-\n-// We do not read any characters until operator* is called.  The first\n-// time operator* is called, it calls getc.  Subsequent calls to getc \n-// return a cached character, and calls to operator++ use snextc.  Before\n-// operator* or operator++ has been called, _M_is_initialized is false.\n-template<class _CharT, class _Traits>\n-class istreambuf_iterator\n-  : public iterator<input_iterator_tag, _CharT,\n-                    typename _Traits::off_type, _CharT*, _CharT&>\n-{\n-public:\n-  typedef _CharT                           char_type;\n-  typedef _Traits                          traits_type;\n-  typedef typename _Traits::int_type       int_type;\n-  typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n-  typedef basic_istream<_CharT, _Traits>   istream_type;\n-\n-public:\n-  istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }\n-  istreambuf_iterator(istream_type& __is) { this->_M_init(__is.rdbuf()); }\n-\n-  char_type operator*() const \n-    { return _M_is_initialized ? _M_c : _M_dereference_aux(); }\n-\n-  istreambuf_iterator& operator++() { this->_M_nextc(); return *this; }\n-  istreambuf_iterator  operator++(int) {\n-    if (!_M_is_initialized)\n-      _M_postincr_aux();\n-    istreambuf_iterator __tmp = *this;\n-    this->_M_nextc();\n-    return __tmp;\n-  }\n-\n-  bool equal(const istreambuf_iterator& __i) const {\n-    return this->_M_is_initialized && __i._M_is_initialized\n-      ? this->_M_eof == __i._M_eof\n-      : this->_M_equal_aux(__i);\n-  }\n-\n-private:\n-  void _M_init(streambuf_type* __p) {\n-    _M_buf = __p;\n-    _M_eof = !__p;\n-    _M_is_initialized = _M_eof;\n-  }\n-\n-  char_type _M_dereference_aux() const;\n-  bool _M_equal_aux(const istreambuf_iterator&) const;\n-  void _M_postincr_aux();\n-\n-  void _M_nextc() {\n-    int_type __c = _M_buf->snextc();\n-    _M_c = traits_type::to_char_type(__c);    \n-    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());\n-    _M_is_initialized = true;\n-  }\n-\n-  void _M_getc() const {\n-    int_type __c = _M_buf->sgetc();\n-    _M_c = traits_type::to_char_type(__c);\n-    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());\n-    _M_is_initialized = true;\n-  }\n-\n-private:\n-  streambuf_type* _M_buf;\n-  mutable _CharT _M_c;\n-  mutable bool _M_eof : 1;\n-  mutable bool _M_is_initialized : 1;\n-};\n-\n-template<class _CharT, class _Traits>\n-_CharT istreambuf_iterator<_CharT, _Traits>::_M_dereference_aux() const\n-{\n-  this->_M_getc();\n-  return _M_c;\n-}\n-\n-template<class _CharT, class _Traits>\n-bool istreambuf_iterator<_CharT, _Traits>\n-  ::_M_equal_aux(const istreambuf_iterator& __i) const\n-{\n-  if (!this->_M_is_initialized)\n-    this->_M_getc();\n-  if (!__i._M_is_initialized)\n-    __i._M_getc();\n-\n-  return this->_M_eof == __i._M_eof;\n-}\n-\n-template<class _CharT, class _Traits>\n-void istreambuf_iterator<_CharT, _Traits>::_M_postincr_aux()\n-{\n-  this->_M_getc();\n-}\n-\n-template<class _CharT, class _Traits>\n-inline bool operator==(const istreambuf_iterator<_CharT, _Traits>& __x,\n-                       const istreambuf_iterator<_CharT, _Traits>& __y) {\n-  return __x.equal(__y);\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template<class _CharT, class _Traits>\n-inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,\n-                       const istreambuf_iterator<_CharT, _Traits>& __y) {\n-  return !__x.equal(__y);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// The default template argument is declared in iosfwd\n-template<class _CharT, class _Traits>\n-class ostreambuf_iterator\n-  : public iterator<output_iterator_tag, void, void, void, void>\n-{\n-public:\n-  typedef _CharT                           char_type;\n-  typedef _Traits                          traits_type;\n-  typedef typename _Traits::int_type       int_type;\n-  typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n-  typedef basic_ostream<_CharT, _Traits>   ostream_type;\n-\n-public:\n-  ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf) {}\n-  ostreambuf_iterator(ostream_type& __o)\n-    : _M_buf(__o.rdbuf()), _M_ok(__o.rdbuf() != 0) {}\n-\n-  ostreambuf_iterator& operator=(char_type __c) {\n-    _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),\n-                                               traits_type::eof());\n-    return *this;\n-  }    \n-  \n-  ostreambuf_iterator& operator*()     { return *this; }\n-  ostreambuf_iterator& operator++()    { return *this; }\n-  ostreambuf_iterator& operator++(int) { return *this; }\n-\n-  bool failed() const { return !_M_ok; }\n-\n-private:\n-  streambuf_type* _M_buf;\n-  bool _M_ok;\n-};\n-\n-#else /* __STL_USE_NEW_IOSTREAMS */\n-\n-template <class _Tp, class _Dist = ptrdiff_t> class istream_iterator;\n-\n-template <class _Tp, class _Dist>\n-inline bool operator==(const istream_iterator<_Tp, _Dist>&,\n-                       const istream_iterator<_Tp, _Dist>&);\n-\n-template <class _Tp, class _Dist>\n-class istream_iterator {\n-#ifdef __STL_TEMPLATE_FRIENDS\n-  template <class _T1, class _D1>\n-  friend bool operator==(const istream_iterator<_T1, _D1>&,\n-                         const istream_iterator<_T1, _D1>&);\n-#else /* __STL_TEMPLATE_FRIENDS */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const istream_iterator&,\n-                                   const istream_iterator&);\n-#endif /* __STL_TEMPLATE_FRIENDS */\n-\n-protected:\n-  istream* _M_stream;\n-  _Tp _M_value;\n-  bool _M_end_marker;\n-  void _M_read() {\n-    _M_end_marker = (*_M_stream) ? true : false;\n-    if (_M_end_marker) *_M_stream >> _M_value;\n-    _M_end_marker = (*_M_stream) ? true : false;\n-  }\n-public:\n-  typedef input_iterator_tag  iterator_category;\n-  typedef _Tp                 value_type;\n-  typedef _Dist               difference_type;\n-  typedef const _Tp*          pointer;\n-  typedef const _Tp&          reference;\n-\n-  istream_iterator() : _M_stream(&cin), _M_end_marker(false) {}\n-  istream_iterator(istream& __s) : _M_stream(&__s) { _M_read(); }\n-  reference operator*() const { return _M_value; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  istream_iterator<_Tp, _Dist>& operator++() { \n-    _M_read(); \n-    return *this;\n-  }\n-  istream_iterator<_Tp, _Dist> operator++(int)  {\n-    istream_iterator<_Tp, _Dist> __tmp = *this;\n-    _M_read();\n-    return __tmp;\n-  }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Tp, class _Dist>\n-inline input_iterator_tag \n-iterator_category(const istream_iterator<_Tp, _Dist>&)\n-{\n-  return input_iterator_tag();\n-}\n-\n-template <class _Tp, class _Dist>\n-inline _Tp* \n-value_type(const istream_iterator<_Tp, _Dist>&) { return (_Tp*) 0; }\n-\n-template <class _Tp, class _Dist>\n-inline _Dist* \n-distance_type(const istream_iterator<_Tp, _Dist>&) { return (_Dist*)0; }\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class _Tp, class _Distance>\n-inline bool operator==(const istream_iterator<_Tp, _Distance>& __x,\n-                       const istream_iterator<_Tp, _Distance>& __y) {\n-  return (__x._M_stream == __y._M_stream &&\n-          __x._M_end_marker == __y._M_end_marker) ||\n-         __x._M_end_marker == false && __y._M_end_marker == false;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Tp, class _Distance>\n-inline bool operator!=(const istream_iterator<_Tp, _Distance>& __x,\n-                       const istream_iterator<_Tp, _Distance>& __y) {\n-  return !(__x == __y);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-template <class _Tp>\n-class ostream_iterator {\n-protected:\n-  ostream* _M_stream;\n-  const char* _M_string;\n-public:\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  ostream_iterator(ostream& __s) : _M_stream(&__s), _M_string(0) {}\n-  ostream_iterator(ostream& __s, const char* __c) \n-    : _M_stream(&__s), _M_string(__c)  {}\n-  ostream_iterator<_Tp>& operator=(const _Tp& __value) { \n-    *_M_stream << __value;\n-    if (_M_string) *_M_stream << _M_string;\n-    return *this;\n-  }\n-  ostream_iterator<_Tp>& operator*() { return *this; }\n-  ostream_iterator<_Tp>& operator++() { return *this; } \n-  ostream_iterator<_Tp>& operator++(int) { return *this; } \n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Tp>\n-inline output_iterator_tag \n-iterator_category(const ostream_iterator<_Tp>&) {\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#endif /* __STL_USE_NEW_IOSTREAMS */\n \n // This iterator adapter is 'normal' in the sense that it does not\n // change the semantics of any of the operators of its itererator\n@@ -1077,7 +539,7 @@ operator+(__normal_iterator<_Iterator, _Container>::difference_type __n,\n           const __normal_iterator<_Iterator, _Container>& __i)\n { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_ITERATOR_H */\n "}, {"sha": "5c5ac2c0f8208ea76a598e8cca56fc9a8ac16e16", "filename": "libstdc++-v3/include/bits/stl_iterator_base.h", "status": "modified", "additions": 3, "deletions": 105, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -37,7 +37,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n struct input_iterator_tag {};\n struct output_iterator_tag {};\n@@ -91,7 +92,6 @@ template <class _Tp, class _Distance> struct random_access_iterator {\n   typedef _Tp&                       reference;\n };\n \n-#ifdef __STL_USE_NAMESPACES\n template <class _Category, class _Tp, class _Distance = ptrdiff_t,\n           class _Pointer = _Tp*, class _Reference = _Tp&>\n struct iterator {\n@@ -101,9 +101,6 @@ struct iterator {\n   typedef _Pointer   pointer;\n   typedef _Reference reference;\n };\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n template <class _Iterator>\n struct iterator_traits {\n@@ -178,92 +175,6 @@ value_type(const _Iter& __i) { return __value_type(__i); }\n #define __DISTANCE_TYPE(__i)     __distance_type(__i)\n #define __VALUE_TYPE(__i)        __value_type(__i)\n \n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class _Tp, class _Distance> \n-inline input_iterator_tag \n-iterator_category(const input_iterator<_Tp, _Distance>&)\n-  { return input_iterator_tag(); }\n-\n-inline output_iterator_tag iterator_category(const output_iterator&)\n-  { return output_iterator_tag(); }\n-\n-template <class _Tp, class _Distance> \n-inline forward_iterator_tag\n-iterator_category(const forward_iterator<_Tp, _Distance>&)\n-  { return forward_iterator_tag(); }\n-\n-template <class _Tp, class _Distance> \n-inline bidirectional_iterator_tag\n-iterator_category(const bidirectional_iterator<_Tp, _Distance>&)\n-  { return bidirectional_iterator_tag(); }\n-\n-template <class _Tp, class _Distance> \n-inline random_access_iterator_tag\n-iterator_category(const random_access_iterator<_Tp, _Distance>&)\n-  { return random_access_iterator_tag(); }\n-\n-template <class _Tp>\n-inline random_access_iterator_tag iterator_category(const _Tp*)\n-  { return random_access_iterator_tag(); }\n-\n-template <class _Tp, class _Distance> \n-inline _Tp* value_type(const input_iterator<_Tp, _Distance>&)\n-  { return (_Tp*)(0); }\n-\n-template <class _Tp, class _Distance> \n-inline _Tp* value_type(const forward_iterator<_Tp, _Distance>&)\n-  { return (_Tp*)(0); }\n-\n-template <class _Tp, class _Distance> \n-inline _Tp* value_type(const bidirectional_iterator<_Tp, _Distance>&)\n-  { return (_Tp*)(0); }\n-\n-template <class _Tp, class _Distance> \n-inline _Tp* value_type(const random_access_iterator<_Tp, _Distance>&)\n-  { return (_Tp*)(0); }\n-\n-template <class _Tp>\n-inline _Tp* value_type(const _Tp*) { return (_Tp*)(0); }\n-\n-template <class _Tp, class _Distance> \n-inline _Distance* distance_type(const input_iterator<_Tp, _Distance>&)\n-{\n-  return (_Distance*)(0);\n-}\n-\n-template <class _Tp, class _Distance> \n-inline _Distance* distance_type(const forward_iterator<_Tp, _Distance>&)\n-{\n-  return (_Distance*)(0);\n-}\n-\n-template <class _Tp, class _Distance> \n-inline _Distance* \n-distance_type(const bidirectional_iterator<_Tp, _Distance>&)\n-{\n-  return (_Distance*)(0);\n-}\n-\n-template <class _Tp, class _Distance> \n-inline _Distance* \n-distance_type(const random_access_iterator<_Tp, _Distance>&)\n-{\n-  return (_Distance*)(0);\n-}\n-\n-template <class _Tp>\n-inline ptrdiff_t* distance_type(const _Tp*) { return (ptrdiff_t*)(0); }\n-\n-// Without partial specialization we can't use iterator_traits, so\n-// we must keep the old iterator query functions around.  \n-\n-#define __ITERATOR_CATEGORY(__i) iterator_category(__i)\n-#define __DISTANCE_TYPE(__i)     distance_type(__i)\n-#define __VALUE_TYPE(__i)        value_type(__i)\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _InputIterator, class _Distance>\n inline void __distance(_InputIterator __first, _InputIterator __last,\n                        _Distance& __n, input_iterator_tag)\n@@ -288,8 +199,6 @@ inline void distance(_InputIterator __first,\n   __distance(__first, __last, __n, iterator_category(__first));\n }\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _InputIterator>\n inline typename iterator_traits<_InputIterator>::difference_type\n __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n@@ -318,17 +227,11 @@ distance(_InputIterator __first, _InputIterator __last) {\n   return __distance(__first, __last, _Category());\n }\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _InputIter, class _Distance>\n inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {\n   while (__n--) ++__i;\n }\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1183\n-#endif\n-\n template <class _BidirectionalIterator, class _Distance>\n inline void __advance(_BidirectionalIterator& __i, _Distance __n, \n                       bidirectional_iterator_tag) {\n@@ -339,10 +242,6 @@ inline void __advance(_BidirectionalIterator& __i, _Distance __n,\n     while (__n++) --__i;\n }\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1183\n-#endif\n-\n template <class _RandomAccessIterator, class _Distance>\n inline void __advance(_RandomAccessIterator& __i, _Distance __n, \n                       random_access_iterator_tag) {\n@@ -356,12 +255,11 @@ inline void advance(_InputIterator& __i, _Distance __n) {\n   __advance(__i, __n, iterator_category(__i));\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_ITERATOR_BASE_H */\n \n \n-\n // Local Variables:\n // mode:C++\n // End:"}, {"sha": "b018317b87b22ba12e51a9fdb8f81eeb635e65bf", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 6, "deletions": 146, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n struct _List_node_base {\n   _List_node_base* _M_next;\n@@ -87,10 +83,7 @@ struct _List_iterator : public _List_iterator_base {\n   _List_iterator(const iterator& __x) : _List_iterator_base(__x._M_node) {}\n \n   reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n-\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   _Self& operator++() { \n     this->_M_incr();\n@@ -112,29 +105,6 @@ struct _List_iterator : public _List_iterator_base {\n   }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-inline bidirectional_iterator_tag\n-iterator_category(const _List_iterator_base&)\n-{\n-  return bidirectional_iterator_tag();\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-inline _Tp*\n-value_type(const _List_iterator<_Tp, _Ref, _Ptr>&)\n-{\n-  return 0;\n-}\n-\n-inline ptrdiff_t*\n-distance_type(const _List_iterator_base&)\n-{\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n \n // Base class that encapsulates details of allocators.  Three cases:\n // an ordinary standard-conforming allocator, a standard-conforming\n@@ -143,7 +113,6 @@ distance_type(const _List_iterator_base&)\n // compatibility and because we want to avoid wasting storage on an \n // allocator instance if it isn't necessary.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n \n // Base for general standard-conforming allocators.\n template <class _Tp, class _Allocator, bool _IsStatic>\n@@ -212,37 +181,6 @@ class _List_base\n   void clear();\n };\n \n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc>\n-class _List_base \n-{\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _List_base(const allocator_type&) {\n-    _M_node = _M_get_node();\n-    _M_node->_M_next = _M_node;\n-    _M_node->_M_prev = _M_node;\n-  }\n-  ~_List_base() {\n-    clear();\n-    _M_put_node(_M_node);\n-  }\n-\n-  void clear();\n-\n-protected:\n-  typedef simple_alloc<_List_node<_Tp>, _Alloc> _Alloc_type;\n-  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); } \n-\n-protected:\n-  _List_node<_Tp>* _M_node;\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n \n template <class _Tp, class _Alloc>\n void \n@@ -286,24 +224,13 @@ class list : protected _List_base<_Tp, _Alloc> {\n   typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n   typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n   typedef reverse_iterator<iterator>       reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_bidirectional_iterator<const_iterator,value_type,\n-                                         const_reference,difference_type>\n-          const_reverse_iterator;\n-  typedef reverse_bidirectional_iterator<iterator,value_type,reference,\n-                                         difference_type>\n-          reverse_iterator; \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:\n-#ifdef __STL_HAS_NAMESPACES\n   using _Base::_M_node;\n   using _Base::_M_put_node;\n   using _Base::_M_get_node;\n-#endif /* __STL_HAS_NAMESPACES */\n \n protected:\n   _Node* _M_create_node(const _Tp& __x)\n@@ -358,7 +285,7 @@ class list : protected _List_base<_Tp, _Alloc> {\n   reference back() { return *(--end()); }\n   const_reference back() const { return *(--end()); }\n \n-  void swap(list<_Tp, _Alloc>& __x) { __STD::swap(_M_node, __x._M_node); }\n+  void swap(list<_Tp, _Alloc>& __x) { std::swap(_M_node, __x._M_node); }\n \n   iterator insert(iterator __position, const _Tp& __x) {\n     _Node* __tmp = _M_create_node(__x);\n@@ -369,9 +296,8 @@ class list : protected _List_base<_Tp, _Alloc> {\n     return __tmp;\n   }\n   iterator insert(iterator __position) { return insert(__position, _Tp()); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n \n+  // Check whether it's an integral type.  If so, it's not an iterator.\n   template<class _Integer>\n   void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n                           __true_type) {\n@@ -389,11 +315,6 @@ class list : protected _List_base<_Tp, _Alloc> {\n     _M_insert_dispatch(__pos, __first, __last, _Integral());\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator __position, const _Tp* __first, const _Tp* __last);\n-  void insert(iterator __position,\n-              const_iterator __first, const_iterator __last);\n-#endif /* __STL_MEMBER_TEMPLATES */\n   void insert(iterator __pos, size_type __n, const _Tp& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n   void _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x); \n@@ -432,8 +353,6 @@ class list : protected _List_base<_Tp, _Alloc> {\n     : _Base(allocator_type())\n     { insert(begin(), __n, _Tp()); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   // We don't need any dispatching tricks here, because insert does all of\n   // that anyway.  \n   template <class _InputIterator>\n@@ -442,18 +361,6 @@ class list : protected _List_base<_Tp, _Alloc> {\n     : _Base(__a)\n     { insert(begin(), __first, __last); }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  list(const _Tp* __first, const _Tp* __last,\n-       const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    { this->insert(begin(), __first, __last); }\n-  list(const_iterator __first, const_iterator __last,\n-       const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    { this->insert(begin(), __first, __last); }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n   list(const list<_Tp, _Alloc>& __x) : _Base(__x.get_allocator())\n     { insert(begin(), __x.begin(), __x.end()); }\n \n@@ -471,8 +378,6 @@ class list : protected _List_base<_Tp, _Alloc> {\n \n   void _M_fill_assign(size_type __n, const _Tp& __val);\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   template <class _InputIterator>\n   void assign(_InputIterator __first, _InputIterator __last) {\n     typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -487,8 +392,6 @@ class list : protected _List_base<_Tp, _Alloc> {\n   void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n                           __false_type);\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n protected:\n   void transfer(iterator __position, iterator __first, iterator __last) {\n     if (__position != __last) {\n@@ -526,12 +429,10 @@ class list : protected _List_base<_Tp, _Alloc> {\n   void reverse();\n   void sort();\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Predicate> void remove_if(_Predicate);\n   template <class _BinaryPredicate> void unique(_BinaryPredicate);\n   template <class _StrictWeakOrdering> void merge(list&, _StrictWeakOrdering);\n   template <class _StrictWeakOrdering> void sort(_StrictWeakOrdering);\n-#endif /* __STL_MEMBER_TEMPLATES */\n };\n \n template <class _Tp, class _Alloc>\n@@ -559,8 +460,6 @@ inline bool operator<(const list<_Tp,_Alloc>& __x,\n                                  __y.begin(), __y.end());\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Alloc>\n inline bool operator!=(const list<_Tp,_Alloc>& __x,\n                        const list<_Tp,_Alloc>& __y) {\n@@ -592,10 +491,6 @@ swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _InputIter>\n void \n list<_Tp, _Alloc>::_M_insert_dispatch(iterator __position,\n@@ -606,28 +501,6 @@ list<_Tp, _Alloc>::_M_insert_dispatch(iterator __position,\n     insert(__position, *__first);\n }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class _Tp, class _Alloc>\n-void \n-list<_Tp, _Alloc>::insert(iterator __position, \n-                          const _Tp* __first, const _Tp* __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert(__position, *__first);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void \n-list<_Tp, _Alloc>::insert(iterator __position,\n-                         const_iterator __first, const_iterator __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert(__position, *__first);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n void \n list<_Tp, _Alloc>::_M_fill_insert(iterator __position,\n@@ -688,8 +561,6 @@ void list<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n     erase(__i, end());\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _InputIter>\n void\n list<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first2, _InputIter __last2,\n@@ -705,8 +576,6 @@ list<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first2, _InputIter __last2,\n     insert(__last1, __first2, __last2);\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n void list<_Tp, _Alloc>::remove(const _Tp& __value)\n {\n@@ -758,7 +627,7 @@ inline void __List_base_reverse(_List_node_base* __p)\n {\n   _List_node_base* __tmp = __p;\n   do {\n-    __STD::swap(__tmp->_M_next, __tmp->_M_prev);\n+    std::swap(__tmp->_M_next, __tmp->_M_prev);\n     __tmp = __tmp->_M_prev;     // Old next node is now prev.\n   } while (__tmp != __p);\n }\n@@ -794,8 +663,6 @@ void list<_Tp, _Alloc>::sort()\n   }\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _Predicate>\n void list<_Tp, _Alloc>::remove_if(_Predicate __pred)\n {\n@@ -869,14 +736,7 @@ void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)\n   }\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n+} // namespace std \n \n #endif /* __SGI_STL_INTERNAL_LIST_H */\n "}, {"sha": "a725004618fe268d1ea00830dc8f9364815eea5d", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 4, "deletions": 53, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n template <class _Key, class _Tp, class _Compare = less<_Key>,\n           class _Alloc = allocator<pair<const _Key, _Tp> > >\n@@ -94,7 +90,6 @@ class map {\n                const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   map(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n@@ -104,27 +99,8 @@ class map {\n   map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n       const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-#else\n-  map(const value_type* __first, const value_type* __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_unique(__first, __last); }\n-\n-  map(const value_type* __first,\n-      const value_type* __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-\n-  map(const_iterator __first, const_iterator __last)\n-    : _M_t(_Compare(), allocator_type()) \n-    { _M_t.insert_unique(__first, __last); }\n-\n-  map(const_iterator __first, const_iterator __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   map(const map<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+\n   map<_Key,_Tp,_Compare,_Alloc>&\n   operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)\n   {\n@@ -164,19 +140,10 @@ class map {\n     { return _M_t.insert_unique(__x); }\n   iterator insert(iterator position, const value_type& __x)\n     { return _M_t.insert_unique(position, __x); }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_unique(__first, __last);\n   }\n-#else\n-  void insert(const value_type* __first, const value_type* __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n-  void insert(const_iterator __first, const_iterator __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   void erase(iterator __position) { _M_t.erase(__position); }\n   size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n@@ -207,19 +174,12 @@ class map {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_TEMPLATE_FRIENDS \n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator== (const map<_K1, _T1, _C1, _A1>&,\n                           const map<_K1, _T1, _C1, _A1>&);\n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator< (const map<_K1, _T1, _C1, _A1>&,\n                          const map<_K1, _T1, _C1, _A1>&);\n-#else /* __STL_TEMPLATE_FRIENDS */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const map&, const map&);\n-  friend bool __STD_QUALIFIER\n-  operator< __STL_NULL_TMPL_ARGS (const map&, const map&);\n-#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n@@ -234,8 +194,6 @@ inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n   return __x._M_t < __y._M_t;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Tp, class _Compare, class _Alloc>\n inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n                        const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n@@ -266,14 +224,7 @@ inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_MAP_H */\n "}, {"sha": "35d22634d2714e31e1d101ce0a1e2d5a9ca60340", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 4, "deletions": 51, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n // Forward declaration of operators < and ==, needed for friend declaration.\n \n@@ -107,7 +103,6 @@ class multimap {\n                     const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n   template <class _InputIterator>\n   multimap(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n@@ -118,25 +113,8 @@ class multimap {\n            const _Compare& __comp,\n            const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-#else\n-  multimap(const value_type* __first, const value_type* __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n-  multimap(const value_type* __first, const value_type* __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-\n-  multimap(const_iterator __first, const_iterator __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n-  multimap(const_iterator __first, const_iterator __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   multimap(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) { }\n+\n   multimap<_Key,_Tp,_Compare,_Alloc>&\n   operator=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) {\n     _M_t = __x._M_t;\n@@ -168,19 +146,10 @@ class multimap {\n   iterator insert(iterator __position, const value_type& __x) {\n     return _M_t.insert_equal(__position, __x);\n   }\n-#ifdef __STL_MEMBER_TEMPLATES  \n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_equal(__first, __last);\n   }\n-#else\n-  void insert(const value_type* __first, const value_type* __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n-  void insert(const_iterator __first, const_iterator __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n   void erase(iterator __position) { _M_t.erase(__position); }\n   size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n   void erase(iterator __first, iterator __last)\n@@ -207,19 +176,12 @@ class multimap {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_TEMPLATE_FRIENDS \n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator== (const multimap<_K1, _T1, _C1, _A1>&,\n                           const multimap<_K1, _T1, _C1, _A1>&);\n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator< (const multimap<_K1, _T1, _C1, _A1>&,\n                          const multimap<_K1, _T1, _C1, _A1>&);\n-#else /* __STL_TEMPLATE_FRIENDS */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const multimap&, const multimap&);\n-  friend bool __STD_QUALIFIER\n-  operator< __STL_NULL_TMPL_ARGS (const multimap&, const multimap&);\n-#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n@@ -234,8 +196,6 @@ inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n   return __x._M_t < __y._M_t;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Tp, class _Compare, class _Alloc>\n inline bool operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n@@ -266,14 +226,7 @@ inline void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_MULTIMAP_H */\n "}, {"sha": "8b2c63ff03b2d78586fda530b0a6f85264a8e766", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n // Forward declaration of operators < and ==, needed for friend declaration.\n \n@@ -93,8 +89,6 @@ class multiset {\n                     const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   template <class _InputIterator>\n   multiset(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n@@ -106,29 +100,8 @@ class multiset {\n            const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n \n-#else\n-\n-  multiset(const value_type* __first, const value_type* __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n-\n-  multiset(const value_type* __first, const value_type* __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-\n-  multiset(const_iterator __first, const_iterator __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n-\n-  multiset(const_iterator __first, const_iterator __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-   \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+\n   multiset<_Key,_Compare,_Alloc>&\n   operator=(const multiset<_Key,_Compare,_Alloc>& __x) {\n     _M_t = __x._M_t; \n@@ -159,19 +132,10 @@ class multiset {\n     return _M_t.insert_equal((_Rep_iterator&)__position, __x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_equal(__first, __last);\n   }\n-#else\n-  void insert(const value_type* __first, const value_type* __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n-  void insert(const_iterator __first, const_iterator __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n   void erase(iterator __position) { \n     typedef typename _Rep_type::iterator _Rep_iterator;\n     _M_t.erase((_Rep_iterator&)__position); \n@@ -199,19 +163,12 @@ class multiset {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_TEMPLATE_FRIENDS\n   template <class _K1, class _C1, class _A1>\n   friend bool operator== (const multiset<_K1,_C1,_A1>&,\n                           const multiset<_K1,_C1,_A1>&);\n   template <class _K1, class _C1, class _A1>\n   friend bool operator< (const multiset<_K1,_C1,_A1>&,\n                          const multiset<_K1,_C1,_A1>&);\n-#else /* __STL_TEMPLATE_FRIENDS */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const multiset&, const multiset&);\n-  friend bool __STD_QUALIFIER\n-  operator< __STL_NULL_TMPL_ARGS (const multiset&, const multiset&);\n-#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Compare, class _Alloc>\n@@ -226,8 +183,6 @@ inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n   return __x._M_t < __y._M_t;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Compare, class _Alloc>\n inline bool operator!=(const multiset<_Key,_Compare,_Alloc>& __x, \n                        const multiset<_Key,_Compare,_Alloc>& __y) {\n@@ -258,14 +213,7 @@ inline void swap(multiset<_Key,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_MULTISET_H */\n "}, {"sha": "0a084e54747018e52a3097b32fb750f1a8e06e14", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -32,7 +32,8 @@\n #ifndef _CPP_BITS_STL_NUMERIC_H\n #define _CPP_BITS_STL_NUMERIC_H 1\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _InputIterator, class _Tp>\n _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n@@ -246,7 +247,7 @@ iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n     *__first++ = __value++;\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_NUMERIC_H */\n "}, {"sha": "8252d97e2bef6fc4eaf20ec511bc4b806b191e84", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,7 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_PAIR_H\n #define __SGI_STL_INTERNAL_PAIR_H\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _T1, class _T2>\n struct pair {\n@@ -43,10 +44,8 @@ struct pair {\n   pair() : first(_T1()), second(_T2()) {}\n   pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _U1, class _U2>\n   pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n-#endif\n };\n \n template <class _T1, class _T2>\n@@ -62,8 +61,6 @@ inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n          (!(__y.first < __x.first) && __x.second < __y.second); \n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _T1, class _T2>\n inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n   return !(__x == __y);\n@@ -84,8 +81,6 @@ inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _T1, class _T2>\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n //181.  make_pair() unintended behavior\n@@ -97,7 +92,7 @@ inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)\n   return pair<_T1, _T2>(__x, __y);\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_PAIR_H */\n "}, {"sha": "65879354f69fba401d3cc0d93fea1d7f4dfa8f36", "filename": "libstdc++-v3/include/bits/stl_pthread_alloc.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -16,13 +16,8 @@\n \n #include <bits/pthread_allocimpl.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::_Pthread_alloc_template;\n-using __STD::pthread_alloc;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n+using std::_Pthread_alloc_template;\n+using std::pthread_alloc;\n \n #endif /* _CPP_BITS_STL_PTHREAD_ALLOC_H */\n "}, {"sha": "d6ca8129465c3a487186049396f6ac1a9299e4b3", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,7 +33,8 @@\n \n #include <bits/sequence_concepts.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // Forward declarations of operators < and ==, needed for friend declaration.\n \n@@ -60,20 +61,12 @@ class queue {\n   __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);\n \n \n-#ifdef __STL_MEMBER_TEMPLATES \n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const queue<_Tp1, _Seq1>&,\n                           const queue<_Tp1, _Seq1>&);\n   template <class _Tp1, class _Seq1>\n   friend bool operator< (const queue<_Tp1, _Seq1>&,\n                          const queue<_Tp1, _Seq1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const queue&, const queue&);\n-  friend bool __STD_QUALIFIER\n-  operator<  __STL_NULL_TMPL_ARGS (const queue&, const queue&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:\n   typedef typename _Sequence::value_type      value_type;\n   typedef typename _Sequence::size_type       size_type;\n@@ -111,8 +104,6 @@ operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n   return __x.c < __y.c;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Sequence>\n bool\n operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n@@ -141,12 +132,9 @@ operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _Tp, \n-          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector<_Tp>),\n-          class _Compare  \n-\t  __STL_DEPENDENT_DEFAULT_TMPL(less<typename _Sequence::value_type>) >\n+          class _Sequence = vector<_Tp>,\n+          class _Compare  = less<typename _Sequence::value_type> >\n class priority_queue {\n public:\n \n@@ -174,7 +162,6 @@ class priority_queue {\n     : c(__s), comp(__x) \n     { make_heap(c.begin(), c.end(), comp); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   priority_queue(_InputIterator __first, _InputIterator __last) \n     : c(__first, __last) { make_heap(c.begin(), c.end(), comp); }\n@@ -194,24 +181,6 @@ class priority_queue {\n     make_heap(c.begin(), c.end(), comp);\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-  priority_queue(const value_type* __first, const value_type* __last) \n-    : c(__first, __last) { make_heap(c.begin(), c.end(), comp); }\n-\n-  priority_queue(const value_type* __first, const value_type* __last, \n-                 const _Compare& __x) \n-    : c(__first, __last), comp(__x)\n-    { make_heap(c.begin(), c.end(), comp); }\n-\n-  priority_queue(const value_type* __first, const value_type* __last, \n-                 const _Compare& __x, const _Sequence& __c)\n-    : c(__c), comp(__x) \n-  { \n-    c.insert(c.end(), __first, __last);\n-    make_heap(c.begin(), c.end(), comp);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   bool empty() const { return c.empty(); }\n   size_type size() const { return c.size(); }\n   const_reference top() const { return c.front(); }\n@@ -233,7 +202,7 @@ class priority_queue {\n \n // no equality is provided\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_QUEUE_H */\n "}, {"sha": "22fec74bcb8be8d0b9cf43fcc81c5e935437fd43", "filename": "libstdc++-v3/include/bits/stl_raw_storage_iter.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,7 +31,8 @@\n #ifndef _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H\n #define _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H 1\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _ForwardIterator, class _Tp>\n class raw_storage_iterator {\n@@ -61,18 +62,8 @@ class raw_storage_iterator {\n   }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _ForwardIterator, class _Tp>\n-inline output_iterator_tag\n-iterator_category(const raw_storage_iterator<_ForwardIterator, _Tp>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H */\n "}, {"sha": "531137a677cf852e1441efd6483db4ba84a0d346", "filename": "libstdc++-v3/include/bits/stl_relops.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -41,7 +41,10 @@\n #ifndef _CPP_BITS_STL_RELOPS_H\n #define _CPP_BITS_STL_RELOPS_H 1\n \n-__STL_BEGIN_RELOPS_NAMESPACE\n+namespace std\n+{\n+  namespace rel_ops\n+  {\n \n template <class _Tp>\n inline bool operator!=(const _Tp& __x, const _Tp& __y) {\n@@ -63,7 +66,8 @@ inline bool operator>=(const _Tp& __x, const _Tp& __y) {\n   return !(__x < __y);\n }\n \n-__STL_END_RELOPS_NAMESPACE\n+  } // namespace rel_ops\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_RELOPS_H */\n "}, {"sha": "03bb190692107f27ac92f29522a4aabc102d619a", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n // Forward declarations of operators < and ==, needed for friend declaration.\n \n@@ -93,7 +89,6 @@ class set {\n                const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   set(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n@@ -103,24 +98,6 @@ class set {\n   set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n       const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-#else\n-  set(const value_type* __first, const value_type* __last) \n-    : _M_t(_Compare(), allocator_type()) \n-    { _M_t.insert_unique(__first, __last); }\n-\n-  set(const value_type* __first, \n-      const value_type* __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-\n-  set(const_iterator __first, const_iterator __last)\n-    : _M_t(_Compare(), allocator_type()) \n-    { _M_t.insert_unique(__first, __last); }\n-\n-  set(const_iterator __first, const_iterator __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n   set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)\n@@ -153,19 +130,10 @@ class set {\n     typedef typename _Rep_type::iterator _Rep_iterator;\n     return _M_t.insert_unique((_Rep_iterator&)__position, __x);\n   }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_unique(__first, __last);\n   }\n-#else\n-  void insert(const_iterator __first, const_iterator __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n-  void insert(const value_type* __first, const value_type* __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n   void erase(iterator __position) { \n     typedef typename _Rep_type::iterator _Rep_iterator;\n     _M_t.erase((_Rep_iterator&)__position); \n@@ -195,17 +163,10 @@ class set {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_TEMPLATE_FRIENDS\n   template <class _K1, class _C1, class _A1>\n   friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n   template <class _K1, class _C1, class _A1>\n   friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-#else /* __STL_TEMPLATE_FRIENDS */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const set&, const set&);\n-  friend bool __STD_QUALIFIER\n-  operator<  __STL_NULL_TMPL_ARGS (const set&, const set&);\n-#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Compare, class _Alloc>\n@@ -220,8 +181,6 @@ inline bool operator<(const set<_Key,_Compare,_Alloc>& __x,\n   return __x._M_t < __y._M_t;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Compare, class _Alloc>\n inline bool operator!=(const set<_Key,_Compare,_Alloc>& __x, \n                        const set<_Key,_Compare,_Alloc>& __y) {\n@@ -252,14 +211,7 @@ inline void swap(set<_Key,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_SET_H */\n "}, {"sha": "72e67bde4da22a4c07405d753c76f66d30f3789b", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,7 +33,8 @@\n \n #include <bits/sequence_concepts.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // Forward declarations of operators == and <, needed for friend declaration.\n \n@@ -59,20 +60,12 @@ class stack {\n   __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);\n \n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const stack<_Tp1, _Seq1>&,\n                           const stack<_Tp1, _Seq1>&);\n   template <class _Tp1, class _Seq1>\n   friend bool operator< (const stack<_Tp1, _Seq1>&,\n                          const stack<_Tp1, _Seq1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const stack&, const stack&);\n-  friend bool __STD_QUALIFIER\n-  operator< __STL_NULL_TMPL_ARGS (const stack&, const stack&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:\n   typedef typename _Sequence::value_type      value_type;\n   typedef typename _Sequence::size_type       size_type;\n@@ -106,8 +99,6 @@ bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n   return __x.c < __y.c;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Seq>\n bool operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n {\n@@ -132,9 +123,7 @@ bool operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_STACK_H */\n "}, {"sha": "e1c5334e42b46aba80593182dc597e1155e23812", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,7 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_TEMPBUF_H\n #define __SGI_STL_INTERNAL_TEMPBUF_H\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _Tp>\n pair<_Tp*, ptrdiff_t> \n@@ -50,15 +51,11 @@ __get_temporary_buffer(ptrdiff_t __len, _Tp*)\n   return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);\n }\n \n-#ifdef __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n-\n template <class _Tp>\n inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {\n   return __get_temporary_buffer(__len, (_Tp*) 0);\n }\n \n-#endif /* __STL_EXPLICIT_FUNCTION_TMPL_ARGS */\n-\n // This overload is not required by the standard; it is an extension.\n // It is supported for backward compatibility with the HP STL, and\n // because not all compilers support the language feature (explicit\n@@ -109,12 +106,8 @@ class _Temporary_buffer {\n \n   _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {\n     // Workaround for a __type_traits bug in the pre-7.3 compiler.\n-#   if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION < 730\n-    typedef typename __type_traits<_Tp>::is_POD_type _Trivial;\n-#   else\n     typedef typename __type_traits<_Tp>::has_trivial_default_constructor\n             _Trivial;\n-#   endif\n \n     __STL_TRY {\n       _M_len = 0;\n@@ -141,9 +134,7 @@ class _Temporary_buffer {\n \n template <class _ForwardIterator, \n           class _Tp \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n                     = typename iterator_traits<_ForwardIterator>::value_type\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n          >\n struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n {\n@@ -152,7 +143,7 @@ struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n   ~temporary_buffer() {}\n };\n     \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_TEMPBUF_H */\n "}, {"sha": "e869a3fc21db13ea971e15217122219761e01f02", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -36,8 +36,8 @@\n #include <windows.h>\n #endif\n \n-__STL_BEGIN_NAMESPACE\n-\n+namespace std\n+{\n \n // Class _Refcount_Base provides a type, _RC_t, a data member,\n // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n@@ -365,15 +365,11 @@ struct _STL_auto_lock\n   _STL_auto_lock(const _STL_auto_lock&);\n };\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_THREADS_H */\n \n // Local Variables:\n // mode:C++\n // End:\n \n-\n-\n-\n-"}, {"sha": "253734e60ec3263ac502fd75b4c76a00b0d49cad", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 7, "deletions": 124, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -58,11 +58,8 @@ iterators invalidated are those referring to the deleted node.\n #include <bits/stl_construct.h>\n #include <bits/stl_function.h>\n \n-__STL_BEGIN_NAMESPACE \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{ \n \n typedef bool _Rb_tree_Color_type;\n const _Rb_tree_Color_type _S_rb_tree_red = false;\n@@ -165,9 +162,7 @@ struct _Rb_tree_iterator : public _Rb_tree_base_iterator\n   _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }\n \n   reference operator*() const { return _Link_type(_M_node)->_M_value_field; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   _Self& operator++() { _M_increment(); return *this; }\n   _Self operator++(int) {\n@@ -220,25 +215,6 @@ inline bool operator!=(const _Rb_tree_iterator<_Value, _Value&, _Value*>& __x,\n   return __x._M_node != __y._M_node;\n }\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-inline bidirectional_iterator_tag\n-iterator_category(const _Rb_tree_base_iterator&) {\n-  return bidirectional_iterator_tag();\n-}\n-\n-inline _Rb_tree_base_iterator::difference_type*\n-distance_type(const _Rb_tree_base_iterator&) {\n-  return (_Rb_tree_base_iterator::difference_type*) 0;\n-}\n-\n-template <class _Value, class _Ref, class _Ptr>\n-inline _Value* value_type(const _Rb_tree_iterator<_Value, _Ref, _Ptr>&) {\n-  return (_Value*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n inline void \n _Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n {\n@@ -361,7 +337,7 @@ _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,\n     else \n       __z->_M_parent->_M_right = __y;\n     __y->_M_parent = __z->_M_parent;\n-    __STD::swap(__y->_M_color, __z->_M_color);\n+    std::swap(__y->_M_color, __z->_M_color);\n     __y = __z;\n     // __y now points to node to be actually deleted\n   }\n@@ -459,8 +435,6 @@ _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,\n // having an empty base class, we arbitrarily move one of rb_tree's\n // data members into the base class.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // _Base for general standard-conforming allocators.\n template <class _Tp, class _Alloc, bool _S_instanceless>\n class _Rb_tree_alloc_base {\n@@ -519,30 +493,6 @@ struct _Rb_tree_base\n \n };\n \n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc>\n-struct _Rb_tree_base\n-{\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Rb_tree_base(const allocator_type&) \n-    : _M_header(0) { _M_header = _M_get_node(); }\n-  ~_Rb_tree_base() { _M_put_node(_M_header); }\n-\n-protected:\n-  _Rb_tree_node<_Tp>* _M_header;\n-\n-  typedef simple_alloc<_Rb_tree_node<_Tp>, _Alloc> _Alloc_type;\n-\n-  _Rb_tree_node<_Tp>* _M_get_node()\n-    { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Rb_tree_node<_Tp>* __p)\n-    { _Alloc_type::deallocate(__p, 1); }\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n \n template <class _Key, class _Value, class _KeyOfValue, class _Compare,\n           class _Alloc = allocator<_Value> >\n@@ -567,11 +517,9 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n   allocator_type get_allocator() const { return _Base::get_allocator(); }\n \n protected:\n-#ifdef __STL_USE_NAMESPACES\n   using _Base::_M_get_node;\n   using _Base::_M_put_node;\n   using _Base::_M_header;\n-#endif /* __STL_USE_NAMESPACES */\n \n protected:\n \n@@ -648,17 +596,8 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n   typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> \n           const_iterator;\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n   typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n-                                         difference_type>\n-          reverse_iterator; \n-  typedef reverse_bidirectional_iterator<const_iterator, value_type,\n-                                         const_reference, difference_type>\n-          const_reverse_iterator;\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n \n private:\n   iterator _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n@@ -726,9 +665,9 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n   size_type max_size() const { return size_type(-1); }\n \n   void swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __t) {\n-    __STD::swap(_M_header, __t._M_header);\n-    __STD::swap(_M_node_count, __t._M_node_count);\n-    __STD::swap(_M_key_compare, __t._M_key_compare);\n+    std::swap(_M_header, __t._M_header);\n+    std::swap(_M_node_count, __t._M_node_count);\n+    std::swap(_M_key_compare, __t._M_key_compare);\n   }\n     \n public:\n@@ -739,17 +678,10 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n   iterator insert_unique(iterator __position, const value_type& __x);\n   iterator insert_equal(iterator __position, const value_type& __x);\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n   template <class _InputIterator>\n   void insert_unique(_InputIterator __first, _InputIterator __last);\n   template <class _InputIterator>\n   void insert_equal(_InputIterator __first, _InputIterator __last);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert_unique(const_iterator __first, const_iterator __last);\n-  void insert_unique(const value_type* __first, const value_type* __last);\n-  void insert_equal(const_iterator __first, const_iterator __last);\n-  void insert_equal(const value_type* __first, const value_type* __last);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   void erase(iterator __position);\n   size_type erase(const key_type& __x);\n@@ -802,8 +734,6 @@ operator<(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x,\n                                  __y.begin(), __y.end());\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Value, class _KeyOfValue, \n           class _Compare, class _Alloc>\n inline bool \n@@ -846,8 +776,6 @@ swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n \n template <class _Key, class _Value, class _KeyOfValue, \n           class _Compare, class _Alloc>\n@@ -1021,8 +949,6 @@ _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>\n   }\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n   template<class _II>\n void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n@@ -1040,45 +966,6 @@ void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n     insert_unique(*__first);\n }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n-void\n-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_equal(const _Val* __first, const _Val* __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert_equal(*__first);\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n-void\n-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_equal(const_iterator __first, const_iterator __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert_equal(*__first);\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n-void \n-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_unique(const _Val* __first, const _Val* __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert_unique(*__first);\n-}\n-\n-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>\n-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>\n-  ::insert_unique(const_iterator __first, const_iterator __last)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert_unique(*__first);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-         \n template <class _Key, class _Value, class _KeyOfValue, \n           class _Compare, class _Alloc>\n inline void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>\n@@ -1381,11 +1268,7 @@ struct rb_tree : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>\n   ~rb_tree() {}\n };\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n+} // namespace std \n \n #endif /* __SGI_STL_INTERNAL_TREE_H */\n "}, {"sha": "acbf4ab80b848dbe7afa99dfaecb8b5e5916c779", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,7 +33,8 @@\n \n #include <bits/std_cstring.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // uninitialized_copy\n \n@@ -272,7 +273,7 @@ __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,\n   __STL_UNWIND(_Destroy(__first2, __mid2));\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_UNINITIALIZED_H */\n "}, {"sha": "afdb1e3b59a48c9e554d8a4e55f75155bf14d052", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 7, "deletions": 159, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -32,24 +32,17 @@\n #define __SGI_STL_INTERNAL_VECTOR_H\n \n #include <bits/functexcept.h>\n-\n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{ \n \n // The vector base class serves two purposes.  First, its constructor\n // and destructor allocate (but don't initialize) storage.  This makes\n // exception safety easier.  Second, the base class encapsulates all of\n // the differences between SGI-style allocators and standard-conforming\n // allocators.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // Base class for ordinary allocators.\n template <class _Tp, class _Allocator, bool _IsStatic>\n class _Vector_alloc_base {\n@@ -119,39 +112,6 @@ struct _Vector_base\n   ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n };    \n \n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> \n-class _Vector_base {\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Vector_base(const _Alloc&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) {}\n-  _Vector_base(size_t __n, const _Alloc&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) \n-  {\n-    _M_start = _M_allocate(__n);\n-    _M_finish = _M_start;\n-    _M_end_of_storage = _M_start + __n;\n-  }\n-\n-  ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-\n-protected:\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n-\n-  typedef simple_alloc<_Tp, _Alloc> _M_data_allocator;\n-  _Tp* _M_allocate(size_t __n)\n-    { return _M_data_allocator::allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n) \n-    { _M_data_allocator::deallocate(__p, __n); }\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n \n template <class _Tp, class _Alloc = allocator<_Tp> >\n class vector : protected _Vector_base<_Tp, _Alloc> \n@@ -177,24 +137,15 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   typedef typename _Base::allocator_type allocator_type;\n   allocator_type get_allocator() const { return _Base::get_allocator(); }\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n   typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                           difference_type>  const_reverse_iterator;\n-  typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-          reverse_iterator;\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:\n-#ifdef __STL_HAS_NAMESPACES\n   using _Base::_M_allocate;\n   using _Base::_M_deallocate;\n   using _Base::_M_start;\n   using _Base::_M_finish;\n   using _Base::_M_end_of_storage;\n-#endif /* __STL_HAS_NAMESPACES */\n \n protected:\n   void _M_insert_aux(iterator __position, const _Tp& __x);\n@@ -228,7 +179,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   reference operator[](size_type __n) { return *(begin() + __n); }\n   const_reference operator[](size_type __n) const { return *(begin() + __n); }\n \n-#ifdef __STL_THROW_RANGE_ERRORS\n   void _M_range_check(size_type __n) const {\n     if (__n >= this->size())\n       __throw_out_of_range(\"vector\");\n@@ -238,7 +188,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     { _M_range_check(__n); return (*this)[__n]; }\n   const_reference at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n-#endif /* __STL_THROW_RANGE_ERRORS */\n \n   explicit vector(const allocator_type& __a = allocator_type())\n     : _Base(__a) {}\n@@ -256,7 +205,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     : _Base(__x.size(), __x.get_allocator())\n     { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InputIterator>\n   vector(_InputIterator __first, _InputIterator __last,\n@@ -278,13 +226,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n-#else\n-  vector(const _Tp* __first, const _Tp* __last,\n-         const allocator_type& __a = allocator_type())\n-    : _Base(__last - __first, __a) \n-    { _M_finish = uninitialized_copy(__first, __last, _M_start); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   ~vector() { destroy(_M_start, _M_finish); }\n \n   vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);\n@@ -308,8 +249,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n   void _M_fill_assign(size_type __n, const _Tp& __val);\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-  \n   template <class _InputIterator>\n   void assign(_InputIterator __first, _InputIterator __last) {\n     typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -332,8 +271,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n                      forward_iterator_tag); \n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   reference front() { return *begin(); }\n   const_reference front() const { return *begin(); }\n   reference back() { return *(end() - 1); }\n@@ -356,9 +293,9 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_insert_aux(end());\n   }\n   void swap(vector<_Tp, _Alloc>& __x) {\n-    __STD::swap(_M_start, __x._M_start);\n-    __STD::swap(_M_finish, __x._M_finish);\n-    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);\n+    std::swap(_M_start, __x._M_start);\n+    std::swap(_M_finish, __x._M_finish);\n+    std::swap(_M_end_of_storage, __x._M_end_of_storage);\n   }\n \n   iterator insert(iterator __position, const _Tp& __x) {\n@@ -381,7 +318,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_insert_aux(iterator(__position));\n     return begin() + __n;\n   }\n-#ifdef __STL_MEMBER_TEMPLATES\n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InputIterator>\n   void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n@@ -400,10 +336,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n                           __false_type) {\n     _M_range_insert(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n   }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator __position,\n-              const_iterator __first, const_iterator __last);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   void insert (iterator __pos, size_type __n, const _Tp& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n@@ -439,33 +371,18 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n protected:\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _ForwardIterator>\n   pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, \n                                                _ForwardIterator __last)\n-{\n-    pointer __result = _M_allocate(__n);\n-    __STL_TRY {\n-      uninitialized_copy(__first, __last, __result);\n-      return __result;\n-    }\n-    __STL_UNWIND(_M_deallocate(__result, __n));\n-  }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  pointer _M_allocate_and_copy(size_type __n, const_iterator __first, \n-                                               const_iterator __last)\n   {\n-    iterator __result(_M_allocate(__n));\n+    pointer __result = _M_allocate(__n);\n     __STL_TRY {\n       uninitialized_copy(__first, __last, __result);\n       return __result;\n     }\n     __STL_UNWIND(_M_deallocate(__result, __n));\n   }\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n-\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void _M_range_initialize(_InputIterator __first,  \n                            _InputIterator __last, input_iterator_tag)\n@@ -495,8 +412,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void _M_range_insert(iterator __pos,\n                        _ForwardIterator __first, _ForwardIterator __last,\n                        forward_iterator_tag);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n };\n \n template <class _Tp, class _Alloc>\n@@ -515,8 +430,6 @@ operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n                                  __y.begin(), __y.end());\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Alloc>\n inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n {\n@@ -547,8 +460,6 @@ operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _Tp, class _Alloc>\n vector<_Tp,_Alloc>& \n vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n@@ -590,8 +501,6 @@ void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)\n     erase(fill_n(begin(), __n, __val), end());\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _InputIter>\n void vector<_Tp, _Alloc>::_M_assign_aux(_InputIter __first, _InputIter __last,\n                                         input_iterator_tag) {\n@@ -631,8 +540,6 @@ vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n   }\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n void \n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n@@ -746,8 +653,6 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n   }\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _InputIterator>\n void \n vector<_Tp, _Alloc>::_M_range_insert(iterator __pos, \n@@ -813,64 +718,7 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n   }\n }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class _Tp, class _Alloc>\n-void \n-vector<_Tp, _Alloc>::insert(iterator __position, \n-                            const_iterator __first, \n-                            const_iterator __last)\n-{\n-  if (__first != __last) {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n-      const size_type __elems_after = _M_finish - __position;\n-      iterator __old_finish(_M_finish);\n-      if (__elems_after > __n) {\n-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-        _M_finish += __n;\n-        copy_backward(__position, __old_finish - __n, __old_finish);\n-        copy(__first, __last, __position);\n-      }\n-      else {\n-        uninitialized_copy(__first + __elems_after, __last, _M_finish);\n-        _M_finish += __n - __elems_after;\n-        uninitialized_copy(__position, __old_finish, _M_finish);\n-        _M_finish += __elems_after;\n-        copy(__first, __first + __elems_after, __position);\n-      }\n-    }\n-    else {\n-      const size_type __old_size = size();\n-      const size_type __len = __old_size + max(__old_size, __n);\n-      iterator __new_start(_M_allocate(__len));\n-      iterator __new_finish(__new_start);\n-      __STL_TRY {\n-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);\n-        __new_finish = uninitialized_copy(__first, __last, __new_finish);\n-        __new_finish\n-          = uninitialized_copy(__position, _M_finish, __new_finish);\n-      }\n-      __STL_UNWIND((destroy(__new_start,__new_finish),\n-                    _M_deallocate(__new_start,__len)));\n-      destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __new_start;\n-      _M_finish = __new_finish;\n-      _M_end_of_storage = __new_start + __len;\n-    }\n-  }\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n+} // namespace std \n \n #endif /* __SGI_STL_INTERNAL_VECTOR_H */\n "}, {"sha": "783fffeeed85f5f39de050e73a4913f1ebdadd20", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -223,7 +223,3 @@ namespace std {\n \n #endif // _CPP_BITS_STREAMBUF_TCC\n \n-\n-\n-\n-"}, {"sha": "70b3522f059938f9a9bb93dbb9268c887c5ba418", "filename": "libstdc++-v3/include/bits/type_traits.h", "status": "modified", "additions": 34, "deletions": 107, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -86,153 +86,140 @@ struct __type_traits {\n };\n \n \n+// Provide some specializations.\n \n-// Provide some specializations.  This is harmless for compilers that\n-//  have built-in __types_traits support, and essential for compilers\n-//  that don't.\n-\n-#ifndef __STL_NO_BOOL\n-\n-__STL_TEMPLATE_NULL struct __type_traits<bool> {\n+template<> struct __type_traits<bool> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#endif /* __STL_NO_BOOL */\n-\n-__STL_TEMPLATE_NULL struct __type_traits<char> {\n+template<> struct __type_traits<char> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<signed char> {\n+template<> struct __type_traits<signed char> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<unsigned char> {\n+template<> struct __type_traits<unsigned char> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#ifdef __STL_HAS_WCHAR_T\n-\n-__STL_TEMPLATE_NULL struct __type_traits<wchar_t> {\n+template<> struct __type_traits<wchar_t> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#endif /* __STL_HAS_WCHAR_T */\n-\n-__STL_TEMPLATE_NULL struct __type_traits<short> {\n+template<> struct __type_traits<short> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<unsigned short> {\n+template<> struct __type_traits<unsigned short> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<int> {\n+template<> struct __type_traits<int> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<unsigned int> {\n+template<> struct __type_traits<unsigned int> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<long> {\n+template<> struct __type_traits<long> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<unsigned long> {\n+template<> struct __type_traits<unsigned long> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#ifdef __STL_LONG_LONG\n+#ifdef _GLIBCPP_USE_LONG_LONG\n \n-__STL_TEMPLATE_NULL struct __type_traits<long long> {\n+template<> struct __type_traits<long long> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<unsigned long long> {\n+template<> struct __type_traits<unsigned long long> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#endif /* __STL_LONG_LONG */\n+#endif /* _GLIBCPP_USE_LONG_LONG */\n \n-__STL_TEMPLATE_NULL struct __type_traits<float> {\n+template<> struct __type_traits<float> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<double> {\n+template<> struct __type_traits<double> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-__STL_TEMPLATE_NULL struct __type_traits<long double> {\n+template<> struct __type_traits<long double> {\n    typedef __true_type    has_trivial_default_constructor;\n    typedef __true_type    has_trivial_copy_constructor;\n    typedef __true_type    has_trivial_assignment_operator;\n    typedef __true_type    has_trivial_destructor;\n    typedef __true_type    is_POD_type;\n };\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _Tp>\n struct __type_traits<_Tp*> {\n    typedef __true_type    has_trivial_default_constructor;\n@@ -242,58 +229,6 @@ struct __type_traits<_Tp*> {\n    typedef __true_type    is_POD_type;\n };\n \n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-__STL_TEMPLATE_NULL struct __type_traits<char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-__STL_TEMPLATE_NULL struct __type_traits<signed char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-__STL_TEMPLATE_NULL struct __type_traits<unsigned char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-__STL_TEMPLATE_NULL struct __type_traits<const char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-__STL_TEMPLATE_NULL struct __type_traits<const signed char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-__STL_TEMPLATE_NULL struct __type_traits<const unsigned char*> {\n-   typedef __true_type    has_trivial_default_constructor;\n-   typedef __true_type    has_trivial_copy_constructor;\n-   typedef __true_type    has_trivial_assignment_operator;\n-   typedef __true_type    has_trivial_destructor;\n-   typedef __true_type    is_POD_type;\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n \n // The following could be written in terms of numeric_limits.  \n // We're doing it separately to reduce the number of dependencies.\n@@ -302,69 +237,61 @@ template <class _Tp> struct _Is_integer {\n   typedef __false_type _Integral;\n };\n \n-#ifndef __STL_NO_BOOL\n-\n-__STL_TEMPLATE_NULL struct _Is_integer<bool> {\n+template<> struct _Is_integer<bool> {\n   typedef __true_type _Integral;\n };\n \n-#endif /* __STL_NO_BOOL */\n-\n-__STL_TEMPLATE_NULL struct _Is_integer<char> {\n+template<> struct _Is_integer<char> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<signed char> {\n+template<> struct _Is_integer<signed char> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<unsigned char> {\n+template<> struct _Is_integer<unsigned char> {\n   typedef __true_type _Integral;\n };\n \n-#ifdef __STL_HAS_WCHAR_T\n-\n-__STL_TEMPLATE_NULL struct _Is_integer<wchar_t> {\n+template<> struct _Is_integer<wchar_t> {\n   typedef __true_type _Integral;\n };\n \n-#endif /* __STL_HAS_WCHAR_T */\n-\n-__STL_TEMPLATE_NULL struct _Is_integer<short> {\n+template<> struct _Is_integer<short> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<unsigned short> {\n+template<> struct _Is_integer<unsigned short> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<int> {\n+template<> struct _Is_integer<int> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<unsigned int> {\n+template<> struct _Is_integer<unsigned int> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<long> {\n+template<> struct _Is_integer<long> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<unsigned long> {\n+template<> struct _Is_integer<unsigned long> {\n   typedef __true_type _Integral;\n };\n \n-#ifdef __STL_LONG_LONG\n+#ifdef _GLIBCPP_USE_LONG_LONG\n \n-__STL_TEMPLATE_NULL struct _Is_integer<long long> {\n+template<> struct _Is_integer<long long> {\n   typedef __true_type _Integral;\n };\n \n-__STL_TEMPLATE_NULL struct _Is_integer<unsigned long long> {\n+template<> struct _Is_integer<unsigned long long> {\n   typedef __true_type _Integral;\n };\n \n-#endif /* __STL_LONG_LONG */\n+#endif /* _GLIBCPP_USE_LONG_LONG */\n \n template<typename _Tp> struct _Is_normal_iterator {\n    typedef __false_type _Normal;"}, {"sha": "392dc9b7eb0d2534b4de3029570c9370ca7fdbca", "filename": "libstdc++-v3/include/bits/valarray_meta.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- internal _Meta class.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,7 +34,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n+namespace std\n+{\n \n     //\n     // Implementing a loosened valarray return value is tricky."}, {"sha": "d40fe50a5b509daeb217a5eace01b2c29b3e8935", "filename": "libstdc++-v3/include/ext/bvector", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,11 +31,7 @@\n #include <bits/std_vector.h>\n #include <ext/stl_bvector.h>\n \n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::bit_vector;\n-\n-#endif /* __STL_USE_NAMESPACES */\n+using std::bit_vector;\n \n #endif /* __SGI_STL_BVECTOR_H */\n "}, {"sha": "cbaf1d6a07a402aa594fc72b374c2beaea886cbc", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 3, "deletions": 119, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,12 +33,8 @@\n \n #include <ext/stl_hashtable.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n // Forward declaration of equality operator; needed for friend declaration.\n \n@@ -95,7 +91,6 @@ public:\n            const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   hash_map(_InputIterator __f, _InputIterator __l)\n     : _M_ht(100, hasher(), key_equal(), allocator_type())\n@@ -116,54 +111,15 @@ public:\n     : _M_ht(__n, __hf, __eql, __a)\n     { _M_ht.insert_unique(__f, __l); }\n \n-#else\n-  hash_map(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-  hash_map(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n public:\n   size_type size() const { return _M_ht.size(); }\n   size_type max_size() const { return _M_ht.max_size(); }\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n   friend bool operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,\n                           const hash_map<_K1, _T1, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n #include <bits/concept_checks.h>\n \n@@ -175,17 +131,9 @@ public:\n public:\n   pair<iterator,bool> insert(const value_type& __obj)\n     { return _M_ht.insert_unique(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __f, _InputIterator __l)\n     { _M_ht.insert_unique(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_unique(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n   pair<iterator,bool> insert_noresize(const value_type& __obj)\n     { return _M_ht.insert_unique_noresize(__obj); }    \n \n@@ -225,8 +173,6 @@ operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n   return __hm1._M_ht == __hm2._M_ht;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n inline bool \n operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n@@ -242,8 +188,6 @@ swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n   __hm1.swap(__hm2);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n // Forward declaration of equality operator; needed for friend declaration.\n \n template <class _Key, class _Tp,\n@@ -306,7 +250,6 @@ public:\n                 const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   hash_multimap(_InputIterator __f, _InputIterator __l)\n     : _M_ht(100, hasher(), key_equal(), allocator_type())\n@@ -327,54 +270,15 @@ public:\n     : _M_ht(__n, __hf, __eql, __a)\n     { _M_ht.insert_equal(__f, __l); }\n \n-#else\n-  hash_multimap(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-\n-  hash_multimap(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n public:\n   size_type size() const { return _M_ht.size(); }\n   size_type max_size() const { return _M_ht.max_size(); }\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n   friend bool operator== (const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,\n                           const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&,const hash_multimap&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   iterator begin() { return _M_ht.begin(); }\n   iterator end() { return _M_ht.end(); }\n@@ -384,17 +288,9 @@ public:\n public:\n   iterator insert(const value_type& __obj) \n     { return _M_ht.insert_equal(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __f, _InputIterator __l) \n     { _M_ht.insert_equal(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_equal(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n   iterator insert_noresize(const value_type& __obj)\n     { return _M_ht.insert_equal_noresize(__obj); }    \n \n@@ -431,8 +327,6 @@ operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n   return __hm1._M_ht == __hm2._M_ht;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n inline bool \n operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n@@ -448,13 +342,10 @@ swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n   __hm1.swap(__hm2);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n // Specialization of insert_iterator so that it will work for hash_map\n // and hash_multimap.\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n class insert_iterator<hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {\n protected:\n@@ -508,14 +399,7 @@ public:\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_HASH_MAP_H */\n "}, {"sha": "aedf1b5f5658cbe2831d56ee044ad908bb8d3445", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 3, "deletions": 120, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -35,12 +35,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{\n \n // Forward declaration of equality operator; needed for friend declaration.\n \n@@ -102,7 +98,6 @@ public:\n            const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   hash_set(_InputIterator __f, _InputIterator __l)\n     : _M_ht(100, hasher(), key_equal(), allocator_type())\n@@ -122,55 +117,16 @@ public:\n            const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a)\n     { _M_ht.insert_unique(__f, __l); }\n-#else\n-\n-  hash_set(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-  hash_set(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n   size_type size() const { return _M_ht.size(); }\n   size_type max_size() const { return _M_ht.max_size(); }\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Val, class _HF, class _EqK, class _Al>  \n   friend bool operator== (const hash_set<_Val, _HF, _EqK, _Al>&,\n                           const hash_set<_Val, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_set&, const hash_set&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   iterator begin() const { return _M_ht.begin(); }\n   iterator end() const { return _M_ht.end(); }\n@@ -181,17 +137,9 @@ public:\n       pair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);\n       return pair<iterator,bool>(__p.first, __p.second);\n     }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __f, _InputIterator __l) \n     { _M_ht.insert_unique(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_unique(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    {_M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n   pair<iterator, bool> insert_noresize(const value_type& __obj)\n   {\n     pair<typename _Ht::iterator, bool> __p = \n@@ -227,8 +175,6 @@ operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n   return __hs1._M_ht == __hs2._M_ht;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n inline bool \n operator!=(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n@@ -244,8 +190,6 @@ swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n   __hs1.swap(__hs2);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n \n template <class _Value,\n           class _HashFcn  = hash<_Value>,\n@@ -306,7 +250,6 @@ public:\n                 const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a) {}\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   hash_multiset(_InputIterator __f, _InputIterator __l)\n     : _M_ht(100, hasher(), key_equal(), allocator_type())\n@@ -326,73 +269,26 @@ public:\n                 const allocator_type& __a = allocator_type())\n     : _M_ht(__n, __hf, __eql, __a)\n     { _M_ht.insert_equal(__f, __l); }\n-#else\n-\n-  hash_multiset(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-\n-  hash_multiset(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n   size_type size() const { return _M_ht.size(); }\n   size_type max_size() const { return _M_ht.max_size(); }\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Val, class _HF, class _EqK, class _Al>  \n   friend bool operator== (const hash_multiset<_Val, _HF, _EqK, _Al>&,\n                           const hash_multiset<_Val, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,const hash_multiset&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n \n   iterator begin() const { return _M_ht.begin(); }\n   iterator end() const { return _M_ht.end(); }\n \n public:\n   iterator insert(const value_type& __obj)\n     { return _M_ht.insert_equal(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert(_InputIterator __f, _InputIterator __l) \n     { _M_ht.insert_equal(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_equal(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n   iterator insert_noresize(const value_type& __obj)\n     { return _M_ht.insert_equal_noresize(__obj); }    \n \n@@ -424,8 +320,6 @@ operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n   return __hs1._M_ht == __hs2._M_ht;\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n inline bool \n operator!=(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n@@ -440,13 +334,9 @@ swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n   __hs1.swap(__hs2);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n // Specialization of insert_iterator so that it will work for hash_set\n // and hash_multiset.\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n class insert_iterator<hash_set<_Value, _HashFcn, _EqualKey, _Alloc> > {\n protected:\n@@ -500,14 +390,7 @@ public:\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_HASH_SET_H */\n "}, {"sha": "7f790f642114211a7ceef338741457cd5c0905a4", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 17, "deletions": 95, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -15,23 +15,15 @@\n  *   You should not attempt to use it directly.\n  */\n \n-# include <bits/std_cstdio.h>     \n-\n-#ifdef __STL_USE_NEW_IOSTREAMS \n-# include <iostream>\n-#else /* __STL_USE_NEW_IOSTREAMS */\n-# include <bits/std_iostream.h>\n-#endif /* __STL_USE_NEW_IOSTREAMS */\n+#include <bits/std_cstdio.h>     \n+#include <bits/std_iostream.h>\n \n #ifdef __STL_USE_EXCEPTIONS\n # include <bits/std_stdexcept.h>\n #endif\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#endif\n+namespace std\n+{\n \n // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n // if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.\n@@ -303,26 +295,16 @@ inline void _Rope_RopeRep<_CharT,_Alloc>::_M_free_c_string()\n \n \n template <class _CharT, class _Alloc>\n-#ifdef __STL_USE_STD_ALLOCATORS\n   inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n \t\t\t\t\t\t\t   size_t __n,\n \t\t\t\t\t\t           allocator_type __a)\n-#else\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n-\t\t\t\t\t\t\t   size_t __n)\n-#endif\n {\n     if (!_S_is_basic_char_type((_CharT*)0)) {\n \tdestroy(__s, __s + __n);\n     }\n //  This has to be a static member, so this gets a bit messy\n-#   ifdef __STL_USE_STD_ALLOCATORS\n         __a.deallocate(\n \t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n-#   else\n-\t_Data_deallocate(\n-\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n-#   endif\n }\n \n \n@@ -375,13 +357,8 @@ void _Rope_RopeRep<_CharT,_Alloc>::_M_free_tree()\n #else\n \n template <class _CharT, class _Alloc>\n-#ifdef __STL_USE_STD_ALLOCATORS\n   inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n \t\t(const _CharT*, size_t, allocator_type)\n-#else\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n-\t\t(const _CharT*, size_t)\n-#endif\n {}\n \n #endif\n@@ -456,9 +433,7 @@ rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n       _S_new_RopeConcatenation(__left, __right, __left->get_allocator());\n     size_t __depth = __result->_M_depth;\n     \n-#   ifdef __STL_USE_STD_ALLOCATORS\n       __stl_assert(__left->get_allocator() == __right->get_allocator());\n-#   endif\n     if (__depth > 20 && (__result->_M_size < 1000 ||\n \t\t\t __depth > _RopeRep::_S_max_rope_depth)) {\n         _RopeRep* __balanced;\n@@ -791,22 +766,11 @@ class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n \t}\n };\n \t    \n-#ifdef __STL_USE_NEW_IOSTREAMS\n   template<class _CharT, class _Traits>\n   // Here _CharT is both the stream and rope character type.\n-#else\n-  template<class _CharT>\n-  // Here _CharT is the rope character type.  Unlike in the\n-  // above case, we somewhat handle the case in which it doesn't\n-  // match the stream character type, i.e. char.\n-#endif\n class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n-#       ifdef __STL_USE_NEW_IOSTREAMS\n \t  typedef basic_ostream<_CharT,_Traits> _Insert_ostream;\n-#\telse\n-\t  typedef ostream _Insert_ostream;\n-#\tendif\n \t_Insert_ostream& _M_o;\n     public:\n \t_Rope_insert_char_consumer(_Insert_ostream& __writer) \n@@ -817,38 +781,15 @@ class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n \t\t// Returns true to continue traversal.\n };\n \t    \n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits>\n-  bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()\n-                                        (const _CharT* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    //  We assume that formatting is set up correctly for each element.\n-    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n-    return true;\n-  }\n-\n-#else\n-  template<class _CharT>\n-  bool _Rope_insert_char_consumer<_CharT>::operator()\n-\t\t\t\t\t(const _CharT* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    //  We assume that formatting is set up correctly for each element.\n-    for (__i = 0; __i < __n; __i++) _M_o << __leaf[__i];\n-    return true;\n-  }\n-\n-\n-  __STL_TEMPLATE_NULL\n-  inline bool _Rope_insert_char_consumer<char>::operator()\n-\t\t\t\t\t(const char* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n-    return true;\n-  }\n-#endif\n+template<class _CharT, class _Traits>\n+bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()\n+                                      (const _CharT* __leaf, size_t __n)\n+{\n+  size_t __i;\n+  //  We assume that formatting is set up correctly for each element.\n+  for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n+  return true;\n+}\n \n template <class _CharT, class _Alloc>\n bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n@@ -908,12 +849,8 @@ bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n     }\n }\n \n-#ifdef __STL_USE_NEW_IOSTREAMS\n   template<class _CharT, class _Traits>\n   inline void _Rope_fill(basic_ostream<_CharT, _Traits>& __o, size_t __n)\n-#else\n-  inline void _Rope_fill(ostream& __o, size_t __n)\n-#endif\n {\n     char __f = __o.fill();\n     size_t __i;\n@@ -926,25 +863,15 @@ template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }\n inline bool _Rope_is_simple(char*) { return true; }\n inline bool _Rope_is_simple(wchar_t*) { return true; }\n \n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits, class _Alloc>\n-  basic_ostream<_CharT, _Traits>& operator<<\n-\t\t\t\t\t(basic_ostream<_CharT, _Traits>& __o,\n-\t\t\t\t\t const rope<_CharT, _Alloc>& __r)\n-#else\n-  template<class _CharT, class _Alloc>\n-  ostream& operator<< (ostream& __o, const rope<_CharT, _Alloc>& __r)\n-#endif\n+template<class _CharT, class _Traits, class _Alloc>\n+basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n+                                            const rope<_CharT, _Alloc>& __r)\n {\n     size_t __w = __o.width();\n     bool __left = bool(__o.flags() & ios::left);\n     size_t __pad_len;\n     size_t __rope_len = __r.size();\n-#   ifdef __STL_USE_NEW_IOSTREAMS\n       _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);\n-#   else\n-      _Rope_insert_char_consumer<_CharT> __c(__o);\n-#   endif\n     bool __is_simple = _Rope_is_simple((_CharT*)0);\n     \n     if (__rope_len < __w) {\n@@ -1575,12 +1502,7 @@ inline void rotate(\n }\n # endif\n \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n // Local Variables:\n // mode:C++"}, {"sha": "3c70c5cc1d5d87f5133578e95b0cce0c69d3d307", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 5, "deletions": 153, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -21,12 +21,8 @@\n \n #include <bits/concept_checks.h>\n \n-__STL_BEGIN_NAMESPACE \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n+namespace std\n+{ \n \n struct _Slist_node_base\n {\n@@ -149,9 +145,7 @@ struct _Slist_iterator : public _Slist_iterator_base\n   _Slist_iterator(const iterator& __x) : _Slist_iterator_base(__x._M_node) {}\n \n   reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   _Self& operator++()\n   {\n@@ -166,22 +160,6 @@ struct _Slist_iterator : public _Slist_iterator_base\n   }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-inline ptrdiff_t* distance_type(const _Slist_iterator_base&) {\n-  return 0;\n-}\n-\n-inline forward_iterator_tag iterator_category(const _Slist_iterator_base&) {\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr> \n-inline _Tp* value_type(const _Slist_iterator<_Tp, _Ref, _Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // Base class that encapsulates details of allocators.  Three cases:\n // an ordinary standard-conforming allocator, a standard-conforming\n@@ -190,8 +168,6 @@ inline _Tp* value_type(const _Slist_iterator<_Tp, _Ref, _Ptr>&) {\n // compatibility and because we want to avoid wasting storage on an \n // allocator instance if it isn't necessary.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // Base for general standard-conforming allocators.\n template <class _Tp, class _Allocator, bool _IsStatic>\n class _Slist_alloc_base {\n@@ -263,38 +239,6 @@ protected:\n   _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n };\n \n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> \n-struct _Slist_base {\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Slist_base(const allocator_type&) { _M_head._M_next = 0; }\n-  ~_Slist_base() { _M_erase_after(&_M_head, 0); }\n-\n-protected:\n-  typedef simple_alloc<_Slist_node<_Tp>, _Alloc> _Alloc_type;\n-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-\n-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n-  {\n-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n-    _Slist_node_base* __next_next = __next->_M_next;\n-    __pos->_M_next = __next_next;\n-    destroy(&__next->_M_data);\n-    _M_put_node(__next);\n-    return __next_next;\n-  }\n-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n-\n-protected:\n-  _Slist_node_base _M_head;\n-};  \n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n template <class _Tp, class _Alloc> \n _Slist_node_base*\n _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n@@ -310,7 +254,7 @@ _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n   return __last_node;\n }\n \n-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n+template <class _Tp, class _Alloc = allocator<_Tp> >\n class slist : private _Slist_base<_Tp,_Alloc>\n {\n   // requirements:\n@@ -369,23 +313,13 @@ public:\n   explicit slist(size_type __n) : _Base(allocator_type())\n     { _M_insert_after_fill(&this->_M_head, __n, value_type()); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   // We don't need any dispatching tricks here, because _M_insert_after_range\n   // already does them.\n   template <class _InputIterator>\n   slist(_InputIterator __first, _InputIterator __last,\n         const allocator_type& __a =  allocator_type()) : _Base(__a)\n     { _M_insert_after_range(&this->_M_head, __first, __last); }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-  slist(const_iterator __first, const_iterator __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-  slist(const value_type* __first, const value_type* __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   slist(const slist& __x) : _Base(__x.get_allocator())\n     { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }\n \n@@ -404,9 +338,6 @@ public:\n \n   void _M_fill_assign(size_type __n, const _Tp& __val);\n \n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   template <class _InputIterator>\n   void assign(_InputIterator __first, _InputIterator __last) {\n     typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -421,8 +352,6 @@ public:\n   void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n                           __false_type);\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:\n \n   iterator begin() { return iterator((_Node*)this->_M_head._M_next); }\n@@ -450,7 +379,7 @@ public:\n   bool empty() const { return this->_M_head._M_next == 0; }\n \n   void swap(slist& __x)\n-    { __STD::swap(this->_M_head._M_next, __x._M_head._M_next); }\n+    { std::swap(this->_M_head._M_next, __x._M_head._M_next); }\n \n public:\n \n@@ -491,8 +420,6 @@ private:\n       __pos = __slist_make_link(__pos, _M_create_node(__x));\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InIter>\n   void _M_insert_after_range(_Node_base* __pos, \n@@ -517,26 +444,6 @@ private:\n     }\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             const_iterator __first, const_iterator __last) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             const value_type* __first,\n-                             const value_type* __last) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:\n \n   iterator insert_after(iterator __pos, const value_type& __x) {\n@@ -551,28 +458,13 @@ public:\n     _M_insert_after_fill(__pos._M_node, __n, __x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   // We don't need any dispatching tricks here, because _M_insert_after_range\n   // already does them.\n   template <class _InIter>\n   void insert_after(iterator __pos, _InIter __first, _InIter __last) {\n     _M_insert_after_range(__pos._M_node, __first, __last);\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert_after(iterator __pos,\n-                    const_iterator __first, const_iterator __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-  void insert_after(iterator __pos,\n-                    const value_type* __first, const value_type* __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n   iterator insert(iterator __pos, const value_type& __x) {\n     return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n                                                      __pos._M_node),\n@@ -590,8 +482,6 @@ public:\n                          __n, __x);\n   } \n     \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n   // We don't need any dispatching tricks here, because _M_insert_after_range\n   // already does them.\n   template <class _InIter>\n@@ -600,21 +490,6 @@ public:\n                           __first, __last);\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert(iterator __pos, const_iterator __first, const_iterator __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n-                          __first, __last);\n-  }\n-  void insert(iterator __pos, const value_type* __first, \n-                              const value_type* __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n-                          __first, __last);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-\n public:\n   iterator erase_after(iterator __pos) {\n     return iterator((_Node*) this->_M_erase_after(__pos._M_node));\n@@ -700,7 +575,6 @@ public:\n   void merge(slist& __x);\n   void sort();     \n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Predicate> \n   void remove_if(_Predicate __pred);\n \n@@ -712,7 +586,6 @@ public:\n \n   template <class _StrictWeakOrdering> \n   void sort(_StrictWeakOrdering __comp); \n-#endif /* __STL_MEMBER_TEMPLATES */\n };\n \n template <class _Tp, class _Alloc>\n@@ -752,8 +625,6 @@ void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n     this->_M_erase_after(__prev, 0);\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> template <class _InputIter>\n void\n slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,\n@@ -773,8 +644,6 @@ slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,\n     this->_M_erase_after(__prev, 0);\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n template <class _Tp, class _Alloc>\n inline bool \n operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n@@ -801,8 +670,6 @@ operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n                                  _SL2.begin(), _SL2.end());\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Tp, class _Alloc>\n inline bool \n operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n@@ -832,8 +699,6 @@ inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {\n   __x.swap(__y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n \n template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)\n@@ -919,8 +784,6 @@ void slist<_Tp,_Alloc>::sort()\n   }\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n template <class _Tp, class _Alloc> \n template <class _Predicate>\n void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n@@ -993,13 +856,9 @@ void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)\n   }\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n // Specialization of insert_iterator so that insertions will be constant\n // time rather than linear time.\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n template <class _Tp, class _Alloc>\n class insert_iterator<slist<_Tp, _Alloc> > {\n protected:\n@@ -1032,14 +891,7 @@ public:\n   insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n+} // namespace std \n \n #endif /* __SGI_STL_INTERNAL_SLIST_H */\n "}, {"sha": "7b768a4c3ed7e28d151046fdd1c15b23bdae3ea6", "filename": "libstdc++-v3/include/ext/stl_bvector.h", "status": "modified", "additions": 350, "deletions": 548, "changes": 898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,15 +31,11 @@\n #ifndef __SGI_STL_INTERNAL_BVECTOR_H\n #define __SGI_STL_INTERNAL_BVECTOR_H\n \n-__STL_BEGIN_NAMESPACE \n+namespace std\n+{ \n \n static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n struct _Bit_reference {\n   unsigned int* _M_p;\n   unsigned int _M_mask;\n@@ -245,8 +241,6 @@ operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }\n // Bit-vector base class, which encapsulates the difference between\n // old SGI-style allocators and standard-conforming allocators.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // Base class for ordinary allocators.\n template <class _Allocator, bool __is_static>\n class _Bvector_alloc_base {\n@@ -317,577 +311,385 @@ class _Bvector_base\n   ~_Bvector_base() { _Base::_M_deallocate(); }\n };\n \n-#else /* __STL_USE_STD_ALLOCATORS */\n+} // namespace std\n \n-template <class _Alloc>\n-class _Bvector_base\n+// Declare a partial specialization of vector<T, Alloc>.\n+#include <bits/stl_vector.h>\n+namespace std\n {\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Bvector_base(const allocator_type&)\n-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n-  ~_Bvector_base() { _M_deallocate(); }\n \n-protected:\n-  typedef simple_alloc<unsigned int, _Alloc> _Alloc_type;\n+template <typename _Alloc> \n+  class vector<bool, _Alloc> : public _Bvector_base<_Alloc> \n+  {\n+  public:\n+    typedef bool value_type;\n+    typedef size_t size_type;\n+    typedef ptrdiff_t difference_type; \n+    typedef _Bit_reference reference;\n+    typedef bool const_reference;\n+    typedef _Bit_reference* pointer;\n+    typedef const bool* const_pointer;\n   \n-  unsigned int* _M_bit_alloc(size_t __n) \n-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _Alloc_type::deallocate(_M_start._M_p,\n-                              _M_end_of_storage - _M_start._M_p);\n-  }\n-\n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;  \n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-// The next few lines are confusing.  What we're doing is declaring a\n-//  partial specialization of vector<T, Alloc> if we have the necessary\n-//  compiler support.  Otherwise, we define a class bit_vector which uses\n-//  the default allocator. \n-\n-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NO_BOOL)\n-#  define __SGI_STL_VECBOOL_TEMPLATE\n-#  define __BVECTOR           vector<bool, _Alloc>\n-#  define __VECTOR            vector\n-#  define __BVECTOR_BASE      _Bvector_base<_Alloc>\n-#  define __BVECTOR_TMPL_LIST template <class _Alloc>\n-   __STL_END_NAMESPACE\n-#  include <bits/stl_vector.h>\n-   __STL_BEGIN_NAMESPACE\n-#else  /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n-#  undef  __SGI_STL_VECBOOL_TEMPLATE\n-#  define __BVECTOR           bit_vector\n-#  define __VECTOR            bit_vector\n-#  define __BVECTOR_BASE      _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) >\n-#  define __BVECTOR_TMPL_LIST\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n-\n-\n-__BVECTOR_TMPL_LIST \n-class __BVECTOR : public __BVECTOR_BASE \n-{\n-public:\n-  typedef bool value_type;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type; \n-  typedef _Bit_reference reference;\n-  typedef bool const_reference;\n-  typedef _Bit_reference* pointer;\n-  typedef const bool* const_pointer;\n-\n-  typedef _Bit_iterator                iterator;\n-  typedef _Bit_const_iterator          const_iterator;\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                           difference_type> const_reverse_iterator;\n-  typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-          reverse_iterator;\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-  typedef typename __BVECTOR_BASE::allocator_type allocator_type;\n-  allocator_type get_allocator() const {\n-    return __BVECTOR_BASE::get_allocator();\n-  }\n-\n-protected:\n-#ifdef __STL_USE_NAMESPACES  \n-  using __BVECTOR_BASE::_M_bit_alloc;\n-  using __BVECTOR_BASE::_M_deallocate;\n-  using __BVECTOR_BASE::_M_start;\n-  using __BVECTOR_BASE::_M_finish;\n-  using __BVECTOR_BASE::_M_end_of_storage;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-protected:\n-  void _M_initialize(size_type __n) {\n-    unsigned int* __q = _M_bit_alloc(__n);\n-    _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n-    _M_start = iterator(__q, 0);\n-    _M_finish = _M_start + difference_type(__n);\n-  }\n-  void _M_insert_aux(iterator __position, bool __x) {\n-    if (_M_finish._M_p != _M_end_of_storage) {\n-      copy_backward(__position, _M_finish, _M_finish + 1);\n-      *__position = __x;\n-      ++_M_finish;\n-    }\n-    else {\n-      size_type __len = size() ? 2 * size() : __WORD_BIT;\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      *__i++ = __x;\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+    typedef _Bit_iterator                iterator;\n+    typedef _Bit_const_iterator          const_iterator;\n+  \n+    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+    typedef reverse_iterator<iterator> reverse_iterator;\n+  \n+    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;\n+    allocator_type get_allocator() const {\n+      return _Bvector_base<_Alloc>::get_allocator();\n+    }\n+  \n+  protected:\n+    using _Bvector_base<_Alloc>::_M_bit_alloc;\n+    using _Bvector_base<_Alloc>::_M_deallocate;\n+    using _Bvector_base<_Alloc>::_M_start;\n+    using _Bvector_base<_Alloc>::_M_finish;\n+    using _Bvector_base<_Alloc>::_M_end_of_storage;\n+  \n+  protected:\n+    void _M_initialize(size_type __n) {\n+      unsigned int* __q = _M_bit_alloc(__n);\n+      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n       _M_start = iterator(__q, 0);\n+      _M_finish = _M_start + difference_type(__n);\n     }\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-                           input_iterator_tag) {\n-    _M_start = iterator();\n-    _M_finish = iterator();\n-    _M_end_of_storage = 0;\n-    for ( ; __first != __last; ++__first) \n-      push_back(*__first);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-                           forward_iterator_tag) {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_insert_range(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       input_iterator_tag) {\n-    for ( ; __first != __last; ++__first) {\n-      __pos = insert(__pos, *__first);\n-      ++__pos;\n+    void _M_insert_aux(iterator __position, bool __x) {\n+      if (_M_finish._M_p != _M_end_of_storage) {\n+        copy_backward(__position, _M_finish, _M_finish + 1);\n+        *__position = __x;\n+        ++_M_finish;\n+      }\n+      else {\n+        size_type __len = size() ? 2 * size() : __WORD_BIT;\n+        unsigned int* __q = _M_bit_alloc(__len);\n+        iterator __i = copy(begin(), __position, iterator(__q, 0));\n+        *__i++ = __x;\n+        _M_finish = copy(__position, end(), __i);\n+        _M_deallocate();\n+        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+        _M_start = iterator(__q, 0);\n+      }\n     }\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_insert_range(iterator __position,\n-                       _ForwardIterator __first, _ForwardIterator __last,\n-                       forward_iterator_tag) {\n-    if (__first != __last) {\n+  \n+    template <class _InputIterator>\n+    void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n+                             input_iterator_tag) {\n+      _M_start = iterator();\n+      _M_finish = iterator();\n+      _M_end_of_storage = 0;\n+      for ( ; __first != __last; ++__first) \n+        push_back(*__first);\n+    }\n+  \n+    template <class _ForwardIterator>\n+    void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n+                             forward_iterator_tag) {\n       size_type __n = 0;\n       distance(__first, __last, __n);\n+      _M_initialize(__n);\n+      copy(__first, __last, _M_start);\n+    }\n+  \n+    template <class _InputIterator>\n+    void _M_insert_range(iterator __pos,\n+                         _InputIterator __first, _InputIterator __last,\n+                         input_iterator_tag) {\n+      for ( ; __first != __last; ++__first) {\n+        __pos = insert(__pos, *__first);\n+        ++__pos;\n+      }\n+    }\n+  \n+    template <class _ForwardIterator>\n+    void _M_insert_range(iterator __position,\n+                         _ForwardIterator __first, _ForwardIterator __last,\n+                         forward_iterator_tag) {\n+      if (__first != __last) {\n+        size_type __n = 0;\n+        distance(__first, __last, __n);\n+        if (capacity() - size() >= __n) {\n+          copy_backward(__position, end(), _M_finish + difference_type(__n));\n+          copy(__first, __last, __position);\n+          _M_finish += difference_type(__n);\n+        }\n+        else {\n+          size_type __len = size() + max(size(), __n);\n+          unsigned int* __q = _M_bit_alloc(__len);\n+          iterator __i = copy(begin(), __position, iterator(__q, 0));\n+          __i = copy(__first, __last, __i);\n+          _M_finish = copy(__position, end(), __i);\n+          _M_deallocate();\n+          _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+          _M_start = iterator(__q, 0);\n+        }\n+      }\n+    }      \n+  \n+  public:\n+    iterator begin() { return _M_start; }\n+    const_iterator begin() const { return _M_start; }\n+    iterator end() { return _M_finish; }\n+    const_iterator end() const { return _M_finish; }\n+  \n+    reverse_iterator rbegin() { return reverse_iterator(end()); }\n+    const_reverse_iterator rbegin() const { \n+      return const_reverse_iterator(end()); \n+    }\n+    reverse_iterator rend() { return reverse_iterator(begin()); }\n+    const_reverse_iterator rend() const { \n+      return const_reverse_iterator(begin()); \n+    }\n+  \n+    size_type size() const { return size_type(end() - begin()); }\n+    size_type max_size() const { return size_type(-1); }\n+    size_type capacity() const {\n+      return size_type(const_iterator(_M_end_of_storage, 0) - begin());\n+    }\n+    bool empty() const { return begin() == end(); }\n+  \n+    reference operator[](size_type __n)\n+      { return *(begin() + difference_type(__n)); }\n+    const_reference operator[](size_type __n) const\n+      { return *(begin() + difference_type(__n)); }\n+  \n+    void _M_range_check(size_type __n) const {\n+      if (__n >= this->size())\n+        __throw_range_error(\"vector<bool>\");\n+    }\n+  \n+    reference at(size_type __n)\n+      { _M_range_check(__n); return (*this)[__n]; }\n+    const_reference at(size_type __n) const\n+      { _M_range_check(__n); return (*this)[__n]; }\n+  \n+    explicit vector(const allocator_type& __a = allocator_type())\n+      : _Bvector_base<_Alloc>(__a) {}\n+  \n+    vector(size_type __n, bool __value,\n+              const allocator_type& __a = allocator_type())\n+      : _Bvector_base<_Alloc>(__a)\n+    {\n+      _M_initialize(__n);\n+      fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n+    }\n+  \n+    explicit vector(size_type __n)\n+      : _Bvector_base<_Alloc>(allocator_type())\n+    {\n+      _M_initialize(__n);\n+      fill(_M_start._M_p, _M_end_of_storage, 0);\n+    }\n+  \n+    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator()) {\n+      _M_initialize(__x.size());\n+      copy(__x.begin(), __x.end(), _M_start);\n+    }\n+  \n+    // Check whether it's an integral type.  If so, it's not an iterator.\n+  \n+    template <class _Integer>\n+    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n+      _M_initialize(__n);\n+      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+    }\n+  \n+    template <class _InputIterator>\n+    void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+                                __false_type) {\n+      _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));\n+    }\n+  \n+    template <class _InputIterator>\n+    vector(_InputIterator __first, _InputIterator __last,\n+             const allocator_type& __a = allocator_type())\n+      : _Bvector_base<_Alloc>(__a)\n+    {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_initialize_dispatch(__first, __last, _Integral());\n+    }\n+      \n+    ~vector() { }\n+  \n+    vector& operator=(const vector& __x) {\n+      if (&__x == this) return *this;\n+      if (__x.size() > capacity()) {\n+        _M_deallocate();\n+        _M_initialize(__x.size());\n+      }\n+      copy(__x.begin(), __x.end(), begin());\n+      _M_finish = begin() + difference_type(__x.size());\n+      return *this;\n+    }\n+  \n+    // assign(), a generalized assignment member function.  Two\n+    // versions: one that takes a count, and one that takes a range.\n+    // The range version is a member template, so we dispatch on whether\n+    // or not the type is an integer.\n+  \n+    void _M_fill_assign(size_t __n, bool __x) {\n+      if (__n > size()) {\n+        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+        insert(end(), __n - size(), __x);\n+      }\n+      else {\n+        erase(begin() + __n, end());\n+        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+      }\n+    }\n+  \n+    void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }\n+  \n+    template <class _InputIterator>\n+    void assign(_InputIterator __first, _InputIterator __last) {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_assign_dispatch(__first, __last, _Integral());\n+    }\n+  \n+    template <class _Integer>\n+    void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      { _M_fill_assign((size_t) __n, (bool) __val); }\n+  \n+    template <class _InputIter>\n+    void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+      { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }\n+  \n+    template <class _InputIterator>\n+    void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+                       input_iterator_tag) {\n+      iterator __cur = begin();\n+      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+        *__cur = *__first;\n+      if (__first == __last)\n+        erase(__cur, end());\n+      else\n+        insert(end(), __first, __last);\n+    }\n+  \n+    template <class _ForwardIterator>\n+    void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                       forward_iterator_tag) {\n+      size_type __len = 0;\n+      distance(__first, __last, __len);\n+      if (__len < size())\n+        erase(copy(__first, __last, begin()), end());\n+      else {\n+        _ForwardIterator __mid = __first;\n+        advance(__mid, size());\n+        copy(__first, __mid, begin());\n+        insert(end(), __mid, __last);\n+      }\n+    }    \n+  \n+    void reserve(size_type __n) {\n+      if (capacity() < __n) {\n+        unsigned int* __q = _M_bit_alloc(__n);\n+        _M_finish = copy(begin(), end(), iterator(__q, 0));\n+        _M_deallocate();\n+        _M_start = iterator(__q, 0);\n+        _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+      }\n+    }\n+  \n+    reference front() { return *begin(); }\n+    const_reference front() const { return *begin(); }\n+    reference back() { return *(end() - 1); }\n+    const_reference back() const { return *(end() - 1); }\n+    void push_back(bool __x) {\n+      if (_M_finish._M_p != _M_end_of_storage)\n+        *_M_finish++ = __x;\n+      else\n+        _M_insert_aux(end(), __x);\n+    }\n+    void swap(vector<bool, _Alloc>& __x) {\n+      std::swap(_M_start, __x._M_start);\n+      std::swap(_M_finish, __x._M_finish);\n+      std::swap(_M_end_of_storage, __x._M_end_of_storage);\n+    }\n+    iterator insert(iterator __position, bool __x = bool()) {\n+      difference_type __n = __position - begin();\n+      if (_M_finish._M_p != _M_end_of_storage && __position == end())\n+        *_M_finish++ = __x;\n+      else\n+        _M_insert_aux(__position, __x);\n+      return begin() + __n;\n+    }\n+  \n+    // Check whether it's an integral type.  If so, it's not an iterator.\n+  \n+    template <class _Integer>\n+    void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+                            __true_type) {\n+      _M_fill_insert(__pos, __n, __x);\n+    }\n+  \n+    template <class _InputIterator>\n+    void _M_insert_dispatch(iterator __pos,\n+                            _InputIterator __first, _InputIterator __last,\n+                            __false_type) {\n+      _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n+    }\n+  \n+    template <class _InputIterator>\n+    void insert(iterator __position,\n+                _InputIterator __first, _InputIterator __last) {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_insert_dispatch(__position, __first, __last, _Integral());\n+    }\n+  \n+    void _M_fill_insert(iterator __position, size_type __n, bool __x) {\n+      if (__n == 0) return;\n       if (capacity() - size() >= __n) {\n         copy_backward(__position, end(), _M_finish + difference_type(__n));\n-        copy(__first, __last, __position);\n+        fill(__position, __position + difference_type(__n), __x);\n         _M_finish += difference_type(__n);\n       }\n       else {\n         size_type __len = size() + max(size(), __n);\n         unsigned int* __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n-        __i = copy(__first, __last, __i);\n-        _M_finish = copy(__position, end(), __i);\n+        fill_n(__i, __n, __x);\n+        _M_finish = copy(__position, end(), __i + difference_type(__n));\n         _M_deallocate();\n         _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n         _M_start = iterator(__q, 0);\n       }\n     }\n-  }      \n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-public:\n-  iterator begin() { return _M_start; }\n-  const_iterator begin() const { return _M_start; }\n-  iterator end() { return _M_finish; }\n-  const_iterator end() const { return _M_finish; }\n-\n-  reverse_iterator rbegin() { return reverse_iterator(end()); }\n-  const_reverse_iterator rbegin() const { \n-    return const_reverse_iterator(end()); \n-  }\n-  reverse_iterator rend() { return reverse_iterator(begin()); }\n-  const_reverse_iterator rend() const { \n-    return const_reverse_iterator(begin()); \n-  }\n-\n-  size_type size() const { return size_type(end() - begin()); }\n-  size_type max_size() const { return size_type(-1); }\n-  size_type capacity() const {\n-    return size_type(const_iterator(_M_end_of_storage, 0) - begin());\n-  }\n-  bool empty() const { return begin() == end(); }\n-\n-  reference operator[](size_type __n)\n-    { return *(begin() + difference_type(__n)); }\n-  const_reference operator[](size_type __n) const\n-    { return *(begin() + difference_type(__n)); }\n-\n-#ifdef __STL_THROW_RANGE_ERRORS\n-  void _M_range_check(size_type __n) const {\n-    if (__n >= this->size())\n-      __throw_range_error(\"vector<bool>\");\n-  }\n-\n-  reference at(size_type __n)\n-    { _M_range_check(__n); return (*this)[__n]; }\n-  const_reference at(size_type __n) const\n-    { _M_range_check(__n); return (*this)[__n]; }\n-#endif /* __STL_THROW_RANGE_ERRORS */\n-\n-  explicit __VECTOR(const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a) {}\n-\n-  __VECTOR(size_type __n, bool __value,\n-            const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n-  }\n-\n-  explicit __VECTOR(size_type __n)\n-    : __BVECTOR_BASE(allocator_type())\n-  {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, 0);\n-  }\n-\n-  __VECTOR(const __VECTOR& __x) : __BVECTOR_BASE(__x.get_allocator()) {\n-    _M_initialize(__x.size());\n-    copy(__x.begin(), __x.end(), _M_start);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-\n-  template <class _Integer>\n-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-                              __false_type) {\n-    _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));\n-  }\n-\n-  template <class _InputIterator>\n-  __VECTOR(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_dispatch(__first, __last, _Integral());\n-  }\n-    \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  __VECTOR(const_iterator __first, const_iterator __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-  __VECTOR(const bool* __first, const bool* __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  ~__VECTOR() { }\n-\n-  __VECTOR& operator=(const __VECTOR& __x) {\n-    if (&__x == this) return *this;\n-    if (__x.size() > capacity()) {\n-      _M_deallocate();\n-      _M_initialize(__x.size());\n-    }\n-    copy(__x.begin(), __x.end(), begin());\n-    _M_finish = begin() + difference_type(__x.size());\n-    return *this;\n-  }\n-\n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void _M_fill_assign(size_t __n, bool __x) {\n-    if (__n > size()) {\n-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n-      insert(end(), __n - size(), __x);\n-    }\n-    else {\n-      erase(begin() + __n, end());\n-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+  \n+    void insert(iterator __position, size_type __n, bool __x) {\n+      _M_fill_insert(__position, __n, __x);\n     }\n-  }\n-\n-  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_t) __n, (bool) __val); }\n-\n-  template <class _InputIter>\n-  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                     input_iterator_tag) {\n-    iterator __cur = begin();\n-    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-      *__cur = *__first;\n-    if (__first == __last)\n-      erase(__cur, end());\n-    else\n-      insert(end(), __first, __last);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                     forward_iterator_tag) {\n-    size_type __len = 0;\n-    distance(__first, __last, __len);\n-    if (__len < size())\n-      erase(copy(__first, __last, begin()), end());\n-    else {\n-      _ForwardIterator __mid = __first;\n-      advance(__mid, size());\n-      copy(__first, __mid, begin());\n-      insert(end(), __mid, __last);\n-    }\n-  }    \n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void reserve(size_type __n) {\n-    if (capacity() < __n) {\n-      unsigned int* __q = _M_bit_alloc(__n);\n-      _M_finish = copy(begin(), end(), iterator(__q, 0));\n-      _M_deallocate();\n-      _M_start = iterator(__q, 0);\n-      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+  \n+    void pop_back() { --_M_finish; }\n+    iterator erase(iterator __position) {\n+      if (__position + 1 != end())\n+        copy(__position + 1, end(), __position);\n+        --_M_finish;\n+      return __position;\n     }\n-  }\n-\n-  reference front() { return *begin(); }\n-  const_reference front() const { return *begin(); }\n-  reference back() { return *(end() - 1); }\n-  const_reference back() const { return *(end() - 1); }\n-  void push_back(bool __x) {\n-    if (_M_finish._M_p != _M_end_of_storage)\n-      *_M_finish++ = __x;\n-    else\n-      _M_insert_aux(end(), __x);\n-  }\n-  void swap(__BVECTOR& __x) {\n-    __STD::swap(_M_start, __x._M_start);\n-    __STD::swap(_M_finish, __x._M_finish);\n-    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);\n-  }\n-  iterator insert(iterator __position, bool __x = bool()) {\n-    difference_type __n = __position - begin();\n-    if (_M_finish._M_p != _M_end_of_storage && __position == end())\n-      *_M_finish++ = __x;\n-    else\n-      _M_insert_aux(__position, __x);\n-    return begin() + __n;\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-\n-  template <class _Integer>\n-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                          __true_type) {\n-    _M_fill_insert(__pos, __n, __x);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_insert_dispatch(iterator __pos,\n-                          _InputIterator __first, _InputIterator __last,\n-                          __false_type) {\n-    _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n-  }\n-\n-  template <class _InputIterator>\n-  void insert(iterator __position,\n-              _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__position, __first, __last, _Integral());\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator __position,\n-              const_iterator __first, const_iterator __last) {\n-    if (__first == __last) return;\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + __n);\n-      copy(__first, __last, __position);\n-      _M_finish += __n;\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      __i = copy(__first, __last, __i);\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n+    iterator erase(iterator __first, iterator __last) {\n+      _M_finish = copy(__last, end(), __first);\n+      return __first;\n     }\n-  }\n-\n-  void insert(iterator __position, const bool* __first, const bool* __last) {\n-    if (__first == __last) return;\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + __n);\n-      copy(__first, __last, __position);\n-      _M_finish += __n;\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      __i = copy(__first, __last, __i);\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n+    void resize(size_type __new_size, bool __x = bool()) {\n+      if (__new_size < size()) \n+        erase(begin() + difference_type(__new_size), end());\n+      else\n+        insert(end(), __new_size - size(), __x);\n     }\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void _M_fill_insert(iterator __position, size_type __n, bool __x) {\n-    if (__n == 0) return;\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + difference_type(__n));\n-      fill(__position, __position + difference_type(__n), __x);\n-      _M_finish += difference_type(__n);\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      fill_n(__i, __n, __x);\n-      _M_finish = copy(__position, end(), __i + difference_type(__n));\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n+    void flip() {\n+      for (unsigned int* __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n+        *__p = ~*__p;\n     }\n-  }\n-\n-  void insert(iterator __position, size_type __n, bool __x) {\n-    _M_fill_insert(__position, __n, __x);\n-  }\n-\n-  void pop_back() { --_M_finish; }\n-  iterator erase(iterator __position) {\n-    if (__position + 1 != end())\n-      copy(__position + 1, end(), __position);\n-      --_M_finish;\n-    return __position;\n-  }\n-  iterator erase(iterator __first, iterator __last) {\n-    _M_finish = copy(__last, end(), __first);\n-    return __first;\n-  }\n-  void resize(size_type __new_size, bool __x = bool()) {\n-    if (__new_size < size()) \n-      erase(begin() + difference_type(__new_size), end());\n-    else\n-      insert(end(), __new_size - size(), __x);\n-  }\n-  void flip() {\n-    for (unsigned int* __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n-      *__p = ~*__p;\n-  }\n-\n-  void clear() { erase(begin(), end()); }\n-};\n-\n-#ifdef __SGI_STL_VECBOOL_TEMPLATE\n+  \n+    void clear() { erase(begin(), end()); }\n+  };\n \n // This typedef is non-standard.  It is provided for backward compatibility.\n typedef vector<bool, alloc> bit_vector;\n \n-#else /* __SGI_STL_VECBOOL_TEMPLATE */\n-\n-inline void swap(bit_vector& __x, bit_vector& __y) {\n-  __x.swap(__y);\n-}\n-\n-inline bool \n-operator==(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return (__x.size() == __y.size() && \n-          equal(__x.begin(), __x.end(), __y.begin()));\n-}\n-\n-inline bool \n-operator!=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__x == __y);\n-}\n-\n-inline bool \n-operator<(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return lexicographical_compare(__x.begin(), __x.end(), \n-                                 __y.begin(), __y.end());\n-}\n-\n-inline bool operator>(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return __y < __x;\n-}\n-\n-inline bool operator<=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__y < __x);\n-}\n-\n-inline bool operator>=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__x < __y);\n-}\n-\n-#endif /* __SGI_STL_VECBOOL_TEMPLATE */\n-\n-#undef __SGI_STL_VECBOOL_TEMPLATE\n-#undef __BVECTOR\n-#undef __VECTOR\n-#undef __BVECTOR_BASE\n-#undef __BVECTOR_TMPL_LIST \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n+} // namespace std \n \n #endif /* __SGI_STL_INTERNAL_BVECTOR_H */\n "}, {"sha": "f5260b01290ab478c1c0a29a491678da04465eb4", "filename": "libstdc++-v3/include/ext/stl_hash_fun.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -33,7 +33,8 @@\n \n #include <bits/std_cstddef.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _Key> struct hash { };\n \n@@ -46,45 +47,45 @@ inline size_t __stl_hash_string(const char* __s)\n   return size_t(__h);\n }\n \n-__STL_TEMPLATE_NULL struct hash<char*>\n+template<> struct hash<char*>\n {\n   size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n };\n \n-__STL_TEMPLATE_NULL struct hash<const char*>\n+template<> struct hash<const char*>\n {\n   size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n };\n \n-__STL_TEMPLATE_NULL struct hash<char> {\n+template<> struct hash<char> {\n   size_t operator()(char __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<unsigned char> {\n+template<> struct hash<unsigned char> {\n   size_t operator()(unsigned char __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<signed char> {\n+template<> struct hash<signed char> {\n   size_t operator()(unsigned char __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<short> {\n+template<> struct hash<short> {\n   size_t operator()(short __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<unsigned short> {\n+template<> struct hash<unsigned short> {\n   size_t operator()(unsigned short __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<int> {\n+template<> struct hash<int> {\n   size_t operator()(int __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<unsigned int> {\n+template<> struct hash<unsigned int> {\n   size_t operator()(unsigned int __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<long> {\n+template<> struct hash<long> {\n   size_t operator()(long __x) const { return __x; }\n };\n-__STL_TEMPLATE_NULL struct hash<unsigned long> {\n+template<> struct hash<unsigned long> {\n   size_t operator()(unsigned long __x) const { return __x; }\n };\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* _CPP_BITS_STL_HASH_FUN_H */\n "}, {"sha": "ff903807fb4fbb38e2391ba323e1cdc1432745b7", "filename": "libstdc++-v3/include/ext/stl_hashtable.h", "status": "modified", "additions": 10, "deletions": 127, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -44,7 +44,8 @@\n #include <bits/stl_vector.h>\n #include <ext/stl_hash_fun.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n template <class _Val>\n struct _Hashtable_node\n@@ -92,9 +93,7 @@ struct _Hashtable_iterator {\n     : _M_cur(__n), _M_ht(__tab) {}\n   _Hashtable_iterator() {}\n   reference operator*() const { return _M_cur->_M_val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   iterator& operator++();\n   iterator operator++(int);\n   bool operator==(const iterator& __it) const\n@@ -133,9 +132,7 @@ struct _Hashtable_const_iterator {\n   _Hashtable_const_iterator(const iterator& __it) \n     : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n   reference operator*() const { return _M_cur->_M_val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   const_iterator& operator++();\n   const_iterator operator++(int);\n   bool operator==(const const_iterator& __it) const \n@@ -205,25 +202,13 @@ class hashtable {\n private:\n   typedef _Hashtable_node<_Val> _Node;\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n public:\n   typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;\n   allocator_type get_allocator() const { return _M_node_allocator; }\n private:\n   typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;\n   _Node* _M_get_node() { return _M_node_allocator.allocate(1); }\n   void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }\n-# define __HASH_ALLOC_INIT(__a) _M_node_allocator(__a), \n-#else /* __STL_USE_STD_ALLOCATORS */\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-private:\n-  typedef simple_alloc<_Node, _Alloc> _M_node_allocator_type;\n-  _Node* _M_get_node() { return _M_node_allocator_type::allocate(1); }\n-  void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); }\n-# define __HASH_ALLOC_INIT(__a)\n-#endif /* __STL_USE_STD_ALLOCATORS */\n \n private:\n   hasher                _M_hash;\n@@ -250,7 +235,7 @@ class hashtable {\n             const _EqualKey&   __eql,\n             const _ExtractKey& __ext,\n             const allocator_type& __a = allocator_type())\n-    : __HASH_ALLOC_INIT(__a)\n+    : _M_node_allocator(__a),\n       _M_hash(__hf),\n       _M_equals(__eql),\n       _M_get_key(__ext),\n@@ -264,7 +249,7 @@ class hashtable {\n             const _HashFcn&    __hf,\n             const _EqualKey&   __eql,\n             const allocator_type& __a = allocator_type())\n-    : __HASH_ALLOC_INIT(__a)\n+    : _M_node_allocator(__a),\n       _M_hash(__hf),\n       _M_equals(__eql),\n       _M_get_key(_ExtractKey()),\n@@ -275,7 +260,7 @@ class hashtable {\n   }\n \n   hashtable(const hashtable& __ht)\n-    : __HASH_ALLOC_INIT(__ht.get_allocator())\n+    : _M_node_allocator(__ht.get_allocator()),\n       _M_hash(__ht._M_hash),\n       _M_equals(__ht._M_equals),\n       _M_get_key(__ht._M_get_key),\n@@ -285,8 +270,6 @@ class hashtable {\n     _M_copy_from(__ht);\n   }\n \n-#undef __HASH_ALLOC_INIT\n-\n   hashtable& operator= (const hashtable& __ht)\n   {\n     if (&__ht != this) {\n@@ -307,11 +290,11 @@ class hashtable {\n \n   void swap(hashtable& __ht)\n   {\n-    __STD::swap(_M_hash, __ht._M_hash);\n-    __STD::swap(_M_equals, __ht._M_equals);\n-    __STD::swap(_M_get_key, __ht._M_get_key);\n+    std::swap(_M_hash, __ht._M_hash);\n+    std::swap(_M_equals, __ht._M_equals);\n+    std::swap(_M_get_key, __ht._M_get_key);\n     _M_buckets.swap(__ht._M_buckets);\n-    __STD::swap(_M_num_elements, __ht._M_num_elements);\n+    std::swap(_M_num_elements, __ht._M_num_elements);\n   }\n \n   iterator begin()\n@@ -334,15 +317,9 @@ class hashtable {\n \n   const_iterator end() const { return const_iterator(0, this); }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq, class _Al>\n   friend bool operator== (const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n                           const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hashtable&, const hashtable&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n public:\n \n   size_type bucket_count() const { return _M_buckets.size(); }\n@@ -373,7 +350,6 @@ class hashtable {\n   pair<iterator, bool> insert_unique_noresize(const value_type& __obj);\n   iterator insert_equal_noresize(const value_type& __obj);\n  \n-#ifdef __STL_MEMBER_TEMPLATES\n   template <class _InputIterator>\n   void insert_unique(_InputIterator __f, _InputIterator __l)\n   {\n@@ -424,42 +400,6 @@ class hashtable {\n       insert_equal_noresize(*__f);\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert_unique(const value_type* __f, const value_type* __l)\n-  {\n-    size_type __n = __l - __f;\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n-\n-  void insert_equal(const value_type* __f, const value_type* __l)\n-  {\n-    size_type __n = __l - __f;\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n-\n-  void insert_unique(const_iterator __f, const_iterator __l)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n-\n-  void insert_equal(const_iterator __f, const_iterator __l)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n   reference find_or_insert(const value_type& __obj);\n \n   iterator find(const key_type& __key) \n@@ -617,59 +557,6 @@ _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n   return __tmp;\n }\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline forward_iterator_tag\n-iterator_category(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Val* \n-value_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (_Val*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n-distance_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline forward_iterator_tag\n-iterator_category(const _Hashtable_const_iterator<_Val,_Key,_HF,\n-                                                  _ExK,_EqK,_All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Val* \n-value_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (_Val*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n-distance_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n                 const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)\n@@ -689,8 +576,6 @@ bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n   return true;\n }  \n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n                        const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {\n@@ -704,8 +589,6 @@ inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n   __ht1.swap(__ht2);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> \n@@ -1045,7 +928,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   __STL_UNWIND(clear());\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n #endif /* __SGI_STL_INTERNAL_HASHTABLE_H */\n "}, {"sha": "d3d3ccf449efba11e79a2e5e50f45466286a703c", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "modified", "additions": 31, "deletions": 286, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -34,11 +34,8 @@\n #    include <mutex.h>\n # endif\n \n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#endif\n+namespace std\n+{\n \n // The _S_eos function is used for those functions that\n // convert to/from C-like strings to detect the end of the string.\n@@ -97,20 +94,10 @@ class char_producer {\n // behave a little like basic_ostringstream<sequence::value_type> and a\n // little like containers.\n \n-template<class _Sequence, size_t _Buf_sz = 100\n-#   if defined(__sgi) && !defined(__GNUC__)\n-#        define __TYPEDEF_WORKAROUND\n-         ,class _V = typename _Sequence::value_type\n-#   endif\n-        >\n-// The 3rd parameter works around a common compiler bug.\n+template<class _Sequence, size_t _Buf_sz = 100>\n class sequence_buffer : public output_iterator {\n     public:\n-#       ifndef __TYPEDEF_WORKAROUND\n-            typedef typename _Sequence::value_type value_type;\n-#       else\n-            typedef _V value_type;\n-#       endif\n+        typedef typename _Sequence::value_type value_type;\n     protected:\n         _Sequence* _M_prefix;\n         value_type _M_buffer[_Buf_sz];\n@@ -208,7 +195,7 @@ class _Rope_char_consumer {\n // First a lot of forward declarations.  The standard seems to require\n // much stricter \"declaration before use\" than many of the implementations\n // that preceded it.\n-template<class _CharT, class _Alloc=__STL_DEFAULT_ALLOCATOR(_CharT)> class rope;\n+template<class _CharT, class _Alloc=allocator<_CharT> > class rope;\n template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;\n template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;\n template<class _CharT, class _Alloc> struct _Rope_RopeFunction;\n@@ -374,8 +361,6 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n //  the differences between SGI-style allocators and standard-conforming\n //  allocators.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n #define __STATIC_IF_SGI_ALLOC  /* not static */\n \n // Base class for ordinary allocators.\n@@ -445,32 +430,6 @@ struct _Rope_rep_base\n     : _Base(__size, __a) {}\n };    \n \n-#else /* !__STL_USE_STD_ALLOCATORS */\n-\n-#define __STATIC_IF_SGI_ALLOC static\n-\n-template <class _CharT, class _Alloc> \n-class _Rope_rep_base {\n-public:\n-  typedef _Alloc allocator_type;\n-  static allocator_type get_allocator() { return allocator_type(); }\n-  _Rope_rep_base(size_t __size, const allocator_type&) : _M_size(__size) {}\n-  size_t _M_size;\n-\n-protected:\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef simple_alloc<_Tp, _Alloc> __name##Alloc; \\\n-        static _Tp* __name##_allocate(size_t __n) \\\n-                { return __name##Alloc::allocate(__n); } \\\n-        static void __name##_deallocate(_Tp* __p, size_t __n) \\\n-                { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Alloc);\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n \n template<class _CharT, class _Alloc>\n struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n@@ -504,14 +463,9 @@ struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n #   ifdef __GC\n         void _M_incr () {}\n #   endif\n-#   ifdef __STL_USE_STD_ALLOCATORS\n         static void _S_free_string(__GC_CONST _CharT*, size_t __len,\n                                    allocator_type __a);\n #       define __STL_FREE_STRING(__s, __l, __a) _S_free_string(__s, __l, __a);\n-#   else\n-        static void _S_free_string(__GC_CONST _CharT*, size_t __len);\n-#       define __STL_FREE_STRING(__s, __l, __a) _S_free_string(__s, __l);\n-#   endif\n                         // Deallocate data section of a leaf.\n                         // This shouldn't be a member function.\n                         // But its hard to do anything else at the\n@@ -814,32 +768,13 @@ class _Rope_char_ref_proxy {\n     }\n };\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-    template<class _CharT, class __Alloc>\n-    inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,\n-                     _Rope_char_ref_proxy <_CharT, __Alloc > __b) {\n-        _CharT __tmp = __a;\n-        __a = __b;\n-        __b = __tmp;\n-    }\n-#else\n-// There is no really acceptable way to handle this.  The default\n-// definition of swap doesn't work for proxy references.\n-// It can't really be made to work, even with ugly hacks, since\n-// the only unusual operation it uses is the copy constructor, which\n-// is needed for other purposes.  We provide a macro for\n-// full specializations, and instantiate the most common case.\n-# define _ROPE_SWAP_SPECIALIZATION(_CharT, __Alloc) \\\n-    inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a, \\\n-                     _Rope_char_ref_proxy <_CharT, __Alloc > __b) { \\\n-        _CharT __tmp = __a; \\\n-        __a = __b; \\\n-        __b = __tmp; \\\n-    }\n-\n-_ROPE_SWAP_SPECIALIZATION(char,__STL_DEFAULT_ALLOCATOR(char))\n-\n-#endif /* !__STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+template<class _CharT, class __Alloc>\n+inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,\n+                 _Rope_char_ref_proxy <_CharT, __Alloc > __b) {\n+    _CharT __tmp = __a;\n+    __a = __b;\n+    __b = __tmp;\n+}\n \n template<class _CharT, class _Alloc>\n class _Rope_char_ptr_proxy {\n@@ -862,15 +797,9 @@ class _Rope_char_ptr_proxy {\n         _M_root = __x._M_root;\n         return *this;\n     }\n-#ifdef __STL_MEMBER_TEMPLATES\n     template<class _CharT2, class _Alloc2>\n     friend bool operator== (const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __x,\n                             const _Rope_char_ptr_proxy<_CharT2,_Alloc2>& __y);\n-#else\n-    friend bool operator==  __STL_NULL_TMPL_ARGS\n-                (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n-                 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y);\n-#endif\n     _Rope_char_ref_proxy<_CharT,_Alloc> operator*() const {\n         return _Rope_char_ref_proxy<_CharT,_Alloc>(_M_root, _M_pos);\n     }\n@@ -886,10 +815,6 @@ class _Rope_char_ptr_proxy {\n // Iterators are assumed to be thread private.  Ropes can\n // be shared.\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1375\n-#endif\n-\n template<class _CharT, class _Alloc>\n class _Rope_iterator_base\n   : public random_access_iterator<_CharT, ptrdiff_t> {\n@@ -966,10 +891,8 @@ template<class _CharT, class _Alloc>\n class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     friend class rope<_CharT,_Alloc>;\n   protected:\n-#   ifdef __STL_HAS_NAMESPACES\n       typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n       // The one from the base class may not be directly visible.\n-#   endif\n     _Rope_const_iterator(const _RopeRep* __root, size_t __pos):\n                    _Rope_iterator_base<_CharT,_Alloc>(\n                      const_cast<_RopeRep*>(__root), __pos)\n@@ -1045,7 +968,6 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         _M_decr(1);\n         return _Rope_const_iterator<_CharT,_Alloc>(_M_root, __old_pos);\n     }\n-#if defined(__STL_MEMBER_TEMPLATES) && defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)\n     template<class _CharT2, class _Alloc2>\n     friend _Rope_const_iterator<_CharT2,_Alloc2> operator-\n         (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n@@ -1058,23 +980,10 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     friend _Rope_const_iterator<_CharT2,_Alloc2> operator+\n         (ptrdiff_t __n,\n          const _Rope_const_iterator<_CharT2,_Alloc2>& __x);\n-#else\n-    friend _Rope_const_iterator<_CharT,_Alloc> operator- __STL_NULL_TMPL_ARGS\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-    friend _Rope_const_iterator<_CharT,_Alloc> operator+ __STL_NULL_TMPL_ARGS\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-    friend _Rope_const_iterator<_CharT,_Alloc> operator+ __STL_NULL_TMPL_ARGS\n-        (ptrdiff_t __n,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __x);\n-#endif\n-\n     reference operator[](size_t __n) {\n         return rope<_CharT,_Alloc>::_S_fetch(_M_root, _M_current_pos + __n);\n     }\n \n-#if defined(__STL_MEMBER_TEMPLATES) && defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)\n     template<class _CharT2, class _Alloc2>\n     friend bool operator==\n         (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n@@ -1087,17 +996,6 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     friend ptrdiff_t operator-\n         (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n          const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n-#else\n-    friend bool operator== __STL_NULL_TMPL_ARGS\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-    friend bool operator< __STL_NULL_TMPL_ARGS\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS\n-        (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_const_iterator<_CharT,_Alloc>& __y);\n-#endif\n };\n \n template<class _CharT, class _Alloc>\n@@ -1201,7 +1099,6 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n           _M_root_rope, _M_current_pos + __n);\n     }\n \n-#if defined(__STL_MEMBER_TEMPLATES) && defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)\n     template<class _CharT2, class _Alloc2>\n     friend bool operator==\n         (const _Rope_iterator<_CharT2,_Alloc2>& __x,\n@@ -1226,38 +1123,12 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     friend _Rope_iterator<_CharT2,_Alloc2> operator+\n         (ptrdiff_t __n,\n          const _Rope_iterator<_CharT2,_Alloc2>& __x);\n-#else\n-    friend bool operator== __STL_NULL_TMPL_ARGS\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-    friend bool operator< __STL_NULL_TMPL_ARGS\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-    friend ptrdiff_t operator- __STL_NULL_TMPL_ARGS\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         const _Rope_iterator<_CharT,_Alloc>& __y);\n-    friend _Rope_iterator<_CharT,_Alloc> operator- __STL_NULL_TMPL_ARGS\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-    friend _Rope_iterator<_CharT,_Alloc> operator+ __STL_NULL_TMPL_ARGS\n-        (const _Rope_iterator<_CharT,_Alloc>& __x,\n-         ptrdiff_t __n);\n-    friend _Rope_iterator<_CharT,_Alloc> operator+ __STL_NULL_TMPL_ARGS\n-        (ptrdiff_t __n,\n-         const _Rope_iterator<_CharT,_Alloc>& __x);\n-#endif\n };\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1375\n-#endif\n-\n //  The rope base class encapsulates\n //  the differences between SGI-style allocators and standard-conforming\n //  allocators.\n \n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n // Base class for ordinary allocators.\n template <class _CharT, class _Allocator, bool _IsStatic>\n class _Rope_alloc_base {\n@@ -1332,33 +1203,6 @@ struct _Rope_base\n   _Rope_base(const allocator_type& __a) : _Base(__a) {}\n };    \n \n-#else /* !__STL_USE_STD_ALLOCATORS */\n-\n-template <class _CharT, class _Alloc> \n-class _Rope_base {\n-public:\n-  typedef _Rope_RopeRep<_CharT, _Alloc> _RopeRep;\n-  typedef _Alloc allocator_type;\n-  static allocator_type get_allocator() { return allocator_type(); }\n-  _Rope_base(_RopeRep * __t, const allocator_type&) : _M_tree_ptr(__t) {}\n-  _Rope_base(const allocator_type&) {}\n-\n-protected:\n-  // The only data member of a rope:\n-    _RopeRep* _M_tree_ptr;\n-\n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef simple_alloc<_Tp, _Alloc> __name##Alloc; \\\n-        static _Tp* __name##_allocate(size_t __n) \\\n-                { return __name##Alloc::allocate(__n); } \\\n-        static void __name##_deallocate(_Tp *__p, size_t __n) \\\n-                { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Alloc)\n-# undef __ROPE_DEFINE_ALLOC\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n \n template <class _CharT, class _Alloc>\n class rope : public _Rope_base<_CharT,_Alloc> {\n@@ -1384,9 +1228,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n     protected:\n         typedef _Rope_base<_CharT,_Alloc> _Base;\n         typedef typename _Base::allocator_type allocator_type;\n-#       ifdef __STL_USE_NAMESPACES\n-          using _Base::_M_tree_ptr;\n-#       endif\n+        using _Base::_M_tree_ptr;\n         typedef __GC_CONST _CharT* _Cstrptr;\n \n         static _CharT _S_empty_c_str[1];\n@@ -1494,70 +1336,41 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,\n                                           size_t __size, allocator_type __a)\n         {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              _RopeLeaf* __space = _LAllocator(__a).allocate(1);\n-#           else\n-              _RopeLeaf* __space = _L_allocate(1);\n-#           endif\n+            _RopeLeaf* __space = _LAllocator(__a).allocate(1);\n             return new(__space) _RopeLeaf(__s, __size, __a);\n         }\n \n         static _RopeConcatenation* _S_new_RopeConcatenation(\n                         _RopeRep* __left, _RopeRep* __right,\n                         allocator_type __a)\n         {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              _RopeConcatenation* __space = _CAllocator(__a).allocate(1);\n-#           else\n-              _RopeConcatenation* __space = _C_allocate(1);\n-#           endif\n+            _RopeConcatenation* __space = _CAllocator(__a).allocate(1);\n             return new(__space) _RopeConcatenation(__left, __right, __a);\n         }\n \n         static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,\n                 size_t __size, bool __d, allocator_type __a)\n         {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              _RopeFunction* __space = _FAllocator(__a).allocate(1);\n-#           else\n-              _RopeFunction* __space = _F_allocate(1);\n-#           endif\n+            _RopeFunction* __space = _FAllocator(__a).allocate(1);\n             return new(__space) _RopeFunction(__f, __size, __d, __a);\n         }\n \n         static _RopeSubstring* _S_new_RopeSubstring(\n                 _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n                 size_t __l, allocator_type __a)\n         {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              _RopeSubstring* __space = _SAllocator(__a).allocate(1);\n-#           else\n-              _RopeSubstring* __space = _S_allocate(1);\n-#           endif\n+            _RopeSubstring* __space = _SAllocator(__a).allocate(1);\n             return new(__space) _RopeSubstring(__b, __s, __l, __a);\n         }\n \n-#       ifdef __STL_USE_STD_ALLOCATORS\n           static\n           _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,\n                        size_t __size, allocator_type __a)\n #         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \\\n                 _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)     \n-#       else\n-          static\n-          _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr2(const _CharT* __s,\n-                                                        size_t __size)\n-#         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \\\n-               _S_RopeLeaf_from_unowned_char_ptr2(__s, __size)\n-#       endif\n         {\n             if (0 == __size) return 0;\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n-#           else\n-              _CharT* __buf = _Data_allocate(_S_rounded_up_size(__size));\n-              allocator_type __a = allocator_type();\n-#           endif\n+            _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n \n             uninitialized_copy_n(__s, __size, __buf);\n             _S_cond_store_eos(__buf[__size]);\n@@ -1734,9 +1547,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         rope& operator=(const rope& __x)\n         {\n             _RopeRep* __old = _M_tree_ptr;\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              __stl_assert(get_allocator() == __x.get_allocator());\n-#           endif\n+            __stl_assert(get_allocator() == __x.get_allocator());\n             _M_tree_ptr = __x._M_tree_ptr;\n             _S_ref(_M_tree_ptr);\n             _S_unref(__old);\n@@ -1893,12 +1704,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             //  but it's harder to make guarantees.\n         }\n \n-#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n         typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-        typedef reverse_iterator<const_iterator, value_type, const_reference,\n-                                 difference_type>  const_reverse_iterator;\n-#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n \n         const_reverse_iterator rbegin() const {\n             return const_reverse_iterator(end());\n@@ -1916,7 +1722,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             return const_reverse_iterator(begin());\n         }\n \n-#if defined(__STL_MEMBER_TEMPLATES) && defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)\n         template<class _CharT2, class _Alloc2>\n         friend rope<_CharT2,_Alloc2>\n         operator+ (const rope<_CharT2,_Alloc2>& __left,\n@@ -1930,19 +1735,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         template<class _CharT2, class _Alloc2>\n         friend rope<_CharT2,_Alloc2>\n         operator+ (const rope<_CharT2,_Alloc2>& __left, _CharT2 __right);\n-#else\n-        friend rope<_CharT,_Alloc> __STD_QUALIFIER\n-        operator+ __STL_NULL_TMPL_ARGS (const rope<_CharT,_Alloc>& __left,\n-                                        const rope<_CharT,_Alloc>& __right);\n-        \n-        friend rope<_CharT,_Alloc> __STD_QUALIFIER\n-        operator+ __STL_NULL_TMPL_ARGS (const rope<_CharT,_Alloc>& __left,\n-                                        const _CharT* __right);\n-        \n-        friend rope<_CharT,_Alloc> __STD_QUALIFIER\n-        operator+ __STL_NULL_TMPL_ARGS (const rope<_CharT,_Alloc>& __left,\n-                                        _CharT __right);\n-#endif        \n         // The symmetric cases are intentionally omitted, since they're presumed\n         // to be less common, and we don't handle them as well.\n \n@@ -1973,9 +1765,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         rope& append(const_iterator __s, const_iterator __e) {\n             __stl_assert(__s._M_root == __e._M_root);\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-                __stl_assert(get_allocator() == __s._M_root->get_allocator());\n-#           endif\n+            __stl_assert(get_allocator() == __s._M_root->get_allocator());\n             _Self_destruct_ptr __appendee(_S_substring(\n               __s._M_root, __s._M_current_pos, __e._M_current_pos));\n             _RopeRep* __result = \n@@ -1996,9 +1786,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         rope& append() { return append(_CharT()); }  // XXX why?\n \n         rope& append(const rope& __y) {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-              __stl_assert(__y.get_allocator() == get_allocator());\n-#           endif\n+            __stl_assert(__y.get_allocator() == get_allocator());\n             _RopeRep* __result = _S_concat(_M_tree_ptr, __y._M_tree_ptr);\n             _S_unref(_M_tree_ptr);\n             _M_tree_ptr = __result;\n@@ -2011,9 +1799,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         void swap(rope& __b) {\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-                __stl_assert(get_allocator() == __b.get_allocator());\n-#           endif\n+            __stl_assert(get_allocator() == __b.get_allocator());\n             _RopeRep* __tmp = _M_tree_ptr;\n             _M_tree_ptr = __b._M_tree_ptr;\n             __b._M_tree_ptr = __tmp;\n@@ -2031,9 +1817,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n               _S_substring(__old, __pos2, __old->_M_size));\n             _RopeRep* __result;\n \n-#           ifdef __STL_USE_STD_ALLOCATORS\n-                __stl_assert(__old->get_allocator() == __r->get_allocator());\n-#           endif\n+            __stl_assert(__old->get_allocator() == __r->get_allocator());\n             if (0 == __r) {\n                 __result = _S_concat(__left, __right);\n             } else {\n@@ -2047,9 +1831,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         void insert(size_t __p, const rope& __r) {\n             _RopeRep* __result = \n               replace(_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n-#           ifdef __STL_USE_STD_ALLOCATORS\n-                __stl_assert(get_allocator() == __r.get_allocator());\n-#           endif\n+            __stl_assert(get_allocator() == __r.get_allocator());\n             _S_unref(_M_tree_ptr);\n             _M_tree_ptr = __result;\n         }\n@@ -2314,12 +2096,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             return(iterator(this, size()));\n         }\n \n-#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n         typedef reverse_iterator<iterator> reverse_iterator;\n-#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-        typedef reverse_iterator<iterator, value_type, reference,\n-                                 difference_type>  reverse_iterator;\n-#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n \n         reverse_iterator mutable_rbegin() {\n             return reverse_iterator(mutable_end());\n@@ -2397,8 +2174,6 @@ inline bool operator< (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n   return (__x._M_current_pos < __y._M_current_pos);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _CharT, class _Alloc>\n inline bool operator!= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n                         const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n@@ -2423,8 +2198,6 @@ inline bool operator>= (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _CharT, class _Alloc>\n inline ptrdiff_t operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x,\n                            const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n@@ -2465,8 +2238,6 @@ inline bool operator< (const _Rope_iterator<_CharT,_Alloc>& __x,\n   return (__x._M_current_pos < __y._M_current_pos);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _CharT, class _Alloc>\n inline bool operator!= (const _Rope_iterator<_CharT,_Alloc>& __x,\n                         const _Rope_iterator<_CharT,_Alloc>& __y) {\n@@ -2491,8 +2262,6 @@ inline bool operator>= (const _Rope_iterator<_CharT,_Alloc>& __x,\n   return !(__x < __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n template <class _CharT, class _Alloc>\n inline ptrdiff_t operator-(const _Rope_iterator<_CharT,_Alloc>& __x,\n                            const _Rope_iterator<_CharT,_Alloc>& __y) {\n@@ -2528,9 +2297,7 @@ rope<_CharT,_Alloc>\n operator+ (const rope<_CharT,_Alloc>& __left,\n            const rope<_CharT,_Alloc>& __right)\n {\n-#   ifdef __STL_USE_STD_ALLOCATORS\n-        __stl_assert(__left.get_allocator() == __right.get_allocator());\n-#   endif\n+    __stl_assert(__left.get_allocator() == __right.get_allocator());\n     return rope<_CharT,_Alloc>(\n       rope<_CharT,_Alloc>::_S_concat(__left._M_tree_ptr, __right._M_tree_ptr));\n     // Inlining this should make it possible to keep __left and\n@@ -2604,8 +2371,6 @@ inline bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n         return (__x._M_pos == __y._M_pos && __x._M_root == __y._M_root);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _CharT, class _Alloc>\n inline bool\n operator!= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {\n@@ -2636,18 +2401,11 @@ inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n   return !(__x == __y);\n }\n \n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits, class _Alloc>\n-  basic_ostream<_CharT, _Traits>& operator<<\n+template<class _CharT, class _Traits, class _Alloc>\n+basic_ostream<_CharT, _Traits>& operator<<\n                                         (basic_ostream<_CharT, _Traits>& __o,\n                                          const rope<_CharT, _Alloc>& __r);\n-#else\n-  template<class _CharT, class _Alloc>\n-  ostream& operator<< (ostream& __o, const rope<_CharT, _Alloc>& __r);\n-#endif\n-        \n+\n typedef rope<char> crope;\n typedef rope<wchar_t> wrope;\n \n@@ -2661,22 +2419,13 @@ inline wrope::reference __mutable_reference_at(wrope& __c, size_t __i)\n     return __c.mutable_reference_at(__i);\n }\n \n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n template <class _CharT, class _Alloc>\n inline void swap(rope<_CharT,_Alloc>& __x, rope<_CharT,_Alloc>& __y) {\n   __x.swap(__y);\n }\n \n-#else\n-\n-inline void swap(crope __x, crope __y) { __x.swap(__y); }\n-inline void swap(wrope __x, wrope __y) { __x.swap(__y); }\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n // Hash functions should probably be revisited later:\n-__STL_TEMPLATE_NULL struct hash<crope>\n+template<> struct hash<crope>\n {\n   size_t operator()(const crope& __str) const\n   {\n@@ -2688,7 +2437,7 @@ __STL_TEMPLATE_NULL struct hash<crope>\n };\n \n \n-__STL_TEMPLATE_NULL struct hash<wrope>\n+template<> struct hash<wrope>\n {\n   size_t operator()(const wrope& __str) const\n   {\n@@ -2699,11 +2448,7 @@ __STL_TEMPLATE_NULL struct hash<wrope>\n   }\n };\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#endif\n-\n-__STL_END_NAMESPACE\n+} // namespace std\n \n # include <ext/ropeimpl.h>\n "}, {"sha": "944414f0c0bf5af7cf021e7e46bccae3dd590817", "filename": "libstdc++-v3/src/complex_io.cc", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fcomplex_io.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fcomplex_io.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcomplex_io.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -147,13 +147,5 @@ namespace std\n     operator<<(basic_ostream<wchar_t, char_traits<wchar_t> >&,\n                const complex<long double>&);\n #endif //_GLIBCPP_USE_WCHAR_T\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n+} // namespace std\n "}, {"sha": "8d78a636710aa6e3cc5083f1892f444a53500bca", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -351,14 +351,3 @@ namespace std\n \n }  // namespace std\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "554fab3f258e910cadcb8c6ad7b72874576b19b6", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -42,7 +42,8 @@\n #include <bits/std_istream.h>\n #include <bits/std_ostream.h>\n \n-namespace std {\n+namespace std\n+{\n \n   typedef ostreambuf_iterator<char, char_traits<char> > obuf_iterator;\n   typedef istreambuf_iterator<char, char_traits<char> > ibuf_iterator;\n@@ -303,5 +304,5 @@ namespace std {\n     fill(__normal_iterator<locale::facet**, vector<locale::facet*> >,\n          __normal_iterator<locale::facet**, vector<locale::facet*> >,\n          locale::facet* const&);\n-} \n+} // namespace std\n "}, {"sha": "3b430904d33a4cd8d12374ab7d736a85d0a2a19f", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1234,8 +1234,3 @@ namespace std\n #endif //  _GLIBCPP_USE_WCHAR_T\n } // namespace std\n \n-\n-\n-\n-\n-"}, {"sha": "e4bc18fefe600a636ea93f39bc14d61f205bc54c", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -31,7 +31,8 @@\n #include <bits/std_vector.h>\n #include <bits/std_stdexcept.h>\n \n-namespace std {\n+namespace std\n+{\n   locale::_Impl::\n   ~_Impl() throw()\n   {\n@@ -196,8 +197,5 @@ namespace std {\n \t  }\n       }\n   }\n-}\n-\n-\n-\n+} // namespace std\n "}, {"sha": "50d11abb44050a85956725cf647f855cbb6c924a", "filename": "libstdc++-v3/src/misc-inst.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -54,7 +54,8 @@\n #include <bits/ostream.tcc>\n #endif\n \n-namespace std {\n+namespace std\n+{\n \n   //\n   // streambuf"}, {"sha": "32ebd265f89fb6e09c75f746a15ac890864a7bb4", "filename": "libstdc++-v3/src/stdexcept.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -76,6 +76,3 @@ namespace std\n   : runtime_error(__arg) { }\n } // namespace std\n \n-\n-\n-"}, {"sha": "29337c02bbfd1a02df438ebd7ef3264a12c25243", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -35,7 +35,8 @@\n #include <bits/stl_alloc.h>\n #include <bits/std_vector.h>\n \n-namespace std {\n+namespace std\n+{\n \n   template class __malloc_alloc_template<0>;\n "}, {"sha": "10d23b0259ceeeab8eabf6983f1e7086641180d6", "filename": "libstdc++-v3/src/strstream.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -24,7 +24,8 @@\n #include <string.h>\n #include <limits.h>\n \n-__STL_BEGIN_NAMESPACE\n+namespace std\n+{\n \n // strstreambuf constructor, destructor.\n \n@@ -420,7 +421,7 @@ char* strstream::str()\n   return _M_buf.str();\n }\n \n-__STL_END_NAMESPACE\n+} // namespace std\n \n // Local Variables:\n // mode:C++"}, {"sha": "9e51ca57835fb3e13dbf901558bbf4b0d9199e34", "filename": "libstdc++-v3/src/valarray-inst.cc", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d53d7f6e612a61bfabc102466ec4203ac36a338e/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc?ref=d53d7f6e612a61bfabc102466ec4203ac36a338e", "patch": "@@ -1,3 +1,36 @@\n+// Explicit instantiation file.\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882:\n+//\n+\n #include <bits/std_valarray.h>\n \n namespace std\n@@ -81,4 +114,5 @@ namespace std\n         _M_index(__l.size() == 0 ? 0 : __valarray_product(__l))\n   { __gslice_to_index(__o, __l, __s, _M_index); }\n   \n-}\n+} // namespace std\n+"}]}