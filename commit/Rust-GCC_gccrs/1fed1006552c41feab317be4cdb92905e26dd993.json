{"sha": "1fed1006552c41feab317be4cdb92905e26dd993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlZDEwMDY1NTJjNDFmZWFiMzE3YmU0Y2RiOTI5MDVlMjZkZDk5Mw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-08-31T07:04:25Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-08-31T07:04:25Z"}, "message": "re PR middle-end/43513 (The stack pointer is adjusted twice)\n\n2011-08-31  Tom de Vries  <tom@codesourcery.com>\n\n\tPR middle-end/43513\n\t* Makefile.in (tree-ssa-ccp.o): Add $(PARAMS_H) to rule.\n\t* tree-ssa-ccp.c (params.h): Include.\n\t(fold_builtin_alloca_for_var): New function.\n\t(ccp_fold_stmt): Use fold_builtin_alloca_for_var.\n\nFrom-SVN: r178353", "tree": {"sha": "cee8103066687204e6d4ec106ad8f2895852f9eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cee8103066687204e6d4ec106ad8f2895852f9eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fed1006552c41feab317be4cdb92905e26dd993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fed1006552c41feab317be4cdb92905e26dd993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fed1006552c41feab317be4cdb92905e26dd993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fed1006552c41feab317be4cdb92905e26dd993/comments", "author": null, "committer": null, "parents": [{"sha": "57f6fb2e769f9179226be37a903d2318361ea5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f6fb2e769f9179226be37a903d2318361ea5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57f6fb2e769f9179226be37a903d2318361ea5bf"}], "stats": {"total": 70, "additions": 69, "deletions": 1}, "files": [{"sha": "ad45eb4c96e840f668cd40cfa72b3337d79cc595", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fed1006552c41feab317be4cdb92905e26dd993", "patch": "@@ -1,3 +1,11 @@\n+2011-08-31  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR middle-end/43513\n+\t* Makefile.in (tree-ssa-ccp.o): Add $(PARAMS_H) to rule.\n+\t* tree-ssa-ccp.c (params.h): Include.\n+\t(fold_builtin_alloca_for_var): New function.\n+\t(ccp_fold_stmt): Use fold_builtin_alloca_for_var.\n+\n 2011-08-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_valid_target_attribute_inner_p):"}, {"sha": "d5caba6c7f70bfb33c601f25932bc2a957157815", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1fed1006552c41feab317be4cdb92905e26dd993", "patch": "@@ -3154,7 +3154,7 @@ tree-call-cdce.o : tree-call-cdce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n-   $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h \\\n+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h  $(PARAMS_H) \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(DIAGNOSTIC_CORE_H) \\\n    $(DBGCNT_H) tree-pretty-print.h gimple-pretty-print.h gimple-fold.h\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\"}, {"sha": "007e17dd8b6882210b53c972a1a11c053391a84d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed1006552c41feab317be4cdb92905e26dd993/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1fed1006552c41feab317be4cdb92905e26dd993", "patch": "@@ -133,6 +133,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"dbgcnt.h\"\n #include \"gimple-fold.h\"\n+#include \"params.h\"\n \n \n /* Possible lattice values.  */\n@@ -1684,6 +1685,51 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n+/* Detects a vla-related alloca with a constant argument.  Declares fixed-size\n+   array and return the address, if found, otherwise returns NULL_TREE.  */\n+\n+static tree\n+fold_builtin_alloca_for_var (gimple stmt)\n+{\n+  unsigned HOST_WIDE_INT size, threshold, n_elem;\n+  tree lhs, arg, block, var, elem_type, array_type;\n+  unsigned int align;\n+\n+  /* Get lhs.  */\n+  lhs = gimple_call_lhs (stmt);\n+  if (lhs == NULL_TREE)\n+    return NULL_TREE;\n+\n+  /* Detect constant argument.  */\n+  arg = get_constant_value (gimple_call_arg (stmt, 0));\n+  if (arg == NULL_TREE || TREE_CODE (arg) != INTEGER_CST\n+      || !host_integerp (arg, 1))\n+    return NULL_TREE;\n+  size = TREE_INT_CST_LOW (arg);\n+\n+  /* Heuristic: don't fold large vlas.  */\n+  threshold = (unsigned HOST_WIDE_INT)PARAM_VALUE (PARAM_LARGE_STACK_FRAME);\n+  /* In case a vla is declared at function scope, it has the same lifetime as a\n+     declared array, so we allow a larger size.  */\n+  block = gimple_block (stmt);\n+  if (!(cfun->after_inlining\n+        && TREE_CODE (BLOCK_SUPERCONTEXT (block)) == FUNCTION_DECL))\n+    threshold /= 10;\n+  if (size > threshold)\n+    return NULL_TREE;\n+\n+  /* Declare array.  */\n+  elem_type = build_nonstandard_integer_type (BITS_PER_UNIT, 1);\n+  n_elem = size * 8 / BITS_PER_UNIT;\n+  align = MIN (size * 8, BIGGEST_ALIGNMENT);\n+  array_type = build_array_type_nelts (elem_type, n_elem);\n+  var = create_tmp_var (array_type, NULL);\n+  DECL_ALIGN (var) = align;\n+\n+  /* Fold alloca to the address of the array.  */\n+  return fold_convert (TREE_TYPE (lhs), build_fold_addr_expr (var));\n+}\n+\n /* Fold the stmt at *GSI with CCP specific information that propagating\n    and regular folding does not catch.  */\n \n@@ -1752,6 +1798,20 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \tif (gimple_call_internal_p (stmt))\n \t  return false;\n \n+        /* The heuristic of fold_builtin_alloca_for_var differs before and after\n+           inlining, so we don't require the arg to be changed into a constant\n+           for folding, but just to be constant.  */\n+        if (gimple_call_alloca_for_var_p (stmt))\n+          {\n+            tree new_rhs = fold_builtin_alloca_for_var (stmt);\n+            bool res;\n+            if (new_rhs == NULL_TREE)\n+              return false;\n+            res = update_call_from_tree (gsi, new_rhs);\n+            gcc_assert (res);\n+            return true;\n+          }\n+\n \t/* Propagate into the call arguments.  Compared to replace_uses_in\n \t   this can use the argument slot types for type verification\n \t   instead of the current argument type.  We also can safely"}]}