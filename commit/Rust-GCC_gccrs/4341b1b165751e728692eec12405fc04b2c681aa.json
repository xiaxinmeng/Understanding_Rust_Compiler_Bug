{"sha": "4341b1b165751e728692eec12405fc04b2c681aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM0MWIxYjE2NTc1MWU3Mjg2OTJlZWMxMjQwNWZjMDRiMmM2ODFhYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-08-13T08:04:52Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-08-13T08:04:52Z"}, "message": "Introduce EAF_NOREAD and cleanup EAF_UNUSED + ipa-modref\n\nthis patch add EAF_NOREAD (as disucssed on IRC already) and fixes meaning\nof EAF_UNUSED to be really unused and not \"does not escape, is not clobbered,\nread or returned\" since we have separate flags for each of the properties\nnow.\n\nSince number of flags has grown I refactored the code a bit to avoid\nrepeated uses of complex flag combinations and also simplified the logic of\nmerging.\n\nMerging is bit tricky since we have flags that implies other flags\n(like NOESCAPE implies NODIRECTESCAPE) but code that sets only NOESCAPE.\nPerhaps it would make sense to update fnspecs to always set flag along with\nall the implications, but for now I am handlingit in merge.\n\nI made only trivial update to tree-ssa-structalias to handle EAF_NORETURN in\nnormal function handling, but not in pure functions.  The problem is that the\nway constraints are generated for pure functions makes this difficult.\nI think logical step is to track whether function reads/stores global memory\nand rewrite the constraint generation so we can handle normal, pure and const\nin unified manner.\n\nBootstrapped/regtested x86_64-linux, plan to commit it after furhter testing.\n\nThe patch improves alias oracle stats for cc1plus somewhat.\n\nFrom:\n\nAlias oracle query stats:\n  refs_may_alias_p: 72380497 disambiguations, 82649832 queries\n  ref_maybe_used_by_call_p: 495184 disambiguations, 73366950 queries\n  call_may_clobber_ref_p: 259312 disambiguations, 263253 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 38006 queries\n  nonoverlapping_refs_since_match_p: 21157 disambiguations, 65698 must overlaps, 87756 queries\n  aliasing_component_refs_p: 63141 disambiguations, 2164695 queries\n  TBAA oracle: 25975753 disambiguations 61449632 queries\n               12138220 are in alias set 0\n               11316663 queries asked about the same object\n               144 queries asked about the same alias set\n               0 access volatile\n               10472885 are dependent in the DAG\n               1545967 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 23857 disambiguations, 754515 queries\n  modref clobber: 1392162 disambiguations, 17753512 queries\n  3450241 tbaa queries (0.194341 per modref query)\n  534816 base compares (0.030125 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 12394915 disambiguations, 20235925 queries\n  pt_solutions_intersect: 1365299 disambiguations, 14638068 queries\n\nTo:\n\nAlias oracle query stats:\n  refs_may_alias_p: 72629640 disambiguations, 82903333 queries\n  ref_maybe_used_by_call_p: 502474 disambiguations, 73612186 queries\n  call_may_clobber_ref_p: 261806 disambiguations, 265659 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 38007 queries\n  nonoverlapping_refs_since_match_p: 21139 disambiguations, 65772 must overlaps, 87816 queries\n  aliasing_component_refs_p: 63144 disambiguations, 2164330 queries\n  TBAA oracle: 26059018 disambiguations 61571714 queries\n               12158033 are in alias set 0\n               11326115 queries asked about the same object\n               144 queries asked about the same alias set\n               0 access volatile\n               10484493 are dependent in the DAG\n               1543911 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 24008 disambiguations, 712712 queries\n  modref clobber: 1395917 disambiguations, 17163694 queries\n  3465657 tbaa queries (0.201918 per modref query)\n  537591 base compares (0.031321 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 12468934 disambiguations, 20295402 queries\n  pt_solutions_intersect: 1391917 disambiguations, 14665265 queries\n\nI think it is mostly due to better heandling of EAF_NODIRECTESCAPE.\n\nHonza\n\ngcc/ChangeLog:\n\n2021-08-12  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (dump_eaf_flags): Dump EAF_NOREAD.\n\t(implicit_const_eaf_flags, implicit_pure_eaf_flags,\n\t ignore_stores_eaf_flags): New constants.\n\t(remove_useless_eaf_flags): New function.\n\t(eaf_flags_useful_p): Use it.\n\t(deref_flags): Add EAF_NOT_RETURNED if flag is unused;\n\thandle EAF_NOREAD.\n\t(modref_lattice::init): Add EAF_NOREAD.\n\t(modref_lattice::add_escape_point): Do not reacord escape point if\n\tresult is unused.\n\t(modref_lattice::merge): EAF_NOESCAPE implies EAF_NODIRECTESCAPE;\n\tuse remove_useless_eaf_flags.\n\t(modref_lattice::merge_deref): Use ignore_stores_eaf_flags.\n\t(modref_lattice::merge_direct_load): Add EAF_NOREAD\n\t(analyze_ssa_name_flags): Fix handling EAF_NOT_RETURNED\n\t(analyze_parms): Use remove_useless_eaf_flags.\n\t(ipa_merge_modref_summary_after_inlining): Use ignore_stores_eaf_flags.\n\t(modref_merge_call_site_flags): Add caller and ecf_flags parameter;\n\tuse remove_useless_eaf_flags.\n\t(modref_propagate_flags_in_scc): Update.\n\t* ipa-modref.h: Turn eaf_flags_t back to char.\n\t* tree-core.h (EAF_NOT_RETURNED): Fix.\n\t(EAF_NOREAD): New constant\n\t* tree-ssa-alias.c: (ref_maybe_used_by_call_p_1): Check for\n\tEAF_NOREAD.\n\t* tree-ssa-structalias.c (handle_rhs_call): Handle new flags.\n\t(handle_pure_call): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n2021-08-12  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/tree-ssa/modref-6.c: Update.", "tree": {"sha": "77e996515a13ad543ef2884b4da100adc1f39893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77e996515a13ad543ef2884b4da100adc1f39893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4341b1b165751e728692eec12405fc04b2c681aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4341b1b165751e728692eec12405fc04b2c681aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4341b1b165751e728692eec12405fc04b2c681aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4341b1b165751e728692eec12405fc04b2c681aa/comments", "author": null, "committer": null, "parents": [{"sha": "e37ddb91a83335e58f16ef9ce9080668ad6ad47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37ddb91a83335e58f16ef9ce9080668ad6ad47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37ddb91a83335e58f16ef9ce9080668ad6ad47f"}], "stats": {"total": 194, "additions": 131, "deletions": 63}, "files": [{"sha": "fafd804d4bae453198bd9f5f38916ef3aeb50d3a", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 113, "deletions": 56, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -158,6 +158,8 @@ dump_eaf_flags (FILE *out, int flags, bool newline = true)\n     fprintf (out, \" unused\");\n   if (flags & EAF_NOT_RETURNED)\n     fprintf (out, \" not_returned\");\n+  if (flags & EAF_NOREAD)\n+    fprintf (out, \" noread\");\n   if (newline)\n   fprintf (out, \"\\n\");\n }\n@@ -278,27 +280,46 @@ modref_summary::~modref_summary ()\n     ggc_delete (stores);\n }\n \n+/* All flags that are implied by the ECF_CONST functions.  */\n+const int implicit_const_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t     | EAF_NODIRECTESCAPE | EAF_NOREAD;\n+/* All flags that are implied by the ECF_PURE function.  */\n+const int implicit_pure_eaf_flags = EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t    | EAF_NODIRECTESCAPE;\n+/* All flags implied when we know we can ignore stores (i.e. when handling\n+   call to noreturn).  */\n+const int ignore_stores_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t    | EAF_NODIRECTESCAPE;\n+\n+/* Remove all flags from EAF_FLAGS that are implied by ECF_FLAGS and not\n+   useful to track.  If returns_void is true moreover clear\n+   EAF_NOT_RETURNED.  */\n+static int\n+remove_useless_eaf_flags (int eaf_flags, int ecf_flags, bool returns_void)\n+{\n+  if (ecf_flags & ECF_NOVOPS)\n+    return 0;\n+  if (ecf_flags & ECF_CONST)\n+    eaf_flags &= ~implicit_const_eaf_flags;\n+  else if (ecf_flags & ECF_PURE)\n+    eaf_flags &= ~implicit_pure_eaf_flags;\n+  else if ((ecf_flags & ECF_NORETURN) || returns_void)\n+    eaf_flags &= ~EAF_NOT_RETURNED;\n+  /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n+     in tree-ssa-alias.c).  Give up earlier.  */\n+  if ((eaf_flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n+    return 0;\n+  return eaf_flags;\n+}\n+\n /* Return true if FLAGS holds some useful information.  */\n \n static bool\n eaf_flags_useful_p (vec <eaf_flags_t> &flags, int ecf_flags)\n {\n   for (unsigned i = 0; i < flags.length (); i++)\n-    if (ecf_flags & ECF_CONST)\n-      {\n-\tif (flags[i] & (EAF_UNUSED | EAF_NOT_RETURNED))\n-\t  return true;\n-      }\n-    else if (ecf_flags & ECF_PURE)\n-      {\n-\tif (flags[i] & (EAF_UNUSED | EAF_DIRECT | EAF_NOT_RETURNED))\n-\t  return true;\n-      }\n-    else\n-      {\n-\tif (flags[i])\n-\t  return true;\n-      }\n+    if (remove_useless_eaf_flags (flags[i], ecf_flags, false))\n+      return true;\n   return false;\n }\n \n@@ -1320,17 +1341,35 @@ static int\n deref_flags (int flags, bool ignore_stores)\n {\n   int ret = EAF_NODIRECTESCAPE;\n+  /* If argument is unused just account for\n+     the read involved in dereference.  */\n   if (flags & EAF_UNUSED)\n-    ret |= EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE;\n+    ret |= EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOT_RETURNED;\n   else\n     {\n       if ((flags & EAF_NOCLOBBER) || ignore_stores)\n \tret |= EAF_NOCLOBBER;\n       if ((flags & EAF_NOESCAPE) || ignore_stores)\n \tret |= EAF_NOESCAPE;\n+      /* If the value dereferenced is not used for another load or store\n+\t we can still consider ARG as used only directly.\n+\n+\t Consider\n+\n+\t int\n+\t test (int *a)\n+\t   {\n+\t     return *a!=0;\n+\t   }\n+\n+\t*/\n+      if ((flags & (EAF_NOREAD | EAF_NOT_RETURNED | EAF_NOESCAPE | EAF_DIRECT))\n+\t  == (EAF_NOREAD | EAF_NOT_RETURNED | EAF_NOESCAPE | EAF_DIRECT)\n+\t  && ((flags & EAF_NOCLOBBER) || ignore_stores))\n+\tret |= EAF_DIRECT;\n+      if (flags & EAF_NOT_RETURNED)\n+\tret |= EAF_NOT_RETURNED;\n     }\n-  if (flags & EAF_NOT_RETURNED)\n-    ret |= EAF_NOT_RETURNED;\n   return ret;\n }\n \n@@ -1355,7 +1394,7 @@ class modref_lattice\n {\n public:\n   /* EAF flags of the SSA name.  */\n-  int flags;\n+  eaf_flags_t flags;\n   /* DFS bookkkeeping: we don't do real dataflow yet.  */\n   bool known;\n   bool open;\n@@ -1379,8 +1418,12 @@ class modref_lattice\n void\n modref_lattice::init ()\n {\n-  flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n-\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED;\n+  /* All flags we track.  */\n+  int f = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n+\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED | EAF_NOREAD;\n+  flags = f;\n+  /* Check that eaf_flags_t is wide enough to hold all flags.  */\n+  gcc_checking_assert (f == flags);\n   open = true;\n   known = false;\n }\n@@ -1424,8 +1467,8 @@ modref_lattice::add_escape_point (gcall *call, int arg, int min_flags,\n   unsigned int i;\n \n   /* If we already determined flags to be bad enough,\n-   * we do not need to record.  */\n-  if ((flags & min_flags) == flags)\n+     we do not need to record.  */\n+  if ((flags & min_flags) == flags || (min_flags & EAF_UNUSED))\n     return false;\n \n   FOR_EACH_VEC_ELT (escape_points, i, ep)\n@@ -1455,13 +1498,18 @@ modref_lattice::merge (int f)\n {\n   if (f & EAF_UNUSED)\n     return false;\n+  /* Noescape implies that value also does not escape directly.\n+     Fnspec machinery does set both so compensate for this.  */\n+  if (f & EAF_NOESCAPE)\n+    f |= EAF_NODIRECTESCAPE;\n   if ((flags & f) != flags)\n     {\n       flags &= f;\n-      /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n-\t in tree-ssa-alias.c).  Give up earlier.  */\n-      if ((flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n-\tflags = 0;\n+      /* Prune obvoiusly useless flags;\n+\t We do not have ECF_FLAGS handy which is not big problem since\n+\t we will do final flags cleanup before producing summary.\n+\t Merging should be fast so it can work well with dataflow.  */\n+      flags = remove_useless_eaf_flags (flags, 0, false);\n       if (!flags)\n \tescape_points.release ();\n       return true;\n@@ -1509,7 +1557,7 @@ modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n       if (with.escape_points[i].direct)\n \tmin_flags = deref_flags (min_flags, ignore_stores);\n       else if (ignore_stores)\n-\tmin_flags |= EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\tmin_flags |= ignore_stores_eaf_flags;\n       changed |= add_escape_point (with.escape_points[i].call,\n \t\t\t\t   with.escape_points[i].arg,\n \t\t\t\t   min_flags,\n@@ -1523,7 +1571,7 @@ modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n bool\n modref_lattice::merge_direct_load ()\n {\n-  return merge (~EAF_UNUSED);\n+  return merge (~(EAF_UNUSED | EAF_NOREAD));\n }\n \n /* Merge in flags for direct store.  */\n@@ -1632,6 +1680,9 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t  fprintf (dump_file, \"%*s  Analyzing stmt: \", depth * 4, \"\");\n \t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n+      /* If we see a direct non-debug use, clear unused bit.\n+\t All dereferneces should be accounted below using deref_flags.  */\n+      lattice[index].merge (~EAF_UNUSED);\n \n       /* Gimple return may load the return value.\n \t Returning name counts as an use by tree-ssa-structalias.c  */\n@@ -1642,7 +1693,7 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n \t    {\n \t      lattice[index].merge_direct_load ();\n-\t      lattice[index].merge (~EAF_NOT_RETURNED);\n+\t      lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED));\n \t    }\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n@@ -1697,8 +1748,7 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t\tint call_flags = gimple_call_arg_flags (call, i)\n \t\t\t\t\t | EAF_NOT_RETURNED;\n \t\t\tif (ignore_stores)\n-\t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t\t| EAF_NODIRECTESCAPE;\n+\t\t\t  call_flags |= ignore_stores_eaf_flags;\n \n \t\t\tif (!record_ipa)\n \t\t\t  lattice[index].merge (call_flags);\n@@ -1890,14 +1940,12 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n       analyze_ssa_name_flags (name, lattice, 0, ipa);\n       int flags = lattice[SSA_NAME_VERSION (name)].flags;\n \n-      /* For pure functions we have implicit NOCLOBBER\n-\t and NOESCAPE.  */\n-      if (ecf_flags & ECF_PURE)\n-\tflags &= (EAF_UNUSED | EAF_DIRECT | EAF_NOT_RETURNED);\n-      /* Only useful flags for const function are EAF_NOT_RETURNED and\n-\t EAF_UNUSED.  */\n-      if (ecf_flags & ECF_CONST)\n-\tflags &= (EAF_UNUSED | EAF_NOT_RETURNED);\n+      /* Eliminate useless flags so we do not end up storing unnecessary\n+\t summaries.  */\n+\n+      flags = remove_useless_eaf_flags\n+\t\t (flags, ecf_flags,\n+\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n \n       if (flags)\n \t{\n@@ -3176,7 +3224,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n \t    else if (ignore_stores)\n-\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\t      flags |= ignore_stores_eaf_flags;\n \t    flags |= ee->min_flags;\n \t    to_info->arg_flags[ee->parm_index] &= flags;\n \t    if (to_info->arg_flags[ee->parm_index])\n@@ -3190,7 +3238,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n \t    else if (ignore_stores)\n-\t      flags |= EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\t      flags |= ignore_stores_eaf_flags;\n \t    flags |= ee->min_flags;\n \t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n \t    if (to_info_lto->arg_flags[ee->parm_index])\n@@ -3673,11 +3721,13 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t\t\t      modref_summary_lto *cur_summary_lto,\n \t\t\t      modref_summary *summary,\n \t\t\t      modref_summary_lto *summary_lto,\n-\t\t\t      bool ignore_stores)\n+\t\t\t      tree caller,\n+\t\t\t      int ecf_flags)\n {\n   escape_entry *ee;\n   unsigned int i;\n   bool changed = false;\n+  bool ignore_stores = ignore_stores_p (caller, ecf_flags);\n \n   /* If we have no useful info to propagate.  */\n   if ((!cur_summary || !cur_summary->arg_flags.length ())\n@@ -3701,21 +3751,27 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t}\n       else if (ignore_stores)\n \t{\n-\t  flags |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n-\t  flags_lto |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n+\t  flags |= ignore_stores_eaf_flags;\n+\t  flags_lto |= ignore_stores_eaf_flags;\n \t}\n       /* Returning the value is already accounted to at local propagation.  */\n       flags |= ee->min_flags | EAF_NOT_RETURNED;\n       flags_lto |= ee->min_flags | EAF_NOT_RETURNED;\n+      /* Noescape implies that value also does not escape directly.\n+\t Fnspec machinery does set both so compensate for this.  */\n+      if (flags & EAF_NOESCAPE)\n+\tflags |= EAF_NODIRECTESCAPE;\n+      if (flags_lto & EAF_NOESCAPE)\n+\tflags_lto |= EAF_NODIRECTESCAPE;\n       if (!(flags & EAF_UNUSED)\n \t  && cur_summary && ee->parm_index < cur_summary->arg_flags.length ())\n \t{\n \t  int f = cur_summary->arg_flags[ee->parm_index];\n \t  if ((f & flags) != f)\n \t    {\n-\t      f = f & flags;\n-\t      if ((f & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n-\t\tf = 0;\n+\t      f = remove_useless_eaf_flags\n+\t\t\t (f & flags, ecf_flags,\n+\t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n \t      cur_summary->arg_flags[ee->parm_index] = f;\n \t      changed = true;\n \t    }\n@@ -3727,9 +3783,9 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  int f = cur_summary_lto->arg_flags[ee->parm_index];\n \t  if ((f & flags_lto) != f)\n \t    {\n-\t      f = f & flags;\n-\t      if ((f & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n-\t\tf = 0;\n+\t      f = remove_useless_eaf_flags\n+\t\t\t (f & flags_lto, ecf_flags,\n+\t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n \t      cur_summary_lto->arg_flags[ee->parm_index] = f;\n \t      changed = true;\n \t    }\n@@ -3780,8 +3836,8 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \n \t      changed |= modref_merge_call_site_flags\n \t\t\t\t(sum, cur_summary, cur_summary_lto,\n-\t\t\t\t NULL, NULL, ignore_stores_p (node->decl,\n-\t\t\t\t e->indirect_info->ecf_flags));\n+\t\t\t\t NULL, NULL,\n+\t\t\t\t node->decl, e->indirect_info->ecf_flags);\n \t    }\n \n \t  if (!cur_summary && !cur_summary_lto)\n@@ -3790,12 +3846,13 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t  for (cgraph_edge *callee_edge = cur->callees; callee_edge;\n \t       callee_edge = callee_edge->next_callee)\n \t    {\n-\t      int flags = flags_from_decl_or_type (callee_edge->callee->decl);\n+\t      int ecf_flags = flags_from_decl_or_type\n+\t\t\t\t (callee_edge->callee->decl);\n \t      modref_summary *callee_summary = NULL;\n \t      modref_summary_lto *callee_summary_lto = NULL;\n \t      struct cgraph_node *callee;\n \n-\t      if (flags & (ECF_CONST | ECF_NOVOPS)\n+\t      if (ecf_flags & (ECF_CONST | ECF_NOVOPS)\n \t\t  || !callee_edge->inline_failed)\n \t\tcontinue;\n \t      /* Get the callee and its summary.  */\n@@ -3832,7 +3889,7 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t      changed |= modref_merge_call_site_flags\n \t\t\t\t(sum, cur_summary, cur_summary_lto,\n \t\t\t\t callee_summary, callee_summary_lto,\n-\t\t\t\t ignore_stores_p (node->decl, flags));\n+\t\t\t\t node->decl, ecf_flags);\n \t      if (dump_file && changed)\n \t\t{\n \t\t  if (cur_summary)"}, {"sha": "540fdea8efac647157d0930326d7c04950dd751a", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define IPA_MODREF_H\n \n typedef modref_tree <alias_set_type> modref_records;\n-typedef unsigned short eaf_flags_t;\n+typedef unsigned char eaf_flags_t;\n \n /* Single function summary.  */\n "}, {"sha": "2d97a4903ff03597f7e8659943c4f5e3aef10d74", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -32,6 +32,6 @@ int test2()\n /* Flags for pure call.  */\n /* { dg-final { scan-tree-dump \"parm 0 flags: direct not_returned\" \"modref1\"  } } */\n /* Flags for const call.  */\n-/* { dg-final { scan-tree-dump \"parm 0 flags: unused not_returned\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: not_returned\" \"modref1\"  } } */\n /* Overall we want to make \"int a\" non escaping.  */\n /* { dg-final { scan-tree-dump \"return 42\" \"optimized\"  } } */"}, {"sha": "239a3a3f80b971bf1450a038aa03ecca01d189e0", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -115,7 +115,10 @@ struct die_struct;\n #define EAF_NODIRECTESCAPE\t(1 << 4)\n \n /* Nonzero if the argument does not escape to return value.  */\n-#define EAF_NOT_RETURNED\t(1 << 8)\n+#define EAF_NOT_RETURNED\t(1 << 5)\n+\n+/* Nonzero if the argument is not read.  */\n+#define EAF_NOREAD\t\t(1 << 6)\n \n /* Call return flags.  */\n /* Mask for the argument number that is returned.  Lower two bits of"}, {"sha": "ce667ff32b9eac930698fa667e51e887ee6d1215", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -2870,7 +2870,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       tree op = gimple_call_arg (call, i);\n       int flags = gimple_call_arg_flags (call, i);\n \n-      if (flags & EAF_UNUSED)\n+      if (flags & (EAF_UNUSED | EAF_NOREAD))\n \tcontinue;\n \n       if (TREE_CODE (op) == WITH_SIZE_EXPR)"}, {"sha": "fb0e429970325b58901ccc260db040f7d36be4ff", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4341b1b165751e728692eec12405fc04b2c681aa/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=4341b1b165751e728692eec12405fc04b2c681aa", "patch": "@@ -4063,8 +4063,14 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n       tree arg = gimple_call_arg (stmt, i);\n       int flags = gimple_call_arg_flags (stmt, i);\n \n-      /* If the argument is not used we can ignore it.  */\n-      if (flags & EAF_UNUSED)\n+      /* If the argument is not used we can ignore it.\n+\t Similarly argument is invisile for us if it not clobbered, does not\n+\t escape, is not read and can not be returned.  */\n+      if ((flags & EAF_UNUSED)\n+\t  || ((flags & (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n+\t\t\t| EAF_NOT_RETURNED))\n+\t      == (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n+\t\t  | EAF_NOT_RETURNED)))\n \tcontinue;\n \n       /* As we compute ESCAPED context-insensitive we do not gain\n@@ -4316,7 +4322,9 @@ handle_pure_call (gcall *stmt, vec<ce_s> *results)\n       int flags = gimple_call_arg_flags (stmt, i);\n \n       /* If the argument is not used we can ignore it.  */\n-      if (flags & EAF_UNUSED)\n+      if ((flags & EAF_UNUSED)\n+\t  || (flags & (EAF_NOT_RETURNED | EAF_NOREAD))\n+\t     == (EAF_NOT_RETURNED | EAF_NOREAD))\n \tcontinue;\n       if (!uses)\n \t{"}]}