{"sha": "37aba8501fbdfcd17b1d7852e45c4cced24c6216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhYmE4NTAxZmJkZmNkMTdiMWQ3ODUyZTQ1YzRjY2VkMjRjNjIxNg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-05-18T02:24:35Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-05-18T02:24:35Z"}, "message": "(i960_output_ldconst): New code for XFmode.\n\nAlso, move SFmode code to immediately after DFmode code.\n(S_MODES, D_MODES): Handle XFmode.\n(XF_MODES): Was TF_MODES, handle XFmode instead of TFmode.\n(hard_regno_mode_ok): Replace TFmode with XFmode.\n(i960_output_long_double): New function.\n\nFrom-SVN: r9738", "tree": {"sha": "1ef4a8a21160b152bf24a5e05d4ac52fb254e15e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ef4a8a21160b152bf24a5e05d4ac52fb254e15e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37aba8501fbdfcd17b1d7852e45c4cced24c6216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37aba8501fbdfcd17b1d7852e45c4cced24c6216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37aba8501fbdfcd17b1d7852e45c4cced24c6216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37aba8501fbdfcd17b1d7852e45c4cced24c6216/comments", "author": null, "committer": null, "parents": [{"sha": "c19a80671bf41d73c9f35212b845d8c55681c903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19a80671bf41d73c9f35212b845d8c55681c903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19a80671bf41d73c9f35212b845d8c55681c903"}], "stats": {"total": 83, "additions": 62, "deletions": 21}, "files": [{"sha": "273e10fb68510f394a0b1c47196e42ea33ff03ae", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37aba8501fbdfcd17b1d7852e45c4cced24c6216/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37aba8501fbdfcd17b1d7852e45c4cced24c6216/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=37aba8501fbdfcd17b1d7852e45c4cced24c6216", "patch": "@@ -570,8 +570,8 @@ emit_move_sequence (operands, mode)\n   return 0;\n }\n \f\n-/* Emit insns to load a constant.  Uses several strategies to try to use\n-   as few insns as possible.  */\n+/* Emit insns to load a constant to non-floating point registers.\n+   Uses several strategies to try to use as few insns as possible.  */\n \n char *\n i960_output_ldconst (dst, src)\n@@ -593,6 +593,30 @@ i960_output_ldconst (dst, src)\n       output_asm_insn (\"ldconst\t%1,%0\", operands);\n       return \"\";\n     }\n+  else if (mode == XFmode)\n+    {\n+      REAL_VALUE_TYPE d;\n+      long value_long[3];\n+      int i;\n+\n+      if (fp_literal_zero (src, XFmode))\n+\treturn \"movt\t0,%0\";\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (d, value_long);\n+\n+      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n+\n+      for (i = 0; i < 3; i++)\n+\t{\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (dst) + i);\n+\t  operands[1] = GEN_INT (value_long[i]);\n+\t  output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n+\t\t\t   operands);\n+\t}\n+\n+      return \"\"; \n+   }\n   else if (mode == DFmode)\n     {\n       rtx first, second;\n@@ -614,6 +638,21 @@ i960_output_ldconst (dst, src)\n \t\t      operands);\n       return \"\";\n     }\n+  else if (mode == SFmode)\n+    {\n+      REAL_VALUE_TYPE d;\n+      long value;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n+      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n+\n+      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n+      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, value);\n+      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n+\t\t      operands);\n+      return \"\";\n+    }\n   else if (mode == TImode)\n     {\n       /* ??? This is currently not handled at all.  */\n@@ -650,21 +689,6 @@ i960_output_ldconst (dst, src)\n \t\t       xoperands);\n       /* The lower word is emitted as normally.  */\n     }\n-  else if (mode == SFmode)\n-    {\n-      REAL_VALUE_TYPE d;\n-      long value;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, value);\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      return \"\";\n-    }\n   else\n     {\n       rsrc1 = INTVAL (src);\n@@ -1851,12 +1875,12 @@ i960_alignment (size, align)\n #define S_MODES\t\t\t\t\t\t\\\n  (~C_MODES\t\t\t\t\t\t\\\n   & ~ ((1 << (int) DImode) | (1 << (int) TImode)\t\\\n-       | (1 << (int) DFmode) | (1 << (int) TFmode)))\n+       | (1 << (int) DFmode) | (1 << (int) XFmode)))\n \n /* Modes for double-word (and smaller) quantities.  */\n #define D_MODES\t\t\t\t\t\\\n   (~C_MODES\t\t\t\t\t\\\n-   & ~ ((1 << (int) TImode) | (1 << (int) TFmode)))\n+   & ~ ((1 << (int) TImode) | (1 << (int) XFmode)))\n \n /* Modes for quad-word quantities.  */\n #define T_MODES (~C_MODES)\n@@ -1868,15 +1892,15 @@ i960_alignment (size, align)\n #define DF_MODES (SF_MODES | (1 << (int) DFmode) | (1 << (int) SCmode))\n \n /* Modes for quad-float quantities.  */\n-#define TF_MODES (DF_MODES | (1 << (int) TFmode) | (1 << (int) DCmode))\n+#define XF_MODES (DF_MODES | (1 << (int) XFmode) | (1 << (int) DCmode))\n \n unsigned int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] = {\n   T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n \n-  TF_MODES, TF_MODES, TF_MODES, TF_MODES, C_MODES};\n+  XF_MODES, XF_MODES, XF_MODES, XF_MODES, C_MODES};\n \n \f\n /* Return the minimum alignment of an expression rtx X in bytes.  This takes\n@@ -2104,6 +2128,23 @@ i960_function_arg (cum, mode, type, named)\n \f\n /* Floating-point support.  */\n \n+void\n+i960_output_long_double (file, value)\n+     FILE *file;\n+     REAL_VALUE_TYPE value;\n+{\n+  long value_long[3];\n+  char dstr[30];\n+\n+  REAL_VALUE_TO_TARGET_LONG_DOUBLE (value, value_long);\n+  REAL_VALUE_TO_DECIMAL (value, \"%.20g\", dstr);\n+\n+  fprintf (file,\n+\t   \"\\t.word\\t0x%08lx\\t\\t# %s\\n\\t.word\\t0x%08lx\\n\\t.word\\t0x%08lx\\n\",\n+\t   value_long[0], dstr, value_long[1], value_long[2]);\n+  fprintf (file, \"\\t.word\\t0x0\\n\");\n+}\n+\n void\n i960_output_double (file, value)\n      FILE *file;"}]}