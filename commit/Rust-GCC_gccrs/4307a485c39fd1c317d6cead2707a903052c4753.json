{"sha": "4307a485c39fd1c317d6cead2707a903052c4753", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwN2E0ODVjMzlmZDFjMzE3ZDZjZWFkMjcwN2E5MDMwNTJjNDc1Mw==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-10-16T07:27:50Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-10-16T07:27:50Z"}, "message": "Generalized IPA predicate on parameter reference\n\n2019-10-16  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/91088\n        * doc/invoke.texi (ipa-max-param-expr-ops): Document new option.\n        * params.def (PARAM_IPA_MAX_PARAM_EXPR_OPS): New.\n        * ipa-predicat.h (struct expr_eval_op): New struct.\n        (expr_eval_ops): New typedef.\n        (struct condition): Add type and param_ops fields, remove size field.\n        (add_condition): Replace size parameter with type parameter, add\n        param_ops parameter.\n        * ipa-predicat.c (expr_eval_ops_equal_p): New function.\n        (predicate::add_clause): Add comparisons on type and param_ops.\n        (dump_condition): Add debug dump for param_ops.\n        (remap_after_inlining): Adjust call arguments to add_condition.\n        (add_condition): Replace size parameter with type parameter, add\n        param_ops parameter. Unshare constant value used in conditions.\n        * ipa-fnsummary.c (evaluate_conditions_for_known_args): Fold\n        parameter expressions using param_ops.\n        (decompose_param_expr):  New function.\n        (set_cond_stmt_execution_predicate): Use call to decompose_param_expr\n        to replace call to unmodified_parm_or_parm_agg_item.\n        (set_switch_stmt_execution_predicate): Likewise.\n        (will_be_nonconstant_expr_predicate): Likewise. Replace usage of size\n        with type.\n        (inline_read_section): Read param_ops from summary stream.\n        (ipa_fn_summary_write): Write param_ops to summary stream.\n\n2019-10-16  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/91088\n        * gcc.dg/ipa/pr91088.c: New test.\n        * gcc.dg/ipa/pr91089.c: Add sub-test for range analysis.\n        * g++.dg/tree-ssa/ivopts-3.C: Force a function to be noinline.\n\nFrom-SVN: r277054", "tree": {"sha": "43e805a49dee12ec7f12a720d4e87a8a6ef39ed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43e805a49dee12ec7f12a720d4e87a8a6ef39ed5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4307a485c39fd1c317d6cead2707a903052c4753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4307a485c39fd1c317d6cead2707a903052c4753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4307a485c39fd1c317d6cead2707a903052c4753", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4307a485c39fd1c317d6cead2707a903052c4753/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8cf9bbd2476bbacdcb8bc51ea2b2c020f3ea0168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf9bbd2476bbacdcb8bc51ea2b2c020f3ea0168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf9bbd2476bbacdcb8bc51ea2b2c020f3ea0168"}], "stats": {"total": 670, "additions": 589, "deletions": 81}, "files": [{"sha": "28629582a023a38740936aab36ffc5b775bddb37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -1,3 +1,30 @@\n+2019-10-16  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91088\n+\t* doc/invoke.texi (ipa-max-param-expr-ops): Document new option.\n+\t* params.def (PARAM_IPA_MAX_PARAM_EXPR_OPS): New.\n+\t* ipa-predicat.h (struct expr_eval_op): New struct.\n+\t(expr_eval_ops): New typedef.\n+\t(struct condition): Add type and param_ops fields, remove size field.\n+\t(add_condition): Replace size parameter with type parameter, add\n+\tparam_ops parameter.\n+\t* ipa-predicat.c (expr_eval_ops_equal_p): New function.\n+\t(predicate::add_clause): Add comparisons on type and param_ops.\n+\t(dump_condition): Add debug dump for param_ops.\n+\t(remap_after_inlining): Adjust call arguments to add_condition.\n+\t(add_condition): Replace size parameter with type parameter, add\n+\tparam_ops parameter. Unshare constant value used in conditions.\n+\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Fold\n+\tparameter expressions using param_ops.\n+\t(decompose_param_expr):  New function.\n+\t(set_cond_stmt_execution_predicate): Use call to decompose_param_expr\n+\tto replace call to unmodified_parm_or_parm_agg_item.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(will_be_nonconstant_expr_predicate): Likewise. Replace usage of size\n+\twith type.\n+\t(inline_read_section): Read param_ops from summary stream.\n+\t(ipa_fn_summary_write): Write param_ops to summary stream.\n+\n 2019-10-15  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/92107"}, {"sha": "1407d019d1404ebbdb9630d6f541eab2e7a1bd01", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -12034,6 +12034,13 @@ For switch exceeding this limit, IPA-CP will not construct cloning cost\n predicate, which is used to estimate cloning benefit, for default case\n of the switch statement.\n \n+@item ipa-max-param-expr-ops\n+IPA-CP will analyze conditional statement that references some function\n+parameter to estimate benefit for cloning upon certain constant value.\n+But if number of operations in a parameter expression exceeds\n+@option{ipa-max-param-expr-ops}, the expression is treated as complicated\n+one, and is not handled by IPA analysis.\n+\n @item lto-partitions\n Specify desired number of partitions produced during WHOPR compilation.\n The number of partitions should exceed the number of CPUs used for compilation."}, {"sha": "40a9e0f3ee3872cdeb63b8aee500cec65a48dee8", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 247, "deletions": 49, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -331,6 +331,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n     {\n       tree val;\n       tree res;\n+      int j;\n+      struct expr_eval_op *op;\n \n       /* We allow call stmt to have fewer arguments than the callee function\n          (especially for K&R style programs).  So bound check here (we assume\n@@ -382,7 +384,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  continue;\n \t}\n \n-      if (maybe_ne (tree_to_poly_int64 (TYPE_SIZE (TREE_TYPE (val))), c->size))\n+      if (TYPE_SIZE (c->type) != TYPE_SIZE (TREE_TYPE (val)))\n \t{\n \t  clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n@@ -394,7 +396,30 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  continue;\n \t}\n \n-      val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);\n+      val = fold_unary (VIEW_CONVERT_EXPR, c->type, val);\n+      for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+\t{\n+\t  if (!val)\n+\t    break;\n+\t  if (!op->val[0])\n+\t    val = fold_unary (op->code, op->type, val);\n+\t  else if (!op->val[1])\n+\t    val = fold_binary (op->code, op->type,\n+\t\t\t       op->index ? op->val[0] : val,\n+\t\t\t       op->index ? val : op->val[0]);\n+\t  else if (op->index == 0)\n+\t    val = fold_ternary (op->code, op->type,\n+\t\t\t\tval, op->val[0], op->val[1]);\n+\t  else if (op->index == 1)\n+\t    val = fold_ternary (op->code, op->type,\n+\t\t\t\top->val[0], val, op->val[1]);\n+\t  else if (op->index == 2)\n+\t    val = fold_ternary (op->code, op->type,\n+\t\t\t\top->val[0], op->val[1], val);\n+\t  else\n+\t    val = NULL_TREE;\n+\t}\n+\n       res = val\n \t? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)\n \t: NULL;\n@@ -1155,6 +1180,127 @@ eliminated_by_inlining_prob (ipa_func_body_info *fbi, gimple *stmt)\n     }\n }\n \n+/* Analyze EXPR if it represents a series of simple operations performed on\n+   a function parameter and return true if so.  FBI, STMT, EXPR, INDEX_P and\n+   AGGPOS have the same meaning like in unmodified_parm_or_parm_agg_item.\n+   Type of the parameter or load from an aggregate via the parameter is\n+   stored in *TYPE_P.  Operations on the parameter are recorded to\n+   PARAM_OPS_P if it is not NULL.  */\n+\n+static bool\n+decompose_param_expr (struct ipa_func_body_info *fbi,\n+\t\t      gimple *stmt, tree expr,\n+\t\t      int *index_p, tree *type_p,\n+\t\t      struct agg_position_info *aggpos,\n+\t\t      expr_eval_ops *param_ops_p = NULL)\n+{\n+  int op_limit = PARAM_VALUE (PARAM_IPA_MAX_PARAM_EXPR_OPS);\n+  int op_count = 0;\n+\n+  if (param_ops_p)\n+    *param_ops_p = NULL;\n+\n+  while (true)\n+    {\n+      expr_eval_op eval_op;\n+      unsigned rhs_count;\n+      unsigned cst_count = 0;\n+\n+      if (unmodified_parm_or_parm_agg_item (fbi, stmt, expr, index_p, NULL,\n+\t\t\t\t\t    aggpos))\n+\t{\n+\t  tree type = TREE_TYPE (expr);\n+\n+\t  if (aggpos->agg_contents)\n+\t    {\n+\t      /* Stop if containing bit-field.  */\n+\t      if (TREE_CODE (expr) == BIT_FIELD_REF\n+\t\t  || contains_bitfld_component_ref_p (expr))\n+\t\tbreak;\n+\t    }\n+\n+\t  *type_p = type;\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (expr) != SSA_NAME || SSA_NAME_IS_DEFAULT_DEF (expr))\n+\tbreak;\n+\n+      if (!is_gimple_assign (stmt = SSA_NAME_DEF_STMT (expr)))\n+\tbreak;\n+\n+      switch (gimple_assign_rhs_class (stmt))\n+\t{\n+\tcase GIMPLE_SINGLE_RHS:\n+\t  expr = gimple_assign_rhs1 (stmt);\n+\t  continue;\n+\n+\tcase GIMPLE_UNARY_RHS:\n+\t  rhs_count = 1;\n+\t  break;\n+\n+\tcase GIMPLE_BINARY_RHS:\n+\t  rhs_count = 2;\n+\t  break;\n+\n+\tcase GIMPLE_TERNARY_RHS:\n+\t  rhs_count = 3;\n+\t  break;\n+\n+\tdefault:\n+\t  goto fail;\n+\t}\n+\n+      /* Stop if expression is too complex.  */\n+      if (op_count++ == op_limit)\n+\tbreak;\n+\n+      if (param_ops_p)\n+\t{\n+\t  eval_op.code = gimple_assign_rhs_code (stmt);\n+\t  eval_op.type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  eval_op.val[0] = NULL_TREE;\n+\t  eval_op.val[1] = NULL_TREE;\n+\t}\n+\n+      expr = NULL_TREE;\n+      for (unsigned i = 0; i < rhs_count; i++)\n+\t{\n+\t  tree op = gimple_op (stmt, i + 1);\n+\n+\t  gcc_assert (op && !TYPE_P (op));\n+\t  if (is_gimple_ip_invariant (op))\n+\t    {\n+\t      if (++cst_count == rhs_count)\n+\t\tgoto fail;\n+\n+\t      eval_op.val[cst_count - 1] = op;\n+\t    }\n+\t  else if (!expr)\n+\t    {\n+\t      /* Found a non-constant operand, and record its index in rhs\n+\t\t operands.  */\n+\t      eval_op.index = i;\n+\t      expr = op;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Found more than one non-constant operands.  */\n+\t      goto fail;\n+\t    }\n+\t}\n+\n+      if (param_ops_p)\n+\tvec_safe_insert (*param_ops_p, 0, eval_op);\n+    }\n+\n+  /* Failed to decompose, free resource and return.  */\n+fail:\n+  if (param_ops_p)\n+    vec_free (*param_ops_p);\n+\n+  return false;\n+}\n \n /* If BB ends by a conditional we can turn into predicates, attach corresponding\n    predicates to the CFG edges.   */\n@@ -1165,26 +1311,25 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t   basic_block bb)\n {\n   gimple *last;\n-  tree op;\n+  tree op, op2;\n   int index;\n-  poly_int64 size;\n   struct agg_position_info aggpos;\n   enum tree_code code, inverted_code;\n   edge e;\n   edge_iterator ei;\n   gimple *set_stmt;\n-  tree op2;\n+  tree param_type;\n+  expr_eval_ops param_ops;\n \n   last = last_stmt (bb);\n   if (!last || gimple_code (last) != GIMPLE_COND)\n     return;\n   if (!is_gimple_ip_invariant (gimple_cond_rhs (last)))\n     return;\n   op = gimple_cond_lhs (last);\n-  /* TODO: handle conditionals like\n-     var = op0 < 4;\n-     if (var != 0).  */\n-  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))\n+\n+  if (decompose_param_expr (fbi, last, op, &index, &param_type, &aggpos,\n+\t\t\t    &param_ops))\n     {\n       code = gimple_cond_code (last);\n       inverted_code = invert_tree_comparison (code, HONOR_NANS (op));\n@@ -1205,13 +1350,13 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t      && !dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \t    {\n \t      predicate p\n-\t\t= add_condition (summary, index, size, &aggpos, this_code,\n-\t\t\t\t unshare_expr_without_location\n-\t\t\t\t (gimple_cond_rhs (last)));\n+\t\t= add_condition (summary, index, param_type, &aggpos,\n+\t\t\t\t this_code, gimple_cond_rhs (last), param_ops);\n \t      e->aux = edge_predicate_pool.allocate ();\n \t      *(predicate *) e->aux = p;\n \t    }\n \t}\n+      vec_free (param_ops);\n     }\n \n   if (TREE_CODE (op) != SSA_NAME)\n@@ -1234,12 +1379,11 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &size,\n-\t\t\t\t\t &aggpos))\n+  if (!decompose_param_expr (fbi, set_stmt, op2, &index, &param_type, &aggpos))\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n-      predicate p = add_condition (summary, index, size, &aggpos,\n+      predicate p = add_condition (summary, index, param_type, &aggpos,\n \t\t\t\t   predicate::is_not_constant, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n       *(predicate *) e->aux = p;\n@@ -1258,19 +1402,21 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   gimple *lastg;\n   tree op;\n   int index;\n-  poly_int64 size;\n   struct agg_position_info aggpos;\n   edge e;\n   edge_iterator ei;\n   size_t n;\n   size_t case_idx;\n+  tree param_type;\n+  expr_eval_ops param_ops;\n \n   lastg = last_stmt (bb);\n   if (!lastg || gimple_code (lastg) != GIMPLE_SWITCH)\n     return;\n   gswitch *last = as_a <gswitch *> (lastg);\n   op = gimple_switch_index (last);\n-  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))\n+  if (!decompose_param_expr (fbi, last, op, &index, &param_type, &aggpos,\n+\t\t\t     &param_ops))\n     return;\n \n   auto_vec<std::pair<tree, tree> > ranges;\n@@ -1302,6 +1448,8 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       tree max = CASE_HIGH (cl);\n       predicate p;\n \n+      e = gimple_switch_edge (cfun, last, case_idx);\n+\n       /* The case value might not have same type as switch expression,\n \t extend the value based on the expression type.  */\n       if (TREE_TYPE (min) != type)\n@@ -1318,18 +1466,17 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       if (dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \tp = true;\n       else if (min == max)\n-\tp = add_condition (summary, index, size, &aggpos, EQ_EXPR,\n-\t\t\t   unshare_expr_without_location (min));\n+\tp = add_condition (summary, index, param_type, &aggpos, EQ_EXPR,\n+\t\t\t   min, param_ops);\n       else\n \t{\n \t  predicate p1, p2;\n-\t  p1 = add_condition (summary, index, size, &aggpos, GE_EXPR,\n-\t\t\t      unshare_expr_without_location (min));\n-\t  p2 = add_condition (summary, index, size, &aggpos, LE_EXPR,\n-\t\t\t      unshare_expr_without_location (max));\n+\t  p1 = add_condition (summary, index, param_type, &aggpos, GE_EXPR,\n+\t\t\t      min, param_ops);\n+\t  p2 = add_condition (summary, index, param_type, &aggpos, LE_EXPR,\n+\t\t\t      max, param_ops);\n \t  p = p1 & p2;\n \t}\n-      e = gimple_switch_edge (cfun, last, case_idx);\n       *(class predicate *) e->aux\n \t= p.or_with (summary->conds, *(class predicate *) e->aux);\n \n@@ -1378,6 +1525,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   if (bound_count > bound_limit)\n     {\n       *(class predicate *) e->aux = true;\n+      vec_free (param_ops);\n       return;\n     }\n \n@@ -1407,16 +1555,16 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       tree max = ranges[i].second;\n \n       if (min == max)\n-\tp_seg &= add_condition (summary, index, size, &aggpos, NE_EXPR,\n-\t\t\t\tunshare_expr_without_location (min));\n+\tp_seg &= add_condition (summary, index, param_type, &aggpos, NE_EXPR,\n+\t\t\t\tmin, param_ops);\n       else\n \t{\n \t  /* Do not create sub-predicate for range that is beyond low bound\n \t     of switch index.  */\n \t  if (wi::lt_p (vr_wmin, wi::to_wide (min), TYPE_SIGN (type)))\n \t    {\n-\t      p_seg &= add_condition (summary, index, size, &aggpos, LT_EXPR,\n-\t\t\t\t      unshare_expr_without_location (min));\n+\t      p_seg &= add_condition (summary, index, param_type, &aggpos,\n+\t\t\t\t      LT_EXPR, min, param_ops);\n \t      p_all = p_all.or_with (summary->conds, p_seg);\n \t    }\n \n@@ -1428,14 +1576,16 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t      break;\n \t    }\n \n-\t  p_seg = add_condition (summary, index, size, &aggpos, GT_EXPR,\n-\t\t\t\t unshare_expr_without_location (max));\n+\t  p_seg = add_condition (summary, index, param_type, &aggpos, GT_EXPR,\n+\t\t\t\t max, param_ops);\n \t}\n     }\n \n   p_all = p_all.or_with (summary->conds, p_seg);\n   *(class predicate *) e->aux\n     = p_all.or_with (summary->conds, *(class predicate *) e->aux);\n+\n+  vec_free (param_ops);\n }\n \n \n@@ -1552,15 +1702,14 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n {\n   tree parm;\n   int index;\n-  poly_int64 size;\n \n   while (UNARY_CLASS_P (expr))\n     expr = TREE_OPERAND (expr, 0);\n \n-  parm = unmodified_parm (fbi, NULL, expr, &size);\n+  parm = unmodified_parm (fbi, NULL, expr, NULL);\n   if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n-    return add_condition (summary, index, size, NULL, predicate::changed,\n-\t\t\t  NULL_TREE);\n+    return add_condition (summary, index, TREE_TYPE (parm), NULL,\n+\t\t\t  predicate::changed, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false;\n   if (TREE_CODE (expr) == SSA_NAME)\n@@ -1624,10 +1773,10 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n   predicate p = true;\n   ssa_op_iter iter;\n   tree use;\n+  tree param_type = NULL_TREE;\n   predicate op_non_const;\n   bool is_load;\n   int base_index;\n-  poly_int64 size;\n   struct agg_position_info aggpos;\n \n   /* What statments might be optimized away\n@@ -1648,11 +1797,9 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n   /* Loads can be optimized when the value is known.  */\n   if (is_load)\n     {\n-      tree op;\n-      gcc_assert (gimple_assign_single_p (stmt));\n-      op = gimple_assign_rhs1 (stmt);\n-      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index, &size,\n-\t\t\t\t\t     &aggpos))\n+      tree op = gimple_assign_rhs1 (stmt);\n+      if (!decompose_param_expr (fbi, stmt, op, &base_index, &param_type,\n+\t\t\t\t &aggpos))\n \treturn p;\n     }\n   else\n@@ -1677,21 +1824,20 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \n   if (is_load)\n     op_non_const =\n-      add_condition (summary, base_index, size, &aggpos, predicate::changed,\n-\t\t     NULL);\n+      add_condition (summary, base_index, param_type, &aggpos,\n+\t\t     predicate::changed, NULL_TREE);\n   else\n     op_non_const = false;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      poly_int64 size;\n-      tree parm = unmodified_parm (fbi, stmt, use, &size);\n+      tree parm = unmodified_parm (fbi, stmt, use, NULL);\n       int index;\n \n       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n-\t    p = add_condition (summary, index, size, NULL, predicate::changed,\n-\t\t\t       NULL_TREE);\n+\t    p = add_condition (summary, index, TREE_TYPE (parm), NULL,\n+\t\t\t       predicate::changed, NULL_TREE);\n \t  else\n \t    continue;\n \t}\n@@ -1823,7 +1969,7 @@ param_change_prob (ipa_func_body_info *fbi, gimple *stmt, int i)\n \treturn REG_BR_PROB_BASE;\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"     Analyzing param change probablity of \");\n+\t  fprintf (dump_file, \"     Analyzing param change probability of \");\n           print_generic_expr (dump_file, op, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n@@ -3452,15 +3598,49 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct condition c;\n+\t  unsigned int k, count3;\n \t  c.operand_num = streamer_read_uhwi (&ib);\n-\t  c.size = streamer_read_poly_uint64 (&ib);\n \t  c.code = (enum tree_code) streamer_read_uhwi (&ib);\n+\t  c.type = stream_read_tree (&ib, data_in);\n \t  c.val = stream_read_tree (&ib, data_in);\n \t  bp = streamer_read_bitpack (&ib);\n \t  c.agg_contents = bp_unpack_value (&bp, 1);\n \t  c.by_ref = bp_unpack_value (&bp, 1);\n \t  if (c.agg_contents)\n \t    c.offset = streamer_read_uhwi (&ib);\n+\t  c.param_ops = NULL;\n+\t  count3 = streamer_read_uhwi (&ib);\n+\t  for (k = 0; k < count3; k++)\n+\t    {\n+\t      struct expr_eval_op op;\n+\t      enum gimple_rhs_class rhs_class;\n+\t      op.code = (enum tree_code) streamer_read_uhwi (&ib);\n+\t      op.type = stream_read_tree (&ib, data_in);\n+\t      switch (rhs_class = get_gimple_rhs_class (op.code))\n+\t\t{\n+\t\tcase GIMPLE_UNARY_RHS:\n+\t\t  op.index = 0;\n+\t\t  op.val[0] = NULL_TREE;\n+\t\t  op.val[1] = NULL_TREE;\n+\t\t  break;\n+\n+\t\tcase GIMPLE_BINARY_RHS:\n+\t\tcase GIMPLE_TERNARY_RHS:\n+\t\t  bp = streamer_read_bitpack (&ib);\n+\t\t  op.index = bp_unpack_value (&bp, 2);\n+\t\t  op.val[0] = stream_read_tree (&ib, data_in);\n+\t\t  if (rhs_class == GIMPLE_BINARY_RHS)\n+\t\t    op.val[1] = NULL_TREE;\n+\t\t  else\n+\t\t    op.val[1] = stream_read_tree (&ib, data_in);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  fatal_error (UNKNOWN_LOCATION,\n+\t\t\t       \"invalid fnsummary in LTO stream\");\n+\t\t}\n+\t      vec_safe_push (c.param_ops, op);\n+\t    }\n \t  if (info)\n \t    vec_safe_push (info->conds, c);\n \t}\n@@ -3606,16 +3786,34 @@ ipa_fn_summary_write (void)\n \t  streamer_write_uhwi (ob, vec_safe_length (info->conds));\n \t  for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)\n \t    {\n+\t      int j;\n+\t      struct expr_eval_op *op;\n+\n \t      streamer_write_uhwi (ob, c->operand_num);\n-\t      streamer_write_poly_uint64 (ob, c->size);\n \t      streamer_write_uhwi (ob, c->code);\n+\t      stream_write_tree (ob, c->type, true);\n \t      stream_write_tree (ob, c->val, true);\n \t      bp = bitpack_create (ob->main_stream);\n \t      bp_pack_value (&bp, c->agg_contents, 1);\n \t      bp_pack_value (&bp, c->by_ref, 1);\n \t      streamer_write_bitpack (&bp);\n \t      if (c->agg_contents)\n \t\tstreamer_write_uhwi (ob, c->offset);\n+\t      streamer_write_uhwi (ob, vec_safe_length (c->param_ops));\n+\t      for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+\t\t{\n+\t\t  streamer_write_uhwi (ob, op->code);\n+\t\t  stream_write_tree (ob, op->type, true);\n+\t\t  if (op->val[0])\n+\t\t    {\n+\t\t      bp = bitpack_create (ob->main_stream);\n+\t\t      bp_pack_value (&bp, op->index, 2);\n+\t\t      streamer_write_bitpack (&bp);\n+\t\t      stream_write_tree (ob, op->val[0], true);\n+\t\t      if (op->val[1])\n+\t\t\tstream_write_tree (ob, op->val[1], true);\n+\t\t    }\n+\t\t}\n \t    }\n \t  streamer_write_uhwi (ob, vec_safe_length (info->size_time_table));\n \t  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)"}, {"sha": "b5e3cf44323896849709e738962a93a0c5af9723", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 136, "deletions": 17, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -33,9 +33,36 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"tree-pretty-print.h\"\n #include \"gimple.h\"\n+#include \"gimplify.h\"\n #include \"data-streamer.h\"\n \n \n+/* Check whether two set of operations have same effects.  */\n+static bool\n+expr_eval_ops_equal_p (expr_eval_ops ops1, expr_eval_ops ops2)\n+{\n+  if (ops1)\n+    {\n+      if (!ops2 || ops1->length () != ops2->length ())\n+\treturn false;\n+\n+      for (unsigned i = 0; i < ops1->length (); i++)\n+\t{\n+\t  expr_eval_op &op1 = (*ops1)[i];\n+\t  expr_eval_op &op2 = (*ops2)[i];\n+\n+\t  if (op1.code != op2.code\n+\t      || op1.index != op2.index\n+\t      || !vrp_operand_equal_p (op1.val[0], op2.val[0])\n+\t      || !vrp_operand_equal_p (op1.val[1], op2.val[1])\n+\t      || !types_compatible_p (op1.type, op2.type))\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return !ops2;\n+}\n+\n /* Add clause CLAUSE into the predicate P.\n    When CONDITIONS is NULL do not perform checking whether NEW_CLAUSE\n    is obviously true.  This is useful only when NEW_CLAUSE is known to be\n@@ -110,14 +137,16 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n \tfor (c2 = c1 + 1; c2 < num_conditions; c2++)\n \t  if (new_clause & (1 << c2))\n \t    {\n-\t      condition *cc1 =\n-\t\t&(*conditions)[c1 - predicate::first_dynamic_condition];\n \t      condition *cc2 =\n \t\t&(*conditions)[c2 - predicate::first_dynamic_condition];\n \t      if (cc1->operand_num == cc2->operand_num\n-\t\t  && cc1->val == cc2->val\n+\t\t  && vrp_operand_equal_p (cc1->val, cc2->val)\n \t\t  && cc2->code != is_not_constant\n-\t\t  && cc2->code != predicate::changed\n+\t\t  && cc2->code != changed\n+\t\t  && expr_eval_ops_equal_p (cc1->param_ops, cc2->param_ops)\n+\t\t  && cc2->agg_contents == cc1->agg_contents\n+\t\t  && cc2->by_ref == cc1->by_ref\n+\t\t  && types_compatible_p (cc2->type, cc1->type)\n \t\t  && cc1->code == invert_tree_comparison (cc2->code,\n \t\t\t\t\t\t\t  HONOR_NANS (cc1->val)))\n \t\treturn;\n@@ -300,6 +329,83 @@ dump_condition (FILE *f, conditions conditions, int cond)\n       if (c->agg_contents)\n \tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n \t\t c->by_ref ? \"ref \" : \"\", c->offset);\n+\n+      for (unsigned i = 0; i < vec_safe_length (c->param_ops); i++)\n+\t{\n+\t  expr_eval_op &op = (*(c->param_ops))[i];\n+\t  const char *op_name = op_symbol_code (op.code);\n+\n+\t  if (op_name == op_symbol_code (ERROR_MARK))\n+\t    op_name = get_tree_code_name (op.code);\n+\n+\t  fprintf (f, \",(\");\n+\n+\t  if (!op.val[0])\n+\t    {\n+\t      switch (op.code)\n+\t\t{\n+\t\tcase FLOAT_EXPR:\n+\t\tcase FIX_TRUNC_EXPR:\n+\t\tcase FIXED_CONVERT_EXPR:\n+\t\tcase VIEW_CONVERT_EXPR:\n+\t\tCASE_CONVERT:\n+\t\t  if (op.code == VIEW_CONVERT_EXPR)\n+\t\t    fprintf (f, \"VCE\");\n+\t\t  fprintf (f, \"(\");\n+\t\t  print_generic_expr (f, op.type);\n+\t\t  fprintf (f, \")\" );\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  fprintf (f, \"%s\", op_name);\n+\t\t}\n+\t      fprintf (f, \" #\");\n+\t    }\n+\t  else if (!op.val[1])\n+\t    {\n+\t      if (op.index)\n+\t\t{\n+\t\t  print_generic_expr (f, op.val[0]);\n+\t\t  fprintf (f, \" %s #\", op_name);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fprintf (f, \"# %s \", op_name);\n+\t\t  print_generic_expr (f, op.val[0]);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (f, \"%s \", op_name);\n+\t      switch (op.index)\n+\t\t{\n+\t\tcase 0:\n+\t\t  fprintf (f, \"#, \");\n+\t\t  print_generic_expr (f, op.val[0]);\n+\t\t  fprintf (f, \", \");\n+\t\t  print_generic_expr (f, op.val[1]);\n+\t\t  break;\n+\n+\t\tcase 1:\n+\t\t  print_generic_expr (f, op.val[0]);\n+\t\t  fprintf (f, \", #, \");\n+\t\t  print_generic_expr (f, op.val[1]);\n+\t\t  break;\n+\n+\t\tcase 2:\n+\t\t  print_generic_expr (f, op.val[0]);\n+\t\t  fprintf (f, \", \");\n+\t\t  print_generic_expr (f, op.val[1]);\n+\t\t  fprintf (f, \", #\");\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  fprintf (f, \"*, *, *\");\n+\t\t}\n+\t    }\n+\t  fprintf (f, \")\");\n+\t}\n+\n       if (c->code == predicate::is_not_constant)\n \t{\n \t  fprintf (f, \" not constant\");\n@@ -462,8 +568,8 @@ predicate::remap_after_inlining (class ipa_fn_summary *info,\n \t\t    ap.by_ref = c->by_ref;\n \t\t    cond_predicate = add_condition (info,\n \t\t\t\t\t\t    operand_map[c->operand_num],\n-\t\t\t\t\t\t    c->size, &ap, c->code,\n-\t\t\t\t\t\t    c->val);\n+\t\t\t\t\t\t    c->type, &ap, c->code,\n+\t\t\t\t\t\t    c->val, c->param_ops);\n \t\t  }\n \t      }\n \t    /* Fixed conditions remains same, construct single\n@@ -516,21 +622,23 @@ predicate::stream_out (struct output_block *ob)\n }\n \n \n-/* Add condition to condition list SUMMARY. OPERAND_NUM, SIZE, CODE and VAL\n-   correspond to fields of condition structure.  AGGPOS describes whether the\n-   used operand is loaded from an aggregate and where in the aggregate it is.\n-   It can be NULL, which means this not a load from an aggregate.  */\n+/* Add condition to condition list SUMMARY.  OPERAND_NUM, TYPE, CODE, VAL and\n+   PARAM_OPS correspond to fields of condition structure.  AGGPOS describes\n+   whether the used operand is loaded from an aggregate and where in the\n+   aggregate it is.  It can be NULL, which means this not a load from an\n+   aggregate.  */\n \n predicate\n add_condition (class ipa_fn_summary *summary, int operand_num,\n-\t       poly_int64 size, struct agg_position_info *aggpos,\n-\t       enum tree_code code, tree val)\n+\t       tree type, struct agg_position_info *aggpos,\n+\t       enum tree_code code, tree val, expr_eval_ops param_ops)\n {\n-  int i;\n+  int i, j;\n   struct condition *c;\n   struct condition new_cond;\n   HOST_WIDE_INT offset;\n   bool agg_contents, by_ref;\n+  expr_eval_op *op;\n \n   if (aggpos)\n     {\n@@ -549,10 +657,11 @@ add_condition (class ipa_fn_summary *summary, int operand_num,\n   for (i = 0; vec_safe_iterate (summary->conds, i, &c); i++)\n     {\n       if (c->operand_num == operand_num\n-\t  && known_eq (c->size, size)\n \t  && c->code == code\n-\t  && c->val == val\n+\t  && types_compatible_p (c->type, type)\n+\t  && vrp_operand_equal_p (c->val, val)\n \t  && c->agg_contents == agg_contents\n+\t  && expr_eval_ops_equal_p (c->param_ops, param_ops)\n \t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n \treturn predicate::predicate_testing_cond (i);\n     }\n@@ -562,11 +671,21 @@ add_condition (class ipa_fn_summary *summary, int operand_num,\n \n   new_cond.operand_num = operand_num;\n   new_cond.code = code;\n-  new_cond.val = val;\n+  new_cond.type = unshare_expr_without_location (type);\n+  new_cond.val = val ? unshare_expr_without_location (val) : val;\n   new_cond.agg_contents = agg_contents;\n   new_cond.by_ref = by_ref;\n   new_cond.offset = offset;\n-  new_cond.size = size;\n+  new_cond.param_ops = vec_safe_copy (param_ops);\n+\n+  for (j = 0; vec_safe_iterate (new_cond.param_ops, j, &op); j++)\n+    {\n+      if (op->val[0])\n+\top->val[0] = unshare_expr_without_location (op->val[0]);\n+      if (op->val[1])\n+\top->val[1] = unshare_expr_without_location (op->val[1]);\n+    }\n+\n   vec_safe_push (summary->conds, new_cond);\n \n   return predicate::predicate_testing_cond (i);"}, {"sha": "4121218ac041c631cc9751e9458b8fead6f37a27", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -22,16 +22,36 @@ along with GCC; see the file COPYING3.  If not see\n    inlined into (i.e. known constant values of function parameters.\n \n    Conditions that are interesting for function body are collected into CONDS\n-   vector.  They are of simple for  function_param OP VAL, where VAL is\n-   IPA invariant.  The conditions are then referred by predicates.  */\n+   vector.  They are of simple as kind of a mathematical transformation on\n+   function parameter, T(function_param), in which the parameter occurs only\n+   once, and other operands are IPA invariant.  The conditions are then\n+   referred by predicates.  */\n+\n+\n+/* A simplified representation of tree node, for unary, binary and ternary\n+   operation.  Computations on parameter are decomposed to a series of this\n+   kind of structure.  */\n+struct GTY(()) expr_eval_op\n+{\n+  /* Result type of expression.  */\n+  tree type;\n+  /* Constant operands in expression, there are at most two.  */\n+  tree val[2];\n+  /* Index of parameter operand in expression.  */\n+  unsigned index : 2;\n+  /* Operation code of expression.  */\n+  ENUM_BITFIELD(tree_code) code : 16;\n+};\n+\n+typedef vec<expr_eval_op, va_gc> *expr_eval_ops;\n \n struct GTY(()) condition\n {\n   /* If agg_contents is set, this is the offset from which the used data was\n      loaded.  */\n   HOST_WIDE_INT offset;\n-  /* Size of the access reading the data (or the PARM_DECL SSA_NAME).  */\n-  poly_int64 size;\n+  /* Type of the access reading the data (or the PARM_DECL SSA_NAME).  */\n+  tree type;\n   tree val;\n   int operand_num;\n   ENUM_BITFIELD(tree_code) code : 16;\n@@ -41,6 +61,9 @@ struct GTY(()) condition\n   /* If agg_contents is set, this differentiates between loads from data\n      passed by reference and by value.  */\n   unsigned by_ref : 1;\n+  /* A set of sequential operations on the parameter, which can be seen as\n+     a mathmatical function on the parameter.  */\n+  expr_eval_ops param_ops;\n };\n \n /* Information kept about parameter of call site.  */\n@@ -228,5 +251,6 @@ class predicate\n \n void dump_condition (FILE *f, conditions conditions, int cond);\n predicate add_condition (class ipa_fn_summary *summary, int operand_num,\n-\t\t\t poly_int64 size, struct agg_position_info *aggpos,\n-\t\t\t enum tree_code code, tree val);\n+\t\t\t tree type, struct agg_position_info *aggpos,\n+\t\t\t enum tree_code code, tree val,\n+\t\t\t expr_eval_ops param_ops = NULL);"}, {"sha": "322c37f8b96c7c5ade92529b7e725ccb92787903", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -1165,6 +1165,12 @@ DEFPARAM (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS,\n \t  \"statement used during IPA functoin summary generation.\",\n \t  5, 0, 0)\n \n+DEFPARAM (PARAM_IPA_MAX_PARAM_EXPR_OPS,\n+\t  \"ipa-max-param-expr-ops\",\n+\t  \"Maximum number of operations in a parameter expression that can \"\n+\t  \"be handled by IPA analysis.\",\n+\t  10, 0, 0)\n+\n /* WHOPR partitioning configuration.  */\n \n DEFPARAM (PARAM_LTO_PARTITIONS,"}, {"sha": "b2b92deb1340346413e48b58acd1e62bf0800936", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -1,3 +1,10 @@\n+2019-10-16  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91088\n+\t* gcc.dg/ipa/pr91088.c: New test.\n+\t* gcc.dg/ipa/pr91089.c: Add sub-test for range analysis.\n+\t* g++.dg/tree-ssa/ivopts-3.C: Force a function to be noinline.\n+\n 2019-10-15  Andrew Pinski  <apinski@marvell.com>\n \n \t* gcc.c-torture/compile/20191015-1.c: New test."}, {"sha": "b0da5e68abcc18d484d5176f0f43759f078c59b6", "filename": "gcc/testsuite/g++.dg/tree-ssa/ivopts-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -25,7 +25,7 @@ protected:\n   double stuff;\n \n public:\n-  explicit MinimalVector ( int length ) {\n+  __attribute__((noinline)) explicit MinimalVector ( int length ) {\n     _pData = new double[length];\n     for (int i = 0; i < length; ++i) _pData[i] = 0.;\n   }"}, {"sha": "a81c59f98b16769832fd1064cd0606be8bd2f649", "filename": "gcc/testsuite/gcc.dg/ipa/pr91088.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91088.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91088.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91088.c?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline\" } */\n+\n+int foo();\n+\n+#define large_code \\\n+do { \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+  foo (); \\\n+} while (1)\n+\n+\n+struct A\n+{\n+  char  f1;\n+  short f2 : 5;\n+  int   f3;\n+};\n+\n+int callee1 (struct A a)\n+{\n+  if ((a.f2 + 7) & 17)\n+    foo ();\n+\n+  if ((1300 / (short)a.f3) == 19)\n+    large_code;\n+\n+  return 1;\n+}\n+\n+int callee2 (short *p)\n+{\n+  if ((*p ^ 1)  <  8)\n+    large_code;      \n+\n+  return 2;\n+}\n+\n+int callee3 (int v)\n+{\n+  if ((27 % ((1 - (char) v) * 3)) < 6)\n+    {\n+      large_code;\n+      return v + 2;\n+    }\n+  else\n+    return v + 1;\n+}\n+\n+int caller ()\n+{\n+  struct A a;\n+  short b;\n+\n+  a.f2 = -7;\n+  a.f3 = 68;\n+  if (callee1 (a))\n+    foo ();\n+\n+  a.f2 = 3;\n+  a.f3 = 10;\n+  if (callee1 (a))\n+    foo ();\n+\n+  b = 9;\n+  if (callee2 (&b))\n+    foo ();\n+\n+  b = 2;\n+  if (callee2 (&b))\n+    foo ();\n+\n+  return callee3 (-5) +\n+\t callee3 (0); \n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of callee1\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of callee2\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of callee3\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"op0\\\\\\[offset: 32],\\\\(\\\\(short int\\\\) #\\\\),\\\\(\\\\(int\\\\) #\\\\),\\\\(1300 / #\\\\) == 19\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"op0\\\\\\[ref offset: 0],\\\\(# \\\\^ 1\\\\) <\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(\\\\(char\\\\) #\\\\),\\\\(\\\\(int\\\\) #\\\\),\\\\(1 - #\\\\),\\\\(# \\\\* 3\\\\),\\\\(27 % #\\\\) <\" \"cp\" } } */"}, {"sha": "a54cbdf5390b20304cf805d1b21606c81d698459", "filename": "gcc/testsuite/gcc.dg/ipa/pr91089.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4307a485c39fd1c317d6cead2707a903052c4753/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c?ref=4307a485c39fd1c317d6cead2707a903052c4753", "patch": "@@ -7,7 +7,7 @@ int data;\n \n int callee (int i)\n {\n-  switch (i)\n+  switch (i % 128)\n     {\n       case -126:  return i + 13;\n       case -127:  return i + 5;\n@@ -45,7 +45,7 @@ int fn2 ();\n \n int callee_complex_predicate (int i)\n {\n-  switch (i )\n+  switch (i)\n     {\n       case 0:\n \tfn ();\n@@ -100,10 +100,10 @@ int caller ()\n }\n  \n /* { dg-final { scan-ipa-dump-times \"Creating a specialized node of callee\" 7 \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 < -127\" \"fnsummary\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 > -126\" \"fnsummary\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 != -8\"  \"fnsummary\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 != 0\"   \"fnsummary\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 < 5\"    \"fnsummary\" } } */\n-/* { dg-final { scan-ipa-dump \"op0 > 7\"    \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump-not \"op0,\\\\(# % 128\\\\) < -127\" \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(# % 128\\\\) > -126\" \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(# % 128\\\\) != -8\"  \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(# % 128\\\\) != 0\"   \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(# % 128\\\\) < 5\"    \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0,\\\\(# % 128\\\\) > 7\"    \"fnsummary\" } } */\n /* { dg-final { scan-ipa-dump \"loop depth: 1 .+ time:\\[ \\]*\\[0-9\\]+ predicate: \\\\(op0 == 1000\\\\)\\[\\r\\n]+\" \"fnsummary\" } } */"}]}