{"sha": "2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxMmE4NTU0YzllZDM1ZmQ2YWE3ODZjMWVmNWVlZTk2YmY4YTZiNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-08-24T18:39:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-08-24T18:39:41Z"}, "message": "Conversion operators kept on single overload set\n\n\tConversion operators kept on single overload set\n\t* class.c (add_method): Keep all conv-ops on one slot.\n\t* name-lookup.c (lookup_conversion_operator): Pull the desired\n\tconv op out of overload set.\n\t* search.c (lookup_conversions_r): Lose template/non-template\n\tdistinction.\n\t(lookup_conversions): Likewise.\n\nFrom-SVN: r251340", "tree": {"sha": "8339ac9ae0c5848cd0dda14a0ea1525cbbb1cc91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8339ac9ae0c5848cd0dda14a0ea1525cbbb1cc91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "281de9c2d56a910fd4321785f9a8c97fc647b8a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281de9c2d56a910fd4321785f9a8c97fc647b8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281de9c2d56a910fd4321785f9a8c97fc647b8a5"}], "stats": {"total": 230, "additions": 77, "deletions": 153}, "files": [{"sha": "92ecf91a23ea39c0fedb7d8a16f715cb3b4e4469", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "patch": "@@ -1,3 +1,13 @@\n+2017-08-24  Nathan Sidwell  <nathan@acm.org>\n+\n+\tConversion operators kept on single overload set\n+\t* class.c (add_method): Keep all conv-ops on one slot.\n+\t* name-lookup.c (lookup_conversion_operator): Pull the desired\n+\tconv op out of overload set.\n+\t* search.c (lookup_conversions_r): Lose template/non-template\n+\tdistinction.\n+\t(lookup_conversions): Likewise.\n+\n 2017-08-23  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-tree.h (lookup_field_1, lookup_fnfields_slot,"}, {"sha": "a08ce89c66e7442a714fb6de2aa8db1389218836", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "patch": "@@ -1014,55 +1014,39 @@ modify_vtable_entry (tree t,\n bool\n add_method (tree type, tree method, bool via_using)\n {\n-  unsigned slot;\n-  bool template_conv_p = false;\n-  bool conv_p;\n-  vec<tree, va_gc> *method_vec;\n-  bool complete_p;\n-  bool insert_p = false;\n-  tree current_fns;\n-\n   if (method == error_mark_node)\n     return false;\n \n-  complete_p = COMPLETE_TYPE_P (type);\n-  conv_p = DECL_CONV_FN_P (method);\n-  if (conv_p)\n-    template_conv_p = (TREE_CODE (method) == TEMPLATE_DECL\n-\t\t       && DECL_TEMPLATE_CONV_FN_P (method));\n+  bool complete_p = COMPLETE_TYPE_P (type);\n+  bool conv_p = DECL_CONV_FN_P (method);\n \n-  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (!method_vec)\n     {\n-      /* Make a new method vector.  We start with 8 entries.  We must\n-\t allocate at least two (for constructors and destructors), and\n-\t we're going to end up with an assignment operator at some\n-\t point as well.  */\n+      /* Make a new method vector.  We start with 8 entries.  */\n       vec_alloc (method_vec, 8);\n       CLASSTYPE_METHOD_VEC (type) = method_vec;\n     }\n \n   /* Maintain TYPE_HAS_USER_CONSTRUCTOR, etc.  */\n   grok_special_member_properties (method);\n \n+  bool insert_p = true;\n+  unsigned slot;\n   tree m;\n \n-  insert_p = true;\n   /* See if we already have an entry with this name.  */\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        vec_safe_iterate (method_vec, slot, &m);\n        ++slot)\n     {\n       m = OVL_FIRST (m);\n-      if (template_conv_p)\n+      if (conv_p)\n \t{\n-\t  if (TREE_CODE (m) == TEMPLATE_DECL\n-\t      && DECL_TEMPLATE_CONV_FN_P (m))\n+\t  if (DECL_CONV_FN_P (m))\n \t    insert_p = false;\n \t  break;\n \t}\n-      if (conv_p && !DECL_CONV_FN_P (m))\n-\tbreak;\n       if (DECL_NAME (m) == DECL_NAME (method))\n \t{\n \t  insert_p = false;\n@@ -1073,7 +1057,8 @@ add_method (tree type, tree method, bool via_using)\n \t  && DECL_NAME (m) > DECL_NAME (method))\n \tbreak;\n     }\n-  current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n+  tree current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n+  gcc_assert (!DECL_EXTERN_C_P (method));\n \n   /* Check to see if we've already got this method.  */\n   for (ovl_iterator iter (current_fns); iter; ++iter)\n@@ -1216,8 +1201,7 @@ add_method (tree type, tree method, bool via_using)\n     }\n \n   /* A class should never have more than one destructor.  */\n-  if (current_fns && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n-    return false;\n+  gcc_assert (!current_fns || !DECL_DESTRUCTOR_P (method));\n \n   current_fns = ovl_insert (method, current_fns, via_using);\n "}, {"sha": "3d69e1d1c2eb09c9f1a41215c6873f7c1475bdb4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "patch": "@@ -1096,34 +1096,31 @@ lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n static tree\n lookup_conversion_operator (tree class_type, tree type)\n {\n-  tree tpls = NULL_TREE;\n+  tree convs = NULL_TREE;\n \n   if (TYPE_HAS_CONVERSION (class_type))\n     {\n-      tree fns;\n+      tree fns = NULL_TREE;\n+      tree tpls = NULL_TREE;\n       vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n \n-      for (int i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   vec_safe_iterate (methods, i, &fns); ++i)\n+      vec_safe_iterate (methods, CLASSTYPE_FIRST_CONVERSION_SLOT, &fns);\n+      if (fns && !DECL_CONV_FN_P (OVL_FIRST (fns)))\n+\tfns = NULL_TREE;\n+      for (ovl_iterator iter (fns); iter; ++iter)\n \t{\n-\t  /* All the conversion operators come near the beginning of\n-\t     the class.  Therefore, if FN is not a conversion\n-\t     operator, there is no matching conversion operator in\n-\t     CLASS_TYPE.  */\n-\t  tree fn = OVL_FIRST (fns);\n-\t  if (!DECL_CONV_FN_P (fn))\n-\t    break;\n+\t  if (same_type_p (DECL_CONV_FN_TYPE (*iter), type))\n+\t    convs = lookup_add (*iter, convs);\n \n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    /* All the templated conversion functions are on the same\n-\t       slot, so remember it.  */\n-\t    tpls = fns;\n-\t  else if (same_type_p (DECL_CONV_FN_TYPE (fn), type))\n-\t    return fns;\n+\t  if (TREE_CODE (*iter) == TEMPLATE_DECL)\n+\t    tpls = lookup_add (*iter, tpls);\n \t}\n+\n+      if (!convs)\n+\tconvs = tpls;\n     }\n \n-  return tpls;\n+  return convs;\n }\n \n /* TYPE is a class type. Return the member functions in the method"}, {"sha": "31f4dd66b9f416eb408c43b1839d6a19647b9930", "filename": "gcc/cp/search.c", "status": "modified", "additions": 41, "deletions": 108, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2e12a8554c9ed35fd6aa786c1ef5eee96bf8a6b6", "patch": "@@ -38,8 +38,7 @@ static tree dfs_dcast_hint_post (tree, void *);\n static tree dfs_debug_mark (tree, void *);\n static int check_hidden_convs (tree, int, int, tree, tree, tree);\n static tree split_conversions (tree, tree, tree, tree);\n-static int lookup_conversions_r (tree, int, int,\n-\t\t\t\t tree, tree, tree, tree, tree *, tree *);\n+static int lookup_conversions_r (tree, int, int, tree, tree, tree *);\n static int look_for_overrides_r (tree, tree);\n static tree lookup_field_r (tree, void *);\n static tree dfs_accessible_post (tree, void *);\n@@ -2333,14 +2332,13 @@ split_conversions (tree my_convs, tree parent_convs,\n }\n \n /* Worker for lookup_conversions.  Lookup conversion functions in\n-   BINFO and its children.  VIRTUAL_DEPTH is nonzero, if BINFO is in\n-   a morally virtual base, and VIRTUALNESS is nonzero, if we've\n-   encountered virtual bases already in the tree walk.  PARENT_CONVS &\n-   PARENT_TPL_CONVS are lists of list of conversions within parent\n-   binfos.  OTHER_CONVS and OTHER_TPL_CONVS are conversions found\n-   elsewhere in the tree.  Return the conversions found within this\n-   portion of the graph in CONVS and TPL_CONVS.  Return nonzero is we\n-   encountered virtualness.  We keep template and non-template\n+   BINFO and its children.  VIRTUAL_DEPTH is nonzero, if BINFO is in a\n+   morally virtual base, and VIRTUALNESS is nonzero, if we've\n+   encountered virtual bases already in the tree walk.  PARENT_CONVS\n+   is a list of conversions within parent binfos.  OTHER_CONVS are\n+   conversions found elsewhere in the tree.  Return the conversions\n+   found within this portion of the graph in CONVS.  Return nonzero if\n+   we encountered virtualness.  We keep template and non-template\n    conversions separate, to avoid unnecessary type comparisons.\n \n    The located conversion functions are held in lists of lists.  The\n@@ -2353,26 +2351,17 @@ split_conversions (tree my_convs, tree parent_convs,\n    is the converted-to type.  */\n \n static int\n-lookup_conversions_r (tree binfo,\n-\t\t      int virtual_depth, int virtualness,\n-\t\t      tree parent_convs, tree parent_tpl_convs,\n-\t\t      tree other_convs, tree other_tpl_convs,\n-\t\t      tree *convs, tree *tpl_convs)\n+lookup_conversions_r (tree binfo, int virtual_depth, int virtualness,\n+\t\t      tree parent_convs, tree other_convs, tree *convs)\n {\n   int my_virtualness = 0;\n   tree my_convs = NULL_TREE;\n-  tree my_tpl_convs = NULL_TREE;\n   tree child_convs = NULL_TREE;\n-  tree child_tpl_convs = NULL_TREE;\n-  unsigned i;\n-  tree base_binfo;\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n-  tree conv;\n \n   /* If we have no conversion operators, then don't look.  */\n   if (!TYPE_HAS_CONVERSION (BINFO_TYPE (binfo)))\n     {\n-      *convs = *tpl_convs = NULL_TREE;\n+      *convs = NULL_TREE;\n \n       return 0;\n     }\n@@ -2381,60 +2370,32 @@ lookup_conversions_r (tree binfo,\n     virtual_depth++;\n \n   /* First, locate the unhidden ones at this level.  */\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, i, &conv);\n-       ++i)\n-    {\n-      tree cur = OVL_FIRST (conv);\n-\n-      if (!DECL_CONV_FN_P (cur))\n-\tbreak;\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  tree conv = NULL_TREE;\n+  vec_safe_iterate (method_vec, CLASSTYPE_FIRST_CONVERSION_SLOT, &conv);\n+  if (conv && !DECL_CONV_FN_P (OVL_FIRST (conv)))\n+    conv = NULL_TREE;\n \n-      if (TREE_CODE (cur) == TEMPLATE_DECL)\n-\t/* Only template conversions can be overloaded, and we must\n-\t   flatten them out and check each one individually.  */\n-\tfor (ovl_iterator iter (conv); iter; ++iter)\n-\t  {\n-\t    tree tpl = *iter;\n-\t    tree type = DECL_CONV_FN_TYPE (tpl);\n+  for (ovl_iterator iter (conv); iter; ++iter)\n+    {\n+      tree fn = *iter;\n+      tree type = DECL_CONV_FN_TYPE (fn);\n \n-\t    if (check_hidden_convs (binfo, virtual_depth, virtualness,\n-\t\t\t\t    type, parent_tpl_convs, other_tpl_convs))\n-\t      {\n-\t\tmy_tpl_convs = tree_cons (binfo, tpl, my_tpl_convs);\n-\t\tTREE_TYPE (my_tpl_convs) = type;\n-\t\tif (virtual_depth)\n-\t\t  {\n-\t\t    TREE_STATIC (my_tpl_convs) = 1;\n-\t\t    my_virtualness = 1;\n-\t\t  }\n-\t      }\n-\t  }\n-      else\n+      if (TREE_CODE (fn) != TEMPLATE_DECL && type_uses_auto (type))\n \t{\n-\t  tree name = DECL_NAME (cur);\n+\t  mark_used (fn);\n+\t  type = DECL_CONV_FN_TYPE (fn);\n+\t}\n \n-\t  if (!IDENTIFIER_MARKED (name))\n+      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n+\t\t\t      type, parent_convs, other_convs))\n+\t{\n+\t  my_convs = tree_cons (binfo, fn, my_convs);\n+\t  TREE_TYPE (my_convs) = type;\n+\t  if (virtual_depth)\n \t    {\n-\t      tree type = DECL_CONV_FN_TYPE (cur);\n-\t      if (type_uses_auto (type))\n-\t\t{\n-\t\t  mark_used (cur);\n-\t\t  type = DECL_CONV_FN_TYPE (cur);\n-\t\t}\n-\n-\t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n-\t\t\t\t      type, parent_convs, other_convs))\n-\t\t{\n-\t\t  my_convs = tree_cons (binfo, conv, my_convs);\n-\t\t  TREE_TYPE (my_convs) = type;\n-\t\t  if (virtual_depth)\n-\t\t    {\n-\t\t      TREE_STATIC (my_convs) = 1;\n-\t\t      my_virtualness = 1;\n-\t\t    }\n-\t\t  IDENTIFIER_MARKED (name) = 1;\n-\t\t}\n+\t      TREE_STATIC (my_convs) = 1;\n+\t      my_virtualness = 1;\n \t    }\n \t}\n     }\n@@ -2446,41 +2407,27 @@ lookup_conversions_r (tree binfo,\n \tTREE_STATIC (parent_convs) = 1;\n     }\n \n-  if (my_tpl_convs)\n-    {\n-      parent_tpl_convs = tree_cons (binfo, my_tpl_convs, parent_tpl_convs);\n-      if (virtual_depth)\n-\tTREE_STATIC (parent_tpl_convs) = 1;\n-    }\n-\n   child_convs = other_convs;\n-  child_tpl_convs = other_tpl_convs;\n \n   /* Now iterate over each base, looking for more conversions.  */\n+  unsigned i;\n+  tree base_binfo;\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n-      tree base_convs, base_tpl_convs;\n+      tree base_convs;\n       unsigned base_virtualness;\n \n       base_virtualness = lookup_conversions_r (base_binfo,\n \t\t\t\t\t       virtual_depth, virtualness,\n-\t\t\t\t\t       parent_convs, parent_tpl_convs,\n-\t\t\t\t\t       child_convs, child_tpl_convs,\n-\t\t\t\t\t       &base_convs, &base_tpl_convs);\n+\t\t\t\t\t       parent_convs, child_convs,\n+\t\t\t\t\t       &base_convs);\n       if (base_virtualness)\n \tmy_virtualness = virtualness = 1;\n       child_convs = chainon (base_convs, child_convs);\n-      child_tpl_convs = chainon (base_tpl_convs, child_tpl_convs);\n     }\n \n-  /* Unmark the conversions found at this level  */\n-  for (conv = my_convs; conv; conv = TREE_CHAIN (conv))\n-    IDENTIFIER_MARKED (OVL_NAME (TREE_VALUE (conv))) = 0;\n-\n   *convs = split_conversions (my_convs, parent_convs,\n \t\t\t      child_convs, other_convs);\n-  *tpl_convs = split_conversions (my_tpl_convs, parent_tpl_convs,\n-\t\t\t\t  child_tpl_convs, other_tpl_convs);\n \n   return my_virtualness;\n }\n@@ -2497,17 +2444,16 @@ lookup_conversions_r (tree binfo,\n tree\n lookup_conversions (tree type)\n {\n-  tree convs, tpl_convs;\n-  tree list = NULL_TREE;\n+  tree convs;\n \n   complete_type (type);\n   if (!CLASS_TYPE_P (type) || !TYPE_BINFO (type))\n     return NULL_TREE;\n \n-  lookup_conversions_r (TYPE_BINFO (type), 0, 0,\n-\t\t\tNULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n-\t\t\t&convs, &tpl_convs);\n+  lookup_conversions_r (TYPE_BINFO (type), 0, 0, NULL_TREE, NULL_TREE, &convs);\n \n+  tree list = NULL_TREE;\n+  \n   /* Flatten the list-of-lists */\n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n@@ -2522,19 +2468,6 @@ lookup_conversions (tree type)\n \t}\n     }\n \n-  for (; tpl_convs; tpl_convs = TREE_CHAIN (tpl_convs))\n-    {\n-      tree probe, next;\n-\n-      for (probe = TREE_VALUE (tpl_convs); probe; probe = next)\n-\t{\n-\t  next = TREE_CHAIN (probe);\n-\n-\t  TREE_CHAIN (probe) = list;\n-\t  list = probe;\n-\t}\n-    }\n-\n   return list;\n }\n "}]}