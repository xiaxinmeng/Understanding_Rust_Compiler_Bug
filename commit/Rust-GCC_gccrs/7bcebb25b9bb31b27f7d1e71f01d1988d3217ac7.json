{"sha": "7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JjZWJiMjViOWJiMzFiMjdmN2QxZTcxZjAxZDE5ODhkMzIxN2FjNw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2005-06-28T14:25:17Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-06-28T14:25:17Z"}, "message": "s390.c (machine_function): New field has_landing_pad_p.\n\n2005-06-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (machine_function): New field has_landing_pad_p.\n\t(s390_set_has_landing_pad_p, s390_reg_clobbered_rtx,\n\t s390_regs_ever_clobbered): New functions.\n\t(s390_return_addr_rtx): Use get_hard_reg_initial_value.\n\t(s390_register_info, s390_init_frame_layout, s390_update_frame_layout):\n\tUse s390_regs_ever_clobbered.\n\t(s390_emit_prologue): Don't use r14 as temp reg if its content is used\n\tfor builtin_return_address.\n\t* config/s390/s390.md (\"exception_receiver\"): New expander.\n\t* config/s390/s390-protos.h (s390_set_has_landing_pad_p): Prototype\n\tadded.\n\nFrom-SVN: r101381", "tree": {"sha": "86c0a9dfdcf1615258ebfa12de800d02e61dd58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86c0a9dfdcf1615258ebfa12de800d02e61dd58c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/comments", "author": null, "committer": null, "parents": [{"sha": "16c5f6e109be9db9ae199094b3c18086005a1100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16c5f6e109be9db9ae199094b3c18086005a1100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16c5f6e109be9db9ae199094b3c18086005a1100"}], "stats": {"total": 170, "additions": 149, "deletions": 21}, "files": [{"sha": "272d7f72b37ca8bc71a64210f8015c0a8ee5fe7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "patch": "@@ -1,3 +1,17 @@\n+2005-06-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (machine_function): New field has_landing_pad_p.\n+\t(s390_set_has_landing_pad_p, s390_reg_clobbered_rtx,\n+\t s390_regs_ever_clobbered): New functions.\n+\t(s390_return_addr_rtx): Use get_hard_reg_initial_value.\n+\t(s390_register_info, s390_init_frame_layout, s390_update_frame_layout):\n+\tUse s390_regs_ever_clobbered.\n+\t(s390_emit_prologue): Don't use r14 as temp reg if its content is used\n+\tfor builtin_return_address.\n+\t* config/s390/s390.md (\"exception_receiver\"): New expander.\n+\t* config/s390/s390-protos.h (s390_set_has_landing_pad_p): Prototype\n+\tadded.\n+\n 2005-06-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* except.c (current_function_has_exception_handlers): Function "}, {"sha": "87cf98ed4699db62675f77ce314a1443764e34ba", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "patch": "@@ -29,6 +29,7 @@ extern void s390_emit_prologue (void);\n extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);\n extern void s390_conditional_register_usage (void);\n+extern void s390_set_has_landing_pad_p (bool);\n \n #ifdef RTX_CODE\n extern int s390_extra_constraint_str (rtx, int, const char *);"}, {"sha": "6311833d390d1dd446e6906fbd797cf35aa69334", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 127, "deletions": 21, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "patch": "@@ -245,6 +245,8 @@ struct machine_function GTY(())\n \n   /* Some local-dynamic TLS symbol name.  */\n   const char *some_ld_name;\n+\n+  bool has_landing_pad_p;\n };\n \n /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */\n@@ -262,6 +264,13 @@ struct machine_function GTY(())\n #define GP_ARG_NUM_REG 5\n #define FP_ARG_NUM_REG (TARGET_64BIT? 4 : 2)\n \n+/* Set the has_landing_pad_p flag in struct machine_function to VALUE.  */\n+\n+void\n+s390_set_has_landing_pad_p (bool value)\n+{\n+  cfun->machine->has_landing_pad_p = value;\n+}\n \n /* Return true if SET either doesn't set the CC register, or else\n    the source and destination have matching CC modes and that\n@@ -5480,8 +5489,14 @@ s390_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n \n   if (count == 0)\n     {\n-      cfun_frame_layout.save_return_addr_p = true;\n-      return gen_rtx_MEM (Pmode, return_address_pointer_rtx);\n+      /* On non-z architectures branch splitting could overwrite r14.  */\n+      if (TARGET_CPU_ZARCH)\n+\treturn get_hard_reg_initial_val (Pmode, RETURN_REGNUM);\n+      else\n+\t{\n+\t  cfun_frame_layout.save_return_addr_p = true;\n+\t  return gen_rtx_MEM (Pmode, return_address_pointer_rtx);\n+\t}\n     }\n \n   if (TARGET_PACKED_STACK)\n@@ -5528,6 +5543,88 @@ find_unused_clobbered_reg (void)\n   return 0;\n }\n \n+\n+/* Helper function for s390_regs_ever_clobbered.  Sets the fields in DATA for all \n+   clobbered hard regs in SETREG.  */\n+\n+static void\n+s390_reg_clobbered_rtx (rtx setreg, rtx set_insn ATTRIBUTE_UNUSED, void *data)\n+{\n+  int *regs_ever_clobbered = (int *)data;\n+  unsigned int i, regno;\n+  enum machine_mode mode = GET_MODE (setreg);\n+\n+  if (GET_CODE (setreg) == SUBREG)\n+    {\n+      rtx inner = SUBREG_REG (setreg);\n+      if (!GENERAL_REG_P (inner))\n+\treturn;\n+      regno = subreg_regno (setreg);\n+    }\n+  else if (GENERAL_REG_P (setreg))\n+    regno = REGNO (setreg);\n+  else\n+    return;\n+\n+  for (i = regno;\n+       i < regno + HARD_REGNO_NREGS (regno, mode);\n+       i++)\n+    regs_ever_clobbered[i] = 1;\n+}\n+\n+/* Walks through all basic blocks of the current function looking\n+   for clobbered hard regs using s390_reg_clobbered_rtx.  The fields\n+   of the passed integer array REGS_EVER_CLOBBERED are set to one for\n+   each of those regs.  */\n+\n+static void\n+s390_regs_ever_clobbered (int *regs_ever_clobbered)\n+{\n+  basic_block cur_bb;\n+  rtx cur_insn;\n+  unsigned int i;\n+\n+  memset (regs_ever_clobbered, 0, 16 * sizeof (int));\n+\n+  /* For non-leaf functions we have to consider all call clobbered regs to be\n+     clobbered.  */\n+  if (!current_function_is_leaf)\n+    {\n+      for (i = 0; i < 16; i++)\n+\tregs_ever_clobbered[i] = call_really_used_regs[i];\n+    }\n+\n+  /* Make the \"magic\" eh_return registers live if necessary.  For regs_ever_live\n+     this work is done by liveness analysis (mark_regs_live_at_end).\n+     Special care is needed for functions containing landing pads.  Landing pads\n+     may use the eh registers, but the code which sets these registers is not\n+     contained in that function.  Hence s390_regs_ever_clobbered is not able to\n+     deal with this automatically.  */\n+  if (current_function_calls_eh_return || cfun->machine->has_landing_pad_p)\n+    for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM ; i++)\n+      regs_ever_clobbered[EH_RETURN_DATA_REGNO (i)] = 1;\n+\n+  /* For nonlocal gotos all call-saved registers have to be saved.\n+     This flag is also set for the unwinding code in libgcc.\n+     See expand_builtin_unwind_init.  For regs_ever_live this is done by\n+     reload.  */\n+  if (current_function_has_nonlocal_label)\n+    for (i = 0; i < 16; i++)\n+      if (!call_really_used_regs[i])\n+\tregs_ever_clobbered[i] = 1;\n+\n+  FOR_EACH_BB (cur_bb)\n+    {\n+      FOR_BB_INSNS (cur_bb, cur_insn)\n+\t{\n+\t  if (INSN_P (cur_insn))\n+\t    note_stores (PATTERN (cur_insn),\n+\t\t\t s390_reg_clobbered_rtx, \n+\t\t\t regs_ever_clobbered);\n+\t}\n+    }\n+}\n+\n /* Determine the frame area which actually has to be accessed \n    in the function epilogue. The values are stored at the \n    given pointers AREA_BOTTOM (address of the lowest used stack\n@@ -5571,10 +5668,10 @@ s390_frame_area (int *area_bottom, int *area_top)\n }\n \n /* Fill cfun->machine with info about register usage of current function.\n-   Return in LIVE_REGS which GPRs are currently considered live.  */\n+   Return in CLOBBERED_REGS which GPRs are currently considered set.  */\n \n static void\n-s390_register_info (int live_regs[])\n+s390_register_info (int clobbered_regs[])\n {\n   int i, j;\n \n@@ -5595,34 +5692,39 @@ s390_register_info (int live_regs[])\n      Also, all registers with special meaning to the compiler need\n      to be handled extra.  */\n \n+  s390_regs_ever_clobbered (clobbered_regs);\n+\n   for (i = 0; i < 16; i++)\n-    live_regs[i] = regs_ever_live[i] && !global_regs[i];\n+    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i];\n+\n+  if (frame_pointer_needed)\n+    clobbered_regs[HARD_FRAME_POINTER_REGNUM] = 1;\n \n   if (flag_pic)\n-    live_regs[PIC_OFFSET_TABLE_REGNUM] \n+    clobbered_regs[PIC_OFFSET_TABLE_REGNUM] \n     = regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n \n-  live_regs[BASE_REGNUM] \n+  clobbered_regs[BASE_REGNUM] \n     = cfun->machine->base_reg\n       && REGNO (cfun->machine->base_reg) == BASE_REGNUM;\n \n-  live_regs[RETURN_REGNUM]\n+  clobbered_regs[RETURN_REGNUM]\n     = cfun->machine->split_branches_pending_p\n       || cfun_frame_layout.save_return_addr_p;\n \n-  live_regs[STACK_POINTER_REGNUM]\n+  clobbered_regs[STACK_POINTER_REGNUM]\n     = !current_function_is_leaf\n       || TARGET_TPF_PROFILING\n       || cfun_save_high_fprs_p\n       || get_frame_size () > 0\n       || current_function_calls_alloca\n       || current_function_stdarg;\n-  \n+\n   for (i = 6; i < 16; i++)\n-    if (live_regs[i])\n+    if (clobbered_regs[i])\n       break;\n   for (j = 15; j > i; j--)\n-    if (live_regs[j])\n+    if (clobbered_regs[j])\n       break;\n \n   if (i == 16)\n@@ -5804,10 +5906,12 @@ s390_init_frame_layout (void)\n {\n   HOST_WIDE_INT frame_size;\n   int base_used;\n-  int live_regs[16];\n+  int clobbered_regs[16];\n \n   /* If return address register is explicitly used, we need to save it.  */\n-  if (regs_ever_live[RETURN_REGNUM]\n+  s390_regs_ever_clobbered (clobbered_regs);\n+\n+  if (clobbered_regs[RETURN_REGNUM]\n       || !current_function_is_leaf\n       || TARGET_TPF_PROFILING\n       || current_function_stdarg\n@@ -5841,7 +5945,7 @@ s390_init_frame_layout (void)\n       else\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n \n-      s390_register_info (live_regs);\n+      s390_register_info (clobbered_regs);\n       s390_frame_info ();\n     }\n   while (frame_size != cfun_frame_layout.frame_size);\n@@ -5855,13 +5959,13 @@ s390_init_frame_layout (void)\n static void\n s390_update_frame_layout (void)\n {\n-  int live_regs[16];\n+  int clobbered_regs[16];\n \n-  s390_register_info (live_regs);\n+  s390_register_info (clobbered_regs);\n \n-  regs_ever_live[BASE_REGNUM] = live_regs[BASE_REGNUM];\n-  regs_ever_live[RETURN_REGNUM] = live_regs[RETURN_REGNUM];\n-  regs_ever_live[STACK_POINTER_REGNUM] = live_regs[STACK_POINTER_REGNUM];\n+  regs_ever_live[BASE_REGNUM] = clobbered_regs[BASE_REGNUM];\n+  regs_ever_live[RETURN_REGNUM] = clobbered_regs[RETURN_REGNUM];\n+  regs_ever_live[STACK_POINTER_REGNUM] = clobbered_regs[STACK_POINTER_REGNUM];\n \n   if (cfun->machine->base_reg)\n     regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n@@ -6131,7 +6235,9 @@ s390_emit_prologue (void)\n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n \n-  if (!current_function_is_leaf && !TARGET_TPF_PROFILING)\n+  if (!has_hard_reg_initial_val (Pmode, RETURN_REGNUM) \n+      && !current_function_is_leaf \n+      && !TARGET_TPF_PROFILING)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);"}, {"sha": "826261d328b8a726c33a9d40b6e3065a576e19ce", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=7bcebb25b9bb31b27f7d1e71f01d1988d3217ac7", "patch": "@@ -6895,6 +6895,13 @@\n   DONE;\n })\n \n+(define_expand \"exception_receiver\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  s390_set_has_landing_pad_p (true);\n+  DONE;\n+})\n \n ;\n ; nop instruction pattern(s)."}]}