{"sha": "e6c3bb379f515b27268d08e62b4b3e5d7200b437", "node_id": "C_kwDOANBUbNoAKGU2YzNiYjM3OWY1MTViMjcyNjhkMDhlNjJiNGIzZTVkNzIwMGI0Mzc", "commit": {"author": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-06-30T22:02:17Z"}, "committer": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-07-02T17:07:49Z"}, "message": "analyzer: add allocation size checker [PR105900]\n\nThis patch adds an checker that warns about code paths in which a buffer\nis assigned to a incompatible type, i.e. when the allocated buffer size\nis not a multiple of the pointee's size.\n\nRegression-tested on x86_64 Linux. Also compiled coreutils, curl, openssh and\nhttpd with the patch enabled.\n\n2022-07-01  Tim Lange  <mail@tim-lange.me>\n\ngcc/analyzer/ChangeLog:\n\n\tPR analyzer/105900\n\t* analyzer.opt: Added Wanalyzer-allocation-size.\n\t* checker-path.cc (region_creation_event::get_desc): Added call to new\n\tvirtual function pending_diagnostic::describe_region_creation_event.\n\t* checker-path.h: Added region_creation_event::get_desc.\n\t* diagnostic-manager.cc (diagnostic_manager::add_event_on_final_node):\n\tNew function.\n\t* diagnostic-manager.h:\n\tAdded diagnostic_manager::add_event_on_final_node.\n\t* pending-diagnostic.h (struct region_creation): New event_desc struct.\n\t(pending_diagnostic::describe_region_creation_event): Added virtual\n\tfunction to overwrite description of a region creation.\n\t* region-model.cc (class dubious_allocation_size): New class.\n\t(capacity_compatible_with_type): New helper function.\n\t(class size_visitor): New class.\n\t(struct_or_union_with_inheritance_p): New helper function.\n\t(is_any_cast_p): New helper function.\n\t(region_model::check_region_size): New function.\n\t(region_model::set_value): Added call to\n\tregion_model::check_region_size.\n\t* region-model.h (class region_model): New function check_region_size.\n\t* svalue.cc (region_svalue::accept): Changed to post-order traversal.\n\t(initial_svalue::accept): Likewise.\n\t(unaryop_svalue::accept): Likewise.\n\t(binop_svalue::accept): Likewise.\n\t(sub_svalue::accept): Likewise.\n\t(repeated_svalue::accept): Likewise.\n\t(bits_within_svalue::accept): Likewise.\n\t(widening_svalue::accept): Likewise.\n\t(unmergeable_svalue::accept): Likewise.\n\t(compound_svalue::accept): Likewise.\n\t(conjured_svalue::accept): Likewise.\n\t(asm_output_svalue::accept): Likewise.\n\t(const_fn_result_svalue::accept): Likewise.\n\ngcc/ChangeLog:\n\n\tPR analyzer/105900\n\t* doc/invoke.texi: Added Wanalyzer-allocation-size.\n\ngcc/testsuite/ChangeLog:\n\n\tPR analyzer/105900\n\t* gcc.dg/analyzer/pr96639.c: Changed buffer size to omit warning.\n\t* gcc.dg/analyzer/allocation-size-1.c: New test.\n\t* gcc.dg/analyzer/allocation-size-2.c: New test.\n\t* gcc.dg/analyzer/allocation-size-3.c: New test.\n\t* gcc.dg/analyzer/allocation-size-4.c: New test.\n\t* gcc.dg/analyzer/allocation-size-5.c: New test.\n\nSigned-off-by: Tim Lange <mail@tim-lange.me>", "tree": {"sha": "9b94cd4942a37d52932c4ac9ed46708336d7beae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b94cd4942a37d52932c4ac9ed46708336d7beae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6c3bb379f515b27268d08e62b4b3e5d7200b437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c3bb379f515b27268d08e62b4b3e5d7200b437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6c3bb379f515b27268d08e62b4b3e5d7200b437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c3bb379f515b27268d08e62b4b3e5d7200b437/comments", "author": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97baacba963c06e3d0e33cde04e7e687671e60e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97baacba963c06e3d0e33cde04e7e687671e60e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97baacba963c06e3d0e33cde04e7e687671e60e7"}], "stats": {"total": 928, "additions": 912, "deletions": 16}, "files": [{"sha": "5021376b6fb6c148b6632939b6cf4b3d9a2770e9", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -54,6 +54,10 @@ The minimum number of supernodes within a function for the analyzer to consider\n Common Joined UInteger Var(param_analyzer_max_enodes_for_full_dump) Init(200) Param\n The maximum depth of exploded nodes that should appear in a dot dump before switching to a less verbose format.\n \n+Wanalyzer-allocation-size\n+Common Var(warn_analyzer_allocation_size) Init(1) Warning\n+Warn about code paths in which a pointer to a buffer is assigned to an incompatible type.\n+\n Wanalyzer-double-fclose\n Common Var(warn_analyzer_double_fclose) Init(1) Warning\n Warn about code paths in which a stdio FILE can be closed more than once."}, {"sha": "953e192cd55c6728922d2932025a23a466f58ce2", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -302,8 +302,17 @@ region_creation_event::region_creation_event (const region *reg,\n    region_creation_event.  */\n \n label_text\n-region_creation_event::get_desc (bool) const\n+region_creation_event::get_desc (bool can_colorize) const\n {\n+  if (m_pending_diagnostic)\n+    {\n+      label_text custom_desc\n+\t    = m_pending_diagnostic->describe_region_creation_event\n+\t\t(evdesc::region_creation (can_colorize, m_reg));\n+      if (custom_desc.m_buffer)\n+\treturn custom_desc;\n+    }\n+\n   switch (m_reg->get_memory_space ())\n     {\n     default:"}, {"sha": "8e48d8a07ab0d07b79fb5207fed038e227f26295", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -219,7 +219,7 @@ class region_creation_event : public checker_event\n   region_creation_event (const region *reg,\n \t\t\t location_t loc, tree fndecl, int depth);\n \n-  label_text get_desc (bool) const final override;\n+  label_text get_desc (bool can_colorize) const final override;\n \n private:\n   const region *m_reg;"}, {"sha": "4adfda1af65721db6ac5931b3c0178d3bfa352cf", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -1476,6 +1476,67 @@ diagnostic_manager::build_emission_path (const path_builder &pb,\n       const exploded_edge *eedge = epath.m_edges[i];\n       add_events_for_eedge (pb, *eedge, emission_path, &interest);\n     }\n+  add_event_on_final_node (epath.get_final_enode (), emission_path, &interest);\n+}\n+\n+/* Emit a region_creation_event when requested on the last statement in\n+   the path.\n+\n+   If a region_creation_event should be emitted on the last statement of the\n+   path, we need to peek to the successors to get whether the final enode\n+   created a region.\n+*/\n+\n+void\n+diagnostic_manager::add_event_on_final_node (const exploded_node *final_enode,\n+\t\t\t\t\t     checker_path *emission_path,\n+\t\t\t\t\t     interesting_t *interest) const\n+{\n+  const program_point &src_point = final_enode->get_point ();\n+  const int src_stack_depth = src_point.get_stack_depth ();\n+  const program_state &src_state = final_enode->get_state ();\n+  const region_model *src_model = src_state.m_region_model;\n+\n+  unsigned j;\n+  exploded_edge *e;\n+  FOR_EACH_VEC_ELT (final_enode->m_succs, j, e)\n+  {\n+    exploded_node *dst = e->m_dest;\n+    const program_state &dst_state = dst->get_state ();\n+    const region_model *dst_model = dst_state.m_region_model;\n+    if (src_model->get_dynamic_extents ()\n+\t!= dst_model->get_dynamic_extents ())\n+      {\n+\tunsigned i;\n+\tconst region *reg;\n+\tbool emitted = false;\n+\tFOR_EACH_VEC_ELT (interest->m_region_creation, i, reg)\n+\t  {\n+\t    const region *base_reg = reg->get_base_region ();\n+\t    const svalue *old_extents\n+\t= src_model->get_dynamic_extents (base_reg);\n+\t    const svalue *new_extents\n+\t= dst_model->get_dynamic_extents (base_reg);\n+\t    if (old_extents == NULL && new_extents != NULL)\n+\t      switch (base_reg->get_kind ())\n+\t\t{\n+\t\tdefault:\n+\t\t  break;\n+\t\tcase RK_HEAP_ALLOCATED:\n+\t\tcase RK_ALLOCA:\n+\t\t  emission_path->add_region_creation_event\n+\t\t    (reg,\n+\t\t    src_point.get_location (),\n+\t\t    src_point.get_fndecl (),\n+\t\t    src_stack_depth);\n+\t\t  emitted = true;\n+\t\t  break;\n+\t\t}\n+\t  }\n+\tif (emitted)\n+\t  break;\n+      }\n+  }\n }\n \n /* Subclass of state_change_visitor that creates state_change_event"}, {"sha": "266eed8f9cb554620986ae3a25efb365f00cd5e7", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -149,6 +149,10 @@ class diagnostic_manager : public log_user\n \t\t\t    const exploded_path &epath,\n \t\t\t    checker_path *emission_path) const;\n \n+  void add_event_on_final_node (const exploded_node *final_enode,\n+\t\t\t\tchecker_path *emission_path,\n+\t\t\t\tinteresting_t *interest) const;\n+\n   void add_events_for_eedge (const path_builder &pb,\n \t\t\t     const exploded_edge &eedge,\n \t\t\t     checker_path *emission_path,"}, {"sha": "4ea469e18791d20c05ec2fce9b859f16e206a7e4", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -58,6 +58,17 @@ struct event_desc\n   bool m_colorize;\n };\n \n+/* For use by pending_diagnostic::describe_region_creation.  */\n+\n+struct region_creation : public event_desc\n+{\n+  region_creation (bool colorize, const region *reg)\n+  : event_desc (colorize), m_reg (reg)\n+  {}\n+\n+  const region *m_reg;\n+};\n+\n /* For use by pending_diagnostic::describe_state_change.  */\n \n struct state_change : public event_desc\n@@ -215,6 +226,15 @@ class pending_diagnostic\n      description; NULL otherwise (falling back on a more generic\n      description).  */\n \n+  /* Precision-of-wording vfunc for describing a region creation event\n+     triggered by the mark_interesting_stuff vfunc.  */\n+  virtual label_text\n+  describe_region_creation_event (const evdesc::region_creation &)\n+  {\n+    /* Default no-op implementation.  */\n+    return label_text ();\n+  }\n+\n   /* Precision-of-wording vfunc for describing a critical state change\n      within the diagnostic_path.\n "}, {"sha": "5d939327e013c2b557abf4cfdde54b4d4950a344", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-operands.h\"\n #include \"ssa-iterators.h\"\n #include \"calls.h\"\n+#include \"is-a.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -2799,6 +2800,373 @@ region_model::check_region_for_read (const region *src_reg,\n   check_region_access (src_reg, DIR_READ, ctxt);\n }\n \n+/* Concrete subclass for casts of pointers that lead to trailing bytes.  */\n+\n+class dubious_allocation_size\n+: public pending_diagnostic_subclass<dubious_allocation_size>\n+{\n+public:\n+  dubious_allocation_size (const region *lhs, const region *rhs)\n+  : m_lhs (lhs), m_rhs (rhs), m_expr (NULL_TREE)\n+  {}\n+\n+  dubious_allocation_size (const region *lhs, const region *rhs,\n+\t\t\t   tree expr)\n+  : m_lhs (lhs), m_rhs (rhs), m_expr (expr)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"dubious_allocation_size\";\n+  }\n+\n+  bool operator== (const dubious_allocation_size &other) const\n+  {\n+    return m_lhs == other.m_lhs && m_rhs == other.m_rhs\n+\t   && pending_diagnostic::same_tree_p (m_expr, other.m_expr);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_allocation_size;\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (131);\n+\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t       \"allocated buffer size is not a multiple of the pointee's size\");\n+  }\n+\n+  label_text\n+  describe_region_creation_event (const evdesc::region_creation &ev) final\n+  override\n+  {\n+    m_allocation_event = &ev;\n+    if (m_expr)\n+      {\n+\tif (TREE_CODE (m_expr) == INTEGER_CST)\n+\t  return ev.formatted_print (\"allocated %E bytes here\", m_expr);\n+\telse\n+\t  return ev.formatted_print (\"allocated %qE bytes here\", m_expr);\n+      }\n+\n+    return ev.formatted_print (\"allocated here\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) final\n+  override\n+  {\n+    tree pointee_type = TREE_TYPE (m_lhs->get_type ());\n+    if (m_allocation_event)\n+      /* Fallback: Typically, we should always\n+\t see an m_allocation_event before.  */\n+      return ev.formatted_print (\"assigned to %qT here;\"\n+\t\t\t\t \" %<sizeof (%T)%> is %qE\",\n+\t\t\t\t m_lhs->get_type (), pointee_type,\n+\t\t\t\t size_in_bytes (pointee_type));\n+\n+    if (m_expr)\n+      {\n+\tif (TREE_CODE (m_expr) == INTEGER_CST)\n+\t  return ev.formatted_print (\"allocated %E bytes and assigned to\"\n+\t\t\t\t    \" %qT here; %<sizeof (%T)%> is %qE\",\n+\t\t\t\t    m_expr, m_lhs->get_type (), pointee_type,\n+\t\t\t\t    size_in_bytes (pointee_type));\n+\telse\n+\t  return ev.formatted_print (\"allocated %qE bytes and assigned to\"\n+\t\t\t\t    \" %qT here; %<sizeof (%T)%> is %qE\",\n+\t\t\t\t    m_expr, m_lhs->get_type (), pointee_type,\n+\t\t\t\t    size_in_bytes (pointee_type));\n+      }\n+\n+    return ev.formatted_print (\"allocated and assigned to %qT here;\"\n+\t\t\t       \" %<sizeof (%T)%> is %qE\",\n+\t\t\t       m_lhs->get_type (), pointee_type,\n+\t\t\t       size_in_bytes (pointee_type));\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    interest->add_region_creation (m_rhs);\n+  }\n+\n+private:\n+  const region *m_lhs;\n+  const region *m_rhs;\n+  const tree m_expr;\n+  const evdesc::region_creation *m_allocation_event;\n+};\n+\n+/* Return true on dubious allocation sizes for constant sizes.  */\n+\n+static bool\n+capacity_compatible_with_type (tree cst, tree pointee_size_tree,\n+\t\t\t       bool is_struct)\n+{\n+  gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (pointee_size_tree) == INTEGER_CST);\n+\n+  unsigned HOST_WIDE_INT pointee_size = TREE_INT_CST_LOW (pointee_size_tree);\n+  unsigned HOST_WIDE_INT alloc_size = TREE_INT_CST_LOW (cst);\n+\n+  if (is_struct)\n+    return alloc_size >= pointee_size;\n+  return alloc_size % pointee_size == 0;\n+}\n+\n+static bool\n+capacity_compatible_with_type (tree cst, tree pointee_size_tree)\n+{\n+  return capacity_compatible_with_type (cst, pointee_size_tree, false);\n+}\n+\n+/* Checks whether SVAL could be a multiple of SIZE_CST.\n+\n+   It works by visiting all svalues inside SVAL until it reaches\n+   atomic nodes.  From those, it goes back up again and adds each\n+   node that might be a multiple of SIZE_CST to the RESULT_SET.  */\n+\n+class size_visitor : public visitor\n+{\n+public:\n+  size_visitor (tree size_cst, const svalue *sval, constraint_manager *cm)\n+  : m_size_cst (size_cst), m_sval (sval), m_cm (cm)\n+  {\n+    sval->accept (this);\n+  }\n+\n+  bool get_result ()\n+  {\n+    return result_set.contains (m_sval);\n+  }\n+\n+  void visit_constant_svalue (const constant_svalue *sval) final override\n+  {\n+    if (capacity_compatible_with_type (sval->get_constant (), m_size_cst))\n+      result_set.add (sval);\n+  }\n+\n+  void visit_unknown_svalue (const unknown_svalue *sval ATTRIBUTE_UNUSED)\n+    final override\n+  {\n+    result_set.add (sval);\n+  }\n+\n+  void visit_poisoned_svalue (const poisoned_svalue *sval ATTRIBUTE_UNUSED)\n+    final override\n+  {\n+    result_set.add (sval);\n+  }\n+\n+  void visit_unaryop_svalue (const unaryop_svalue *sval)\n+  {\n+    const svalue *arg = sval->get_arg ();\n+    if (result_set.contains (arg))\n+      result_set.add (sval);\n+  }\n+\n+  void visit_binop_svalue (const binop_svalue *sval) final override\n+  {\n+    const svalue *arg0 = sval->get_arg0 ();\n+    const svalue *arg1 = sval->get_arg1 ();\n+\n+    if (sval->get_op () == MULT_EXPR)\n+      {\n+\tif (result_set.contains (arg0) || result_set.contains (arg1))\n+\t  result_set.add (sval);\n+      }\n+    else\n+      {\n+\tif (result_set.contains (arg0) && result_set.contains (arg1))\n+\t  result_set.add (sval);\n+      }\n+  }\n+\n+  void visit_repeated_svalue (const repeated_svalue *sval)\n+  {\n+    sval->get_inner_svalue ()->accept (this);\n+    if (result_set.contains (sval->get_inner_svalue ()))\n+      result_set.add (sval);\n+  }\n+\n+  void visit_unmergeable_svalue (const unmergeable_svalue *sval) final override\n+  {\n+    sval->get_arg ()->accept (this);\n+    if (result_set.contains (sval->get_arg ()))\n+      result_set.add (sval);\n+  }\n+\n+  void visit_widening_svalue (const widening_svalue *sval) final override\n+  {\n+    const svalue *base = sval->get_base_svalue ();\n+    const svalue *iter = sval->get_iter_svalue ();\n+\n+    if (result_set.contains (base) && result_set.contains (iter))\n+      result_set.add (sval);\n+  }\n+\n+  void visit_conjured_svalue (const conjured_svalue *sval ATTRIBUTE_UNUSED)\n+    final override\n+  {\n+    equiv_class_id id (-1);\n+    if (m_cm->get_equiv_class_by_svalue (sval, &id))\n+      {\n+\tif (tree cst_val = id.get_obj (*m_cm).get_any_constant ())\n+\t  {\n+\t    if (capacity_compatible_with_type (cst_val, m_size_cst))\n+\t      result_set.add (sval);\n+\t  }\n+\telse\n+\t  {\n+\t    result_set.add (sval);\n+\t  }\n+      }\n+  }\n+\n+  void visit_asm_output_svalue (const asm_output_svalue *sval ATTRIBUTE_UNUSED)\n+    final override\n+  {\n+    result_set.add (sval);\n+  }\n+\n+  void visit_const_fn_result_svalue (const const_fn_result_svalue\n+\t\t\t\t      *sval ATTRIBUTE_UNUSED) final override\n+  {\n+    result_set.add (sval);\n+  }\n+\n+private:\n+  tree m_size_cst;\n+  const svalue *m_sval;\n+  constraint_manager *m_cm;\n+  svalue_set result_set; /* Used as a mapping of svalue*->bool.  */\n+};\n+\n+/* Return true if a struct or union either uses the inheritance pattern,\n+   where the first field is a base struct, or the flexible array member\n+   pattern, where the last field is an array without a specified size.  */\n+\n+static bool\n+struct_or_union_with_inheritance_p (tree struc)\n+{\n+  tree iter = TYPE_FIELDS (struc);\n+  if (iter == NULL_TREE)\n+\t  return false;\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (iter)))\n+\t  return true;\n+\n+  tree last_field;\n+  while (iter != NULL_TREE)\n+    {\n+      last_field = iter;\n+      iter = DECL_CHAIN (iter);\n+    }\n+\n+  if (last_field != NULL_TREE\n+      && TREE_CODE (TREE_TYPE (last_field)) == ARRAY_TYPE)\n+\t  return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the lhs and rhs of an assignment have different types.  */\n+\n+static bool\n+is_any_cast_p (const gimple *stmt)\n+{\n+  if (const gassign *assign = dyn_cast<const gassign *>(stmt))\n+    return gimple_assign_cast_p (assign)\n+\t   || !pending_diagnostic::same_tree_p (\n+\t\t  TREE_TYPE (gimple_assign_lhs (assign)),\n+\t\t  TREE_TYPE (gimple_assign_rhs1 (assign)));\n+  else if (const gcall *call = dyn_cast<const gcall *>(stmt))\n+    {\n+      tree lhs = gimple_call_lhs (call);\n+      return lhs != NULL_TREE && !pending_diagnostic::same_tree_p (\n+\t\t\t\t    TREE_TYPE (gimple_call_lhs (call)),\n+\t\t\t\t    gimple_call_return_type (call));\n+    }\n+\n+  return false;\n+}\n+\n+/* On pointer assignments, check whether the buffer size of\n+   RHS_SVAL is compatible with the type of the LHS_REG.\n+   Use a non-null CTXT to report allocation size warnings.  */\n+\n+void\n+region_model::check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n+\t\t\t\t region_model_context *ctxt) const\n+{\n+  if (!ctxt || ctxt->get_stmt () == NULL)\n+    return;\n+  /* Only report warnings on assignments that actually change the type.  */\n+  if (!is_any_cast_p (ctxt->get_stmt ()))\n+    return;\n+\n+  const region_svalue *reg_sval = dyn_cast <const region_svalue *> (rhs_sval);\n+  if (!reg_sval)\n+    return;\n+\n+  tree pointer_type = lhs_reg->get_type ();\n+  if (pointer_type == NULL_TREE || !POINTER_TYPE_P (pointer_type))\n+    return;\n+\n+  tree pointee_type = TREE_TYPE (pointer_type);\n+  /* Make sure that the type on the left-hand size actually has a size.  */\n+  if (pointee_type == NULL_TREE || VOID_TYPE_P (pointee_type)\n+      || TYPE_SIZE_UNIT (pointee_type) == NULL_TREE)\n+    return;\n+\n+  /* Bail out early on pointers to structs where we can\n+     not deduce whether the buffer size is compatible.  */\n+  bool is_struct = RECORD_OR_UNION_TYPE_P (pointee_type);\n+  if (is_struct && struct_or_union_with_inheritance_p (pointee_type))\n+    return;\n+\n+  tree pointee_size_tree = size_in_bytes (pointee_type);\n+  /* We give up if the type size is not known at compile-time or the\n+     type size is always compatible regardless of the buffer size.  */\n+  if (TREE_CODE (pointee_size_tree) != INTEGER_CST\n+      || integer_zerop (pointee_size_tree)\n+      || integer_onep (pointee_size_tree))\n+    return;\n+\n+  const region *rhs_reg = reg_sval->get_pointee ();\n+  const svalue *capacity = get_capacity (rhs_reg);\n+  switch (capacity->get_kind ())\n+    {\n+    case svalue_kind::SK_CONSTANT:\n+      {\n+\tconst constant_svalue *cst_cap_sval\n+\t\t= as_a <const constant_svalue *> (capacity);\n+\ttree cst_cap = cst_cap_sval->get_constant ();\n+\tif (!capacity_compatible_with_type (cst_cap, pointee_size_tree,\n+\t\t\t\t\t    is_struct))\n+\t  ctxt->warn (new dubious_allocation_size (lhs_reg, rhs_reg,\n+\t\t\t\t\t\t   cst_cap));\n+      }\n+      break;\n+    default:\n+      {\n+\tif (!is_struct)\n+\t  {\n+\t    size_visitor v (pointee_size_tree, capacity, m_constraints);\n+\t    if (!v.get_result ())\n+\t      {\n+\t\ttree expr = get_representative_tree (capacity);\n+\t\tctxt->warn (new dubious_allocation_size (lhs_reg, rhs_reg,\n+\t\t\t    expr));\n+\t      }\n+\t  }\n+      break;\n+      }\n+    }\n+}\n+\n /* Set the value of the region given by LHS_REG to the value given\n    by RHS_SVAL.\n    Use CTXT to report any warnings associated with writing to LHS_REG.  */\n@@ -2810,6 +3178,8 @@ region_model::set_value (const region *lhs_reg, const svalue *rhs_sval,\n   gcc_assert (lhs_reg);\n   gcc_assert (rhs_sval);\n \n+  check_region_size (lhs_reg, rhs_sval, ctxt);\n+\n   check_region_for_write (lhs_reg, ctxt);\n \n   m_store.set_value (m_mgr->get_store_manager(), lhs_reg, rhs_sval,"}, {"sha": "6dda43f5658b327d0932b7c0a4782f5fdd1e147d", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -865,6 +865,8 @@ class region_model\n \t\t\t       region_model_context *ctxt) const;\n   void check_region_for_read (const region *src_reg,\n \t\t\t      region_model_context *ctxt) const;\n+  void check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n+\t\t\t  region_model_context *ctxt) const;\n \n   void check_call_args (const call_details &cd) const;\n   void check_external_function_for_access_attr (const gcall *call,"}, {"sha": "7bad3cea31b4c07ecc3716b0c57941f8416df036", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -732,8 +732,8 @@ region_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n region_svalue::accept (visitor *v) const\n {\n-  v->visit_region_svalue (this);\n   m_reg->accept (v);\n+  v->visit_region_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for region_svalue.  */\n@@ -1031,8 +1031,8 @@ initial_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n initial_svalue::accept (visitor *v) const\n {\n-  v->visit_initial_svalue (this);\n   m_reg->accept (v);\n+  v->visit_initial_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for initial_svalue.  */\n@@ -1123,8 +1123,8 @@ unaryop_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n unaryop_svalue::accept (visitor *v) const\n {\n-  v->visit_unaryop_svalue (this);\n   m_arg->accept (v);\n+  v->visit_unaryop_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for unaryop_svalue.  */\n@@ -1225,9 +1225,9 @@ binop_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n binop_svalue::accept (visitor *v) const\n {\n-  v->visit_binop_svalue (this);\n   m_arg0->accept (v);\n   m_arg1->accept (v);\n+  v->visit_binop_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for binop_svalue.  */\n@@ -1283,9 +1283,9 @@ sub_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n sub_svalue::accept (visitor *v) const\n {\n-  v->visit_sub_svalue (this);\n   m_parent_svalue->accept (v);\n   m_subregion->accept (v);\n+  v->visit_sub_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for sub_svalue.  */\n@@ -1352,8 +1352,8 @@ repeated_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n repeated_svalue::accept (visitor *v) const\n {\n-  v->visit_repeated_svalue (this);\n   m_inner_svalue->accept (v);\n+  v->visit_repeated_svalue (this);\n }\n \n /* Implementation of svalue::all_zeroes_p for repeated_svalue.  */\n@@ -1494,8 +1494,8 @@ bits_within_svalue::maybe_fold_bits_within (tree type,\n void\n bits_within_svalue::accept (visitor *v) const\n {\n-  v->visit_bits_within_svalue (this);\n   m_inner_svalue->accept (v);\n+  v->visit_bits_within_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for bits_within_svalue.  */\n@@ -1544,9 +1544,9 @@ widening_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n widening_svalue::accept (visitor *v) const\n {\n-  v->visit_widening_svalue (this);\n   m_base_sval->accept (v);\n   m_iter_sval->accept (v);\n+  v->visit_widening_svalue (this);\n }\n \n /* Attempt to determine in which direction this value is changing\n@@ -1711,8 +1711,8 @@ unmergeable_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n unmergeable_svalue::accept (visitor *v) const\n {\n-  v->visit_unmergeable_svalue (this);\n   m_arg->accept (v);\n+  v->visit_unmergeable_svalue (this);\n }\n \n /* Implementation of svalue::implicitly_live_p vfunc for unmergeable_svalue.  */\n@@ -1776,13 +1776,13 @@ compound_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n compound_svalue::accept (visitor *v) const\n {\n-  v->visit_compound_svalue (this);\n   for (binding_map::iterator_t iter = m_map.begin ();\n        iter != m_map.end (); ++iter)\n     {\n       //(*iter).first.accept (v);\n       (*iter).second->accept (v);\n     }\n+  v->visit_compound_svalue (this);\n }\n \n /* Calculate what the complexity of a compound_svalue instance for MAP\n@@ -1903,8 +1903,8 @@ conjured_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n void\n conjured_svalue::accept (visitor *v) const\n {\n-  v->visit_conjured_svalue (this);\n   m_id_reg->accept (v);\n+  v->visit_conjured_svalue (this);\n }\n \n /* class asm_output_svalue : public svalue.  */\n@@ -1968,9 +1968,9 @@ asm_output_svalue::input_idx_to_asm_idx (unsigned input_idx) const\n void\n asm_output_svalue::accept (visitor *v) const\n {\n-  v->visit_asm_output_svalue (this);\n   for (unsigned i = 0; i < m_num_inputs; i++)\n     m_input_arr[i]->accept (v);\n+  v->visit_asm_output_svalue (this);\n }\n \n /* class const_fn_result_svalue : public svalue.  */\n@@ -2021,9 +2021,9 @@ const_fn_result_svalue::dump_input (pretty_printer *pp,\n void\n const_fn_result_svalue::accept (visitor *v) const\n {\n-  v->visit_const_fn_result_svalue (this);\n   for (unsigned i = 0; i < m_num_inputs; i++)\n     m_input_arr[i]->accept (v);\n+  v->visit_const_fn_result_svalue (this);\n }\n \n } // namespace ana"}, {"sha": "89c8dce3038263a67ed52f6a5b5898b63b54d11f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -9739,6 +9739,7 @@ This analysis is much more expensive than other GCC warnings.\n Enabling this option effectively enables the following warnings:\n \n @gccoptlist{ @gol\n+-Wanalyzer-allocation-size @gol\n -Wanalyzer-double-fclose @gol\n -Wanalyzer-double-free @gol\n -Wanalyzer-exposure-through-output-file @gol\n@@ -9791,6 +9792,19 @@ By default, the analysis silently stops if the code is too\n complicated for the analyzer to fully explore and it reaches an internal\n limit.  The @option{-Wanalyzer-too-complex} option warns if this occurs.\n \n+@item -Wno-analyzer-allocation-size\n+@opindex Wanalyzer-allocation-size\n+@opindex Wno-analyzer-allocation-size\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-allocation-size}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which a pointer to\n+a buffer is assigned to point at a buffer with a size that is not a\n+multiple of @code{sizeof (*pointer)}.\n+\n+See @url{https://cwe.mitre.org/data/definitions/131.html, CWE-131: Incorrect Calculation of Buffer Size}.\n+\n @item -Wno-analyzer-double-fclose\n @opindex Wanalyzer-double-fclose\n @opindex Wno-analyzer-double-fclose"}, {"sha": "4fc2bf75d6cb47c0deeea75f70d3219daf2ae6c3", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-1.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-1.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -0,0 +1,116 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* Tests with constant buffer sizes.  */\n+\n+void test_1 (void)\n+{\n+  short *ptr = malloc (21 * sizeof (short));\n+  free (ptr);\n+}\n+\n+void test_2 (void)\n+{\n+  int *ptr = malloc (21 * sizeof (short)); /* { dg-line malloc2 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"\\\\d+ bytes\" \"note\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc2 } */\n+}\n+\n+void test_3 (void)\n+{\n+  void *ptr = malloc (21 * sizeof (short));\n+  short *sptr = (short *)ptr;\n+  free (sptr);\n+}\n+\n+void test_4 (void)\n+{\n+  void *ptr = malloc (21 * sizeof (short)); /* { dg-message \"\\\\d+ bytes\" } */\n+  int *iptr = (int *)ptr; /* { dg-line assign4 } */\n+  free (iptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign4 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign4 } */\n+}\n+\n+void test_5 (void)\n+{\n+  int user_input;\n+  scanf(\"%i\", &user_input);\n+  int n;\n+  if (user_input == 0)\n+    n = 21 * sizeof (short);\n+  else\n+    n = 42 * sizeof (short);\n+  void *ptr = malloc (n);\n+  short *sptr = (short *)ptr;\n+  free (sptr);\n+}\n+\n+void test_6 (void)\n+{\n+  int user_input;\n+  scanf(\"%i\", &user_input);\n+  int n;\n+  if (user_input == 0)\n+    n = 21 * sizeof (short);\n+  else\n+    n = 42 * sizeof (short);\n+  void *ptr = malloc (n); /* { dg-message \"\" \"note\" } */\n+                          /* ^^^ on widening_svalues no expr is returned\n+                                 by get_representative_tree at the moment.  */ \n+  int *iptr = (int *)ptr; /* { dg-line assign6 } */\n+  free (iptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign6 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign6 } */\n+}\n+\n+void test_7 (void)\n+{\n+  int user_input;\n+  scanf(\"%i\", &user_input);\n+  int n;\n+  if (user_input == 0)\n+    n = 1;\n+  else if (user_input == 2)\n+    n = 5;\n+  else\n+    n = 7;\n+  /* n is an unknown_svalue at this point.  */\n+  void *ptr = malloc (n);\n+  int *iptr = (int *)ptr;\n+  free (iptr);\n+}\n+\n+void *create_buffer (int n)\n+{\n+  return malloc(n);\n+}\n+\n+void test_8 (void) \n+{\n+  int *buf = create_buffer(4 * sizeof (int));\n+  free (buf);\n+}\n+\n+void test_9 (void) \n+{\n+  /* FIXME: At the moment, region_model::set_value (lhs, <return_value>)\n+     is called at the src_node of the return edge. This edge has no stmts\n+     associated with it, leading to a rejection of the warning inside\n+     impl_region_model_context::warn. To ensure that the indentation\n+     in the diagnostic is right, the warning has to be emitted on an EN\n+     that is after the return edge.  */\n+  int *buf = create_buffer(42); /* { dg-warning \"\" \"\" { xfail *-*-* } } */\n+  free (buf);\n+}\n+\n+void test_10 (int n)\n+{\n+  char *ptr = malloc (7 * n);\n+  free (ptr);\n+}\n\\ No newline at end of file"}, {"sha": "37bbbac87c54963468201ec0455261e633618221", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-2.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -0,0 +1,155 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* Tests with symbolic buffer sizes.  */\n+\n+void test_1 (int n)\n+{\n+  short *ptr = malloc (n * sizeof (short));\n+  free (ptr);\n+}\n+\n+void test_2 (int n)\n+{\n+  int *ptr = malloc (n * sizeof (short)); /* { dg-line malloc2 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"'\\[a-z0-9\\\\*\\\\(\\\\)\\\\s\\]*' bytes\" \"note\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc2 } */\n+}\n+\n+void test_3 (int n)\n+{\n+  void *ptr = malloc (n * sizeof (short));\n+  short *sptr = (short *)ptr;\n+  free (sptr);\n+}\n+\n+void test_4 (int n)\n+{\n+  void *ptr = malloc (n * sizeof (short)); /* { dg-message \"'\\[a-z0-9\\\\*\\\\(\\\\)\\\\s\\]*'\" \"note\" } */\n+  int *iptr = (int *)ptr; /* { dg-line assign4 } */\n+  free (iptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign4 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign4 } */\n+}\n+\n+void test_5 (void)\n+{\n+  int user_input;\n+  scanf(\"%i\", &user_input);\n+  int n;\n+  if (user_input == 0)\n+    n = 3 * user_input * sizeof (short);\n+  else\n+    n = 5 * user_input * sizeof (short);\n+  void *ptr = malloc (n);\n+  short *sptr = (short *)ptr;\n+  free (sptr);\n+}\n+\n+void test_6 (void)\n+{\n+  int user_input;\n+  scanf(\"%i\", &user_input);\n+  int n;\n+  if (user_input == 0)\n+    n = user_input;\n+  else if (user_input == 2)\n+    n = user_input * 3;\n+  else\n+    n = user_input * 5;\n+  /* n is an unknown_svalue at this point.  */\n+  void *ptr = malloc (n);\n+  int *iptr = (int *)ptr;\n+  free (iptr);\n+}\n+\n+void *create_buffer(int n)\n+{\n+  return malloc(n);\n+}\n+\n+void test_7(int n) \n+{\n+  int *buf = create_buffer(n * sizeof (int));\n+  free (buf);\n+}\n+\n+void test_8(int n) \n+{\n+  /* FIXME: At the moment, region_model::set_value (lhs, <return_value>)\n+     is called at the src_node of the return edge. This edge has no stmts\n+     associated with it, leading to a rejection of the warning inside\n+     impl_region_model_context::warn. To ensure that the indentation\n+     in the diagnostic is right, the warning has to be emitted on an EN\n+     that is after the return edge.  */\n+  int *buf = create_buffer(n * sizeof(short)); /* { dg-warning \"\" \"\" { xfail *-*-* } } */\n+  free (buf);\n+}\n+\n+void test_9 (void)\n+{\n+  int n;\n+  scanf(\"%i\", &n);\n+  /* n is a conjured_svalue.  */\n+  void *ptr = malloc (n); /* { dg-message \"'n' bytes\" \"note\" } */\n+  int *iptr = (int *)ptr; /* { dg-line assign9 } */\n+  free (iptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign9 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign9 } */\n+}\n+\n+void test_11 (void)\n+{\n+  int n;\n+  scanf(\"%i\", &n);\n+  void *ptr = malloc (n);\n+  if (n == sizeof (int))\n+    {\n+      /* n is a conjured_svalue but guarded such that we\n+         know the value is a multiple of sizeof (*iptr).  */\n+      int *iptr = (int *)ptr;\n+      free (iptr);\n+    }\n+  else\n+    free (ptr);\n+}\n+\n+void test_12 (void)\n+{\n+  int n;\n+  scanf(\"%i\", &n);\n+  void *ptr = malloc (n); /* { dg-message \"'n' bytes\" } */\n+  if (n == 5)\n+    {\n+      /* n is a conjured_svalue but guarded such that we\n+         know the value isn't a multiple of sizeof (*iptr).  */\n+      int *iptr = (int *)ptr; /* { dg-line assign12 } */\n+      free (iptr);\n+    }\n+  else\n+    free (ptr);\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign12 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign12 } */\n+}\n+\n+void test_13 (void)\n+{\n+  int n;\n+  scanf(\"%i\", &n);\n+  void *ptr = malloc (n);\n+  if (n == n * n)\n+    {\n+      /* n is a conjured_svalue but guarded such that we don't have an\n+         equivalence class for it. In such cases, we assume that the\n+         condition ensures that the value is okay.  */\n+      int *iptr = (int *)ptr;\n+      free (iptr);\n+    }\n+  else\n+    free (ptr);\n+}"}, {"sha": "fdc1c56b7eea572804221552385e4ba67f634395", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -0,0 +1,45 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* CWE-131 example 5 */\n+void test_1 (void) \n+{\n+  int *id_sequence = (int *) malloc (3); /* { dg-line malloc1 } */\n+  if (id_sequence == NULL) exit (1);\n+\n+  id_sequence[0] = 13579;\n+  id_sequence[1] = 24680;\n+  id_sequence[2] = 97531;\n+\n+  free (id_sequence);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc1 } */\n+  /* { dg-message \"\\\\d+ bytes\" \"note\" { target *-*-* } malloc1 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc1 } */\n+}\n+\n+void test_2 (void)\n+{\n+  int *ptr = malloc (10 + sizeof(int)); /* { dg-line malloc2 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"\\\\d+ bytes\" \"note\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc2 } */\n+}\n+\n+void test_3 (int n)\n+{\n+  int *ptr = malloc (n + sizeof (int)); /* { dg-line malloc3 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc3 } */\n+  /* { dg-message \"'\\[a-z0-9\\\\+\\\\(\\\\)\\\\s\\]*' bytes\" \"note\" { target *-*-* } malloc3 } */\n+  /* { dg-message \"'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc3 } */\n+}\n+\n+void test_4 (int n, int m)\n+{\n+  int *ptr = malloc ((n + m) * sizeof (int));\n+  free (ptr);\n+}"}, {"sha": "e475c1586a315cf81aa3f8188fdae6c7b6823d33", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-4.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-4.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -0,0 +1,60 @@\n+#include <stdlib.h>\n+\n+/* Tests related to structs.  */\n+\n+struct base {\n+  int i;\n+};\n+\n+struct sub {\n+  struct base b;\n+  int j;\n+};\n+\n+struct var_len {\n+  int i;\n+  char arr[];\n+};\n+\n+\n+void test_1 (void)\n+{\n+  struct base *ptr = malloc (5 * sizeof (struct base));\n+  free (ptr);\n+}\n+\n+void test_2 (void)\n+{\n+  long *ptr = malloc (5 * sizeof (struct base));  /* { dg-line malloc2 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"\\\\d+ bytes\" \"note\" { target *-*-* } malloc2 } */\n+  /* { dg-message \"'long (int)? \\\\*' here; 'sizeof \\\\(long (int)?\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc2 } */\n+}\n+\n+void test_3 (void)\n+{\n+  /* Even though 10 bytes is not a multiple of 4, we do not warn to prevent\n+     a false positive in case s is the base struct of a struct inheritance.  */\n+  struct base *ptr = malloc (10);\n+  free (ptr);\n+}\n+\n+void test_4 (void)\n+{\n+  struct var_len *ptr = malloc (10);\n+  free (ptr);\n+}\n+\n+void test_5 (void)\n+{\n+  /* For constant sizes, we warn if the buffer\n+     is too small to hold a single struct.  */\n+  struct base *ptr = malloc (2);  /* { dg-line malloc5 } */\n+  free (ptr);\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } malloc5 } */\n+  /* { dg-message \"\\\\d+ bytes\" \"note\" { target *-*-* } malloc5 } */\n+  /* { dg-message \"'struct base \\\\*' here; 'sizeof \\\\(struct base\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } malloc5 } */\n+}"}, {"sha": "ae7e1074ebba3ae237a98c4242f0ca869d8be7d4", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-5.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-5.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -0,0 +1,36 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* Tests related to statically allocated buffers.  */\n+\n+typedef struct a {\n+  short s;\n+} a;\n+\n+int *test_1 (void)\n+{\n+  a A; /* { dg-message \"\\\\d+ bytes\" \"note\" } */\n+  A.s = 1;\n+  int *ptr = (int *) &A; /* { dg-line assign1 } */\n+  return ptr;\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign1 } */\n+  /* { dg-message \"assigned to 'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign1 } */\n+}\n+\n+int *test2 (void)\n+{\n+  char arr[sizeof (int)];\n+  int *ptr = (int *)arr;\n+  return ptr;\n+}\n+\n+int *test3 (void)\n+{\n+  char arr[sizeof (short)]; /* { dg-message \"\\\\d+ bytes\" \"note\" } */\n+  int *ptr = (int *)arr; /* { dg-line assign3 } */\n+  return ptr;\n+\n+  /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size \\\\\\[CWE-131\\\\\\]\" \"warning\" { target *-*-* } assign3 } */\n+  /* { dg-message \"assigned to 'int \\\\*' here; 'sizeof \\\\(int\\\\)' is '\\\\d+'\" \"note\" { target *-*-* } assign3 } */\n+}"}, {"sha": "aedf0464dc937d6b90f6aba04b865fc6b0fae0c9", "filename": "gcc/testsuite/gcc.dg/analyzer/pr96639.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96639.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c3bb379f515b27268d08e62b4b3e5d7200b437/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96639.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96639.c?ref=e6c3bb379f515b27268d08e62b4b3e5d7200b437", "patch": "@@ -3,7 +3,7 @@ void *calloc (__SIZE_TYPE__, __SIZE_TYPE__);\n int\n x7 (void)\n {\n-  int **md = calloc (1, 1);\n+  int **md = calloc (1, sizeof (void *));\n \n   return md[0][0]; /* { dg-warning \"possibly-NULL\" \"unchecked deref\" } */\n   /* { dg-warning \"leak of 'md'\" \"leak\" { target *-*-* } .-1 } */"}]}