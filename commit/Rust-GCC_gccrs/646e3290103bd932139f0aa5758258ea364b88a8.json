{"sha": "646e3290103bd932139f0aa5758258ea364b88a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ2ZTMyOTAxMDNiZDkzMjEzOWYwYWE1NzU4MjU4ZWEzNjRiODhhOA==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-02-28T21:28:53Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-02-28T21:28:53Z"}, "message": "2004-02-28  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/ObjectInputStream.java\n\t(readClassDescriptor): Keep elements of the mapping non null.\n\t(checkTypeConsistency): New method.\n\t(readFields): Fixed main loop and base logic. Small reindentation.\n\t* java/io/ObjectStreamField.java\n\t(lookupField): New method to update the field reference.\n\t(checkFieldType): New method.\n\t* java/io/ObjectStreamClass.java\n\t(setClass, setFields): Call lookupField when building the field\n\tdatabase. Check the real field type.\n\nFrom-SVN: r78627", "tree": {"sha": "d0c8fb679a0816081a9e684d6257cbb4ca08a0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0c8fb679a0816081a9e684d6257cbb4ca08a0e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/646e3290103bd932139f0aa5758258ea364b88a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646e3290103bd932139f0aa5758258ea364b88a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646e3290103bd932139f0aa5758258ea364b88a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646e3290103bd932139f0aa5758258ea364b88a8/comments", "author": null, "committer": null, "parents": [{"sha": "ca67f278502e6f32aab0dd6ba4715762691f690d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca67f278502e6f32aab0dd6ba4715762691f690d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca67f278502e6f32aab0dd6ba4715762691f690d"}], "stats": {"total": 490, "additions": 317, "deletions": 173}, "files": [{"sha": "b46441a5dd475f583bd95003ec0f26fdda7358bc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=646e3290103bd932139f0aa5758258ea364b88a8", "patch": "@@ -1,3 +1,16 @@\n+2004-02-28  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(readClassDescriptor): Keep elements of the mapping non null.\n+\t(checkTypeConsistency): New method.\n+\t(readFields): Fixed main loop and base logic. Small reindentation.\n+\t* java/io/ObjectStreamField.java\n+\t(lookupField): New method to update the field reference.\n+\t(checkFieldType): New method.\n+\t* java/io/ObjectStreamClass.java\n+\t(setClass, setFields): Call lookupField when building the field\n+\tdatabase. Check the real field type.\n+\n 2004-02-28  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/ByteOrder.java"}, {"sha": "3c2dec97010d534f8c6010558a31c172e67fce21", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 184, "deletions": 128, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=646e3290103bd932139f0aa5758258ea364b88a8", "patch": "@@ -1,6 +1,5 @@\n /* ObjectInputStream.java -- Class used to read serialized objects\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -412,6 +411,64 @@ public final Object readObject() throws ClassNotFoundException, IOException\n     return ret_val;\n   }\n \n+  /**\n+   * This method makes a partial check of types for the fields\n+   * contained given in arguments. It checks primitive types of\n+   * fields1 against non primitive types of fields2. This method \n+   * assumes the two lists has already been sorted according to \n+   * the Java specification.\n+   *\n+   * @param name Name of the class owning the given fields.\n+   * @param fields1 First list to check.\n+   * @param fields2 Second list to check.\n+   * @throws InvalidClassException if a field in fields1, which has a primitive type, is a present\n+   * in the non primitive part in fields2.\n+   */\n+  private void checkTypeConsistency(String name, ObjectStreamField[] fields1, ObjectStreamField[] fields2)\n+    throws InvalidClassException\n+    int nonPrimitive = 0;\n+    \n+    for (nonPrimitive = 0; \n+\t nonPrimitive < fields1.length\n+\t   && fields1[nonPrimitive].isPrimitive(); nonPrimitive++)\n+      {\n+      }\n+\n+    if (nonPrimitive == fields1.length)\n+      return;\n+    \n+    int i = 0;\n+    ObjectStreamField f1;\n+    ObjectStreamField f2;\n+    \n+    while (i < fields2.length\n+\t   && nonPrimitive < fields1.length)\n+      {\n+\tf1 = fields1[nonPrimitive];\n+\tf2 = fields2[i];\n+\t\n+\tif (!f2.isPrimitive())\n+\t  break;\n+\n+\tint compVal = f1.getName().compareTo (f2.getName());\n+\n+\tif (compVal < 0)\n+\t  {\n+\t    nonPrimitive++;\n+\t  }\n+\telse if (compVal > 0)\n+\t  {\n+\t    i++;\n+\t  }\n+\telse\n+\t  {\n+\t    throw new InvalidClassException\n+\t      (\"invalid field type for \" + f2.getName() +\n+\t       \" in class \" + name);\n+\t  }\n+      }\n+  }\n+\n   /**\n    * This method reads a class descriptor from the real input stream\n    * and use these data to create a new instance of ObjectStreamClass.\n@@ -497,6 +554,15 @@ protected ObjectStreamClass readClassDescriptor()\n     int real_idx = 0;\n     int map_idx = 0;\n \n+    /*\n+     * Check that there is no type inconsistencies between the lists.\n+     * A special checking must be done for the two groups: primitive types and\n+     * not primitive types. \n+     */\n+    checkTypeConsistency(name, real_fields, stream_fields);\n+    checkTypeConsistency(name, stream_fields, real_fields);\n+\n+    \n     while (stream_idx < stream_fields.length\n \t   || real_idx < real_fields.length)\n       {\n@@ -514,7 +580,7 @@ else if (real_idx == real_fields.length)\n \telse\n \t  {\n \t    int comp_val =\n-\t\treal_fields[real_idx].compareTo (stream_fields[stream_idx]);\n+\t      real_fields[real_idx].compareTo (stream_fields[stream_idx]);\n \n \t    if (comp_val < 0)\n \t      {\n@@ -528,21 +594,13 @@ else if (comp_val > 0)\n \t      {\n \t\tstream_field = stream_fields[stream_idx++];\n \t\treal_field = real_fields[real_idx++];\n-\t\tif(stream_field.getType() != real_field.getType())\n-\t\t    throw new InvalidClassException\n-\t\t\t(\"invalid field type for \" + real_field.getName() +\n-\t\t\t\" in class \" + name);\n+\t\tif (stream_field.getType() != real_field.getType())\n+\t\t  throw new InvalidClassException\n+\t\t    (\"invalid field type for \" + real_field.getName() +\n+\t\t     \" in class \" + name);\n \t      }\n \t  }\n-\tif (stream_field != null)\n-\t  {\n-\t    if (stream_field.getOffset() < 0)\n-\t\tstream_field = null;\n-\t    else if (!stream_field.isToSet())\n-\t\treal_field = null;\n-\t  }\n-\tif (real_field != null && !real_field.isToSet())\n-\t    real_field = null;\n+\n \t/* If some of stream_fields does not correspond to any of real_fields,\n \t * or the opposite, then fieldmapping will go short.\n \t */\n@@ -551,7 +609,7 @@ else if (!stream_field.isToSet())\n \t    ObjectStreamField[] newfieldmapping =\n \t      new ObjectStreamField[fieldmapping.length + 2];\n \t    System.arraycopy(fieldmapping, 0,\n-\t      newfieldmapping, 0, fieldmapping.length);\n+\t\t\t     newfieldmapping, 0, fieldmapping.length);\n \t    fieldmapping = newfieldmapping;\n \t  }\n \tfieldmapping[map_idx++] = stream_field;\n@@ -1577,121 +1635,119 @@ private void readFields (Object obj, ObjectStreamClass stream_osc)\n       {\n \tObjectStreamField stream_field = fields[i];\n \tObjectStreamField real_field = fields[i + 1];\n-\tif(stream_field != null || real_field != null)\n-\t  {\n-\t    boolean read_value = stream_field != null;\n-\t    boolean set_value = real_field != null;\n-\t    String field_name;\n-\t    char type;\n-\t    if (stream_field != null)\n-\t      {\n-\t\tfield_name = stream_field.getName();\n-\t\ttype = stream_field.getTypeCode();\n-\t      }\n-\t    else\n-\t      {\n-\t\tfield_name = real_field.getName();\n-\t\ttype = real_field.getTypeCode();\n-\t      }\n+\tboolean read_value = (stream_field != null && stream_field.getOffset() >= 0 && stream_field.isToSet());\n+\tboolean set_value = (real_field != null && real_field.isToSet());\n+\tString field_name;\n+\tchar type;\n \n-\t    switch(type)\n-\t      {\n-\t\tcase 'Z':\n-\t\t  {\n-\t\t    boolean value =\n-\t\t\tread_value ? this.realInputStream.readBoolean() : false;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setBooleanField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'B':\n-\t\t  {\n-\t\t    byte value =\n-\t\t\tread_value ? this.realInputStream.readByte() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setByteField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'C':\n-\t\t  {\n-\t\t    char value =\n-\t\t\tread_value ? this.realInputStream.readChar(): 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setCharField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'D':\n-\t\t  {\n-\t\t    double value =\n-\t\t\tread_value ? this.realInputStream.readDouble() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setDoubleField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'F':\n-\t\t  {\n-\t\t    float value =\n-\t\t\tread_value ? this.realInputStream.readFloat() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setFloatField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'I':\n-\t\t  {\n-\t\t    int value =\n-\t\t\tread_value ? this.realInputStream.readInt() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setIntField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'J':\n-\t\t  {\n-\t\t    long value =\n-\t\t\tread_value ? this.realInputStream.readLong() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setLongField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'S':\n-\t\t  {\n-\t\t    short value =\n-\t\t\tread_value ? this.realInputStream.readShort() : 0;\n-\t\t    if (dump && read_value && set_value)\n-\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\t    if (set_value)\n-\t\t\treal_field.setShortField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tcase 'L':\n-\t\tcase '[':\n-\t\t  {\n-\t\t    Object value =\n-\t\t\tread_value ? readObject() : null;\n-\t\t    if (set_value)\n-\t\t\treal_field.setObjectField(obj, value);\n-\t\t    break;\n-\t\t  }\n-\t\tdefault:\n-\t\t    throw new InternalError(\"Invalid type code: \" + type);\n-\t      }\n+\tif (stream_field != null)\n+\t  {\n+\t    field_name = stream_field.getName();\n+\t    type = stream_field.getTypeCode();\n+\t  }\n+\telse\n+\t  {\n+\t    field_name = real_field.getName();\n+\t    type = real_field.getTypeCode();\n+\t  }\n+\t\n+\tswitch(type)\n+\t  {\n+\t  case 'Z':\n+\t    {\n+\t      boolean value =\n+\t\tread_value ? this.realInputStream.readBoolean() : false;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setBooleanField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'B':\n+\t    {\n+\t      byte value =\n+\t\tread_value ? this.realInputStream.readByte() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setByteField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'C':\n+\t    {\n+\t      char value =\n+\t\tread_value ? this.realInputStream.readChar(): 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setCharField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'D':\n+\t    {\n+\t      double value =\n+\t\tread_value ? this.realInputStream.readDouble() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setDoubleField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'F':\n+\t    {\n+\t      float value =\n+\t\tread_value ? this.realInputStream.readFloat() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setFloatField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'I':\n+\t    {\n+\t      int value =\n+\t\tread_value ? this.realInputStream.readInt() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setIntField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'J':\n+\t    {\n+\t      long value =\n+\t\tread_value ? this.realInputStream.readLong() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setLongField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'S':\n+\t    {\n+\t      short value =\n+\t\tread_value ? this.realInputStream.readShort() : 0;\n+\t      if (dump && read_value && set_value)\n+\t\tdumpElementln(\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\treal_field.setShortField(obj, value);\n+\t      break;\n+\t    }\n+\t  case 'L':\n+\t  case '[':\n+\t    {\n+\t      Object value =\n+\t\tread_value ? readObject() : null;\n+\t      if (set_value)\n+\t\treal_field.setObjectField(obj, value);\n+\t      break;\n+\t    }\n+\t  default:\n+\t    throw new InternalError(\"Invalid type code: \" + type);\n \t  }\n       }\n   }\n-\n+  \n   // Toggles writing primitive data to block-data buffer.\n   private boolean setBlockDataMode (boolean on)\n   {"}, {"sha": "d080f280ba907a591ba9a6bd612b69066ec1c032", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=646e3290103bd932139f0aa5758258ea364b88a8", "patch": "@@ -327,7 +327,7 @@ void setClass(Class cl, ObjectStreamClass superClass) throws InvalidClassExcepti\n \ti = 0; j = 0; k = 0;\n \twhile (i < fields.length && j < exportedFields.length)\n \t  {\n-\t    int comp = fields[i].getName().compareTo(exportedFields[j].getName());\n+\t    int comp = fields[i].compareTo(exportedFields[j]);\n \n \t    if (comp < 0)\n \t      {\n@@ -344,10 +344,27 @@ else if (comp > 0)\n \t\tnewFieldList[k] = exportedFields[j];\n \t\tnewFieldList[k].setPersistent(true);\n \t\tnewFieldList[k].setToSet(false);\n+\t\ttry\n+\t\t  {\n+\t\t    newFieldList[k].lookupField(clazz);\n+\t\t    newFieldList[k].checkFieldType();\n+\t\t  }\n+\t\tcatch (NoSuchFieldException _)\n+\t\t  {\n+\t\t  }\n \t\tj++;\n \t      }\n \t    else\n \t      {\n+\t\ttry\n+\t\t  {\n+\t\t    exportedFields[j].lookupField(clazz);\n+\t\t    exportedFields[j].checkFieldType();\n+\t\t  }\n+\t\tcatch (NoSuchFieldException _)\n+\t\t  {\n+\t\t  }\n+\n \t\tif (!fields[i].getType().equals(exportedFields[j].getType()))\n \t\t  throw new InvalidClassException\n \t\t    (\"serialPersistentFields must be compatible with\" +\n@@ -554,6 +571,19 @@ public Object run()\n \t    if (fields != null)\n \t      {\n \t\tArrays.sort (fields);\n+\t\t// Retrieve field reference.\n+\t\tfor (int i=0; i < fields.length; i++)\n+\t\t  {\n+\t\t    try\n+\t\t      {\n+\t\t\tfields[i].lookupField(cl);\n+\t\t      }\n+\t\t    catch (NoSuchFieldException _)\n+\t\t      {\n+\t\t\tfields[i].setToSet(false);\n+\t\t      }\n+\t\t  }\n+\t\t\n \t\tcalculateOffsets();\n \t\treturn;\n \t      }\n@@ -798,7 +828,7 @@ private ObjectStreamField[] getSerialPersistentFields(Class clazz)\n \n     fieldsArray = new ObjectStreamField[ o.length ];\n     System.arraycopy(o, 0, fieldsArray, 0, o.length);\n-    \n+\n     return fieldsArray;\n   }\n "}, {"sha": "f4a866ed06753867b6e87a9b4998181aeff37fc0", "filename": "libjava/java/io/ObjectStreamField.java", "status": "modified", "additions": 88, "deletions": 43, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646e3290103bd932139f0aa5758258ea364b88a8/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=646e3290103bd932139f0aa5758258ea364b88a8", "patch": "@@ -41,6 +41,8 @@\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n import gnu.java.lang.reflect.TypeSignature;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n \n /**\n  * This class intends to describe the field of a class for the serialization\n@@ -99,7 +101,7 @@ public ObjectStreamField (String name, Class type, boolean unshared)\n  \n   /**\n    * There are many cases you can not get java.lang.Class from typename \n-   * if your context class loader cann not load it, then use typename to\n+   * if your context class loader cannot load it, then use typename to\n    * construct the field.\n    *\n    * @param name Name of the field to export.\n@@ -292,7 +294,7 @@ void setToSet(boolean toset)\n   }\n \n   /**\n-   * This methods returns true if the field is marked as to be\n+   * This method returns true if the field is marked as to be\n    * set.\n    *\n    * @return True if it is to be set, false in the other cases.\n@@ -303,109 +305,152 @@ boolean isToSet()\n     return toset;\n   }\n \n+  /**\n+   * This method searches for its field reference in the specified class\n+   * object. It requests privileges. If an error occurs the internal field\n+   * reference is not modified.\n+   *\n+   * @throws NoSuchFieldException if the field name does not exist in this class.\n+   * @throws SecurityException if there was an error requesting the privileges.\n+   */\n+  void lookupField(Class clazz) throws NoSuchFieldException, SecurityException\n+  {\n+    final Field f = clazz.getDeclaredField(name);\n+    \n+    AccessController.doPrivileged(new PrivilegedAction()\n+      {\n+\tpublic Object run()\n+\t{\n+\t  f.setAccessible(true);\n+\t  return null;\n+\t}\n+      });\n+    \n+    this.field = f;\n+  }\n+\n+  /**\n+   * This method check whether the field described by this\n+   * instance of ObjectStreamField is compatible with the\n+   * actual implementation of this field.\n+   *\n+   * @throws NullPointerException if this field does not exist\n+   * in the real class.\n+   * @throws InvalidClassException if the types are incompatible.\n+   */\n+  void checkFieldType() throws InvalidClassException\n+  {\n+    Class ftype = field.getType();\n+\n+    if (!ftype.isAssignableFrom(type))\n+      throw new InvalidClassException\n+\t(\"invalid field type for \" + name +\n+\t \" in class \" + field.getDeclaringClass());\n+  }\n+\n   public String toString ()\n   {\n     return \"ObjectStreamField< \" + type + \" \" + name + \" >\";\n   }\n \n   final void setBooleanField(Object obj, boolean val)\n   {\n-      try\n+    try\n       {\n-\t  field.setBoolean(obj, val);\n+\tfield.setBoolean(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setByteField(Object obj, byte val)\n   {\n-      try\n+    try\n       {\n-\t  field.setByte(obj, val);\n+\tfield.setByte(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setCharField(Object obj, char val)\n   {\n-      try\n+    try\n       {\n-\t  field.setChar(obj, val);\n+\tfield.setChar(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setShortField(Object obj, short val)\n   {\n-      try\n+    try\n       {\n-\t  field.setShort(obj, val);\n+\tfield.setShort(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setIntField(Object obj, int val)\n   {\n-      try\n+    try\n       {\n-\t  field.setInt(obj, val);\n+\tfield.setInt(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setLongField(Object obj, long val)\n   {\n-      try\n+    try\n       {\n-\t  field.setLong(obj, val);\n+\tfield.setLong(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setFloatField(Object obj, float val)\n   {\n-      try\n+    try\n       {\n-\t  field.setFloat(obj, val);\n+\tfield.setFloat(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setDoubleField(Object obj, double val)\n   {\n-      try\n+    try\n       {\n-\t  field.setDouble(obj, val);\n+\tfield.setDouble(obj, val);\n       }\n-      catch(IllegalAccessException x)\n+    catch(IllegalAccessException x)\n       {\n-\t  throw new InternalError(x.getMessage());\n+\tthrow new InternalError(x.getMessage());\n       }\n   }\n-\n+  \n   final void setObjectField(Object obj, Object val)\n-  {\n+  { \n     try\n       {\n \tfield.set(obj, val);"}]}