{"sha": "b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0MjE0ZmUyMjEwNzYxOGU3ZGQ3YzZhYmQzYmZmOTUyNmZjYjNlNQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-14T18:50:48Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-14T18:50:48Z"}, "message": "rs6000.h (RS6000_SAVE_AREA): Handle ABI_ELFv2.\n\ngcc/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/rs6000.h (RS6000_SAVE_AREA): Handle ABI_ELFv2.\n\t(RS6000_SAVE_TOC): Remove.\n\t(RS6000_TOC_SAVE_SLOT): New macro.\n\t* config/rs6000/rs6000.c (rs6000_parm_offset): New function.\n\t(rs6000_parm_start): Use it.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_emit_prologue): Use RS6000_TOC_SAVE_SLOT.\n\t(rs6000_emit_epilogue): Likewise.\n\t(rs6000_call_aix): Likewise.\n\t(rs6000_output_function_prologue): Do not save/restore r11\n\taround calling _mcount for ABI_ELFv2.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_reg_parm_stack_space):\n\tAdd prototype.\n\t* config/rs6000/rs6000.h (RS6000_REG_SAVE): Remove.\n\t(REG_PARM_STACK_SPACE): Call rs6000_reg_parm_stack_space.\n\t* config/rs6000/rs6000.c (rs6000_parm_needs_stack): New function.\n\t(rs6000_function_parms_need_stack): Likewise.\n\t(rs6000_reg_parm_stack_space): Likewise.\n\t(rs6000_function_arg): Do not replace BLKmode by Pmode when\n\treturning a register argument.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Michael Gschwind  <mkg@us.ibm.com>\n\n\t* config/rs6000/rs6000.h (FP_ARG_MAX_RETURN): New macro.\n\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n\t(FUNCTION_VALUE_REGNO_P): Use them.\n\t* config/rs6000/rs6000.c (TARGET_RETURN_IN_MSB): Define.\n\t(rs6000_return_in_msb): New function.\n\t(rs6000_return_in_memory): Handle ELFv2 homogeneous aggregates.\n\tHandle aggregates of up to 16 bytes for ELFv2.\n\t(rs6000_function_value): Handle ELFv2 homogeneous aggregates.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Michael Gschwind  <mkg@us.ibm.com>\n\n\t* config/rs6000/rs6000.h (AGGR_ARG_NUM_REG): Define.\n\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): New function.\n\t(rs6000_discover_homogeneous_aggregate): Likewise.\n\t(rs6000_function_arg_boundary): Handle homogeneous aggregates.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_function_arg): Likewise.\n\t(rs6000_arg_partial_bytes): Likewise.\n\t(rs6000_psave_function_arg): Handle BLKmode arguments.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Michael Gschwind  <mkg@us.ibm.com>\n\n\t* config/rs6000/rs6000.h (AGGR_ARG_NUM_REG): Define.\n\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): New function.\n\t(rs6000_discover_homogeneous_aggregate): Likewise.\n\t(rs6000_function_arg_boundary): Handle homogeneous aggregates.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_function_arg): Likewise.\n\t(rs6000_arg_partial_bytes): Likewise.\n\t(rs6000_psave_function_arg): Handle BLKmode arguments.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/rs6000/rs6000.c (machine_function): New member\n\tr2_setup_needed.\n\t(rs6000_emit_prologue): Set r2_setup_needed if necessary.\n\t(rs6000_output_mi_thunk): Set r2_setup_needed.\n\t(rs6000_output_function_prologue): Output global entry point\n\tprologue and local entry point marker if needed for ABI_ELFv2.\n\tOutput -mprofile-kernel code here.\n\t(output_function_profiler): Do not output -mprofile-kernel\n\tcode here; moved to rs6000_output_function_prologue.\n\t(rs6000_file_start): Output \".abiversion 2\" for ABI_ELFv2.\n\n\t(rs6000_emit_move): Do not handle dot symbols for ABI_ELFv2.\n\t(rs6000_output_function_entry): Likewise.\n\t(rs6000_assemble_integer): Likewise.\n\t(rs6000_elf_encode_section_info): Likewise.\n\t(rs6000_elf_declare_function_name): Do not create dot symbols\n\tor .opd section for ABI_ELFv2.\n\n\t(rs6000_trampoline_size): Update for ABI_ELFv2 trampolines.\n\t(rs6000_trampoline_init): Likewise.\n\t(rs6000_elf_file_end): Call file_end_indicate_exec_stack\n\tfor ABI_ELFv2.\n\n\t(rs6000_call_aix): Handle ELFv2 indirect calls.  Do not check\n\tfor function descriptors in ABI_ELFv2.\n\n\t* config/rs6000/rs6000.md (\"*call_indirect_aix<mode>\"): Support\n\ton ABI_AIX only, not ABI_ELFv2.\n\t(\"*call_value_indirect_aix<mode>\"): Likewise.\n\t(\"*call_indirect_elfv2<mode>\"): New pattern.\n\t(\"*call_value_indirect_elfv2<mode>\"): Likewise.\n\n\t* config/rs6000/predicates.md (\"symbol_ref_operand\"): Do not\n\tcheck for function descriptors in ABI_ELFv2.\n\t(\"current_file_function_operand\"): Likewise.\n\n\t* config/rs6000/ppc-asm.h [__powerpc64__ && _CALL_ELF == 2]:\n\t(toc): Undefine.\n\t(FUNC_NAME): Define ELFv2 variant.\n\t(JUMP_TARGET): Likewise.\n\t(FUNC_START): Likewise.\n\t(HIDDEN_FUNC): Likewise.\n\t(FUNC_END): Likeiwse.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config.gcc [powerpc*-*-* | rs6000-*-*]: Support --with-abi=elfv1\n\tand --with-abi=elfv2.\n\t* config/rs6000/option-defaults.h (OPTION_DEFAULT_SPECS): Add \"abi\".\n\t* config/rs6000/rs6000.opt (mabi=elfv1): New option.\n\t(mabi=elfv2): Likewise.\n\t* config/rs6000/rs6000-opts.h (enum rs6000_abi): Add ABI_ELFv2.\n\t* config/rs6000/linux64.h (DEFAULT_ABI): Do not hard-code to AIX_ABI\n\tif !RS6000_BI_ARCH.\n\t(ELFv2_ABI_CHECK): New macro.\n\t(SUBSUBTARGET_OVERRIDE_OPTIONS): Use it to decide whether to set\n\trs6000_current_abi to ABI_AIX or ABI_ELFv2.\n\t(GLIBC_DYNAMIC_LINKER64): Support ELFv2 ld.so version.\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Predefine\n\t_CALL_ELF and __STRUCT_PARM_ALIGN__ if appropriate.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Handle ABI_ELFv2.\n\t(debug_stack_info): Likewise.\n\t(rs6000_file_start): Treat ABI_ELFv2 the same as ABI_AIX.\n\t(rs6000_legitimize_tls_address): Likewise.\n\t(rs6000_conditional_register_usage): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(init_cumulative_args): Likewise.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_function_arg): Likewise.\n\t(rs6000_arg_partial_bytes): Likewise.\n\t(rs6000_output_function_entry): Likewise.\n\t(rs6000_assemble_integer): Likewise.\n\t(rs6000_savres_strategy): Likewise.\n\t(rs6000_stack_info): Likewise.\n\t(rs6000_function_ok_for_sibcall): Likewise.\n\t(rs6000_emit_load_toc_table): Likewise.\n\t(rs6000_savres_routine_name): Likewise.\n\t(ptr_regno_for_savres): Likewise.\n\t(rs6000_emit_prologue): Likewise.\n\t(rs6000_emit_epilogue): Likewise.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(output_profile_hook): Likewise.\n\t(output_function_profiler): Likewise.\n\t(rs6000_trampoline_size): Likewise.\n\t(rs6000_trampoline_init): Likewise.\n\t(rs6000_elf_output_toc_section_asm_op): Likewise.\n\t(rs6000_elf_encode_section_info): Likewise.\n\t(rs6000_elf_reloc_rw_mask): Likewise.\n\t(rs6000_elf_declare_function_name): Likewise.\n\t(rs6000_function_arg_boundary): Treat ABI_ELFv2 the same as ABI_AIX,\n\texcept that rs6000_compat_align_parm is always assumed false.\n\t(rs6000_gimplify_va_arg): Likewise.\n\t(rs6000_call_aix): Update comment.\n\t(rs6000_sibcall_aix): Likewise.\n\t* config/rs6000/rs6000.md (\"tls_gd_aix<TLSmode:tls_abi_suffix>\"):\n\tTreat ABI_ELFv2 the same as ABI_AIX.\n\t(\"*tls_gd_call_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n\t(\"tls_ld_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n\t(\"*tls_ld_call_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n\t(\"load_toc_aix_si\"): Likewise.\n\t(\"load_toc_aix_di\"): Likewise.\n\t(\"call\"): Likewise.\n\t(\"call_value\"): Likewise.\n\t(\"*call_local_aix<mode>\"): Likewise.\n\t(\"*call_value_local_aix<mode>\"): Likewise.\n\t(\"*call_nonlocal_aix<mode>\"): Likewise.\n\t(\"*call_value_nonlocal_aix<mode>\"): Likewise.\n\t(\"*call_indirect_aix<mode>\"): Likewise.\n\t(\"*call_value_indirect_aix<mode>\"): Likewise.\n\t(\"sibcall\"): Likewise.\n\t(\"sibcall_value\"): Likewise.\n\t(\"*sibcall_aix<mode>\"): Likewise.\n\t(\"*sibcall_value_aix<mode>\"): Likewise.\n\t* config/rs6000/predicates.md (\"symbol_ref_operand\"): Likewise.\n\t(\"current_file_function_operand\"): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* gcc.target/powerpc/ppc64-abi-1.c (stack_frame_t): Remove\n\tcompiler and linker field if _CALL_ELF == 2.\n\t* gcc.target/powerpc/ppc64-abi-2.c (stack_frame_t): Likewise.\n\t* gcc.target/powerpc/ppc64-abi-dfp-1.c (stack_frame_t): Likewise.\n\t* gcc.dg/stack-usage-1.c (SIZE): Update value for _CALL_ELF == 2.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* gcc.target/powerpc/ppc64-abi-dfp-1.c (FUNC_START): New macro.\n\t(WRAPPER): Use it.\n\t* gcc.target/powerpc/no-r11-1.c: Skip on powerpc_elfv2.\n\t* gcc.target/powerpc/no-r11-2.c: Skip on powerpc_elfv2.\n\t* gcc.target/powerpc/no-r11-3.c: Skip on powerpc_elfv2.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* lib/target-supports.exp (check_effective_target_powerpc_elfv2):\n\tNew function.\n\t* gcc.target/powerpc/pr57949-1.c: Disable for powerpc_elfv2.\n\t* gcc.target/powerpc/pr57949-2.c: Likewise.\n\nlibgcc/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/linux-unwind.h (TOC_SAVE_SLOT): Define.\n\t(frob_update_context): Use it.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/tramp.S [__powerpc64__ && _CALL_ELF == 2]:\n\t(trampoline_initial): Provide ELFv2 variant.\n\t(__trampoline_setup): Likewise.\n\n\t* config/rs6000/linux-unwind.h (frob_update_context): Do not\n\tcheck for AIX indirect function call sequence if _CALL_ELF == 2.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/linux-unwind.h (get_regs): Do not support\n\told kernel versions if _CALL_ELF == 2.\n\t(frob_update_context): Do not support PLT stub variants only\n\tgenerated by old linkers if _CALL_ELF == 2.\n\nlibitm/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/powerpc/sjlj.S [__powerpc64__ && _CALL_ELF == 2]:\n\t(FUNC): Define ELFv2 variant.\n\t(END): Likewise.\n\t(HIDDEN): Likewise.\n\t(CALL): Likewise.\n\t(BASE): Likewise.\n\t(LR_SAVE): Likewise.\n\nlibstdc++/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* scripts/extract_symvers.in: Ignore <localentry: > fields\n\tin readelf --symbols output.\n\n\nCo-Authored-By: Alan Modra <amodra@gmail.com>\nCo-Authored-By: Michael Gschwind <mkg@us.ibm.com>\n\nFrom-SVN: r204808", "tree": {"sha": "a0a8fa24a9935839e0db8a171f488dec1d6e7783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0a8fa24a9935839e0db8a171f488dec1d6e7783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/comments", "author": null, "committer": null, "parents": [{"sha": "140f2c812c50fbe104c3a251c530454a2682c891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140f2c812c50fbe104c3a251c530454a2682c891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140f2c812c50fbe104c3a251c530454a2682c891"}], "stats": {"total": 1674, "additions": 1454, "deletions": 220}, "files": [{"sha": "076eaaeda89527ecf3f4668633757c800b0784b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,3 +1,186 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.h (RS6000_SAVE_AREA): Handle ABI_ELFv2.\n+\t(RS6000_SAVE_TOC): Remove.\n+\t(RS6000_TOC_SAVE_SLOT): New macro.\n+\t* config/rs6000/rs6000.c (rs6000_parm_offset): New function.\n+\t(rs6000_parm_start): Use it.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_emit_prologue): Use RS6000_TOC_SAVE_SLOT.\n+\t(rs6000_emit_epilogue): Likewise.\n+\t(rs6000_call_aix): Likewise.\n+\t(rs6000_output_function_prologue): Do not save/restore r11\n+\taround calling _mcount for ABI_ELFv2.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_reg_parm_stack_space):\n+\tAdd prototype.\n+\t* config/rs6000/rs6000.h (RS6000_REG_SAVE): Remove.\n+\t(REG_PARM_STACK_SPACE): Call rs6000_reg_parm_stack_space.\n+\t* config/rs6000/rs6000.c (rs6000_parm_needs_stack): New function.\n+\t(rs6000_function_parms_need_stack): Likewise.\n+\t(rs6000_reg_parm_stack_space): Likewise.\n+\t(rs6000_function_arg): Do not replace BLKmode by Pmode when\n+\treturning a register argument.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Michael Gschwind  <mkg@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (FP_ARG_MAX_RETURN): New macro.\n+\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n+\t(FUNCTION_VALUE_REGNO_P): Use them.\n+\t* config/rs6000/rs6000.c (TARGET_RETURN_IN_MSB): Define.\n+\t(rs6000_return_in_msb): New function.\n+\t(rs6000_return_in_memory): Handle ELFv2 homogeneous aggregates.\n+\tHandle aggregates of up to 16 bytes for ELFv2.\n+\t(rs6000_function_value): Handle ELFv2 homogeneous aggregates.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Michael Gschwind  <mkg@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (AGGR_ARG_NUM_REG): Define.\n+\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): New function.\n+\t(rs6000_discover_homogeneous_aggregate): Likewise.\n+\t(rs6000_function_arg_boundary): Handle homogeneous aggregates.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_function_arg): Likewise.\n+\t(rs6000_arg_partial_bytes): Likewise.\n+\t(rs6000_psave_function_arg): Handle BLKmode arguments.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Michael Gschwind  <mkg@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (AGGR_ARG_NUM_REG): Define.\n+\t* config/rs6000/rs6000.c (rs6000_aggregate_candidate): New function.\n+\t(rs6000_discover_homogeneous_aggregate): Likewise.\n+\t(rs6000_function_arg_boundary): Handle homogeneous aggregates.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_function_arg): Likewise.\n+\t(rs6000_arg_partial_bytes): Likewise.\n+\t(rs6000_psave_function_arg): Handle BLKmode arguments.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (machine_function): New member\n+\tr2_setup_needed.\n+\t(rs6000_emit_prologue): Set r2_setup_needed if necessary.\n+\t(rs6000_output_mi_thunk): Set r2_setup_needed.\n+\t(rs6000_output_function_prologue): Output global entry point\n+\tprologue and local entry point marker if needed for ABI_ELFv2.\n+\tOutput -mprofile-kernel code here.\n+\t(output_function_profiler): Do not output -mprofile-kernel\n+\tcode here; moved to rs6000_output_function_prologue.\n+\t(rs6000_file_start): Output \".abiversion 2\" for ABI_ELFv2.\n+\n+\t(rs6000_emit_move): Do not handle dot symbols for ABI_ELFv2.\n+\t(rs6000_output_function_entry): Likewise.\n+\t(rs6000_assemble_integer): Likewise.\n+\t(rs6000_elf_encode_section_info): Likewise.\n+\t(rs6000_elf_declare_function_name): Do not create dot symbols\n+\tor .opd section for ABI_ELFv2.\n+\n+\t(rs6000_trampoline_size): Update for ABI_ELFv2 trampolines.\n+\t(rs6000_trampoline_init): Likewise.\n+\t(rs6000_elf_file_end): Call file_end_indicate_exec_stack\n+\tfor ABI_ELFv2.\n+\n+\t(rs6000_call_aix): Handle ELFv2 indirect calls.  Do not check\n+\tfor function descriptors in ABI_ELFv2.\n+\n+\t* config/rs6000/rs6000.md (\"*call_indirect_aix<mode>\"): Support\n+\ton ABI_AIX only, not ABI_ELFv2.\n+\t(\"*call_value_indirect_aix<mode>\"): Likewise.\n+\t(\"*call_indirect_elfv2<mode>\"): New pattern.\n+\t(\"*call_value_indirect_elfv2<mode>\"): Likewise.\n+\n+\t* config/rs6000/predicates.md (\"symbol_ref_operand\"): Do not\n+\tcheck for function descriptors in ABI_ELFv2.\n+\t(\"current_file_function_operand\"): Likewise.\n+\n+\t* config/rs6000/ppc-asm.h [__powerpc64__ && _CALL_ELF == 2]:\n+\t(toc): Undefine.\n+\t(FUNC_NAME): Define ELFv2 variant.\n+\t(JUMP_TARGET): Likewise.\n+\t(FUNC_START): Likewise.\n+\t(HIDDEN_FUNC): Likewise.\n+\t(FUNC_END): Likeiwse.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config.gcc [powerpc*-*-* | rs6000-*-*]: Support --with-abi=elfv1\n+\tand --with-abi=elfv2.\n+\t* config/rs6000/option-defaults.h (OPTION_DEFAULT_SPECS): Add \"abi\".\n+\t* config/rs6000/rs6000.opt (mabi=elfv1): New option.\n+\t(mabi=elfv2): Likewise.\n+\t* config/rs6000/rs6000-opts.h (enum rs6000_abi): Add ABI_ELFv2.\n+\t* config/rs6000/linux64.h (DEFAULT_ABI): Do not hard-code to AIX_ABI\n+\tif !RS6000_BI_ARCH.\n+\t(ELFv2_ABI_CHECK): New macro.\n+\t(SUBSUBTARGET_OVERRIDE_OPTIONS): Use it to decide whether to set\n+\trs6000_current_abi to ABI_AIX or ABI_ELFv2.\n+\t(GLIBC_DYNAMIC_LINKER64): Support ELFv2 ld.so version.\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Predefine\n+\t_CALL_ELF and __STRUCT_PARM_ALIGN__ if appropriate.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Handle ABI_ELFv2.\n+\t(debug_stack_info): Likewise.\n+\t(rs6000_file_start): Treat ABI_ELFv2 the same as ABI_AIX.\n+\t(rs6000_legitimize_tls_address): Likewise.\n+\t(rs6000_conditional_register_usage): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(init_cumulative_args): Likewise.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_function_arg): Likewise.\n+\t(rs6000_arg_partial_bytes): Likewise.\n+\t(rs6000_output_function_entry): Likewise.\n+\t(rs6000_assemble_integer): Likewise.\n+\t(rs6000_savres_strategy): Likewise.\n+\t(rs6000_stack_info): Likewise.\n+\t(rs6000_function_ok_for_sibcall): Likewise.\n+\t(rs6000_emit_load_toc_table): Likewise.\n+\t(rs6000_savres_routine_name): Likewise.\n+\t(ptr_regno_for_savres): Likewise.\n+\t(rs6000_emit_prologue): Likewise.\n+\t(rs6000_emit_epilogue): Likewise.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(output_profile_hook): Likewise.\n+\t(output_function_profiler): Likewise.\n+\t(rs6000_trampoline_size): Likewise.\n+\t(rs6000_trampoline_init): Likewise.\n+\t(rs6000_elf_output_toc_section_asm_op): Likewise.\n+\t(rs6000_elf_encode_section_info): Likewise.\n+\t(rs6000_elf_reloc_rw_mask): Likewise.\n+\t(rs6000_elf_declare_function_name): Likewise.\n+\t(rs6000_function_arg_boundary): Treat ABI_ELFv2 the same as ABI_AIX,\n+\texcept that rs6000_compat_align_parm is always assumed false.\n+\t(rs6000_gimplify_va_arg): Likewise.\n+\t(rs6000_call_aix): Update comment.\n+\t(rs6000_sibcall_aix): Likewise.\n+\t* config/rs6000/rs6000.md (\"tls_gd_aix<TLSmode:tls_abi_suffix>\"):\n+\tTreat ABI_ELFv2 the same as ABI_AIX.\n+\t(\"*tls_gd_call_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n+\t(\"tls_ld_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n+\t(\"*tls_ld_call_aix<TLSmode:tls_abi_suffix>\"): Likewise.\n+\t(\"load_toc_aix_si\"): Likewise.\n+\t(\"load_toc_aix_di\"): Likewise.\n+\t(\"call\"): Likewise.\n+\t(\"call_value\"): Likewise.\n+\t(\"*call_local_aix<mode>\"): Likewise.\n+\t(\"*call_value_local_aix<mode>\"): Likewise.\n+\t(\"*call_nonlocal_aix<mode>\"): Likewise.\n+\t(\"*call_value_nonlocal_aix<mode>\"): Likewise.\n+\t(\"*call_indirect_aix<mode>\"): Likewise.\n+\t(\"*call_value_indirect_aix<mode>\"): Likewise.\n+\t(\"sibcall\"): Likewise.\n+\t(\"sibcall_value\"): Likewise.\n+\t(\"*sibcall_aix<mode>\"): Likewise.\n+\t(\"*sibcall_value_aix<mode>\"): Likewise.\n+\t* config/rs6000/predicates.md (\"symbol_ref_operand\"): Likewise.\n+\t(\"current_file_function_operand\"): Likewise.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Simplify logic"}, {"sha": "fafa8b87e07f737055c09e1c1470c8c83b33eb09", "filename": "gcc/config.gcc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -3805,7 +3805,7 @@ case \"${target}\" in\n \t\t;;\n \n \tpowerpc*-*-* | rs6000-*-*)\n-\t\tsupported_defaults=\"cpu cpu_32 cpu_64 float tune tune_32 tune_64\"\n+\t\tsupported_defaults=\"abi cpu cpu_32 cpu_64 float tune tune_32 tune_64\"\n \n \t\tfor which in cpu cpu_32 cpu_64 tune tune_32 tune_64; do\n \t\t\teval \"val=\\$with_$which\"\n@@ -3842,6 +3842,16 @@ case \"${target}\" in\n \t\t\t\t;;\n \t\t\tesac\n \t\tdone\n+\n+\t\tcase \"$with_abi\" in\n+\t\t\"\" | elfv1 | elfv2 )\n+\t\t\t#OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown ABI used in --with-abi=$with_abi\"\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n \t\t;;\n \n \ts390*-*-*)"}, {"sha": "78e84531300fdecacb57b6fd8c183b222fa26e39", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -25,9 +25,6 @@\n \n #ifndef RS6000_BI_ARCH\n \n-#undef\tDEFAULT_ABI\n-#define\tDEFAULT_ABI ABI_AIX\n-\n #undef\tTARGET_64BIT\n #define\tTARGET_64BIT 1\n \n@@ -88,6 +85,12 @@ extern int dot_symbols;\n #define INVALID_64BIT \"-m%s not supported in this configuration\"\n #define INVALID_32BIT INVALID_64BIT\n \n+#ifdef LINUX64_DEFAULT_ABI_ELFv2\n+#define ELFv2_ABI_CHECK (rs6000_elf_abi != 1)\n+#else\n+#define ELFv2_ABI_CHECK (rs6000_elf_abi == 2)\n+#endif\n+\n #undef\tSUBSUBTARGET_OVERRIDE_OPTIONS\n #define\tSUBSUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n@@ -102,6 +105,12 @@ extern int dot_symbols;\n \t      error (INVALID_64BIT, \"call\");\t\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n \t  dot_symbols = !strcmp (rs6000_abi_name, \"aixdesc\");\t\\\n+\t  if (ELFv2_ABI_CHECK)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      rs6000_current_abi = ABI_ELFv2;\t\t\t\\\n+\t      if (dot_symbols)\t\t\t\t\t\\\n+\t\terror (\"-mcall-aixdesc incompatible with -mabi=elfv2\"); \\\n+\t    }\t\t\t\t\t\t\t\\\n \t  if (rs6000_isa_flags & OPTION_MASK_RELOCATABLE)\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      rs6000_isa_flags &= ~OPTION_MASK_RELOCATABLE;\t\\\n@@ -355,7 +364,11 @@ extern int dot_symbols;\n #define LINK_OS_DEFAULT_SPEC \"%(link_os_linux)\"\n \n #define GLIBC_DYNAMIC_LINKER32 \"/lib/ld.so.1\"\n-#define GLIBC_DYNAMIC_LINKER64 \"/lib64/ld64.so.1\"\n+#ifdef LINUX64_DEFAULT_ABI_ELFv2\n+#define GLIBC_DYNAMIC_LINKER64 \"%{mabi=elfv1:/lib64/ld64.so.1;:/lib64/ld64.so.2}\"\n+#else\n+#define GLIBC_DYNAMIC_LINKER64 \"%{mabi=elfv2:/lib64/ld64.so.2;:/lib64/ld64.so.1}\"\n+#endif\n #define UCLIBC_DYNAMIC_LINKER32 \"/lib/ld-uClibc.so.0\"\n #define UCLIBC_DYNAMIC_LINKER64 \"/lib/ld64-uClibc.so.0\"\n #if DEFAULT_LIBC == LIBC_UCLIBC"}, {"sha": "0d7ba1ea3ac414ed57be9b0872b057015bb5336e", "filename": "gcc/config/rs6000/option-defaults.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Foption-defaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Foption-defaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Foption-defaults.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -54,6 +54,7 @@\n    --with-float is ignored if -mhard-float or -msoft-float are\n      specified.  */\n #define OPTION_DEFAULT_SPECS \\\n+  {\"abi\", \"%{!mabi=elfv*:-mabi=%(VALUE)}\" }, \\\n   {\"tune\", \"%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}\" }, \\\n   {\"tune_32\", \"%{\" OPT_ARCH32 \":%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}}\" }, \\\n   {\"tune_64\", \"%{\" OPT_ARCH64 \":%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}}\" }, \\"}, {"sha": "8108efd07f5b44935160b96a39fd5ff188a52fa8", "filename": "gcc/config/rs6000/ppc-asm.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Fppc-asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Fppc-asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fppc-asm.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -256,7 +256,30 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n  * the real function with one or two leading periods respectively.\n  */\n \n-#if defined (__powerpc64__)\n+#if defined(__powerpc64__) && _CALL_ELF == 2\n+\n+/* Defining \"toc\" above breaks @toc in assembler code.  */\n+#undef toc\n+\n+#define FUNC_NAME(name) GLUE(__USER_LABEL_PREFIX__,name)\n+#define JUMP_TARGET(name) FUNC_NAME(name)\n+#define FUNC_START(name) \\\n+\t.type FUNC_NAME(name),@function; \\\n+\t.globl FUNC_NAME(name); \\\n+FUNC_NAME(name): \\\n+0:\taddis 2,12,(.TOC.-0b)@ha; \\\n+\taddi 2,2,(.TOC.-0b)@l; \\\n+\t.localentry FUNC_NAME(name),.-FUNC_NAME(name)\n+\n+#define HIDDEN_FUNC(name) \\\n+  FUNC_START(name) \\\n+  .hidden FUNC_NAME(name);\n+\n+#define FUNC_END(name) \\\n+\t.size FUNC_NAME(name),.-FUNC_NAME(name)\n+\n+#elif defined (__powerpc64__)\n+\n #define FUNC_NAME(name) GLUE(.,name)\n #define JUMP_TARGET(name) FUNC_NAME(name)\n #define FUNC_START(name) \\"}, {"sha": "c3118beb516875aae563d52501b3eaa0b8000ca8", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1050,7 +1050,8 @@\n   (and (match_code \"symbol_ref\")\n        (match_test \"(DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\n \t\t    && ((SYMBOL_REF_LOCAL_P (op)\n-\t\t\t && (DEFAULT_ABI != ABI_AIX\n+\t\t\t && ((DEFAULT_ABI != ABI_AIX\n+\t\t\t      && DEFAULT_ABI != ABI_ELFv2)\n \t\t\t     || !SYMBOL_REF_EXTERNAL_P (op)))\n \t\t        || (op == XEXP (DECL_RTL (current_function_decl),\n \t\t\t\t\t\t  0)))\")))"}, {"sha": "283cc917ae8b87c1f066b066055d437603fd650b", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -461,6 +461,10 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     case ABI_AIX:\n       builtin_define (\"_CALL_AIXDESC\");\n       builtin_define (\"_CALL_AIX\");\n+      builtin_define (\"_CALL_ELF=1\");\n+      break;\n+    case ABI_ELFv2:\n+      builtin_define (\"_CALL_ELF=2\");\n       break;\n     case ABI_DARWIN:\n       builtin_define (\"_CALL_DARWIN\");\n@@ -473,6 +477,13 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n   if (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n     builtin_define (\"__NO_FPRS__\");\n \n+  /* Whether aggregates passed by value are aligned to a 16 byte boundary\n+     if their alignment is 16 bytes or larger.  */\n+  if ((TARGET_MACHO && rs6000_darwin64_abi)\n+      || DEFAULT_ABI == ABI_ELFv2\n+      || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))\n+    builtin_define (\"__STRUCT_PARM_ALIGN__=16\");\n+\n   /* Generate defines for Xilinx FPU. */\n   if (rs6000_xilinx_fpu) \n     {"}, {"sha": "6d6d69379d5867ff0d0bd7c6d04c6ff089139a78", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -107,7 +107,8 @@ enum group_termination\n /* Enumeration to give which calling sequence to use.  */\n enum rs6000_abi {\n   ABI_NONE,\n-  ABI_AIX,\t\t\t/* IBM's AIX */\n+  ABI_AIX,\t\t\t/* IBM's AIX, or Linux ELFv1 */\n+  ABI_ELFv2,\t\t\t/* Linux ELFv2 ABI */\n   ABI_V4,\t\t\t/* System V.4/eabi */\n   ABI_DARWIN\t\t\t/* Apple's Darwin (OS X kernel) */\n };"}, {"sha": "2ad6f08f47daa82face19006d7fbc42b0c7da9b5", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -158,6 +158,7 @@ extern tree altivec_resolve_overloaded_builtin (location_t, tree, void *);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern rtx rs6000_va_arg (tree, tree);\n extern int function_ok_for_sibcall (tree);\n+extern int rs6000_reg_parm_stack_space (tree);\n extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n extern bool rs6000_elf_in_small_data_p (const_tree);\n #ifdef ARGS_SIZE_RTX"}, {"sha": "c6b61717538873da71ada4fcccd3acc970e8c8ac", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 896, "deletions": 168, "changes": 1064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -99,6 +99,7 @@ typedef struct rs6000_stack {\n   int spe_gp_save_offset;\t/* offset to save spe 64-bit gprs  */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n   int ehrd_offset;\t\t/* offset to EH return data */\n+  int ehcr_offset;\t\t/* offset to EH CR field data */\n   int reg_size;\t\t\t/* register size (4 or 8) */\n   HOST_WIDE_INT vars_size;\t/* variable save area size */\n   int parm_size;\t\t/* outgoing parameter size */\n@@ -142,6 +143,8 @@ typedef struct GTY(()) machine_function\n      64-bits wide and is allocated early enough so that the offset\n      does not overflow the 16-bit load/store offset field.  */\n   rtx sdmode_stack_slot;\n+  /* Flag if r2 setup is needed with ELFv2 ABI.  */\n+  bool r2_setup_needed;\n } machine_function;\n \n /* Support targetm.vectorize.builtin_mask_for_load.  */\n@@ -1448,6 +1451,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY rs6000_return_in_memory\n \n+#undef TARGET_RETURN_IN_MSB\n+#define TARGET_RETURN_IN_MSB rs6000_return_in_msb\n+\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS setup_incoming_varargs\n \n@@ -2236,6 +2242,7 @@ rs6000_debug_reg_global (void)\n     {\n     case ABI_NONE:\tabi_str = \"none\";\tbreak;\n     case ABI_AIX:\tabi_str = \"aix\";\tbreak;\n+    case ABI_ELFv2:\tabi_str = \"ELFv2\";\tbreak;\n     case ABI_V4:\tabi_str = \"V4\";\t\tbreak;\n     case ABI_DARWIN:\tabi_str = \"darwin\";\tbreak;\n     default:\t\tabi_str = \"unknown\";\tbreak;\n@@ -4766,7 +4773,11 @@ rs6000_file_start (void)\n \tputc ('\\n', file);\n     }\n \n-  if (DEFAULT_ABI == ABI_AIX || (TARGET_ELF && flag_pic == 2))\n+  if (DEFAULT_ABI == ABI_ELFv2)\n+    fprintf (file, \"\\t.abiversion 2\\n\");\n+\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\n+      || (TARGET_ELF && flag_pic == 2))\n     {\n       switch_to_section (toc_section);\n       switch_to_section (text_section);\n@@ -6976,10 +6987,13 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t\t\t\t   1, const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n-\t  if (DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n-\t    insn = gen_tls_gd_aix64 (r3, got, addr, tga, const0_rtx);\n-\t  else if (DEFAULT_ABI == ABI_AIX && !TARGET_64BIT)\n-\t    insn = gen_tls_gd_aix32 (r3, got, addr, tga, const0_rtx);\n+\t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+\t    {\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_gd_aix64 (r3, got, addr, tga, const0_rtx);\n+\t      else\n+\t\tinsn = gen_tls_gd_aix32 (r3, got, addr, tga, const0_rtx);\n+\t    }\n \t  else if (DEFAULT_ABI == ABI_V4)\n \t    insn = gen_tls_gd_sysvsi (r3, got, addr, tga, const0_rtx);\n \t  else\n@@ -6998,10 +7012,13 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t\t\t\t   1, const0_rtx, Pmode);\n \n \t  r3 = gen_rtx_REG (Pmode, 3);\n-\t  if (DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n-\t    insn = gen_tls_ld_aix64 (r3, got, tga, const0_rtx);\n-\t  else if (DEFAULT_ABI == ABI_AIX && !TARGET_64BIT)\n-\t    insn = gen_tls_ld_aix32 (r3, got, tga, const0_rtx);\n+\t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+\t    {\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_ld_aix64 (r3, got, tga, const0_rtx);\n+\t      else\n+\t\tinsn = gen_tls_ld_aix32 (r3, got, tga, const0_rtx);\n+\t    }\n \t  else if (DEFAULT_ABI == ABI_V4)\n \t    insn = gen_tls_ld_sysvsi (r3, got, tga, const0_rtx);\n \t  else\n@@ -7628,7 +7645,7 @@ rs6000_conditional_register_usage (void)\n \n   /* The TOC register is not killed across calls in a way that is\n      visible to the compiler.  */\n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     call_really_used_regs[2] = 0;\n \n   if (DEFAULT_ABI == ABI_V4\n@@ -8451,6 +8468,219 @@ rs6000_member_type_forces_blk (const_tree field, enum machine_mode mode)\n    && TARGET_ALTIVEC_ABI\t\t\t\t\t\\\n    && (NAMED))\n \n+/* Walk down the type tree of TYPE counting consecutive base elements.\n+   If *MODEP is VOIDmode, then set it to the first valid floating point\n+   or vector type.  If a non-floating point or vector type is found, or\n+   if a floating point or vector type that doesn't match a non-VOIDmode\n+   *MODEP is found, then return -1, otherwise return the count in the\n+   sub-tree.  */\n+\n+static int\n+rs6000_aggregate_candidate (const_tree type, enum machine_mode *modep)\n+{\n+  enum machine_mode mode;\n+  HOST_WIDE_INT size;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case REAL_TYPE:\n+      mode = TYPE_MODE (type);\n+      if (!SCALAR_FLOAT_MODE_P (mode))\n+\treturn -1;\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      if (*modep == mode)\n+\treturn 1;\n+\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      mode = TYPE_MODE (TREE_TYPE (type));\n+      if (!SCALAR_FLOAT_MODE_P (mode))\n+\treturn -1;\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      if (*modep == mode)\n+\treturn 2;\n+\n+      break;\n+\n+    case VECTOR_TYPE:\n+      if (!TARGET_ALTIVEC_ABI || !TARGET_ALTIVEC)\n+\treturn -1;\n+\n+      /* Use V4SImode as representative of all 128-bit vector types.  */\n+      size = int_size_in_bytes (type);\n+      switch (size)\n+\t{\n+\tcase 16:\n+\t  mode = V4SImode;\n+\t  break;\n+\tdefault:\n+\t  return -1;\n+\t}\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      /* Vector modes are considered to be opaque: two vectors are\n+\t equivalent for the purposes of being homogeneous aggregates\n+\t if they are the same size.  */\n+      if (*modep == mode)\n+\treturn 1;\n+\n+      break;\n+\n+    case ARRAY_TYPE:\n+      {\n+\tint count;\n+\ttree index = TYPE_DOMAIN (type);\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P (type))\n+\t  return -1;\n+\n+\tcount = rs6000_aggregate_candidate (TREE_TYPE (type), modep);\n+\tif (count == -1\n+\t    || !index\n+\t    || !TYPE_MAX_VALUE (index)\n+\t    || !host_integerp (TYPE_MAX_VALUE (index), 1)\n+\t    || !TYPE_MIN_VALUE (index)\n+\t    || !host_integerp (TYPE_MIN_VALUE (index), 1)\n+\t    || count < 0)\n+\t  return -1;\n+\n+\tcount *= (1 + tree_low_cst (TYPE_MAX_VALUE (index), 1)\n+\t\t      - tree_low_cst (TYPE_MIN_VALUE (index), 1));\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+\n+    case RECORD_TYPE:\n+      {\n+\tint count = 0;\n+\tint sub_count;\n+\ttree field;\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P (type))\n+\t  return -1;\n+\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  {\n+\t    if (TREE_CODE (field) != FIELD_DECL)\n+\t      continue;\n+\n+\t    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep);\n+\t    if (sub_count < 0)\n+\t      return -1;\n+\t    count += sub_count;\n+\t  }\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\t/* These aren't very interesting except in a degenerate case.  */\n+\tint count = 0;\n+\tint sub_count;\n+\ttree field;\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P (type))\n+\t  return -1;\n+\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  {\n+\t    if (TREE_CODE (field) != FIELD_DECL)\n+\t      continue;\n+\n+\t    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep);\n+\t    if (sub_count < 0)\n+\t      return -1;\n+\t    count = count > sub_count ? count : sub_count;\n+\t  }\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return -1;\n+}\n+\n+/* If an argument, whose type is described by TYPE and MODE, is a homogeneous\n+   float or vector aggregate that shall be passed in FP/vector registers\n+   according to the ELFv2 ABI, return the homogeneous element mode in\n+   *ELT_MODE and the number of elements in *N_ELTS, and return TRUE.\n+\n+   Otherwise, set *ELT_MODE to MODE and *N_ELTS to 1, and return FALSE.  */\n+\n+static bool\n+rs6000_discover_homogeneous_aggregate (enum machine_mode mode, const_tree type,\n+\t\t\t\t       enum machine_mode *elt_mode,\n+\t\t\t\t       int *n_elts)\n+{\n+  /* Note that we do not accept complex types at the top level as\n+     homogeneous aggregates; these types are handled via the\n+     targetm.calls.split_complex_arg mechanism.  Complex types\n+     can be elements of homogeneous aggregates, however.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && type && AGGREGATE_TYPE_P (type))\n+    {\n+      enum machine_mode field_mode = VOIDmode;\n+      int field_count = rs6000_aggregate_candidate (type, &field_mode);\n+\n+      if (field_count > 0)\n+\t{\n+\t  int n_regs = (SCALAR_FLOAT_MODE_P (field_mode)?\n+\t\t\t(GET_MODE_SIZE (field_mode) + 7) >> 3 : 1);\n+\n+\t  /* The ELFv2 ABI allows homogeneous aggregates to occupy\n+\t     up to AGGR_ARG_NUM_REG registers.  */\n+\t  if (field_count * n_regs <= AGGR_ARG_NUM_REG)\n+\t    {\n+\t      if (elt_mode)\n+\t\t*elt_mode = field_mode;\n+\t      if (n_elts)\n+\t\t*n_elts = field_count;\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+\n+  if (elt_mode)\n+    *elt_mode = mode;\n+  if (n_elts)\n+    *n_elts = 1;\n+  return false;\n+}\n+\n /* Return a nonzero value to say to return the function value in\n    memory, just as large structures are always returned.  TYPE will be\n    the data type of the value, and FNTYPE will be the type of the\n@@ -8503,6 +8733,16 @@ rs6000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n       /* Otherwise fall through to more conventional ABI rules.  */\n     }\n \n+  /* The ELFv2 ABI returns homogeneous VFP aggregates in registers */\n+  if (rs6000_discover_homogeneous_aggregate (TYPE_MODE (type), type,\n+\t\t\t\t\t     NULL, NULL))\n+    return false;\n+\n+  /* The ELFv2 ABI returns aggregates up to 16B in registers */\n+  if (DEFAULT_ABI == ABI_ELFv2 && AGGREGATE_TYPE_P (type)\n+      && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) <= 16)\n+    return false;\n+\n   if (AGGREGATE_TYPE_P (type)\n       && (aix_struct_return\n \t  || (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8))\n@@ -8534,6 +8774,19 @@ rs6000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Specify whether values returned in registers should be at the most\n+   significant end of a register.  We want aggregates returned by\n+   value to match the way aggregates are passed to functions.  */\n+\n+static bool\n+rs6000_return_in_msb (const_tree valtype)\n+{\n+  return (DEFAULT_ABI == ABI_ELFv2\n+\t  && BYTES_BIG_ENDIAN\n+\t  && AGGREGATE_TYPE_P (valtype)\n+\t  && FUNCTION_ARG_PADDING (TYPE_MODE (valtype), valtype) == upward);\n+}\n+\n #ifdef HAVE_AS_GNU_ATTRIBUTE\n /* Return TRUE if a call to function FNDECL may be one that\n    potentially affects the function calling ABI of the object file.  */\n@@ -8670,7 +8923,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n static bool\n rs6000_must_pass_in_stack (enum machine_mode mode, const_tree type)\n {\n-  if (DEFAULT_ABI == ABI_AIX || TARGET_64BIT)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2 || TARGET_64BIT)\n     return must_pass_in_stack_var_size (mode, type);\n   else\n     return must_pass_in_stack_var_size_or_pad (mode, type);\n@@ -8751,6 +9004,11 @@ function_arg_padding (enum machine_mode mode, const_tree type)\n static unsigned int\n rs6000_function_arg_boundary (enum machine_mode mode, const_tree type)\n {\n+  enum machine_mode elt_mode;\n+  int n_elts;\n+\n+  rs6000_discover_homogeneous_aggregate (mode, type, &elt_mode, &n_elts);\n+\n   if (DEFAULT_ABI == ABI_V4\n       && (GET_MODE_SIZE (mode) == 8\n \t  || (TARGET_HARD_FLOAT\n@@ -8762,11 +9020,12 @@ rs6000_function_arg_boundary (enum machine_mode mode, const_tree type)\n \t       && int_size_in_bytes (type) >= 8\n \t       && int_size_in_bytes (type) < 16))\n     return 64;\n-  else if (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n+  else if (ALTIVEC_OR_VSX_VECTOR_MODE (elt_mode)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n \t       && int_size_in_bytes (type) >= 16))\n     return 128;\n   else if (((TARGET_MACHO && rs6000_darwin64_abi)\n+\t    || DEFAULT_ABI == ABI_ELFv2\n             || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))\n  \t   && mode == BLKmode\n \t   && type && TYPE_ALIGN (type) > 64)\n@@ -8775,6 +9034,16 @@ rs6000_function_arg_boundary (enum machine_mode mode, const_tree type)\n     return PARM_BOUNDARY;\n }\n \n+/* The offset in words to the start of the parameter save area.  */\n+\n+static unsigned int\n+rs6000_parm_offset (void)\n+{\n+  return (DEFAULT_ABI == ABI_V4 ? 2\n+\t  : DEFAULT_ABI == ABI_ELFv2 ? 4\n+\t  : 6);\n+}\n+\n /* For a function parm of MODE and TYPE, return the starting word in\n    the parameter area.  NWORDS of the parameter area are already used.  */\n \n@@ -8783,11 +9052,9 @@ rs6000_parm_start (enum machine_mode mode, const_tree type,\n \t\t   unsigned int nwords)\n {\n   unsigned int align;\n-  unsigned int parm_offset;\n \n   align = rs6000_function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n-  parm_offset = DEFAULT_ABI == ABI_V4 ? 2 : 6;\n-  return nwords + (-(parm_offset + nwords) & align);\n+  return nwords + (-(rs6000_parm_offset () + nwords) & align);\n }\n \n /* Compute the size (in words) of a function argument.  */\n@@ -8972,6 +9239,11 @@ static void\n rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t       const_tree type, bool named, int depth)\n {\n+  enum machine_mode elt_mode;\n+  int n_elts;\n+\n+  rs6000_discover_homogeneous_aggregate (mode, type, &elt_mode, &n_elts);\n+\n   /* Only tick off an argument if we're not recursing.  */\n   if (depth == 0)\n     cum->nargs_prototype--;\n@@ -8992,15 +9264,16 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n #endif\n \n   if (TARGET_ALTIVEC_ABI\n-      && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n+      && (ALTIVEC_OR_VSX_VECTOR_MODE (elt_mode)\n \t  || (type && TREE_CODE (type) == VECTOR_TYPE\n \t      && int_size_in_bytes (type) == 16)))\n     {\n       bool stack = false;\n \n-      if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named))\n+      if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, named))\n \t{\n-\t  cum->vregno++;\n+\t  cum->vregno += n_elts;\n+\n \t  if (!TARGET_ALTIVEC)\n \t    error (\"cannot pass argument in vector register because\"\n \t\t   \" altivec instructions are disabled, use -maltivec\"\n@@ -9009,7 +9282,8 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  /* PowerPC64 Linux and AIX allocate GPRs for a vector argument\n \t     even if it is going to be passed in a vector register.\n \t     Darwin does the same for variable-argument functions.  */\n-\t  if ((DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n+\t  if (((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+\t       && TARGET_64BIT)\n \t      || (cum->stdarg && DEFAULT_ABI != ABI_V4))\n \t    stack = true;\n \t}\n@@ -9020,15 +9294,13 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t{\n \t  int align;\n \n-\t  /* Vector parameters must be 16-byte aligned.  This places\n-\t     them at 2 mod 4 in terms of words in 32-bit mode, since\n-\t     the parameter save area starts at offset 24 from the\n-\t     stack.  In 64-bit mode, they just have to start on an\n-\t     even word, since the parameter save area is 16-byte\n-\t     aligned.  Space for GPRs is reserved even if the argument\n-\t     will be passed in memory.  */\n+\t  /* Vector parameters must be 16-byte aligned.  In 32-bit\n+\t     mode this means we need to take into account the offset\n+\t     to the parameter save area.  In 64-bit mode, they just\n+\t     have to start on an even word, since the parameter save\n+\t     area is 16-byte aligned.  */\n \t  if (TARGET_32BIT)\n-\t    align = (2 - cum->words) & 3;\n+\t    align = -(rs6000_parm_offset () + cum->words) & 3;\n \t  else\n \t    align = cum->words & 1;\n \t  cum->words += align + rs6000_arg_size (mode, type);\n@@ -9153,15 +9425,15 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n       cum->words = align_words + n_words;\n \n-      if (SCALAR_FLOAT_MODE_P (mode)\n+      if (SCALAR_FLOAT_MODE_P (elt_mode)\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \t{\n \t  /* _Decimal128 must be passed in an even/odd float register pair.\n \t     This assumes that the register number is odd when fregno is\n \t     odd.  */\n-\t  if (mode == TDmode && (cum->fregno % 2) == 1)\n+\t  if (elt_mode == TDmode && (cum->fregno % 2) == 1)\n \t    cum->fregno++;\n-\t  cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t  cum->fregno += n_elts * ((GET_MODE_SIZE (elt_mode) + 7) >> 3);\n \t}\n \n       if (TARGET_DEBUG_ARG)\n@@ -9532,6 +9804,7 @@ rs6000_psave_function_arg (enum machine_mode mode, const_tree type,\n       int n_words = rs6000_arg_size (mode, type);\n \n       if (align_words + n_words > GP_ARG_NUM_REG\n+\t  || mode == BLKmode\n \t  || (TARGET_32BIT && TARGET_POWERPC64))\n \t{\n \t  /* If this is partially on the stack, then we only\n@@ -9627,6 +9900,8 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   enum rs6000_abi abi = DEFAULT_ABI;\n+  enum machine_mode elt_mode;\n+  int n_elts;\n \n   /* Return a marker to indicate whether CR1 needs to set or clear the\n      bit that V.4 uses to say fp args were passed in registers.\n@@ -9653,6 +9928,8 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n       return GEN_INT (cum->call_cookie & ~CALL_LIBCALL);\n     }\n \n+  rs6000_discover_homogeneous_aggregate (mode, type, &elt_mode, &n_elts);\n+\n   if (TARGET_MACHO && rs6000_darwin64_struct_check_p (mode, type))\n     {\n       rtx rslt = rs6000_darwin64_record_arg (cum, type, named, /*retval= */false);\n@@ -9661,11 +9938,11 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n       /* Else fall through to usual handling.  */\n     }\n \n-  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named))\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, named))\n     {\n-      rtx rvec[GP_ARG_NUM_REG + 1];\n-      rtx r;\n-      int k = 0;\n+      rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];\n+      rtx r, off;\n+      int i, k = 0;\n \n       /* Do we also need to pass this argument in the parameter\n \t save area?  */\n@@ -9676,8 +9953,12 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t}\n \n       /* Describe where this argument goes in the vector registers.  */\n-      r = gen_rtx_REG (mode, cum->vregno);\n-      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+      for (i = 0; i < n_elts && cum->vregno + i <= ALTIVEC_ARG_MAX_REG; i++)\n+\t{\n+\t  r = gen_rtx_REG (elt_mode, cum->vregno + i);\n+\t  off = GEN_INT (i * GET_MODE_SIZE (elt_mode));\n+\t  rvec[k++] =  gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t}\n \n       return rs6000_finish_function_arg (mode, rvec, k);\n     }\n@@ -9695,13 +9976,13 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t  int align, align_words, n_words;\n \t  enum machine_mode part_mode;\n \n-\t  /* Vector parameters must be 16-byte aligned.  This places them at\n-\t     2 mod 4 in terms of words in 32-bit mode, since the parameter\n-\t     save area starts at offset 24 from the stack.  In 64-bit mode,\n-\t     they just have to start on an even word, since the parameter\n-\t     save area is 16-byte aligned.  */\n+\t  /* Vector parameters must be 16-byte aligned.  In 32-bit\n+\t     mode this means we need to take into account the offset\n+\t     to the parameter save area.  In 64-bit mode, they just\n+\t     have to start on an even word, since the parameter save\n+\t     area is 16-byte aligned.  */\n \t  if (TARGET_32BIT)\n-\t    align = (2 - cum->words) & 3;\n+\t    align = -(rs6000_parm_offset () + cum->words) & 3;\n \t  else\n \t    align = cum->words & 1;\n \t  align_words = cum->words + align;\n@@ -9779,38 +10060,42 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \n       /* _Decimal128 must be passed in an even/odd float register pair.\n \t This assumes that the register number is odd when fregno is odd.  */\n-      if (mode == TDmode && (cum->fregno % 2) == 1)\n+      if (elt_mode == TDmode && (cum->fregno % 2) == 1)\n \tcum->fregno++;\n \n-      if (USE_FP_FOR_ARG_P (cum, mode))\n+      if (USE_FP_FOR_ARG_P (cum, elt_mode))\n \t{\n-\t  rtx rvec[GP_ARG_NUM_REG + 1];\n-\t  rtx r;\n-\t  int k = 0;\n-\t  enum machine_mode fmode = mode;\n-\t  unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];\n+\t  rtx r, off;\n+\t  int i, k = 0;\n+\t  unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;\n \n \t  /* Do we also need to pass this argument in the parameter\n \t     save area?  */\n \t  if (type && (cum->nargs_prototype <= 0\n-\t\t       || (DEFAULT_ABI == ABI_AIX\n+\t\t       || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t\t\t   && TARGET_XL_COMPAT\n \t\t\t   && align_words >= GP_ARG_NUM_REG)))\n \t    k = rs6000_psave_function_arg (mode, type, align_words, rvec);\n \n \t  /* Describe where this argument goes in the fprs.  */\n-\n-\t  /* Check if the argument is split over registers and memory.\n-\t     This can only ever happen for long double or _Decimal128;\n-\t     complex types are handled via split_complex_arg.  */\n-\t  if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n+\t  for (i = 0; i < n_elts\n+\t\t      && cum->fregno + i * n_fpreg <= FP_ARG_MAX_REG; i++)\n \t    {\n-\t      gcc_assert (fmode == TFmode || fmode == TDmode);\n-\t      fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n-\t    }\n+\t      /* Check if the argument is split over registers and memory.\n+\t\t This can only ever happen for long double or _Decimal128;\n+\t\t complex types are handled via split_complex_arg.  */\n+\t      enum machine_mode fmode = elt_mode;\n+\t      if (cum->fregno + (i + 1) * n_fpreg > FP_ARG_MAX_REG + 1)\n+\t\t{\n+\t\t  gcc_assert (fmode == TFmode || fmode == TDmode);\n+\t\t  fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n+\t\t}\n \n-\t  r = gen_rtx_REG (fmode, cum->fregno);\n-\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+\t      r = gen_rtx_REG (fmode, cum->fregno + i * n_fpreg);\n+\t      off = GEN_INT (i * GET_MODE_SIZE (elt_mode));\n+\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t    }\n \n \t  return rs6000_finish_function_arg (mode, rvec, k);\n \t}\n@@ -9819,9 +10104,6 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t  if (TARGET_32BIT && TARGET_POWERPC64)\n \t    return rs6000_mixed_function_arg (mode, type, align_words);\n \n-\t  if (mode == BLKmode)\n-\t    mode = Pmode;\n-\n \t  return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n \t}\n       else\n@@ -9843,11 +10125,15 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n   bool passed_in_gprs = true;\n   int ret = 0;\n   int align_words;\n+  enum machine_mode elt_mode;\n+  int n_elts;\n+\n+  rs6000_discover_homogeneous_aggregate (mode, type, &elt_mode, &n_elts);\n \n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n \n-  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named))\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, named))\n     {\n       /* If we are passing this arg in the fixed parameter save area\n          (gprs or memory) as well as VRs, we do not use the partial\n@@ -9856,8 +10142,10 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n       if (TARGET_64BIT && ! cum->prototype)\n \treturn 0;\n \n-      /* Otherwise, we pass in VRs only.  No partial copy possible.  */\n+      /* Otherwise, we pass in VRs only.  Check for partial copies.  */\n       passed_in_gprs = false;\n+      if (cum->vregno + n_elts > ALTIVEC_ARG_MAX_REG + 1)\n+\tret = (ALTIVEC_ARG_MAX_REG + 1 - cum->vregno) * 16;\n     }\n \n   /* In this complicated case we just disable the partial_nregs code.  */\n@@ -9866,25 +10154,26 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \n   align_words = rs6000_parm_start (mode, type, cum->words);\n \n-  if (USE_FP_FOR_ARG_P (cum, mode))\n+  if (USE_FP_FOR_ARG_P (cum, elt_mode))\n     {\n-      unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n+      unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;\n \n       /* If we are passing this arg in the fixed parameter save area\n          (gprs or memory) as well as FPRs, we do not use the partial\n \t bytes mechanism; instead, rs6000_function_arg will return a\n \t PARALLEL including a memory element as necessary.  */\n       if (type\n \t  && (cum->nargs_prototype <= 0\n-\t      || (DEFAULT_ABI == ABI_AIX\n+\t      || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t\t  && TARGET_XL_COMPAT\n \t\t  && align_words >= GP_ARG_NUM_REG)))\n \treturn 0;\n \n       /* Otherwise, we pass in FPRs only.  Check for partial copies.  */\n       passed_in_gprs = false;\n-      if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n-\tret = (FP_ARG_MAX_REG + 1 - cum->fregno) * 8;\n+      if (cum->fregno + n_elts * n_fpreg > FP_ARG_MAX_REG + 1)\n+\tret = ((FP_ARG_MAX_REG + 1 - cum->fregno)\n+\t       * MIN (8, GET_MODE_SIZE (elt_mode)));\n     }\n \n   if (passed_in_gprs\n@@ -9969,6 +10258,139 @@ rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+/* Process parameter of type TYPE after ARGS_SO_FAR parameters were\n+   already processes.  Return true if the parameter must be passed\n+   (fully or partially) on the stack.  */\n+\n+static bool\n+rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n+{\n+  enum machine_mode mode;\n+  int unsignedp;\n+  rtx entry_parm;\n+\n+  /* Catch errors.  */\n+  if (type == NULL || type == error_mark_node)\n+    return true;\n+\n+  /* Handle types with no storage requirement.  */\n+  if (TYPE_MODE (type) == VOIDmode)\n+    return false;\n+\n+  /* Handle complex types.  */\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    return (rs6000_parm_needs_stack (args_so_far, TREE_TYPE (type))\n+\t    || rs6000_parm_needs_stack (args_so_far, TREE_TYPE (type)));\n+\n+  /* Handle transparent aggregates.  */\n+  if ((TREE_CODE (type) == UNION_TYPE || TREE_CODE (type) == RECORD_TYPE)\n+      && TYPE_TRANSPARENT_AGGR (type))\n+    type = TREE_TYPE (first_field (type));\n+\n+  /* See if this arg was passed by invisible reference.  */\n+  if (pass_by_reference (get_cumulative_args (args_so_far),\n+\t\t\t TYPE_MODE (type), type, true))\n+    type = build_pointer_type (type);\n+\n+  /* Find mode as it is passed by the ABI.  */\n+  unsignedp = TYPE_UNSIGNED (type);\n+  mode = promote_mode (type, TYPE_MODE (type), &unsignedp);\n+\n+  /* If we must pass in stack, we need a stack.  */\n+  if (rs6000_must_pass_in_stack (mode, type))\n+    return true;\n+\n+  /* If there is no incoming register, we need a stack.  */\n+  entry_parm = rs6000_function_arg (args_so_far, mode, type, true);\n+  if (entry_parm == NULL)\n+    return true;\n+\n+  /* Likewise if we need to pass both in registers and on the stack.  */\n+  if (GET_CODE (entry_parm) == PARALLEL\n+      && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n+    return true;\n+\n+  /* Also true if we're partially in registers and partially not.  */\n+  if (rs6000_arg_partial_bytes (args_so_far, mode, type, true) != 0)\n+    return true;\n+\n+  /* Update info on where next arg arrives in registers.  */\n+  rs6000_function_arg_advance (args_so_far, mode, type, true);\n+  return false;\n+}\n+\n+/* Return true if FUN has no prototype, has a variable argument\n+   list, or passes any parameter in memory.  */\n+\n+static bool\n+rs6000_function_parms_need_stack (tree fun)\n+{\n+  function_args_iterator args_iter;\n+  tree arg_type;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n+\n+  if (!fun)\n+    /* Must be a libcall, all of which only use reg parms.  */\n+    return false;\n+  if (!TYPE_P (fun))\n+    fun = TREE_TYPE (fun);\n+\n+  /* Varargs functions need the parameter save area.  */\n+  if (!prototype_p (fun) || stdarg_p (fun))\n+    return true;\n+\n+  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far_v, fun, NULL_RTX);\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n+\n+  if (aggregate_value_p (TREE_TYPE (fun), fun))\n+    {\n+      tree type = build_pointer_type (TREE_TYPE (fun));\n+      rs6000_parm_needs_stack (args_so_far, type);\n+    }\n+\n+  FOREACH_FUNCTION_ARGS (fun, arg_type, args_iter)\n+    if (rs6000_parm_needs_stack (args_so_far, arg_type))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return the size of the REG_PARM_STACK_SPACE are for FUN.  This is\n+   usually a constant depending on the ABI.  However, in the ELFv2 ABI\n+   the register parameter area is optional when calling a function that\n+   has a prototype is scope, has no variable argument list, and passes\n+   all parameters in registers.  */\n+\n+int\n+rs6000_reg_parm_stack_space (tree fun)\n+{\n+  int reg_parm_stack_space;\n+\n+  switch (DEFAULT_ABI)\n+    {\n+    default:\n+      reg_parm_stack_space = 0;\n+      break;\n+\n+    case ABI_AIX:\n+    case ABI_DARWIN:\n+      reg_parm_stack_space = TARGET_64BIT ? 64 : 32;\n+      break;\n+\n+    case ABI_ELFv2:\n+      /* ??? Recomputing this every time is a bit expensive.  Is there\n+\t a place to cache this information?  */\n+      if (rs6000_function_parms_need_stack (fun))\n+\treg_parm_stack_space = TARGET_64BIT ? 64 : 32;\n+      else\n+\treg_parm_stack_space = 0;\n+      break;\n+    }\n+\n+  return reg_parm_stack_space;\n+}\n+\n static void\n rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n {\n@@ -10348,6 +10770,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \n   if (((TARGET_MACHO\n         && rs6000_darwin64_abi)\n+       || DEFAULT_ABI == ABI_ELFv2\n        || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))\n       && integer_zerop (TYPE_SIZE (type)))\n     {\n@@ -16678,6 +17101,7 @@ rs6000_output_function_entry (FILE *file, const char *fname)\n \t    ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"L.\");\n \t  break;\n \n+\tcase ABI_ELFv2:\n \tcase ABI_V4:\n \tcase ABI_DARWIN:\n \t  break;\n@@ -19630,7 +20054,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n     }\n   else\n     {\n-      gcc_checking_assert (DEFAULT_ABI == ABI_AIX);\n+      gcc_checking_assert (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2);\n       if (info->first_fp_reg_save > 61)\n \tstrategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;\n       strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n@@ -19775,6 +20199,34 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n    The required alignment for AIX configurations is two words (i.e., 8\n    or 16 bytes).\n \n+   The ELFv2 ABI is a variant of the AIX ABI.  Stack frames look like:\n+\n+\tSP---->\t+---------------------------------------+\n+\t\t| Back chain to caller\t\t\t|  0\n+\t\t+---------------------------------------+\n+\t\t| Save area for CR\t\t\t|  8\n+\t\t+---------------------------------------+\n+\t\t| Saved LR\t\t\t\t|  16\n+\t\t+---------------------------------------+\n+\t\t| Saved TOC pointer\t\t\t|  24\n+\t\t+---------------------------------------+\n+\t\t| Parameter save area (P)\t\t|  32\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t|  32+P\n+\t\t+---------------------------------------+\n+\t\t| Local variable space (L)\t\t|  32+P+A\n+\t\t+---------------------------------------+\n+\t\t| Save area for AltiVec registers (W)\t|  32+P+A+L\n+\t\t+---------------------------------------+\n+\t\t| AltiVec alignment padding (Y)\t\t|  32+P+A+L+W\n+\t\t+---------------------------------------+\n+\t\t| Save area for GP registers (G)\t|  32+P+A+L+W+Y\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t|  32+P+A+L+W+Y+G\n+\t\t+---------------------------------------+\n+\told SP->| back chain to caller's caller\t\t|  32+P+A+L+W+Y+G+F\n+\t\t+---------------------------------------+\n+\n \n    V.4 stack frames look like:\n \n@@ -19835,6 +20287,7 @@ rs6000_stack_info (void)\n   rs6000_stack_t *info_ptr = &stack_info;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int ehrd_size;\n+  int ehcr_size;\n   int save_align;\n   int first_gp;\n   HOST_WIDE_INT non_fixed_size;\n@@ -19928,6 +20381,18 @@ rs6000_stack_info (void)\n   else\n     ehrd_size = 0;\n \n+  /* In the ELFv2 ABI, we also need to allocate space for separate\n+     CR field save areas if the function calls __builtin_eh_return.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && crtl->calls_eh_return)\n+    {\n+      /* This hard-codes that we have three call-saved CR fields.  */\n+      ehcr_size = 3 * reg_size;\n+      /* We do *not* use the regular CR save mechanism.  */\n+      info_ptr->cr_save_p = 0;\n+    }\n+  else\n+    ehcr_size = 0;\n+\n   /* Determine various sizes.  */\n   info_ptr->reg_size     = reg_size;\n   info_ptr->fixed_size   = RS6000_SAVE_AREA;\n@@ -19967,6 +20432,7 @@ rs6000_stack_info (void)\n       gcc_unreachable ();\n \n     case ABI_AIX:\n+    case ABI_ELFv2:\n     case ABI_DARWIN:\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n@@ -19996,6 +20462,8 @@ rs6000_stack_info (void)\n \t}\n       else\n \tinfo_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n+\n+      info_ptr->ehcr_offset      = info_ptr->ehrd_offset - ehcr_size;\n       info_ptr->cr_save_offset   = reg_size; /* first word when 64-bit.  */\n       info_ptr->lr_save_offset   = 2*reg_size;\n       break;\n@@ -20058,6 +20526,7 @@ rs6000_stack_info (void)\n \t\t\t\t\t + info_ptr->spe_gp_size\n \t\t\t\t\t + info_ptr->spe_padding_size\n \t\t\t\t\t + ehrd_size\n+\t\t\t\t\t + ehcr_size\n \t\t\t\t\t + info_ptr->cr_size\n \t\t\t\t\t + info_ptr->vrsave_size,\n \t\t\t\t\t save_align);\n@@ -20071,7 +20540,7 @@ rs6000_stack_info (void)\n \n   /* Determine if we need to save the link register.  */\n   if (info_ptr->calls_p\n-      || (DEFAULT_ABI == ABI_AIX\n+      || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t  && crtl->profile\n \t  && !TARGET_PROFILE_KERNEL)\n       || (DEFAULT_ABI == ABI_V4 && cfun->calls_alloca)\n@@ -20217,6 +20686,7 @@ debug_stack_info (rs6000_stack_t *info)\n     default:\t\t abi_string = \"Unknown\";\tbreak;\n     case ABI_NONE:\t abi_string = \"NONE\";\t\tbreak;\n     case ABI_AIX:\t abi_string = \"AIX\";\t\tbreak;\n+    case ABI_ELFv2:\t abi_string = \"ELFv2\";\t\tbreak;\n     case ABI_DARWIN:\t abi_string = \"Darwin\";\t\tbreak;\n     case ABI_V4:\t abi_string = \"V.4\";\t\tbreak;\n     }\n@@ -20398,13 +20868,13 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp)\n \treturn false;\n     }\n \n-  /* Under the AIX ABI we can't allow calls to non-local functions,\n-     because the callee may have a different TOC pointer to the\n-     caller and there's no way to ensure we restore the TOC when we\n-     return.  With the secure-plt SYSV ABI we can't make non-local\n+  /* Under the AIX or ELFv2 ABIs we can't allow calls to non-local\n+     functions, because the callee may have a different TOC pointer to\n+     the caller and there's no way to ensure we restore the TOC when\n+     we return.  With the secure-plt SYSV ABI we can't make non-local\n      calls when -fpic/PIC because the plt call stubs use r30.  */\n   if (DEFAULT_ABI == ABI_DARWIN\n-      || (DEFAULT_ABI == ABI_AIX\n+      || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t  && decl\n \t  && !DECL_EXTERNAL (decl)\n \t  && (*targetm.binds_local_p) (decl))\n@@ -20563,7 +21033,7 @@ rs6000_emit_load_toc_table (int fromprolog)\n     }\n   else\n     {\n-      gcc_assert (DEFAULT_ABI == ABI_AIX);\n+      gcc_assert (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2);\n \n       if (TARGET_32BIT)\n \temit_insn (gen_load_toc_aix_si (dest));\n@@ -21282,7 +21752,7 @@ rs6000_savres_routine_name (rs6000_stack_t *info, int regno, int sel)\n       if ((sel & SAVRES_LR))\n \tsuffix = \"_x\";\n     }\n-  else if (DEFAULT_ABI == ABI_AIX)\n+  else if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n #if !defined (POWERPC_LINUX) && !defined (POWERPC_FREEBSD)\n       /* No out-of-line save/restore routines for GPRs on AIX.  */\n@@ -21423,7 +21893,7 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n static inline unsigned\n ptr_regno_for_savres (int sel)\n {\n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     return (sel & SAVRES_REG) == SAVRES_FPR || (sel & SAVRES_LR) ? 1 : 12;\n   return DEFAULT_ABI == ABI_DARWIN && (sel & SAVRES_REG) == SAVRES_FPR ? 1 : 11;\n }\n@@ -21508,6 +21978,43 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n   return insn;\n }\n \n+/* Emit code to store CR fields that need to be saved into REG.  */\n+\n+static void\n+rs6000_emit_move_from_cr (rtx reg)\n+{\n+  /* Only the ELFv2 ABI allows storing only selected fields.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && TARGET_MFCRF)\n+    {\n+      int i, cr_reg[8], count = 0;\n+\n+      /* Collect CR fields that must be saved.  */\n+      for (i = 0; i < 8; i++)\n+\tif (save_reg_p (CR0_REGNO + i))\n+\t  cr_reg[count++] = i;\n+\n+      /* If it's just a single one, use mfcrf.  */\n+      if (count == 1)\n+\t{\n+\t  rtvec p = rtvec_alloc (1);\n+\t  rtvec r = rtvec_alloc (2);\n+\t  RTVEC_ELT (r, 0) = gen_rtx_REG (CCmode, CR0_REGNO + cr_reg[0]);\n+\t  RTVEC_ELT (r, 1) = GEN_INT (1 << (7 - cr_reg[0]));\n+\t  RTVEC_ELT (p, 0)\n+\t    = gen_rtx_SET (VOIDmode, reg,\n+\t\t\t   gen_rtx_UNSPEC (SImode, r, UNSPEC_MOVESI_FROM_CR));\n+\n+\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\t  return;\n+\t}\n+\n+      /* ??? It might be better to handle count == 2 / 3 cases here\n+\t as well, using logical operations to combine the values.  */\n+    }\n+\n+  emit_insn (gen_movesi_from_cr (reg));\n+}\n+\n /* Determine whether the gp REG is really used.  */\n \n static bool\n@@ -21573,6 +22080,17 @@ rs6000_emit_prologue (void)\n #define NOT_INUSE(R) do {} while (0)\n #endif\n \n+  if (DEFAULT_ABI == ABI_ELFv2)\n+    {\n+      cfun->machine->r2_setup_needed = df_regs_ever_live_p (TOC_REGNUM);\n+\n+      /* With -mminimal-toc we may generate an extra use of r2 below.  */\n+      if (!TARGET_SINGLE_PIC_BASE\n+\t  && TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n+\tcfun->machine->r2_setup_needed = true;\n+    }\n+\n+\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = info->total_size;\n \n@@ -21790,7 +22308,7 @@ rs6000_emit_prologue (void)\n \n   /* If we need to save CR, put it into r12 or r11.  Choose r12 except when\n      r12 will be needed by out-of-line gpr restore.  */\n-  cr_save_regno = (DEFAULT_ABI == ABI_AIX\n+  cr_save_regno = ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t\t   && !(strategy & (SAVE_INLINE_GPRS\n \t\t\t\t    | SAVE_NOINLINE_GPRS_SAVES_LR))\n \t\t   ? 11 : 12);\n@@ -21801,7 +22319,7 @@ rs6000_emit_prologue (void)\n     {\n       cr_save_rtx = gen_rtx_REG (SImode, cr_save_regno);\n       START_USE (cr_save_regno);\n-      emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+      rs6000_emit_move_from_cr (cr_save_rtx);\n     }\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n@@ -22053,7 +22571,8 @@ rs6000_emit_prologue (void)\n \t be updated if we arrived at this function via a plt call or\n \t toc adjusting stub.  */\n       emit_move_insn (tmp_reg_si, gen_rtx_MEM (SImode, tmp_reg));\n-      toc_restore_insn = TARGET_32BIT ? 0x80410014 : 0xE8410028;\n+      toc_restore_insn = ((TARGET_32BIT ? 0x80410000 : 0xE8410000)\n+\t\t\t  + RS6000_TOC_SAVE_SLOT);\n       hi = gen_int_mode (toc_restore_insn & ~0xffff, SImode);\n       emit_insn (gen_xorsi3 (tmp_reg_si, tmp_reg_si, hi));\n       compare_result = gen_rtx_REG (CCUNSmode, CR0_REGNO);\n@@ -22072,7 +22591,7 @@ rs6000_emit_prologue (void)\n       LABEL_NUSES (toc_save_done) += 1;\n \n       save_insn = emit_frame_save (frame_reg_rtx, reg_mode,\n-\t\t\t\t   TOC_REGNUM, frame_off + 5 * reg_size,\n+\t\t\t\t   TOC_REGNUM, frame_off + RS6000_TOC_SAVE_SLOT,\n \t\t\t\t   sp_off - frame_off);\n \n       emit_label (toc_save_done);\n@@ -22118,7 +22637,7 @@ rs6000_emit_prologue (void)\n \t{\n \t  START_USE (0);\n \t  cr_save_rtx = gen_rtx_REG (SImode, 0);\n-\t  emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+\t  rs6000_emit_move_from_cr (cr_save_rtx);\n \t}\n \n       /* Saving CR requires a two-instruction sequence: one instruction\n@@ -22162,12 +22681,71 @@ rs6000_emit_prologue (void)\n \t\t\t   GEN_INT (info->cr_save_offset + sp_off));\n       mem = gen_frame_mem (SImode, addr);\n \n-      /* We still cannot express that multiple CR fields are saved in the\n-\t CR save slot.  By convention, we use a single CR regnum to represent\n-\t the fact that all call-saved CR fields are saved.  We use CR2_REGNO\n-\t to be compatible with gcc-2.95 on Linux.  */\n-      rtx set = gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (SImode, CR2_REGNO));\n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n+      if (DEFAULT_ABI == ABI_ELFv2)\n+\t{\n+\t  /* In the ELFv2 ABI we generate separate CFI records for each\n+\t     CR field that was actually saved.  They all point to the\n+\t     same 32-bit stack slot.  */\n+\t  rtx crframe[8];\n+\t  int n_crframe = 0;\n+\n+\t  for (i = 0; i < 8; i++)\n+\t    if (save_reg_p (CR0_REGNO + i))\n+\t      {\n+\t\tcrframe[n_crframe]\n+\t\t  = gen_rtx_SET (VOIDmode, mem,\n+\t\t\t\t gen_rtx_REG (SImode, CR0_REGNO + i));\n+\n+\t\tRTX_FRAME_RELATED_P (crframe[n_crframe]) = 1;\n+\t\tn_crframe++;\n+\t     }\n+\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t  gen_rtvec_v (n_crframe, crframe)));\n+\t}\n+      else\n+\t{\n+\t  /* In other ABIs, by convention, we use a single CR regnum to\n+\t     represent the fact that all call-saved CR fields are saved.\n+\t     We use CR2_REGNO to be compatible with gcc-2.95 on Linux.  */\n+\t  rtx set = gen_rtx_SET (VOIDmode, mem,\n+\t\t\t\t gen_rtx_REG (SImode, CR2_REGNO));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n+\t}\n+    }\n+\n+  /* In the ELFv2 ABI we need to save all call-saved CR fields into\n+     *separate* slots if the routine calls __builtin_eh_return, so\n+     that they can be independently restored by the unwinder.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && crtl->calls_eh_return)\n+    {\n+      int i, cr_off = info->ehcr_offset;\n+      rtx crsave;\n+\n+      /* ??? We might get better performance by using multiple mfocrf\n+\t instructions.  */\n+      crsave = gen_rtx_REG (SImode, 0);\n+      emit_insn (gen_movesi_from_cr (crsave));\n+\n+      for (i = 0; i < 8; i++)\n+\tif (!call_used_regs[CR0_REGNO + i])\n+\t  {\n+\t    rtvec p = rtvec_alloc (2);\n+\t    RTVEC_ELT (p, 0)\n+\t      = gen_frame_store (crsave, frame_reg_rtx, cr_off + frame_off);\n+\t    RTVEC_ELT (p, 1)\n+\t      = gen_rtx_USE (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO + i));\n+\n+\t    insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t  gen_frame_store (gen_rtx_REG (SImode, CR0_REGNO + i),\n+\t\t\t\t\t   sp_reg_rtx, cr_off + sp_off));\n+\n+\t    cr_off += reg_size;\n+\t  }\n     }\n \n   /* Update stack and set back pointer unless this is V.4,\n@@ -22306,7 +22884,8 @@ rs6000_emit_prologue (void)\n \t be using r12 as frame_reg_rtx and r11 as the static chain\n \t pointer for nested functions.  */\n       save_regno = 12;\n-      if (DEFAULT_ABI == ABI_AIX && !using_static_chain_p)\n+      if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+\t  && !using_static_chain_p)\n \tsave_regno = 11;\n       else if (REGNO (frame_reg_rtx) == 12)\n \t{\n@@ -22407,7 +22986,7 @@ rs6000_emit_prologue (void)\n   if (rs6000_save_toc_in_prologue_p ())\n     {\n       rtx reg = gen_rtx_REG (reg_mode, TOC_REGNUM);\n-      emit_insn (gen_frame_store (reg, sp_reg_rtx, 5 * reg_size));\n+      emit_insn (gen_frame_store (reg, sp_reg_rtx, RS6000_TOC_SAVE_SLOT));\n     }\n }\n \n@@ -22448,6 +23027,49 @@ rs6000_output_function_prologue (FILE *file,\n \t}\n     }\n \n+  /* ELFv2 ABI r2 setup code and local entry point.  This must follow\n+     immediately after the global entry point label.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && cfun->machine->r2_setup_needed)\n+    {\n+      const char *name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+\n+      fprintf (file, \"0:\\taddis 2,12,.TOC.-0b@ha\\n\");\n+      fprintf (file, \"\\taddi 2,2,.TOC.-0b@l\\n\");\n+\n+      fputs (\"\\t.localentry\\t\", file);\n+      assemble_name (file, name);\n+      fputs (\",.-\", file);\n+      assemble_name (file, name);\n+      fputs (\"\\n\", file);\n+    }\n+\n+  /* Output -mprofile-kernel code.  This needs to be done here instead of\n+     in output_function_profile since it must go after the ELFv2 ABI\n+     local entry point.  */\n+  if (TARGET_PROFILE_KERNEL)\n+    {\n+      gcc_assert (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2);\n+      gcc_assert (!TARGET_32BIT);\n+\n+      asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n+      asm_fprintf (file, \"\\tstd %s,16(%s)\\n\", reg_names[0], reg_names[1]);\n+\n+      /* In the ELFv2 ABI we have no compiler stack word.  It must be\n+\t the resposibility of _mcount to preserve the static chain\n+\t register if required.  */\n+      if (DEFAULT_ABI != ABI_ELFv2\n+\t  && cfun->static_chain_decl != NULL)\n+\t{\n+\t  asm_fprintf (file, \"\\tstd %s,24(%s)\\n\",\n+\t\t       reg_names[STATIC_CHAIN_REGNUM], reg_names[1]);\n+\t  fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n+\t  asm_fprintf (file, \"\\tld %s,24(%s)\\n\",\n+\t\t       reg_names[STATIC_CHAIN_REGNUM], reg_names[1]);\n+\t}\n+      else\n+\tfprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n+    }\n+\n   rs6000_pic_labelno++;\n }\n \n@@ -22500,6 +23122,7 @@ restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n \n   if (using_mfcr_multiple && count > 1)\n     {\n+      rtx insn;\n       rtvec p;\n       int ndx;\n \n@@ -22517,16 +23140,43 @@ restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n \t\t\t   gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n \t    ndx++;\n \t  }\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       gcc_assert (ndx == count);\n+\n+      /* For the ELFv2 ABI we generate a CFA_RESTORE for each\n+\t CR field separately.  */\n+      if (!exit_func && DEFAULT_ABI == ABI_ELFv2 && flag_shrink_wrap)\n+\t{\n+\t  for (i = 0; i < 8; i++)\n+\t    if (save_reg_p (CR0_REGNO + i))\n+\t      add_reg_note (insn, REG_CFA_RESTORE,\n+\t\t\t    gen_rtx_REG (SImode, CR0_REGNO + i));\n+\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n     }\n   else\n     for (i = 0; i < 8; i++)\n       if (save_reg_p (CR0_REGNO + i))\n-\temit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode, CR0_REGNO + i),\n-\t\t\t\t\treg));\n+\t{\n+\t  rtx insn = emit_insn (gen_movsi_to_cr_one\n+\t\t\t\t (gen_rtx_REG (CCmode, CR0_REGNO + i), reg));\n+\n+\t  /* For the ELFv2 ABI we generate a CFA_RESTORE for each\n+\t     CR field separately, attached to the insn that in fact\n+\t     restores this particular CR field.  */\n+\t  if (!exit_func && DEFAULT_ABI == ABI_ELFv2 && flag_shrink_wrap)\n+\t    {\n+\t      add_reg_note (insn, REG_CFA_RESTORE,\n+\t\t\t    gen_rtx_REG (SImode, CR0_REGNO + i));\n \n-  if (!exit_func && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t}\n+\n+  /* For other ABIs, we just generate a single CFA_RESTORE for CR2.  */\n+  if (!exit_func && DEFAULT_ABI != ABI_ELFv2\n+      && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n     {\n       rtx insn = get_last_insn ();\n       rtx cr = gen_rtx_REG (SImode, CR2_REGNO);\n@@ -22567,10 +23217,22 @@ restore_saved_lr (int regno, bool exit_func)\n static rtx\n add_crlr_cfa_restore (const rs6000_stack_t *info, rtx cfa_restores)\n {\n-  if (info->cr_save_p)\n+  if (DEFAULT_ABI == ABI_ELFv2)\n+    {\n+      int i;\n+      for (i = 0; i < 8; i++)\n+\tif (save_reg_p (CR0_REGNO + i))\n+\t  {\n+\t    rtx cr = gen_rtx_REG (SImode, CR0_REGNO + i);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, cr,\n+\t\t\t\t\t   cfa_restores);\n+\t  }\n+    }\n+  else if (info->cr_save_p)\n     cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n \t\t\t\t   gen_rtx_REG (SImode, CR2_REGNO),\n \t\t\t\t   cfa_restores);\n+\n   if (info->lr_save_p)\n     cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n \t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n@@ -23068,6 +23730,35 @@ rs6000_emit_epilogue (int sibcall)\n \t       || (!restoring_GPRs_inline\n \t\t   && info->first_fp_reg_save == 64));\n \n+  /* In the ELFv2 ABI we need to restore all call-saved CR fields from\n+     *separate* slots if the routine calls __builtin_eh_return, so\n+     that they can be independently restored by the unwinder.  */\n+  if (DEFAULT_ABI == ABI_ELFv2 && crtl->calls_eh_return)\n+    {\n+      int i, cr_off = info->ehcr_offset;\n+\n+      for (i = 0; i < 8; i++)\n+\tif (!call_used_regs[CR0_REGNO + i])\n+\t  {\n+\t    rtx reg = gen_rtx_REG (SImode, 0);\n+\t    emit_insn (gen_frame_load (reg, frame_reg_rtx,\n+\t\t\t\t       cr_off + frame_off));\n+\n+\t    insn = emit_insn (gen_movsi_to_cr_one\n+\t\t\t\t(gen_rtx_REG (CCmode, CR0_REGNO + i), reg));\n+\n+\t    if (!exit_func && flag_shrink_wrap)\n+\t      {\n+\t\tadd_reg_note (insn, REG_CFA_RESTORE,\n+\t\t\t      gen_rtx_REG (SImode, CR0_REGNO + i));\n+\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t      }\n+\n+\t    cr_off += reg_size;\n+\t  }\n+    }\n+\n   /* Get the old lr if we saved it.  If we are restoring registers\n      out-of-line, then the out-of-line routines can do this for us.  */\n   if (restore_lr && restoring_GPRs_inline)\n@@ -23111,7 +23802,7 @@ rs6000_emit_epilogue (int sibcall)\n \t{\n \t  rtx reg = gen_rtx_REG (reg_mode, 2);\n \t  emit_insn (gen_frame_load (reg, frame_reg_rtx,\n-\t\t\t\t     frame_off + 5 * reg_size));\n+\t\t\t\t     frame_off + RS6000_TOC_SAVE_SLOT));\n \t}\n \n       for (i = 0; ; ++i)\n@@ -23397,6 +24088,7 @@ rs6000_emit_epilogue (int sibcall)\n       if (! restoring_FPRs_inline)\n \t{\n \t  int i;\n+\t  int reg;\n \t  rtx sym;\n \n \t  if (flag_shrink_wrap)\n@@ -23405,10 +24097,9 @@ rs6000_emit_epilogue (int sibcall)\n \t  sym = rs6000_savres_routine_sym (info,\n \t\t\t\t\t   SAVRES_FPR | (lr ? SAVRES_LR : 0));\n \t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode, sym);\n-\t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t       DEFAULT_ABI == ABI_AIX\n-\t\t\t\t\t\t       ? 1 : 11));\n+\t  reg = (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)? 1 : 11;\n+\t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, reg));\n+\n \t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \t    {\n \t      rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n@@ -23486,7 +24177,8 @@ rs6000_output_function_epilogue (FILE *file,\n \n      System V.4 Powerpc's (and the embedded ABI derived from it) use a\n      different traceback table.  */\n-  if (DEFAULT_ABI == ABI_AIX && ! flag_inhibit_size_directive\n+  if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+      && ! flag_inhibit_size_directive\n       && rs6000_traceback != traceback_none && !cfun->is_thunk)\n     {\n       const char *fname = NULL;\n@@ -23814,6 +24506,12 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   SIBLING_CALL_P (insn) = 1;\n   emit_barrier ();\n \n+  /* Ensure we have a global entry point for the thunk.   ??? We could\n+     avoid that if the target routine doesn't need a global entry point,\n+     but we do not know whether this is the case at this point.  */\n+  if (DEFAULT_ABI == ABI_ELFv2)\n+    cfun->machine->r2_setup_needed = true;\n+\n   /* Run just enough of rest_of_compilation to get the insns emitted.\n      There's not really enough bulk here to make other passes such as\n      instruction scheduling worth while.  Note that use_thunk calls\n@@ -24489,7 +25187,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n   if (TARGET_PROFILE_KERNEL)\n     return;\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n #ifndef NO_PROFILE_COUNTERS\n # define NO_PROFILE_COUNTERS 0\n@@ -24633,29 +25331,9 @@ output_function_profiler (FILE *file, int labelno)\n       break;\n \n     case ABI_AIX:\n+    case ABI_ELFv2:\n     case ABI_DARWIN:\n-      if (!TARGET_PROFILE_KERNEL)\n-\t{\n-\t  /* Don't do anything, done in output_profile_hook ().  */\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (!TARGET_32BIT);\n-\n-\t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n-\t  asm_fprintf (file, \"\\tstd %s,16(%s)\\n\", reg_names[0], reg_names[1]);\n-\n-\t  if (cfun->static_chain_decl != NULL)\n-\t    {\n-\t      asm_fprintf (file, \"\\tstd %s,24(%s)\\n\",\n-\t\t\t   reg_names[STATIC_CHAIN_REGNUM], reg_names[1]);\n-\t      fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n-\t      asm_fprintf (file, \"\\tld %s,24(%s)\\n\",\n-\t\t\t   reg_names[STATIC_CHAIN_REGNUM], reg_names[1]);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n-\t}\n+      /* Don't do anything, done in output_profile_hook ().  */\n       break;\n     }\n }\n@@ -26591,6 +27269,11 @@ rs6000_trampoline_size (void)\n       ret = (TARGET_32BIT) ? 12 : 24;\n       break;\n \n+    case ABI_ELFv2:\n+      gcc_assert (!TARGET_32BIT);\n+      ret = 32;\n+      break;\n+\n     case ABI_DARWIN:\n     case ABI_V4:\n       ret = (TARGET_32BIT) ? 40 : 48;\n@@ -26646,6 +27329,7 @@ rs6000_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n       break;\n \n     /* Under V.4/eabi/darwin, __trampoline_setup does the real work.  */\n+    case ABI_ELFv2:\n     case ABI_DARWIN:\n     case ABI_V4:\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__trampoline_setup\"),\n@@ -26940,7 +27624,7 @@ rs6000_ms_bitfield_layout_p (const_tree record_type)\n static void\n rs6000_elf_output_toc_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n {\n-  if (DEFAULT_ABI == ABI_AIX\n+  if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n       && TARGET_MINIMAL_TOC\n       && !TARGET_RELOCATABLE)\n     {\n@@ -26961,7 +27645,8 @@ rs6000_elf_output_toc_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n       else\n \tfprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\n     }\n-  else if (DEFAULT_ABI == ABI_AIX && !TARGET_RELOCATABLE)\n+  else if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+\t   && !TARGET_RELOCATABLE)\n     fprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\n   else\n     {\n@@ -27511,7 +28196,7 @@ rs6000_elf_reloc_rw_mask (void)\n {\n   if (flag_pic)\n     return 3;\n-  else if (DEFAULT_ABI == ABI_AIX)\n+  else if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     return 2;\n   else\n     return 0;\n@@ -27587,7 +28272,7 @@ rs6000_elf_asm_out_destructor (rtx symbol, int priority)\n void\n rs6000_elf_declare_function_name (FILE *file, const char *name, tree decl)\n {\n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT && DEFAULT_ABI != ABI_ELFv2)\n     {\n       fputs (\"\\t.section\\t\\\".opd\\\",\\\"aw\\\"\\n\\t.align 3\\n\", file);\n       ASM_OUTPUT_LABEL (file, name);\n@@ -27682,7 +28367,7 @@ rs6000_elf_file_end (void)\n     }\n #endif\n #if defined (POWERPC_LINUX) || defined (POWERPC_FREEBSD)\n-  if (TARGET_32BIT)\n+  if (TARGET_32BIT || DEFAULT_ABI == ABI_ELFv2)\n     file_end_indicate_exec_stack ();\n #endif\n }\n@@ -29412,6 +30097,8 @@ rs6000_function_value (const_tree valtype,\n {\n   enum machine_mode mode;\n   unsigned int regno;\n+  enum machine_mode elt_mode;\n+  int n_elts;\n \n   /* Special handling for structs in darwin64.  */\n   if (TARGET_MACHO \n@@ -29431,6 +30118,36 @@ rs6000_function_value (const_tree valtype,\n       /* Otherwise fall through to standard ABI rules.  */\n     }\n \n+  /* The ELFv2 ABI returns homogeneous VFP aggregates in registers.  */\n+  if (rs6000_discover_homogeneous_aggregate (TYPE_MODE (valtype), valtype,\n+\t\t\t\t\t     &elt_mode, &n_elts))\n+    {\n+      int first_reg, n_regs, i;\n+      rtx par;\n+\n+      if (SCALAR_FLOAT_MODE_P (elt_mode))\n+\t{\n+\t  /* _Decimal128 must use even/odd register pairs.  */\n+\t  first_reg = (elt_mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n+\t  n_regs = (GET_MODE_SIZE (elt_mode) + 7) >> 3;\n+\t}\n+      else\n+\t{\n+\t  first_reg = ALTIVEC_ARG_RETURN;\n+\t  n_regs = 1;\n+\t}\n+\n+      par = gen_rtx_PARALLEL (TYPE_MODE (valtype), rtvec_alloc (n_elts));\n+      for (i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx r = gen_rtx_REG (elt_mode, first_reg + i * n_regs);\n+\t  rtx off = GEN_INT (i * GET_MODE_SIZE (elt_mode));\n+\t  XVECEXP (par, 0, i) = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t}\n+\n+      return par;\n+    }\n+\n   if (TARGET_32BIT && TARGET_POWERPC64 && TYPE_MODE (valtype) == DImode)\n     {\n       /* Long long return value need be split in -mpowerpc64, 32bit ABI.  */\n@@ -30637,7 +31354,7 @@ rs6000_legitimate_constant_p (enum machine_mode mode, rtx x)\n \n \f\n \n-/* Expand code to perform a call under the AIX ABI.  */\n+/* Expand code to perform a call under the AIX or ELFv2 ABI.  */\n \n void\n rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n@@ -30657,12 +31374,12 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n \n   /* Handle indirect calls.  */\n   if (GET_CODE (func_desc) != SYMBOL_REF\n-      || !SYMBOL_REF_FUNCTION_P (func_desc))\n+      || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (func_desc)))\n     {\n       /* Save the TOC into its reserved slot before the call,\n \t and prepare to restore it after the call.  */\n       rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-      rtx stack_toc_offset = GEN_INT (5 * GET_MODE_SIZE (Pmode));\n+      rtx stack_toc_offset = GEN_INT (RS6000_TOC_SAVE_SLOT);\n       rtx stack_toc_mem = gen_frame_mem (Pmode,\n \t\t\t\t\t gen_rtx_PLUS (Pmode, stack_ptr,\n \t\t\t\t\t\t       stack_toc_offset));\n@@ -30678,38 +31395,49 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n \t  emit_move_insn (stack_toc_mem, toc_reg);\n \t}\n \n-      /* A function pointer under AIX is a pointer to a data area whose\n-\t first word contains the actual address of the function, whose\n-\t second word contains a pointer to its TOC, and whose third word\n-\t contains a value to place in the static chain register (r11).\n-\t Note that if we load the static chain, our \"trampoline\" need\n-\t not have any executable code.  */\n-\n-      /* Load up address of the actual function.  */\n-      func_desc = force_reg (Pmode, func_desc);\n-      func_addr = gen_reg_rtx (Pmode);\n-      emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n-\n-      /* Prepare to load the TOC of the called function.  Note that the\n-\t TOC load must happen immediately before the actual call so\n-\t that unwinding the TOC registers works correctly.  See the\n-\t comment in frob_update_context.  */\n-      rtx func_toc_offset = GEN_INT (GET_MODE_SIZE (Pmode));\n-      rtx func_toc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t\t      gen_rtx_PLUS (Pmode, func_desc,\n-\t\t\t\t\t\t    func_toc_offset));\n-      toc_load = gen_rtx_USE (VOIDmode, func_toc_mem);\n-\n-      /* If we have a static chain, load it up.  */\n-      if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n-\t{\n-\t  rtx sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\t  rtx func_sc_offset = GEN_INT (2 * GET_MODE_SIZE (Pmode));\n-\t  rtx func_sc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t\t\t gen_rtx_PLUS (Pmode, func_desc,\n-\t\t\t\t\t\t       func_sc_offset));\n-\t  emit_move_insn (sc_reg, func_sc_mem);\n-\t  abi_reg = sc_reg;\n+      if (DEFAULT_ABI == ABI_ELFv2)\n+\t{\n+\t  /* A function pointer in the ELFv2 ABI is just a plain address, but\n+\t     the ABI requires it to be loaded into r12 before the call.  */\n+\t  func_addr = gen_rtx_REG (Pmode, 12);\n+\t  emit_move_insn (func_addr, func_desc);\n+\t  abi_reg = func_addr;\n+\t}\n+      else\n+\t{\n+\t  /* A function pointer under AIX is a pointer to a data area whose\n+\t     first word contains the actual address of the function, whose\n+\t     second word contains a pointer to its TOC, and whose third word\n+\t     contains a value to place in the static chain register (r11).\n+\t     Note that if we load the static chain, our \"trampoline\" need\n+\t     not have any executable code.  */\n+\n+\t  /* Load up address of the actual function.  */\n+\t  func_desc = force_reg (Pmode, func_desc);\n+\t  func_addr = gen_reg_rtx (Pmode);\n+\t  emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n+\n+\t  /* Prepare to load the TOC of the called function.  Note that the\n+\t     TOC load must happen immediately before the actual call so\n+\t     that unwinding the TOC registers works correctly.  See the\n+\t     comment in frob_update_context.  */\n+\t  rtx func_toc_offset = GEN_INT (GET_MODE_SIZE (Pmode));\n+\t  rtx func_toc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t\t\t  gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t\t\tfunc_toc_offset));\n+\t  toc_load = gen_rtx_USE (VOIDmode, func_toc_mem);\n+\n+\t  /* If we have a static chain, load it up.  */\n+\t  if (TARGET_POINTERS_TO_NESTED_FUNCTIONS)\n+\t    {\n+\t      rtx sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+\t      rtx func_sc_offset = GEN_INT (2 * GET_MODE_SIZE (Pmode));\n+\t      rtx func_sc_mem = gen_rtx_MEM (Pmode,\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t\t\t   func_sc_offset));\n+\t      emit_move_insn (sc_reg, func_sc_mem);\n+\t      abi_reg = sc_reg;\n+\t    }\n \t}\n     }\n   else\n@@ -30743,7 +31471,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), abi_reg);\n }\n \n-/* Expand code to perform a sibling call under the AIX ABI.  */\n+/* Expand code to perform a sibling call under the AIX or ELFv2 ABI.  */\n \n void\n rs6000_sibcall_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)"}, {"sha": "eb59235ec6144bebf890f8a29bad0264d969511d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1527,18 +1527,14 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define FRAME_GROWS_DOWNWARD (flag_stack_protect != 0\t\t\t\\\n \t\t\t      || (flag_sanitize & SANITIZE_ADDRESS) != 0)\n \n-/* Size of the outgoing register save area */\n-#define RS6000_REG_SAVE \\\n-  ((DEFAULT_ABI == ABI_V4 ? 0 : 32) << (TARGET_64BIT ? 1 : 0))\n-\n /* Size of the fixed area on the stack */\n #define RS6000_SAVE_AREA \\\n-  ((DEFAULT_ABI == ABI_V4 ? 8 : 24) << (TARGET_64BIT ? 1 : 0))\n+  ((DEFAULT_ABI == ABI_V4 ? 8 : DEFAULT_ABI == ABI_ELFv2 ? 16 : 24)\t\\\n+   << (TARGET_64BIT ? 1 : 0))\n \n-/* MEM representing address to save the TOC register */\n-#define RS6000_SAVE_TOC gen_rtx_MEM (Pmode, \\\n-\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx, \\\n-\t\t\t\t\t\t    (TARGET_32BIT ? 20 : 40)))\n+/* Stack offset for toc save slot.  */\n+#define RS6000_TOC_SAVE_SLOT \\\n+  ((DEFAULT_ABI == ABI_ELFv2 ? 12 : 20) << (TARGET_64BIT ? 1 : 0))\n \n /* Align an address */\n #define RS6000_ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))\n@@ -1588,7 +1584,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n /* Define this if stack space is still allocated for a parameter passed\n    in a register.  The value is the number of bytes allocated to this\n    area.  */\n-#define REG_PARM_STACK_SPACE(FNDECL)\tRS6000_REG_SAVE\n+#define REG_PARM_STACK_SPACE(FNDECL) rs6000_reg_parm_stack_space((FNDECL))\n \n /* Define this if the above stack space is to be considered part of the\n    space allocated by the caller.  */\n@@ -1641,10 +1637,17 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define ALTIVEC_ARG_MAX_REG (ALTIVEC_ARG_MIN_REG + 11)\n #define ALTIVEC_ARG_NUM_REG (ALTIVEC_ARG_MAX_REG - ALTIVEC_ARG_MIN_REG + 1)\n \n+/* Maximum number of registers per ELFv2 homogeneous aggregate argument.  */\n+#define AGGR_ARG_NUM_REG 8\n+\n /* Return registers */\n #define GP_ARG_RETURN GP_ARG_MIN_REG\n #define FP_ARG_RETURN FP_ARG_MIN_REG\n #define ALTIVEC_ARG_RETURN (FIRST_ALTIVEC_REGNO + 2)\n+#define FP_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? FP_ARG_RETURN\t\\\n+\t\t\t   : (FP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n+#define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? ALTIVEC_ARG_RETURN \\\n+\t\t\t        : (ALTIVEC_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n \n /* Flags for the call/call_value rtl operations set up by function_arg */\n #define CALL_NORMAL\t\t0x00000000\t/* no special processing */\n@@ -1664,8 +1667,10 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    On RS/6000, this is r3, fp1, and v2 (for AltiVec).  */\n #define FUNCTION_VALUE_REGNO_P(N)\t\t\t\t\t\\\n   ((N) == GP_ARG_RETURN\t\t\t\t\t\t\t\\\n-   || ((N) == FP_ARG_RETURN && TARGET_HARD_FLOAT && TARGET_FPRS)\t\\\n-   || ((N) == ALTIVEC_ARG_RETURN && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI))\n+   || ((N) >= FP_ARG_RETURN && (N) <= FP_ARG_MAX_RETURN\t\t\t\\\n+       && TARGET_HARD_FLOAT && TARGET_FPRS)\t\t\t\t\\\n+   || ((N) >= ALTIVEC_ARG_RETURN && (N) <= ALTIVEC_ARG_MAX_RETURN\t\\\n+       && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI))\n \n /* 1 if N is a possible register number for function argument passing.\n    On RS/6000, these are r3-r10 and fp1-fp13."}, {"sha": "4de7c3a2f6e453703672c339910d314ee730bde4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -11185,7 +11185,7 @@\n \t \t    (match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t   UNSPEC_TLSGD)\n    (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX\"\n+  \"HAVE_AS_TLS && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n {\n   if (TARGET_CMODEL != CMODEL_SMALL)\n     return \"addis %0,%1,%2@got@tlsgd@ha\\;addi %0,%0,%2@got@tlsgd@l\\;\"\n@@ -11294,7 +11294,8 @@\n    (unspec:TLSmode [(match_operand:TLSmode 3 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t   UNSPEC_TLSGD)\n    (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX && TARGET_TLS_MARKERS\"\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\n+   && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n   \"bl %z1(%3@tlsgd)\\;nop\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -11326,7 +11327,7 @@\n    (unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")]\n \t\t   UNSPEC_TLSLD)\n    (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX\"\n+  \"HAVE_AS_TLS && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n {\n   if (TARGET_CMODEL != CMODEL_SMALL)\n     return \"addis %0,%1,%&@got@tlsld@ha\\;addi %0,%0,%&@got@tlsld@l\\;\"\n@@ -11429,7 +11430,8 @@\n \t      (match_operand 2 \"\" \"g\")))\n    (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)\n    (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_AIX && TARGET_TLS_MARKERS\"\n+  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\n+   && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n   \"bl %z1(%&@tlsld)\\;nop\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -11800,7 +11802,7 @@\n   [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t\t   (unspec:SI [(const_int 0)] UNSPEC_TOC))\n \t      (use (reg:SI 2))])]\n-  \"DEFAULT_ABI == ABI_AIX && TARGET_32BIT\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2) && TARGET_32BIT\"\n   \"*\n {\n   char buf[30];\n@@ -11815,7 +11817,7 @@\n   [(parallel [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t\t   (unspec:DI [(const_int 0)] UNSPEC_TOC))\n \t      (use (reg:DI 2))])]\n-  \"DEFAULT_ABI == ABI_AIX && TARGET_64BIT\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2) && TARGET_64BIT\"\n   \"*\n {\n   char buf[30];\n@@ -12081,7 +12083,7 @@\n \n   operands[0] = XEXP (operands[0], 0);\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n       rs6000_call_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n       DONE;\n@@ -12125,7 +12127,7 @@\n \n   operands[1] = XEXP (operands[1], 0);\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n       rs6000_call_aix (operands[0], operands[1], operands[2], operands[3]);\n       DONE;\n@@ -12424,7 +12426,7 @@\n   [(call (mem:SI (match_operand:P 0 \"current_file_function_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"bl %z0\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n@@ -12434,7 +12436,7 @@\n \t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"bl %z1\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n@@ -12446,7 +12448,7 @@\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1 \"\" \"g\"))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"bl %z0\\;nop\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -12456,7 +12458,7 @@\n \t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"g\")))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"bl %z1\\;nop\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -12489,6 +12491,31 @@\n   [(set_attr \"type\" \"jmpreg\")\n    (set_attr \"length\" \"12\")])\n \n+;; Call to indirect functions with the ELFv2 ABI.\n+;; Operand0 is the addresss of the function to call\n+;; Operand2 is the stack location to hold the current TOC pointer\n+\n+(define_insn \"*call_indirect_elfv2<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+\t (match_operand 1 \"\" \"g,g\"))\n+   (set (reg:P TOC_REGNUM) (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_ELFv2\"\n+  \"b%T0l\\;<ptrload> 2,%2\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*call_value_indirect_elfv2<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t      (match_operand 2 \"\" \"g,g\")))\n+   (set (reg:P TOC_REGNUM) (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n+   (clobber (reg:P LR_REGNO))]\n+  \"DEFAULT_ABI == ABI_ELFv2\"\n+  \"b%T1l\\;<ptrload> 2,%3\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n+\n \n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\"\n@@ -12538,7 +12565,7 @@\n \n   operands[0] = XEXP (operands[0], 0);\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n       rs6000_sibcall_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n       DONE;\n@@ -12565,7 +12592,7 @@\n \n   operands[1] = XEXP (operands[1], 0);\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n       rs6000_sibcall_aix (operands[0], operands[1], operands[2], operands[3]);\n       DONE;\n@@ -12725,7 +12752,7 @@\n   [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,c\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (simple_return)]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"@\n    b %z0\n    b%T0\"\n@@ -12737,7 +12764,7 @@\n \t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,c\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n    (simple_return)]\n-  \"DEFAULT_ABI == ABI_AIX\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n   \"@\n    b %z1\n    b%T1\""}, {"sha": "347f76e207c8ae588348e2361ed90db64aabf8f1", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -369,6 +369,14 @@ mabi=no-spe\n Target RejectNegative Var(rs6000_spe_abi, 0)\n Do not use the SPE ABI extensions\n \n+mabi=elfv1\n+Target RejectNegative Var(rs6000_elf_abi, 1) Save\n+Use the ELFv1 ABI\n+\n+mabi=elfv2\n+Target RejectNegative Var(rs6000_elf_abi, 2)\n+Use the ELFv2 ABI\n+\n ; These are here for testing during development only, do not document\n ; in the manual please.\n "}, {"sha": "dd787dda559251e1f49b254b6c98d527ca45f6d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,3 +1,26 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc64-abi-1.c (stack_frame_t): Remove\n+\tcompiler and linker field if _CALL_ELF == 2.\n+\t* gcc.target/powerpc/ppc64-abi-2.c (stack_frame_t): Likewise.\n+\t* gcc.target/powerpc/ppc64-abi-dfp-1.c (stack_frame_t): Likewise.\n+\t* gcc.dg/stack-usage-1.c (SIZE): Update value for _CALL_ELF == 2.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc64-abi-dfp-1.c (FUNC_START): New macro.\n+\t(WRAPPER): Use it.\n+\t* gcc.target/powerpc/no-r11-1.c: Skip on powerpc_elfv2.\n+\t* gcc.target/powerpc/no-r11-2.c: Skip on powerpc_elfv2.\n+\t* gcc.target/powerpc/no-r11-3.c: Skip on powerpc_elfv2.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_powerpc_elfv2):\n+\tNew function.\n+\t* gcc.target/powerpc/pr57949-1.c: Disable for powerpc_elfv2.\n+\t* gcc.target/powerpc/pr57949-2.c: Likewise.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* g++.dg/eh/ppc64-sighandle-cr.C: New test."}, {"sha": "78807bacd3064fe1d31c4b376ebb241a5ab2f71b", "filename": "gcc/testsuite/gcc.dg/stack-usage-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -40,7 +40,11 @@\n #  endif\n #elif defined (__powerpc64__) || defined (__ppc64__) || defined (__POWERPC64__) \\\n       || defined (__PPC64__)\n-#  define SIZE 180\n+#  if _CALL_ELF == 2\n+#     define SIZE 208\n+#  else\n+#     define SIZE 180\n+#  endif\n #elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) \\\n       || defined (__POWERPC__) || defined (PPC) || defined (_IBMR2)\n #  if defined (__ALTIVEC__)"}, {"sha": "94b7988ec76ae8610e8585efdc883e6d351621e3", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-1.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc_elfv2 } { \"*\" } { \"\" } } */\n /* { dg-options \"-O2 -mno-pointers-to-nested-functions\" } */\n \n int"}, {"sha": "214a9dfb49a0778450112018cfea5b03cf2490fd", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-2.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc_elfv2 } { \"*\" } { \"\" } } */\n /* { dg-options \"-O2 -mpointers-to-nested-functions\" } */\n \n int"}, {"sha": "9cc830909211f814625ea0f5fba00be0071a023e", "filename": "gcc/testsuite/gcc.target/powerpc/no-r11-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fno-r11-3.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-skip-if \"\" { *-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc_elfv2 } { \"*\" } { \"\" } } */\n /* { dg-options \"-O2 -mno-pointers-to-nested-functions\" } */\n \n extern void ext_call (int (func) (void));"}, {"sha": "9dc730e0dbd39342c71805ab4bc79356ad3e5ff0", "filename": "gcc/testsuite/gcc.target/powerpc/ppc64-abi-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-1.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -89,8 +89,10 @@ typedef struct sf\n   long a1;\n   long a2;\n   long a3;\n+#if _CALL_ELF != 2\n   long a4;\n   long a5;\n+#endif\n   parm_t slot[100];\n } stack_frame_t;\n "}, {"sha": "fdb781554c688e8e6cf18701690010940df49567", "filename": "gcc/testsuite/gcc.target/powerpc/ppc64-abi-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-2.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -107,8 +107,10 @@ typedef struct sf\n   long a1;\n   long a2;\n   long a3;\n+#if _CALL_ELF != 2\n   long a4;\n   long a5;\n+#endif\n   parm_t slot[100];\n } stack_frame_t;\n "}, {"sha": "4e91b1bba26ad860fc5636ceb3cf6f3e5a3b7c35", "filename": "gcc/testsuite/gcc.target/powerpc/ppc64-abi-dfp-1.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -33,15 +33,27 @@ reg_parms_t gparms;\n \n \n /* Wrapper to save the GPRs and FPRs and then jump to the real function.  */\n+#if _CALL_ELF != 2\n+#define FUNC_START(NAME)\t\t\t\t\t\t\\\n+\t\"\\t.globl\\t\" NAME \"\\n\\t\"\t\t\t\t\t\\\n+         \".section \\\".opd\\\",\\\"aw\\\"\\n\\t\"\t\t\t\t\t\\\n+         \".align 3\\n\"\t\t\t\t\t\t\t\\\n+         NAME \":\\n\\t\"\t\t\t\t\t\t\t\\\n+         \".quad .L.\" NAME \",.TOC.@tocbase,0\\n\\t\"\t\t\t\\\n+         \".text\\n\\t\"\t\t\t\t\t\t\t\\\n+         \".type \" NAME \", @function\\n\"\t\t\t\t\t\\\n+         \".L.\" NAME \":\\n\\t\"\n+#else\n+#define FUNC_START(NAME)\t\t\t\t\t\t\\\n+\t\"\\t.globl\\t\" NAME \"\\n\\t\"\t\t\t\t\t\\\n+         \".text\\n\\t\"\t\t\t\t\t\t\t\\\n+         NAME \":\\n\"\t\t\t\t\t\t\t\\\n+\t\"0:\\taddis 2,12,(.TOC.-0b)@ha\\n\\t\"\t\t\t\t\\\n+\t\"addi 2,2,(.TOC.-0b)@l\\n\\t\"\t\t\t\t\t\\\n+\t\".localentry \" NAME \",.-\" NAME \"\\n\\t\"\n+#endif\n #define WRAPPER(NAME)\t\t\t\t\t\t\t\\\n-__asm__ (\"\\t.globl\\t\" #NAME \"_asm\\n\\t\"\t\t\t\t\t\\\n-\t \".section \\\".opd\\\",\\\"aw\\\"\\n\\t\"\t\t\t\t\t\\\n-\t \".align 3\\n\"\t\t\t\t\t\t\t\\\n-\t #NAME \"_asm:\\n\\t\"\t\t\t\t\t\t\\\n-\t \".quad .L.\" #NAME \"_asm,.TOC.@tocbase,0\\n\\t\"\t\t\t\\\n-\t \".text\\n\\t\"\t\t\t\t\t\t\t\\\n-\t \".type \" #NAME \"_asm, @function\\n\"\t\t\t\t\\\n-\t \".L.\" #NAME \"_asm:\\n\\t\"\t\t\t\t\t\\\n+__asm__ (FUNC_START (#NAME \"_asm\")\t\t\t\t\t\\\n \t \"ld 11,gparms@got(2)\\n\\t\"\t\t\t\t\t\\\n \t \"std 3,0(11)\\n\\t\"\t\t\t\t\t\t\\\n \t \"std 4,8(11)\\n\\t\"\t\t\t\t\t\t\\\n@@ -75,8 +87,10 @@ typedef struct sf\n   long a1;\n   long a2;\n   long a3;\n+#if _CALL_ELF != 2\n   long a4;\n   long a5;\n+#endif\n   unsigned long slot[100];\n } stack_frame_t;\n "}, {"sha": "c2eecea1b843931f8355d26afc6a954d5999879e", "filename": "gcc/testsuite/gcc.target/powerpc/pr57949-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-1.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc_elfv2 } { \"*\" } { \"\" } } */\n /* { dg-options \"-O2 -mcpu=power7\" } */\n \n /* Verify that vs is 16-byte aligned in the absence of -mcompat-align-parm.  */"}, {"sha": "e5ad212f3e3c721474716c842b975c6d03045c5b", "filename": "gcc/testsuite/gcc.target/powerpc/pr57949-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57949-2.c?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc_elfv2 } { \"*\" } { \"\" } } */\n /* { dg-options \"-O2 -mcpu=power7 -mcompat-align-parm\" } */\n \n /* Verify that vs is not 16-byte aligned with -mcompat-align-parm.  */"}, {"sha": "104818d327e6ad5dc9e547faa723d59c206f2bbc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -3020,6 +3020,22 @@ proc check_effective_target_powerpc_405_nocache { } {\n     }\n }\n \n+# Return 1 if this is a PowerPC target using the ELFv2 ABI.\n+\n+proc check_effective_target_powerpc_elfv2 { } {\n+    if { [istarget powerpc*-*-*] } {\n+\treturn [check_no_compiler_messages powerpc_elfv2 object {\n+\t    #if _CALL_ELF != 2\n+\t    #error not ELF v2 ABI\n+\t    #else\n+\t    int dummy;\n+\t    #endif\n+\t}]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n # Return 1 if this is a SPU target with a toolchain that\n # supports automatic overlay generation.\n "}, {"sha": "0ba697e5c41c4d3d8933fad9d7f68eb63c9a0923", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,3 +1,27 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/linux-unwind.h (TOC_SAVE_SLOT): Define.\n+\t(frob_update_context): Use it.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/tramp.S [__powerpc64__ && _CALL_ELF == 2]:\n+\t(trampoline_initial): Provide ELFv2 variant.\n+\t(__trampoline_setup): Likewise.\n+\n+\t* config/rs6000/linux-unwind.h (frob_update_context): Do not\n+\tcheck for AIX indirect function call sequence if _CALL_ELF == 2.\n+\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/linux-unwind.h (get_regs): Do not support\n+\told kernel versions if _CALL_ELF == 2.\n+\t(frob_update_context): Do not support PLT stub variants only\n+\tgenerated by old linkers if _CALL_ELF == 2.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \t    Alan Modra  <amodra@gmail.com>\n "}, {"sha": "a421b15821662ea736ac1ef2c5188c2371e1b119", "filename": "libgcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -24,9 +24,19 @@\n \n #define R_LR\t\t65\n #define R_CR2\t\t70\n+#define R_CR3\t\t71\n+#define R_CR4\t\t72\n #define R_VR0\t\t77\n #define R_VRSAVE\t109\n \n+#ifdef __powerpc64__\n+#if _CALL_ELF == 2\n+#define TOC_SAVE_SLOT\t24\n+#else\n+#define TOC_SAVE_SLOT\t40\n+#endif\n+#endif\n+\n struct gcc_vregs\n {\n   __attribute__ ((vector_size (16))) int vr[32];\n@@ -107,6 +117,8 @@ get_regs (struct _Unwind_Context *context)\n     }\n   else if (pc[1] == 0x380000AC)\n     {\n+#if _CALL_ELF != 2\n+      /* These old kernel versions never supported ELFv2.  */\n       /* This works for 2.4 kernels, but not for 2.6 kernels with vdso\n \t because pc isn't pointing into the stack.  Can be removed when\n \t no one is running 2.4.19 or 2.4.20, the first two ppc64\n@@ -121,6 +133,7 @@ get_regs (struct _Unwind_Context *context)\n       if ((long) frame24->puc != -21 * 8)\n \treturn frame24->puc->regs;\n       else\n+#endif\n \t{\n \t  /* This works for 2.4.21 and later kernels.  */\n \t  struct rt_sigframe {\n@@ -212,8 +225,16 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n #ifndef __LITTLE_ENDIAN__\n   cr_offset += sizeof (long) - 4;\n #endif\n+  /* In the ELFv1 ABI, CR2 stands in for the whole CR.  */\n   fs->regs.reg[R_CR2].how = REG_SAVED_OFFSET;\n   fs->regs.reg[R_CR2].loc.offset = cr_offset;\n+#if _CALL_ELF == 2\n+  /* In the ELFv2 ABI, every CR field has a separate CFI entry.  */\n+  fs->regs.reg[R_CR3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[R_CR3].loc.offset = cr_offset;\n+  fs->regs.reg[R_CR4].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[R_CR4].loc.offset = cr_offset;\n+#endif\n \n   fs->regs.reg[R_LR].how = REG_SAVED_OFFSET;\n   fs->regs.reg[R_LR].loc.offset = (long) &regs->link - new_cfa;\n@@ -297,9 +318,13 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs ATT\n \t figure out if it was saved.  The big problem here is that the\n \t code that does the save/restore is generated by the linker, so\n \t we have no good way to determine at compile time what to do.  */\n-      if (pc[0] == 0xF8410028\n+      if (pc[0] == 0xF8410000 + TOC_SAVE_SLOT\n+#if _CALL_ELF != 2\n+\t  /* The ELFv2 linker never generates the old PLT stub form.  */\n \t  || ((pc[0] & 0xFFFF0000) == 0x3D820000\n-\t      && pc[1] == 0xF8410028))\n+\t      && pc[1] == 0xF8410000 + TOC_SAVE_SLOT)\n+#endif\n+\t  )\n \t{\n \t  /* We are in a plt call stub or r2 adjusting long branch stub,\n \t     before r2 has been saved.  Keep REG_UNSAVED.  */\n@@ -308,18 +333,21 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs ATT\n \t{\n \t  unsigned int *insn\n \t    = (unsigned int *) _Unwind_GetGR (context, R_LR);\n-\t  if (insn && *insn == 0xE8410028)\n-\t    _Unwind_SetGRPtr (context, 2, context->cfa + 40);\n+\t  if (insn && *insn == 0xE8410000 + TOC_SAVE_SLOT)\n+\t    _Unwind_SetGRPtr (context, 2, context->cfa + TOC_SAVE_SLOT);\n+#if _CALL_ELF != 2\n+\t  /* ELFv2 does not use this function pointer call sequence.  */\n \t  else if (pc[0] == 0x4E800421\n-\t\t   && pc[1] == 0xE8410028)\n+\t\t   && pc[1] == 0xE8410000 + TOC_SAVE_SLOT)\n \t    {\n \t      /* We are at the bctrl instruction in a call via function\n \t\t pointer.  gcc always emits the load of the new R2 just\n \t\t before the bctrl so this is the first and only place\n \t\t we need to use the stored R2.  */\n \t      _Unwind_Word sp = _Unwind_GetGR (context, 1);\n-\t      _Unwind_SetGRPtr (context, 2, (void *)(sp + 40));\n+\t      _Unwind_SetGRPtr (context, 2, (void *)(sp + TOC_SAVE_SLOT));\n \t    }\n+#endif\n \t}\n     }\n #endif"}, {"sha": "fe2a4543b6706dc6e29346bb2d5a581024f1ab44", "filename": "libgcc/config/rs6000/tramp.S", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2Fconfig%2Frs6000%2Ftramp.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libgcc%2Fconfig%2Frs6000%2Ftramp.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ftramp.S?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -116,4 +116,70 @@ FUNC_END(__trampoline_setup)\n \n #endif\n \n+#elif _CALL_ELF == 2\n+\t.type\ttrampoline_initial,@object\n+\t.align\t3\n+trampoline_initial:\n+\tld\tr11,.Lchain(r12)\n+\tld\tr12,.Lfunc(r12)\n+\tmtctr\tr12\n+\tbctr\n+.Lfunc = .-trampoline_initial\n+\t.quad\t0\t\t\t/* will be replaced with function address */\n+.Lchain = .-trampoline_initial\n+\t.quad\t0\t\t\t/* will be replaced with static chain */\n+\n+trampoline_size = .-trampoline_initial\n+\t.size\ttrampoline_initial,trampoline_size\n+\n+\n+/* R3 = stack address to store trampoline */\n+/* R4 = length of trampoline area */\n+/* R5 = function address */\n+/* R6 = static chain */\n+\n+\t.pushsection \".toc\",\"aw\"\n+.LC0:\n+\t.quad\ttrampoline_initial-8\n+\t.popsection\n+\n+FUNC_START(__trampoline_setup)\n+\taddis 7,2,.LC0@toc@ha\n+\tld 7,.LC0@toc@l(7)\t/* trampoline address -8 */\n+\n+\tli\tr8,trampoline_size\t/* verify that the trampoline is big enough */\n+\tcmpw\tcr1,r8,r4\n+\tsrwi\tr4,r4,3\t\t/* # doublewords to move */\n+\taddi\tr9,r3,-8\t/* adjust pointer for stdu */\n+\tmtctr\tr4\n+\tblt\tcr1,.Labort\n+\n+\t/* Copy the instructions to the stack */\n+.Lmove:\n+\tldu\tr10,8(r7)\n+\tstdu\tr10,8(r9)\n+\tbdnz\t.Lmove\n+\n+\t/* Store correct function and static chain */\n+\tstd\tr5,.Lfunc(r3)\n+\tstd\tr6,.Lchain(r3)\n+\n+\t/* Now flush both caches */\n+\tmtctr\tr4\n+.Lcache:\n+\ticbi\t0,r3\n+\tdcbf\t0,r3\n+\taddi\tr3,r3,8\n+\tbdnz\t.Lcache\n+\n+\t/* Finally synchronize things & return */\n+\tsync\n+\tisync\n+\tblr\n+\n+.Labort:\n+\tbl\tJUMP_TARGET(abort)\n+\tnop\n+FUNC_END(__trampoline_setup)\n+\n #endif"}, {"sha": "e6dc6468d194ab14b5572c5ca5d1241165529496", "filename": "libitm/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,3 +1,13 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/powerpc/sjlj.S [__powerpc64__ && _CALL_ELF == 2]:\n+\t(FUNC): Define ELFv2 variant.\n+\t(END): Likewise.\n+\t(HIDDEN): Likewise.\n+\t(CALL): Likewise.\n+\t(BASE): Likewise.\n+\t(LR_SAVE): Likewise.\n+\n 2013-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* configure: Regenerate."}, {"sha": "4a0b43dbbbddeefca09e71486bd40ebbf34297b1", "filename": "libitm/config/powerpc/sjlj.S", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libitm%2Fconfig%2Fpowerpc%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libitm%2Fconfig%2Fpowerpc%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fpowerpc%2Fsjlj.S?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -26,7 +26,26 @@\n \n #include \"asmcfi.h\"\n \n-#if defined(__powerpc64__) && defined(__ELF__)\n+#if defined(__powerpc64__) && _CALL_ELF == 2\n+.macro FUNC name\n+        .globl  \\name\n+        .type   \\name, @function\n+\\name:\n+0:\taddis 2,12,(.TOC.-0b)@ha\n+\taddi 2,2,(.TOC.-0b)@l\n+\t.localentry \\name, . - \\name\n+.endm\n+.macro END name\n+\t.size\t\\name, . - \\name\n+.endm\n+.macro HIDDEN name\n+\t.hidden\t\\name\n+.endm\n+.macro CALL name\n+\tbl\t\\name\n+\tnop\n+.endm\n+#elif defined(__powerpc64__) && defined(__ELF__)\n .macro FUNC name\n         .globl  \\name, .\\name\n         .section \".opd\",\"aw\"\n@@ -117,6 +136,9 @@ _$0:\n #if defined(_CALL_AIXDESC)\n # define BASE\t\t6*WS\n # define LR_SAVE\t2*WS\n+#elif _CALL_ELF == 2\n+# define BASE\t\t6*WS\n+# define LR_SAVE\t2*WS\n #elif defined(_CALL_SYSV)\n # define BASE\t\t2*WS\n # define LR_SAVE\t1*WS"}, {"sha": "352a13b28c5bf7863009ebcb67e20a10de347003", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -1,3 +1,8 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* scripts/extract_symvers.in: Ignore <localentry: > fields\n+\tin readelf --symbols output.\n+\n 2013-11-14  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/alloc_traits.h (__allow_copy_cons): Remove."}, {"sha": "c9cf7e5dbe1c217997f4901ed221a49668a76fa7", "filename": "libstdc++-v3/scripts/extract_symvers.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libstdc%2B%2B-v3%2Fscripts%2Fextract_symvers.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54214fe22107618e7dd7c6abd3bff9526fcb3e5/libstdc%2B%2B-v3%2Fscripts%2Fextract_symvers.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fextract_symvers.in?ref=b54214fe22107618e7dd7c6abd3bff9526fcb3e5", "patch": "@@ -53,6 +53,7 @@ SunOS)\n   # present on Solaris.\n   ${readelf} ${lib} |\\\n   sed -e 's/ \\[<other>: [A-Fa-f0-9]*\\] //' -e '/\\.dynsym/,/^$/p;d' |\\\n+  sed -e 's/ \\[<localentry>: [0-9]*\\] //' |\\\n   egrep -v ' (LOCAL|UND) ' |\\\n   egrep -v ' (_DYNAMIC|_GLOBAL_OFFSET_TABLE_|_PROCEDURE_LINKAGE_TABLE_|_edata|_end|_etext)$' |\\\n   sed -e 's/ <processor specific>: / <processor_specific>:_/g' |\\"}]}