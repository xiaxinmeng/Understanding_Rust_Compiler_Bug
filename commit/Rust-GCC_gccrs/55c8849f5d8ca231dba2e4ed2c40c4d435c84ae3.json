{"sha": "55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVjODg0OWY1ZDhjYTIzMWRiYTJlNGVkMmM0MGM0ZDQzNWM4NGFlMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-20T21:46:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-20T21:46:58Z"}, "message": "tree-vrp.c (compare_values_warnv): Simplify handling of symbolic ranges by calling get_single_symbol and tidy up.\n\n\t* tree-vrp.c (compare_values_warnv): Simplify handling of symbolic\n\tranges by calling get_single_symbol and tidy up.  Look more closely\n\tinto NAME + CST1 vs CST2 comparisons if type overflow is undefined.\nada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tMake same-sized subtypes of signed base types signed.\n\t* gcc-interface/utils.c (make_type_from_size): Adjust to above change.\n\t(unchecked_convert): Likewise.\n\nFrom-SVN: r236548", "tree": {"sha": "0b4f1df898e1cc3a5d61e29748c1888ebaa51560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b4f1df898e1cc3a5d61e29748c1888ebaa51560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/comments", "author": null, "committer": null, "parents": [{"sha": "aa6d7407f90130dfea5df768787ce5c46c87f07b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6d7407f90130dfea5df768787ce5c46c87f07b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6d7407f90130dfea5df768787ce5c46c87f07b"}], "stats": {"total": 234, "additions": 121, "deletions": 113}, "files": [{"sha": "8585175482a8260131ed9b47233f3f8a24ebb908", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1,3 +1,9 @@\n+2016-05-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-vrp.c (compare_values_warnv): Simplify handling of symbolic\n+\tranges by calling get_single_symbol and tidy up.  Look more closely\n+\tinto NAME + CST1 vs CST2 comparisons if type overflow is undefined.\n+\n 2016-05-20  Jeff Law  <law@redhat.com>\n \n \t* bitmap.c (bitmap_find_bit): Remove useless test."}, {"sha": "525b89f9c6edc76e5bee11548f8b4d586f971565", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1,3 +1,10 @@\n+2016-05-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tMake same-sized subtypes of signed base types signed.\n+\t* gcc-interface/utils.c (make_type_from_size): Adjust to above change.\n+\t(unchecked_convert): Likewise.\n+\n 2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Do not build"}, {"sha": "6b6bc07684dcb82ee8b1c2b2144aca95bcd87ad6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1814,15 +1814,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       /* First subtypes of Character are treated as Character; otherwise\n \t this should be an unsigned type if the base type is unsigned or\n \t if the lower bound is constant and non-negative or if the type\n-\t is biased.  */\n+\t is biased.  However, even if the lower bound is constant and\n+\t non-negative, we use a signed type for a subtype with the same\n+\t size as its signed base type, because this eliminates useless\n+\t conversions to it and gives more leeway to the optimizer; but\n+\t this means that we will need to explicitly test for this case\n+\t when we change the representation based on the RM size.  */\n       if (kind == E_Enumeration_Subtype\n \t  && No (First_Literal (Etype (gnat_entity)))\n \t  && Esize (gnat_entity) == RM_Size (gnat_entity)\n \t  && esize == CHAR_TYPE_SIZE\n \t  && flag_signed_char)\n \tgnu_type = make_signed_type (CHAR_TYPE_SIZE);\n       else if (Is_Unsigned_Type (Etype (gnat_entity))\n-\t       || Is_Unsigned_Type (gnat_entity)\n+\t       || (Esize (Etype (gnat_entity)) != Esize (gnat_entity)\n+\t\t   && Is_Unsigned_Type (gnat_entity))\n \t       || Has_Biased_Representation (gnat_entity))\n \tgnu_type = make_unsigned_type (esize);\n       else"}, {"sha": "798048a903d4d861b21ba65c23df97712df3a255", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1116,7 +1116,14 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \tbreak;\n \n       biased_p |= for_biased;\n-      if (TYPE_UNSIGNED (type) || biased_p)\n+\n+      /* The type should be an unsigned type if the original type is unsigned\n+\t or if the lower bound is constant and non-negative or if the type is\n+\t biased, see E_Signed_Integer_Subtype case of gnat_to_gnu_entity.  */\n+      if (TYPE_UNSIGNED (type)\n+\t  || (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n+\t      && tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0)\n+\t  || biased_p)\n \tnew_type = make_unsigned_type (size);\n       else\n \tnew_type = make_signed_type (size);\n@@ -5111,7 +5118,9 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   /* If the result is an integral type whose precision is not equal to its\n      size, sign- or zero-extend the result.  We need not do this if the input\n      is an integral type of the same precision and signedness or if the output\n-     is a biased type or if both the input and output are unsigned.  */\n+     is a biased type or if both the input and output are unsigned, or if the\n+     lower bound is constant and non-negative, see E_Signed_Integer_Subtype\n+     case of gnat_to_gnu_entity.  */\n   if (!notrunc_p\n       && INTEGRAL_TYPE_P (type)\n       && TYPE_RM_SIZE (type)\n@@ -5123,7 +5132,10 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t\t    ? TYPE_RM_SIZE (etype)\n \t\t\t\t    : TYPE_SIZE (etype)) == 0)\n       && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n-      && !(TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n+      && !((TYPE_UNSIGNED (type)\n+\t    || (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n+\t\t&& tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0))\n+\t   && TYPE_UNSIGNED (etype)))\n     {\n       tree base_type\n \t= gnat_type_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),"}, {"sha": "1a6a460f621ce65c0a547036a11f3866ab4ae0bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1,3 +1,8 @@\n+2016-05-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt53.adb: New test.\n+\t* gnat.dg/opt54.adb: Likewise.\n+\n 2016-05-20  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/70884"}, {"sha": "936277db85f65fad9f396b6b5852df5801be39b2", "filename": "gcc/testsuite/gnat.dg/opt53.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2Fgnat.dg%2Fopt53.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2Fgnat.dg%2Fopt53.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt53.adb?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+function Opt53 (Val, Max : Positive) return Positive is\n+begin\n+   if Val >= Max then\n+      return Max;\n+   end if;\n+   return Val + 1;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"gnat_rcheck\" \"optimized\" } }"}, {"sha": "b4aaa0900e64c82102c7dfc7a9d3b077630f0c7c", "filename": "gcc/testsuite/gnat.dg/opt54.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2Fgnat.dg%2Fopt54.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftestsuite%2Fgnat.dg%2Fopt54.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt54.adb?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+function Opt54 (Val, Max : Integer) return Integer is\n+begin\n+   if Val >= Max then\n+      return Max;\n+   end if;\n+   return Val + 1;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"gnat_rcheck\" \"optimized\" } }"}, {"sha": "68f2e905424999e2a639c02ae74b160ebfe8a067", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 56, "deletions": 108, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "patch": "@@ -1187,129 +1187,77 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n   val2 = fold_convert (TREE_TYPE (val1), val2);\n   STRIP_USELESS_TYPE_CONVERSION (val2);\n \n-  if ((TREE_CODE (val1) == SSA_NAME\n-       || (TREE_CODE (val1) == NEGATE_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (val1, 0)) == SSA_NAME)\n-       || TREE_CODE (val1) == PLUS_EXPR\n-       || TREE_CODE (val1) == MINUS_EXPR)\n-      && (TREE_CODE (val2) == SSA_NAME\n-\t  || (TREE_CODE (val2) == NEGATE_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (val2, 0)) == SSA_NAME)\n-\t  || TREE_CODE (val2) == PLUS_EXPR\n-\t  || TREE_CODE (val2) == MINUS_EXPR))\n-    {\n-      tree n1, c1, n2, c2;\n-      enum tree_code code1, code2;\n-\n-      /* If VAL1 and VAL2 are of the form '[-]NAME [+-] CST' or 'NAME',\n-\t return -1 or +1 accordingly.  If VAL1 and VAL2 don't use the\n-\t same name, return -2.  */\n-      if (TREE_CODE (val1) == SSA_NAME || TREE_CODE (val1) == NEGATE_EXPR)\n-\t{\n-\t  code1 = SSA_NAME;\n-\t  n1 = val1;\n-\t  c1 = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  code1 = TREE_CODE (val1);\n-\t  n1 = TREE_OPERAND (val1, 0);\n-\t  c1 = TREE_OPERAND (val1, 1);\n-\t  if (tree_int_cst_sgn (c1) == -1)\n-\t    {\n-\t      if (is_negative_overflow_infinity (c1))\n-\t\treturn -2;\n-\t      c1 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c1), c1);\n-\t      if (!c1)\n-\t\treturn -2;\n-\t      code1 = code1 == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR;\n-\t    }\n-\t}\n-\n-      if (TREE_CODE (val2) == SSA_NAME || TREE_CODE (val2) == NEGATE_EXPR)\n-\t{\n-\t  code2 = SSA_NAME;\n-\t  n2 = val2;\n-\t  c2 = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  code2 = TREE_CODE (val2);\n-\t  n2 = TREE_OPERAND (val2, 0);\n-\t  c2 = TREE_OPERAND (val2, 1);\n-\t  if (tree_int_cst_sgn (c2) == -1)\n-\t    {\n-\t      if (is_negative_overflow_infinity (c2))\n-\t\treturn -2;\n-\t      c2 = fold_unary_to_constant (NEGATE_EXPR, TREE_TYPE (c2), c2);\n-\t      if (!c2)\n-\t\treturn -2;\n-\t      code2 = code2 == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR;\n-\t    }\n-\t}\n-\n-      /* Both values must use the same name.  */\n-      if (TREE_CODE (n1) == NEGATE_EXPR && TREE_CODE (n2) == NEGATE_EXPR)\n-\t{\n-\t  n1 = TREE_OPERAND (n1, 0);\n-\t  n2 = TREE_OPERAND (n2, 0);\n-\t}\n-      if (n1 != n2)\n+  const bool overflow_undefined\n+    = INTEGRAL_TYPE_P (TREE_TYPE (val1))\n+      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1));\n+  tree inv1, inv2;\n+  bool neg1, neg2;\n+  tree sym1 = get_single_symbol (val1, &neg1, &inv1);\n+  tree sym2 = get_single_symbol (val2, &neg2, &inv2);\n+\n+  /* If VAL1 and VAL2 are of the form '[-]NAME [+ CST]', return -1 or +1\n+     accordingly.  If VAL1 and VAL2 don't use the same name, return -2.  */\n+  if (sym1 && sym2)\n+    {\n+      /* Both values must use the same name with the same sign.  */\n+      if (sym1 != sym2 || neg1 != neg2)\n \treturn -2;\n \n-      if (code1 == SSA_NAME && code2 == SSA_NAME)\n-\t/* NAME == NAME  */\n+      /* [-]NAME + CST == [-]NAME + CST.  */\n+      if (inv1 == inv2)\n \treturn 0;\n \n       /* If overflow is defined we cannot simplify more.  */\n-      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n+      if (!overflow_undefined)\n \treturn -2;\n \n       if (strict_overflow_p != NULL\n-\t  && (code1 == SSA_NAME || !TREE_NO_WARNING (val1))\n-\t  && (code2 == SSA_NAME || !TREE_NO_WARNING (val2)))\n+\t  && (!inv1 || !TREE_NO_WARNING (val1))\n+\t  && (!inv2 || !TREE_NO_WARNING (val2)))\n \t*strict_overflow_p = true;\n \n-      if (code1 == SSA_NAME)\n-\t{\n-\t  if (code2 == PLUS_EXPR)\n-\t    /* NAME < NAME + CST  */\n-\t    return -1;\n-\t  else if (code2 == MINUS_EXPR)\n-\t    /* NAME > NAME - CST  */\n-\t    return 1;\n-\t}\n-      else if (code1 == PLUS_EXPR)\n-\t{\n-\t  if (code2 == SSA_NAME)\n-\t    /* NAME + CST > NAME  */\n-\t    return 1;\n-\t  else if (code2 == PLUS_EXPR)\n-\t    /* NAME + CST1 > NAME + CST2, if CST1 > CST2  */\n-\t    return compare_values_warnv (c1, c2, strict_overflow_p);\n-\t  else if (code2 == MINUS_EXPR)\n-\t    /* NAME + CST1 > NAME - CST2  */\n-\t    return 1;\n-\t}\n-      else if (code1 == MINUS_EXPR)\n+      if (!inv1)\n+\tinv1 = build_int_cst (TREE_TYPE (val1), 0);\n+      if (!inv2)\n+\tinv2 = build_int_cst (TREE_TYPE (val2), 0);\n+\n+      return compare_values_warnv (inv1, inv2, strict_overflow_p);\n+    }\n+\n+  const bool cst1 = is_gimple_min_invariant (val1);\n+  const bool cst2 = is_gimple_min_invariant (val2);\n+\n+  /* If one is of the form '[-]NAME + CST' and the other is constant, then\n+     it might be possible to say something depending on the constants.  */\n+  if ((sym1 && inv1 && cst2) || (sym2 && inv2 && cst1))\n+    {\n+      if (!overflow_undefined)\n+\treturn -2;\n+\n+      if (strict_overflow_p != NULL\n+\t  && (!sym1 || !TREE_NO_WARNING (val1))\n+\t  && (!sym2 || !TREE_NO_WARNING (val2)))\n+\t*strict_overflow_p = true;\n+\n+      const signop sgn = TYPE_SIGN (TREE_TYPE (val1));\n+      tree cst = cst1 ? val1 : val2;\n+      tree inv = cst1 ? inv2 : inv1;\n+\n+      /* Compute the difference between the constants.  If it overflows or\n+\t underflows, this means that we can trivially compare the NAME with\n+\t it and, consequently, the two values with each other.  */\n+      wide_int diff = wi::sub (cst, inv);\n+      if (wi::cmp (0, inv, sgn) != wi::cmp (diff, cst, sgn))\n \t{\n-\t  if (code2 == SSA_NAME)\n-\t    /* NAME - CST < NAME  */\n-\t    return -1;\n-\t  else if (code2 == PLUS_EXPR)\n-\t    /* NAME - CST1 < NAME + CST2  */\n-\t    return -1;\n-\t  else if (code2 == MINUS_EXPR)\n-\t    /* NAME - CST1 > NAME - CST2, if CST1 < CST2.  Notice that\n-\t       C1 and C2 are swapped in the call to compare_values.  */\n-\t    return compare_values_warnv (c2, c1, strict_overflow_p);\n+\t  const int res = wi::cmp (cst, inv, sgn);\n+\t  return cst1 ? res : -res;\n \t}\n \n-      gcc_unreachable ();\n+      return -2;\n     }\n \n-  /* We cannot compare non-constants.  */\n-  if (!is_gimple_min_invariant (val1) || !is_gimple_min_invariant (val2))\n+  /* We cannot say anything more for non-constants.  */\n+  if (!cst1 || !cst2)\n     return -2;\n \n   if (!POINTER_TYPE_P (TREE_TYPE (val1)))"}]}