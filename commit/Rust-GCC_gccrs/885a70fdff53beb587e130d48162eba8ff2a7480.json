{"sha": "885a70fdff53beb587e130d48162eba8ff2a7480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg1YTcwZmRmZjUzYmViNTg3ZTEzMGQ0ODE2MmViYThmZjJhNzQ4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-29T22:25:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-29T22:25:16Z"}, "message": "i386.c (ix86_expand_setcc): Support 64bit.\n\n\n\t* i386.c (ix86_expand_setcc): Support 64bit.\n\t(ix86_expand_int_movcc): Likewise.\n\t* i386.md (movdicc_rex64, x86_movsicc_0_m1_rex64, movdicc_c_rex64):\n\tNew patterns.\n\n\t* i386.md (allocate_stack_worker): Turn to expander.\n\t(allocate_stack_worker_1, allocate_stack_worker_rex64): New insns.\n\n\t* i386.c (print_reg): Do not print x86_64 style regs on IA-32\n\nFrom-SVN: r40958", "tree": {"sha": "63c02f76cdfb52fa55591056a699c6270da03368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63c02f76cdfb52fa55591056a699c6270da03368"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/885a70fdff53beb587e130d48162eba8ff2a7480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885a70fdff53beb587e130d48162eba8ff2a7480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/885a70fdff53beb587e130d48162eba8ff2a7480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885a70fdff53beb587e130d48162eba8ff2a7480/comments", "author": null, "committer": null, "parents": [{"sha": "e4b776a6d013ba9ec635f30f09021f050d844fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b776a6d013ba9ec635f30f09021f050d844fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b776a6d013ba9ec635f30f09021f050d844fdd"}], "stats": {"total": 119, "additions": 107, "deletions": 12}, "files": [{"sha": "826b875207f49fdddea44767ca96d7711837c495", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=885a70fdff53beb587e130d48162eba8ff2a7480", "patch": "@@ -1,3 +1,15 @@\n+Fri Mar 30 00:21:41 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_expand_setcc): Support 64bit.\n+\t(ix86_expand_int_movcc): Likewise.\n+\t* i386.md (movdicc_rex64, x86_movsicc_0_m1_rex64, movdicc_c_rex64):\n+\tNew patterns.\n+\n+\t* i386.md (allocate_stack_worker): Turn to expander.\n+\t(allocate_stack_worker_1, allocate_stack_worker_rex64): New insns.\n+\n+\t* i386.c (print_reg): Do not print x86_64 style regs on IA-32\n+\n 2001-03-29  Richard Henderson  <rth@redhat.com>\n \n \t* libgcc2.c [L__main]: Include unwind-dw2-fde.h instead of frame.h."}, {"sha": "5dc9fa9821f47d0e0b04f85528b17bc66bb168dc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=885a70fdff53beb587e130d48162eba8ff2a7480", "patch": "@@ -3798,6 +3798,8 @@ print_reg (x, code, file)\n      from the normal registers.  */\n   if (REX_INT_REG_P (x))\n     {\n+      if (!TARGET_64BIT)\n+\tabort ();\n       switch (code)\n \t{\n \t  case 5:\n@@ -3837,7 +3839,7 @@ print_reg (x, code, file)\n     case 4:\n     case 12:\n       if (! ANY_FP_REG_P (x))\n-\tputc (code == 8 ? 'r' : 'e', file);\n+\tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n     case 2:\n@@ -6112,7 +6114,8 @@ ix86_expand_setcc (code, dest)\n   rtx second_test, bypass_test;\n   int type;\n \n-  if (GET_MODE (ix86_compare_op0) == DImode)\n+  if (GET_MODE (ix86_compare_op0) == DImode\n+      && !TARGET_64BIT)\n     return 0; /* FAIL */\n \n   /* Three modes of generation:\n@@ -6229,6 +6232,7 @@ ix86_expand_int_movcc (operands)\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n   if (GET_MODE (operands[0]) != HImode\n+      && GET_MODE (operands[0]) != DImode\n       && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n@@ -6362,28 +6366,46 @@ ix86_expand_int_movcc (operands)\n \t\t\t\t ix86_compare_op1, VOIDmode, 0, 1);\n \n \t  nops = 0;\n+\t  /* On x86_64 the lea instruction operates on Pmode, so we need to get arithmetics\n+\t     done in proper mode to match.  */\n \t  if (diff == 1)\n-\t      tmp = out;\n+\t    {\n+\t      if (Pmode != SImode)\n+\t\ttmp = gen_lowpart (Pmode, out);\n+\t      else\n+\t\ttmp = out;\n+\t    }\n \t  else\n \t    {\n-\t      tmp = gen_rtx_MULT (SImode, out, GEN_INT (diff & ~1));\n+\t      rtx out1;\n+\t      if (Pmode != SImode)\n+\t        out1 = gen_lowpart (Pmode, out);\n+\t      else\n+\t\tout1 = out;\n+\t      tmp = gen_rtx_MULT (Pmode, out1, GEN_INT (diff & ~1));\n \t      nops++;\n \t      if (diff & 1)\n \t\t{\n-\t\t  tmp = gen_rtx_PLUS (SImode, tmp, out);\n+\t\t  tmp = gen_rtx_PLUS (Pmode, tmp, out1);\n \t\t  nops++;\n \t\t}\n \t    }\n \t  if (cf != 0)\n \t    {\n-\t      tmp = gen_rtx_PLUS (SImode, tmp, GEN_INT (cf));\n+\t      tmp = gen_rtx_PLUS (Pmode, tmp, GEN_INT (cf));\n \t      nops++;\n \t    }\n-\t  if (tmp != out)\n+\t  if (tmp != out\n+\t      && (GET_CODE (tmp) != SUBREG || SUBREG_REG (tmp) != out))\n \t    {\n-\t      if (nops == 0)\n-\t\temit_move_insn (out, tmp);\n-\t      else if (nops == 1)\n+\t      if (Pmode != SImode)\n+\t        tmp = gen_rtx_SUBREG (SImode, tmp, 0);\n+\n+\t      /* ??? We should to take care for outputing non-lea arithmetics\n+\t         for Pmode != SImode case too, but it is quite tricky and not\n+\t         too important, since all TARGET_64BIT machines support real\n+\t         conditional moves.  */\n+\t      if (nops == 1 && Pmode == SImode)\n \t\t{\n \t\t  rtx clob;\n "}, {"sha": "695d488f917b0fc085cff9d1b55bd9c17a49aef4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885a70fdff53beb587e130d48162eba8ff2a7480/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=885a70fdff53beb587e130d48162eba8ff2a7480", "patch": "@@ -14919,6 +14919,45 @@\n \f\n ;; Conditional move instructions.\n \n+(define_expand \"movdicc_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"x86_64_general_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"if (!ix86_expand_int_movcc (operands)) FAIL; DONE;\")\n+\n+(define_insn \"x86_movsicc_0_m1_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:DI (ltu (reg:CC 17) (const_int 0))\n+\t  (const_int -1)\n+\t  (const_int 0)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"sbb{l}\\\\t%0, %0\"\n+  ; Since we don't have the proper number of operands for an alu insn,\n+  ; fill in all the blanks.\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"memory\" \"none\")\n+   (set_attr \"imm_disp\" \"false\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length_immediate\" \"0\")])\n+\n+(define_insn \"*movdicc_c_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:DI (match_operator 1 \"ix86_comparison_operator\" \n+\t\t\t\t[(reg 17) (const_int 0)])\n+\t\t      (match_operand:DI 2 \"nonimmediate_operand\" \"rm,0\")\n+\t\t      (match_operand:DI 3 \"nonimmediate_operand\" \"0,rm\")))]\n+  \"TARGET_64BIT && TARGET_CMOVE\n+   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n+  \"@\n+   cmov%C1\\\\t{%2, %0|%0, %2}\n+   cmov%c1\\\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"icmov\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n (define_expand \"movsicc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n@@ -15749,12 +15788,34 @@\n     }\n }\")\n \n-(define_insn \"allocate_stack_worker\"\n+(define_expand \"allocate_stack_worker\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"TARGET_STACK_PROBE\"\n+  \"\n+{\n+  if (TARGET_64BIT)\n+    emit_insn (gen_allocate_stack_worker_rex64 (operands[0]));\n+  else\n+    emit_insn (gen_allocate_stack_worker_1 (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_insn \"allocate_stack_worker_1\"\n   [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"a\")] 3)\n    (set (reg:SI 7) (minus:SI (reg:SI 7) (match_dup 0)))\n    (clobber (match_dup 0))\n    (clobber (reg:CC 17))]\n-  \"TARGET_STACK_PROBE\"\n+  \"TARGET_STACK_PROBE && !TARGET_64BIT\"\n+  \"call\\\\t__alloca\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"5\")])\n+\n+(define_insn \"allocate_stack_worker_rex64\"\n+  [(unspec:DI [(match_operand:DI 0 \"register_operand\" \"a\")] 3)\n+   (set (reg:DI 7) (minus:DI (reg:DI 7) (match_dup 0)))\n+   (clobber (match_dup 0))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_STACK_PROBE && TARGET_64BIT\"\n   \"call\\\\t__alloca\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])"}]}