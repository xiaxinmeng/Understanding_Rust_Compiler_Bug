{"sha": "a20f263ba1a76af40eb4e6734529739a2a30ed65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwZjI2M2JhMWE3NmFmNDBlYjRlNjczNDUyOTczOWEyYTMwZWQ2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-07-14T11:57:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-14T11:57:10Z"}, "message": "ipa-fnsummary.c (ipa_dump_hints): Do not dump array_index.\n\n\n\t* ipa-fnsummary.c (ipa_dump_hints): Do not dump array_index.\n\t(ipa_fn_summary::~ipa_fn_summary): Do not destroy array_index.\n\t(ipa_fn_summary_t::duplicate): Do not duplicate array_index.\n\t(array_index_predicate): Remove.\n\t(analyze_function_body): Account cost for variable ofsetted array\n\tindexing.\n\t(estimate_node_size_and_time): Do not compute array index hint.\n\t(ipa_merge_fn_summary_after_inlining): Do not merge array index hint.\n\t(inline_read_section): Do not read array index hint.\n\t(ipa_fn_summary_write): Do not write array index hint.\n\t* doc/invoke.texi (ipa-cp-array-index-hint-bonus): Remove.\n\t* ipa-cp.c (hint_time_bonus): Remove.\n\t* ipa-fnsummary.h (ipa_hints_vals): Remove array_index.\n\t(ipa_fnsummary): Remove array_index.\n\t* ipa-inline.c (want_inline_small_function_p): Do not use\n\tarray_index.\n\t(edge_badness): Likewise.\n\t* params.def (PARAM_IPA_CP_ARRAY_INDEX_HINT_BONUS): Remove.\n\nFrom-SVN: r273479", "tree": {"sha": "0374cc07418b7f7254bf3fb1678943287f0c7fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0374cc07418b7f7254bf3fb1678943287f0c7fa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a20f263ba1a76af40eb4e6734529739a2a30ed65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20f263ba1a76af40eb4e6734529739a2a30ed65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20f263ba1a76af40eb4e6734529739a2a30ed65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20f263ba1a76af40eb4e6734529739a2a30ed65/comments", "author": null, "committer": null, "parents": [{"sha": "d67dfb85ba4f89f5f3045f2483005c290bc18108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d67dfb85ba4f89f5f3045f2483005c290bc18108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d67dfb85ba4f89f5f3045f2483005c290bc18108"}], "stats": {"total": 158, "additions": 54, "deletions": 104}, "files": [{"sha": "9b5cc7a5b5bebd043d526061895b57592ad78d85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -1,3 +1,24 @@\n+2019-07-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (ipa_dump_hints): Do not dump array_index.\n+\t(ipa_fn_summary::~ipa_fn_summary): Do not destroy array_index.\n+\t(ipa_fn_summary_t::duplicate): Do not duplicate array_index.\n+\t(array_index_predicate): Remove.\n+\t(analyze_function_body): Account cost for variable ofsetted array\n+\tindexing.\n+\t(estimate_node_size_and_time): Do not compute array index hint.\n+\t(ipa_merge_fn_summary_after_inlining): Do not merge array index hint.\n+\t(inline_read_section): Do not read array index hint.\n+\t(ipa_fn_summary_write): Do not write array index hint.\n+\t* doc/invoke.texi (ipa-cp-array-index-hint-bonus): Remove.\n+\t* ipa-cp.c (hint_time_bonus): Remove.\n+\t* ipa-fnsummary.h (ipa_hints_vals): Remove array_index.\n+\t(ipa_fnsummary): Remove array_index.\n+\t* ipa-inline.c (want_inline_small_function_p): Do not use\n+\tarray_index.\n+\t(edge_badness): Likewise.\n+\t* params.def (PARAM_IPA_CP_ARRAY_INDEX_HINT_BONUS): Remove.\n+\n 2019-07-14  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/91148"}, {"sha": "758aef36bd83d9d4a36b09ce62708b47bbeb3e06", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -11895,12 +11895,6 @@ of iterations of a loop known, it adds a bonus of\n @option{ipa-cp-loop-hint-bonus} to the profitability score of\n the candidate.\n \n-@item ipa-cp-array-index-hint-bonus\n-When IPA-CP determines that a cloning candidate would make the index of\n-an array access known, it adds a bonus of\n-@option{ipa-cp-array-index-hint-bonus} to the profitability\n-score of the candidate.\n-\n @item ipa-max-aa-steps\n During its analysis of function bodies, IPA-CP employs alias analysis\n in order to track values pointed to by function parameters.  In order"}, {"sha": "b20a6d0879493fb0a87fd2a3c6a7a543d0dbc09a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -2607,8 +2607,6 @@ hint_time_bonus (ipa_hints hints)\n   int result = 0;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n     result += PARAM_VALUE (PARAM_IPA_CP_LOOP_HINT_BONUS);\n-  if (hints & INLINE_HINT_array_index)\n-    result += PARAM_VALUE (PARAM_IPA_CP_ARRAY_INDEX_HINT_BONUS);\n   return result;\n }\n "}, {"sha": "78eb8cb6f50d0cc33f19c46f521b93445a371630", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 30, "deletions": 79, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -134,11 +134,6 @@ ipa_dump_hints (FILE *f, ipa_hints hints)\n       hints &= ~INLINE_HINT_declared_inline;\n       fprintf (f, \" declared_inline\");\n     }\n-  if (hints & INLINE_HINT_array_index)\n-    {\n-      hints &= ~INLINE_HINT_array_index;\n-      fprintf (f, \" array_index\");\n-    }\n   if (hints & INLINE_HINT_known_hot)\n     {\n       hints &= ~INLINE_HINT_known_hot;\n@@ -549,8 +544,6 @@ ipa_fn_summary::~ipa_fn_summary ()\n     edge_predicate_pool.remove (loop_iterations);\n   if (loop_stride)\n     edge_predicate_pool.remove (loop_stride);\n-  if (array_index)\n-    edge_predicate_pool.remove (array_index);\n   vec_free (conds);\n   vec_free (size_time_table);\n }\n@@ -703,8 +696,6 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t\t\t\t\t      possible_truths);\n       remap_hint_predicate_after_duplication (&info->loop_stride,\n \t\t\t\t\t      possible_truths);\n-      remap_hint_predicate_after_duplication (&info->array_index,\n-\t\t\t\t\t      possible_truths);\n \n       /* If inliner or someone after inliner will ever start producing\n          non-trivial clones, we will get trouble with lack of information\n@@ -727,12 +718,6 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t  info->loop_stride = NULL;\n \t  set_hint_predicate (&info->loop_stride, p);\n \t}\n-      if (info->array_index)\n-\t{\n-\t  predicate p = *info->array_index;\n-\t  info->array_index = NULL;\n-\t  set_hint_predicate (&info->array_index, p);\n-\t}\n     }\n   if (!dst->global.inlined_to)\n     ipa_update_overall_fn_summary (dst);\n@@ -894,11 +879,6 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t      fprintf (f, \"  loop stride:\");\n \t      s->loop_stride->dump (f, s->conds);\n \t    }\n-\t  if (s->array_index)\n-\t    {\n-\t      fprintf (f, \"  array index:\");\n-\t      s->array_index->dump (f, s->conds);\n-\t    }\n \t  fprintf (f, \"  calls:\\n\");\n \t  dump_ipa_call_summary (f, 4, node, s);\n \t  fprintf (f, \"\\n\");\n@@ -1824,27 +1804,6 @@ predicate_for_phi_result (class ipa_fn_summary *summary, gphi *phi,\n   nonconstant_names[SSA_NAME_VERSION (gimple_phi_result (phi))] = *p;\n }\n \n-/* Return predicate specifying when array index in access OP becomes non-constant.  */\n-\n-static predicate\n-array_index_predicate (ipa_fn_summary *info,\n-\t\t       vec< predicate> nonconstant_names, tree op)\n-{\n-  predicate p = false;\n-  while (handled_component_p (op))\n-    {\n-      if (TREE_CODE (op) == ARRAY_REF || TREE_CODE (op) == ARRAY_RANGE_REF)\n-\t{\n-\t  if (TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n-\t    p = p.or_with (info->conds, \n-\t\t\t   nonconstant_names[SSA_NAME_VERSION\n-\t\t\t\t\t\t  (TREE_OPERAND (op, 1))]);\n-\t}\n-      op = TREE_OPERAND (op, 0);\n-    }\n-  return p;\n-}\n-\n /* For a typical usage of __builtin_expect (a<b, 1), we\n    may introduce an extra relation stmt:\n    With the builtin, we have\n@@ -2001,7 +1960,6 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   vec<predicate> nonconstant_names = vNULL;\n   int nblocks, n;\n   int *order;\n-  predicate array_index = true;\n   gimple *fix_builtin_expect_stmt;\n \n   gcc_assert (my_function && my_function->cfg);\n@@ -2146,26 +2104,6 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t       this_time);\n \t    }\n \n-\t  if (gimple_assign_load_p (stmt) && nonconstant_names.exists ())\n-\t    {\n-\t      predicate this_array_index;\n-\t      this_array_index =\n-\t\tarray_index_predicate (info, nonconstant_names,\n-\t\t\t\t       gimple_assign_rhs1 (stmt));\n-\t      if (this_array_index != false)\n-\t\tarray_index &= this_array_index;\n-\t    }\n-\t  if (gimple_store_p (stmt) && nonconstant_names.exists ())\n-\t    {\n-\t      predicate this_array_index;\n-\t      this_array_index =\n-\t\tarray_index_predicate (info, nonconstant_names,\n-\t\t\t\t       gimple_get_lhs (stmt));\n-\t      if (this_array_index != false)\n-\t\tarray_index &= this_array_index;\n-\t    }\n-\n-\n \t  if (is_gimple_call (stmt)\n \t      && !gimple_call_internal_p (stmt))\n \t    {\n@@ -2273,14 +2211,40 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"   fp_expression set\\n\");\n \t\t}\n+\t    }\n \n-\t      gcc_assert (time >= 0);\n-\t      gcc_assert (size >= 0);\n+\t  /* Account cost of address calculations in the statements.  */\n+\t  for (unsigned int i = 0; i < gimple_num_ops (stmt); i++)\n+\t    {\n+\t      for (tree op = gimple_op (stmt, i);\n+\t\t   op && handled_component_p (op);\n+\t\t   op = TREE_OPERAND (op, 0))\n+\t        if ((TREE_CODE (op) == ARRAY_REF\n+\t\t     || TREE_CODE (op) == ARRAY_RANGE_REF)\n+\t\t    && TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n+\t\t  {\n+\t\t    predicate p = bb_predicate;\n+\t\t    if (fbi.info)\n+\t\t      p = p & will_be_nonconstant_expr_predicate\n+\t\t\t\t (&fbi, info, TREE_OPERAND (op, 1),\n+\t\t\t          nonconstant_names);\n+\t\t    if (p != false)\n+\t\t      {\n+\t\t\ttime += freq;\n+\t\t\tsize += 1;\n+\t\t\tif (dump_file)\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"\\t\\tAccounting address calculation.\\n\");\n+\t\t\tinfo->account_size_time (ipa_fn_summary::size_scale,\n+\t\t\t\t\t\t freq,\n+\t\t\t\t\t\t bb_predicate,\n+\t\t\t\t\t\t p);\n+\t\t      }\n+\t\t  }\n \t    }\n+\n \t}\n     }\n-  set_hint_predicate (&ipa_fn_summaries->get_create (node)->array_index,\n-\t\t      array_index);\n   free (order);\n \n   if (nonconstant_names.exists () && !early)\n@@ -2783,9 +2747,6 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (info->loop_stride\n       && !info->loop_stride->evaluate (possible_truths))\n     hints |= INLINE_HINT_loop_stride;\n-  if (info->array_index\n-      && !info->array_index->evaluate (possible_truths))\n-    hints |= INLINE_HINT_array_index;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n   if (DECL_DECLARED_INLINE_P (node->decl))\n@@ -3106,9 +3067,6 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   remap_hint_predicate (info, callee_info,\n \t\t\t&callee_info->loop_stride,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n-  remap_hint_predicate (info, callee_info,\n-\t\t\t&callee_info->array_index,\n-\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n   ipa_call_summary *s = ipa_call_summaries->get (edge);\n   inline_update_callee_summaries (edge->callee, s->loop_depth);\n@@ -3366,9 +3324,6 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       p.stream_in (&ib);\n       if (info)\n         set_hint_predicate (&info->loop_stride, p);\n-      p.stream_in (&ib);\n-      if (info)\n-        set_hint_predicate (&info->array_index, p);\n       for (e = node->callees; e; e = e->next_callee)\n \tread_ipa_call_summary (&ib, e, info != NULL);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -3517,10 +3472,6 @@ ipa_fn_summary_write (void)\n \t    info->loop_stride->stream_out (ob);\n  \t  else\n \t    streamer_write_uhwi (ob, 0);\n-\t  if (info->array_index)\n-\t    info->array_index->stream_out (ob);\n-\t  else\n-\t    streamer_write_uhwi (ob, 0);\n \t  for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t    write_ipa_call_summary (ob, edge);\n \t  for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "173d3f2a652df84351720ea4bf7d396f763c37d1", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -48,11 +48,8 @@ enum ipa_hints_vals {\n      if functions are in different modules, inlining may not be so important. \n      Set by simple_edge_hints in ipa-inline-analysis.c.   */\n   INLINE_HINT_cross_module = 64,\n-  /* If array indexes of loads/stores become known there may be room for\n-     further optimization.  */\n-  INLINE_HINT_array_index = 128,\n   /* We know that the callee is hot by profile.  */\n-  INLINE_HINT_known_hot = 256\n+  INLINE_HINT_known_hot = 128\n };\n \n typedef int ipa_hints;\n@@ -97,7 +94,7 @@ class GTY(()) ipa_fn_summary\n       fp_expressions (false), estimated_stack_size (false),\n       stack_frame_offset (false), time (0), size (0), conds (NULL),\n       size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n-      array_index (NULL), growth (0), scc_no (0)\n+      growth (0), scc_no (0)\n   {\n   }\n \n@@ -111,7 +108,7 @@ class GTY(()) ipa_fn_summary\n     stack_frame_offset (s.stack_frame_offset), time (s.time), size (s.size),\n     conds (s.conds), size_time_table (s.size_time_table),\n     loop_iterations (s.loop_iterations), loop_stride (s.loop_stride),\n-    array_index (s.array_index), growth (s.growth), scc_no (s.scc_no)\n+    growth (s.growth), scc_no (s.scc_no)\n   {}\n \n   /* Default constructor.  */\n@@ -157,8 +154,6 @@ class GTY(()) ipa_fn_summary\n   /* Predicate on when some loop in the function becomes to have known\n      stride.   */\n   predicate * GTY((skip)) loop_stride;\n-  /* Predicate on when some array indexes become constants.  */\n-  predicate * GTY((skip)) array_index;\n   /* Estimated growth for inlining all copies of the function before start\n      of small functions inlining.\n      This value will get out of date as the callers are duplicated, but"}, {"sha": "e73006662ad597b61226587ddef67baa047a749c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -807,7 +807,6 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t   || (!(hints & (INLINE_HINT_indirect_call\n \t\t\t\t  | INLINE_HINT_known_hot\n \t\t\t\t  | INLINE_HINT_loop_iterations\n-\t\t\t\t  | INLINE_HINT_array_index\n \t\t\t\t  | INLINE_HINT_loop_stride))\n \t\t       && !(big_speedup = big_speedup_p (e)))))\n \t{\n@@ -833,7 +832,6 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && !(hints & INLINE_HINT_known_hot)\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n \t\t\t\t       | INLINE_HINT_loop_iterations\n-\t\t\t               | INLINE_HINT_array_index\n \t\t\t\t       | INLINE_HINT_loop_stride))\n \t\t\t     ? MAX (MAX_INLINE_INSNS_AUTO,\n \t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n@@ -1227,7 +1225,6 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n     badness = badness.shift (badness > 0 ? 4 : -4);\n   if ((hints & (INLINE_HINT_indirect_call\n \t\t| INLINE_HINT_loop_iterations\n-\t\t| INLINE_HINT_array_index\n \t\t| INLINE_HINT_loop_stride))\n       || callee_info->growth <= 0)\n     badness = badness.shift (badness > 0 ? -2 : 2);"}, {"sha": "7d0dcae0aeeff21c17e38b2f56093eda7506759c", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20f263ba1a76af40eb4e6734529739a2a30ed65/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=a20f263ba1a76af40eb4e6734529739a2a30ed65", "patch": "@@ -1109,12 +1109,6 @@ DEFPARAM (PARAM_IPA_CP_LOOP_HINT_BONUS,\n \t  \"bounds or strides known.\",\n \t  64, 0, 0)\n \n-DEFPARAM (PARAM_IPA_CP_ARRAY_INDEX_HINT_BONUS,\n-\t  \"ipa-cp-array-index-hint-bonus\",\n-\t  \"Compile-time bonus IPA-CP assigns to candidates which make an array \"\n-\t  \"index known.\",\n-\t  48, 0, 0)\n-\n DEFPARAM (PARAM_IPA_MAX_AA_STEPS,\n \t  \"ipa-max-aa-steps\",\n \t  \"Maximum number of statements that will be visited by IPA formal \""}]}