{"sha": "1df3f84256114788e5340cc800b2cdea0e1c9486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRmM2Y4NDI1NjExNDc4OGU1MzQwY2M4MDBiMmNkZWEwZTFjOTQ4Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-13T13:49:47Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:49:47Z"}, "message": "[PATCH 5/7] OpenMP 4.0 offloading infrastructure: libgomp.\n\nlibgomp/\n\t* libgomp.map (GOMP_4.0.1): New symbol version.\n\tAdd GOMP_offload_register.\n\t* libgomp_target.h: New file.\n\t* splay-tree.h: New file.\n\t* target.c: Include config.h, libgomp_target.h, dlfcn.h, splay-tree.h.\n\t(gomp_target_init): New forward declaration.\n\t(gomp_is_initialized): New static variable.\n\t(splay_tree_node, splay_tree, splay_tree_key): New typedefs.\n\t(struct target_mem_desc, struct splay_tree_key_s, offload_image_descr):\n\tNew structures.\n\t(offload_images, num_offload_images, devices, num_devices): New static\n\tvariables.\n\t(splay_compare): New static function.\n\t(struct gomp_device_descr): New structure.\n\t(gomp_get_num_devices): Call gomp_target_init.\n\t(resolve_device, gomp_map_vars_existing, gomp_map_vars, gomp_unmap_tgt)\n\t(gomp_unmap_vars, gomp_update, gomp_init_device): New static functions.\n\t(GOMP_offload_register): New function.\n\t(GOMP_target): Arrange for host callback to be performed in a separate\n\tinitial thread and contention group, inheriting ICVs from\n\tgomp_global_icv etc.  Call gomp_map_vars and gomp_unmap_vars.\n\tAdd device initialization and lookup for target function in splay tree.\n\t(GOMP_target_data): Add device initialization and call gomp_map_vars.\n\t(GOMP_target_end_data): Call gomp_unmap_vars.\n\t(GOMP_target_update): Add device initialization and call gomp_update.\n\t(gomp_load_plugin_for_device, gomp_register_images_for_device)\n\t(gomp_target_init): New static functions.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>\n\nFrom-SVN: r217492", "tree": {"sha": "ddbdbd5bcf3af4f93259466d17ee8a7b1b053abd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddbdbd5bcf3af4f93259466d17ee8a7b1b053abd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1df3f84256114788e5340cc800b2cdea0e1c9486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df3f84256114788e5340cc800b2cdea0e1c9486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df3f84256114788e5340cc800b2cdea0e1c9486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df3f84256114788e5340cc800b2cdea0e1c9486/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc8b3540d23168b5a35988b35336ba70c4174091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8b3540d23168b5a35988b35336ba70c4174091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc8b3540d23168b5a35988b35336ba70c4174091"}], "stats": {"total": 1165, "additions": 1160, "deletions": 5}, "files": [{"sha": "52d45f7aa5041f63cbd1e4e958e0b5500807bb20", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1df3f84256114788e5340cc800b2cdea0e1c9486", "patch": "@@ -1,3 +1,36 @@\n+2014-11-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\n+\t* libgomp.map (GOMP_4.0.1): New symbol version.\n+\tAdd GOMP_offload_register.\n+\t* libgomp_target.h: New file.\n+\t* splay-tree.h: New file.\n+\t* target.c: Include config.h, libgomp_target.h, dlfcn.h, splay-tree.h.\n+\t(gomp_target_init): New forward declaration.\n+\t(gomp_is_initialized): New static variable.\n+\t(splay_tree_node, splay_tree, splay_tree_key): New typedefs.\n+\t(struct target_mem_desc, struct splay_tree_key_s, offload_image_descr):\n+\tNew structures.\n+\t(offload_images, num_offload_images, devices, num_devices): New static\n+\tvariables.\n+\t(splay_compare): New static function.\n+\t(struct gomp_device_descr): New structure.\n+\t(gomp_get_num_devices): Call gomp_target_init.\n+\t(resolve_device, gomp_map_vars_existing, gomp_map_vars, gomp_unmap_tgt)\n+\t(gomp_unmap_vars, gomp_update, gomp_init_device): New static functions.\n+\t(GOMP_offload_register): New function.\n+\t(GOMP_target): Arrange for host callback to be performed in a separate\n+\tinitial thread and contention group, inheriting ICVs from\n+\tgomp_global_icv etc.  Call gomp_map_vars and gomp_unmap_vars.\n+\tAdd device initialization and lookup for target function in splay tree.\n+\t(GOMP_target_data): Add device initialization and call gomp_map_vars.\n+\t(GOMP_target_end_data): Call gomp_unmap_vars.\n+\t(GOMP_target_update): Add device initialization and call gomp_update.\n+\t(gomp_load_plugin_for_device, gomp_register_images_for_device)\n+\t(gomp_target_init): New static functions.\n+\n 2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>"}, {"sha": "f36df23e79515a3c593b6017c8afe533a2586666", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=1df3f84256114788e5340cc800b2cdea0e1c9486", "patch": "@@ -227,3 +227,8 @@ GOMP_4.0 {\n \tGOMP_target_update;\n \tGOMP_teams;\n } GOMP_3.0;\n+\n+GOMP_4.0.1 {\n+  global:\n+\tGOMP_offload_register;\n+} GOMP_4.0;"}, {"sha": "f7d19d051f0e355baab2568db1f050007f2f1b9c", "filename": "libgomp/libgomp_target.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Flibgomp_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Flibgomp_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_target.h?ref=1df3f84256114788e5340cc800b2cdea0e1c9486", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBGOMP_TARGET_H\n+#define LIBGOMP_TARGET_H 1\n+\n+/* Type of offload target device.  */\n+enum offload_target_type\n+{\n+  OFFLOAD_TARGET_TYPE_HOST,\n+  OFFLOAD_TARGET_TYPE_INTEL_MIC\n+};\n+\n+/* Auxiliary struct, used for transferring a host-target address range mapping\n+   from plugin to libgomp.  */\n+struct mapping_table\n+{\n+  uintptr_t host_start;\n+  uintptr_t host_end;\n+  uintptr_t tgt_start;\n+  uintptr_t tgt_end;\n+};\n+\n+#endif /* LIBGOMP_TARGET_H */"}, {"sha": "eb8011a8b5c8e2111b521566e5c788d7ac1e2288", "filename": "libgomp/splay-tree.h", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.h?ref=1df3f84256114788e5340cc800b2cdea0e1c9486", "patch": "@@ -0,0 +1,232 @@\n+/* A splay-tree datatype.\n+   Copyright 1998-2014\n+   Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The splay tree code copied from include/splay-tree.h and adjusted,\n+   so that all the data lives directly in splay_tree_node_s structure\n+   and no extra allocations are needed.\n+\n+   Files including this header should before including it add:\n+typedef struct splay_tree_node_s *splay_tree_node;\n+typedef struct splay_tree_s *splay_tree;\n+typedef struct splay_tree_key_s *splay_tree_key;\n+   define splay_tree_key_s structure, and define\n+   splay_compare inline function.  */\n+\n+/* For an easily readable description of splay-trees, see:\n+\n+     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n+     Algorithms.  Harper-Collins, Inc.  1991.\n+\n+   The major feature of splay trees is that all basic tree operations\n+   are amortized O(log n) time for a tree with n nodes.  */\n+\n+/* The nodes in the splay tree.  */\n+struct splay_tree_node_s {\n+  struct splay_tree_key_s key;\n+  /* The left and right children, respectively.  */\n+  splay_tree_node left;\n+  splay_tree_node right;\n+};\n+\n+/* The splay tree.  */\n+struct splay_tree_s {\n+  splay_tree_node root;\n+};\n+\n+/* Rotate the edge joining the left child N with its parent P.  PP is the\n+   grandparents' pointer to P.  */\n+\n+static inline void\n+rotate_left (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)\n+{\n+  splay_tree_node tmp;\n+  tmp = n->right;\n+  n->right = p;\n+  p->left = tmp;\n+  *pp = n;\n+}\n+\n+/* Rotate the edge joining the right child N with its parent P.  PP is the\n+   grandparents' pointer to P.  */\n+\n+static inline void\n+rotate_right (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)\n+{\n+  splay_tree_node tmp;\n+  tmp = n->left;\n+  n->left = p;\n+  p->right = tmp;\n+  *pp = n;\n+}\n+\n+/* Bottom up splay of KEY.  */\n+\n+static void\n+splay_tree_splay (splay_tree sp, splay_tree_key key)\n+{\n+  if (sp->root == NULL)\n+    return;\n+\n+  do {\n+    int cmp1, cmp2;\n+    splay_tree_node n, c;\n+\n+    n = sp->root;\n+    cmp1 = splay_compare (key, &n->key);\n+\n+    /* Found.  */\n+    if (cmp1 == 0)\n+      return;\n+\n+    /* Left or right?  If no child, then we're done.  */\n+    if (cmp1 < 0)\n+      c = n->left;\n+    else\n+      c = n->right;\n+    if (!c)\n+      return;\n+\n+    /* Next one left or right?  If found or no child, we're done\n+       after one rotation.  */\n+    cmp2 = splay_compare (key, &c->key);\n+    if (cmp2 == 0\n+\t|| (cmp2 < 0 && !c->left)\n+\t|| (cmp2 > 0 && !c->right))\n+      {\n+\tif (cmp1 < 0)\n+\t  rotate_left (&sp->root, n, c);\n+\telse\n+\t  rotate_right (&sp->root, n, c);\n+\treturn;\n+      }\n+\n+    /* Now we have the four cases of double-rotation.  */\n+    if (cmp1 < 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->left, c, c->left);\n+\trotate_left (&sp->root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->right, c, c->right);\n+\trotate_right (&sp->root, n, n->right);\n+      }\n+    else if (cmp1 < 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->left, c, c->right);\n+\trotate_left (&sp->root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->right, c, c->left);\n+\trotate_right (&sp->root, n, n->right);\n+      }\n+  } while (1);\n+}\n+\n+/* Insert a new NODE into SP.  The NODE shouldn't exist in the tree.  */\n+\n+static void\n+splay_tree_insert (splay_tree sp, splay_tree_node node)\n+{\n+  int comparison = 0;\n+\n+  splay_tree_splay (sp, &node->key);\n+\n+  if (sp->root)\n+    comparison = splay_compare (&sp->root->key, &node->key);\n+\n+  if (sp->root && comparison == 0)\n+    abort ();\n+  else\n+    {\n+      /* Insert it at the root.  */\n+      if (sp->root == NULL)\n+\tnode->left = node->right = NULL;\n+      else if (comparison < 0)\n+\t{\n+\t  node->left = sp->root;\n+\t  node->right = node->left->right;\n+\t  node->left->right = NULL;\n+\t}\n+      else\n+\t{\n+\t  node->right = sp->root;\n+\t  node->left = node->right->left;\n+\t  node->right->left = NULL;\n+\t}\n+\n+      sp->root = node;\n+    }\n+}\n+\n+/* Remove node with KEY from SP.  It is not an error if it did not exist.  */\n+\n+static void\n+splay_tree_remove (splay_tree sp, splay_tree_key key)\n+{\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root && splay_compare (&sp->root->key, key) == 0)\n+    {\n+      splay_tree_node left, right;\n+\n+      left = sp->root->left;\n+      right = sp->root->right;\n+\n+      /* One of the children is now the root.  Doesn't matter much\n+\t which, so long as we preserve the properties of the tree.  */\n+      if (left)\n+\t{\n+\t  sp->root = left;\n+\n+\t  /* If there was a right child as well, hang it off the\n+\t     right-most leaf of the left child.  */\n+\t  if (right)\n+\t    {\n+\t      while (left->right)\n+\t\tleft = left->right;\n+\t      left->right = right;\n+\t    }\n+\t}\n+      else\n+\tsp->root = right;\n+    }\n+}\n+\n+/* Lookup KEY in SP, returning NODE if present, and NULL\n+   otherwise.  */\n+\n+static splay_tree_key\n+splay_tree_lookup (splay_tree sp, splay_tree_key key)\n+{\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root && splay_compare (&sp->root->key, key) == 0)\n+    return &sp->root->key;\n+  else\n+    return NULL;\n+}"}, {"sha": "5b4873b4ffc40ce0968ccb70afcf0c3d5555dea5", "filename": "libgomp/target.c", "status": "modified", "additions": 846, "deletions": 5, "changes": 851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df3f84256114788e5340cc800b2cdea0e1c9486/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=1df3f84256114788e5340cc800b2cdea0e1c9486", "patch": "@@ -22,19 +22,641 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* This file handles the maintainence of threads in response to team\n-   creation and termination.  */\n+/* This file contains the support of offloading.  */\n \n+#include \"config.h\"\n #include \"libgomp.h\"\n+#include \"libgomp_target.h\"\n #include <limits.h>\n #include <stdbool.h>\n #include <stdlib.h>\n #include <string.h>\n \n+#ifdef PLUGIN_SUPPORT\n+#include <dlfcn.h>\n+#endif\n+\n+static void gomp_target_init (void);\n+\n+static pthread_once_t gomp_is_initialized = PTHREAD_ONCE_INIT;\n+\n+/* Forward declaration for a node in the tree.  */\n+typedef struct splay_tree_node_s *splay_tree_node;\n+typedef struct splay_tree_s *splay_tree;\n+typedef struct splay_tree_key_s *splay_tree_key;\n+\n+struct target_mem_desc {\n+  /* Reference count.  */\n+  uintptr_t refcount;\n+  /* All the splay nodes allocated together.  */\n+  splay_tree_node array;\n+  /* Start of the target region.  */\n+  uintptr_t tgt_start;\n+  /* End of the targer region.  */\n+  uintptr_t tgt_end;\n+  /* Handle to free.  */\n+  void *to_free;\n+  /* Previous target_mem_desc.  */\n+  struct target_mem_desc *prev;\n+  /* Number of items in following list.  */\n+  size_t list_count;\n+\n+  /* Corresponding target device descriptor.  */\n+  struct gomp_device_descr *device_descr;\n+\n+  /* List of splay keys to remove (or decrease refcount)\n+     at the end of region.  */\n+  splay_tree_key list[];\n+};\n+\n+struct splay_tree_key_s {\n+  /* Address of the host object.  */\n+  uintptr_t host_start;\n+  /* Address immediately after the host object.  */\n+  uintptr_t host_end;\n+  /* Descriptor of the target memory.  */\n+  struct target_mem_desc *tgt;\n+  /* Offset from tgt->tgt_start to the start of the target object.  */\n+  uintptr_t tgt_offset;\n+  /* Reference count.  */\n+  uintptr_t refcount;\n+  /* True if data should be copied from device to host at the end.  */\n+  bool copy_from;\n+};\n+\n+/* This structure describes an offload image.\n+   It contains type of the target device, pointer to host table descriptor, and\n+   pointer to target data.  */\n+struct offload_image_descr {\n+  enum offload_target_type type;\n+  void *host_table;\n+  void *target_data;\n+};\n+\n+/* Array of descriptors of offload images.  */\n+static struct offload_image_descr *offload_images;\n+\n+/* Total number of offload images.  */\n+static int num_offload_images;\n+\n+/* Array of descriptors for all available devices.  */\n+static struct gomp_device_descr *devices;\n+\n+/* Total number of available devices.  */\n+static int num_devices;\n+\n+/* The comparison function.  */\n+\n+static int\n+splay_compare (splay_tree_key x, splay_tree_key y)\n+{\n+  if (x->host_start == x->host_end\n+      && y->host_start == y->host_end)\n+    return 0;\n+  if (x->host_end <= y->host_start)\n+    return -1;\n+  if (x->host_start >= y->host_end)\n+    return 1;\n+  return 0;\n+}\n+\n+#include \"splay-tree.h\"\n+\n+/* This structure describes accelerator device.\n+   It contains ID-number of the device, its type, function handlers for\n+   interaction with the device, and information about mapped memory.  */\n+struct gomp_device_descr\n+{\n+  /* This is the ID number of device.  It could be specified in DEVICE-clause of\n+     TARGET construct.  */\n+  int id;\n+\n+  /* This is the ID number of device among devices of the same type.  */\n+  int target_id;\n+\n+  /* This is the TYPE of device.  */\n+  enum offload_target_type type;\n+\n+  /* Set to true when device is initialized.  */\n+  bool is_initialized;\n+\n+  /* Function handlers.  */\n+  int (*get_type_func) (void);\n+  int (*get_num_devices_func) (void);\n+  void (*register_image_func) (void *, void *);\n+  void (*init_device_func) (int);\n+  int (*get_table_func) (int, void *);\n+  void *(*alloc_func) (int, size_t);\n+  void (*free_func) (int, void *);\n+  void *(*host2dev_func) (int, void *, const void *, size_t);\n+  void *(*dev2host_func) (int, void *, const void *, size_t);\n+  void (*run_func) (int, void *, void *);\n+\n+  /* Splay tree containing information about mapped memory regions.  */\n+  struct splay_tree_s dev_splay_tree;\n+\n+  /* Mutex for operating with the splay tree and other shared structures.  */\n+  gomp_mutex_t dev_env_lock;\n+};\n+\n attribute_hidden int\n gomp_get_num_devices (void)\n {\n-  return 0;\n+  (void) pthread_once (&gomp_is_initialized, gomp_target_init);\n+  return num_devices;\n+}\n+\n+static struct gomp_device_descr *\n+resolve_device (int device_id)\n+{\n+  if (device_id == -1)\n+    {\n+      struct gomp_task_icv *icv = gomp_icv (false);\n+      device_id = icv->default_device_var;\n+    }\n+\n+  if (device_id < 0 || device_id >= gomp_get_num_devices ())\n+    return NULL;\n+\n+  return &devices[device_id];\n+}\n+\n+\n+/* Handle the case where splay_tree_lookup found oldn for newn.\n+   Helper function of gomp_map_vars.  */\n+\n+static inline void\n+gomp_map_vars_existing (splay_tree_key oldn, splay_tree_key newn,\n+\t\t\tunsigned char kind)\n+{\n+  if (oldn->host_start > newn->host_start\n+      || oldn->host_end < newn->host_end)\n+    gomp_fatal (\"Trying to map into device [%p..%p) object when\"\n+\t\t\"[%p..%p) is already mapped\",\n+\t\t(void *) newn->host_start, (void *) newn->host_end,\n+\t\t(void *) oldn->host_start, (void *) oldn->host_end);\n+  oldn->refcount++;\n+}\n+\n+static struct target_mem_desc *\n+gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n+\t       void **hostaddrs, size_t *sizes, unsigned char *kinds,\n+\t       bool is_target)\n+{\n+  size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n+  struct splay_tree_key_s cur_node;\n+  struct target_mem_desc *tgt\n+    = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n+  tgt->list_count = mapnum;\n+  tgt->refcount = 1;\n+  tgt->device_descr = devicep;\n+\n+  if (mapnum == 0)\n+    return tgt;\n+\n+  tgt_align = sizeof (void *);\n+  tgt_size = 0;\n+  if (is_target)\n+    {\n+      size_t align = 4 * sizeof (void *);\n+      tgt_align = align;\n+      tgt_size = mapnum * sizeof (void *);\n+    }\n+\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  for (i = 0; i < mapnum; i++)\n+    {\n+      if (hostaddrs[i] == NULL)\n+\t{\n+\t  tgt->list[i] = NULL;\n+\t  continue;\n+\t}\n+      cur_node.host_start = (uintptr_t) hostaddrs[i];\n+      if ((kinds[i] & 7) != 4)\n+\tcur_node.host_end = cur_node.host_start + sizes[i];\n+      else\n+\tcur_node.host_end = cur_node.host_start + sizeof (void *);\n+      splay_tree_key n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t    &cur_node);\n+      if (n)\n+\t{\n+\t  tgt->list[i] = n;\n+\t  gomp_map_vars_existing (n, &cur_node, kinds[i]);\n+\t}\n+      else\n+\t{\n+\t  size_t align = (size_t) 1 << (kinds[i] >> 3);\n+\t  tgt->list[i] = NULL;\n+\t  not_found_cnt++;\n+\t  if (tgt_align < align)\n+\t    tgt_align = align;\n+\t  tgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t  tgt_size += cur_node.host_end - cur_node.host_start;\n+\t  if ((kinds[i] & 7) == 5)\n+\t    {\n+\t      size_t j;\n+\t      for (j = i + 1; j < mapnum; j++)\n+\t\tif ((kinds[j] & 7) != 4)\n+\t\t  break;\n+\t\telse if ((uintptr_t) hostaddrs[j] < cur_node.host_start\n+\t\t\t || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n+\t\t\t     > cur_node.host_end))\n+\t\t  break;\n+\t\telse\n+\t\t  {\n+\t\t    tgt->list[j] = NULL;\n+\t\t    i++;\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+\n+  if (not_found_cnt || is_target)\n+    {\n+      /* Allocate tgt_align aligned tgt_size block of memory.  */\n+      /* FIXME: Perhaps change interface to allocate properly aligned\n+\t memory.  */\n+      tgt->to_free = devicep->alloc_func (devicep->target_id,\n+\t\t\t\t\t  tgt_size + tgt_align - 1);\n+      tgt->tgt_start = (uintptr_t) tgt->to_free;\n+      tgt->tgt_start = (tgt->tgt_start + tgt_align - 1) & ~(tgt_align - 1);\n+      tgt->tgt_end = tgt->tgt_start + tgt_size;\n+    }\n+  else\n+    {\n+      tgt->to_free = NULL;\n+      tgt->tgt_start = 0;\n+      tgt->tgt_end = 0;\n+    }\n+\n+  tgt_size = 0;\n+  if (is_target)\n+    tgt_size = mapnum * sizeof (void *);\n+\n+  tgt->array = NULL;\n+  if (not_found_cnt)\n+    {\n+      tgt->array = gomp_malloc (not_found_cnt * sizeof (*tgt->array));\n+      splay_tree_node array = tgt->array;\n+      size_t j;\n+\n+      for (i = 0; i < mapnum; i++)\n+\tif (tgt->list[i] == NULL)\n+\t  {\n+\t    if (hostaddrs[i] == NULL)\n+\t      continue;\n+\t    splay_tree_key k = &array->key;\n+\t    k->host_start = (uintptr_t) hostaddrs[i];\n+\t    if ((kinds[i] & 7) != 4)\n+\t      k->host_end = k->host_start + sizes[i];\n+\t    else\n+\t      k->host_end = k->host_start + sizeof (void *);\n+\t    splay_tree_key n\n+\t      = splay_tree_lookup (&devicep->dev_splay_tree, k);\n+\t    if (n)\n+\t      {\n+\t\ttgt->list[i] = n;\n+\t\tgomp_map_vars_existing (n, k, kinds[i]);\n+\t      }\n+\t    else\n+\t      {\n+\t\tsize_t align = (size_t) 1 << (kinds[i] >> 3);\n+\t\ttgt->list[i] = k;\n+\t\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n+\t\tk->tgt = tgt;\n+\t\tk->tgt_offset = tgt_size;\n+\t\ttgt_size += k->host_end - k->host_start;\n+\t\tk->copy_from = false;\n+\t\tif ((kinds[i] & 7) == 2 || (kinds[i] & 7) == 3)\n+\t\t  k->copy_from = true;\n+\t\tk->refcount = 1;\n+\t\ttgt->refcount++;\n+\t\tarray->left = NULL;\n+\t\tarray->right = NULL;\n+\t\tsplay_tree_insert (&devicep->dev_splay_tree, array);\n+\t\tswitch (kinds[i] & 7)\n+\t\t  {\n+\t\t  case 0: /* ALLOC */\n+\t\t  case 2: /* FROM */\n+\t\t    break;\n+\t\t  case 1: /* TO */\n+\t\t  case 3: /* TOFROM */\n+\t\t    /* FIXME: Perhaps add some smarts, like if copying\n+\t\t       several adjacent fields from host to target, use some\n+\t\t       host buffer to avoid sending each var individually.  */\n+\t\t    devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t    (void *) (tgt->tgt_start\n+\t\t\t\t\t\t      + k->tgt_offset),\n+\t\t\t\t\t    (void *) k->host_start,\n+\t\t\t\t\t    k->host_end - k->host_start);\n+\t\t    break;\n+\t\t  case 4: /* POINTER */\n+\t\t    cur_node.host_start\n+\t\t      = (uintptr_t) *(void **) k->host_start;\n+\t\t    if (cur_node.host_start == (uintptr_t) NULL)\n+\t\t      {\n+\t\t\tcur_node.tgt_offset = (uintptr_t) NULL;\n+\t\t\tdevicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t\t(void *) (tgt->tgt_start\n+\t\t\t\t\t\t\t  + k->tgt_offset),\n+\t\t\t\t\t\t(void *) &cur_node.tgt_offset,\n+\t\t\t\t\t\tsizeof (void *));\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    /* Add bias to the pointer value.  */\n+\t\t    cur_node.host_start += sizes[i];\n+\t\t    cur_node.host_end = cur_node.host_start + 1;\n+\t\t    n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t   &cur_node);\n+\t\t    if (n == NULL)\n+\t\t      {\n+\t\t\t/* Could be possibly zero size array section.  */\n+\t\t\tcur_node.host_end--;\n+\t\t\tn = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t       &cur_node);\n+\t\t\tif (n == NULL)\n+\t\t\t  {\n+\t\t\t    cur_node.host_start--;\n+\t\t\t    n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t\t   &cur_node);\n+\t\t\t    cur_node.host_start++;\n+\t\t\t  }\n+\t\t      }\n+\t\t    if (n == NULL)\n+\t\t      gomp_fatal (\"Pointer target of array section \"\n+\t\t\t\t  \"wasn't mapped\");\n+\t\t    cur_node.host_start -= n->host_start;\n+\t\t    cur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n+\t\t\t\t\t  + cur_node.host_start;\n+\t\t    /* At this point tgt_offset is target address of the\n+\t\t       array section.  Now subtract bias to get what we want\n+\t\t       to initialize the pointer with.  */\n+\t\t    cur_node.tgt_offset -= sizes[i];\n+\t\t    devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t    (void *) (tgt->tgt_start\n+\t\t\t\t\t\t      + k->tgt_offset),\n+\t\t\t\t\t    (void *) &cur_node.tgt_offset,\n+\t\t\t\t\t    sizeof (void *));\n+\t\t    break;\n+\t\t  case 5: /* TO_PSET */\n+\t\t    devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t    (void *) (tgt->tgt_start\n+\t\t\t\t\t\t      + k->tgt_offset),\n+\t\t\t\t\t    (void *) k->host_start,\n+\t\t\t\t\t    k->host_end - k->host_start);\n+\t\t    for (j = i + 1; j < mapnum; j++)\n+\t\t      if ((kinds[j] & 7) != 4)\n+\t\t\tbreak;\n+\t\t      else if ((uintptr_t) hostaddrs[j] < k->host_start\n+\t\t\t       || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n+\t\t\t\t   > k->host_end))\n+\t\t\tbreak;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  tgt->list[j] = k;\n+\t\t\t  k->refcount++;\n+\t\t\t  cur_node.host_start\n+\t\t\t    = (uintptr_t) *(void **) hostaddrs[j];\n+\t\t\t  if (cur_node.host_start == (uintptr_t) NULL)\n+\t\t\t    {\n+\t\t\t      cur_node.tgt_offset = (uintptr_t) NULL;\n+\t\t\t      devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t (void *) (tgt->tgt_start + k->tgt_offset\n+\t\t\t\t\t   + ((uintptr_t) hostaddrs[j]\n+\t\t\t\t\t      - k->host_start)),\n+\t\t\t\t (void *) &cur_node.tgt_offset,\n+\t\t\t\t sizeof (void *));\n+\t\t\t      i++;\n+\t\t\t      continue;\n+\t\t\t    }\n+\t\t\t  /* Add bias to the pointer value.  */\n+\t\t\t  cur_node.host_start += sizes[j];\n+\t\t\t  cur_node.host_end = cur_node.host_start + 1;\n+\t\t\t  n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t\t &cur_node);\n+\t\t\t  if (n == NULL)\n+\t\t\t    {\n+\t\t\t      /* Could be possibly zero size array section.  */\n+\t\t\t      cur_node.host_end--;\n+\t\t\t      n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t\t     &cur_node);\n+\t\t\t      if (n == NULL)\n+\t\t\t\t{\n+\t\t\t\t  cur_node.host_start--;\n+\t\t\t\t  n = splay_tree_lookup\n+\t\t\t\t\t(&devicep->dev_splay_tree, &cur_node);\n+\t\t\t\t  cur_node.host_start++;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  if (n == NULL)\n+\t\t\t    gomp_fatal (\"Pointer target of array section \"\n+\t\t\t\t\t\"wasn't mapped\");\n+\t\t\t  cur_node.host_start -= n->host_start;\n+\t\t\t  cur_node.tgt_offset = n->tgt->tgt_start\n+\t\t\t\t\t\t+ n->tgt_offset\n+\t\t\t\t\t\t+ cur_node.host_start;\n+\t\t\t  /* At this point tgt_offset is target address of the\n+\t\t\t     array section.  Now subtract bias to get what we\n+\t\t\t     want to initialize the pointer with.  */\n+\t\t\t  cur_node.tgt_offset -= sizes[j];\n+\t\t\t  devicep->host2dev_func (devicep->target_id,\n+\t\t\t     (void *) (tgt->tgt_start + k->tgt_offset\n+\t\t\t\t       + ((uintptr_t) hostaddrs[j]\n+\t\t\t\t\t  - k->host_start)),\n+\t\t\t     (void *) &cur_node.tgt_offset,\n+\t\t\t     sizeof (void *));\n+\t\t\t  i++;\n+\t\t\t}\n+\t\t      break;\n+\t\t  }\n+\t\tarray++;\n+\t      }\n+\t  }\n+    }\n+  if (is_target)\n+    {\n+      for (i = 0; i < mapnum; i++)\n+\t{\n+\t  if (tgt->list[i] == NULL)\n+\t    cur_node.tgt_offset = (uintptr_t) NULL;\n+\t  else\n+\t    cur_node.tgt_offset = tgt->list[i]->tgt->tgt_start\n+\t\t\t\t  + tgt->list[i]->tgt_offset;\n+\t  devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t  (void *) (tgt->tgt_start\n+\t\t\t\t\t    + i * sizeof (void *)),\n+\t\t\t\t  (void *) &cur_node.tgt_offset,\n+\t\t\t\t  sizeof (void *));\n+\t}\n+    }\n+\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+  return tgt;\n+}\n+\n+static void\n+gomp_unmap_tgt (struct target_mem_desc *tgt)\n+{\n+  /* Deallocate on target the tgt->tgt_start .. tgt->tgt_end region.  */\n+  if (tgt->tgt_end)\n+    tgt->device_descr->free_func (tgt->device_descr->target_id, tgt->to_free);\n+\n+  free (tgt->array);\n+  free (tgt);\n+}\n+\n+static void\n+gomp_unmap_vars (struct target_mem_desc *tgt)\n+{\n+  struct gomp_device_descr *devicep = tgt->device_descr;\n+\n+  if (tgt->list_count == 0)\n+    {\n+      free (tgt);\n+      return;\n+    }\n+\n+  size_t i;\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  for (i = 0; i < tgt->list_count; i++)\n+    if (tgt->list[i] == NULL)\n+      ;\n+    else if (tgt->list[i]->refcount > 1)\n+      tgt->list[i]->refcount--;\n+    else\n+      {\n+\tsplay_tree_key k = tgt->list[i];\n+\tif (k->copy_from)\n+\t  devicep->dev2host_func (devicep->target_id, (void *) k->host_start,\n+\t\t\t\t  (void *) (k->tgt->tgt_start + k->tgt_offset),\n+\t\t\t\t  k->host_end - k->host_start);\n+\tsplay_tree_remove (&devicep->dev_splay_tree, k);\n+\tif (k->tgt->refcount > 1)\n+\t  k->tgt->refcount--;\n+\telse\n+\t  gomp_unmap_tgt (k->tgt);\n+      }\n+\n+  if (tgt->refcount > 1)\n+    tgt->refcount--;\n+  else\n+    gomp_unmap_tgt (tgt);\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+}\n+\n+static void\n+gomp_update (struct gomp_device_descr *devicep, size_t mapnum,\n+\t     void **hostaddrs, size_t *sizes, unsigned char *kinds)\n+{\n+  size_t i;\n+  struct splay_tree_key_s cur_node;\n+\n+  if (!devicep)\n+    return;\n+\n+  if (mapnum == 0)\n+    return;\n+\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  for (i = 0; i < mapnum; i++)\n+    if (sizes[i])\n+      {\n+\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n+\tcur_node.host_end = cur_node.host_start + sizes[i];\n+\tsplay_tree_key n = splay_tree_lookup (&devicep->dev_splay_tree,\n+\t\t\t\t\t      &cur_node);\n+\tif (n)\n+\t  {\n+\t    if (n->host_start > cur_node.host_start\n+\t\t|| n->host_end < cur_node.host_end)\n+\t      gomp_fatal (\"Trying to update [%p..%p) object when\"\n+\t\t\t  \"only [%p..%p) is mapped\",\n+\t\t\t  (void *) cur_node.host_start,\n+\t\t\t  (void *) cur_node.host_end,\n+\t\t\t  (void *) n->host_start,\n+\t\t\t  (void *) n->host_end);\n+\t    if ((kinds[i] & 7) == 1)\n+\t      devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t      (void *) (n->tgt->tgt_start\n+\t\t\t\t\t\t+ n->tgt_offset\n+\t\t\t\t\t\t+ cur_node.host_start\n+\t\t\t\t\t\t- n->host_start),\n+\t\t\t\t      (void *) cur_node.host_start,\n+\t\t\t\t      cur_node.host_end - cur_node.host_start);\n+\t    else if ((kinds[i] & 7) == 2)\n+\t      devicep->dev2host_func (devicep->target_id,\n+\t\t\t\t      (void *) cur_node.host_start,\n+\t\t\t\t      (void *) (n->tgt->tgt_start\n+\t\t\t\t\t\t+ n->tgt_offset\n+\t\t\t\t\t\t+ cur_node.host_start\n+\t\t\t\t\t\t- n->host_start),\n+\t\t\t\t      cur_node.host_end - cur_node.host_start);\n+\t  }\n+\telse\n+\t  gomp_fatal (\"Trying to update [%p..%p) object that is not mapped\",\n+\t\t      (void *) cur_node.host_start,\n+\t\t      (void *) cur_node.host_end);\n+      }\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+}\n+\n+/* This function should be called from every offload image.\n+   It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n+   the target, and TARGET_DATA needed by target plugin.  */\n+\n+void\n+GOMP_offload_register (void *host_table, enum offload_target_type target_type,\n+\t\t       void *target_data)\n+{\n+  offload_images = gomp_realloc (offload_images,\n+\t\t\t\t (num_offload_images + 1)\n+\t\t\t\t * sizeof (struct offload_image_descr));\n+\n+  offload_images[num_offload_images].type = target_type;\n+  offload_images[num_offload_images].host_table = host_table;\n+  offload_images[num_offload_images].target_data = target_data;\n+\n+  num_offload_images++;\n+}\n+\n+/* This function initializes the target device, specified by DEVICEP.  */\n+\n+static void\n+gomp_init_device (struct gomp_device_descr *devicep)\n+{\n+  devicep->init_device_func (devicep->target_id);\n+\n+  /* Get address mapping table for device.  */\n+  struct mapping_table *table = NULL;\n+  int num_entries = devicep->get_table_func (devicep->target_id, &table);\n+\n+  /* Insert host-target address mapping into dev_splay_tree.  */\n+  int i;\n+  for (i = 0; i < num_entries; i++)\n+    {\n+      struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n+      tgt->refcount = 1;\n+      tgt->array = gomp_malloc (sizeof (*tgt->array));\n+      tgt->tgt_start = table[i].tgt_start;\n+      tgt->tgt_end = table[i].tgt_end;\n+      tgt->to_free = NULL;\n+      tgt->list_count = 0;\n+      tgt->device_descr = devicep;\n+      splay_tree_node node = tgt->array;\n+      splay_tree_key k = &node->key;\n+      k->host_start = table[i].host_start;\n+      k->host_end = table[i].host_end;\n+      k->tgt_offset = 0;\n+      k->refcount = 1;\n+      k->copy_from = false;\n+      k->tgt = tgt;\n+      node->left = NULL;\n+      node->right = NULL;\n+      splay_tree_insert (&devicep->dev_splay_tree, node);\n+    }\n+\n+  free (table);\n+  devicep->is_initialized = true;\n }\n \n /* Called when encountering a target directive.  If DEVICE\n@@ -52,7 +674,38 @@ GOMP_target (int device, void (*fn) (void *), const void *openmp_target,\n \t     size_t mapnum, void **hostaddrs, size_t *sizes,\n \t     unsigned char *kinds)\n {\n-  /* Host fallback.  */\n+  struct gomp_device_descr *devicep = resolve_device (device);\n+  if (devicep == NULL)\n+    {\n+      /* Host fallback.  */\n+      struct gomp_thread old_thr, *thr = gomp_thread ();\n+      old_thr = *thr;\n+      memset (thr, '\\0', sizeof (*thr));\n+      if (gomp_places_list)\n+\t{\n+\t  thr->place = old_thr.place;\n+\t  thr->ts.place_partition_len = gomp_places_list_len;\n+\t}\n+      fn (hostaddrs);\n+      gomp_free_thread (thr);\n+      *thr = old_thr;\n+      return;\n+    }\n+\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  if (!devicep->is_initialized)\n+    gomp_init_device (devicep);\n+\n+  struct splay_tree_key_s k;\n+  k.host_start = (uintptr_t) fn;\n+  k.host_end = k.host_start + 1;\n+  splay_tree_key tgt_fn = splay_tree_lookup (&devicep->dev_splay_tree, &k);\n+  if (tgt_fn == NULL)\n+    gomp_fatal (\"Target function wasn't mapped\");\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+\n+  struct target_mem_desc *tgt_vars\n+    = gomp_map_vars (devicep, mapnum, hostaddrs, sizes, kinds, true);\n   struct gomp_thread old_thr, *thr = gomp_thread ();\n   old_thr = *thr;\n   memset (thr, '\\0', sizeof (*thr));\n@@ -61,26 +714,74 @@ GOMP_target (int device, void (*fn) (void *), const void *openmp_target,\n       thr->place = old_thr.place;\n       thr->ts.place_partition_len = gomp_places_list_len;\n     }\n-  fn (hostaddrs);\n+  devicep->run_func (devicep->target_id, (void *) tgt_fn->tgt->tgt_start,\n+\t\t     (void *) tgt_vars->tgt_start);\n   gomp_free_thread (thr);\n   *thr = old_thr;\n+  gomp_unmap_vars (tgt_vars);\n }\n \n void\n GOMP_target_data (int device, const void *openmp_target, size_t mapnum,\n \t\t  void **hostaddrs, size_t *sizes, unsigned char *kinds)\n {\n+  struct gomp_device_descr *devicep = resolve_device (device);\n+  if (devicep == NULL)\n+    {\n+      /* Host fallback.  */\n+      struct gomp_task_icv *icv = gomp_icv (false);\n+      if (icv->target_data)\n+\t{\n+\t  /* Even when doing a host fallback, if there are any active\n+\t     #pragma omp target data constructs, need to remember the\n+\t     new #pragma omp target data, otherwise GOMP_target_end_data\n+\t     would get out of sync.  */\n+\t  struct target_mem_desc *tgt\n+\t    = gomp_map_vars (NULL, 0, NULL, NULL, NULL, false);\n+\t  tgt->prev = icv->target_data;\n+\t  icv->target_data = tgt;\n+\t}\n+      return;\n+    }\n+\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  if (!devicep->is_initialized)\n+    gomp_init_device (devicep);\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+\n+  struct target_mem_desc *tgt\n+    = gomp_map_vars (devicep, mapnum, hostaddrs, sizes, kinds, false);\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  tgt->prev = icv->target_data;\n+  icv->target_data = tgt;\n }\n \n void\n GOMP_target_end_data (void)\n {\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  if (icv->target_data)\n+    {\n+      struct target_mem_desc *tgt = icv->target_data;\n+      icv->target_data = tgt->prev;\n+      gomp_unmap_vars (tgt);\n+    }\n }\n \n void\n GOMP_target_update (int device, const void *openmp_target, size_t mapnum,\n \t\t    void **hostaddrs, size_t *sizes, unsigned char *kinds)\n {\n+  struct gomp_device_descr *devicep = resolve_device (device);\n+  if (devicep == NULL)\n+    return;\n+\n+  gomp_mutex_lock (&devicep->dev_env_lock);\n+  if (!devicep->is_initialized)\n+    gomp_init_device (devicep);\n+  gomp_mutex_unlock (&devicep->dev_env_lock);\n+\n+  gomp_update (devicep, mapnum, hostaddrs, sizes, kinds);\n }\n \n void\n@@ -94,3 +795,143 @@ GOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n     }\n   (void) num_teams;\n }\n+\n+#ifdef PLUGIN_SUPPORT\n+\n+/* This function tries to load a plugin for DEVICE.  Name of plugin is passed\n+   in PLUGIN_NAME.\n+   The handles of the found functions are stored in the corresponding fields\n+   of DEVICE.  The function returns TRUE on success and FALSE otherwise.  */\n+\n+static bool\n+gomp_load_plugin_for_device (struct gomp_device_descr *device,\n+\t\t\t     const char *plugin_name)\n+{\n+  void *plugin_handle = dlopen (plugin_name, RTLD_LAZY);\n+  if (!plugin_handle)\n+    return false;\n+\n+  /* Check if all required functions are available in the plugin and store\n+     their handlers.  */\n+#define DLSYM(f)\t\t\t\t\t\t    \\\n+  do\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t    \\\n+      device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\"#f);  \\\n+      if (!device->f##_func)\t\t\t\t\t    \\\n+\treturn false;\t\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t\t    \\\n+  while (0)\n+  DLSYM (get_type);\n+  DLSYM (get_num_devices);\n+  DLSYM (register_image);\n+  DLSYM (init_device);\n+  DLSYM (get_table);\n+  DLSYM (alloc);\n+  DLSYM (free);\n+  DLSYM (dev2host);\n+  DLSYM (host2dev);\n+  DLSYM (run);\n+#undef DLSYM\n+\n+  return true;\n+}\n+\n+/* This function finds OFFLOAD_IMAGES corresponding to DEVICE type, and\n+   registers them in the plugin.  */\n+\n+static void\n+gomp_register_images_for_device (struct gomp_device_descr *device)\n+{\n+  int i;\n+  for (i = 0; i < num_offload_images; i++)\n+    {\n+      struct offload_image_descr *image = &offload_images[i];\n+      if (image->type == device->type)\n+\tdevice->register_image_func (image->host_table, image->target_data);\n+    }\n+}\n+\n+/* This function initializes the runtime needed for offloading.\n+   It parses the list of offload targets and tries to load the plugins for these\n+   targets.  Result of the function is properly initialized variable NUM_DEVICES\n+   and array DEVICES, containing descriptors for corresponding devices.  */\n+\n+static void\n+gomp_target_init (void)\n+{\n+  const char *prefix =\"libgomp-plugin-\";\n+  const char *suffix = \".so.1\";\n+  const char *cur, *next;\n+  char *plugin_name;\n+  int i, new_num_devices;\n+\n+  num_devices = 0;\n+  devices = NULL;\n+\n+  cur = OFFLOAD_TARGETS;\n+  if (*cur)\n+    do\n+      {\n+\tstruct gomp_device_descr current_device;\n+\n+\tnext = strchr (cur, ',');\n+\n+\tplugin_name = (char *) malloc (1 + (next ? next - cur : strlen (cur))\n+\t\t\t\t       + strlen (prefix) + strlen (suffix));\n+\tif (!plugin_name)\n+\t  {\n+\t    num_devices = 0;\n+\t    break;\n+\t  }\n+\n+\tstrcpy (plugin_name, prefix);\n+\tstrncat (plugin_name, cur, next ? next - cur : strlen (cur));\n+\tstrcat (plugin_name, suffix);\n+\n+\tif (gomp_load_plugin_for_device (&current_device, plugin_name))\n+\t  {\n+\t    new_num_devices = current_device.get_num_devices_func ();\n+\t    if (new_num_devices >= 1)\n+\t      {\n+\t\tdevices = realloc (devices, (num_devices + new_num_devices)\n+\t\t\t\t   * sizeof (struct gomp_device_descr));\n+\t\tif (!devices)\n+\t\t  {\n+\t\t    num_devices = 0;\n+\t\t    free (plugin_name);\n+\t\t    break;\n+\t\t  }\n+\n+\t\tcurrent_device.type = current_device.get_type_func ();\n+\t\tcurrent_device.is_initialized = false;\n+\t\tcurrent_device.dev_splay_tree.root = NULL;\n+\t\tgomp_register_images_for_device (&current_device);\n+\t\tfor (i = 0; i < new_num_devices; i++)\n+\t\t  {\n+\t\t    current_device.id = num_devices + 1;\n+\t\t    current_device.target_id = i;\n+\t\t    devices[num_devices] = current_device;\n+\t\t    gomp_mutex_init (&devices[num_devices].dev_env_lock);\n+\t\t    num_devices++;\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tfree (plugin_name);\n+\tcur = next + 1;\n+      }\n+    while (next);\n+\n+  free (offload_images);\n+  offload_images = NULL;\n+  num_offload_images = 0;\n+}\n+\n+#else /* PLUGIN_SUPPORT */\n+/* If dlfcn.h is unavailable we always fallback to host execution.\n+   GOMP_target* routines are just stubs for this case.  */\n+static void\n+gomp_target_init (void)\n+{\n+}\n+#endif /* PLUGIN_SUPPORT */"}]}