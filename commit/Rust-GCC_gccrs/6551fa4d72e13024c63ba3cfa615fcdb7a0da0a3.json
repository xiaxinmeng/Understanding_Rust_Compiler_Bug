{"sha": "6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU1MWZhNGQ3MmUxMzAyNGM2M2JhM2NmYTYxNWZjZGI3YTBkYTBhMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-16T20:57:27Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-16T20:57:27Z"}, "message": "(group_insns): Delete.\n\n(emit_move_insn_1, expand_expr): Use emit_no_conflict_block\ninstead of group_insns.\n\nFrom-SVN: r6578", "tree": {"sha": "90fca649f5ee1e243580280f7d313a080a045a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90fca649f5ee1e243580280f7d313a080a045a1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3/comments", "author": null, "committer": null, "parents": [{"sha": "9316e820d01257e8550e581e89f2cbd7241a8f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9316e820d01257e8550e581e89f2cbd7241a8f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9316e820d01257e8550e581e89f2cbd7241a8f4a"}], "stats": {"total": 98, "additions": 40, "deletions": 58}, "files": [{"sha": "a336dd79104dd74d1ee32995bd05c33c9f30038f", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 58, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6551fa4d72e13024c63ba3cfa615fcdb7a0da0a3", "patch": "@@ -137,7 +137,6 @@ static void move_by_pieces\tPROTO((rtx, rtx, int, int));\n static int move_by_pieces_ninsns PROTO((unsigned int, int));\n static void move_by_pieces_1\tPROTO((rtx (*) (), enum machine_mode,\n \t\t\t\t       struct move_by_pieces *));\n-static void group_insns\t\tPROTO((rtx));\n static void store_constructor\tPROTO((tree, rtx));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n@@ -1674,31 +1673,6 @@ use_regs (regno, nregs)\n   for (i = 0; i < nregs; i++)\n     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, word_mode, regno + i)));\n }\n-\n-/* Mark the instructions since PREV as a libcall block.\n-   Add REG_LIBCALL to PREV and add a REG_RETVAL to the most recent insn.  */\n-\n-static void\n-group_insns (prev)\n-     rtx prev;\n-{\n-  rtx insn_first;\n-  rtx insn_last;\n-\n-  /* Find the instructions to mark */\n-  if (prev)\n-    insn_first = NEXT_INSN (prev);\n-  else\n-    insn_first = get_insns ();\n-\n-  insn_last = get_last_insn ();\n-\n-  REG_NOTES (insn_last) = gen_rtx (INSN_LIST, REG_RETVAL, insn_first,\n-\t\t\t\t   REG_NOTES (insn_last));\n-\n-  REG_NOTES (insn_first) = gen_rtx (INSN_LIST, REG_LIBCALL, insn_last,\n-\t\t\t\t    REG_NOTES (insn_first));\n-}\n \f\n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n@@ -1803,11 +1777,9 @@ emit_move_insn_1 (x, y)\n     {\n       /* Don't split destination if it is a stack push.  */\n       int stack = push_operand (x, GET_MODE (x));\n-      rtx prev = get_last_insn ();\n+      rtx insns;\n \n-      /* Tell flow that the whole of the destination is being set.  */\n-      if (GET_CODE (x) == REG)\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, x));\n+      start_sequence ();\n \n       /* If this is a stack, push the highpart first, so it\n \t will be in the argument order.\n@@ -1842,11 +1814,16 @@ emit_move_insn_1 (x, y)\n \t\t     (gen_imagpart (submode, x), gen_imagpart (submode, y)));\n \t}\n \n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      /* If X is a CONCAT, we got insns like RD = RS, ID = IS,\n+\t each with a separate pseudo as destination.\n+\t It's not correct for flow to treat them as a unit.  */\n       if (GET_CODE (x) != CONCAT)\n-\t/* If X is a CONCAT, we got insns like RD = RS, ID = IS,\n-\t   each with a separate pseudo as destination.\n-\t   It's not correct for flow to treat them as a unit.  */\n-\tgroup_insns (prev);\n+\temit_no_conflict_block (insns, x, y, NULL_RTX, NULL_RTX);\n+      else\n+\temit_insns (insns);\n \n       return get_last_insn ();\n     }\n@@ -1857,7 +1834,9 @@ emit_move_insn_1 (x, y)\n   else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     {\n       rtx last_insn = 0;\n-      rtx prev_insn = get_last_insn ();\n+      rtx insns;\n+      \n+      start_sequence ();\n \n       for (i = 0;\n \t   i < (GET_MODE_SIZE (mode)  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n@@ -1882,8 +1861,10 @@ emit_move_insn_1 (x, y)\n \n \t  last_insn = emit_move_insn (xpart, ypart);\n \t}\n-      /* Mark these insns as a libcall block.  */\n-      group_insns (prev_insn);\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_no_conflict_block (insns, x, y, NULL_RTX, NULL_RTX);\n \n       return last_insn;\n     }\n@@ -5845,8 +5826,7 @@ expand_expr (exp, target, tmode, modifier)\n     case COMPLEX_EXPR:\n       {\n \tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n-\n-\trtx prev;\n+\trtx insns;\n \n \t/* Get the rtx code of the operands.  */\n \top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n@@ -5855,22 +5835,23 @@ expand_expr (exp, target, tmode, modifier)\n \tif (! target)\n \t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \n-\tprev = get_last_insn ();\n-\n-\t/* Tell flow that the whole of the destination is being set.  */\n-\tif (GET_CODE (target) == REG)\n-\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\tstart_sequence ();\n \n \t/* Move the real (op0) and imaginary (op1) parts to their location.  */\n \temit_move_insn (gen_realpart (mode, target), op0);\n \temit_move_insn (gen_imagpart (mode, target), op1);\n \n+\tinsns = get_insns ();\n+\tend_sequence ();\n+\n \t/* Complex construction should appear as a single unit.  */\n+\t/* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS,\n+\t   each with a separate pseudo as destination.\n+\t   It's not correct for flow to treat them as a unit.  */\n \tif (GET_CODE (target) != CONCAT)\n-\t  /* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS,\n-\t     each with a separate pseudo as destination.\n-\t     It's not correct for flow to treat them as a unit.  */\n-\t  group_insns (prev);\n+\t  emit_no_conflict_block (insns, target, op0, op1, NULL_RTX);\n+\telse\n+\t  emit_insns (insns);\n \n \treturn target;\n       }\n@@ -5887,18 +5868,14 @@ expand_expr (exp, target, tmode, modifier)\n       {\n \tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \trtx imag_t;\n-\trtx prev;\n+\trtx insns;\n \t\n \top0  = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n \n \tif (! target)\n \t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \t\t\t\t\t\t\t\t    \n-\tprev = get_last_insn ();\n-\n-\t/* Tell flow that the whole of the destination is being set.  */\n-\tif (GET_CODE (target) == REG)\n-\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\tstart_sequence ();\n \n \t/* Store the realpart and the negated imagpart to target.  */\n \temit_move_insn (gen_realpart (mode, target), gen_realpart (mode, op0));\n@@ -5909,12 +5886,17 @@ expand_expr (exp, target, tmode, modifier)\n \tif (temp != imag_t)\n \t  emit_move_insn (imag_t, temp);\n \n+\tinsns = get_insns ();\n+\tend_sequence ();\n+\n \t/* Conjugate should appear as a single unit */\n+\t/* If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n+\t   each with a separate pseudo as destination.\n+\t   It's not correct for flow to treat them as a unit.  */\n \tif (GET_CODE (target) != CONCAT)\n-\t  /* If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n-\t     each with a separate pseudo as destination.\n-\t     It's not correct for flow to treat them as a unit.  */\n-\t  group_insns (prev);\n+\t  emit_no_conflict_block (insns, target, op0, NULL_RTX, NULL_RTX);\n+\telse\n+\t  emit_insns (insns);\n \n \treturn target;\n       }"}]}