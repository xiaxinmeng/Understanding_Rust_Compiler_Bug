{"sha": "85ebc1938f831130e98e8b0865cb172487254818", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVlYmMxOTM4ZjgzMTEzMGU5OGU4YjA4NjVjYjE3MjQ4NzI1NDgxOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-04-28T07:26:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-04-28T07:26:41Z"}, "message": "re PR c++/65851 (ice in set_lattice_value at tree-ssa-cc p.c:535)\n\n2015-04-28  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/65851\n\t* tree-ssa-ccp.c (set_lattice_value): Perform a meet when\n\tchanging CONSTANT to CONSTANT non-copy.  Get new_val by reference.\n\t(ccp_lattice_meet): Remove stray argument.  Use operand_equal_p\n\trather than simple_cst_equal as the latter doesn't handle COMPLEX_CST.\n\t(ccp_visit_phi_node): Adjust.\n\t(evaluate_stmt): For simplifications to SSA names return its\n\tlattice value if that isn't VARYING.  Return immediately when\n\tsimplified to a constant.\n\t(visit_assignment): Adjust.\n\t(ccp_visit_stmt): Likewise.\n\n\t* g++.dg/torture/pr65851.C: New testcase.\n\nFrom-SVN: r222510", "tree": {"sha": "b1f8fc210896c895aad096222e3fc7480d565c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f8fc210896c895aad096222e3fc7480d565c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85ebc1938f831130e98e8b0865cb172487254818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ebc1938f831130e98e8b0865cb172487254818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ebc1938f831130e98e8b0865cb172487254818", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ebc1938f831130e98e8b0865cb172487254818/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a66dfffdb8946993ee06fe1ec9fdc3cbda5d96c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a66dfffdb8946993ee06fe1ec9fdc3cbda5d96c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a66dfffdb8946993ee06fe1ec9fdc3cbda5d96c6"}], "stats": {"total": 134, "additions": 97, "deletions": 37}, "files": [{"sha": "5677eba648c1bdd7b60e115f19f12d2ad4627c57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebc1938f831130e98e8b0865cb172487254818/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebc1938f831130e98e8b0865cb172487254818/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85ebc1938f831130e98e8b0865cb172487254818", "patch": "@@ -1,3 +1,17 @@\n+2015-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65851\n+\t* tree-ssa-ccp.c (set_lattice_value): Perform a meet when\n+\tchanging CONSTANT to CONSTANT non-copy.  Get new_val by reference.\n+\t(ccp_lattice_meet): Remove stray argument.  Use operand_equal_p\n+\trather than simple_cst_equal as the latter doesn't handle COMPLEX_CST.\n+\t(ccp_visit_phi_node): Adjust.\n+\t(evaluate_stmt): For simplifications to SSA names return its\n+\tlattice value if that isn't VARYING.  Return immediately when\n+\tsimplified to a constant.\n+\t(visit_assignment): Adjust.\n+\t(ccp_visit_stmt): Likewise.\n+\n 2015-04-28  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/65818"}, {"sha": "f9cce49d453d8f12dfb94434ebb848516224d2ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85ebc1938f831130e98e8b0865cb172487254818", "patch": "@@ -1,3 +1,8 @@\n+2015-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65851\n+\t* g++.dg/torture/pr65851.C: New testcase.\n+\n 2015-04-27  Jeff Law <law@redhat.com>\n \n         PR tree-optimization/65217"}, {"sha": "6efe8861a195f6ceb5cf2d26faee8380435bafc2", "filename": "gcc/testsuite/g++.dg/torture/pr65851.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr65851.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr65851.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr65851.C?ref=85ebc1938f831130e98e8b0865cb172487254818", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+class A {\n+  virtual unsigned long write(const char *, unsigned long);\n+};\n+char *a;\n+int b;\n+bool c;\n+char e[16];\n+class B {\n+public:\n+  void push_range(const char *);\n+};\n+class C : A {\n+  B m_string;\n+\n+public:\n+  unsigned long write(const char *p1, unsigned long p2) {\n+    m_string.push_range(p1 + p2);\n+  }\n+};\n+char *write_signed_decimal_backward(bool) {\n+  char *d = 0;\n+  if (b) {\n+    if (c)\n+      --a;\n+    d = a;\n+  }\n+  return d;\n+}\n+\n+template <typename TextOutputStreamType>\n+void ostream_write(TextOutputStreamType &p1) {\n+  char *f = write_signed_decimal_backward(false);\n+  p1.write(f, e - f);\n+}\n+\n+void operator<<(C p1, int) { ostream_write(p1); }"}, {"sha": "ebd493d50e78684e48d6bd647339c244464f1573", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ebc1938f831130e98e8b0865cb172487254818/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=85ebc1938f831130e98e8b0865cb172487254818", "patch": "@@ -208,6 +208,7 @@ static unsigned n_const_val;\n \n static void canonicalize_value (ccp_prop_value_t *);\n static bool ccp_fold_stmt (gimple_stmt_iterator *);\n+static void ccp_lattice_meet (ccp_prop_value_t *, ccp_prop_value_t *);\n \n /* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n \n@@ -512,54 +513,51 @@ valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n    value is different from VAR's previous value.  */\n \n static bool\n-set_lattice_value (tree var, ccp_prop_value_t new_val)\n+set_lattice_value (tree var, ccp_prop_value_t *new_val)\n {\n   /* We can deal with old UNINITIALIZED values just fine here.  */\n   ccp_prop_value_t *old_val = &const_val[SSA_NAME_VERSION (var)];\n \n-  canonicalize_value (&new_val);\n+  canonicalize_value (new_val);\n \n   /* We have to be careful to not go up the bitwise lattice\n-     represented by the mask.\n-     ???  This doesn't seem to be the best place to enforce this.  */\n-  if (new_val.lattice_val == CONSTANT\n+     represented by the mask.  Instead of dropping to VARYING\n+     use the meet operator to retain a conservative value.\n+     Missed optimizations like PR65851 makes this necessary.\n+     It also ensures we converge to a stable lattice solution.  */\n+  if (new_val->lattice_val == CONSTANT\n       && old_val->lattice_val == CONSTANT\n-      && TREE_CODE (new_val.value) == INTEGER_CST\n-      && TREE_CODE (old_val->value) == INTEGER_CST)\n-    {\n-      widest_int diff = (wi::to_widest (new_val.value)\n-\t\t\t ^ wi::to_widest (old_val->value));\n-      new_val.mask = new_val.mask | old_val->mask | diff;\n-    }\n+      && TREE_CODE (new_val->value) != SSA_NAME)\n+    ccp_lattice_meet (new_val, old_val);\n \n-  gcc_checking_assert (valid_lattice_transition (*old_val, new_val));\n+  gcc_checking_assert (valid_lattice_transition (*old_val, *new_val));\n \n   /* If *OLD_VAL and NEW_VAL are the same, return false to inform the\n      caller that this was a non-transition.  */\n-  if (old_val->lattice_val != new_val.lattice_val\n-      || (new_val.lattice_val == CONSTANT\n-\t  && (TREE_CODE (new_val.value) != TREE_CODE (old_val->value)\n-\t      || (TREE_CODE (new_val.value) == INTEGER_CST\n-\t\t  && (new_val.mask != old_val->mask\n+  if (old_val->lattice_val != new_val->lattice_val\n+      || (new_val->lattice_val == CONSTANT\n+\t  && (TREE_CODE (new_val->value) != TREE_CODE (old_val->value)\n+\t      || (TREE_CODE (new_val->value) == INTEGER_CST\n+\t\t  && (new_val->mask != old_val->mask\n \t\t      || (wi::bit_and_not (wi::to_widest (old_val->value),\n-\t\t\t\t\t   new_val.mask)\n-\t\t\t  != wi::bit_and_not (wi::to_widest (new_val.value),\n-\t\t\t\t\t      new_val.mask))))\n-\t      || (TREE_CODE (new_val.value) != INTEGER_CST\n-\t\t  && !operand_equal_p (new_val.value, old_val->value, 0)))))\n+\t\t\t\t\t   new_val->mask)\n+\t\t\t  != wi::bit_and_not (wi::to_widest (new_val->value),\n+\t\t\t\t\t      new_val->mask))))\n+\t      || (TREE_CODE (new_val->value) != INTEGER_CST\n+\t\t  && !operand_equal_p (new_val->value, old_val->value, 0)))))\n     {\n       /* ???  We would like to delay creation of INTEGER_CSTs from\n \t partially constants here.  */\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  dump_lattice_value (dump_file, \"Lattice value changed to \", new_val);\n+\t  dump_lattice_value (dump_file, \"Lattice value changed to \", *new_val);\n \t  fprintf (dump_file, \".  Adding SSA edges to worklist.\\n\");\n \t}\n \n-      *old_val = new_val;\n+      *old_val = *new_val;\n \n-      gcc_assert (new_val.lattice_val != UNINITIALIZED);\n+      gcc_assert (new_val->lattice_val != UNINITIALIZED);\n       return true;\n     }\n \n@@ -991,8 +989,7 @@ ccp_finalize (void)\n    */\n \n static void\n-ccp_lattice_meet (basic_block where,\n-\t\t  ccp_prop_value_t *val1, ccp_prop_value_t *val2)\n+ccp_lattice_meet (ccp_prop_value_t *val1, ccp_prop_value_t *val2)\n {\n   if (val1->lattice_val == UNDEFINED\n       /* For UNDEFINED M SSA we can't always SSA because its definition\n@@ -1042,7 +1039,7 @@ ccp_lattice_meet (basic_block where,\n     }\n   else if (val1->lattice_val == CONSTANT\n \t   && val2->lattice_val == CONSTANT\n-\t   && simple_cst_equal (val1->value, val2->value) == 1)\n+\t   && operand_equal_p (val1->value, val2->value, 0))\n     {\n       /* Ci M Cj = Ci\t\tif (i == j)\n \t Ci M Cj = VARYING\tif (i != j)\n@@ -1061,7 +1058,7 @@ ccp_lattice_meet (basic_block where,\n \t*val1 = get_value_for_expr (val1->value, true);\n       if (TREE_CODE (val2->value) == ADDR_EXPR)\n \ttem = get_value_for_expr (val2->value, true);\n-      ccp_lattice_meet (where, val1, &tem);\n+      ccp_lattice_meet (val1, &tem);\n     }\n   else\n     {\n@@ -1122,7 +1119,7 @@ ccp_visit_phi_node (gphi *phi)\n \t      first = false;\n \t    }\n \t  else\n-\t    ccp_lattice_meet (gimple_bb (phi), &new_val, &arg_val);\n+\t    ccp_lattice_meet (&new_val, &arg_val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1144,7 +1141,7 @@ ccp_visit_phi_node (gphi *phi)\n     }\n \n   /* Make the transition to the new value.  */\n-  if (set_lattice_value (gimple_phi_result (phi), new_val))\n+  if (set_lattice_value (gimple_phi_result (phi), &new_val))\n     {\n       if (new_val.lattice_val == VARYING)\n \treturn SSA_PROP_VARYING;\n@@ -1745,6 +1742,15 @@ evaluate_stmt (gimple stmt)\n     {\n       fold_defer_overflow_warnings ();\n       simplified = ccp_fold (stmt);\n+      if (simplified && TREE_CODE (simplified) == SSA_NAME)\n+\t{\n+\t  val = *get_value (simplified);\n+\t  if (val.lattice_val != VARYING)\n+\t    {\n+\t      fold_undefer_overflow_warnings (true, stmt, 0);\n+\t      return val;\n+\t    }\n+\t}\n       is_constant = simplified && is_gimple_min_invariant (simplified);\n       fold_undefer_overflow_warnings (is_constant, stmt, 0);\n       if (is_constant)\n@@ -1753,6 +1759,7 @@ evaluate_stmt (gimple stmt)\n \t  val.lattice_val = CONSTANT;\n \t  val.value = simplified;\n \t  val.mask = 0;\n+\t  return val;\n \t}\n     }\n   /* If the statement is likely to have a VARYING result, then do not\n@@ -2293,7 +2300,7 @@ visit_assignment (gimple stmt, tree *output_p)\n \n       /* If STMT is an assignment to an SSA_NAME, we only have one\n \t value to set.  */\n-      if (set_lattice_value (lhs, val))\n+      if (set_lattice_value (lhs, &val))\n \t{\n \t  *output_p = lhs;\n \t  if (val.lattice_val == VARYING)\n@@ -2391,10 +2398,7 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n      SSA_NAMEs represent unknown modifications to their outputs.\n      Mark them VARYING.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      ccp_prop_value_t v = { VARYING, NULL_TREE, -1 };\n-      set_lattice_value (def, v);\n-    }\n+    set_value_varying (def);\n \n   return SSA_PROP_VARYING;\n }"}]}