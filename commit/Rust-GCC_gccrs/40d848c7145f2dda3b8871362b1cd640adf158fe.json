{"sha": "40d848c7145f2dda3b8871362b1cd640adf158fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBkODQ4YzcxNDVmMmRkYTNiODg3MTM2MmIxY2Q2NDBhZGYxNThmZQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-02T05:25:46Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-02T05:25:46Z"}, "message": "re PR target/52898 (SH Target: Inefficient DImode comparisons)\n\ngcc/\n\tPR target/52898\n\t* config/sh/sh.c (sh_option_override): Remove TARGET_CBRANCHDI4,\n\tTARGET_CMPEQDI_T.\n\t(prepare_cbranch_operands): Don't use scratch register.  Assume that\n\tfunction is used when pseudos can be created.\n\t(expand_cbranchdi4): Likewise.  Remove unused TARGET_CMPEQDI_T paths.\n\t* config/sh/sh.md (cbranchsi4): Allow only when pseudos can be created.\n\t(cbranchdi4, cbranchdi4_i): Simplify to single cbranchdi4\n\tdefine_expand.  Allow it only when pseudos can be created.\n\t* config/sh/sh.opt (mcbranchdi, mcmpeqdi): Delete.\n\nFrom-SVN: r235698", "tree": {"sha": "478b791eadd3cc9b945434b9b5cebe57697c6e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/478b791eadd3cc9b945434b9b5cebe57697c6e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40d848c7145f2dda3b8871362b1cd640adf158fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d848c7145f2dda3b8871362b1cd640adf158fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40d848c7145f2dda3b8871362b1cd640adf158fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d848c7145f2dda3b8871362b1cd640adf158fe/comments", "author": null, "committer": null, "parents": [{"sha": "126fa2bb01d775d8023d233c7a587fcfa6067c4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/126fa2bb01d775d8023d233c7a587fcfa6067c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/126fa2bb01d775d8023d233c7a587fcfa6067c4f"}], "stats": {"total": 141, "additions": 26, "deletions": 115}, "files": [{"sha": "e88ca467c5966d667fae80dfc89e7e2762d5f645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40d848c7145f2dda3b8871362b1cd640adf158fe", "patch": "@@ -1,3 +1,16 @@\n+2016-05-02  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/52898\n+\t* config/sh/sh.c (sh_option_override): Remove TARGET_CBRANCHDI4,\n+\tTARGET_CMPEQDI_T.\n+\t(prepare_cbranch_operands): Don't use scratch register.  Assume that\n+\tfunction is used when pseudos can be created.\n+\t(expand_cbranchdi4): Likewise.  Remove unused TARGET_CMPEQDI_T paths.\n+\t* config/sh/sh.md (cbranchsi4): Allow only when pseudos can be created.\n+\t(cbranchdi4, cbranchdi4_i): Simplify to single cbranchdi4\n+\tdefine_expand.  Allow it only when pseudos can be created.\n+\t* config/sh/sh.opt (mcbranchdi, mcmpeqdi): Delete.\n+\n 2016-05-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/constraints.md (BC): Only allow -1 operands."}, {"sha": "ebdb523cd17ab10598a91ada192e3ddab6df1117", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 65, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=40d848c7145f2dda3b8871362b1cd640adf158fe", "patch": "@@ -809,10 +809,6 @@ sh_option_override (void)\n   if (optimize > 1 && !optimize_size)\n     target_flags |= MASK_SAVE_ALL_TARGET_REGS;\n \n-  /* Set default values of TARGET_CBRANCHDI4 and TARGET_CMPEQDI_T.  */\n-  TARGET_CBRANCHDI4 = 1;\n-  TARGET_CMPEQDI_T = 0;\n-\n   sh_cpu = PROCESSOR_SH1;\n   assembler_dialect = 0;\n   if (TARGET_SH2)\n@@ -1936,24 +1932,17 @@ enum rtx_code\n prepare_cbranch_operands (rtx *operands, machine_mode mode,\n \t\t\t  enum rtx_code comparison)\n {\n-  /* The scratch reg is only available when this is invoked from within\n-     the cbranchdi4_i splitter, through expand_cbranchdi4.  */\n-  rtx scratch = NULL_RTX;\n+  gcc_assert (can_create_pseudo_p ());\n \n   if (comparison == LAST_AND_UNUSED_RTX_CODE)\n     comparison = GET_CODE (operands[0]);\n-  else\n-    scratch = operands[4];\n \n   sh_canonicalize_comparison (comparison, operands[1], operands[2],\n \t\t\t      mode, false);\n \n-  /* Notice that this function is also invoked after reload by\n-     the cbranchdi4_i pattern, through expand_cbranchdi4.  */\n   rtx op1 = operands[1];\n+  operands[1] = force_reg (mode, op1);\n \n-  if (can_create_pseudo_p ())\n-    operands[1] = force_reg (mode, op1);\n   /* When we are handling DImode comparisons, we want to keep constants so\n      that we can optimize the component comparisons; however, memory loads\n      are better issued as a whole so that they can be scheduled well.\n@@ -1969,15 +1958,8 @@ prepare_cbranch_operands (rtx *operands, machine_mode mode,\n \t      && ((comparison != EQ && comparison != NE)\n \t\t  || (REG_P (op1) && REGNO (op1) != R0_REG)\n \t\t  || !satisfies_constraint_I08 (operands[2])))))\n-    {\n-      if (scratch && GET_MODE (scratch) == mode)\n-\t{\n-\t  emit_move_insn (scratch, operands[2]);\n-\t  operands[2] = scratch;\n-\t}\n-      else if (can_create_pseudo_p ())\n-\toperands[2] = force_reg (mode, operands[2]);\n-    }\n+    operands[2] = force_reg (mode, operands[2]);\n+\n   return comparison;\n }\n \n@@ -2027,7 +2009,6 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   int num_branches;\n   int prob, rev_prob;\n   int msw_taken_prob = -1, msw_skip_prob = -1, lsw_taken_prob = -1;\n-  rtx scratch = operands[4];\n \n   comparison = prepare_cbranch_operands (operands, DImode, comparison);\n   op1h = gen_highpart_mode (SImode, DImode, operands[1]);\n@@ -2039,17 +2020,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   rev_prob = REG_BR_PROB_BASE - prob;\n   switch (comparison)\n     {\n-    /* ??? Should we use the cmpeqdi_t pattern for equality comparisons?\n-       That costs 1 cycle more when the first branch can be predicted taken,\n-       but saves us mispredicts because only one branch needs prediction.\n-       It also enables generating the cmpeqdi_t-1 pattern.  */\n     case EQ:\n-      if (TARGET_CMPEQDI_T)\n-\t{\n-\t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n-\t  emit_jump_insn (gen_branch_true (operands[3]));\n-\t  return true;\n-\t}\n       msw_skip = NE;\n       lsw_taken = EQ;\n       if (prob >= 0)\n@@ -2070,12 +2041,6 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n \t}\n       break;\n     case NE:\n-      if (TARGET_CMPEQDI_T)\n-\t{\n-\t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n-\t  emit_jump_insn (gen_branch_false (operands[3]));\n-\t  return true;\n-\t}\n       msw_taken = NE;\n       msw_taken_prob = prob;\n       lsw_taken = NE;\n@@ -2152,15 +2117,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   operands[1] = op1h;\n   operands[2] = op2h;\n   operands[4] = NULL_RTX;\n-  if (reload_completed\n-      && ! arith_reg_or_0_operand (op2h, SImode)\n-      && (true_regnum (op1h) || (comparison != EQ && comparison != NE))\n-      && (msw_taken != LAST_AND_UNUSED_RTX_CODE\n-\t  || msw_skip != LAST_AND_UNUSED_RTX_CODE))\n-    {\n-      emit_move_insn (scratch, operands[2]);\n-      operands[2] = scratch;\n-    }\n+\n   if (msw_taken != LAST_AND_UNUSED_RTX_CODE)\n     expand_cbranchsi4 (operands, msw_taken, msw_taken_prob);\n   if (msw_skip != LAST_AND_UNUSED_RTX_CODE)\n@@ -2173,13 +2130,6 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n \t{\n \t  operands[1] = op1h;\n \t  operands[2] = op2h;\n-\t  if (reload_completed\n-\t      && ! arith_reg_or_0_operand (op2h, SImode)\n-\t      && (true_regnum (op1h) || (comparison != EQ && comparison != NE)))\n-\t    {\n-\t      emit_move_insn (scratch, operands[2]);\n-\t      operands[2] = scratch;\n-\t    }\n \t}\n \n       operands[3] = skip_label = gen_label_rtx ();\n@@ -2189,16 +2139,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   operands[1] = op1l;\n   operands[2] = op2l;\n   if (lsw_taken != LAST_AND_UNUSED_RTX_CODE)\n-    {\n-      if (reload_completed\n-\t  && ! arith_reg_or_0_operand (op2l, SImode)\n-\t  && (true_regnum (op1l) || (lsw_taken != EQ && lsw_taken != NE)))\n-\t{\n-\t  emit_move_insn (scratch, operands[2]);\n-\t  operands[2] = scratch;\n-\t}\n-      expand_cbranchsi4 (operands, lsw_taken, lsw_taken_prob);\n-    }\n+    expand_cbranchsi4 (operands, lsw_taken, lsw_taken_prob);\n   if (msw_skip != LAST_AND_UNUSED_RTX_CODE)\n     emit_label (skip_label);\n   return true;"}, {"sha": "af46acc78180262eb68b74bd87d40b389633c9e0", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=40d848c7145f2dda3b8871362b1cd640adf158fe", "patch": "@@ -1115,7 +1115,7 @@\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))\n    (clobber (reg:SI T_REG))]\n-  \"\"\n+  \"can_create_pseudo_p ()\"\n {\n   expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1);\n   DONE;\n@@ -1161,7 +1161,8 @@\n \t\t\t   (label_ref (match_dup 2))\n \t\t\t   (pc)))])\n \n-;; FIXME: These could probably use code iterators for the compare op.\n+;; FIXME: These don't seem to have any effect on the generated cbranch code\n+;;\t  anymore, but only on some register allocation choices.\n (define_split\n   [(set (pc)\n \t(if_then_else (le (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -1255,48 +1256,12 @@\n (define_expand \"cbranchdi4\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand:DI 1 \"arith_operand\" \"\")\n-\t\t\t (match_operand:DI 2 \"arith_operand\" \"\")])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))\n-   (clobber (match_dup 4))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_CBRANCHDI4 || TARGET_SH2\"\n-{\n-  enum rtx_code comparison;\n-\n-  if (!TARGET_CBRANCHDI4)\n-    {\n-      sh_emit_compare_and_branch (operands, DImode);\n-      DONE;\n-    }\n-  else\n-    {\n-      if (expand_cbranchdi4 (operands, LAST_AND_UNUSED_RTX_CODE))\n-\tDONE;\n-\n-      comparison = prepare_cbranch_operands (operands, DImode,\n-\t\t\t\t\t     LAST_AND_UNUSED_RTX_CODE);\n-      if (comparison != GET_CODE (operands[0]))\n-\toperands[0]\n-\t  = gen_rtx_fmt_ee (comparison, VOIDmode, operands[1], operands[2]);\n-       operands[4] = gen_rtx_SCRATCH (SImode);\n-    }\n-})\n-\n-(define_insn_and_split \"cbranchdi4_i\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand:DI 1 \"arith_operand\" \"r,r\")\n-\t\t\t (match_operand:DI 2 \"arith_operand\" \"rN,I08\")])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t\t[(match_operand:DI 1 \"arith_operand\")\n+\t\t\t (match_operand:DI 2 \"arith_operand\")])\n+\t\t      (label_ref (match_operand 3))\n \t\t      (pc)))\n-   (clobber (match_scratch:SI 4 \"=X,&r\"))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_CBRANCHDI4\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n+  \"TARGET_SH2 && can_create_pseudo_p ()\"\n {\n   if (!expand_cbranchdi4 (operands, GET_CODE (operands[0])))\n     FAIL;"}, {"sha": "f9b02c520cbed5373976004a34eaa62d7bcae727", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d848c7145f2dda3b8871362b1cd640adf158fe/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=40d848c7145f2dda3b8871362b1cd640adf158fe", "patch": "@@ -205,14 +205,6 @@ mzdcbranch\n Target Report Var(TARGET_ZDCBRANCH)\n Assume that zero displacement conditional branches are fast.\n \n-mcbranchdi\n-Target Undocumented Var(TARGET_CBRANCHDI4) Warn(%qs is deprecated and has no effect)\n-Enable cbranchdi4 pattern.\n-\n-mcmpeqdi\n-Target Undocumented Var(TARGET_CMPEQDI_T) Warn(%qs is deprecated and has no effect)\n-Emit cmpeqdi_t pattern even when -mcbranchdi is in effect.\n-\n mcbranch-force-delay-slot\n Target Report RejectNegative Var(TARGET_CBRANCH_FORCE_DELAY_SLOT) Init(0)\n Force the usage of delay slots for conditional branches."}]}