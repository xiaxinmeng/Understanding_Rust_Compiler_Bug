{"sha": "d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyOWUwNThmMmRlMDhhYTUyYjY4ZTk3YmM3YWUxM2MwZGJjYmUzOQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-22T15:03:27Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-22T15:03:27Z"}, "message": "caller-save.c: Convert to ISO C90.\n\n\t* caller-save.c: Convert to ISO C90.\n\t* calls.c: Likewise.\n\t* cfg.c: Likewise.\n\t* cfganal.c: Likewise.\n\t* cfgbuild.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfghooks.c: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfglayout.h: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgloop.h: Likewise.\n\t* cfgloopanal.c: Likewise.\n\t* cfgloopmainip.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\nFrom-SVN: r68331", "tree": {"sha": "1c9f6bed6ad2463273501c132977d557fd474433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c9f6bed6ad2463273501c132977d557fd474433"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "84edd42cd48594dfe92b87af25e214ccd15d300d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84edd42cd48594dfe92b87af25e214ccd15d300d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84edd42cd48594dfe92b87af25e214ccd15d300d"}], "stats": {"total": 1831, "additions": 656, "deletions": 1175}, "files": [{"sha": "9224fb1d852b10cd5af8b446146bbcd5052710d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,3 +1,20 @@\n+2003-06-22  Andreas Jaeger  <aj@suse.de>\n+\n+\t* caller-save.c: Convert to ISO C90.\n+\t* calls.c: Likewise.\n+\t* cfg.c: Likewise.\n+\t* cfganal.c: Likewise.\n+\t* cfgbuild.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfghooks.c: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfglayout.h: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* cfgloopanal.c: Likewise.\n+\t* cfgloopmainip.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\n 2003-06-22  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (BIGGEST_ALIGNMENT): Use TARGET_REALLY_IWMMXT for selecting"}, {"sha": "689f4f8b22a967955623231e4484d0966ee172bc", "filename": "gcc/caller-save.c", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,6 +1,6 @@\n /* Save and restore call-clobbered registers which are live across a call.\n    Copyright (C) 1989, 1992, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -51,13 +51,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    register because it is live we first try to save in multi-register modes.\n    If that is not possible the save is done one register at a time.  */\n \n-static enum machine_mode \n+static enum machine_mode\n   regno_save_mode[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n \n /* For each hard register, a place on the stack where it can be saved,\n    if needed.  */\n \n-static rtx \n+static rtx\n   regno_save_mem[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n \n /* We will only make a register eligible for caller-save if it can be\n@@ -68,7 +68,7 @@ static rtx\n \n static int\n   reg_save_code[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n-static int \n+static int\n   reg_restore_code[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n \n /* Set of hard regs currently residing in save area (during insn scan).  */\n@@ -88,29 +88,28 @@ static HARD_REG_SET referenced_regs;\n static HARD_REG_SET this_insn_sets;\n \n \n-static void mark_set_regs\t\tPARAMS ((rtx, rtx, void *));\n-static void mark_referenced_regs\tPARAMS ((rtx));\n-static int insert_save\t\t\tPARAMS ((struct insn_chain *, int, int,\n-\t\t\t\t\t\t HARD_REG_SET *,\n-\t\t\t\t\t\t enum machine_mode *));\n-static int insert_restore\t\tPARAMS ((struct insn_chain *, int, int,\n-\t\t\t\t\t\t int, enum machine_mode *));\n-static struct insn_chain *insert_one_insn PARAMS ((struct insn_chain *, int,\n-\t\t\t\t\t\t   int, rtx));\n-static void add_stored_regs\t\tPARAMS ((rtx, rtx, void *));\n+static void mark_set_regs (rtx, rtx, void *);\n+static void mark_referenced_regs (rtx);\n+static int insert_save (struct insn_chain *, int, int, HARD_REG_SET *,\n+\t\t\tenum machine_mode *);\n+static int insert_restore (struct insn_chain *, int, int, int,\n+\t\t\t   enum machine_mode *);\n+static struct insn_chain *insert_one_insn (struct insn_chain *, int, int,\n+\t\t\t\t\t   rtx);\n+static void add_stored_regs (rtx, rtx, void *);\n \f\n /* Initialize for caller-save.\n \n    Look at all the hard registers that are used by a call and for which\n    regclass.c has not already excluded from being used across a call.\n \n-   Ensure that we can find a mode to save the register and that there is a \n+   Ensure that we can find a mode to save the register and that there is a\n    simple insn to save and restore the register.  This latter check avoids\n    problems that would occur if we tried to save the MQ register of some\n    machines directly into memory.  */\n \n void\n-init_caller_save ()\n+init_caller_save (void)\n {\n   rtx addr_reg;\n   int offset;\n@@ -184,7 +183,7 @@ init_caller_save ()\n     address = addr_reg;\n \n   /* Next we try to form an insn to save and restore the register.  We\n-     see if such an insn is recognized and meets its constraints. \n+     see if such an insn is recognized and meets its constraints.\n \n      To avoid lots of unnecessary RTL allocation, we construct all the RTL\n      once, then modify the memory and register operands in-place.  */\n@@ -256,7 +255,7 @@ init_caller_save ()\n /* Initialize save areas by showing that we haven't allocated any yet.  */\n \n void\n-init_save_areas ()\n+init_save_areas (void)\n {\n   int i, j;\n \n@@ -274,17 +273,17 @@ init_save_areas ()\n    Future work:\n \n      In the fallback case we should iterate backwards across all possible\n-     modes for the save, choosing the largest available one instead of \n+     modes for the save, choosing the largest available one instead of\n      falling back to the smallest mode immediately.  (eg TF -> DF -> SF).\n \n      We do not try to use \"move multiple\" instructions that exist\n-     on some machines (such as the 68k moveml).  It could be a win to try \n+     on some machines (such as the 68k moveml).  It could be a win to try\n      and use them when possible.  The hard part is doing it in a way that is\n-     machine independent since they might be saving non-consecutive \n+     machine independent since they might be saving non-consecutive\n      registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */\n \n void\n-setup_save_areas ()\n+setup_save_areas (void)\n {\n   int i, j, k;\n   unsigned int r;\n@@ -300,7 +299,7 @@ setup_save_areas ()\n     if (reg_renumber[i] >= 0 && REG_N_CALLS_CROSSED (i) > 0)\n       {\n \tunsigned int regno = reg_renumber[i];\n-\tunsigned int endregno \n+\tunsigned int endregno\n \t  = regno + HARD_REGNO_NREGS (regno, GET_MODE (regno_reg_rtx[i]));\n \n \tfor (r = regno; r < endregno; r++)\n@@ -367,7 +366,7 @@ setup_save_areas ()\n /* Find the places where hard regs are live across calls and save them.  */\n \n void\n-save_call_clobbered_regs ()\n+save_call_clobbered_regs (void)\n {\n   struct insn_chain *chain, *next;\n   enum machine_mode save_mode [FIRST_PSEUDO_REGISTER];\n@@ -488,18 +487,16 @@ save_call_clobbered_regs ()\n \t\tregno += insert_restore (chain, GET_CODE (insn) == JUMP_INSN,\n \t\t\t\t\t regno, MOVE_MAX_WORDS, save_mode);\n \t}\n-    }  \n+    }\n }\n \n /* Here from note_stores when an insn stores a value in a register.\n    Set the proper bit or bits in this_insn_sets.  All pseudos that have\n    been assigned hard regs have had their register number changed already,\n    so we can ignore pseudos.  */\n static void\n-mark_set_regs (reg, setter, data)\n-     rtx reg;\n-     rtx setter ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_set_regs (rtx reg, rtx setter ATTRIBUTE_UNUSED,\n+\t       void *data ATTRIBUTE_UNUSED)\n {\n   int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n@@ -529,10 +526,7 @@ mark_set_regs (reg, setter, data)\n    been assigned hard regs have had their register number changed already,\n    so we can ignore pseudos.  */\n static void\n-add_stored_regs (reg, setter, data)\n-     rtx reg;\n-     rtx setter;\n-     void *data;\n+add_stored_regs (rtx reg, rtx setter, void *data)\n {\n   int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n@@ -562,8 +556,7 @@ add_stored_regs (reg, setter, data)\n \n /* Walk X and record all referenced registers in REFERENCED_REGS.  */\n static void\n-mark_referenced_regs (x)\n-     rtx x;\n+mark_referenced_regs (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n@@ -639,12 +632,8 @@ mark_referenced_regs (x)\n    Return the extra number of registers saved.  */\n \n static int\n-insert_restore (chain, before_p, regno, maxrestore, save_mode)\n-     struct insn_chain *chain;\n-     int before_p;\n-     int regno;\n-     int maxrestore;\n-     enum machine_mode *save_mode;\n+insert_restore (struct insn_chain *chain, int before_p, int regno,\n+\t\tint maxrestore, enum machine_mode *save_mode)\n {\n   int i, k;\n   rtx pat = NULL_RTX;\n@@ -695,7 +684,7 @@ insert_restore (chain, before_p, regno, maxrestore, save_mode)\n       && numregs == (unsigned int) HARD_REGNO_NREGS (regno, save_mode [regno]))\n     mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_REG (GET_MODE (mem), \n+\t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno), mem);\n   code = reg_restore_code[regno][GET_MODE (mem)];\n   new = insert_one_insn (chain, before_p, code, pat);\n@@ -715,12 +704,8 @@ insert_restore (chain, before_p, regno, maxrestore, save_mode)\n /* Like insert_restore above, but save registers instead.  */\n \n static int\n-insert_save (chain, before_p, regno, to_save, save_mode)\n-     struct insn_chain *chain;\n-     int before_p;\n-     int regno;\n-     HARD_REG_SET *to_save;\n-     enum machine_mode *save_mode;\n+insert_save (struct insn_chain *chain, int before_p, int regno,\n+\t     HARD_REG_SET (*to_save), enum machine_mode *save_mode)\n {\n   int i;\n   unsigned int k;\n@@ -742,7 +727,7 @@ insert_save (chain, before_p, regno, to_save, save_mode)\n \n   /* Get the pattern to emit and update our status.\n \n-     See if we can save several registers with a single instruction.  \n+     See if we can save several registers with a single instruction.\n      Work backwards to the single register case.  */\n   for (i = MOVE_MAX_WORDS; i > 0; i--)\n     {\n@@ -790,15 +775,11 @@ insert_save (chain, before_p, regno, to_save, save_mode)\n \n /* Emit a new caller-save insn and set the code.  */\n static struct insn_chain *\n-insert_one_insn (chain, before_p, code, pat)\n-     struct insn_chain *chain;\n-     int before_p;\n-     int code;\n-     rtx pat;\n+insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n {\n   rtx insn = chain->insn;\n   struct insn_chain *new;\n-  \n+\n #ifdef HAVE_cc0\n   /* If INSN references CC0, put our insns in front of the insn that sets\n      CC0.  This is always safe, since the only way we could be passed an"}, {"sha": "d55c2d13189df4fc92d66848f8c83cede27bcd2f", "filename": "gcc/calls.c", "status": "modified", "additions": 96, "deletions": 203, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -140,59 +140,41 @@ static sbitmap stored_args_map;\n    argument list for the constructor call.  */\n int stack_arg_under_construction;\n \n-static int calls_function\tPARAMS ((tree, int));\n-static int calls_function_1\tPARAMS ((tree, int));\n-\n-static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, rtx,\n-\t\t\t\t\t rtx, int, rtx, int,\n-\t\t\t\t\t CUMULATIVE_ARGS *));\n-static void precompute_register_parameters\tPARAMS ((int,\n-\t\t\t\t\t\t\t struct arg_data *,\n-\t\t\t\t\t\t\t int *));\n-static int store_one_arg\tPARAMS ((struct arg_data *, rtx, int, int,\n-\t\t\t\t\t int));\n-static void store_unaligned_arguments_into_pseudos PARAMS ((struct arg_data *,\n-\t\t\t\t\t\t\t    int));\n-static int finalize_must_preallocate\t\tPARAMS ((int, int,\n-\t\t\t\t\t\t\t struct arg_data *,\n-\t\t\t\t\t\t\t struct args_size *));\n-static void precompute_arguments \t\tPARAMS ((int, int,\n-\t\t\t\t\t\t\t struct arg_data *));\n-static int compute_argument_block_size\t\tPARAMS ((int,\n-\t\t\t\t\t\t\t struct args_size *,\n-\t\t\t\t\t\t\t int));\n-static void initialize_argument_information\tPARAMS ((int,\n-\t\t\t\t\t\t\t struct arg_data *,\n-\t\t\t\t\t\t\t struct args_size *,\n-\t\t\t\t\t\t\t int, tree, tree,\n-\t\t\t\t\t\t\t CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t\t int, rtx *, int *,\n-\t\t\t\t\t\t\t int *, int *));\n-static void compute_argument_addresses\t\tPARAMS ((struct arg_data *,\n-\t\t\t\t\t\t\t rtx, int));\n-static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n-static void load_register_parameters\t\tPARAMS ((struct arg_data *,\n-\t\t\t\t\t\t\t int, rtx *, int,\n-\t\t\t\t\t\t\t int, int *));\n-static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx,\n-\t\t\t\t\t\t\t enum libcall_type,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int, va_list));\n-static int special_function_p\t\t\tPARAMS ((tree, int));\n-static rtx try_to_integrate\t\t\tPARAMS ((tree, tree, rtx,\n-\t\t\t\t\t\t\t int, tree, rtx));\n-static int check_sibcall_argument_overlap_1\tPARAMS ((rtx));\n-static int check_sibcall_argument_overlap\tPARAMS ((rtx, struct arg_data *,\n-\t\t\t\t\t\t\t int));\n-\n-static int combine_pending_stack_adjustment_and_call\n-                                                PARAMS ((int, struct args_size *, int));\n-static tree fix_unsafe_tree\t\tPARAMS ((tree));\n+static int calls_function (tree, int);\n+static int calls_function_1 (tree, int);\n+\n+static void emit_call_1 (rtx, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n+\t\t\t CUMULATIVE_ARGS *);\n+static void precompute_register_parameters (int, struct arg_data *, int *);\n+static int store_one_arg (struct arg_data *, rtx, int, int, int);\n+static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n+static int finalize_must_preallocate (int, int, struct arg_data *,\n+\t\t\t\t      struct args_size *);\n+static void precompute_arguments (int, int, struct arg_data *);\n+static int compute_argument_block_size (int, struct args_size *, int);\n+static void initialize_argument_information (int, struct arg_data *,\n+\t\t\t\t\t     struct args_size *, int, tree,\n+\t\t\t\t\t     tree, CUMULATIVE_ARGS *, int,\n+\t\t\t\t\t     rtx *, int *, int *, int *);\n+static void compute_argument_addresses (struct arg_data *, rtx, int);\n+static rtx rtx_for_function_call (tree, tree);\n+static void load_register_parameters (struct arg_data *, int, rtx *, int,\n+\t\t\t\t      int, int *);\n+static rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n+\t\t\t\t      enum machine_mode, int, va_list);\n+static int special_function_p (tree, int);\n+static rtx try_to_integrate (tree, tree, rtx, int, tree, rtx);\n+static int check_sibcall_argument_overlap_1 (rtx);\n+static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n+\n+static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n+\t\t\t\t\t\t      int);\n+static tree fix_unsafe_tree (tree);\n \n #ifdef REG_PARM_STACK_SPACE\n-static rtx save_fixed_argument_area\tPARAMS ((int, rtx, int *, int *));\n-static void restore_fixed_argument_area\tPARAMS ((rtx, rtx, int, int));\n+static rtx save_fixed_argument_area (int, rtx, int *, int *);\n+static void restore_fixed_argument_area (rtx, rtx, int, int);\n #endif\n \f\n /* If WHICH is 1, return 1 if EXP contains a call to the built-in function\n@@ -206,9 +188,7 @@ static void restore_fixed_argument_area\tPARAMS ((rtx, rtx, int, int));\n static tree calls_function_save_exprs;\n \n static int\n-calls_function (exp, which)\n-     tree exp;\n-     int which;\n+calls_function (tree exp, int which)\n {\n   int val;\n \n@@ -221,9 +201,7 @@ calls_function (exp, which)\n /* Recursive function to do the work of above function.  */\n \n static int\n-calls_function_1 (exp, which)\n-     tree exp;\n-     int which;\n+calls_function_1 (tree exp, int which)\n {\n   int i;\n   enum tree_code code = TREE_CODE (exp);\n@@ -323,12 +301,8 @@ calls_function_1 (exp, which)\n    CALL_INSN_FUNCTION_USAGE information.  */\n \n rtx\n-prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen, sibcallp)\n-     rtx funexp;\n-     tree fndecl;\n-     rtx *call_fusage;\n-     int reg_parm_seen;\n-     int sibcallp;\n+prepare_call_address (rtx funexp, tree fndecl, rtx *call_fusage,\n+\t\t      int reg_parm_seen, int sibcallp)\n {\n   rtx static_chain_value = 0;\n \n@@ -409,21 +383,13 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen, sibcallp)\n    denote registers used by the called function.  */\n \n static void\n-emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n-\t     struct_value_size, next_arg_reg, valreg, old_inhibit_defer_pop,\n-\t     call_fusage, ecf_flags, args_so_far)\n-     rtx funexp;\n-     tree fndecl ATTRIBUTE_UNUSED;\n-     tree funtype ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT stack_size ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT rounded_stack_size;\n-     HOST_WIDE_INT struct_value_size ATTRIBUTE_UNUSED;\n-     rtx next_arg_reg ATTRIBUTE_UNUSED;\n-     rtx valreg;\n-     int old_inhibit_defer_pop;\n-     rtx call_fusage;\n-     int ecf_flags;\n-     CUMULATIVE_ARGS *args_so_far ATTRIBUTE_UNUSED;\n+emit_call_1 (rtx funexp, tree fndecl, tree funtype,\n+\t     HOST_WIDE_INT stack_size ATTRIBUTE_UNUSED,\n+\t     HOST_WIDE_INT rounded_stack_size,\n+\t     HOST_WIDE_INT struct_value_size ATTRIBUTE_UNUSED,\n+\t     rtx next_arg_reg ATTRIBUTE_UNUSED, rtx valreg,\n+\t     int old_inhibit_defer_pop, rtx call_fusage, int ecf_flags,\n+\t     CUMULATIVE_ARGS *args_so_far ATTRIBUTE_UNUSED)\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n   rtx call_insn;\n@@ -437,7 +403,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n #ifdef CALL_POPS_ARGS\n   n_popped += CALL_POPS_ARGS (* args_so_far);\n #endif\n-  \n+\n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n      because prepare_call_address already did it if it should be done.  */\n@@ -643,9 +609,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n    space from the stack such as alloca.  */\n \n static int\n-special_function_p (fndecl, flags)\n-     tree fndecl;\n-     int flags;\n+special_function_p (tree fndecl, int flags)\n {\n   if (! (flags & ECF_MALLOC)\n       && fndecl && DECL_NAME (fndecl)\n@@ -725,16 +689,14 @@ special_function_p (fndecl, flags)\n /* Return nonzero when tree represent call to longjmp.  */\n \n int\n-setjmp_call_p (fndecl)\n-     tree fndecl;\n+setjmp_call_p (tree fndecl)\n {\n   return special_function_p (fndecl, 0) & ECF_RETURNS_TWICE;\n }\n \n /* Return true when exp contains alloca call.  */\n bool\n-alloca_call_p (exp)\n-     tree exp;\n+alloca_call_p (tree exp)\n {\n   if (TREE_CODE (exp) == CALL_EXPR\n       && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n@@ -749,8 +711,7 @@ alloca_call_p (exp)\n /* Detect flags (function attributes) from the function decl or type node.  */\n \n int\n-flags_from_decl_or_type (exp)\n-     tree exp;\n+flags_from_decl_or_type (tree exp)\n {\n   int flags = 0;\n   tree type = exp;\n@@ -805,10 +766,7 @@ flags_from_decl_or_type (exp)\n    Set REG_PARM_SEEN if we encounter a register parameter.  */\n \n static void\n-precompute_register_parameters (num_actuals, args, reg_parm_seen)\n-     int num_actuals;\n-     struct arg_data *args;\n-     int *reg_parm_seen;\n+precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg_parm_seen)\n {\n   int i;\n \n@@ -873,12 +831,7 @@ precompute_register_parameters (num_actuals, args, reg_parm_seen)\n      parameters, we must save and restore it.  */\n \n static rtx\n-save_fixed_argument_area (reg_parm_stack_space, argblock,\n-\t\t\t  low_to_save, high_to_save)\n-     int reg_parm_stack_space;\n-     rtx argblock;\n-     int *low_to_save;\n-     int *high_to_save;\n+save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_save, int *high_to_save)\n {\n   int low;\n   int high;\n@@ -945,11 +898,7 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n }\n \n static void\n-restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n-     rtx save_area;\n-     rtx argblock;\n-     int high_to_save;\n-     int low_to_save;\n+restore_fixed_argument_area (rtx save_area, rtx argblock, int high_to_save, int low_to_save)\n {\n   enum machine_mode save_mode = GET_MODE (save_area);\n   int delta;\n@@ -984,9 +933,7 @@ restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n    the aligned_regs array if it is nonzero.  */\n \n static void\n-store_unaligned_arguments_into_pseudos (args, num_actuals)\n-     struct arg_data *args;\n-     int num_actuals;\n+store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n {\n   int i, j;\n \n@@ -1067,23 +1014,15 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n    flags which may may be modified by this routine.  */\n \n static void\n-initialize_argument_information (num_actuals, args, args_size, n_named_args,\n-\t\t\t\t actparms, fndecl, args_so_far,\n-\t\t\t\t reg_parm_stack_space, old_stack_level,\n-\t\t\t\t old_pending_adj, must_preallocate,\n-\t\t\t\t ecf_flags)\n-     int num_actuals ATTRIBUTE_UNUSED;\n-     struct arg_data *args;\n-     struct args_size *args_size;\n-     int n_named_args ATTRIBUTE_UNUSED;\n-     tree actparms;\n-     tree fndecl;\n-     CUMULATIVE_ARGS *args_so_far;\n-     int reg_parm_stack_space;\n-     rtx *old_stack_level;\n-     int *old_pending_adj;\n-     int *must_preallocate;\n-     int *ecf_flags;\n+initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n+\t\t\t\t struct arg_data *args,\n+\t\t\t\t struct args_size *args_size,\n+\t\t\t\t int n_named_args ATTRIBUTE_UNUSED,\n+\t\t\t\t tree actparms, tree fndecl,\n+\t\t\t\t CUMULATIVE_ARGS *args_so_far,\n+\t\t\t\t int reg_parm_stack_space,\n+\t\t\t\t rtx *old_stack_level, int *old_pending_adj,\n+\t\t\t\t int *must_preallocate, int *ecf_flags)\n {\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n@@ -1324,11 +1263,9 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n    for arguments passed in registers.  */\n \n static int\n-compute_argument_block_size (reg_parm_stack_space, args_size,\n-\t\t\t     preferred_stack_boundary)\n-     int reg_parm_stack_space;\n-     struct args_size *args_size;\n-     int preferred_stack_boundary ATTRIBUTE_UNUSED;\n+compute_argument_block_size (int reg_parm_stack_space,\n+\t\t\t     struct args_size *args_size,\n+\t\t\t     int preferred_stack_boundary ATTRIBUTE_UNUSED)\n {\n   int unadjusted_args_size = args_size->constant;\n \n@@ -1411,10 +1348,7 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n    precomputed argument.  */\n \n static void\n-precompute_arguments (flags, num_actuals, args)\n-     int flags;\n-     int num_actuals;\n-     struct arg_data *args;\n+precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n {\n   int i;\n \n@@ -1482,11 +1416,7 @@ precompute_arguments (flags, num_actuals, args)\n    compute and return the final value for MUST_PREALLOCATE.  */\n \n static int\n-finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n-     int must_preallocate;\n-     int num_actuals;\n-     struct arg_data *args;\n-     struct args_size *args_size;\n+finalize_must_preallocate (int must_preallocate, int num_actuals, struct arg_data *args, struct args_size *args_size)\n {\n   /* See if we have or want to preallocate stack space.\n \n@@ -1545,10 +1475,7 @@ finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n    ARGBLOCK is an rtx for the address of the outgoing arguments.  */\n \n static void\n-compute_argument_addresses (args, argblock, num_actuals)\n-     struct arg_data *args;\n-     rtx argblock;\n-     int num_actuals;\n+compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals)\n {\n   if (argblock)\n     {\n@@ -1609,9 +1536,7 @@ compute_argument_addresses (args, argblock, num_actuals)\n    ADDR is the operand 0 of CALL_EXPR for this call.  */\n \n static rtx\n-rtx_for_function_call (fndecl, addr)\n-     tree fndecl;\n-     tree addr;\n+rtx_for_function_call (tree fndecl, tree addr)\n {\n   rtx funexp;\n \n@@ -1645,20 +1570,15 @@ rtx_for_function_call (fndecl, addr)\n    expressions were already evaluated.\n \n    Mark all register-parms as living through the call, putting these USE\n-   insns in the CALL_INSN_FUNCTION_USAGE field.  \n- \n+   insns in the CALL_INSN_FUNCTION_USAGE field.\n+\n    When IS_SIBCALL, perform the check_sibcall_overlap_argument_overlap\n    checking, setting *SIBCALL_FAILURE if appropriate.  */\n \n static void\n-load_register_parameters (args, num_actuals, call_fusage, flags, \n-\t\t\t    is_sibcall, sibcall_failure)\n-     struct arg_data *args;\n-     int num_actuals;\n-     rtx *call_fusage;\n-     int flags;\n-     int is_sibcall;\n-     int *sibcall_failure;\n+load_register_parameters (struct arg_data *args, int num_actuals,\n+\t\t\t  rtx *call_fusage, int flags, int is_sibcall,\n+\t\t\t  int *sibcall_failure)\n {\n   int i, j;\n \n@@ -1736,13 +1656,8 @@ load_register_parameters (args, num_actuals, call_fusage, flags,\n    about the parameters.  */\n \n static rtx\n-try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n-     tree fndecl;\n-     tree actparms;\n-     rtx target;\n-     int ignore;\n-     tree type;\n-     rtx structure_value_addr;\n+try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n+\t\t  tree type, rtx structure_value_addr)\n {\n   rtx temp;\n   rtx before_call;\n@@ -1864,12 +1779,9 @@ try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n    be popped after the call.  Returns the adjustment.  */\n \n static int\n-combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n-\t\t\t\t\t   args_size,\n-\t\t\t\t\t   preferred_unit_stack_boundary)\n-     int unadjusted_args_size;\n-     struct args_size *args_size;\n-     int preferred_unit_stack_boundary;\n+combine_pending_stack_adjustment_and_call (int unadjusted_args_size,\n+\t\t\t\t\t   struct args_size *args_size,\n+\t\t\t\t\t   int preferred_unit_stack_boundary)\n {\n   /* The number of bytes to pop so that the stack will be\n      under-aligned by UNADJUSTED_ARGS_SIZE bytes.  */\n@@ -1920,8 +1832,7 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n    zero otherwise.  */\n \n static int\n-check_sibcall_argument_overlap_1 (x)\n-     rtx x;\n+check_sibcall_argument_overlap_1 (rtx x)\n {\n   RTX_CODE code;\n   int i, j;\n@@ -1984,10 +1895,7 @@ check_sibcall_argument_overlap_1 (x)\n    slots, zero otherwise.  */\n \n static int\n-check_sibcall_argument_overlap (insn, arg, mark_stored_args_map)\n-     rtx insn;\n-     struct arg_data *arg;\n-     int mark_stored_args_map;\n+check_sibcall_argument_overlap (rtx insn, struct arg_data *arg, int mark_stored_args_map)\n {\n   int low, high;\n \n@@ -2016,8 +1924,7 @@ check_sibcall_argument_overlap (insn, arg, mark_stored_args_map)\n }\n \n static tree\n-fix_unsafe_tree (t)\n-     tree t;\n+fix_unsafe_tree (tree t)\n {\n   switch (unsafe_for_reeval (t))\n     {\n@@ -2051,10 +1958,7 @@ fix_unsafe_tree (t)\n    If IGNORE is nonzero, then we ignore the value of the function call.  */\n \n rtx\n-expand_call (exp, target, ignore)\n-     tree exp;\n-     rtx target;\n-     int ignore;\n+expand_call (tree exp, rtx target, int ignore)\n {\n   /* Nonzero if we are currently expanding a call.  */\n   static int currently_expanding_call = 0;\n@@ -2931,7 +2835,7 @@ expand_call (exp, target, ignore)\n \t\tbreak;\n \t      }\n \t}\n-      \n+\n       compute_argument_addresses (args, argblock, num_actuals);\n \n       /* If we push args individually in reverse order, perform stack alignment\n@@ -3385,13 +3289,13 @@ expand_call (exp, target, ignore)\n \t by at least the delay slot scheduling pass. We do this now instead of\n \t adding to call_fusage before the call to emit_call_1 because TARGET\n \t may be modified in the meantime.  */\n-      if (structure_value_addr != 0 && target != 0 \n+      if (structure_value_addr != 0 && target != 0\n \t  && GET_CODE (target) == MEM && RTX_UNCHANGING_P (target))\n \tadd_function_usage_to\n \t  (last_call_insn (),\n \t   gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_CLOBBER (VOIDmode, target),\n \t\t\t      NULL_RTX));\n-      \n+\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -3572,14 +3476,9 @@ split_complex_types (tree types)\n    parameters are documented in the emit_library_call function below.  */\n \n static rtx\n-emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n-     int retval;\n-     rtx orgfun;\n-     rtx value;\n-     enum libcall_type fn_type;\n-     enum machine_mode outmode;\n-     int nargs;\n-     va_list p;\n+emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n+\t\t\t   enum libcall_type fn_type,\n+\t\t\t   enum machine_mode outmode, int nargs, va_list p)\n {\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n@@ -3799,7 +3698,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t{\n \t  rtx slot;\n \t  int must_copy = 1\n-#ifdef FUNCTION_ARG_CALLEE_COPIES\t  \n+#ifdef FUNCTION_ARG_CALLEE_COPIES\n \t    && ! FUNCTION_ARG_CALLEE_COPIES (args_so_far, mode,\n \t\t\t\t\t     NULL_TREE, 1)\n #endif\n@@ -4298,7 +4197,7 @@ emit_library_call (rtx orgfun, enum libcall_type fn_type,\n \t\t   enum machine_mode outmode, int nargs, ...)\n {\n   va_list p;\n-  \n+\n   va_start (p, nargs);\n   emit_library_call_value_1 (0, orgfun, NULL_RTX, fn_type, outmode, nargs, p);\n   va_end (p);\n@@ -4319,7 +4218,7 @@ emit_library_call_value (rtx orgfun, rtx value,\n {\n   rtx result;\n   va_list p;\n-  \n+\n   va_start (p, nargs);\n   result = emit_library_call_value_1 (1, orgfun, value, fn_type, outmode,\n \t\t\t\t      nargs, p);\n@@ -4348,12 +4247,8 @@ emit_library_call_value (rtx orgfun, rtx value,\n    zero otherwise.  */\n \n static int\n-store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n-     struct arg_data *arg;\n-     rtx argblock;\n-     int flags;\n-     int variable_size ATTRIBUTE_UNUSED;\n-     int reg_parm_stack_space;\n+store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n+\t       int variable_size ATTRIBUTE_UNUSED, int reg_parm_stack_space)\n {\n   tree pval = arg->tree_value;\n   rtx reg = 0;\n@@ -4533,7 +4428,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, \n+      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX,\n \t\t      PARM_BOUNDARY, partial, reg, used - size, argblock,\n \t\t      ARGS_SIZE_RTX (arg->locate.offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad));\n@@ -4682,9 +4577,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n    For a little-endian machine, the reverse is true.  */\n \n bool\n-default_must_pass_in_stack (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+default_must_pass_in_stack (enum machine_mode mode, tree type)\n {\n   if (!type)\n     return false;"}, {"sha": "b55a2c0f3d1b2fd069e024e9d4ec1ca02d64881b", "filename": "gcc/cfg.c", "status": "modified", "additions": 40, "deletions": 74, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -138,13 +138,13 @@ struct basic_block_def entry_exit_blocks[2]\n   }\n };\n \n-void debug_flow_info\t\t\tPARAMS ((void));\n-static void free_edge\t\t\tPARAMS ((edge));\n+void debug_flow_info (void);\n+static void free_edge (edge);\n \f\n /* Called once at initialization time.  */\n \n void\n-init_flow ()\n+init_flow (void)\n {\n   static int initialized;\n \n@@ -163,7 +163,7 @@ init_flow ()\n       obstack_free (&flow_obstack, flow_firstobj);\n       flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n     }\n-  bb_pool = create_alloc_pool (\"Basic block pool\", \n+  bb_pool = create_alloc_pool (\"Basic block pool\",\n \t\t\t       sizeof (struct basic_block_def), 100);\n   edge_pool = create_alloc_pool (\"Edge pool\",\n \t\t\t       sizeof (struct edge_def), 100);\n@@ -173,8 +173,7 @@ init_flow ()\n    without actually unlinking it from the pred/succ lists.  */\n \n static void\n-free_edge (e)\n-     edge e;\n+free_edge (edge e)\n {\n   n_edges--;\n   pool_free (edge_pool, e);\n@@ -183,7 +182,7 @@ free_edge (e)\n /* Free the memory associated with the edge structures.  */\n \n void\n-clear_edges ()\n+clear_edges (void)\n {\n   basic_block bb;\n   edge e;\n@@ -223,7 +222,7 @@ clear_edges ()\n /* Allocate memory for basic_block.  */\n \n basic_block\n-alloc_block ()\n+alloc_block (void)\n {\n   basic_block bb;\n   bb = pool_alloc (bb_pool);\n@@ -233,8 +232,7 @@ alloc_block ()\n \n /* Link block B to chain after AFTER.  */\n void\n-link_block (b, after)\n-     basic_block b, after;\n+link_block (basic_block b, basic_block after)\n {\n   b->next_bb = after->next_bb;\n   b->prev_bb = after;\n@@ -244,20 +242,19 @@ link_block (b, after)\n \n /* Unlink block B from chain.  */\n void\n-unlink_block (b)\n-     basic_block b;\n+unlink_block (basic_block b)\n {\n   b->next_bb->prev_bb = b->prev_bb;\n   b->prev_bb->next_bb = b->next_bb;\n }\n \n /* Sequentially order blocks and compact the arrays.  */\n void\n-compact_blocks ()\n+compact_blocks (void)\n {\n   int i;\n   basic_block bb;\n- \n+\n   i = 0;\n   FOR_EACH_BB (bb)\n     {\n@@ -275,8 +272,7 @@ compact_blocks ()\n /* Remove block B from the basic block array.  */\n \n void\n-expunge_block (b)\n-     basic_block b;\n+expunge_block (basic_block b)\n {\n   unlink_block (b);\n   BASIC_BLOCK (b->index) = NULL;\n@@ -289,9 +285,7 @@ expunge_block (b)\n    possibly already exist.  */\n \n edge\n-unchecked_make_edge (src, dst, flags)\n-     basic_block src, dst;\n-     int flags;\n+unchecked_make_edge (basic_block src, basic_block dst, int flags)\n {\n   edge e;\n   e = pool_alloc (edge_pool);\n@@ -314,10 +308,7 @@ unchecked_make_edge (src, dst, flags)\n    edge cache CACHE.  Return the new edge, NULL if already exist.  */\n \n edge\n-cached_make_edge (edge_cache, src, dst, flags)\n-     sbitmap *edge_cache;\n-     basic_block src, dst;\n-     int flags;\n+cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int flags)\n {\n   int use_edge_cache;\n   edge e;\n@@ -349,7 +340,7 @@ cached_make_edge (edge_cache, src, dst, flags)\n \t  }\n       break;\n     }\n-  \n+\n   e = unchecked_make_edge (src, dst, flags);\n \n   if (use_edge_cache)\n@@ -362,9 +353,7 @@ cached_make_edge (edge_cache, src, dst, flags)\n    created edge or NULL if already exist.  */\n \n edge\n-make_edge (src, dest, flags)\n-     basic_block src, dest;\n-     int flags;\n+make_edge (basic_block src, basic_block dest, int flags)\n {\n   return cached_make_edge (NULL, src, dest, flags);\n }\n@@ -373,9 +362,7 @@ make_edge (src, dest, flags)\n    that it is the single edge leaving SRC.  */\n \n edge\n-make_single_succ_edge (src, dest, flags)\n-     basic_block src, dest;\n-     int flags;\n+make_single_succ_edge (basic_block src, basic_block dest, int flags)\n {\n   edge e = make_edge (src, dest, flags);\n \n@@ -387,8 +374,7 @@ make_single_succ_edge (src, dest, flags)\n /* This function will remove an edge from the flow graph.  */\n \n void\n-remove_edge (e)\n-     edge e;\n+remove_edge (edge e)\n {\n   edge last_pred = NULL;\n   edge last_succ = NULL;\n@@ -423,9 +409,7 @@ remove_edge (e)\n /* Redirect an edge's successor from one block to another.  */\n \n void\n-redirect_edge_succ (e, new_succ)\n-     edge e;\n-     basic_block new_succ;\n+redirect_edge_succ (edge e, basic_block new_succ)\n {\n   edge *pe;\n \n@@ -443,9 +427,7 @@ redirect_edge_succ (e, new_succ)\n /* Like previous but avoid possible duplicate edge.  */\n \n edge\n-redirect_edge_succ_nodup (e, new_succ)\n-     edge e;\n-     basic_block new_succ;\n+redirect_edge_succ_nodup (edge e, basic_block new_succ)\n {\n   edge s;\n \n@@ -473,9 +455,7 @@ redirect_edge_succ_nodup (e, new_succ)\n /* Redirect an edge's predecessor from one block to another.  */\n \n void\n-redirect_edge_pred (e, new_pred)\n-     edge e;\n-     basic_block new_pred;\n+redirect_edge_pred (edge e, basic_block new_pred)\n {\n   edge *pe;\n \n@@ -492,7 +472,7 @@ redirect_edge_pred (e, new_pred)\n }\n \n void\n-clear_bb_flags ()\n+clear_bb_flags (void)\n {\n   basic_block bb;\n \n@@ -501,8 +481,7 @@ clear_bb_flags ()\n }\n \f\n void\n-dump_flow_info (file)\n-     FILE *file;\n+dump_flow_info (FILE *file)\n {\n   int i;\n   int max_regno = max_reg_num ();\n@@ -625,16 +604,13 @@ dump_flow_info (file)\n }\n \n void\n-debug_flow_info ()\n+debug_flow_info (void)\n {\n   dump_flow_info (stderr);\n }\n \n void\n-dump_edge_info (file, e, do_succ)\n-     FILE *file;\n-     edge e;\n-     int do_succ;\n+dump_edge_info (FILE *file, edge e, int do_succ)\n {\n   basic_block side = (do_succ ? e->dest : e->src);\n \n@@ -693,9 +669,7 @@ static void *first_edge_aux_obj = 0;\n    be first initialized by alloc_aux_for_blocks.  */\n \n inline void\n-alloc_aux_for_block (bb, size)\n-     basic_block bb;\n-     int size;\n+alloc_aux_for_block (basic_block bb, int size)\n {\n   /* Verify that aux field is clear.  */\n   if (bb->aux || !first_block_aux_obj)\n@@ -708,8 +682,7 @@ alloc_aux_for_block (bb, size)\n    alloc_aux_for_block for each basic block.  */\n \n void\n-alloc_aux_for_blocks (size)\n-     int size;\n+alloc_aux_for_blocks (int size)\n {\n   static int initialized;\n \n@@ -735,7 +708,7 @@ alloc_aux_for_blocks (size)\n /* Clear AUX pointers of all blocks.  */\n \n void\n-clear_aux_for_blocks ()\n+clear_aux_for_blocks (void)\n {\n   basic_block bb;\n \n@@ -747,7 +720,7 @@ clear_aux_for_blocks ()\n    of all blocks.  */\n \n void\n-free_aux_for_blocks ()\n+free_aux_for_blocks (void)\n {\n   if (!first_block_aux_obj)\n     abort ();\n@@ -761,9 +734,7 @@ free_aux_for_blocks ()\n    be first initialized by alloc_aux_for_edges.  */\n \n inline void\n-alloc_aux_for_edge (e, size)\n-     edge e;\n-     int size;\n+alloc_aux_for_edge (edge e, int size)\n {\n   /* Verify that aux field is clear.  */\n   if (e->aux || !first_edge_aux_obj)\n@@ -776,8 +747,7 @@ alloc_aux_for_edge (e, size)\n    alloc_aux_for_edge for each basic edge.  */\n \n void\n-alloc_aux_for_edges (size)\n-     int size;\n+alloc_aux_for_edges (int size)\n {\n   static int initialized;\n \n@@ -809,7 +779,7 @@ alloc_aux_for_edges (size)\n /* Clear AUX pointers of all edges.  */\n \n void\n-clear_aux_for_edges ()\n+clear_aux_for_edges (void)\n {\n   basic_block bb;\n   edge e;\n@@ -825,7 +795,7 @@ clear_aux_for_edges ()\n    of all edges.  */\n \n void\n-free_aux_for_edges ()\n+free_aux_for_edges (void)\n {\n   if (!first_edge_aux_obj)\n     abort ();\n@@ -835,12 +805,12 @@ free_aux_for_edges ()\n   clear_aux_for_edges ();\n }\n \n-/* Verify the CFG consistency.  \n-  \n+/* Verify the CFG consistency.\n+\n    Currently it does following checks edge and basic block list correctness\n    and calls into IL dependent checking then.  */\n void\n-verify_flow_info ()\n+verify_flow_info (void)\n {\n   size_t *edge_checksum;\n   int num_bb_notes, err = 0;\n@@ -984,9 +954,7 @@ verify_flow_info ()\n /* Print out one basic block with live information at start and end.  */\n \n void\n-dump_bb (bb, outf)\n-     basic_block bb;\n-     FILE *outf;\n+dump_bb (basic_block bb, FILE *outf)\n {\n   edge e;\n \n@@ -1004,15 +972,13 @@ dump_bb (bb, outf)\n }\n \n void\n-debug_bb (bb)\n-     basic_block bb;\n+debug_bb (basic_block bb)\n {\n   dump_bb (bb, stderr);\n }\n \n basic_block\n-debug_bb_n (n)\n-     int n;\n+debug_bb_n (int n)\n {\n   basic_block bb = BASIC_BLOCK (n);\n   dump_bb (bb, stderr);"}, {"sha": "186a6c422d5373f1ac902f3671dd1b3b2a8f40f5", "filename": "gcc/cfganal.c", "status": "modified", "additions": 38, "deletions": 74, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -46,29 +46,25 @@ struct depth_first_search_dsS {\n };\n typedef struct depth_first_search_dsS *depth_first_search_ds;\n \n-static void flow_dfs_compute_reverse_init\n-  PARAMS ((depth_first_search_ds));\n-static void flow_dfs_compute_reverse_add_bb\n-  PARAMS ((depth_first_search_ds, basic_block));\n-static basic_block flow_dfs_compute_reverse_execute\n-  PARAMS ((depth_first_search_ds));\n-static void flow_dfs_compute_reverse_finish\n-  PARAMS ((depth_first_search_ds));\n-static void remove_fake_successors\tPARAMS ((basic_block));\n-static bool need_fake_edge_p\t\tPARAMS ((rtx));\n-static bool flow_active_insn_p\t\tPARAMS ((rtx));\n+static void flow_dfs_compute_reverse_init (depth_first_search_ds);\n+static void flow_dfs_compute_reverse_add_bb (depth_first_search_ds,\n+\t\t\t\t\t     basic_block);\n+static basic_block flow_dfs_compute_reverse_execute (depth_first_search_ds);\n+static void flow_dfs_compute_reverse_finish (depth_first_search_ds);\n+static void remove_fake_successors (basic_block);\n+static bool need_fake_edge_p (rtx);\n+static bool flow_active_insn_p (rtx);\n \f\n /* Like active_insn_p, except keep the return value clobber around\n    even after reload.  */\n \n static bool\n-flow_active_insn_p (insn)\n-     rtx insn;\n+flow_active_insn_p (rtx insn)\n {\n   if (active_insn_p (insn))\n     return true;\n \n-  /* A clobber of the function return value exists for buggy \n+  /* A clobber of the function return value exists for buggy\n      programs that fail to return a value.  Its effect is to\n      keep the return value from being live across the entire\n      function.  If we allow it to be skipped, we introduce the\n@@ -85,8 +81,7 @@ flow_active_insn_p (insn)\n    its single destination.  */\n \n bool\n-forwarder_block_p (bb)\n-     basic_block bb;\n+forwarder_block_p (basic_block bb)\n {\n   rtx insn;\n \n@@ -106,8 +101,7 @@ forwarder_block_p (bb)\n /* Return nonzero if we can reach target from src by falling through.  */\n \n bool\n-can_fallthru (src, target)\n-     basic_block src, target;\n+can_fallthru (basic_block src, basic_block target)\n {\n   rtx insn = src->end;\n   rtx insn2 = target->head;\n@@ -133,7 +127,7 @@ can_fallthru (src, target)\n    and heavily borrowed from flow_depth_first_order_compute.  */\n \n bool\n-mark_dfs_back_edges ()\n+mark_dfs_back_edges (void)\n {\n   edge *stack;\n   int *pre;\n@@ -217,7 +211,7 @@ mark_dfs_back_edges ()\n /* Set the flag EDGE_CAN_FALLTHRU for edges that can be fallthru.  */\n \n void\n-set_edge_can_fallthru_flag ()\n+set_edge_can_fallthru_flag (void)\n {\n   basic_block bb;\n \n@@ -252,8 +246,7 @@ set_edge_can_fallthru_flag ()\n    Helper function for the flow_call_edges_add.  */\n \n static bool\n-need_fake_edge_p (insn)\n-     rtx insn;\n+need_fake_edge_p (rtx insn)\n {\n   if (!INSN_P (insn))\n     return false;\n@@ -282,8 +275,7 @@ need_fake_edge_p (insn)\n    that all subsequent instructions must be executed.  */\n \n int\n-flow_call_edges_add (blocks)\n-     sbitmap blocks;\n+flow_call_edges_add (sbitmap blocks)\n {\n   int i;\n   int blocks_split = 0;\n@@ -405,7 +397,7 @@ flow_call_edges_add (blocks)\n    block is reachable.  */\n \n void\n-find_unreachable_blocks ()\n+find_unreachable_blocks (void)\n {\n   edge e;\n   basic_block *tos, *worklist, bb;\n@@ -461,7 +453,7 @@ find_unreachable_blocks ()\n    and the data structure is filled in.  */\n \n struct edge_list *\n-create_edge_list ()\n+create_edge_list (void)\n {\n   struct edge_list *elist;\n   edge e;\n@@ -499,8 +491,7 @@ create_edge_list ()\n /* This function free's memory associated with an edge list.  */\n \n void\n-free_edge_list (elist)\n-     struct edge_list *elist;\n+free_edge_list (struct edge_list *elist)\n {\n   if (elist)\n     {\n@@ -512,9 +503,7 @@ free_edge_list (elist)\n /* This function provides debug output showing an edge list.  */\n \n void\n-print_edge_list (f, elist)\n-     FILE *f;\n-     struct edge_list *elist;\n+print_edge_list (FILE *f, struct edge_list *elist)\n {\n   int x;\n \n@@ -541,9 +530,7 @@ print_edge_list (f, elist)\n    extra edges.  */\n \n void\n-verify_edge_list (f, elist)\n-     FILE *f;\n-     struct edge_list *elist;\n+verify_edge_list (FILE *f, struct edge_list *elist)\n {\n   int pred, succ, index;\n   edge e;\n@@ -608,9 +595,7 @@ verify_edge_list (f, elist)\n    a specified predecessor and successor.  */\n \n int\n-find_edge_index (edge_list, pred, succ)\n-     struct edge_list *edge_list;\n-     basic_block pred, succ;\n+find_edge_index (struct edge_list *edge_list, basic_block pred, basic_block succ)\n {\n   int x;\n \n@@ -625,10 +610,7 @@ find_edge_index (edge_list, pred, succ)\n /* Dump the list of basic blocks in the bitmap NODES.  */\n \n void\n-flow_nodes_print (str, nodes, file)\n-     const char *str;\n-     const sbitmap nodes;\n-     FILE *file;\n+flow_nodes_print (const char *str, const sbitmap nodes, FILE *file)\n {\n   int node;\n \n@@ -643,11 +625,7 @@ flow_nodes_print (str, nodes, file)\n /* Dump the list of edges in the array EDGE_LIST.  */\n \n void\n-flow_edge_list_print (str, edge_list, num_edges, file)\n-     const char *str;\n-     const edge *edge_list;\n-     int num_edges;\n-     FILE *file;\n+flow_edge_list_print (const char *str, const edge *edge_list, int num_edges, FILE *file)\n {\n   int i;\n \n@@ -668,8 +646,7 @@ flow_edge_list_print (str, edge_list, num_edges, file)\n    list it is in.  */\n \n static void\n-remove_fake_successors (bb)\n-     basic_block bb;\n+remove_fake_successors (basic_block bb)\n {\n   edge e;\n \n@@ -688,7 +665,7 @@ remove_fake_successors (bb)\n    fake predecessors.  */\n \n void\n-remove_fake_edges ()\n+remove_fake_edges (void)\n {\n   basic_block bb;\n \n@@ -701,7 +678,7 @@ remove_fake_edges ()\n    edges to exist.  */\n \n void\n-add_noreturn_fake_exit_edges ()\n+add_noreturn_fake_exit_edges (void)\n {\n   basic_block bb;\n \n@@ -722,7 +699,7 @@ add_noreturn_fake_exit_edges ()\n    nodes not reachable from the exit block.  */\n \n void\n-connect_infinite_loops_to_exit ()\n+connect_infinite_loops_to_exit (void)\n {\n   basic_block unvisited_block;\n   struct depth_first_search_dsS dfs_ds;\n@@ -750,8 +727,7 @@ connect_infinite_loops_to_exit ()\n /* Compute reverse top sort order */\n \n void\n-flow_reverse_top_sort_order_compute (rts_order)\n-     int *rts_order;\n+flow_reverse_top_sort_order_compute (int *rts_order)\n {\n   edge *stack;\n   int sp;\n@@ -819,9 +795,7 @@ flow_reverse_top_sort_order_compute (rts_order)\n   possible.  */\n \n int\n-flow_depth_first_order_compute (dfs_order, rc_order)\n-     int *dfs_order;\n-     int *rc_order;\n+flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n {\n   edge *stack;\n   int sp;\n@@ -922,8 +896,7 @@ struct dfst_node\n      2) Walking the resulting tree from right to left.  */\n \n void\n-flow_preorder_transversal_compute (pot_order)\n-     int *pot_order;\n+flow_preorder_transversal_compute (int *pot_order)\n {\n   edge e;\n   edge *stack;\n@@ -1062,8 +1035,7 @@ flow_preorder_transversal_compute (pot_order)\n    element on the stack.  */\n \n static void\n-flow_dfs_compute_reverse_init (data)\n-     depth_first_search_ds data;\n+flow_dfs_compute_reverse_init (depth_first_search_ds data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n   data->stack = (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n@@ -1084,9 +1056,7 @@ flow_dfs_compute_reverse_init (data)\n    block.  */\n \n static void\n-flow_dfs_compute_reverse_add_bb (data, bb)\n-     depth_first_search_ds data;\n-     basic_block bb;\n+flow_dfs_compute_reverse_add_bb (depth_first_search_ds data, basic_block bb)\n {\n   data->stack[data->sp++] = bb;\n   SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1));\n@@ -1098,8 +1068,7 @@ flow_dfs_compute_reverse_add_bb (data, bb)\n    available.  */\n \n static basic_block\n-flow_dfs_compute_reverse_execute (data)\n-     depth_first_search_ds data;\n+flow_dfs_compute_reverse_execute (depth_first_search_ds data)\n {\n   basic_block bb;\n   edge e;\n@@ -1127,8 +1096,7 @@ flow_dfs_compute_reverse_execute (data)\n    reverse graph.  */\n \n static void\n-flow_dfs_compute_reverse_finish (data)\n-     depth_first_search_ds data;\n+flow_dfs_compute_reverse_finish (depth_first_search_ds data)\n {\n   free (data->stack);\n   sbitmap_free (data->visited_blocks);\n@@ -1138,13 +1106,9 @@ flow_dfs_compute_reverse_finish (data)\n    if REVERSE, go against direction of edges.  Returns number of blocks\n    found and their list in RSLT.  RSLT can contain at most RSLT_MAX items.  */\n int\n-dfs_enumerate_from (bb, reverse, predicate, rslt, rslt_max, data)\n-     basic_block bb;\n-     int reverse;\n-     bool (*predicate) PARAMS ((basic_block, void *));\n-     basic_block *rslt;\n-     int rslt_max;\n-     void *data;\n+dfs_enumerate_from (basic_block bb, int reverse,\n+\t\t    bool (*predicate) (basic_block, void *),\n+\t\t    basic_block *rslt, int rslt_max, void *data)\n {\n   basic_block *st, lbb;\n   int sp = 0, tv = 0;"}, {"sha": "eb7fd22e3317e8118472d99f3b72c67cee52d498", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 23, "deletions": 47, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -48,23 +48,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"timevar.h\"\n \n-static int count_basic_blocks\t\tPARAMS ((rtx));\n-static void find_basic_blocks_1\t\tPARAMS ((rtx));\n-static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n-static void make_edges\t\t\tPARAMS ((rtx, basic_block,\n-\t\t\t\t\t\t basic_block, int));\n-static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n-\t\t\t\t\t\t rtx, int));\n-static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n-static void find_bb_boundaries\t\tPARAMS ((basic_block));\n-static void compute_outgoing_frequencies PARAMS ((basic_block));\n+static int count_basic_blocks (rtx);\n+static void find_basic_blocks_1 (rtx);\n+static rtx find_label_refs (rtx, rtx);\n+static void make_edges (rtx, basic_block, basic_block, int);\n+static void make_label_edge (sbitmap *, basic_block, rtx, int);\n+static void make_eh_edge (sbitmap *, basic_block, rtx);\n+static void find_bb_boundaries (basic_block);\n+static void compute_outgoing_frequencies (basic_block);\n \f\n /* Return true if insn is something that should be contained inside basic\n    block.  */\n \n bool\n-inside_basic_block_p (insn)\n-     rtx insn;\n+inside_basic_block_p (rtx insn)\n {\n   switch (GET_CODE (insn))\n     {\n@@ -96,8 +93,7 @@ inside_basic_block_p (insn)\n    the basic block.  */\n \n bool\n-control_flow_insn_p (insn)\n-     rtx insn;\n+control_flow_insn_p (rtx insn)\n {\n   rtx note;\n \n@@ -138,8 +134,7 @@ control_flow_insn_p (insn)\n /* Count the basic blocks of the function.  */\n \n static int\n-count_basic_blocks (f)\n-     rtx f;\n+count_basic_blocks (rtx f)\n {\n   int count = 0;\n   bool saw_insn = false;\n@@ -180,9 +175,7 @@ count_basic_blocks (f)\n    This is used to scan the alternatives of a call placeholder.  */\n \n static rtx\n-find_label_refs (f, lvl)\n-     rtx f;\n-     rtx lvl;\n+find_label_refs (rtx f, rtx lvl)\n {\n   rtx insn;\n \n@@ -229,11 +222,7 @@ find_label_refs (f, lvl)\n /* Create an edge from a basic block to a label.  */\n \n static void\n-make_label_edge (edge_cache, src, label, flags)\n-     sbitmap *edge_cache;\n-     basic_block src;\n-     rtx label;\n-     int flags;\n+make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n {\n   if (GET_CODE (label) != CODE_LABEL)\n     abort ();\n@@ -252,10 +241,7 @@ make_label_edge (edge_cache, src, label, flags)\n /* Create the edges generated by INSN in REGION.  */\n \n static void\n-make_eh_edge (edge_cache, src, insn)\n-     sbitmap *edge_cache;\n-     basic_block src;\n-     rtx insn;\n+make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n {\n   int is_call = GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0;\n   rtx handlers, i;\n@@ -278,10 +264,7 @@ make_eh_edge (edge_cache, src, insn)\n    the list of exception regions active at the end of the basic block.  */\n \n static void\n-make_edges (label_value_list, min, max, update_p)\n-     rtx label_value_list;\n-     basic_block min, max;\n-     int update_p;\n+make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p)\n {\n   basic_block bb;\n   sbitmap *edge_cache = NULL;\n@@ -464,8 +447,7 @@ make_edges (label_value_list, min, max, update_p)\n    will be used in make_edges for use with computed gotos.  */\n \n static void\n-find_basic_blocks_1 (f)\n-     rtx f;\n+find_basic_blocks_1 (rtx f)\n {\n   rtx insn, next;\n   rtx bb_note = NULL_RTX;\n@@ -604,10 +586,8 @@ find_basic_blocks_1 (f)\n    numbers in use.  */\n \n void\n-find_basic_blocks (f, nregs, file)\n-     rtx f;\n-     int nregs ATTRIBUTE_UNUSED;\n-     FILE *file ATTRIBUTE_UNUSED;\n+find_basic_blocks (rtx f, int nregs ATTRIBUTE_UNUSED,\n+\t\t   FILE *file ATTRIBUTE_UNUSED)\n {\n   basic_block bb;\n \n@@ -622,7 +602,7 @@ find_basic_blocks (f, nregs, file)\n \t tag for reuse during create_basic_block, just in case some pass\n \t copies around basic block notes improperly.  */\n       FOR_EACH_BB (bb)\n- \tbb->aux = NULL;\n+\tbb->aux = NULL;\n \n       VARRAY_FREE (basic_block_info);\n     }\n@@ -667,8 +647,7 @@ enum state {BLOCK_NEW = 0, BLOCK_ORIGINAL, BLOCK_TO_SPLIT};\n    and create new basic blocks in the progress.  */\n \n static void\n-find_bb_boundaries (bb)\n-     basic_block bb;\n+find_bb_boundaries (basic_block bb)\n {\n   rtx insn = bb->head;\n   rtx end = bb->end;\n@@ -734,8 +713,7 @@ find_bb_boundaries (bb)\n     and probabilities of outgoing edges.  */\n \n static void\n-compute_outgoing_frequencies (b)\n-     basic_block b;\n+compute_outgoing_frequencies (basic_block b)\n {\n   edge e, f;\n \n@@ -771,8 +749,7 @@ compute_outgoing_frequencies (b)\n    basic block.  Update the data structure.  */\n \n void\n-find_many_sub_basic_blocks (blocks)\n-     sbitmap blocks;\n+find_many_sub_basic_blocks (sbitmap blocks)\n {\n   basic_block bb, min, max;\n \n@@ -826,8 +803,7 @@ find_many_sub_basic_blocks (blocks)\n /* Like above but for single basic block only.  */\n \n void\n-find_sub_basic_blocks (bb)\n-     basic_block bb;\n+find_sub_basic_blocks (basic_block bb)\n {\n   basic_block min, max, b;\n   basic_block next = bb->next_bb;"}, {"sha": "62f7f301e5bcc001cb6e41bfbd3a228d6b24db59", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 41, "deletions": 78, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,6 +1,6 @@\n /* Control flow optimization code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -67,36 +67,30 @@ enum bb_flags\n \n #define FORWARDER_BLOCK_P(BB) (BB_FLAGS (BB) & BB_FORWARDER_BLOCK)\n \n-static bool try_crossjump_to_edge\tPARAMS ((int, edge, edge));\n-static bool try_crossjump_bb\t\tPARAMS ((int, basic_block));\n-static bool outgoing_edges_match\tPARAMS ((int,\n-\t\t\t\t\t\t basic_block, basic_block));\n-static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n-\t\t\t\t\t\t rtx *, rtx *));\n-static bool insns_match_p\t\tPARAMS ((int, rtx, rtx));\n-\n-static bool label_is_jump_target_p\tPARAMS ((rtx, rtx));\n-static bool tail_recursion_label_p\tPARAMS ((rtx));\n-static void merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n-\t\t\t\t\t\t\t  basic_block));\n-static void merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n-\t\t\t\t\t\t\tbasic_block));\n-static basic_block merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n-\t\t\t\t\t\t int));\n-static bool try_optimize_cfg\t\tPARAMS ((int));\n-static bool try_simplify_condjump\tPARAMS ((basic_block));\n-static bool try_forward_edges\t\tPARAMS ((int, basic_block));\n-static edge thread_jump\t\t\tPARAMS ((int, edge, basic_block));\n-static bool mark_effect\t\t\tPARAMS ((rtx, bitmap));\n-static void notice_new_block\t\tPARAMS ((basic_block));\n-static void update_forwarder_flag\tPARAMS ((basic_block));\n-static int mentions_nonequal_regs\tPARAMS ((rtx *, void *));\n+static bool try_crossjump_to_edge (int, edge, edge);\n+static bool try_crossjump_bb (int, basic_block);\n+static bool outgoing_edges_match (int, basic_block, basic_block);\n+static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n+static bool insns_match_p (int, rtx, rtx);\n+\n+static bool label_is_jump_target_p (rtx, rtx);\n+static bool tail_recursion_label_p (rtx);\n+static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n+static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n+static basic_block merge_blocks (edge,basic_block,basic_block, int);\n+static bool try_optimize_cfg (int);\n+static bool try_simplify_condjump (basic_block);\n+static bool try_forward_edges (int, basic_block);\n+static edge thread_jump (int, edge, basic_block);\n+static bool mark_effect (rtx, bitmap);\n+static void notice_new_block (basic_block);\n+static void update_forwarder_flag (basic_block);\n+static int mentions_nonequal_regs (rtx *, void *);\n \f\n /* Set flags for newly created block.  */\n \n static void\n-notice_new_block (bb)\n-     basic_block bb;\n+notice_new_block (basic_block bb)\n {\n   if (!bb)\n     return;\n@@ -108,8 +102,7 @@ notice_new_block (bb)\n /* Recompute forwarder flag after block has been modified.  */\n \n static void\n-update_forwarder_flag (bb)\n-     basic_block bb;\n+update_forwarder_flag (basic_block bb)\n {\n   if (forwarder_block_p (bb))\n     BB_SET_FLAG (bb, BB_FORWARDER_BLOCK);\n@@ -121,8 +114,7 @@ update_forwarder_flag (bb)\n    Return true if something changed.  */\n \n static bool\n-try_simplify_condjump (cbranch_block)\n-     basic_block cbranch_block;\n+try_simplify_condjump (basic_block cbranch_block)\n {\n   basic_block jump_block, jump_dest_block, cbranch_dest_block;\n   edge cbranch_jump_edge, cbranch_fallthru_edge;\n@@ -190,9 +182,7 @@ try_simplify_condjump (cbranch_block)\n    on register.  Used by jump threading.  */\n \n static bool\n-mark_effect (exp, nonequal)\n-     rtx exp;\n-     regset nonequal;\n+mark_effect (rtx exp, regset nonequal)\n {\n   int regno;\n   rtx dest;\n@@ -241,9 +231,7 @@ mark_effect (exp, nonequal)\n /* Return nonzero if X is an register set in regset DATA.\n    Called via for_each_rtx.  */\n static int\n-mentions_nonequal_regs (x, data)\n-     rtx *x;\n-     void *data;\n+mentions_nonequal_regs (rtx *x, void *data)\n {\n   regset nonequal = (regset) data;\n   if (REG_P (*x))\n@@ -268,10 +256,7 @@ mentions_nonequal_regs (x, data)\n    if exist, NULL otherwise.  */\n \n static edge\n-thread_jump (mode, e, b)\n-     int mode;\n-     edge e;\n-     basic_block b;\n+thread_jump (int mode, edge e, basic_block b)\n {\n   rtx set1, set2, cond1, cond2, insn;\n   enum rtx_code code1, code2, reversed_code2;\n@@ -413,9 +398,7 @@ thread_jump (mode, e, b)\n    Return true if successful.  */\n \n static bool\n-try_forward_edges (mode, b)\n-     basic_block b;\n-     int mode;\n+try_forward_edges (int mode, basic_block b)\n {\n   bool changed = false;\n   edge e, next, *threaded_edges = NULL;\n@@ -648,8 +631,7 @@ try_forward_edges (mode, b)\n    not apply to the fallthru case of a conditional jump.  */\n \n static bool\n-label_is_jump_target_p (label, jump_insn)\n-     rtx label, jump_insn;\n+label_is_jump_target_p (rtx label, rtx jump_insn)\n {\n   rtx tmp = JUMP_LABEL (jump_insn);\n \n@@ -672,8 +654,7 @@ label_is_jump_target_p (label, jump_insn)\n /* Return true if LABEL is used for tail recursion.  */\n \n static bool\n-tail_recursion_label_p (label)\n-     rtx label;\n+tail_recursion_label_p (rtx label)\n {\n   rtx x;\n \n@@ -689,8 +670,7 @@ tail_recursion_label_p (label)\n    any jumps (aside from the jump from A to B).  */\n \n static void\n-merge_blocks_move_predecessor_nojumps (a, b)\n-     basic_block a, b;\n+merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier;\n \n@@ -732,8 +712,7 @@ merge_blocks_move_predecessor_nojumps (a, b)\n    any jumps (aside from the jump from A to B).  */\n \n static void\n-merge_blocks_move_successor_nojumps (a, b)\n-     basic_block a, b;\n+merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier, real_b_end;\n \n@@ -795,10 +774,7 @@ merge_blocks_move_successor_nojumps (a, b)\n    relative ordering of these two.  Hopefully it is not too common.  */\n \n static basic_block\n-merge_blocks (e, b, c, mode)\n-     edge e;\n-     basic_block b, c;\n-     int mode;\n+merge_blocks (edge e, basic_block b, basic_block c, int mode)\n {\n   basic_block next;\n   /* If C has a tail recursion label, do not merge.  There is no\n@@ -895,9 +871,7 @@ merge_blocks (e, b, c, mode)\n /* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n \n static bool\n-insns_match_p (mode, i1, i2)\n-     int mode ATTRIBUTE_UNUSED;\n-     rtx i1, i2;\n+insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n {\n   rtx p1, p2;\n \n@@ -1010,10 +984,8 @@ insns_match_p (mode, i1, i2)\n    store the head of the blocks in *F1 and *F2.  */\n \n static int\n-flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n-     int mode ATTRIBUTE_UNUSED;\n-     basic_block bb1, bb2;\n-     rtx *f1, *f2;\n+flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n+\t\t      basic_block bb2, rtx *f1, rtx *f2)\n {\n   rtx i1, i2, last1, last2, afterlast1, afterlast2;\n   int ninsns = 0;\n@@ -1122,10 +1094,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n    We may assume that there exists one edge with a common destination.  */\n \n static bool\n-outgoing_edges_match (mode, bb1, bb2)\n-     int mode;\n-     basic_block bb1;\n-     basic_block bb2;\n+outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n {\n   int nehedges1 = 0, nehedges2 = 0;\n   edge fallthru1 = 0, fallthru2 = 0;\n@@ -1394,9 +1363,7 @@ outgoing_edges_match (mode, bb1, bb2)\n    (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */\n \n static bool\n-try_crossjump_to_edge (mode, e1, e2)\n-     int mode;\n-     edge e1, e2;\n+try_crossjump_to_edge (int mode, edge e1, edge e2)\n {\n   int nmatch;\n   basic_block src1 = e1->src, src2 = e2->src;\n@@ -1580,9 +1547,7 @@ try_crossjump_to_edge (mode, e1, e2)\n    any changes made.  */\n \n static bool\n-try_crossjump_bb (mode, bb)\n-     int mode;\n-     basic_block bb;\n+try_crossjump_bb (int mode, basic_block bb)\n {\n   edge e, e2, nexte2, nexte, fallthru;\n   bool changed;\n@@ -1675,8 +1640,7 @@ try_crossjump_bb (mode, bb)\n    instructions etc.  Return nonzero if changes were made.  */\n \n static bool\n-try_optimize_cfg (mode)\n-     int mode;\n+try_optimize_cfg (int mode)\n {\n   bool changed_overall = false;\n   bool changed;\n@@ -1856,7 +1820,7 @@ try_optimize_cfg (mode)\n /* Delete all unreachable basic blocks.  */\n \n bool\n-delete_unreachable_blocks ()\n+delete_unreachable_blocks (void)\n {\n   bool changed = false;\n   basic_block b, next_bb;\n@@ -1884,8 +1848,7 @@ delete_unreachable_blocks ()\n /* Tidy the CFG by deleting unreachable code and whatnot.  */\n \n bool\n-cleanup_cfg (mode)\n-     int mode;\n+cleanup_cfg (int mode)\n {\n   bool changed = false;\n "}, {"sha": "525289c04f8413ac6901de73280594735a57b1e0", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -34,15 +34,15 @@ extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n struct cfg_hooks *cfg_hooks;\n \n /* Initialization of functions specific to the rtl IR.  */\n-void \n-rtl_register_cfg_hooks ()\n+void\n+rtl_register_cfg_hooks (void)\n {\n   cfg_hooks = &rtl_cfg_hooks;\n }\n \n /* Initialization of functions specific to the rtl IR.  */\n-void \n-cfg_layout_rtl_register_cfg_hooks ()\n+void\n+cfg_layout_rtl_register_cfg_hooks (void)\n {\n   cfg_hooks = &cfg_layout_rtl_cfg_hooks;\n }"}, {"sha": "3097b214da6dc704c4e7dbc250ae0102514d7dd2", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -26,30 +26,30 @@ struct cfg_hooks\n {\n   /* Debugging.  Do not use macros to hook these so they can be called from\n      debugger!  */\n-  int (*cfgh_verify_flow_info)\t        PARAMS ((void));\n-  void (*dump_bb)\t\t\tPARAMS ((basic_block, FILE *));\n+  int (*cfgh_verify_flow_info) (void);\n+  void (*dump_bb) (basic_block, FILE *);\n \n   /* Basic CFG manipulation.  */\n \n   /* Redirect edge E to the given basic block B and update underlying program\n      representation.  Returns false when edge is not easilly redirectable for\n      whatever reason.  */\n-  bool (*redirect_edge_and_branch)      PARAMS ((edge e, basic_block b));\n+  bool (*redirect_edge_and_branch) (edge e, basic_block b);\n \n   /* Same as the above but allows redirecting of fallthru edges.  In that case\n      newly created forwarder basic block is returned.  It aborts when called\n      on abnormal edge.  */\n-  basic_block (*redirect_edge_and_branch_force)PARAMS ((edge, basic_block));\n+  basic_block (*redirect_edge_and_branch_force) (edge, basic_block);\n \n   /* Remove given basic block and all edges possibly pointing into it.  */\n-  void (*delete_block)PARAMS ((basic_block));\n+  void (*delete_block) (basic_block);\n \n   /* Split basic block B after specified instruction I.  */\n-  edge (*split_block)\t\t\tPARAMS ((basic_block b, void * i));\n+  edge (*split_block) (basic_block b, void * i);\n \n   /* Higher level functions representable by primitive operations above if\n      we didn't have some oddities in RTL and Tree representations.  */\n-  basic_block (*cfgh_split_edge)        PARAMS ((edge));\n+  basic_block (*cfgh_split_edge) (edge);\n };\n \n #define redirect_edge_and_branch(e,b)        cfg_hooks->redirect_edge_and_branch (e,b)\n@@ -65,7 +65,7 @@ extern struct cfg_hooks rtl_cfg_hooks;\n extern struct cfg_hooks *cfg_hooks;\n \n /* Declarations.  */\n-extern void rtl_register_cfg_hooks     PARAMS ((void));\n-extern void cfg_layout_rtl_register_cfg_hooks PARAMS ((void));\n+extern void rtl_register_cfg_hooks (void);\n+extern void cfg_layout_rtl_register_cfg_hooks (void);\n \n #endif  /* GCC_CFGHOOKS_H */"}, {"sha": "eea7b94226557480123862178d4b0523d4cb42b3", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -42,25 +42,23 @@ extern struct obstack flow_obstack;\n /* Holds the interesting trailing notes for the function.  */\n rtx cfg_layout_function_footer;\n \n-static rtx skip_insns_after_block\tPARAMS ((basic_block));\n-static void record_effective_endpoints\tPARAMS ((void));\n-static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n-static void fixup_reorder_chain\t\tPARAMS ((void));\n+static rtx skip_insns_after_block (basic_block);\n+static void record_effective_endpoints (void);\n+static rtx label_for_bb (basic_block);\n+static void fixup_reorder_chain (void);\n \n-static void set_block_levels\t\tPARAMS ((tree, int));\n-static void change_scope\t\tPARAMS ((rtx, tree, tree));\n+static void set_block_levels (tree, int);\n+static void change_scope (rtx, tree, tree);\n \n-void verify_insn_chain\t\t\tPARAMS ((void));\n-static void cleanup_unconditional_jumps\tPARAMS ((struct loops *));\n-static void fixup_fallthru_exit_predecessor PARAMS ((void));\n-static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n-static void break_superblocks PARAMS ((void));\n-static tree insn_scope PARAMS ((rtx));\n+void verify_insn_chain (void);\n+static void cleanup_unconditional_jumps (struct loops *);\n+static void fixup_fallthru_exit_predecessor (void);\n+static rtx duplicate_insn_chain (rtx, rtx);\n+static void break_superblocks (void);\n+static tree insn_scope (rtx);\n \f\n rtx\n-unlink_insn_chain (first, last)\n-     rtx first;\n-     rtx last;\n+unlink_insn_chain (rtx first, rtx last)\n {\n   rtx prevfirst = PREV_INSN (first);\n   rtx nextlast = NEXT_INSN (last);\n@@ -83,8 +81,7 @@ unlink_insn_chain (first, last)\n    we return the last one. Otherwise, we return the end of BB.  */\n \n static rtx\n-skip_insns_after_block (bb)\n-     basic_block bb;\n+skip_insns_after_block (basic_block bb)\n {\n   rtx insn, last_insn, next_head, prev;\n \n@@ -171,8 +168,7 @@ skip_insns_after_block (bb)\n /* Locate or create a label for a given basic block.  */\n \n static rtx\n-label_for_bb (bb)\n-     basic_block bb;\n+label_for_bb (basic_block bb)\n {\n   rtx label = bb->head;\n \n@@ -191,7 +187,7 @@ label_for_bb (bb)\n    block, as defined by skip_insns_after_block above.  */\n \n static void\n-record_effective_endpoints ()\n+record_effective_endpoints (void)\n {\n   rtx next_insn = get_insns ();\n   basic_block bb;\n@@ -235,7 +231,7 @@ int epilogue_locator;\n    INSN_LOCATORs.  */\n \n void\n-insn_locators_initialize ()\n+insn_locators_initialize (void)\n {\n   tree block = NULL;\n   tree last_block = NULL;\n@@ -325,9 +321,7 @@ insn_locators_initialize ()\n    found in the block tree.  */\n \n static void\n-set_block_levels (block, level)\n-     tree block;\n-     int level;\n+set_block_levels (tree block, int level)\n {\n   while (block)\n     {\n@@ -339,8 +333,7 @@ set_block_levels (block, level)\n \f\n /* Return sope resulting from combination of S1 and S2.  */\n tree\n-choose_inner_scope (s1, s2)\n-     tree s1, s2;\n+choose_inner_scope (tree s1, tree s2)\n {\n    if (!s1)\n      return s2;\n@@ -354,9 +347,7 @@ choose_inner_scope (s1, s2)\n /* Emit lexical block notes needed to change scope from S1 to S2.  */\n \n static void\n-change_scope (orig_insn, s1, s2)\n-     rtx orig_insn;\n-     tree s1, s2;\n+change_scope (rtx orig_insn, tree s1, tree s2)\n {\n   rtx insn = orig_insn;\n   tree com = NULL_TREE;\n@@ -400,8 +391,7 @@ change_scope (orig_insn, s1, s2)\n \n /* Return lexical scope block insn belong to.  */\n static tree\n-insn_scope (insn)\n-   rtx insn;\n+insn_scope (rtx insn)\n {\n   int max = VARRAY_ACTIVE_SIZE (block_locators_locs);\n   int min = 0;\n@@ -429,8 +419,7 @@ insn_scope (insn)\n \n /* Return line number of the statement that produced this insn.  */\n int\n-insn_line (insn)\n-   rtx insn;\n+insn_line (rtx insn)\n {\n   int max = VARRAY_ACTIVE_SIZE (line_locators_locs);\n   int min = 0;\n@@ -458,8 +447,7 @@ insn_line (insn)\n \n /* Return source file of the statement that produced this insn.  */\n const char *\n-insn_file (insn)\n-   rtx insn;\n+insn_file (rtx insn)\n {\n   int max = VARRAY_ACTIVE_SIZE (file_locators_locs);\n   int min = 0;\n@@ -489,7 +477,7 @@ insn_file (insn)\n    on the scope tree and the newly reordered instructions.  */\n \n void\n-reemit_insn_block_notes ()\n+reemit_insn_block_notes (void)\n {\n   tree cur_block = DECL_INITIAL (cfun->decl);\n   rtx insn, note;\n@@ -512,7 +500,7 @@ reemit_insn_block_notes ()\n \t  this_block = NULL;\n \t  for (i = 0; i < XVECLEN (body, 0); i++)\n \t    this_block = choose_inner_scope (this_block,\n-\t\t\t    \t\t insn_scope (XVECEXP (body, 0, i)));\n+\t\t\t\t\t insn_scope (XVECEXP (body, 0, i)));\n \t}\n       if (! this_block)\n \tcontinue;\n@@ -535,7 +523,7 @@ reemit_insn_block_notes ()\n /* Given a reorder chain, rearrange the code to match.  */\n \n static void\n-fixup_reorder_chain ()\n+fixup_reorder_chain (void)\n {\n   basic_block bb, prev_bb;\n   int index;\n@@ -623,7 +611,7 @@ fixup_reorder_chain ()\n \n \t      /* The degenerated case of conditional jump jumping to the next\n \t\t instruction can happen on target having jumps with side\n-\t\t effects.  \n+\t\t effects.\n \n \t\t Create temporarily the duplicated edge representing branch.\n \t\t It will get unidentified by force_nonfallthru_and_redirect\n@@ -776,7 +764,7 @@ fixup_reorder_chain ()\n    3. Check that get_last_insn () returns the actual end of chain.  */\n \n void\n-verify_insn_chain ()\n+verify_insn_chain (void)\n {\n   rtx x, prevx, nextx;\n   int insn_cnt1, insn_cnt2;\n@@ -807,8 +795,7 @@ verify_insn_chain ()\n    dominators.  */\n \n static void\n-cleanup_unconditional_jumps (loops)\n-     struct loops *loops;\n+cleanup_unconditional_jumps (struct loops *loops)\n {\n   basic_block bb;\n \n@@ -885,7 +872,7 @@ cleanup_unconditional_jumps (loops)\n /* The block falling through to exit must be the last one in the\n    reordered chain.  Ensure that this condition is met.  */\n static void\n-fixup_fallthru_exit_predecessor ()\n+fixup_fallthru_exit_predecessor (void)\n {\n   edge e;\n   basic_block bb = NULL;\n@@ -913,8 +900,7 @@ fixup_fallthru_exit_predecessor ()\n /* Return true in case it is possible to duplicate the basic block BB.  */\n \n bool\n-cfg_layout_can_duplicate_bb_p (bb)\n-     basic_block bb;\n+cfg_layout_can_duplicate_bb_p (basic_block bb)\n {\n   edge s;\n \n@@ -951,8 +937,7 @@ cfg_layout_can_duplicate_bb_p (bb)\n }\n \n static rtx\n-duplicate_insn_chain (from, to)\n-     rtx from, to;\n+duplicate_insn_chain (rtx from, rtx to)\n {\n   rtx insn, last;\n \n@@ -1047,9 +1032,7 @@ duplicate_insn_chain (from, to)\n /* Create a duplicate of the basic block BB and redirect edge E into it.  */\n \n basic_block\n-cfg_layout_duplicate_bb (bb, e)\n-     basic_block bb;\n-     edge e;\n+cfg_layout_duplicate_bb (basic_block bb, edge e)\n {\n   rtx insn;\n   edge s, n;\n@@ -1141,8 +1124,7 @@ cfg_layout_duplicate_bb (bb, e)\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n void\n-cfg_layout_initialize (loops)\n-     struct loops *loops;\n+cfg_layout_initialize (struct loops *loops)\n {\n   /* Our algorithm depends on fact that there are now dead jumptables\n      around the code.  */\n@@ -1156,7 +1138,7 @@ cfg_layout_initialize (loops)\n \n /* Splits superblocks.  */\n static void\n-break_superblocks ()\n+break_superblocks (void)\n {\n   sbitmap superblocks;\n   int i, need;\n@@ -1187,7 +1169,7 @@ break_superblocks ()\n    compensation code, rebuild scope forest.  */\n \n void\n-cfg_layout_finalize ()\n+cfg_layout_finalize (void)\n {\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();"}, {"sha": "1ab3e1f956ab560858e888645b09818bc7d7f382", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -37,9 +37,9 @@ typedef struct reorder_block_def\n \n extern rtx cfg_layout_function_footer;\n \n-extern void cfg_layout_initialize\tPARAMS ((struct loops *));\n-extern void cfg_layout_finalize\t\tPARAMS ((void));\n-extern bool cfg_layout_can_duplicate_bb_p PARAMS ((basic_block));\n-extern basic_block cfg_layout_duplicate_bb PARAMS ((basic_block, edge));\n-extern void insn_locators_initialize\tPARAMS ((void));\n-extern void reemit_insn_block_notes\tPARAMS ((void));\n+extern void cfg_layout_initialize (struct loops *);\n+extern void cfg_layout_finalize (void);\n+extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n+extern basic_block cfg_layout_duplicate_bb (basic_block, edge);\n+extern void insn_locators_initialize (void);\n+extern void reemit_insn_block_notes (void);"}, {"sha": "4bb165f9ccf52fdff5231a0a7d8a9a3dc33ae972", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 63, "deletions": 128, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,5 +1,5 @@\n /* Natural loop discovery code for GNU compiler.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -33,29 +33,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    considered to belong to inner loop with same header.  */\n #define HEAVY_EDGE_RATIO 8\n \n-static void flow_loops_cfg_dump\t\tPARAMS ((const struct loops *,\n-\t\t\t\t\t\t FILE *));\n-static void flow_loop_entry_edges_find\tPARAMS ((struct loop *));\n-static void flow_loop_exit_edges_find\tPARAMS ((struct loop *));\n-static int flow_loop_nodes_find\t\tPARAMS ((basic_block, struct loop *));\n-static void flow_loop_pre_header_scan\tPARAMS ((struct loop *));\n-static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n-\t\t\t\t\t\t      dominance_info));\n-static int flow_loop_level_compute\tPARAMS ((struct loop *));\n-static int flow_loops_level_compute\tPARAMS ((struct loops *));\n-static void establish_preds\t\tPARAMS ((struct loop *));\n-static basic_block make_forwarder_block PARAMS ((basic_block, int, int,\n-\t\t\t\t\t\t edge, int));\n-static void canonicalize_loop_headers   PARAMS ((void));\n-static bool glb_enum_p PARAMS ((basic_block, void *));\n-static void redirect_edge_with_latch_update PARAMS ((edge, basic_block));\n+static void flow_loops_cfg_dump (const struct loops *, FILE *);\n+static void flow_loop_entry_edges_find (struct loop *);\n+static void flow_loop_exit_edges_find (struct loop *);\n+static int flow_loop_nodes_find (basic_block, struct loop *);\n+static void flow_loop_pre_header_scan (struct loop *);\n+static basic_block flow_loop_pre_header_find (basic_block, dominance_info);\n+static int flow_loop_level_compute (struct loop *);\n+static int flow_loops_level_compute (struct loops *);\n+static void establish_preds (struct loop *);\n+static basic_block make_forwarder_block (basic_block, int, int, edge, int);\n+static void canonicalize_loop_headers (void);\n+static bool glb_enum_p (basic_block, void *);\n+static void redirect_edge_with_latch_update (edge, basic_block);\n \f\n /* Dump loop related CFG information.  */\n \n static void\n-flow_loops_cfg_dump (loops, file)\n-     const struct loops *loops;\n-     FILE *file;\n+flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n {\n   int i;\n   basic_block bb;\n@@ -97,9 +92,7 @@ flow_loops_cfg_dump (loops, file)\n /* Return nonzero if the nodes of LOOP are a subset of OUTER.  */\n \n bool\n-flow_loop_nested_p (outer, loop)\n-     const struct loop *outer;\n-     const struct loop *loop;\n+flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n {\n   return loop->depth > outer->depth\n \t && loop->pred[outer->depth] == outer;\n@@ -109,11 +102,9 @@ flow_loop_nested_p (outer, loop)\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n void\n-flow_loop_dump (loop, file, loop_dump_aux, verbose)\n-     const struct loop *loop;\n-     FILE *file;\n-     void (*loop_dump_aux) PARAMS((const struct loop *, FILE *, int));\n-     int verbose;\n+flow_loop_dump (const struct loop *loop, FILE *file,\n+\t\tvoid (*loop_dump_aux) (const struct loop *, FILE *, int),\n+\t\tint verbose)\n {\n   basic_block *bbs;\n   unsigned i;\n@@ -154,11 +145,7 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n void\n-flow_loops_dump (loops, file, loop_dump_aux, verbose)\n-     const struct loops *loops;\n-     FILE *file;\n-     void (*loop_dump_aux) PARAMS((const struct loop *, FILE *, int));\n-     int verbose;\n+flow_loops_dump (const struct loops *loops, FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n {\n   int i;\n   int num_loops;\n@@ -186,8 +173,7 @@ flow_loops_dump (loops, file, loop_dump_aux, verbose)\n \n /* Free data allocated for LOOP.  */\n void\n-flow_loop_free (loop)\n-     struct loop *loop;\n+flow_loop_free (struct loop *loop)\n {\n   if (loop->pre_header_edges)\n     free (loop->pre_header_edges);\n@@ -203,8 +189,7 @@ flow_loop_free (loop)\n /* Free all the memory allocated for LOOPS.  */\n \n void\n-flow_loops_free (loops)\n-     struct loops *loops;\n+flow_loops_free (struct loops *loops)\n {\n   if (loops->parray)\n     {\n@@ -240,9 +225,8 @@ flow_loops_free (loops)\n \n /* Find the entry edges into the LOOP.  */\n \n-static void \n-flow_loop_entry_edges_find (loop)\n-     struct loop *loop;\n+static void\n+flow_loop_entry_edges_find (struct loop *loop)\n {\n   edge e;\n   int num_entries;\n@@ -272,8 +256,7 @@ flow_loop_entry_edges_find (loop)\n /* Find the exit edges from the LOOP.  */\n \n static void\n-flow_loop_exit_edges_find (loop)\n-     struct loop *loop;\n+flow_loop_exit_edges_find (struct loop *loop)\n {\n   edge e;\n   basic_block node, *bbs;\n@@ -328,9 +311,7 @@ flow_loop_exit_edges_find (loop)\n    Return the number of nodes within the loop.  */\n \n static int\n-flow_loop_nodes_find (header, loop)\n-     basic_block header;\n-     struct loop *loop;\n+flow_loop_nodes_find (basic_block header, struct loop *loop)\n {\n   basic_block *stack;\n   int sp;\n@@ -347,14 +328,14 @@ flow_loop_nodes_find (header, loop)\n       stack[sp++] = loop->latch;\n       loop->latch->loop_father = loop;\n       loop->latch->loop_depth = loop->depth;\n- \n+\n       while (sp)\n \t{\n \t  basic_block node;\n \t  edge e;\n \n \t  node = stack[--sp];\n-      \n+\n \t  for (e = node->pred; e; e = e->pred_next)\n \t    {\n \t      basic_block ancestor = e->src;\n@@ -378,8 +359,7 @@ flow_loop_nodes_find (header, loop)\n    the edges along the trace from the root node to the loop header.  */\n \n static void\n-flow_loop_pre_header_scan (loop)\n-     struct loop *loop;\n+flow_loop_pre_header_scan (struct loop *loop)\n {\n   int num;\n   basic_block ebb;\n@@ -415,9 +395,7 @@ flow_loop_pre_header_scan (loop)\n    there is no pre-header.  */\n \n static basic_block\n-flow_loop_pre_header_find (header, dom)\n-     basic_block header;\n-     dominance_info dom;\n+flow_loop_pre_header_find (basic_block header, dominance_info dom)\n {\n   basic_block pre_header;\n   edge e;\n@@ -448,8 +426,7 @@ flow_loop_pre_header_find (header, dom)\n }\n \n static void\n-establish_preds (loop)\n-     struct loop *loop;\n+establish_preds (struct loop *loop)\n {\n   struct loop *ploop, *father = loop->outer;\n \n@@ -469,9 +446,7 @@ establish_preds (loop)\n    pred field will be initialized correctly.  */\n \n void\n-flow_loop_tree_node_add (father, loop)\n-     struct loop *father;\n-     struct loop *loop;\n+flow_loop_tree_node_add (struct loop *father, struct loop *loop)\n {\n   loop->next = father->inner;\n   father->inner = loop;\n@@ -483,8 +458,7 @@ flow_loop_tree_node_add (father, loop)\n /* Remove LOOP from the loop hierarchy tree.  */\n \n void\n-flow_loop_tree_node_remove (loop)\n-     struct loop *loop;\n+flow_loop_tree_node_remove (struct loop *loop)\n {\n   struct loop *prev, *father;\n \n@@ -509,8 +483,7 @@ flow_loop_tree_node_remove (loop)\n    for the natural loop specified by LOOP.  Returns the loop level.  */\n \n static int\n-flow_loop_level_compute (loop)\n-     struct loop *loop;\n+flow_loop_level_compute (struct loop *loop)\n {\n   struct loop *inner;\n   int level = 1;\n@@ -540,8 +513,7 @@ flow_loop_level_compute (loop)\n    level.  */\n \n static int\n-flow_loops_level_compute (loops)\n-     struct loops *loops;\n+flow_loops_level_compute (struct loops *loops)\n {\n   return flow_loop_level_compute (loops->tree_root);\n }\n@@ -550,10 +522,7 @@ flow_loops_level_compute (loops)\n    about it specified by FLAGS.  */\n \n int\n-flow_loop_scan (loops, loop, flags)\n-     struct loops *loops;\n-     struct loop *loop;\n-     int flags;\n+flow_loop_scan (struct loops *loops, struct loop *loop, int flags)\n {\n   if (flags & LOOP_ENTRY_EDGES)\n     {\n@@ -588,9 +557,7 @@ flow_loop_scan (loops, loop, flags)\n \n /* Redirect edge and update latch and header info.  */\n static void\n-redirect_edge_with_latch_update (e, to)\n-     edge e;\n-     basic_block to;\n+redirect_edge_with_latch_update (edge e, basic_block to)\n {\n   basic_block jump;\n \n@@ -612,13 +579,7 @@ redirect_edge_with_latch_update (e, to)\n    part.  */\n \n static basic_block\n-make_forwarder_block (bb, redirect_latch, redirect_nonlatch, except,\n-\t\t      conn_latch)\n-     basic_block bb;\n-     int redirect_latch;\n-     int redirect_nonlatch;\n-     edge except;\n-     int conn_latch;\n+make_forwarder_block (basic_block bb, int redirect_latch, int redirect_nonlatch, edge except, int conn_latch)\n {\n   edge e, next_e, fallthru;\n   basic_block dummy;\n@@ -664,12 +625,12 @@ make_forwarder_block (bb, redirect_latch, redirect_nonlatch, except,\n \n /* Takes care of merging natural loops with shared headers.  */\n static void\n-canonicalize_loop_headers ()\n+canonicalize_loop_headers (void)\n {\n   dominance_info dom;\n   basic_block header;\n   edge e;\n-  \n+\n   /* Compute the dominators.  */\n   dom = calculate_dominance_info (CDI_DOMINATORS);\n \n@@ -709,7 +670,7 @@ canonicalize_loop_headers ()\n       /* We could not redirect edges freely here. On the other hand,\n \t we can simply split the edge from entry block.  */\n       bb = split_edge (ENTRY_BLOCK_PTR->succ);\n- \n+\n       alloc_aux_for_edge (bb->succ, sizeof (int));\n       LATCH_EDGE (bb->succ) = 0;\n       alloc_aux_for_block (bb, sizeof (int));\n@@ -776,9 +737,7 @@ canonicalize_loop_headers ()\n    loops found.  */\n \n int\n-flow_loops_find (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+flow_loops_find (struct loops *loops, int flags)\n {\n   int i;\n   int b;\n@@ -822,7 +781,7 @@ flow_loops_find (loops, flags)\n   FOR_EACH_BB (header)\n     {\n       int more_latches = 0;\n-     \n+\n       header->loop_depth = 0;\n \n       /* If we have an abnormal predecessor, do not consider the\n@@ -906,7 +865,7 @@ flow_loops_find (loops, flags)\n \t    continue;\n \n \t  header = BASIC_BLOCK (rc_order[b]);\n-\t  \n+\n \t  loop = loops->parray[num_loops] = xcalloc (1, sizeof (struct loop));\n \n \t  loop->header = header;\n@@ -961,9 +920,7 @@ flow_loops_find (loops, flags)\n    specified by LOOPS.  */\n \n int\n-flow_loops_update (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+flow_loops_update (struct loops *loops, int flags)\n {\n   /* One day we may want to update the current loop data.  For now\n      throw away the old stuff and rebuild what we need.  */\n@@ -975,9 +932,7 @@ flow_loops_update (loops, flags)\n \n /* Return nonzero if basic block BB belongs to LOOP.  */\n bool\n-flow_bb_inside_loop_p (loop, bb)\n-     const struct loop *loop;\n-     const basic_block bb;\n+flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n {\n   struct loop *source_loop;\n \n@@ -991,9 +946,7 @@ flow_bb_inside_loop_p (loop, bb)\n /* Return nonzero if edge E enters header of LOOP from outside of LOOP.  */\n \n bool\n-flow_loop_outside_edge_p (loop, e)\n-     const struct loop *loop;\n-     edge e;\n+flow_loop_outside_edge_p (const struct loop *loop, edge e)\n {\n   if (e->dest != loop->header)\n     abort ();\n@@ -1002,17 +955,14 @@ flow_loop_outside_edge_p (loop, e)\n \n /* Enumeration predicate for get_loop_body.  */\n static bool\n-glb_enum_p (bb, glb_header)\n-     basic_block bb;\n-     void *glb_header;\n+glb_enum_p (basic_block bb, void *glb_header)\n {\n   return bb != (basic_block) glb_header;\n }\n \n /* Gets basic blocks of a loop.  */\n basic_block *\n-get_loop_body (loop)\n-     const struct loop *loop;\n+get_loop_body (const struct loop *loop)\n {\n   basic_block *tovisit, bb;\n   unsigned tv = 0;\n@@ -1046,9 +996,7 @@ get_loop_body (loop)\n \n /* Gets exit edges of a LOOP, returning their number in N_EDGES.  */\n edge *\n-get_loop_exit_edges (loop, n_edges)\n-     const struct loop *loop;\n-     unsigned *n_edges;\n+get_loop_exit_edges (const struct loop *loop, unsigned int *n_edges)\n {\n   edge *edges, e;\n   unsigned i, n;\n@@ -1077,12 +1025,10 @@ get_loop_exit_edges (loop, n_edges)\n \n /* Adds basic block BB to LOOP.  */\n void\n-add_bb_to_loop (bb, loop)\n-     basic_block bb;\n-     struct loop *loop;\n- {\n+add_bb_to_loop (basic_block bb, struct loop *loop)\n+{\n    int i;\n- \n+\n    bb->loop_father = loop;\n    bb->loop_depth = loop->depth;\n    loop->num_nodes++;\n@@ -1092,9 +1038,8 @@ add_bb_to_loop (bb, loop)\n \n /* Remove basic block BB from loops.  */\n void\n-remove_bb_from_loops (bb)\n-     basic_block bb;\n- {\n+remove_bb_from_loops (basic_block bb)\n+{\n    int i;\n    struct loop *loop = bb->loop_father;\n \n@@ -1107,13 +1052,11 @@ remove_bb_from_loops (bb)\n \n /* Finds nearest common ancestor in loop tree for given loops.  */\n struct loop *\n-find_common_loop (loop_s, loop_d)\n-    struct loop *loop_s;\n-    struct loop *loop_d;\n+find_common_loop (struct loop *loop_s, struct loop *loop_d)\n {\n   if (!loop_s) return loop_d;\n   if (!loop_d) return loop_s;\n-  \n+\n   if (loop_s->depth < loop_d->depth)\n     loop_d = loop_d->pred[loop_s->depth];\n   else if (loop_s->depth > loop_d->depth)\n@@ -1129,9 +1072,7 @@ find_common_loop (loop_s, loop_d)\n \n /* Cancels the LOOP; it must be innermost one.  */\n void\n-cancel_loop (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+cancel_loop (struct loops *loops, struct loop *loop)\n {\n   basic_block *bbs;\n   unsigned i;\n@@ -1156,9 +1097,7 @@ cancel_loop (loops, loop)\n \n /* Cancels LOOP and all its subloops.  */\n void\n-cancel_loop_tree (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+cancel_loop_tree (struct loops *loops, struct loop *loop)\n {\n   while (loop->inner)\n     cancel_loop_tree (loops, loop->inner);\n@@ -1173,8 +1112,7 @@ cancel_loop_tree (loops, loop)\n      -- irreducible loops are correctly marked\n   */\n void\n-verify_loop_structure (loops)\n-     struct loops *loops;\n+verify_loop_structure (struct loops *loops)\n {\n   unsigned *sizes, i, j;\n   sbitmap irreds;\n@@ -1283,7 +1221,7 @@ verify_loop_structure (loops)\n \t    RESET_BIT (irreds, bb->index);\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n-      \t      e->flags |= EDGE_ALL_FLAGS + 1;\n+\t      e->flags |= EDGE_ALL_FLAGS + 1;\n \t}\n \n       /* Recount it.  */\n@@ -1332,8 +1270,7 @@ verify_loop_structure (loops)\n \n /* Returns latch edge of LOOP.  */\n edge\n-loop_latch_edge (loop)\n-     const struct loop *loop;\n+loop_latch_edge (const struct loop *loop)\n {\n   edge e;\n \n@@ -1345,8 +1282,7 @@ loop_latch_edge (loop)\n \n /* Returns preheader edge of LOOP.  */\n edge\n-loop_preheader_edge (loop)\n-     const struct loop *loop;\n+loop_preheader_edge (const struct loop *loop)\n {\n   edge e;\n \n@@ -1355,4 +1291,3 @@ loop_preheader_edge (loop)\n \n   return e;\n }\n-"}, {"sha": "d3ab8e8739b1ac84e124110110f1108cbba9ee5e", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -255,90 +255,81 @@ struct loops\n #define LOOP_ALL\t       15\t/* All of the above  */\n \n /* Loop recognition.  */\n-extern int flow_loops_find\t\tPARAMS ((struct loops *, int flags));\n-extern int flow_loops_update\t\tPARAMS ((struct loops *, int flags));\n-extern void flow_loops_free\t\tPARAMS ((struct loops *));\n-extern void flow_loops_dump\t\tPARAMS ((const struct loops *, FILE *,\n-\t\t\t\t\t\tvoid (*)(const struct loop *,\n-\t\t\t\t\t\tFILE *, int), int));\n-extern void flow_loop_dump\t\tPARAMS ((const struct loop *, FILE *,\n-\t\t\t\t\t\tvoid (*)(const struct loop *,\n-\t\t\t\t\t\tFILE *, int), int));\n-extern int flow_loop_scan\t\tPARAMS ((struct loops *,\n-\t\t\t\t\t\tstruct loop *, int));\n-extern void flow_loop_free\t\tPARAMS ((struct loop *));\n-void mark_irreducible_loops\t\tPARAMS ((struct loops *));\n+extern int flow_loops_find (struct loops *, int flags);\n+extern int flow_loops_update (struct loops *, int flags);\n+extern void flow_loops_free (struct loops *);\n+extern void flow_loops_dump (const struct loops *, FILE *,\n+\t\t\t     void (*)(const struct loop *, FILE *, int), int);\n+extern void flow_loop_dump (const struct loop *, FILE *,\n+\t\t\t    void (*)(const struct loop *, FILE *, int), int);\n+extern int flow_loop_scan (struct loops *, struct loop *, int);\n+extern void flow_loop_free (struct loop *);\n+void mark_irreducible_loops (struct loops *);\n \n /* Loop datastructure manipulation/querying.  */\n-extern void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n-extern void flow_loop_tree_node_remove\tPARAMS ((struct loop *));\n-extern bool flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n-extern bool flow_loop_nested_p\t\tPARAMS ((const struct loop *,\n-\t\t\t\t\t\tconst struct loop *));\n-extern bool flow_bb_inside_loop_p\tPARAMS ((const struct loop *,\n-\t\t\t\t\t\tconst basic_block));\n-extern struct loop * find_common_loop\tPARAMS ((struct loop *, struct loop *));\n-extern int num_loop_insns\t\tPARAMS ((struct loop *));\n-extern int average_num_loop_insns\tPARAMS ((struct loop *));\n+extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n+extern void flow_loop_tree_node_remove (struct loop *);\n+extern bool flow_loop_outside_edge_p (const struct loop *, edge);\n+extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n+extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n+extern struct loop * find_common_loop (struct loop *, struct loop *);\n+extern int num_loop_insns (struct loop *);\n+extern int average_num_loop_insns (struct loop *);\n \n /* Loops & cfg manipulation.  */\n-extern basic_block *get_loop_body\tPARAMS ((const struct loop *));\n-extern edge *get_loop_exit_edges\tPARAMS ((const struct loop *, unsigned *));\n+extern basic_block *get_loop_body (const struct loop *);\n+extern edge *get_loop_exit_edges (const struct loop *, unsigned *);\n \n-extern edge loop_preheader_edge\t\tPARAMS ((const struct loop *));\n-extern edge loop_latch_edge\t\tPARAMS ((const struct loop *));\n+extern edge loop_preheader_edge (const struct loop *);\n+extern edge loop_latch_edge (const struct loop *);\n \n-extern void add_bb_to_loop\t\tPARAMS ((basic_block, struct loop *));\n-extern void remove_bb_from_loops\tPARAMS ((basic_block));\n+extern void add_bb_to_loop (basic_block, struct loop *);\n+extern void remove_bb_from_loops (basic_block);\n \n-extern void cancel_loop\t\t\tPARAMS ((struct loops *, struct loop *));\n-extern void cancel_loop_tree\t\tPARAMS ((struct loops *, struct loop *));\n+extern void cancel_loop (struct loops *, struct loop *);\n+extern void cancel_loop_tree (struct loops *, struct loop *);\n \n-extern basic_block loop_split_edge_with PARAMS ((edge, rtx, struct loops *));\n-extern int fix_loop_placement\t\tPARAMS ((struct loop *));\n+extern basic_block loop_split_edge_with (edge, rtx, struct loops *);\n+extern int fix_loop_placement (struct loop *);\n \n enum\n {\n   CP_SIMPLE_PREHEADERS = 1,\n   CP_INSIDE_CFGLAYOUT = 2\n };\n \n-extern void create_preheaders\t\tPARAMS ((struct loops *, int));\n-extern void force_single_succ_latches\tPARAMS ((struct loops *));\n+extern void create_preheaders (struct loops *, int);\n+extern void force_single_succ_latches (struct loops *);\n \n-extern void verify_loop_structure\tPARAMS ((struct loops *));\n+extern void verify_loop_structure (struct loops *);\n \n /* Loop analysis.  */\n-extern bool simple_loop_p\t\tPARAMS ((struct loops *, struct loop *,\n-\t\t\t\t\t\tstruct loop_desc *));\n-extern rtx count_loop_iterations\tPARAMS ((struct loop_desc *, rtx, rtx));\n-extern bool just_once_each_iteration_p\tPARAMS ((struct loops *,struct loop *,\n-\t\t\t\t\t\t basic_block));\n-extern unsigned expected_loop_iterations PARAMS ((const struct loop *));\n+extern bool simple_loop_p (struct loops *, struct loop *, struct loop_desc *);\n+extern rtx count_loop_iterations (struct loop_desc *, rtx, rtx);\n+extern bool just_once_each_iteration_p (struct loops *,struct loop *,\n+\t\t\t\t\tbasic_block);\n+extern unsigned expected_loop_iterations (const struct loop *);\n \n /* Loop manipulation.  */\n-extern bool can_duplicate_loop_p\tPARAMS ((struct loop *loop));\n+extern bool can_duplicate_loop_p (struct loop *loop);\n \n #define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n \t\t\t\t\t   duplicate_loop_to_header_edge.  */\n \n-extern int duplicate_loop_to_header_edge PARAMS ((struct loop *, edge,\n-\t\t\t\t\t\tstruct loops *, unsigned,\n-\t\t\t\t\t\tsbitmap, edge, edge *,\n-\t\t\t\t\t\tunsigned *, int));\n-extern struct loop *loopify\t\tPARAMS ((struct loops *, edge,\n-\t\t\t\t\t\tedge, basic_block));\n-extern void unloop\t\t\tPARAMS ((struct loops *, struct loop *));\n-extern bool remove_path\t\t\tPARAMS ((struct loops *, edge));\n-extern edge split_loop_bb\t\tPARAMS ((struct loops *, basic_block,\n-\t\t\t\t\t\trtx));\n+extern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n+\t\t\t\t\t  unsigned, sbitmap, edge, edge *,\n+\t\t\t\t\t  unsigned *, int);\n+extern struct loop *loopify (struct loops *, edge, edge, basic_block);\n+extern void unloop (struct loops *, struct loop *);\n+extern bool remove_path (struct loops *, edge);\n+extern edge split_loop_bb (struct loops *, basic_block, rtx);\n \n /* Loop optimizer initialization.  */\n-extern struct loops *loop_optimizer_init PARAMS ((FILE *));\n-extern void loop_optimizer_finalize\tPARAMS ((struct loops *, FILE *));\n+extern struct loops *loop_optimizer_init (FILE *);\n+extern void loop_optimizer_finalize (struct loops *, FILE *);\n \n /* Optimization passes.  */\n-extern void unswitch_loops\t\tPARAMS ((struct loops *));\n+extern void unswitch_loops (struct loops *);\n \n enum\n {\n@@ -347,4 +338,4 @@ enum\n   UAP_UNROLL_ALL = 4\t/* Enables peeling of all loops.  */\n };\n \n-extern void unroll_and_peel_loops\tPARAMS ((struct loops *, int));\n+extern void unroll_and_peel_loops (struct loops *, int);"}, {"sha": "be5b82effcf1193d150cc76734e925f7771d0c1d", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 52, "deletions": 103, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,5 +1,5 @@\n /* Natural loop analysis code for GNU compiler.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -30,33 +30,27 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n \n struct unmark_altered_insn_data;\n-static void unmark_altered\t PARAMS ((rtx, rtx, regset));\n-static void blocks_invariant_registers PARAMS ((basic_block *, int, regset));\n-static void unmark_altered_insn\t PARAMS ((rtx, rtx, struct unmark_altered_insn_data *));\n-static void blocks_single_set_registers PARAMS ((basic_block *, int, rtx *));\n-static int invariant_rtx_wrto_regs_p_helper PARAMS ((rtx *, regset));\n-static bool invariant_rtx_wrto_regs_p PARAMS ((rtx, regset));\n-static rtx test_for_iteration PARAMS ((struct loop_desc *desc,\n-\t\t\t\t       unsigned HOST_WIDE_INT));\n-static bool constant_iterations PARAMS ((struct loop_desc *,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t bool *));\n-static bool simple_loop_exit_p PARAMS ((struct loops *, struct loop *,\n-\t\t\t\t\tedge, regset, rtx *,\n-\t\t\t\t\tstruct loop_desc *));\n-static rtx variable_initial_value PARAMS ((rtx, regset, rtx, rtx *));\n-static rtx variable_initial_values PARAMS ((edge, rtx));\n-static bool simple_condition_p PARAMS ((struct loop *, rtx,\n-\t\t\t\t\tregset, struct loop_desc *));\n-static basic_block simple_increment PARAMS ((struct loops *, struct loop *,\n-\t\t\t\t\t     rtx *, struct loop_desc *));\n+static void unmark_altered (rtx, rtx, regset);\n+static void blocks_invariant_registers (basic_block *, int, regset);\n+static void unmark_altered_insn (rtx, rtx, struct unmark_altered_insn_data *);\n+static void blocks_single_set_registers (basic_block *, int, rtx *);\n+static int invariant_rtx_wrto_regs_p_helper (rtx *, regset);\n+static bool invariant_rtx_wrto_regs_p (rtx, regset);\n+static rtx test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT);\n+static bool constant_iterations (struct loop_desc *, unsigned HOST_WIDE_INT *,\n+\t\t\t\t bool *);\n+static bool simple_loop_exit_p (struct loops *, struct loop *, edge, regset,\n+\t\t\t\trtx *, struct loop_desc *);\n+static rtx variable_initial_value (rtx, regset, rtx, rtx *);\n+static rtx variable_initial_values (edge, rtx);\n+static bool simple_condition_p (struct loop *, rtx, regset,\n+\t\t\t\tstruct loop_desc *);\n+static basic_block simple_increment (struct loops *, struct loop *, rtx *,\n+\t\t\t\t     struct loop_desc *);\n \n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n bool\n-just_once_each_iteration_p (loops, loop, bb)\n-     struct loops *loops;\n-     struct loop *loop;\n-     basic_block bb;\n+just_once_each_iteration_p (struct loops *loops, struct loop *loop, basic_block bb)\n {\n   /* It must be executed at least once each iteration.  */\n   if (!dominated_by_p (loops->cfg.dom, loop->latch, bb))\n@@ -76,10 +70,7 @@ just_once_each_iteration_p (loops, loop, bb)\n \n /* Unmarks modified registers; helper to blocks_invariant_registers.  */\n static void\n-unmark_altered (what, by, regs)\n-     rtx what;\n-     rtx by ATTRIBUTE_UNUSED;\n-     regset regs;\n+unmark_altered (rtx what, rtx by ATTRIBUTE_UNUSED, regset regs)\n {\n   if (GET_CODE (what) == SUBREG)\n     what = SUBREG_REG (what);\n@@ -90,10 +81,7 @@ unmark_altered (what, by, regs)\n \n /* Marks registers that are invariant inside blocks BBS.  */\n static void\n-blocks_invariant_registers (bbs, nbbs, regs)\n-     basic_block *bbs;\n-     int nbbs;\n-     regset regs;\n+blocks_invariant_registers (basic_block *bbs, int nbbs, regset regs)\n {\n   rtx insn;\n   int i;\n@@ -118,10 +106,8 @@ struct unmark_altered_insn_data\n };\n \n static void\n-unmark_altered_insn (what, by, data)\n-     rtx what;\n-     rtx by ATTRIBUTE_UNUSED;\n-     struct unmark_altered_insn_data *data;\n+unmark_altered_insn (rtx what, rtx by ATTRIBUTE_UNUSED,\n+\t\t     struct unmark_altered_insn_data *data)\n {\n   int rn;\n \n@@ -138,10 +124,7 @@ unmark_altered_insn (what, by, data)\n /* Marks registers that have just single simple set in BBS; the relevant\n    insn is returned in REGS.  */\n static void\n-blocks_single_set_registers (bbs, nbbs, regs)\n-     basic_block *bbs;\n-     int nbbs;\n-     rtx *regs;\n+blocks_single_set_registers (basic_block *bbs, int nbbs, rtx *regs)\n {\n   rtx insn;\n   int i;\n@@ -180,9 +163,7 @@ blocks_single_set_registers (bbs, nbbs, regs)\n \n /* Helper for invariant_rtx_wrto_regs_p.  */\n static int\n-invariant_rtx_wrto_regs_p_helper (expr, invariant_regs)\n-     rtx *expr;\n-     regset invariant_regs;\n+invariant_rtx_wrto_regs_p_helper (rtx *expr, regset invariant_regs)\n {\n   switch (GET_CODE (*expr))\n     {\n@@ -216,9 +197,7 @@ invariant_rtx_wrto_regs_p_helper (expr, invariant_regs)\n \n /* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant.  */\n static bool\n-invariant_rtx_wrto_regs_p (expr, invariant_regs)\n-     rtx expr;\n-     regset invariant_regs;\n+invariant_rtx_wrto_regs_p (rtx expr, regset invariant_regs)\n {\n   return !for_each_rtx (&expr, (rtx_function) invariant_rtx_wrto_regs_p_helper,\n \t\t\tinvariant_regs);\n@@ -228,11 +207,8 @@ invariant_rtx_wrto_regs_p (expr, invariant_regs)\n    is register and the other one is invariant in the LOOP. Fills var, lim\n    and cond fields in DESC.  */\n static bool\n-simple_condition_p (loop, condition, invariant_regs, desc)\n-     struct loop *loop ATTRIBUTE_UNUSED;\n-     rtx condition;\n-     regset invariant_regs;\n-     struct loop_desc *desc;\n+simple_condition_p (struct loop *loop ATTRIBUTE_UNUSED, rtx condition,\n+\t\t    regset invariant_regs, struct loop_desc *desc)\n {\n   rtx op0, op1;\n \n@@ -262,7 +238,7 @@ simple_condition_p (loop, condition, invariant_regs, desc)\n   /* One of operands must be a simple register.  */\n   op0 = XEXP (condition, 0);\n   op1 = XEXP (condition, 1);\n-  \n+\n   /* One of operands must be invariant.  */\n   if (invariant_rtx_wrto_regs_p (op0, invariant_regs))\n     {\n@@ -296,11 +272,8 @@ simple_condition_p (loop, condition, invariant_regs, desc)\n    iteration.  Fills in DESC->stride and returns block in that DESC->var is\n    modified.  */\n static basic_block\n-simple_increment (loops, loop, simple_increment_regs, desc)\n-     struct loops *loops;\n-     struct loop *loop;\n-     rtx *simple_increment_regs;\n-     struct loop_desc *desc;\n+simple_increment (struct loops *loops, struct loop *loop,\n+\t\t  rtx *simple_increment_regs, struct loop_desc *desc)\n {\n   rtx mod_insn, set, set_src, set_add;\n   basic_block mod_bb;\n@@ -344,11 +317,7 @@ simple_increment (loops, loop, simple_increment_regs, desc)\n    wrto INVARIANT_REGS.  If SET_INSN is not NULL, insn in that var is set is\n    placed here.  */\n static rtx\n-variable_initial_value (insn, invariant_regs, var, set_insn)\n-     rtx insn;\n-     regset invariant_regs;\n-     rtx var;\n-     rtx *set_insn;\n+variable_initial_value (rtx insn, regset invariant_regs, rtx var, rtx *set_insn)\n {\n   basic_block bb;\n   rtx set;\n@@ -373,7 +342,7 @@ variable_initial_value (insn, invariant_regs, var, set_insn)\n \t  rtx set_dest;\n \t  rtx val;\n \t  rtx note;\n-          \n+\n \t  set = single_set (insn);\n \t  if (!set)\n \t    return NULL;\n@@ -407,9 +376,7 @@ variable_initial_value (insn, invariant_regs, var, set_insn)\n \n /* Returns list of definitions of initial value of VAR at Edge.  */\n static rtx\n-variable_initial_values (e, var)\n-     edge e;\n-     rtx var;\n+variable_initial_values (edge e, rtx var)\n {\n   rtx set_insn, list;\n   regset invariant_regs;\n@@ -437,10 +404,8 @@ variable_initial_values (e, var)\n /* Counts constant number of iterations of the loop described by DESC;\n    returns false if impossible.  */\n static bool\n-constant_iterations (desc, niter, may_be_zero)\n-     struct loop_desc *desc;\n-     unsigned HOST_WIDE_INT *niter;\n-     bool *may_be_zero;\n+constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n+\t\t     bool *may_be_zero)\n {\n   rtx test, expr;\n   rtx ainit, alim;\n@@ -485,21 +450,18 @@ constant_iterations (desc, niter, may_be_zero)\n \n /* Return RTX expression representing number of iterations of loop as bounded\n    by test described by DESC (in the case loop really has multiple exit\n-   edges, fewer iterations may happen in the practice).  \n+   edges, fewer iterations may happen in the practice).\n \n    Return NULL if it is unknown.  Additionally the value may be invalid for\n    paradoxical loop (lets define paradoxical loops as loops whose test is\n    failing at -1th iteration, for instance \"for (i=5;i<1;i++);\").\n-   \n+\n    These cases needs to be either cared by copying the loop test in the front\n    of loop or keeping the test in first iteration of loop.\n-   \n+\n    When INIT/LIM are set, they are used instead of var/lim of DESC.  */\n rtx\n-count_loop_iterations (desc, init, lim)\n-     struct loop_desc *desc;\n-     rtx init;\n-     rtx lim;\n+count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n {\n   enum rtx_code cond = desc->cond;\n   rtx stride = desc->stride;\n@@ -618,9 +580,7 @@ count_loop_iterations (desc, init, lim)\n    described of DESC at given iteration of loop.  */\n \n static rtx\n-test_for_iteration (desc, iter)\n-     struct loop_desc *desc;\n-     unsigned HOST_WIDE_INT iter;\n+test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT iter)\n {\n   enum rtx_code cond = desc->cond;\n   rtx exp = XEXP (desc->var_alts, 0);\n@@ -661,13 +621,9 @@ test_for_iteration (desc, iter)\n    description joined to it in in DESC.  INVARIANT_REGS and SINGLE_SET_REGS\n    are results of blocks_{invariant,single_set}_regs over BODY.  */\n static bool\n-simple_loop_exit_p (loops, loop, exit_edge, invariant_regs, single_set_regs, desc)\n-     struct loops *loops;\n-     struct loop *loop;\n-     edge exit_edge;\n-     struct loop_desc *desc;\n-     regset invariant_regs;\n-     rtx *single_set_regs;\n+simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n+\t\t    regset invariant_regs, rtx *single_set_regs,\n+\t\t    struct loop_desc *desc)\n {\n   basic_block mod_bb, exit_bb;\n   int fallthru_out;\n@@ -729,10 +685,7 @@ simple_loop_exit_p (loops, loop, exit_edge, invariant_regs, single_set_regs, des\n /* Tests whether LOOP is simple for loop.  Returns simple loop description\n    in DESC.  */\n bool\n-simple_loop_p (loops, loop, desc)\n-     struct loops *loops;\n-     struct loop *loop;\n-     struct loop_desc *desc;\n+simple_loop_p (struct loops *loops, struct loop *loop, struct loop_desc *desc)\n {\n   unsigned i;\n   basic_block *body;\n@@ -743,7 +696,7 @@ simple_loop_p (loops, loop, desc)\n   regset_head invariant_regs_head;\n   rtx *single_set_regs;\n   int n_branches;\n-  \n+\n   body = get_loop_body (loop);\n \n   invariant_regs = INITIALIZE_REG_SET (invariant_regs_head);\n@@ -825,8 +778,7 @@ simple_loop_p (loops, loop, desc)\n    each cycle, we want to mark blocks that belong directly to innermost\n    loop containing the whole cycle.  */\n void\n-mark_irreducible_loops (loops)\n-     struct loops *loops;\n+mark_irreducible_loops (struct loops *loops)\n {\n   int *dfs_in, *closed, *mr, *mri, *n_edges, *stack;\n   unsigned i;\n@@ -1019,8 +971,7 @@ next:;\n \n /* Counts number of insns inside LOOP.  */\n int\n-num_loop_insns (loop)\n-     struct loop *loop;\n+num_loop_insns (struct loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, ninsns = 0;\n@@ -1036,14 +987,13 @@ num_loop_insns (loop)\n \t  ninsns++;\n     }\n   free(bbs);\n-  \n+\n   return ninsns;\n }\n \n /* Counts number of insns executed on average per iteration LOOP.  */\n int\n-average_num_loop_insns (loop)\n-     struct loop *loop;\n+average_num_loop_insns (struct loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, binsns, ninsns, ratio;\n@@ -1066,7 +1016,7 @@ average_num_loop_insns (loop)\n       ninsns += binsns * ratio;\n     }\n   free(bbs);\n- \n+\n   ninsns /= BB_FREQ_MAX;\n   if (!ninsns)\n     ninsns = 1; /* To avoid division by zero.  */\n@@ -1078,8 +1028,7 @@ average_num_loop_insns (loop)\n    Compute upper bound on number of iterations in case they do not fit integer\n    to help loop peeling heuristics.  Use exact counts if at all possible.  */\n unsigned\n-expected_loop_iterations (loop)\n-     const struct loop *loop;\n+expected_loop_iterations (const struct loop *loop)\n {\n   edge e;\n "}, {"sha": "fff74f8f2a60e62cb3dc978b2ddeb4fdc381f7db", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 82, "deletions": 170, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -29,44 +29,35 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"output.h\"\n \n-static struct loop * duplicate_loop\tPARAMS ((struct loops *,\n-\t\t\t\t\t\tstruct loop *, struct loop *));\n-static void duplicate_subloops\t\tPARAMS ((struct loops *, struct loop *,\n-\t\t\t\t\t\tstruct loop *));\n-static void copy_loops_to\t\tPARAMS ((struct loops *, struct loop **,\n-\t\t\t\t\t\tint, struct loop *));\n-static void loop_redirect_edge\t\tPARAMS ((edge, basic_block));\n-static bool loop_delete_branch_edge\tPARAMS ((edge, int));\n-static void copy_bbs\t\t\tPARAMS ((basic_block *, int, edge,\n-\t\t\t\t\t\tedge, basic_block **,\n-\t\t\t\t\t\tstruct loops *, edge *,\n-\t\t\t\t\t\tedge *, int));\n-static void remove_bbs\t\t\tPARAMS ((dominance_info, basic_block *,\n-\t\t\t\t\t\tint));\n-static bool rpe_enum_p\t\t\tPARAMS ((basic_block, void *));\n-static int find_path\t\t\tPARAMS ((edge, dominance_info,\n-\t\t\t\t\t\tbasic_block **));\n-static bool alp_enum_p\t\t\tPARAMS ((basic_block, void *));\n-static void add_loop\t\t\tPARAMS ((struct loops *, struct loop *));\n-static void fix_loop_placements\t\tPARAMS ((struct loop *));\n-static bool fix_bb_placement\t\tPARAMS ((struct loops *, basic_block));\n-static void fix_bb_placements\t\tPARAMS ((struct loops *, basic_block));\n-static void place_new_loop\t\tPARAMS ((struct loops *, struct loop *));\n-static void scale_loop_frequencies\tPARAMS ((struct loop *, int, int));\n-static void scale_bbs_frequencies\tPARAMS ((basic_block *, int, int, int));\n-static void record_exit_edges\t\tPARAMS ((edge, basic_block *, int,\n-\t\t\t\t\t\tedge *, unsigned *, int));\n-static basic_block create_preheader\tPARAMS ((struct loop *, dominance_info,\n-\t\t\t\t\t\tint));\n-static void fix_irreducible_loops\tPARAMS ((basic_block));\n+static struct loop * duplicate_loop (struct loops *, struct loop *,\n+\t\t\t\t     struct loop *);\n+static void duplicate_subloops (struct loops *, struct loop *, struct loop *);\n+static void copy_loops_to (struct loops *, struct loop **, int,\n+\t\t\t   struct loop *);\n+static void loop_redirect_edge (edge, basic_block);\n+static bool loop_delete_branch_edge (edge, int);\n+static void copy_bbs (basic_block *, int, edge, edge, basic_block **,\n+\t\t      struct loops *, edge *, edge *, int);\n+static void remove_bbs (dominance_info, basic_block *, int);\n+static bool rpe_enum_p (basic_block, void *);\n+static int find_path (edge, dominance_info, basic_block **);\n+static bool alp_enum_p (basic_block, void *);\n+static void add_loop (struct loops *, struct loop *);\n+static void fix_loop_placements (struct loop *);\n+static bool fix_bb_placement (struct loops *, basic_block);\n+static void fix_bb_placements (struct loops *, basic_block);\n+static void place_new_loop (struct loops *, struct loop *);\n+static void scale_loop_frequencies (struct loop *, int, int);\n+static void scale_bbs_frequencies (basic_block *, int, int, int);\n+static void record_exit_edges (edge, basic_block *, int, edge *, unsigned *,\n+\t\t\t       int);\n+static basic_block create_preheader (struct loop *, dominance_info, int);\n+static void fix_irreducible_loops (basic_block);\n \n /* Splits basic block BB after INSN, returns created edge.  Updates loops\n    and dominators.  */\n edge\n-split_loop_bb (loops, bb, insn)\n-     struct loops *loops;\n-     basic_block bb;\n-     rtx insn;\n+split_loop_bb (struct loops *loops, basic_block bb, rtx insn)\n {\n   edge e;\n   basic_block *dom_bbs;\n@@ -98,9 +89,7 @@ struct rpe_data\n  };\n \n static bool\n-rpe_enum_p (bb, data)\n-     basic_block bb;\n-     void *data;\n+rpe_enum_p (basic_block bb, void *data)\n {\n   struct rpe_data *rpe = data;\n   return dominated_by_p (rpe->doms, bb, rpe->dom);\n@@ -109,10 +98,7 @@ rpe_enum_p (bb, data)\n /* Remove basic blocks BBS from loop structure and dominance info,\n    and delete them afterwards.  */\n static void\n-remove_bbs (dom, bbs, nbbs)\n-     dominance_info dom;\n-     basic_block *bbs;\n-     int nbbs;\n+remove_bbs (dominance_info dom, basic_block *bbs, int nbbs)\n {\n   int i;\n \n@@ -131,10 +117,7 @@ remove_bbs (dom, bbs, nbbs)\n    alter anything by this function).  The number of basic blocks in the\n    path is returned.  */\n static int\n-find_path (e, doms, bbs)\n-     edge e;\n-     dominance_info doms;\n-     basic_block **bbs;\n+find_path (edge e, dominance_info doms, basic_block **bbs)\n {\n   struct rpe_data rpe;\n \n@@ -157,9 +140,7 @@ find_path (e, doms, bbs)\n    false if the placement of BB was already correct (provided that placements\n    of its successors are correct).  */\n static bool\n-fix_bb_placement (loops, bb)\n-     struct loops *loops;\n-     basic_block bb;\n+fix_bb_placement (struct loops *loops, basic_block bb)\n {\n   edge e;\n   struct loop *loop = loops->tree_root, *act;\n@@ -195,9 +176,7 @@ fix_bb_placement (loops, bb)\n    to this change; the condition for them is simmilar, except that instead of\n    successors we consider edges coming out of the loops.  */\n static void\n-fix_bb_placements (loops, from)\n-     struct loops *loops;\n-     basic_block from;\n+fix_bb_placements (struct loops *loops, basic_block from)\n {\n   sbitmap in_queue;\n   basic_block *queue, *qtop, *qbeg, *qend;\n@@ -257,7 +236,7 @@ fix_bb_placements (loops, from)\n \t  if (TEST_BIT (in_queue, pred->index))\n \t    continue;\n \n-\t  /* If it is subloop, then it either was not moved, or \n+\t  /* If it is subloop, then it either was not moved, or\n \t     the path up the loop tree from base_loop do not contain\n \t     it.  */\n \t  nca = find_common_loop (pred->loop_father, base_loop);\n@@ -290,8 +269,7 @@ fix_bb_placements (loops, from)\n    mo longer be part irreducible loop.  Fix it and proceed recursively\n    for its successors if needed.  */\n static void\n-fix_irreducible_loops (from)\n-     basic_block from;\n+fix_irreducible_loops (basic_block from)\n {\n   basic_block bb;\n   basic_block *stack;\n@@ -334,7 +312,7 @@ fix_irreducible_loops (from)\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    edges[n_edges++] = e;\n \t}\n-\t\n+\n       for (i = 0; i < n_edges; i++)\n \tif (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t  {\n@@ -343,10 +321,10 @@ fix_irreducible_loops (from)\n \n \t    e->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n \t    if (TEST_BIT (on_stack, e->dest->index))\n-  \t      continue;\n+\t      continue;\n \n \t    SET_BIT (on_stack, e->dest->index);\n-  \t    stack[stack_top++] = e->dest;\n+\t    stack[stack_top++] = e->dest;\n \t  }\n       free (edges);\n     }\n@@ -360,9 +338,7 @@ fix_irreducible_loops (from)\n    we were able to remove the path, false otherwise (and nothing is affected\n    then).  */\n bool\n-remove_path (loops, e)\n-     struct loops *loops;\n-     edge e;\n+remove_path (struct loops *loops, edge e)\n {\n   edge ae;\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n@@ -387,7 +363,7 @@ remove_path (loops, e)\n \t && dominated_by_p (loops->cfg.dom,\n \t\t\t    e->src->loop_father->latch, e->dest))\n     unloop (loops, e->src->loop_father);\n-  \n+\n   /* Identify the path.  */\n   nrem = find_path (e, loops->cfg.dom, &rem_bbs);\n \n@@ -466,23 +442,19 @@ remove_path (loops, e)\n \n /* Predicate for enumeration in add_loop.  */\n static bool\n-alp_enum_p (bb, alp_header)\n-     basic_block bb;\n-     void *alp_header;\n+alp_enum_p (basic_block bb, void *alp_header)\n {\n   return bb != (basic_block) alp_header;\n }\n \n /* Given LOOP structure with filled header and latch, find the body of the\n    corresponding loop and add it to LOOPS tree.  */\n static void\n-add_loop (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+add_loop (struct loops *loops, struct loop *loop)\n {\n   basic_block *bbs;\n   int i, n;\n-  \n+\n   /* Add it to loop structure.  */\n   place_new_loop (loops, loop);\n   loop->level = 1;\n@@ -502,11 +474,7 @@ add_loop (loops, loop)\n /* Multiply all frequencies of basic blocks in array BBS of lenght NBBS\n    by NUM/DEN.  */\n static void\n-scale_bbs_frequencies (bbs, nbbs, num, den)\n-     basic_block *bbs;\n-     int nbbs;\n-     int num;\n-     int den;\n+scale_bbs_frequencies (basic_block *bbs, int nbbs, int num, int den)\n {\n   int i;\n   edge e;\n@@ -522,10 +490,7 @@ scale_bbs_frequencies (bbs, nbbs, num, den)\n \n /* Multiply all frequencies in LOOP by NUM/DEN.  */\n static void\n-scale_loop_frequencies (loop, num, den)\n-     struct loop *loop;\n-     int num;\n-     int den;\n+scale_loop_frequencies (struct loop *loop, int num, int den)\n {\n   basic_block *bbs;\n \n@@ -543,11 +508,7 @@ scale_loop_frequencies (loop, num, den)\n    SWITCH_BB->succ->succ_next to original destination of HEADER_EDGE.\n    Returns newly created loop.  */\n struct loop *\n-loopify (loops, latch_edge, header_edge, switch_bb)\n-     struct loops *loops;\n-     edge latch_edge;\n-     edge header_edge;\n-     basic_block switch_bb;\n+loopify (struct loops *loops, edge latch_edge, edge header_edge, basic_block switch_bb)\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n@@ -634,9 +595,7 @@ loopify (loops, latch_edge, header_edge, switch_bb)\n    the LOOP was removed.  After this function, original loop latch will\n    have no successor, which caller is expected to fix somehow.  */\n void\n-unloop (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+unloop (struct loops *loops, struct loop *loop)\n {\n   basic_block *body;\n   struct loop *ploop;\n@@ -694,8 +653,7 @@ unloop (loops, loop)\n    FATHER, and set it as outer loop of LOOP.  Return 1 if placement of\n    LOOP changed.  */\n int\n-fix_loop_placement (loop)\n-     struct loop *loop;\n+fix_loop_placement (struct loop *loop)\n {\n   basic_block *body;\n   unsigned i;\n@@ -729,8 +687,7 @@ fix_loop_placement (loop)\n    It is used in case when we removed some edges coming out of LOOP, which\n    may cause the right placement of LOOP inside loop tree to change.  */\n static void\n-fix_loop_placements (loop)\n-     struct loop *loop;\n+fix_loop_placements (struct loop *loop)\n {\n   struct loop *outer;\n \n@@ -745,9 +702,7 @@ fix_loop_placements (loop)\n \n /* Creates place for a new LOOP in LOOPS structure.  */\n static void\n-place_new_loop (loops, loop)\n-     struct loops *loops;\n-     struct loop *loop;\n+place_new_loop (struct loops *loops, struct loop *loop)\n {\n   loops->parray =\n     xrealloc (loops->parray, (loops->num + 1) * sizeof (struct loop *));\n@@ -759,10 +714,7 @@ place_new_loop (loops, loop)\n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n    created loop into LOOPS structure.  */\n static struct loop *\n-duplicate_loop (loops, loop, target)\n-     struct loops *loops;\n-     struct loop *loop;\n-     struct loop *target;\n+duplicate_loop (struct loops *loops, struct loop *loop, struct loop *target)\n {\n   struct loop *cloop;\n   cloop = xcalloc (1, sizeof (struct loop));\n@@ -782,11 +734,8 @@ duplicate_loop (loops, loop, target)\n \n /* Copies structure of subloops of LOOP into TARGET loop, placing\n    newly created loops into loop tree stored in LOOPS.  */\n-static void \n-duplicate_subloops (loops, loop, target)\n-     struct loops *loops;\n-     struct loop *loop;\n-     struct loop *target;\n+static void\n+duplicate_subloops (struct loops *loops, struct loop *loop, struct loop *target)\n {\n   struct loop *aloop, *cloop;\n \n@@ -799,12 +748,8 @@ duplicate_subloops (loops, loop, target)\n \n /* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,\n    into TARGET loop, placing newly created loops into loop tree LOOPS.  */\n-static void \n-copy_loops_to (loops, copied_loops, n, target)\n-     struct loops *loops;\n-     struct loop **copied_loops;\n-     int n;\n-     struct loop *target;\n+static void\n+copy_loops_to (struct loops *loops, struct loop **copied_loops, int n, struct loop *target)\n {\n   struct loop *aloop;\n   int i;\n@@ -818,9 +763,7 @@ copy_loops_to (loops, copied_loops, n, target)\n \n /* Redirects edge E to basic block DEST.  */\n static void\n-loop_redirect_edge (e, dest)\n-     edge e;\n-     basic_block dest;\n+loop_redirect_edge (edge e, basic_block dest)\n {\n   if (e->dest == dest)\n     return;\n@@ -831,9 +774,7 @@ loop_redirect_edge (e, dest)\n /* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,\n    just test whether it is possible to remove the edge.  */\n static bool\n-loop_delete_branch_edge (e, really_delete)\n-     edge e;\n-     int really_delete;\n+loop_delete_branch_edge (edge e, int really_delete)\n {\n   basic_block src = e->src;\n   int irr;\n@@ -861,7 +802,7 @@ loop_delete_branch_edge (e, really_delete)\n \n       /* Redirecting behaves wrongly wrto this flag.  */\n       irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n-      \n+\n       if (!redirect_edge_and_branch (e, newdest))\n \treturn false;\n       src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n@@ -904,16 +845,9 @@ loop_delete_branch_edge (e, really_delete)\n      original entry block to first block in peeled copy.\n  */\n static void\n-copy_bbs (bbs, n, entry, latch_edge, new_bbs, loops, header_edge, copy_header_edge, add_irreducible_flag)\n-     basic_block *bbs;\n-     int n;\n-     edge entry;\n-     edge latch_edge;\n-     basic_block **new_bbs;\n-     struct loops *loops;\n-     edge *header_edge;\n-     edge *copy_header_edge;\n-     int add_irreducible_flag;\n+copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n+\t  basic_block **new_bbs, struct loops *loops, edge *header_edge,\n+\t  edge *copy_header_edge, int add_irreducible_flag)\n {\n   int i;\n   basic_block bb, new_bb, header = entry->dest, dom_bb;\n@@ -975,7 +909,7 @@ copy_bbs (bbs, n, entry, latch_edge, new_bbs, loops, header_edge, copy_header_ed\n \t  basic_block src = e->src;\n \n \t  e_pred = e->pred_next;\n-\t  \n+\n \t  if (!RBI (src)->duplicated)\n \t    continue;\n \n@@ -1007,8 +941,7 @@ copy_bbs (bbs, n, entry, latch_edge, new_bbs, loops, header_edge, copy_header_ed\n \n /* Check whether LOOP's body can be duplicated.  */\n bool\n-can_duplicate_loop_p (loop)\n-     struct loop *loop;\n+can_duplicate_loop_p (struct loop *loop)\n {\n   basic_block *bbs;\n   unsigned i;\n@@ -1047,13 +980,8 @@ can_duplicate_loop_p (loop)\n    into TO_REMOVE array that must be large enough to hold them all; their\n    number is returned in N_TO_REMOVE.  */\n static void\n-record_exit_edges (orig, bbs, nbbs, to_remove, n_to_remove, is_orig)\n-     edge orig;\n-     basic_block *bbs;\n-     int nbbs;\n-     edge *to_remove;\n-     unsigned *n_to_remove;\n-     int is_orig;\n+record_exit_edges (edge orig, basic_block *bbs, int nbbs, edge *to_remove,\n+\t\t   unsigned int *n_to_remove, int is_orig)\n {\n   sbitmap my_blocks;\n   int i;\n@@ -1106,17 +1034,10 @@ record_exit_edges (orig, bbs, nbbs, to_remove, n_to_remove, is_orig)\n    other copies are numbered in order given by control flow through them)\n    into TO_REMOVE array.  Returns false if duplication is impossible.  */\n int\n-duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n-\t\t\t       to_remove, n_to_remove, flags)\n-     struct loop *loop;\n-     edge e;\n-     struct loops *loops;\n-     unsigned ndupl;\n-     sbitmap wont_exit;\n-     edge orig;\n-     edge *to_remove;\n-     unsigned *n_to_remove;\n-     int flags;\n+duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n+\t\t\t       unsigned int ndupl, sbitmap wont_exit,\n+\t\t\t       edge orig, edge *to_remove,\n+\t\t\t       unsigned int *n_to_remove, int flags)\n {\n   struct loop *target, *aloop;\n   struct loop **orig_loops;\n@@ -1184,7 +1105,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n       scale_step = xmalloc (ndupl * sizeof (int));\n \n \tfor (i = 1; i <= ndupl; i++)\n-\t  scale_step[i - 1] = TEST_BIT (wont_exit, i) \n+\t  scale_step[i - 1] = TEST_BIT (wont_exit, i)\n \t\t\t\t? prob_pass_wont_exit\n \t\t\t\t: prob_pass_thru;\n \n@@ -1230,7 +1151,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n     orig_loops[i] = aloop;\n \n   loop->copy = target;\n-  \n+\n   /* Original basic blocks.  */\n   n = loop->num_nodes;\n \n@@ -1244,7 +1165,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n   /* Record exit edges in original loop body.  */\n   if (TEST_BIT (wont_exit, 0))\n     record_exit_edges (orig, bbs, n, to_remove, n_to_remove, true);\n-  \n+\n   for (j = 0; j < ndupl; j++)\n     {\n       /* Copy loops.  */\n@@ -1259,7 +1180,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n       /* Record exit edges in this copy.  */\n       if (TEST_BIT (wont_exit, j + 1))\n \trecord_exit_edges (orig, new_bbs, n, to_remove, n_to_remove, false);\n-  \n+\n       /* Set counts and frequencies.  */\n       for (i = 0; i < n; i++)\n \t{\n@@ -1270,7 +1191,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n \t    {\n \t      new_bb->count = RDIV (scale_act * bb->count, REG_BR_PROB_BASE);\n \t      new_bb->frequency = RDIV (scale_act * bb->frequency,\n-     \t\t\t\t\tREG_BR_PROB_BASE);\n+\t\t\t\t\tREG_BR_PROB_BASE);\n \t    }\n \t  else\n \t    {\n@@ -1279,7 +1200,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n \t    }\n \n \t  for (ae = new_bb->succ; ae; ae = ae->succ_next)\n-    \t    ae->count = RDIV (new_bb->count * ae->probability,\n+\t    ae->count = RDIV (new_bb->count * ae->probability,\n \t\t\t      REG_BR_PROB_BASE);\n \t}\n       if (flags & DLTHE_FLAG_UPDATE_FREQ)\n@@ -1290,7 +1211,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n \t  memcpy (first_active, new_bbs, n * sizeof (basic_block));\n \t  first_active_latch = RBI (latch)->copy;\n \t}\n-      \n+\n       free (new_bbs);\n \n       /* Original loop header is dominated by latch copy\n@@ -1306,7 +1227,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n \t}\n     }\n   /* Now handle original loop.  */\n-  \n+\n   /* Update edge counts.  */\n   if (flags & DLTHE_FLAG_UPDATE_FREQ)\n     {\n@@ -1353,10 +1274,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n    entry; otherwise we also force preheader block to have only one successor.\n    The function also updates dominators stored in DOM.  */\n static basic_block\n-create_preheader (loop, dom, flags)\n-     struct loop *loop;\n-     dominance_info dom;\n-     int flags;\n+create_preheader (struct loop *loop, dominance_info dom, int flags)\n {\n   edge e, fallthru;\n   basic_block dummy;\n@@ -1404,7 +1322,7 @@ create_preheader (loop, dom, flags)\n       ploop->latch = fallthru->dest;\n \n   add_to_dominance_info (dom, fallthru->dest);\n-  \n+\n   /* Redirect edges.  */\n   for (e = dummy->pred; e; e = e->pred_next)\n     {\n@@ -1442,9 +1360,7 @@ create_preheader (loop, dom, flags)\n /* Create preheaders for each loop from loop tree stored in LOOPS; for meaning\n    of FLAGS see create_preheader.  */\n void\n-create_preheaders (loops, flags)\n-     struct loops *loops;\n-     int flags;\n+create_preheaders (struct loops *loops, int flags)\n {\n   unsigned i;\n   for (i = 1; i < loops->num; i++)\n@@ -1455,8 +1371,7 @@ create_preheaders (loops, flags)\n /* Forces all loop latches of loops from loop tree LOOPS to have only single\n    successor.  */\n void\n-force_single_succ_latches (loops)\n-     struct loops *loops;\n+force_single_succ_latches (struct loops *loops)\n {\n   unsigned i;\n   struct loop *loop;\n@@ -1467,7 +1382,7 @@ force_single_succ_latches (loops)\n       loop = loops->parray[i];\n       if (!loop->latch->succ->succ_next)\n \tcontinue;\n- \n+\n       for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next)\n \tcontinue;\n \n@@ -1481,15 +1396,12 @@ force_single_succ_latches (loops)\n    be ok after this function.  The created block is placed on correct place\n    in LOOPS structure and its dominator is set.  */\n basic_block\n-loop_split_edge_with (e, insns, loops)\n-     edge e;\n-     rtx insns;\n-     struct loops *loops;\n+loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n {\n   basic_block src, dest, new_bb;\n   struct loop *loop_c;\n   edge new_e;\n-  \n+\n   src = e->src;\n   dest = e->dest;\n \n@@ -1531,6 +1443,6 @@ loop_split_edge_with (e, insns, loops)\n \n   if (dest->loop_father->latch == src)\n     dest->loop_father->latch = new_bb;\n-  \n+\n   return new_bb;\n }"}, {"sha": "371910592abf79538561436b4d3a38b0a95ba10f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 63, "deletions": 111, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d329e058f2de08aa52b68e97bc7ae13c0dbcbe39/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d329e058f2de08aa52b68e97bc7ae13c0dbcbe39", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -69,32 +69,31 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n rtx label_value_list;\n rtx tail_recursion_label_list;\n \n-static int can_delete_note_p\t\tPARAMS ((rtx));\n-static int can_delete_label_p\t\tPARAMS ((rtx));\n-static void commit_one_edge_insertion\tPARAMS ((edge, int));\n-static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n-static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n-static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n-basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n-static basic_block rtl_split_edge\tPARAMS ((edge));\n-static int rtl_verify_flow_info\t\tPARAMS ((void));\n-static edge cfg_layout_split_block\tPARAMS ((basic_block, void *));\n-static bool cfg_layout_redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n-static basic_block cfg_layout_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n-static void cfg_layout_delete_block\tPARAMS ((basic_block));\n-static void rtl_delete_block\t\tPARAMS ((basic_block));\n-static basic_block rtl_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n-static bool rtl_redirect_edge_and_branch PARAMS ((edge, basic_block));\n-static edge rtl_split_block\t\tPARAMS ((basic_block, void *));\n-static void rtl_dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n-static int rtl_verify_flow_info_1\tPARAMS ((void));\n+static int can_delete_note_p (rtx);\n+static int can_delete_label_p (rtx);\n+static void commit_one_edge_insertion (edge, int);\n+static bool try_redirect_by_replacing_jump (edge, basic_block);\n+static rtx last_loop_beg_note (rtx);\n+static bool back_edge_of_syntactic_loop_p (basic_block, basic_block);\n+basic_block force_nonfallthru_and_redirect (edge, basic_block);\n+static basic_block rtl_split_edge (edge);\n+static int rtl_verify_flow_info (void);\n+static edge cfg_layout_split_block (basic_block, void *);\n+static bool cfg_layout_redirect_edge_and_branch (edge, basic_block);\n+static basic_block cfg_layout_redirect_edge_and_branch_force (edge, basic_block);\n+static void cfg_layout_delete_block (basic_block);\n+static void rtl_delete_block (basic_block);\n+static basic_block rtl_redirect_edge_and_branch_force (edge, basic_block);\n+static bool rtl_redirect_edge_and_branch (edge, basic_block);\n+static edge rtl_split_block (basic_block, void *);\n+static void rtl_dump_bb (basic_block, FILE *);\n+static int rtl_verify_flow_info_1 (void);\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete it.  */\n \n static int\n-can_delete_note_p (note)\n-     rtx note;\n+can_delete_note_p (rtx note)\n {\n   return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n \t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK\n@@ -104,8 +103,7 @@ can_delete_note_p (note)\n /* True if a given label can be deleted.  */\n \n static int\n-can_delete_label_p (label)\n-     rtx label;\n+can_delete_label_p (rtx label)\n {\n   return (!LABEL_PRESERVE_P (label)\n \t  /* User declared labels must be preserved.  */\n@@ -117,8 +115,7 @@ can_delete_label_p (label)\n /* Delete INSN by patching it out.  Return the next insn.  */\n \n rtx\n-delete_insn (insn)\n-     rtx insn;\n+delete_insn (rtx insn)\n {\n   rtx next = NEXT_INSN (insn);\n   rtx note;\n@@ -189,8 +186,7 @@ delete_insn (insn)\n \n /* Like delete_insn but also purge dead edges from BB.  */\n rtx\n-delete_insn_and_edges (insn)\n-     rtx insn;\n+delete_insn_and_edges (rtx insn)\n {\n   rtx x;\n   bool purge = false;\n@@ -209,8 +205,7 @@ delete_insn_and_edges (insn)\n    that must be paired.  */\n \n void\n-delete_insn_chain (start, finish)\n-     rtx start, finish;\n+delete_insn_chain (rtx start, rtx finish)\n {\n   rtx next;\n \n@@ -233,8 +228,7 @@ delete_insn_chain (start, finish)\n \n /* Like delete_insn but also purge dead edges from BB.  */\n void\n-delete_insn_chain_and_edges (first, last)\n-     rtx first, last;\n+delete_insn_chain_and_edges (rtx first, rtx last)\n {\n   bool purge = false;\n \n@@ -256,9 +250,7 @@ delete_insn_chain_and_edges (first, last)\n    AFTER is the basic block we should be put after.  */\n \n basic_block\n-create_basic_block_structure (head, end, bb_note, after)\n-     rtx head, end, bb_note;\n-     basic_block after;\n+create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n {\n   basic_block bb;\n \n@@ -333,9 +325,7 @@ create_basic_block_structure (head, end, bb_note, after)\n    create basic block at the end of INSN chain.  */\n \n basic_block\n-create_basic_block (head, end, after)\n-     rtx head, end;\n-     basic_block after;\n+create_basic_block (rtx head, rtx end, basic_block after)\n {\n   basic_block bb;\n \n@@ -358,8 +348,7 @@ create_basic_block (head, end, after)\n    to post-process the stream to remove empty blocks, loops, ranges, etc.  */\n \n static void\n-rtl_delete_block (b)\n-     basic_block b;\n+rtl_delete_block (basic_block b)\n {\n   rtx insn, end, tmp;\n \n@@ -420,7 +409,7 @@ rtl_delete_block (b)\n /* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */\n \n void\n-compute_bb_for_insn ()\n+compute_bb_for_insn (void)\n {\n   basic_block bb;\n \n@@ -441,7 +430,7 @@ compute_bb_for_insn ()\n /* Release the basic_block_for_insn array.  */\n \n void\n-free_bb_for_insn ()\n+free_bb_for_insn (void)\n {\n   rtx insn;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -452,8 +441,7 @@ free_bb_for_insn ()\n /* Update insns block within BB.  */\n \n void\n-update_bb_for_insn (bb)\n-     basic_block bb;\n+update_bb_for_insn (basic_block bb)\n {\n   rtx insn;\n \n@@ -472,9 +460,7 @@ update_bb_for_insn (bb)\n    one has a number one greater than the block split.  */\n \n static edge\n-rtl_split_block (bb, insnp)\n-     basic_block bb;\n-     void *insnp;\n+rtl_split_block (basic_block bb, void *insnp)\n {\n   basic_block new_bb;\n   edge new_edge;\n@@ -533,8 +519,7 @@ rtl_split_block (bb, insnp)\n    are already contiguous, hence `nomove'.  */\n \n void\n-merge_blocks_nomove (a, b)\n-     basic_block a, b;\n+merge_blocks_nomove (basic_block a, basic_block b)\n {\n   rtx b_head = b->head, b_end = b->end, a_end = a->end;\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n@@ -641,8 +626,7 @@ merge_blocks_nomove (a, b)\n    exist.  */\n \n rtx\n-block_label (block)\n-     basic_block block;\n+block_label (basic_block block)\n {\n   if (block == EXIT_BLOCK_PTR)\n     return NULL_RTX;\n@@ -661,9 +645,7 @@ block_label (block)\n    return values are equivalent to redirect_edge_and_branch.  */\n \n static bool\n-try_redirect_by_replacing_jump (e, target)\n-     edge e;\n-     basic_block target;\n+try_redirect_by_replacing_jump (edge e, basic_block target)\n {\n   basic_block src = e->src;\n   rtx insn = src->end, kill_from;\n@@ -785,8 +767,7 @@ try_redirect_by_replacing_jump (e, target)\n    test.  */\n \n static rtx\n-last_loop_beg_note (insn)\n-     rtx insn;\n+last_loop_beg_note (rtx insn)\n {\n   rtx last = insn;\n \n@@ -810,9 +791,7 @@ last_loop_beg_note (insn)\n    stream.  */\n \n static bool\n-rtl_redirect_edge_and_branch (e, target)\n-     edge e;\n-     basic_block target;\n+rtl_redirect_edge_and_branch (edge e, basic_block target)\n {\n   rtx tmp;\n   rtx old_label = e->dest->head;\n@@ -911,9 +890,7 @@ rtl_redirect_edge_and_branch (e, target)\n    Used by redirect_edge_and_branch_force.  */\n \n basic_block\n-force_nonfallthru_and_redirect (e, target)\n-     edge e;\n-     basic_block target;\n+force_nonfallthru_and_redirect (edge e, basic_block target)\n {\n   basic_block jump_block, new_bb = NULL, src = e->src;\n   rtx note;\n@@ -956,7 +933,7 @@ force_nonfallthru_and_redirect (e, target)\n       /* Irritating special case - fallthru edge to the same block as abnormal\n \t edge.\n \t We can't redirect abnormal edge, but we still can split the fallthru\n-\t one and create separate abnormal edge to original destination. \n+\t one and create separate abnormal edge to original destination.\n \t This allows bb-reorder to make such edge non-fallthru.  */\n       if (e->dest != target)\n \tabort ();\n@@ -1064,8 +1041,7 @@ force_nonfallthru_and_redirect (e, target)\n    Return newly created BB or NULL if none.  */\n \n basic_block\n-force_nonfallthru (e)\n-     edge e;\n+force_nonfallthru (edge e)\n {\n   return force_nonfallthru_and_redirect (e, e->dest);\n }\n@@ -1075,9 +1051,7 @@ force_nonfallthru (e)\n    Abort if conversion is impossible.  */\n \n static basic_block\n-rtl_redirect_edge_and_branch_force (e, target)\n-     edge e;\n-     basic_block target;\n+rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n {\n   if (redirect_edge_and_branch (e, target)\n       || e->dest == target)\n@@ -1092,9 +1066,7 @@ rtl_redirect_edge_and_branch_force (e, target)\n    fact true, delete the jump and barriers that are in the way.  */\n \n void\n-tidy_fallthru_edge (e, b, c)\n-     edge e;\n-     basic_block b, c;\n+tidy_fallthru_edge (edge e, basic_block b, basic_block c)\n {\n   rtx q;\n \n@@ -1149,7 +1121,7 @@ tidy_fallthru_edge (e, b, c)\n    is how find_basic_blocks created them.  */\n \n void\n-tidy_fallthru_edges ()\n+tidy_fallthru_edges (void)\n {\n   basic_block b, c;\n \n@@ -1189,8 +1161,7 @@ tidy_fallthru_edges ()\n    is back edge of syntactic loop.  */\n \n static bool\n-back_edge_of_syntactic_loop_p (bb1, bb2)\n-\tbasic_block bb1, bb2;\n+back_edge_of_syntactic_loop_p (basic_block bb1, basic_block bb2)\n {\n   rtx insn;\n   int count = 0;\n@@ -1228,8 +1199,7 @@ back_edge_of_syntactic_loop_p (bb1, bb2)\n    block with multiple predecessors is not handled optimally.  */\n \n basic_block\n-rtl_split_edge (edge_in)\n-     edge edge_in;\n+rtl_split_edge (edge edge_in)\n {\n   basic_block bb;\n   rtx before;\n@@ -1317,9 +1287,7 @@ rtl_split_edge (edge_in)\n    CFG until commit_edge_insertions is called.  */\n \n void\n-insert_insn_on_edge (pattern, e)\n-     rtx pattern;\n-     edge e;\n+insert_insn_on_edge (rtx pattern, edge e)\n {\n   /* We cannot insert instructions on an abnormal critical edge.\n      It will be easier to find the culprit if we die now.  */\n@@ -1340,9 +1308,7 @@ insert_insn_on_edge (pattern, e)\n /* Update the CFG for the instructions queued on edge E.  */\n \n static void\n-commit_one_edge_insertion (e, watch_calls)\n-     edge e;\n-     int watch_calls;\n+commit_one_edge_insertion (edge e, int watch_calls)\n {\n   rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n   basic_block bb = NULL;\n@@ -1467,7 +1433,7 @@ commit_one_edge_insertion (e, watch_calls)\n /* Update the CFG for all queued instructions.  */\n \n void\n-commit_edge_insertions ()\n+commit_edge_insertions (void)\n {\n   basic_block bb;\n   sbitmap blocks;\n@@ -1515,7 +1481,7 @@ commit_edge_insertions ()\n    code on edges between call and storing its return value.  */\n \n void\n-commit_edge_insertions_watch_calls ()\n+commit_edge_insertions_watch_calls (void)\n {\n   basic_block bb;\n   sbitmap blocks;\n@@ -1562,9 +1528,7 @@ commit_edge_insertions_watch_calls ()\n /* Print out one basic block with live information at start and end.  */\n \n static void\n-rtl_dump_bb (bb, outf)\n-     basic_block bb;\n-     FILE *outf;\n+rtl_dump_bb (basic_block bb, FILE *outf)\n {\n   rtx insn;\n   rtx last;\n@@ -1586,9 +1550,7 @@ rtl_dump_bb (bb, outf)\n    basic block.  */\n \n void\n-print_rtl_with_bb (outf, rtx_first)\n-     FILE *outf;\n-     rtx rtx_first;\n+print_rtl_with_bb (FILE *outf, rtx rtx_first)\n {\n   rtx tmp_rtx;\n \n@@ -1674,8 +1636,7 @@ print_rtl_with_bb (outf, rtx_first)\n }\n \f\n void\n-update_br_prob_note (bb)\n-     basic_block bb;\n+update_br_prob_note (basic_block bb)\n {\n   rtx note;\n   if (GET_CODE (bb->end) != JUMP_INSN)\n@@ -1701,7 +1662,7 @@ update_br_prob_note (bb)\n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n static int\n-rtl_verify_flow_info_1 ()\n+rtl_verify_flow_info_1 (void)\n {\n   const int max_uid = get_max_uid ();\n   rtx last_head = get_last_insn ();\n@@ -1920,7 +1881,7 @@ rtl_verify_flow_info_1 ()\n    - check that all returns are followed by barriers\n    - check that all fallthru edge points to the adjacent blocks.  */\n static int\n-rtl_verify_flow_info ()\n+rtl_verify_flow_info (void)\n {\n   basic_block bb;\n   int err = rtl_verify_flow_info_1 ();\n@@ -2044,8 +2005,7 @@ rtl_verify_flow_info ()\n    Return true if any edges are eliminated.  */\n \n bool\n-purge_dead_edges (bb)\n-     basic_block bb;\n+purge_dead_edges (basic_block bb)\n {\n   edge e, next;\n   rtx insn = bb->end, note;\n@@ -2227,8 +2187,7 @@ purge_dead_edges (bb)\n    true if some edge has been eliminated.  */\n \n bool\n-purge_all_dead_edges (update_life_p)\n-     int update_life_p;\n+purge_all_dead_edges (int update_life_p)\n {\n   int purged = false;\n   sbitmap blocks = 0;\n@@ -2261,9 +2220,7 @@ purge_all_dead_edges (update_life_p)\n \n /* Same as split_block but update cfg_layout structures.  */\n static edge\n-cfg_layout_split_block (bb, insnp)\n-     basic_block bb;\n-     void *insnp;\n+cfg_layout_split_block (basic_block bb, void *insnp)\n {\n   rtx insn = insnp;\n \n@@ -2278,9 +2235,7 @@ cfg_layout_split_block (bb, insnp)\n \n /* Redirect Edge to DEST.  */\n static bool\n-cfg_layout_redirect_edge_and_branch (e, dest)\n-     edge e;\n-     basic_block dest;\n+cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n {\n   basic_block src = e->src;\n   basic_block old_next_bb = src->next_bb;\n@@ -2332,9 +2287,7 @@ cfg_layout_redirect_edge_and_branch (e, dest)\n \n /* Simple wrapper as we always can redirect fallthru edges.  */\n static basic_block\n-cfg_layout_redirect_edge_and_branch_force (e, dest)\n-     edge e;\n-     basic_block dest;\n+cfg_layout_redirect_edge_and_branch_force (edge e, basic_block dest)\n {\n   if (!cfg_layout_redirect_edge_and_branch (e, dest))\n     abort ();\n@@ -2343,8 +2296,7 @@ cfg_layout_redirect_edge_and_branch_force (e, dest)\n \n /* Same as flow_delete_block but update cfg_layout structures.  */\n static void\n-cfg_layout_delete_block (bb)\n-     basic_block bb;\n+cfg_layout_delete_block (basic_block bb)\n {\n   rtx insn, next, prev = PREV_INSN (bb->head), *to, remaints;\n \n@@ -2384,11 +2336,11 @@ cfg_layout_delete_block (bb)\n \n   if (prev)\n     prev = NEXT_INSN (prev);\n-  else \n+  else\n     prev = get_insns ();\n   if (next)\n     next = PREV_INSN (next);\n-  else \n+  else\n     next = get_last_insn ();\n \n   if (next && NEXT_INSN (next) != prev)"}]}