{"sha": "e1b793e7c10393b112937ce3e7de4db903052618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiNzkzZTdjMTAzOTNiMTEyOTM3Y2UzZTdkZTRkYjkwMzA1MjYxOA==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2010-09-24T17:37:16Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-09-24T17:37:16Z"}, "message": "gengtype.c: Reindented.\n\n\n2010-09-24  Basile Starynkevitch  <basile@starynkevitch.net>\n\n\t* gcc/gengtype.c: Reindented.\n\n\t* gcc/gengtype.h: Reindented.\n\n\t* gcc/gengtype-parse.c: Reindented.\n\nFrom-SVN: r164604", "tree": {"sha": "b69215f34e3bb2c29a5ec4bfc4727dfce15fafb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b69215f34e3bb2c29a5ec4bfc4727dfce15fafb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1b793e7c10393b112937ce3e7de4db903052618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b793e7c10393b112937ce3e7de4db903052618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b793e7c10393b112937ce3e7de4db903052618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b793e7c10393b112937ce3e7de4db903052618/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d0804d4b6a66182a23ea9df876fb33da0b7d702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0804d4b6a66182a23ea9df876fb33da0b7d702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0804d4b6a66182a23ea9df876fb33da0b7d702"}], "stats": {"total": 1067, "additions": 568, "deletions": 499}, "files": [{"sha": "567e8f1fcba73e4d1df461173707f65425e9bacf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1b793e7c10393b112937ce3e7de4db903052618", "patch": "@@ -1,3 +1,12 @@\n+\n+2010-09-24  Basile Starynkevitch  <basile@starynkevitch.net>\n+\n+\t* gengtype.c: Reindented.\n+\n+\t* gengtype.h: Reindented.\n+\n+\t* gengtype-parse.c: Reindented.\n+\n 2010-09-24  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/45738"}, {"sha": "3092a43eca074c8216dc39129a13bae4e1987b70", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 126, "deletions": 96, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=e1b793e7c10393b112937ce3e7de4db903052618", "patch": "@@ -1,21 +1,21 @@\n /* Process source files and output type information.\n    Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"bconfig.h\"\n #include \"system.h\"\n@@ -113,7 +113,7 @@ print_token (int code, const char *value)\n   else if (code < FIRST_TOKEN_WITH_VALUE)\n     return xasprintf (\"'%s'\", token_names[code - CHAR_TOKEN_OFFSET]);\n   else if (!value)\n-    return token_names[code - CHAR_TOKEN_OFFSET]; /* don't quote these */\n+    return token_names[code - CHAR_TOKEN_OFFSET];\t/* don't quote these */\n   else\n     return xasprintf (token_value_format[code - FIRST_TOKEN_WITH_VALUE],\n \t\t      value);\n@@ -199,7 +199,7 @@ string_seq (void)\n \n       l1 = strlen (s1);\n       l2 = strlen (s2);\n-      buf = XRESIZEVEC (char, CONST_CAST(char *, s1), l1 + l2 + 1);\n+      buf = XRESIZEVEC (char, CONST_CAST (char *, s1), l1 + l2 + 1);\n       memcpy (buf + l1, s2, l2 + 1);\n       XDELETE (CONST_CAST (char *, s2));\n       s1 = buf;\n@@ -222,7 +222,7 @@ typedef_name (void)\n       require (',');\n       c2 = require (ID);\n       require (')');\n-      r = concat (\"VEC_\", c1, \"_\", c2, (char *)0);\n+      r = concat (\"VEC_\", c1, \"_\", c2, (char *) 0);\n       free (CONST_CAST (char *, c1));\n       free (CONST_CAST (char *, c2));\n       return r;\n@@ -239,19 +239,27 @@ consume_balanced (int opener, int closer)\n   for (;;)\n     switch (token ())\n       {\n-      default: advance (); break;\n-      case '(': consume_balanced ('(',')'); break;\n-      case '[': consume_balanced ('[',']'); break;\n-      case '{': consume_balanced ('{','}'); break;\n+      default:\n+\tadvance ();\n+\tbreak;\n+      case '(':\n+\tconsume_balanced ('(', ')');\n+\tbreak;\n+      case '[':\n+\tconsume_balanced ('[', ']');\n+\tbreak;\n+      case '{':\n+\tconsume_balanced ('{', '}');\n+\tbreak;\n \n       case '}':\n       case ']':\n       case ')':\n \tif (token () != closer)\n \t  parse_error (\"unbalanced delimiters - expected '%c', have '%c'\",\n \t\t       closer, token ());\n-\tadvance ();\n-\treturn;\n+      advance ();\n+      return;\n \n       case EOF_TOKEN:\n \tparse_error (\"unexpected end of file within %c%c-delimited construct\",\n@@ -272,18 +280,28 @@ consume_until_semi (bool immediate)\n   for (;;)\n     switch (token ())\n       {\n-      case ';':\tadvance (); return;\n-      default:\tadvance (); break;\n+      case ';':\n+\tadvance ();\n+\treturn;\n+      default:\n+\tadvance ();\n+\tbreak;\n \n-      case '(':\tconsume_balanced ('(',')'); break;\n-      case '[': consume_balanced ('[',']'); break;\n-      case '{':\tconsume_balanced ('{','}'); break;\n+      case '(':\n+\tconsume_balanced ('(', ')');\n+\tbreak;\n+      case '[':\n+\tconsume_balanced ('[', ']');\n+\tbreak;\n+      case '{':\n+\tconsume_balanced ('{', '}');\n+\tbreak;\n \n       case '}':\n       case ']':\n       case ')':\n \tparse_error (\"unmatched '%c' while scanning for ';'\", token ());\n-\treturn;\n+      return;\n \n       case EOF_TOKEN:\n \tparse_error (\"unexpected end of file while scanning for ';'\");\n@@ -304,28 +322,40 @@ consume_until_comma_or_semi (bool immediate)\n   for (;;)\n     switch (token ())\n       {\n-      case ',':\tadvance (); return true;\n-      case ';':\tadvance (); return false;\n-      default:\tadvance (); break;\n+      case ',':\n+\tadvance ();\n+\treturn true;\n+      case ';':\n+\tadvance ();\n+\treturn false;\n+      default:\n+\tadvance ();\n+\tbreak;\n \n-      case '(':\tconsume_balanced ('(',')'); break;\n-      case '[': consume_balanced ('[',']'); break;\n-      case '{':\tconsume_balanced ('{','}'); break;\n+      case '(':\n+\tconsume_balanced ('(', ')');\n+\tbreak;\n+      case '[':\n+\tconsume_balanced ('[', ']');\n+\tbreak;\n+      case '{':\n+\tconsume_balanced ('{', '}');\n+\tbreak;\n \n       case '}':\n       case ']':\n       case ')':\n \tparse_error (\"unmatched '%s' while scanning for ',' or ';'\",\n \t\t     print_cur_token ());\n-\treturn false;\n+      return false;\n \n       case EOF_TOKEN:\n \tparse_error (\"unexpected end of file while scanning for ',' or ';'\");\n \treturn false;\n       }\n }\n-\n \f\n+\n /* GTY(()) option handling.  */\n static type_p type (options_p *optsp, bool nested);\n \n@@ -401,11 +431,11 @@ nestedptr_optvalue (options_p prev)\n }\n \n /* One GTY(()) option:\n-         ID str_optvalue_opt\n-       | PTR_ALIAS type_optvalue\n-       | PARAM_IS type_optvalue\n-       | NESTED_PTR nestedptr_optvalue\n- */\n+   ID str_optvalue_opt\n+   | PTR_ALIAS type_optvalue\n+   | PARAM_IS type_optvalue\n+   | NESTED_PTR nestedptr_optvalue\n+*/\n static options_p\n option (options_p prev)\n {\n@@ -426,8 +456,7 @@ option (options_p prev)\n       return nestedptr_optvalue (prev);\n \n     default:\n-      parse_error (\"expected an option keyword, have %s\",\n-\t\t   print_cur_token ());\n+      parse_error (\"expected an option keyword, have %s\", print_cur_token ());\n       advance ();\n       return create_option (prev, \"\", \"\");\n     }\n@@ -479,9 +508,9 @@ gtymarker_opt (void)\n    we don't have to do it.  */\n \n /* array_and_function_declarators_opt:\n-      \\epsilon\n-      array_and_function_declarators_opt ARRAY\n-      array_and_function_declarators_opt '(' ... ')'\n+   \\epsilon\n+   array_and_function_declarators_opt ARRAY\n+   array_and_function_declarators_opt '(' ... ')'\n \n    where '...' indicates stuff we ignore except insofar as grouping\n    symbols ()[]{} must balance.\n@@ -510,8 +539,8 @@ array_and_function_declarators_opt (type_p ty)\n static type_p inner_declarator (type_p, const char **, options_p *);\n \n /* direct_declarator:\n-      '(' inner_declarator ')'\n-      gtymarker_opt ID array_and_function_declarators_opt\n+   '(' inner_declarator ')'\n+   gtymarker_opt ID array_and_function_declarators_opt\n \n    Subroutine of declarator, mutually recursive with inner_declarator;\n    do not use elsewhere.  */\n@@ -550,7 +579,7 @@ direct_declarator (type_p ty, const char **namep, options_p *optsp)\n /* The difference between inner_declarator and declarator is in the\n    handling of stars.  Consider this declaration:\n \n-      char * (*pfc) (void)\n+   char * (*pfc) (void)\n \n    It declares a pointer to a function that takes no arguments and\n    returns a char*.  To construct the correct type for this\n@@ -562,8 +591,8 @@ direct_declarator (type_p ty, const char **namep, options_p *optsp)\n    creating pointers.  */\n \n /* inner_declarator:\n-     '*' inner_declarator\n-     direct_declarator\n+   '*' inner_declarator\n+   direct_declarator\n \n    Mutually recursive subroutine of direct_declarator; do not use\n    elsewhere.  */\n@@ -609,13 +638,13 @@ declarator (type_p ty, const char **namep, options_p *optsp)\n \n /* Structure field(s) declaration:\n    (\n-       type bitfield ';'\n-     | type declarator bitfield? ( ',' declarator bitfield? )+ ';'\n+   type bitfield ';'\n+   | type declarator bitfield? ( ',' declarator bitfield? )+ ';'\n    )+\n \n    Knows that such declarations must end with a close brace (or,\n    erroneously, at EOF).\n- */\n+*/\n static pair_p\n struct_field_seq (void)\n {\n@@ -666,15 +695,15 @@ struct_field_seq (void)\n /* This is called type(), but what it parses (sort of) is what C calls\n    declaration-specifiers and specifier-qualifier-list:\n \n-     SCALAR\n+   SCALAR\n    | ID     // typedef\n    | (STRUCT|UNION) ID? gtymarker? ( '{' gtymarker? struct_field_seq '}' )?\n    | ENUM ID ( '{' ... '}' )?\n \n    Returns a partial type; under some conditions (notably\n    \"struct foo GTY((...)) thing;\") it may write an options\n    structure to *OPTSP.\n- */\n+*/\n static type_p\n type (options_p *optsp, bool nested)\n {\n@@ -695,15 +724,16 @@ type (options_p *optsp, bool nested)\n     case UNION:\n       {\n \toptions_p opts = 0;\n-    /* GTY annotations follow attribute syntax\n-       GTY_BEFORE_ID is for union/struct declarations\n-       GTY_AFTER_ID is for variable declarations.  */\n-    enum {\n-        NO_GTY,\n-        GTY_BEFORE_ID,\n-        GTY_AFTER_ID\n-    } is_gty = NO_GTY;\n-    bool is_union = (token () == UNION);\n+\t/* GTY annotations follow attribute syntax\n+\t   GTY_BEFORE_ID is for union/struct declarations\n+\t   GTY_AFTER_ID is for variable declarations.  */\n+\tenum\n+\t{\n+\t  NO_GTY,\n+\t  GTY_BEFORE_ID,\n+\t  GTY_AFTER_ID\n+\t} is_gty = NO_GTY;\n+\tbool is_union = (token () == UNION);\n \tadvance ();\n \n \t/* Top-level structures that are not explicitly tagged GTY(())\n@@ -713,54 +743,54 @@ type (options_p *optsp, bool nested)\n \t   that we can't handle.  */\n \tif (nested || token () == GTY_TOKEN)\n \t  {\n-        is_gty = GTY_BEFORE_ID;\n-        opts = gtymarker_opt ();\n+\t    is_gty = GTY_BEFORE_ID;\n+\t    opts = gtymarker_opt ();\n \t  }\n \n \tif (token () == ID)\n \t  s = advance ();\n \telse\n \t  s = xasprintf (\"anonymous:%s:%d\", lexer_line.file, lexer_line.line);\n \n-        /* Unfortunately above GTY_TOKEN check does not capture the\n-           typedef struct_type GTY case.  */\n+\t/* Unfortunately above GTY_TOKEN check does not capture the\n+\t   typedef struct_type GTY case.  */\n \tif (token () == GTY_TOKEN)\n \t  {\n-        is_gty = GTY_AFTER_ID;\n-        opts = gtymarker_opt ();\n+\t    is_gty = GTY_AFTER_ID;\n+\t    opts = gtymarker_opt ();\n \t  }\n \n-    if (is_gty)\n-      {\n-        if (token () == '{')\n-          {\n-            pair_p fields;\n-\n-            if (is_gty == GTY_AFTER_ID)\n-                parse_error (\"GTY must be specified before identifier\");\n-\n-            advance ();\n-            fields = struct_field_seq ();\n-            require ('}');\n-            return new_structure (s, is_union, &lexer_line, fields, opts);\n-          }\n-      }\n-    else if (token () == '{')\n-      consume_balanced ('{', '}');\n+\tif (is_gty)\n+\t  {\n+\t    if (token () == '{')\n+\t      {\n+\t\tpair_p fields;\n+\n+\t\tif (is_gty == GTY_AFTER_ID)\n+\t\t  parse_error (\"GTY must be specified before identifier\");\n+\n+\t\tadvance ();\n+\t\tfields = struct_field_seq ();\n+\t\trequire ('}');\n+\t\treturn new_structure (s, is_union, &lexer_line, fields, opts);\n+\t      }\n+\t  }\n+\telse if (token () == '{')\n+\t  consume_balanced ('{', '}');\n \tif (opts)\n \t  *optsp = opts;\n \treturn find_structure (s, is_union);\n       }\n \n     case ENUM:\n       advance ();\n-\tif (token () == ID)\n-\t  s = advance ();\n-\telse\n-\t  s = xasprintf (\"anonymous:%s:%d\", lexer_line.file, lexer_line.line);\n+      if (token () == ID)\n+\ts = advance ();\n+      else\n+\ts = xasprintf (\"anonymous:%s:%d\", lexer_line.file, lexer_line.line);\n \n       if (token () == '{')\n-\tconsume_balanced ('{','}');\n+\tconsume_balanced ('{', '}');\n       return create_scalar_type (s);\n \n     default:\n@@ -821,7 +851,7 @@ struct_or_union (void)\n }\n \n /* GC root declaration:\n-     (extern|static) gtymarker? type ID array_declarators_opt (';'|'=')\n+   (extern|static) gtymarker? type ID array_declarators_opt (';'|'=')\n    If the gtymarker is not present, we ignore the rest of the declaration.  */\n static void\n extern_or_static (void)\n@@ -838,8 +868,8 @@ extern_or_static (void)\n     }\n \n   opts = gtymarker ();\n-  ty   = type (&opts2, true);  /* if we get here, it's got a GTY(()) */\n-  dty  = declarator (ty, &name, &dopts);\n+  ty = type (&opts2, true);\t/* if we get here, it's got a GTY(()) */\n+  dty = declarator (ty, &name, &dopts);\n \n   if ((opts && dopts) || (opts && opts2) || (opts2 && dopts))\n     parse_error (\"GTY((...)) specified more than once for %s\", name);\n@@ -864,7 +894,7 @@ extern_or_static (void)\n static void\n def_vec (void)\n {\n-  bool is_scalar = (token() == DEFVEC_I);\n+  bool is_scalar = (token () == DEFVEC_I);\n   const char *type;\n \n   require2 (DEFVEC_OP, DEFVEC_I);"}, {"sha": "badb8f1fff163903a659122f9b4e76b407b7ce89", "filename": "gcc/gengtype.c", "status": "modified", "additions": 374, "deletions": 351, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=e1b793e7c10393b112937ce3e7de4db903052618", "patch": "@@ -21,14 +21,15 @@\n #include \"bconfig.h\"\n #include \"system.h\"\n #include \"gengtype.h\"\n-#include \"errors.h\"\t/* for fatal */\n+#include \"errors.h\"\t\t/* for fatal */\n #include \"double-int.h\"\n #include \"hashtab.h\"\n \n /* Data types, macros, etc. used only in this file.  */\n \n /* Kinds of types we can understand.  */\n-enum typekind {\n+enum typekind\n+{\n   TYPE_SCALAR,\n   TYPE_STRING,\n   TYPE_STRUCT,\n@@ -71,26 +72,28 @@ struct pair\n \n /* A description of a type.  */\n enum gc_used_enum\n-  {\n-    GC_UNUSED = 0,\n-    GC_USED,\n-    /* Used for structures whose definitions we haven't seen so far when\n-       we encounter a pointer to it that is annotated with ``maybe_undef''.\n-       If after reading in everything we don't have source file\n-       information for it, we assume that it never has been defined. */\n-    GC_MAYBE_POINTED_TO,\n-    GC_POINTED_TO\n-  };\n+{\n+  GC_UNUSED = 0,\n+  GC_USED,\n+  /* Used for structures whose definitions we haven't seen so far when\n+     we encounter a pointer to it that is annotated with ``maybe_undef''.\n+     If after reading in everything we don't have source file\n+     information for it, we assume that it never has been defined. */\n+  GC_MAYBE_POINTED_TO,\n+  GC_POINTED_TO\n+};\n \n struct type\n {\n   enum typekind kind;\n   type_p next;\n   type_p pointer_to;\n   enum gc_used_enum gc_used;\n-  union {\n+  union\n+  {\n     type_p p;\n-    struct {\n+    struct\n+    {\n       const char *tag;\n       struct fileloc line;\n       pair_p fields;\n@@ -99,11 +102,13 @@ struct type\n       type_p lang_struct;\n     } s;\n     bool scalar_is_char;\n-    struct {\n+    struct\n+    {\n       type_p p;\n       const char *len;\n     } a;\n-    struct {\n+    struct\n+    {\n       type_p stru;\n       type_p param[NUM_PARAM];\n       struct fileloc line;\n@@ -112,13 +117,13 @@ struct type\n };\n \n #define UNION_P(x)\t\t\t\t\t\\\n- ((x)->kind == TYPE_UNION || \t\t\t\t\\\n-  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n-   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+  ((x)->kind == TYPE_UNION || \t\t\t\t\\\n+   ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n+    && (x)->u.s.lang_struct->kind == TYPE_UNION))\n #define UNION_OR_STRUCT_P(x)\t\t\t\\\n- ((x)->kind == TYPE_UNION \t\t\t\\\n-  || (x)->kind == TYPE_STRUCT \t\t\t\\\n-  || (x)->kind == TYPE_LANG_STRUCT)\n+  ((x)->kind == TYPE_UNION \t\t\t\\\n+   || (x)->kind == TYPE_STRUCT \t\t\t\\\n+   || (x)->kind == TYPE_LANG_STRUCT)\n \n /* Structure representing an output file.  */\n struct outf\n@@ -129,25 +134,25 @@ struct outf\n   size_t bufused;\n   char *buf;\n };\n-typedef struct outf * outf_p;\n+typedef struct outf *outf_p;\n \n /* An output file, suitable for definitions, that can see declarations\n    made in INPUT_FILE and is linked into every language that uses\n    INPUT_FILE.  May return NULL in plugin mode. */\n-extern outf_p get_output_file_with_visibility\n-   (const char *input_file);\n+extern outf_p get_output_file_with_visibility (const char *input_file);\n const char *get_output_file_name (const char *);\n \n /* Print, like fprintf, to O.  No-op if O is NULL. */\n-static void oprintf (outf_p o, const char *S, ...)\n-     ATTRIBUTE_PRINTF_2;\n+static void\n+oprintf (outf_p o, const char *S, ...)\n+  ATTRIBUTE_PRINTF_2;\n \n /* The list of output files.  */\n static outf_p output_files;\n \n /* The plugin input files and their number; in that case only\n    a single file is produced.  */\n-static char** plugin_files;\n+static char **plugin_files;\n static size_t nb_plugin_files;\n /* the generated plugin output name & file */\n static outf_p plugin_output;\n@@ -164,14 +169,14 @@ static size_t srcdir_len = 0;\n \n static outf_p create_file (const char *, const char *);\n \n-static const char * get_file_basename (const char *);\n-static const char * get_file_realbasename (const char *);\n-static const char * get_file_srcdir_relative_path (const char *);\n+static const char *get_file_basename (const char *);\n+static const char *get_file_realbasename (const char *);\n+static const char *get_file_srcdir_relative_path (const char *);\n \n static int get_prefix_langdir_index (const char *);\n-static const char * get_file_langdir (const char *);\n-\n+static const char *get_file_langdir (const char *);\n \f\n+\n /* Nonzero iff an error has occurred.  */\n bool hit_error = false;\n \n@@ -251,13 +256,13 @@ get_lang_bitmap (const char *gtfile)\n \n   if (gtfile == this_file)\n     /* Things defined in this file are universal.  */\n-    return (((lang_bitmap)1) << num_lang_dirs) - 1;\n+    return (((lang_bitmap) 1) << num_lang_dirs) - 1;\n   else\n     {\n       lang_bitmap n = 0;\n       int i;\n       for (i = -(int) sizeof (lang_bitmap); i < 0; i++)\n-\tn = (n << CHAR_BIT) + (unsigned char)gtfile[i];\n+\tn = (n << CHAR_BIT) + (unsigned char) gtfile[i];\n       return n;\n     }\n }\n@@ -270,7 +275,7 @@ set_lang_bitmap (char *gtfile, lang_bitmap n)\n   int i;\n   for (i = -1; i >= -(int) sizeof (lang_bitmap); i--)\n     {\n-      gtfile[i] = n & ((1U << CHAR_BIT)-1);\n+      gtfile[i] = n & ((1U << CHAR_BIT) - 1);\n       n >>= CHAR_BIT;\n     }\n }\n@@ -319,8 +324,7 @@ measure_input_list (FILE *list)\n    touch *HEREP, and sets *LINEP to NULL.  POS is used for\n    diagnostics.  */\n static bool\n-read_input_line (FILE *list, char **herep, char **linep,\n-\t\t struct fileloc *pos)\n+read_input_line (FILE *list, char **herep, char **linep, struct fileloc *pos)\n {\n   char *here = *herep;\n   char *line;\n@@ -349,12 +353,13 @@ read_input_line (FILE *list, char **herep, char **linep,\n \n       if (c == ']')\n \t{\n-\t  c = getc (list);  /* eat what should be a newline */\n+\t  c = getc (list);\t/* eat what should be a newline */\n \t  if (c != '\\n' && c != EOF)\n \t    error_at_line (pos, \"junk on line after language tag [%s]\", line);\n \t}\n       else\n-\terror_at_line (pos, \"missing close bracket for language tag [%s\", line);\n+\terror_at_line (pos, \"missing close bracket for language tag [%s\",\n+\t\t       line);\n \n       *herep = here;\n       *linep = line;\n@@ -429,7 +434,8 @@ read_input_list (const char *listname)\n \t      for (i = 0; i < langno; i++)\n \t\tif (strcmp (lang_dir_names[i], line) == 0)\n \t\t  {\n-\t\t    error_at_line (&epos, \"duplicate language tag [%s]\", line);\n+\t\t    error_at_line (&epos, \"duplicate language tag [%s]\",\n+\t\t\t\t   line);\n \t\t    curlangs = 1 << i;\n \t\t    here = committed;\n \t\t    goto next_line;\n@@ -449,13 +455,15 @@ read_input_list (const char *listname)\n \t\t       current language to the existing string's bitmap.  */\n \t\t    lang_bitmap bmap = get_lang_bitmap (gt_files[i]);\n \t\t    if (bmap & curlangs)\n-\t\t      error_at_line (&epos, \"file %s specified more than once \"\n-\t\t\t\t     \"for language %s\", line, langno == 0\n-\t\t\t\t     ? \"(all)\"\n-\t\t\t\t     : lang_dir_names[langno - 1]);\n+\t\t      error_at_line (&epos,\n+\t\t\t\t     \"file %s specified more than once \"\n+\t\t\t\t     \"for language %s\", line,\n+\t\t\t\t     langno ==\n+\t\t\t\t     0 ? \"(all)\" : lang_dir_names[langno -\n+\t\t\t\t\t\t\t\t  1]);\n \n \t\t    bmap |= curlangs;\n-\t\t    set_lang_bitmap (CONST_CAST(char *, gt_files[i]), bmap);\n+\t\t    set_lang_bitmap (CONST_CAST (char *, gt_files[i]), bmap);\n \t\t    here = committed;\n \t\t    goto next_line;\n \t\t  }\n@@ -465,7 +473,7 @@ read_input_list (const char *listname)\n \t    }\n \t}\n       /* Update the global counts now that we know accurately how many\n-\t things there are.  (We do not bother resizing the arrays down.)  */\n+         things there are.  (We do not bother resizing the arrays down.)  */\n       num_lang_dirs = langno;\n       /* Add the plugin files if provided.  */\n       if (plugin_files)\n@@ -493,7 +501,7 @@ read_input_list (const char *listname)\n \t  {\n \t    size_t l;\n \t    for (l = 0; l < num_lang_dirs; l++)\n-\t      if ((size_t)(slashpos - basename) == strlen (lang_dir_names [l])\n+\t      if ((size_t) (slashpos - basename) == strlen (lang_dir_names[l])\n \t\t  && memcmp (basename, lang_dir_names[l],\n \t\t\t     strlen (lang_dir_names[l])) == 0)\n \t\t{\n@@ -503,7 +511,7 @@ read_input_list (const char *listname)\n \t\t\t   basename, lang_dir_names[l]);\n \t\t  break;\n \t\t}\n-          }\n+\t  }\n       }\n   }\n \n@@ -512,9 +520,9 @@ read_input_list (const char *listname)\n \n   fclose (list);\n }\n+\f\n \n \n-\f\n /* The one and only TYPE_STRING.  */\n \n static struct type string_type = {\n@@ -527,6 +535,7 @@ static struct type string_type = {\n static struct type scalar_nonchar = {\n   TYPE_SCALAR, 0, 0, GC_USED, {0}\n };\n+\n static struct type scalar_char = {\n   TYPE_SCALAR, 0, 0, GC_USED, {0}\n };\n@@ -538,8 +547,7 @@ static type_p structures;\n static type_p param_structs;\n static pair_p variables;\n \n-static type_p find_param_structure\n-  (type_p t, type_p param[NUM_PARAM]);\n+static type_p find_param_structure (type_p t, type_p param[NUM_PARAM]);\n static type_p adjust_field_tree_exp (type_p t, options_p opt);\n static type_p adjust_field_rtx_def (type_p t, options_p opt);\n \n@@ -597,7 +605,7 @@ resolve_typedef (const char *s, struct fileloc *pos)\n     if (strcmp (p->name, s) == 0)\n       return p->type;\n   error_at_line (pos, \"unidentified type `%s'\", s);\n-  return &scalar_nonchar;  /* treat as \"int\" */\n+  return &scalar_nonchar;\t/* treat as \"int\" */\n }\n \n /* Create and return a new structure with tag NAME (or a union iff\n@@ -614,13 +622,11 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   /* temporary kludge - gengtype doesn't handle conditionals or\n      macros.  Ignore any attempt to define struct location_s, unless\n      it is coming from this file (main() sets it up safely). */\n-  if (!strcmp (name, \"location_s\") && !isunion\n-      && pos->file != this_file)\n+  if (!strcmp (name, \"location_s\") && !isunion && pos->file != this_file)\n     return find_structure (name, 0);\n \n   for (si = structures; si != NULL; si = si->next)\n-    if (strcmp (name, si->u.s.tag) == 0\n-\t&& UNION_P (si) == isunion)\n+    if (strcmp (name, si->u.s.tag) == 0 && UNION_P (si) == isunion)\n       {\n \ttype_p ls = NULL;\n \tif (si->kind == TYPE_LANG_STRUCT)\n@@ -682,8 +688,7 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n \n   /* Reset location_s's location to input.h so that we know where to\n      write out its mark routine.  */\n-  if (!strcmp (name, \"location_s\") && !isunion\n-      && pos->file == this_file)\n+  if (!strcmp (name, \"location_s\") && !isunion && pos->file == this_file)\n     {\n       size_t n;\n       for (n = 0; n < num_gt_files; n++)\n@@ -695,7 +700,7 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n \t  }\n     }\n \n-    return s;\n+  return s;\n }\n \n /* Return the previously-defined structure with tag NAME (or a union\n@@ -708,8 +713,7 @@ find_structure (const char *name, int isunion)\n   type_p s;\n \n   for (s = structures; s != NULL; s = s->next)\n-    if (strcmp (name, s->u.s.tag) == 0\n-\t&& UNION_P (s) == isunion)\n+    if (strcmp (name, s->u.s.tag) == 0 && UNION_P (s) == isunion)\n       return s;\n \n   s = XCNEW (struct type);\n@@ -763,7 +767,7 @@ create_scalar_type (const char *name)\n type_p\n create_pointer (type_p t)\n {\n-  if (! t->pointer_to)\n+  if (!t->pointer_to)\n     {\n       type_p r = XCNEW (struct type);\n       r->kind = TYPE_POINTER;\n@@ -796,7 +800,7 @@ create_option (options_p next, const char *name, const void *info)\n   options_p o = XNEW (struct options);\n   o->next = next;\n   o->name = name;\n-  o->info = (const char*) info;\n+  o->info = (const char *) info;\n   return o;\n }\n \n@@ -860,7 +864,7 @@ create_field_at (pair_p next, type_p type, const char *name, options_p opt,\n /* Create a fake field with the given type and name.  NEXT is the next\n    field in the chain.  */\n #define create_field(next,type,name) \\\n-    create_field_all(next,type,name, 0, this_file, __LINE__)\n+  create_field_all(next,type,name, 0, this_file, __LINE__)\n \n /* Like create_field, but the field is only valid when condition COND\n    is true.  */\n@@ -885,11 +889,11 @@ create_optional_field_ (pair_p next, type_p type, const char *name,\n   /* Create the field and give it the new fake union type.  Add a \"desc\"\n      tag that specifies the condition under which the field is valid.  */\n   return create_field_all (next, union_type, name,\n-\t\t\t   create_option (0, \"desc\", cond),\n-\t\t\t   this_file, line);\n+\t\t\t   create_option (0, \"desc\", cond), this_file, line);\n }\n+\n #define create_optional_field(next,type,name,cond)\t\\\n-       create_optional_field_(next,type,name,cond,__LINE__)\n+  create_optional_field_(next,type,name,cond,__LINE__)\n \n /* Reverse a linked list of 'struct pair's in place.  */\n pair_p\n@@ -904,27 +908,28 @@ nreverse_pairs (pair_p list)\n     }\n   return prev;\n }\n-\n \f\n+\n /* We don't care how long a CONST_DOUBLE is.  */\n #define CONST_DOUBLE_FORMAT \"ww\"\n /* We don't want to see codes that are only for generator files.  */\n #undef GENERATOR_FILE\n \n-enum rtx_code {\n+enum rtx_code\n+{\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS) ENUM ,\n #include \"rtl.def\"\n #undef DEF_RTL_EXPR\n   NUM_RTX_CODE\n };\n \n-static const char * const rtx_name[NUM_RTX_CODE] = {\n+static const char *const rtx_name[NUM_RTX_CODE] = {\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   NAME ,\n #include \"rtl.def\"\n #undef DEF_RTL_EXPR\n };\n \n-static const char * const rtx_format[NUM_RTX_CODE] = {\n+static const char *const rtx_format[NUM_RTX_CODE] = {\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n #include \"rtl.def\"\n #undef DEF_RTL_EXPR\n@@ -934,7 +939,8 @@ static int rtx_next_new[NUM_RTX_CODE];\n \n /* We also need codes and names for insn notes (not register notes).\n    Note that we do *not* bias the note values here.  */\n-enum insn_note {\n+enum insn_note\n+{\n #define DEF_INSN_NOTE(NAME) NAME,\n #include \"insn-notes.def\"\n #undef DEF_INSN_NOTE\n@@ -944,7 +950,7 @@ enum insn_note {\n \n /* We must allocate one more entry here, as we use NOTE_INSN_MAX as the\n    default field for line number notes.  */\n-static const char *const note_insn_name[NOTE_INSN_MAX+1] = {\n+static const char *const note_insn_name[NOTE_INSN_MAX + 1] = {\n #define DEF_INSN_NOTE(NAME) #NAME,\n #include \"insn-notes.def\"\n #undef DEF_INSN_NOTE\n@@ -992,8 +998,7 @@ write_rtx_next (void)\n       oprintf (f, \"  0,\\n\");\n     else\n       oprintf (f,\n-\t       \"  RTX_HDR_SIZE + %d * sizeof (rtunion),\\n\",\n-\t       rtx_next_new[i]);\n+\t       \"  RTX_HDR_SIZE + %d * sizeof (rtunion),\\n\", rtx_next_new[i]);\n   oprintf (f, \"};\\n\");\n }\n \n@@ -1025,8 +1030,9 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n   mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", 0));\n   reg_attrs_tp = create_pointer (find_structure (\"reg_attrs\", 0));\n   basic_block_tp = create_pointer (find_structure (\"basic_block_def\", 0));\n-  constant_tp = create_pointer (find_structure (\"constant_descriptor_rtx\", 0));\n-  scalar_tp = &scalar_nonchar;  /* rtunion int */\n+  constant_tp =\n+    create_pointer (find_structure (\"constant_descriptor_rtx\", 0));\n+  scalar_tp = &scalar_nonchar;\t/* rtunion int */\n \n   {\n     pair_p note_flds = NULL;\n@@ -1109,8 +1115,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == CODE_LABEL && aindex == 4)\n \t\tt = rtx_tp, subname = \"rt_rtx\";\n-\t      else if (i == LABEL_REF\n-\t\t       && (aindex == 1 || aindex == 2))\n+\t      else if (i == LABEL_REF && (aindex == 1 || aindex == 2))\n \t\tt = rtx_tp, subname = \"rt_rtx\";\n \t      else if (i == NOTE && aindex == 4)\n \t\tt = note_union_tp, subname = \"\";\n@@ -1139,7 +1144,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t      else\n \t\t{\n \t\t  error_at_line (&lexer_line,\n-\t\t\t\"rtx type `%s' has `0' in position %lu, can't handle\",\n+\t\t\t\t \"rtx type `%s' has `0' in position %lu, can't handle\",\n \t\t\t\t rtx_name[i], (unsigned long) aindex);\n \t\t  t = &string_type;\n \t\t  subname = \"rt_int\";\n@@ -1177,9 +1182,9 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \n \t    default:\n \t      error_at_line (&lexer_line,\n-\t\t     \"rtx type `%s' has `%c' in position %lu, can't handle\",\n+\t\t\t     \"rtx type `%s' has `%c' in position %lu, can't handle\",\n \t\t\t     rtx_name[i], rtx_format[i][aindex],\n-\t\t\t     (unsigned long)aindex);\n+\t\t\t     (unsigned long) aindex);\n \t      t = &string_type;\n \t      subname = \"rt_int\";\n \t      break;\n@@ -1282,20 +1287,21 @@ adjust_field_type (type_p t, options_p opt)\n       {\n \tint num = ISDIGIT (opt->name[5]) ? opt->name[5] - '0' : 0;\n \n-\tif (! UNION_OR_STRUCT_P (t)\n-\t    && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n+\tif (!UNION_OR_STRUCT_P (t)\n+\t    && (t->kind != TYPE_POINTER || !UNION_OR_STRUCT_P (t->u.p)))\n \t  {\n \t    error_at_line (&lexer_line,\n-   \"option `%s' may only be applied to structures or structure pointers\",\n+\t\t\t   \"option `%s' may only be applied to structures or structure pointers\",\n \t\t\t   opt->name);\n \t    return t;\n \t  }\n \n \tparams_p = 1;\n \tif (params[num] != NULL)\n \t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n-\tif (! ISDIGIT (opt->name[5]))\n-\t  params[num] = create_pointer (CONST_CAST2(type_p, const char *, opt->info));\n+\tif (!ISDIGIT (opt->name[5]))\n+\t  params[num] =\n+\t    create_pointer (CONST_CAST2 (type_p, const char *, opt->info));\n \telse\n \t  params[num] = CONST_CAST2 (type_p, const char *, opt->info);\n       }\n@@ -1320,10 +1326,8 @@ adjust_field_type (type_p t, options_p opt)\n       t = pointer_p ? create_pointer (realt) : realt;\n     }\n \n-  if (! length_p\n-      && pointer_p\n-      && t->u.p->kind == TYPE_SCALAR\n-      && t->u.p->u.scalar_is_char)\n+  if (!length_p\n+      && pointer_p && t->u.p->kind == TYPE_SCALAR && t->u.p->u.scalar_is_char)\n     return &string_type;\n   if (t->kind == TYPE_ARRAY && t->u.a.p->kind == TYPE_POINTER\n       && t->u.a.p->u.p->kind == TYPE_SCALAR\n@@ -1332,16 +1336,17 @@ adjust_field_type (type_p t, options_p opt)\n \n   return t;\n }\n-\n \f\n+\n static void set_gc_used_type (type_p, enum gc_used_enum, type_p *);\n static void set_gc_used (pair_p);\n \n /* Handle OPT for set_gc_used_type.  */\n \n static void\n process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n-\t\t    int *pass_param, int *length, int *skip, type_p *nested_ptr)\n+\t\t    int *pass_param, int *length, int *skip,\n+\t\t    type_p *nested_ptr)\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n@@ -1403,7 +1408,7 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n \t      set_gc_used_type (find_param_structure (f->type->u.p, param),\n \t\t\t\tGC_POINTED_TO, NULL);\n \t    else if (skip)\n-\t      ; /* target type is not used through this field */\n+\t      ;\t\t\t/* target type is not used through this field */\n \t    else\n \t      set_gc_used_type (f->type, GC_USED, pass_param ? param : NULL);\n \t  }\n@@ -1522,7 +1527,7 @@ oprintf (outf_p o, const char *format, ...)\n \n   va_start (ap, format);\n   slength = vasprintf (&s, format, ap);\n-  if (s == NULL || (int)slength < 0)\n+  if (s == NULL || (int) slength < 0)\n     fatal (\"out of memory\");\n   va_end (ap);\n \n@@ -1531,9 +1536,11 @@ oprintf (outf_p o, const char *format, ...)\n       size_t new_len = o->buflength;\n       if (new_len == 0)\n \tnew_len = 1024;\n-      do {\n-\tnew_len *= 2;\n-      } while (o->bufused + slength >= new_len);\n+      do\n+\t{\n+\t  new_len *= 2;\n+\t}\n+      while (o->bufused + slength >= new_len);\n       o->buf = XRESIZEVEC (char, o->buf, new_len);\n       o->buflength = new_len;\n     }\n@@ -1563,9 +1570,9 @@ open_base_files (void)\n   /* gtype-desc.c is a little special, so we create it here.  */\n   {\n     /* The order of files here matters very much.  */\n-    static const char *const ifiles [] = {\n+    static const char *const ifiles[] = {\n       \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\",\n-      \"hashtab.h\", \"splay-tree.h\",  \"obstack.h\", \"bitmap.h\", \"input.h\",\n+      \"hashtab.h\", \"splay-tree.h\", \"obstack.h\", \"bitmap.h\", \"input.h\",\n       \"tree.h\", \"rtl.h\", \"function.h\", \"insn-config.h\", \"expr.h\",\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n@@ -1592,7 +1599,7 @@ open_base_files (void)\n static const char *\n get_file_realbasename (const char *f)\n {\n-  const char * lastslash = strrchr (f, '/');\n+  const char *lastslash = strrchr (f, '/');\n \n   return (lastslash != NULL) ? lastslash + 1 : f;\n }\n@@ -1617,7 +1624,7 @@ get_file_srcdir_relative_path (const char *f)\n static const char *\n get_file_basename (const char *f)\n {\n-  const char * srcdir_path = get_file_srcdir_relative_path (f);\n+  const char *srcdir_path = get_file_srcdir_relative_path (f);\n \n   return (srcdir_path != NULL) ? srcdir_path : get_file_realbasename (f);\n }\n@@ -1633,7 +1640,7 @@ get_prefix_langdir_index (const char *f)\n \n   for (lang_index = 0; lang_index < num_lang_dirs; lang_index++)\n     {\n-      const char * langdir = lang_dir_names [lang_index];\n+      const char *langdir = lang_dir_names[lang_index];\n       size_t langdir_len = strlen (langdir);\n \n       if (f_len > langdir_len\n@@ -1656,18 +1663,17 @@ get_file_langdir (const char *f)\n      srcdir relative, no point in looking further.  */\n \n   int lang_index;\n-  const char * srcdir_relative_path = get_file_srcdir_relative_path (f);\n-  const char * r;\n+  const char *srcdir_relative_path = get_file_srcdir_relative_path (f);\n+  const char *r;\n \n   if (!srcdir_relative_path)\n     return NULL;\n \n   lang_index = get_prefix_langdir_index (srcdir_relative_path);\n-  if (lang_index < 0\n-      && strncmp (srcdir_relative_path, \"c-family\", 8) == 0)\n+  if (lang_index < 0 && strncmp (srcdir_relative_path, \"c-family\", 8) == 0)\n     r = \"c-family\";\n   else if (lang_index >= 0)\n-    r = lang_dir_names [lang_index];\n+    r = lang_dir_names[lang_index];\n   else\n     r = NULL;\n \n@@ -1685,7 +1691,7 @@ get_file_gtfilename (const char *f)\n   const char *basename = get_file_realbasename (f);\n   const char *langdir = get_file_langdir (f);\n \n-  char * result =\n+  char *result =\n     (langdir ? xasprintf (\"gt-%s-%s\", langdir, basename)\n      : xasprintf (\"gt-%s\", basename));\n \n@@ -1696,7 +1702,7 @@ get_file_gtfilename (const char *f)\n   char *s = result;\n \n   for (; *s != '.'; s++)\n-    if (! ISALNUM (*s) && *s != '-')\n+    if (!ISALNUM (*s) && *s != '-')\n       *s = '-';\n \n   memcpy (s, \".h\", sizeof (\".h\"));\n@@ -1739,9 +1745,9 @@ get_output_file_with_visibility (const char *input_file)\n   basename = get_file_basename (input_file);\n \n   len = strlen (basename);\n-  if ((len > 2 && memcmp (basename+len-2, \".c\", 2) == 0)\n-      || (len > 2 && memcmp (basename+len-2, \".y\", 2) == 0)\n-      || (len > 3 && memcmp (basename+len-3, \".in\", 3) == 0))\n+  if ((len > 2 && memcmp (basename + len - 2, \".c\", 2) == 0)\n+      || (len > 2 && memcmp (basename + len - 2, \".y\", 2) == 0)\n+      || (len > 3 && memcmp (basename + len - 3, \".in\", 3) == 0))\n     {\n       output_name = get_file_gtfilename (input_file);\n       for_name = basename;\n@@ -1768,7 +1774,8 @@ get_output_file_with_visibility (const char *input_file)\n   else if (strncmp (basename, \"cp\", 2) == 0 && IS_DIR_SEPARATOR (basename[2])\n \t   && strcmp (basename + 3, \"name-lookup.h\") == 0)\n     output_name = \"gt-cp-name-lookup.h\", for_name = \"cp/name-lookup.c\";\n-  else if (strncmp (basename, \"objc\", 4) == 0 && IS_DIR_SEPARATOR (basename[4])\n+  else if (strncmp (basename, \"objc\", 4) == 0\n+\t   && IS_DIR_SEPARATOR (basename[4])\n \t   && strcmp (basename + 5, \"objc-act.h\") == 0)\n     output_name = \"gt-objc-objc-act.h\", for_name = \"objc/objc-act.c\";\n   else\n@@ -1801,7 +1808,7 @@ get_output_file_with_visibility (const char *input_file)\n const char *\n get_output_file_name (const char *input_file)\n {\n-  outf_p o =  get_output_file_with_visibility (input_file);\n+  outf_p o = get_output_file_with_visibility (input_file);\n   if (o)\n     return o->name;\n   return NULL;\n@@ -1844,23 +1851,24 @@ close_output_files (void)\n   for (of = output_files; of; of = of->next)\n     {\n \n-      if (!is_file_equal(of))\n-      {\n-        FILE *newfile = fopen (of->name, \"w\");\n-        if (newfile == NULL)\n-          fatal (\"opening output file %s: %s\", of->name, xstrerror (errno));\n-        if (fwrite (of->buf, 1, of->bufused, newfile) != of->bufused)\n-          fatal (\"writing output file %s: %s\", of->name, xstrerror (errno));\n-        if (fclose (newfile) != 0)\n-          fatal (\"closing output file %s: %s\", of->name, xstrerror (errno));\n-      }\n-      free(of->buf);\n+      if (!is_file_equal (of))\n+\t{\n+\t  FILE *newfile = fopen (of->name, \"w\");\n+\t  if (newfile == NULL)\n+\t    fatal (\"opening output file %s: %s\", of->name, xstrerror (errno));\n+\t  if (fwrite (of->buf, 1, of->bufused, newfile) != of->bufused)\n+\t    fatal (\"writing output file %s: %s\", of->name, xstrerror (errno));\n+\t  if (fclose (newfile) != 0)\n+\t    fatal (\"closing output file %s: %s\", of->name, xstrerror (errno));\n+\t}\n+      free (of->buf);\n       of->buf = NULL;\n       of->bufused = of->buflength = 0;\n     }\n }\n \f\n-struct flist {\n+struct flist\n+{\n   struct flist *next;\n   int started_p;\n   const char *name;\n@@ -1873,10 +1881,8 @@ struct walk_type_data;\n    For structures, given a pointer to the item in 'val'.\n    For misc. pointers, given the item in 'val'.\n */\n-typedef void (*process_field_fn)\n-     (type_p f, const struct walk_type_data *p);\n-typedef void (*func_name_fn)\n-     (type_p s, const struct walk_type_data *p);\n+typedef void (*process_field_fn) (type_p f, const struct walk_type_data * p);\n+typedef void (*func_name_fn) (type_p s, const struct walk_type_data * p);\n \n /* Parameters for write_types.  */\n \n@@ -1895,28 +1901,27 @@ static void output_escaped_param (struct walk_type_data *d,\n \t\t\t\t  const char *, const char *);\n static void output_mangled_typename (outf_p, const_type_p);\n static void walk_type (type_p t, struct walk_type_data *d);\n-static void write_func_for_structure (type_p orig_s, type_p s, type_p * param,\n+static void write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t\t\t\t      const struct write_types_data *wtd);\n static void write_types_process_field\n-     (type_p f, const struct walk_type_data *d);\n+  (type_p f, const struct walk_type_data *d);\n static void write_types (outf_p output_header,\n-                         type_p structures,\n+\t\t\t type_p structures,\n \t\t\t type_p param_structs,\n \t\t\t const struct write_types_data *wtd);\n static void write_types_local_process_field\n-     (type_p f, const struct walk_type_data *d);\n+  (type_p f, const struct walk_type_data *d);\n static void write_local_func_for_structure\n-     (const_type_p orig_s, type_p s, type_p * param);\n+  (const_type_p orig_s, type_p s, type_p *param);\n static void write_local (outf_p output_header,\n-                         type_p structures,\n-\t\t\t type_p param_structs);\n+\t\t\t type_p structures, type_p param_structs);\n static void write_enum_defn (type_p structures, type_p param_structs);\n static int contains_scalar_p (type_p t);\n-static void put_mangled_filename (outf_p , const char *);\n+static void put_mangled_filename (outf_p, const char *);\n static void finish_root_table (struct flist *flp, const char *pfx,\n \t\t\t       const char *tname, const char *lastname,\n \t\t\t       const char *name);\n-static void write_root (outf_p , pair_p, type_p, const char *, int,\n+static void write_root (outf_p, pair_p, type_p, const char *, int,\n \t\t\tstruct fileloc *, const char *, bool);\n static void write_array (outf_p f, pair_p v,\n \t\t\t const struct write_types_data *wtd);\n@@ -1951,35 +1956,37 @@ output_mangled_typename (outf_p of, const_type_p t)\n {\n   if (t == NULL)\n     oprintf (of, \"Z\");\n-  else switch (t->kind)\n-    {\n-    case TYPE_POINTER:\n-      oprintf (of, \"P\");\n-      output_mangled_typename (of, t->u.p);\n-      break;\n-    case TYPE_SCALAR:\n-      oprintf (of, \"I\");\n-      break;\n-    case TYPE_STRING:\n-      oprintf (of, \"S\");\n-      break;\n-    case TYPE_STRUCT:\n-    case TYPE_UNION:\n-    case TYPE_LANG_STRUCT:\n-      oprintf (of, \"%lu%s\", (unsigned long) strlen (t->u.s.tag), t->u.s.tag);\n-      break;\n-    case TYPE_PARAM_STRUCT:\n+  else\n+    switch (t->kind)\n       {\n-\tint i;\n-\tfor (i = 0; i < NUM_PARAM; i++)\n-\t  if (t->u.param_struct.param[i] != NULL)\n-\t    output_mangled_typename (of, t->u.param_struct.param[i]);\n-\toutput_mangled_typename (of, t->u.param_struct.stru);\n+      case TYPE_POINTER:\n+\toprintf (of, \"P\");\n+\toutput_mangled_typename (of, t->u.p);\n+\tbreak;\n+      case TYPE_SCALAR:\n+\toprintf (of, \"I\");\n+\tbreak;\n+      case TYPE_STRING:\n+\toprintf (of, \"S\");\n+\tbreak;\n+      case TYPE_STRUCT:\n+      case TYPE_UNION:\n+      case TYPE_LANG_STRUCT:\n+\toprintf (of, \"%lu%s\", (unsigned long) strlen (t->u.s.tag),\n+\t\t t->u.s.tag);\n+\tbreak;\n+      case TYPE_PARAM_STRUCT:\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < NUM_PARAM; i++)\n+\t    if (t->u.param_struct.param[i] != NULL)\n+\t      output_mangled_typename (of, t->u.param_struct.param[i]);\n+\t  output_mangled_typename (of, t->u.param_struct.stru);\n+\t}\n+\tbreak;\n+      case TYPE_ARRAY:\n+\tgcc_unreachable ();\n       }\n-      break;\n-    case TYPE_ARRAY:\n-      gcc_unreachable ();\n-    }\n }\n \n /* Print PARAM to D->OF processing escapes.  D->VAL references the\n@@ -1996,30 +2003,31 @@ output_escaped_param (struct walk_type_data *d, const char *param,\n   for (p = param; *p; p++)\n     if (*p != '%')\n       oprintf (d->of, \"%c\", *p);\n-    else switch (*++p)\n-      {\n-      case 'h':\n-\toprintf (d->of, \"(%s)\", d->prev_val[2]);\n-\tbreak;\n-      case '0':\n-\toprintf (d->of, \"(%s)\", d->prev_val[0]);\n-\tbreak;\n-      case '1':\n-\toprintf (d->of, \"(%s)\", d->prev_val[1]);\n-\tbreak;\n-      case 'a':\n+    else\n+      switch (*++p)\n \t{\n-\t  const char *pp = d->val + strlen (d->val);\n-\t  while (pp[-1] == ']')\n-\t    while (*pp != '[')\n-\t      pp--;\n-\t  oprintf (d->of, \"%s\", pp);\n+\tcase 'h':\n+\t  oprintf (d->of, \"(%s)\", d->prev_val[2]);\n+\t  break;\n+\tcase '0':\n+\t  oprintf (d->of, \"(%s)\", d->prev_val[0]);\n+\t  break;\n+\tcase '1':\n+\t  oprintf (d->of, \"(%s)\", d->prev_val[1]);\n+\t  break;\n+\tcase 'a':\n+\t  {\n+\t    const char *pp = d->val + strlen (d->val);\n+\t    while (pp[-1] == ']')\n+\t      while (*pp != '[')\n+\t\tpp--;\n+\t    oprintf (d->of, \"%s\", pp);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  error_at_line (d->line, \"`%s' option contains bad escape %c%c\",\n+\t\t\t oname, '%', *p);\n \t}\n-\tbreak;\n-      default:\n-\terror_at_line (d->line, \"`%s' option contains bad escape %c%c\",\n-\t\t       oname, '%', *p);\n-      }\n }\n \n /* Call D->PROCESS_FIELD for every field (or subfield) of D->VAL,\n@@ -2076,8 +2084,7 @@ walk_type (type_p t, struct walk_type_data *d)\n     else if (strcmp (oo->name, \"param_is\") == 0)\n       ;\n     else if (strncmp (oo->name, \"param\", 5) == 0\n-\t     && ISDIGIT (oo->name[5])\n-\t     && strcmp (oo->name + 6, \"_is\") == 0)\n+\t     && ISDIGIT (oo->name[5]) && strcmp (oo->name + 6, \"_is\") == 0)\n       ;\n     else if (strcmp (oo->name, \"chain_next\") == 0)\n       ;\n@@ -2101,7 +2108,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n       if (pointer_p)\n \tt = t->u.p;\n-      if (! UNION_OR_STRUCT_P (t))\n+      if (!UNION_OR_STRUCT_P (t))\n \terror_at_line (d->line, \"`use_params' option on unimplemented type\");\n       else\n \tt = find_param_structure (t, d->param);\n@@ -2125,12 +2132,11 @@ walk_type (type_p t, struct walk_type_data *d)\n \t  t = nt;\n \t}\n       else\n-\terror_at_line (d->line, \"no parameter defined for `%s'\",\n-\t\t       d->val);\n+\terror_at_line (d->line, \"no parameter defined for `%s'\", d->val);\n     }\n \n   if (maybe_undef_p\n-      && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n+      && (t->kind != TYPE_POINTER || !UNION_OR_STRUCT_P (t->u.p)))\n     {\n       error_at_line (d->line,\n \t\t     \"field `%s' has invalid option `maybe_undef_p'\\n\",\n@@ -2147,16 +2153,15 @@ walk_type (type_p t, struct walk_type_data *d)\n \n     case TYPE_POINTER:\n       {\n-\tif (maybe_undef_p\n-\t    && t->u.p->u.s.line.file == NULL)\n+\tif (maybe_undef_p && t->u.p->u.s.line.file == NULL)\n \t  {\n \t    oprintf (d->of, \"%*sgcc_assert (!%s);\\n\", d->indent, \"\", d->val);\n \t    break;\n \t  }\n \n-\tif (! length)\n+\tif (!length)\n \t  {\n-\t    if (! UNION_OR_STRUCT_P (t->u.p)\n+\t    if (!UNION_OR_STRUCT_P (t->u.p)\n \t\t&& t->u.p->kind != TYPE_PARAM_STRUCT)\n \t      {\n \t\terror_at_line (d->line,\n@@ -2169,12 +2174,11 @@ walk_type (type_p t, struct walk_type_data *d)\n \t      {\n \t\tconst char *oldprevval2 = d->prev_val[2];\n \n-\t\tif (! UNION_OR_STRUCT_P (nested_ptr_d->type))\n+\t\tif (!UNION_OR_STRUCT_P (nested_ptr_d->type))\n \t\t  {\n \t\t    error_at_line (d->line,\n \t\t\t\t   \"field `%s' has invalid \"\n-\t\t\t\t   \"option `nested_ptr'\\n\",\n-\t\t\t\t   d->val);\n+\t\t\t\t   \"option `nested_ptr'\\n\", d->val);\n \t\t    return;\n \t\t  }\n \n@@ -2186,8 +2190,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\t\t (nested_ptr_d->type->kind == TYPE_UNION\n \t\t\t  ? \"union\" : \"struct\"),\n \t\t\t nested_ptr_d->type->u.s.tag,\n-\t\t\t d->fn_wants_lvalue ? \"\" : \"const \",\n-\t\t\t d->val);\n+\t\t\t d->fn_wants_lvalue ? \"\" : \"const \", d->val);\n \t\toprintf (d->of, \"%*s\", d->indent + 2, \"\");\n \t\toutput_escaped_param (d, nested_ptr_d->convert_from,\n \t\t\t\t      \"nested_ptr\");\n@@ -2223,8 +2226,8 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    oprintf (d->of, \"%*sif (%s != NULL) {\\n\", d->indent, \"\", d->val);\n \t    d->indent += 2;\n \t    oprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n-\t    oprintf (d->of, \"%*sfor (i%d = 0; i%d != (size_t)(\", d->indent, \"\",\n-\t\t     loopcounter, loopcounter);\n+\t    oprintf (d->of, \"%*sfor (i%d = 0; i%d != (size_t)(\", d->indent,\n+\t\t     \"\", loopcounter, loopcounter);\n \t    output_escaped_param (d, length, \"length\");\n \t    oprintf (d->of, \"); i%d++) {\\n\", loopcounter);\n \t    d->indent += 2;\n@@ -2238,7 +2241,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->used_length = 0;\n \t    d->indent -= 2;\n \t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n-\t    d->process_field(t, d);\n+\t    d->process_field (t, d);\n \t    d->indent -= 2;\n \t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t  }\n@@ -2302,7 +2305,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \tint seen_default_p = 0;\n \toptions_p o;\n \n-\tif (! t->u.s.line.file)\n+\tif (!t->u.s.line.file)\n \t  error_at_line (d->line, \"incomplete structure `%s'\", t->u.s.tag);\n \n \tif ((d->bitmap & t->u.s.bitmap) != d->bitmap)\n@@ -2315,7 +2318,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \t/* Some things may also be defined in the structure's options.  */\n \tfor (o = t->u.s.opt; o; o = o->next)\n-\t  if (! desc && strcmp (o->name, \"desc\") == 0)\n+\t  if (!desc && strcmp (o->name, \"desc\") == 0)\n \t    desc = o->info;\n \n \td->prev_val[2] = oldval;\n@@ -2324,7 +2327,8 @@ walk_type (type_p t, struct walk_type_data *d)\n \t  {\n \t    if (desc == NULL)\n \t      {\n-\t\terror_at_line (d->line, \"missing `desc' option for union `%s'\",\n+\t\terror_at_line (d->line,\n+\t\t\t       \"missing `desc' option for union `%s'\",\n \t\t\t       t->u.s.tag);\n \t\tdesc = \"1\";\n \t      }\n@@ -2374,19 +2378,19 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\td->indent += 2;\n \t\tseen_default_p = 1;\n \t      }\n-\t    else if (! union_p && (default_p || tagid))\n+\t    else if (!union_p && (default_p || tagid))\n \t      error_at_line (d->line,\n \t\t\t     \"can't use `%s' outside a union on field `%s'\",\n \t\t\t     default_p ? \"default\" : \"tag\", f->name);\n-\t    else if (union_p && ! (default_p || tagid)\n+\t    else if (union_p && !(default_p || tagid)\n \t\t     && f->type->kind == TYPE_SCALAR)\n \t      {\n \t\tfprintf (stderr,\n-\t\"%s:%d: warning: field `%s' is missing `tag' or `default' option\\n\",\n+\t\t\t \"%s:%d: warning: field `%s' is missing `tag' or `default' option\\n\",\n \t\t\t d->line->file, d->line->line, f->name);\n \t\tcontinue;\n \t      }\n-\t    else if (union_p && ! (default_p || tagid))\n+\t    else if (union_p && !(default_p || tagid))\n \t      error_at_line (d->line,\n \t\t\t     \"field `%s' is missing `tag' or `default' option\",\n \t\t\t     f->name);\n@@ -2415,7 +2419,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \td->prev_val[1] = oldprevval1;\n \td->prev_val[2] = oldprevval2;\n \n-\tif (union_p && ! seen_default_p)\n+\tif (union_p && !seen_default_p)\n \t  {\n \t    oprintf (d->of, \"%*sdefault:\\n\", d->indent, \"\");\n \t    oprintf (d->of, \"%*s  break;\\n\", d->indent, \"\");\n@@ -2488,8 +2492,7 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \t      oprintf (d->of, \", gt_e_\");\n \t      output_mangled_typename (d->of, f);\n \t    }\n-\t  else if (UNION_OR_STRUCT_P (f)\n-\t\t   && f->u.p->u.s.line.file != NULL)\n+\t  else if (UNION_OR_STRUCT_P (f) && f->u.p->u.s.line.file != NULL)\n \t    {\n \t      oprintf (d->of, \", gt_ggc_e_\");\n \t      output_mangled_typename (d->of, f);\n@@ -2551,7 +2554,7 @@ output_type_enum (outf_p of, type_p s)\n static outf_p\n get_output_file_for_structure (const_type_p s, type_p *param)\n {\n-  const char * fn = s->u.s.line.file;\n+  const char *fn = s->u.s.line.file;\n   int i;\n \n   /* This is a hack, and not the good kind either.  */\n@@ -2567,8 +2570,8 @@ get_output_file_for_structure (const_type_p s, type_p *param)\n    PARAM, write out a routine that:\n    - Takes a parameter, a void * but actually of type *S\n    - If SEEN_ROUTINE returns nonzero, calls write_types_process_field on each\n-     field of S or its substructures and (in some cases) things\n-     that are pointed to by S.\n+   field of S or its substructures and (in some cases) things\n+   that are pointed to by S.\n */\n \n static void\n@@ -2610,7 +2613,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   d.bitmap = s->u.s.bitmap;\n   d.param = param;\n   d.prev_val[0] = \"*x\";\n-  d.prev_val[1] = \"not valid postage\";  /* Guarantee an error.  */\n+  d.prev_val[1] = \"not valid postage\";\t/* Guarantee an error.  */\n   d.prev_val[3] = \"x\";\n   d.val = \"(*x)\";\n \n@@ -2682,8 +2685,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t  oprintf (d.of, \");\\n\");\n \t  oprintf (d.of, \"        if (xprev == NULL) break;\\n\");\n \t  oprintf (d.of, \"        x = xprev;\\n\");\n-\t  oprintf (d.of, \"        (void) %s (xprev\",\n-\t\t   wtd->marker_routine);\n+\t  oprintf (d.of, \"        (void) %s (xprev\", wtd->marker_routine);\n \t  if (wtd->param_prefix)\n \t    {\n \t      oprintf (d.of, \", xprev, gt_%s_\", wtd->param_prefix);\n@@ -2745,13 +2747,11 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n      emitted afterwards.  This is needed in plugin mode.  */\n   oprintf (output_header, \"/* macros and declarations */\\n\");\n   for (s = structures; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO\n-\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n \toptions_p opt;\n \n-\tif (s->gc_used == GC_MAYBE_POINTED_TO\n-\t    && s->u.s.line.file == NULL)\n+\tif (s->gc_used == GC_MAYBE_POINTED_TO && s->u.s.line.file == NULL)\n \t  continue;\n \n \toprintf (output_header, \"#define gt_%s_\", wtd->prefix);\n@@ -2760,16 +2760,14 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \toprintf (output_header,\n \t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix,\n \t\t s->u.s.tag);\n-\toprintf (output_header,\n-\t\t \"  } while (0)\\n\");\n+\toprintf (output_header, \"  } while (0)\\n\");\n \n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n \t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n \t    {\n \t      const_type_p const t = (const_type_p) opt->info;\n \t      if (t->kind == TYPE_STRUCT\n-\t\t  || t->kind == TYPE_UNION\n-\t\t  || t->kind == TYPE_LANG_STRUCT)\n+\t\t  || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)\n \t\toprintf (output_header,\n \t\t\t \"#define gt_%sx_%s gt_%sx_%s\\n\",\n \t\t\t wtd->prefix, s->u.s.tag, wtd->prefix, t->u.s.tag);\n@@ -2815,13 +2813,11 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n   /* At last we emit the functions code.  */\n   oprintf (output_header, \"\\n/* functions code */\\n\");\n   for (s = structures; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO\n-\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n \toptions_p opt;\n \n-\tif (s->gc_used == GC_MAYBE_POINTED_TO\n-\t    && s->u.s.line.file == NULL)\n+\tif (s->gc_used == GC_MAYBE_POINTED_TO && s->u.s.line.file == NULL)\n \t  continue;\n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n \t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n@@ -2856,15 +2852,13 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n       }\n }\n \n-static const struct write_types_data ggc_wtd =\n-{\n+static const struct write_types_data ggc_wtd = {\n   \"ggc_m\", NULL, \"ggc_mark\", \"ggc_test_and_set_mark\", NULL,\n   \"GC marker procedures.  \",\n   FALSE\n };\n \n-static const struct write_types_data pch_wtd =\n-{\n+static const struct write_types_data pch_wtd = {\n   \"pch_n\", \"pch_p\", \"gt_pch_note_object\", \"gt_pch_note_object\",\n   \"gt_pch_note_reorder\",\n   \"PCH type-walking procedures.  \",\n@@ -2918,7 +2912,7 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n   d.bitmap = s->u.s.bitmap;\n   d.param = param;\n   d.prev_val[0] = d.prev_val[2] = \"*x\";\n-  d.prev_val[1] = \"not valid postage\";  /* Guarantee an error.  */\n+  d.prev_val[1] = \"not valid postage\";\t/* Guarantee an error.  */\n   d.prev_val[3] = \"x\";\n   d.val = \"(*x)\";\n   d.fn_wants_lvalue = true;\n@@ -2951,8 +2945,7 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n     return;\n   oprintf (output_header, \"\\n/* Local pointer-walking routines.  */\\n\");\n   for (s = structures; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO\n-\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n \toptions_p opt;\n \n@@ -2964,8 +2957,7 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \t    {\n \t      const_type_p const t = (const_type_p) opt->info;\n \t      if (t->kind == TYPE_STRUCT\n-\t\t  || t->kind == TYPE_UNION\n-\t\t  || t->kind == TYPE_LANG_STRUCT)\n+\t\t  || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)\n \t\t{\n \t\t  oprintf (output_header, \"#define gt_pch_p_\");\n \t\t  output_mangled_typename (output_header, s);\n@@ -2985,7 +2977,7 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \toprintf (output_header, \"extern void gt_pch_p_\");\n \toutput_mangled_typename (output_header, s);\n \toprintf (output_header,\n-\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n+\t\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n \n \tif (s->kind == TYPE_LANG_STRUCT)\n \t  {\n@@ -3000,14 +2992,14 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n   for (s = param_structs; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO)\n       {\n-\ttype_p * param = s->u.param_struct.param;\n+\ttype_p *param = s->u.param_struct.param;\n \ttype_p stru = s->u.param_struct.stru;\n \n \t/* Declare the marker procedure.  */\n \toprintf (output_header, \"extern void gt_pch_p_\");\n \toutput_mangled_typename (output_header, s);\n \toprintf (output_header,\n-\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n+\t\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n \n \tif (stru->u.s.line.file == NULL)\n \t  {\n@@ -3084,7 +3076,7 @@ contains_scalar_p (type_p t)\n       return contains_scalar_p (t->u.a.p);\n     default:\n       /* Could also check for structures that have no non-pointer\n-\t fields, but there aren't enough of those to worry about.  */\n+         fields, but there aren't enough of those to worry about.  */\n       return 1;\n     }\n }\n@@ -3131,8 +3123,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \t  if (bitmap & 1)\n \t    {\n \t      oprintf (base_files[fnum],\n-\t\t       \"extern const struct %s gt_%s_\",\n-\t\t       tname, pfx);\n+\t\t       \"extern const struct %s gt_%s_\", tname, pfx);\n \t      put_mangled_filename (base_files[fnum], fli2->name);\n \t      oprintf (base_files[fnum], \"[];\\n\");\n \t    }\n@@ -3141,9 +3132,8 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n   {\n     size_t fnum;\n     for (fnum = 0; base_files && fnum < num_lang_dirs; fnum++)\n-      oprintf (base_files [fnum],\n-\t       \"EXPORTED_CONST struct %s * const %s[] = {\\n\",\n-\t       tname, name);\n+      oprintf (base_files[fnum],\n+\t       \"EXPORTED_CONST struct %s * const %s[] = {\\n\", tname, name);\n   }\n \n \n@@ -3240,13 +3230,13 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n /* Write out to F the table entry and any marker routines needed to\n    mark NAME as TYPE.  V can be one of three values:\n \n-     - null, if NAME is too complex to represent using a single\n-       count and stride.  In this case, it is an error for NAME to\n-       contain any gc-ed data.\n+   - null, if NAME is too complex to represent using a single\n+   count and stride.  In this case, it is an error for NAME to\n+   contain any gc-ed data.\n \n-     - the outermost array that contains NAME, if NAME is part of an array.\n+   - the outermost array that contains NAME, if NAME is part of an array.\n \n-     - the C variable that contains NAME, if NAME is not part of an array.\n+   - the C variable that contains NAME, if NAME is not part of an array.\n \n    LINE is the line of the C source that declares the root variable.\n    HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED\n@@ -3276,7 +3266,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t;\n \t      else\n \t\terror_at_line (line,\n-\t\t       \"field `%s' of global `%s' has unknown option `%s'\",\n+\t\t\t       \"field `%s' of global `%s' has unknown option `%s'\",\n \t\t\t       fld->name, name, o->name);\n \n \t    if (skip_p)\n@@ -3298,10 +3288,9 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t      continue;\n \t\t    if (validf != NULL)\n \t\t      error_at_line (line,\n-\t\t\t   \"both `%s.%s.%s' and `%s.%s.%s' have tag `%s'\",\n+\t\t\t\t     \"both `%s.%s.%s' and `%s.%s.%s' have tag `%s'\",\n \t\t\t\t     name, fld->name, validf->name,\n-\t\t\t\t     name, fld->name, ufld->name,\n-\t\t\t\t     tag);\n+\t\t\t\t     name, fld->name, ufld->name, tag);\n \t\t    validf = ufld;\n \t\t  }\n \t\tif (validf != NULL)\n@@ -3312,7 +3301,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t      }\n \t    else if (desc)\n \t      error_at_line (line,\n-\t\t     \"global `%s.%s' has `desc' option but is not union\",\n+\t\t\t     \"global `%s.%s' has `desc' option but is not union\",\n \t\t\t     name, fld->name);\n \t    else\n \t      write_field_root (f, v, type, name, 0, line, if_marked,\n@@ -3340,15 +3329,15 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n \ttp = type->u.p;\n \n-\tif (! has_length && UNION_OR_STRUCT_P (tp))\n+\tif (!has_length && UNION_OR_STRUCT_P (tp))\n \t  {\n \t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", tp->u.s.tag);\n \t    if (emit_pch)\n \t      oprintf (f, \"    &gt_pch_nx_%s\", tp->u.s.tag);\n \t    else\n \t      oprintf (f, \"    NULL\");\n \t  }\n-\telse if (! has_length && tp->kind == TYPE_PARAM_STRUCT)\n+\telse if (!has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n \t    oprintf (f, \"    &gt_ggc_m_\");\n \t    output_mangled_typename (f, tp);\n@@ -3396,9 +3385,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n       break;\n \n     default:\n-      error_at_line (line,\n-\t\t     \"global `%s' is unimplemented type\",\n-\t\t     name);\n+      error_at_line (line, \"global `%s' is unimplemented type\", name);\n     }\n }\n \n@@ -3424,8 +3411,7 @@ write_array (outf_p f, pair_p v, const struct write_types_data *wtd)\n   if (wtd->param_prefix)\n     {\n       oprintf (f, \"static void gt_%sa_%s\\n\", wtd->param_prefix, v->name);\n-      oprintf (f,\n-       \"    (void *, void *, gt_pointer_operator, void *);\\n\");\n+      oprintf (f, \"    (void *, void *, gt_pointer_operator, void *);\\n\");\n       oprintf (f, \"static void gt_%sa_%s (ATTRIBUTE_UNUSED void *this_obj,\\n\",\n \t       wtd->param_prefix, v->name);\n       oprintf (d.of,\n@@ -3440,8 +3426,7 @@ write_array (outf_p f, pair_p v, const struct write_types_data *wtd)\n     }\n \n   d.opt = v->opt;\n-  oprintf (f, \"static void gt_%sa_%s (void *);\\n\",\n-\t   wtd->prefix, v->name);\n+  oprintf (f, \"static void gt_%sa_%s (void *);\\n\", wtd->prefix, v->name);\n   oprintf (f, \"static void\\ngt_%sa_%s (ATTRIBUTE_UNUSED void *x_p)\\n\",\n \t   wtd->prefix, v->name);\n   oprintf (f, \"{\\n\");\n@@ -3476,8 +3461,7 @@ write_roots (pair_p variables, bool emit_pch)\n \telse if (strcmp (o->name, \"param_is\") == 0)\n \t  ;\n \telse if (strncmp (o->name, \"param\", 5) == 0\n-\t\t && ISDIGIT (o->name[5])\n-\t\t && strcmp (o->name + 6, \"_is\") == 0)\n+\t\t && ISDIGIT (o->name[5]) && strcmp (o->name + 6, \"_is\") == 0)\n \t  ;\n \telse if (strcmp (o->name, \"if_marked\") == 0)\n \t  ;\n@@ -3496,13 +3480,13 @@ write_roots (pair_p variables, bool emit_pch)\n \t  fli->next = flp;\n \t  fli->started_p = 0;\n \t  fli->name = v->line.file;\n-\t  gcc_assert(fli->name);\n+\t  gcc_assert (fli->name);\n \t  flp = fli;\n \n \t  oprintf (f, \"\\n/* GC roots.  */\\n\\n\");\n \t}\n \n-      if (! deletable_p\n+      if (!deletable_p\n \t  && length\n \t  && v->type->kind == TYPE_POINTER\n \t  && (v->type->u.p->kind == TYPE_POINTER\n@@ -3534,7 +3518,7 @@ write_roots (pair_p variables, bool emit_pch)\n       for (fli = flp; fli; fli = fli->next)\n \tif (fli->f == f)\n \t  break;\n-      if (! fli->started_p)\n+      if (!fli->started_p)\n \t{\n \t  fli->started_p = 1;\n \n@@ -3568,7 +3552,7 @@ write_roots (pair_p variables, bool emit_pch)\n       for (fli = flp; fli; fli = fli->next)\n \tif (fli->f == f)\n \t  break;\n-      if (! fli->started_p)\n+      if (!fli->started_p)\n \t{\n \t  fli->started_p = 1;\n \n@@ -3605,14 +3589,15 @@ write_roots (pair_p variables, bool emit_pch)\n \t  || v->type->u.p->kind != TYPE_PARAM_STRUCT\n \t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\", 0))\n \t{\n-\t  error_at_line (&v->line, \"if_marked option used but not hash table\");\n+\t  error_at_line (&v->line,\n+\t\t\t \"if_marked option used but not hash table\");\n \t  continue;\n \t}\n \n       for (fli = flp; fli; fli = fli->next)\n \tif (fli->f == f)\n \t  break;\n-      if (! fli->started_p)\n+      if (!fli->started_p)\n \t{\n \t  fli->started_p = 1;\n \n@@ -3645,13 +3630,13 @@ write_roots (pair_p variables, bool emit_pch)\n \telse if (strcmp (o->name, \"if_marked\") == 0)\n \t  if_marked_p = 1;\n \n-      if (! if_marked_p)\n+      if (!if_marked_p)\n \tcontinue;\n \n       for (fli = flp; fli; fli = fli->next)\n \tif (fli->f == f)\n \t  break;\n-      if (! fli->started_p)\n+      if (!fli->started_p)\n \t{\n \t  fli->started_p = 1;\n \n@@ -3681,13 +3666,13 @@ write_roots (pair_p variables, bool emit_pch)\n       if (skip_p)\n \tcontinue;\n \n-      if (! contains_scalar_p (v->type))\n+      if (!contains_scalar_p (v->type))\n \tcontinue;\n \n       for (fli = flp; fli; fli = fli->next)\n \tif (fli->f == f)\n \t  break;\n-      if (! fli->started_p)\n+      if (!fli->started_p)\n \t{\n \t  fli->started_p = 1;\n \n@@ -3722,7 +3707,7 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n   type_p t;\n   options_p o;\n   type_p len_ty = create_scalar_type (\"unsigned\");\n-  const char *name = concat (\"VEC_\", type_name, \"_base\", (char *)0);\n+  const char *name = concat (\"VEC_\", type_name, \"_base\", (char *) 0);\n \n   if (is_scalar)\n     {\n@@ -3747,14 +3732,14 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n    we had expanded the macros in vec.h:\n \n    typedef struct VEC_<type>_<astrat> {\n-     VEC_<type>_base base;\n+   VEC_<type>_base base;\n    } VEC_<type>_<astrat>;\n */\n void\n note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n {\n-  const char *astratname = concat (\"VEC_\", type, \"_\", astrat, (char *)0);\n-  const char *basename = concat (\"VEC_\", type, \"_base\", (char *)0);\n+  const char *astratname = concat (\"VEC_\", type, \"_\", astrat, (char *) 0);\n+  const char *basename = concat (\"VEC_\", type, \"_base\", (char *) 0);\n \n   pair_p field = create_field_at (0, resolve_typedef (basename, pos),\n \t\t\t\t  \"base\", 0, pos);\n@@ -3787,8 +3772,10 @@ variable_size_p (const type_p s)\n   return false;\n }\n \n-enum alloc_quantity { single, vector };\n-enum alloc_zone { any_zone, specific_zone };\n+enum alloc_quantity\n+{ single, vector };\n+enum alloc_zone\n+{ any_zone, specific_zone };\n \n /* Writes one typed allocator definition for type identifier TYPE_NAME with\n    optional type specifier TYPE_SPECIFIER.  The allocator name will contain\n@@ -3798,15 +3785,15 @@ enum alloc_zone { any_zone, specific_zone };\n    the allocator will be zone-specific.  */\n \n static void\n-write_typed_alloc_def (bool variable_size, const char * type_specifier,\n-\t\t       const char * type_name, const char * allocator_type,\n+write_typed_alloc_def (bool variable_size, const char *type_specifier,\n+\t\t       const char *type_name, const char *allocator_type,\n \t\t       enum alloc_quantity quantity, enum alloc_zone zone)\n {\n   bool two_args = variable_size && (quantity == vector);\n   bool third_arg = ((zone == specific_zone)\n \t\t    && (variable_size || (quantity == vector)));\n \n-  oprintf (header_file, \"#define ggc_alloc_%s%s\",allocator_type, type_name);\n+  oprintf (header_file, \"#define ggc_alloc_%s%s\", allocator_type, type_name);\n   oprintf (header_file, \"(%s%s%s%s%s) \",\n \t   (variable_size ? \"SIZE\" : \"\"),\n \t   (two_args ? \", \" : \"\"),\n@@ -3828,7 +3815,7 @@ write_typed_alloc_def (bool variable_size, const char * type_specifier,\n /* Writes a typed allocator definition for a struct or union S.  */\n \n static void\n-write_typed_struct_alloc_def (const type_p s, const char * allocator_type,\n+write_typed_struct_alloc_def (const type_p s, const char *allocator_type,\n \t\t\t      enum alloc_quantity quantity,\n \t\t\t      enum alloc_zone zone)\n {\n@@ -3839,7 +3826,7 @@ write_typed_struct_alloc_def (const type_p s, const char * allocator_type,\n /* Writes a typed allocator definition for a typedef P.  */\n \n static void\n-write_typed_typedef_alloc_def (const pair_p p, const char * allocator_type,\n+write_typed_typedef_alloc_def (const pair_p p, const char *allocator_type,\n \t\t\t       enum alloc_quantity quantity,\n \t\t\t       enum alloc_zone zone)\n {\n@@ -3920,15 +3907,16 @@ output_typename (outf_p of, const_type_p t)\n       {\n \tint i;\n \tfor (i = 0; i < NUM_PARAM; i++)\n-\t  if (t->u.param_struct.param[i] != NULL) {\n-\t    output_typename (of, t->u.param_struct.param[i]);\n-\t    oprintf (of, \"_\");\n-\t  }\n+\t  if (t->u.param_struct.param[i] != NULL)\n+\t    {\n+\t      output_typename (of, t->u.param_struct.param[i]);\n+\t      oprintf (of, \"_\");\n+\t    }\n \toutput_typename (of, t->u.param_struct.stru);\n \tbreak;\n       }\n     default:\n-      gcc_unreachable();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3938,7 +3926,7 @@ output_typename (outf_p of, const_type_p t)\n static void\n write_splay_tree_allocator_def (const_type_p s)\n {\n-  outf_p of = get_output_file_for_structure(s, NULL);\n+  outf_p of = get_output_file_for_structure (s, NULL);\n   oprintf (of, \"void * ggc_alloc_splay_tree_\");\n   output_typename (of, s);\n   oprintf (of, \" (int sz, void * nl)\\n\");\n@@ -3983,15 +3971,32 @@ dump_typekind (int indent, enum typekind kind)\n   printf (\"%*ckind = \", indent, ' ');\n   switch (kind)\n     {\n-    case TYPE_SCALAR: printf (\"TYPE_SCALAR\"); break;\n-    case TYPE_STRING: printf (\"TYPE_STRING\"); break;\n-    case TYPE_STRUCT: printf (\"TYPE_STRUCT\"); break;\n-    case TYPE_UNION:  printf (\"TYPE_UNION\"); break;\n-    case TYPE_POINTER: printf (\"TYPE_POINTER\"); break;\n-    case TYPE_ARRAY: printf (\"TYPE_ARRAY\"); break;\n-    case TYPE_LANG_STRUCT: printf (\"TYPE_LANG_STRUCT\"); break;\n-    case TYPE_PARAM_STRUCT: printf (\"TYPE_PARAM_STRUCT\"); break;\n-    default: gcc_unreachable ();\n+    case TYPE_SCALAR:\n+      printf (\"TYPE_SCALAR\");\n+      break;\n+    case TYPE_STRING:\n+      printf (\"TYPE_STRING\");\n+      break;\n+    case TYPE_STRUCT:\n+      printf (\"TYPE_STRUCT\");\n+      break;\n+    case TYPE_UNION:\n+      printf (\"TYPE_UNION\");\n+      break;\n+    case TYPE_POINTER:\n+      printf (\"TYPE_POINTER\");\n+      break;\n+    case TYPE_ARRAY:\n+      printf (\"TYPE_ARRAY\");\n+      break;\n+    case TYPE_LANG_STRUCT:\n+      printf (\"TYPE_LANG_STRUCT\");\n+      break;\n+    case TYPE_PARAM_STRUCT:\n+      printf (\"TYPE_PARAM_STRUCT\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n   printf (\"\\n\");\n }\n@@ -4004,11 +4009,20 @@ dump_gc_used (int indent, enum gc_used_enum gc_used)\n   printf (\"%*cgc_used = \", indent, ' ');\n   switch (gc_used)\n     {\n-    case GC_UNUSED: printf (\"GC_UNUSED\"); break;\n-    case GC_USED: printf (\"GC_USED\"); break;\n-    case GC_MAYBE_POINTED_TO: printf (\"GC_MAYBE_POINTED_TO\"); break;\n-    case GC_POINTED_TO: printf (\"GC_POINTED_TO\"); break;\n-    default: gcc_unreachable ();\n+    case GC_UNUSED:\n+      printf (\"GC_UNUSED\");\n+      break;\n+    case GC_USED:\n+      printf (\"GC_USED\");\n+      break;\n+    case GC_MAYBE_POINTED_TO:\n+      printf (\"GC_MAYBE_POINTED_TO\");\n+      break;\n+    case GC_POINTED_TO:\n+      printf (\"GC_POINTED_TO\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n   printf (\"\\n\");\n }\n@@ -4023,8 +4037,8 @@ dump_options (int indent, options_p opt)\n   o = opt;\n   while (o)\n     {\n-       printf (\"%s:%s \", o->name, o->info);\n-       o = o->next;\n+      printf (\"%s:%s \", o->name, o->info);\n+      o = o->next;\n     }\n   printf (\"\\n\");\n }\n@@ -4054,8 +4068,8 @@ dump_type_u_s (int indent, type_p t)\n   fields = t->u.s.fields;\n   while (fields)\n     {\n-       dump_pair (indent + INDENT, fields);\n-       fields = fields->next;\n+      dump_pair (indent + INDENT, fields);\n+      fields = fields->next;\n     }\n   printf (\"%*cend of fields of type %p\\n\", indent, ' ', (void *) t);\n   dump_options (indent, t->u.s.opt);\n@@ -4118,7 +4132,7 @@ dump_type (int indent, type_p t)\n {\n   PTR *slot;\n \n-  printf (\"%*cType at %p: \", indent, ' ', (void *)t);\n+  printf (\"%*cType at %p: \", indent, ' ', (void *) t);\n   slot = htab_find_slot (seen_types, t, INSERT);\n   if (*slot != NULL)\n     {\n@@ -4130,7 +4144,7 @@ dump_type (int indent, type_p t)\n \n   dump_typekind (indent, t->kind);\n   printf (\"%*cpointer_to = %p\\n\", indent + INDENT, ' ',\n-\t  (void *)t->pointer_to);\n+\t  (void *) t->pointer_to);\n   dump_gc_used (indent + INDENT, t->gc_used);\n   switch (t->kind)\n     {\n@@ -4158,7 +4172,7 @@ dump_type (int indent, type_p t)\n     default:\n       gcc_unreachable ();\n     }\n-  printf (\"%*cEnd of type at %p\\n\", indent, ' ', (void *)t);\n+  printf (\"%*cEnd of type at %p\\n\", indent, ' ', (void *) t);\n }\n \n /* Dumps the pair P.  */\n@@ -4176,7 +4190,7 @@ dump_pair (int indent, pair_p p)\n /* Dumps the list of pairs PP.  */\n \n static void\n-dump_pair_list (const char * name, pair_p pp)\n+dump_pair_list (const char *name, pair_p pp)\n {\n   pair_p p;\n   printf (\"%s:\\n\", name);\n@@ -4188,7 +4202,7 @@ dump_pair_list (const char * name, pair_p pp)\n /* Dumps the STRUCTURES.  */\n \n static void\n-dump_structures (const char * name, type_p structures)\n+dump_structures (const char *name, type_p structures)\n {\n   printf (\"%s:\\n\", name);\n   dump_type_list (0, structures);\n@@ -4207,17 +4221,17 @@ dump_everything (void)\n   dump_pair_list (\"variables\", variables);\n   htab_delete (seen_types);\n }\n-\n \f\n+\n int\n main (int argc, char **argv)\n {\n   size_t i;\n   static struct fileloc pos = { this_file, 0 };\n-  char* inputlist = 0;\n+  char *inputlist = 0;\n   int do_dump = 0;\n   outf_p output_header;\n-  char* plugin_output_filename = NULL;\n+  char *plugin_output_filename = NULL;\n   /* fatal uses this */\n   progname = \"gengtype\";\n \n@@ -4237,14 +4251,14 @@ main (int argc, char **argv)\n       nb_plugin_files = argc - 5;\n       plugin_files = XCNEWVEC (char *, nb_plugin_files);\n       for (i = 0; i < nb_plugin_files; i++)\n-      {\n-        /* Place an all zero lang_bitmap before the plugin file\n-\t   name.  */\n-        char *name = argv[i + 5];\n-        int len = strlen(name) + 1 + sizeof (lang_bitmap);\n-        plugin_files[i] = XCNEWVEC (char, len) + sizeof (lang_bitmap);\n-        strcpy (plugin_files[i], name);\n-      }\n+\t{\n+\t  /* Place an all zero lang_bitmap before the plugin file\n+\t     name.  */\n+\t  char *name = argv[i + 5];\n+\t  int len = strlen (name) + 1 + sizeof (lang_bitmap);\n+\t  plugin_files[i] = XCNEWVEC (char, len) + sizeof (lang_bitmap);\n+\t  strcpy (plugin_files[i], name);\n+\t}\n     }\n   else if (argc == 3)\n     {\n@@ -4253,7 +4267,7 @@ main (int argc, char **argv)\n     }\n   else\n     fatal (\"usage: gengtype [-d] [-P pluginout.h] srcdir input-list \"\n-           \"[file1 file2 ... fileN]\");\n+\t   \"[file1 file2 ... fileN]\");\n \n   srcdir_len = strlen (srcdir);\n \n@@ -4268,15 +4282,24 @@ main (int argc, char **argv)\n   /* These types are set up with #define or else outside of where\n      we can see them.  */\n   pos.line = __LINE__ + 1;\n-  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos); pos.line++;\n-  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos); pos.line++;\n-  do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos); pos.line++;\n-  do_scalar_typedef (\"double_int\", &pos); pos.line++;\n-  do_scalar_typedef (\"uint64_t\", &pos); pos.line++;\n-  do_scalar_typedef (\"uint8\", &pos); pos.line++;\n-  do_scalar_typedef (\"jword\", &pos); pos.line++;\n-  do_scalar_typedef (\"JCF_u2\", &pos); pos.line++;\n-  do_scalar_typedef (\"void\", &pos); pos.line++;\n+  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"double_int\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"uint64_t\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"uint8\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"jword\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"JCF_u2\", &pos);\n+  pos.line++;\n+  do_scalar_typedef (\"void\", &pos);\n+  pos.line++;\n   do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)), &pos);\n \n   for (i = 0; i < num_gt_files; i++)\n@@ -4306,11 +4329,11 @@ main (int argc, char **argv)\n     dump_everything ();\n \n   if (plugin_files)\n-  {\n-    for (i = 0; i < nb_plugin_files; i++)\n-      free (plugin_files[i] - sizeof (lang_bitmap));\n-    free (plugin_files);\n-  }\n+    {\n+      for (i = 0; i < nb_plugin_files; i++)\n+\tfree (plugin_files[i] - sizeof (lang_bitmap));\n+      free (plugin_files);\n+    }\n \n   if (hit_error)\n     return 1;"}, {"sha": "304d3b17ae46859f5047eff527dcee7d61515c35", "filename": "gcc/gengtype.h", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b793e7c10393b112937ce3e7de4db903052618/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=e1b793e7c10393b112937ce3e7de4db903052618", "patch": "@@ -1,28 +1,29 @@\n /* Process source files and output type information.\n    Copyright (C) 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #ifndef GCC_GENGTYPE_H\n #define GCC_GENGTYPE_H\n \n /* A file position, mostly for error messages.\n    The FILE element may be compared using pointer equality.  */\n-struct fileloc {\n+struct fileloc\n+{\n   const char *file;\n   int line;\n };\n@@ -39,10 +40,12 @@ extern struct fileloc lexer_line;\n \n /* Print an error message.  */\n extern void error_at_line\n-  (const struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n+(const struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n /* Like asprintf, but calls fatal() on out of memory.  */\n-extern char *xasprintf(const char *, ...) ATTRIBUTE_PRINTF_1;\n+extern char *\n+xasprintf (const char *, ...)\n+  ATTRIBUTE_PRINTF_1;\n \n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n@@ -55,11 +58,14 @@ extern type_p find_structure (const char *s, int isunion);\n extern type_p create_scalar_type (const char *name);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n-extern options_p create_option (options_p, const char *name, const void *info);\n+extern options_p create_option (options_p, const char *name,\n+\t\t\t\tconst void *info);\n extern options_p create_nested_ptr_option (options_p, type_p t,\n-\t\t\t\t\t   const char *from, const char *to);\n-extern pair_p create_field_at (pair_p next, type_p type, const char *name,\n-\t\t\t       options_p opt, struct fileloc *pos);\n+\t\t\t\t\t   const char *from,\n+\t\t\t\t\t   const char *to);\n+extern pair_p create_field_at (pair_p next, type_p type,\n+\t\t\t       const char *name, options_p opt,\n+\t\t\t       struct fileloc *pos);\n extern pair_p nreverse_pairs (pair_p list);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n@@ -77,37 +83,38 @@ extern void parse_file (const char *name);\n extern bool hit_error;\n \n /* Token codes.  */\n-enum {\n-  EOF_TOKEN = 0,\n-\n-  /* Per standard convention, codes in the range (0, UCHAR_MAX]\n-     represent single characters with those character codes.  */\n-\n-  CHAR_TOKEN_OFFSET = UCHAR_MAX + 1,\n-  GTY_TOKEN = CHAR_TOKEN_OFFSET,\n-  TYPEDEF,\n-  EXTERN,\n-  STATIC,\n-  UNION,\n-  STRUCT,\n-  ENUM,\n-  VEC_TOKEN,\n-  DEFVEC_OP,\n-  DEFVEC_I,\n-  DEFVEC_ALLOC,\n-  ELLIPSIS,\n-  PTR_ALIAS,\n-  NESTED_PTR,\n-  PARAM_IS,\n-  NUM,\n-  SCALAR,\n-  ID,\n-  STRING,\n-  CHAR,\n-  ARRAY,\n-\n-  /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n-     a meaningful value to be printed.  */\n-  FIRST_TOKEN_WITH_VALUE = PARAM_IS\n-};\n+enum\n+  {\n+    EOF_TOKEN = 0,\n+\n+    /* Per standard convention, codes in the range (0, UCHAR_MAX]\n+       represent single characters with those character codes.  */\n+\n+    CHAR_TOKEN_OFFSET = UCHAR_MAX + 1,\n+    GTY_TOKEN = CHAR_TOKEN_OFFSET,\n+    TYPEDEF,\n+    EXTERN,\n+    STATIC,\n+    UNION,\n+    STRUCT,\n+    ENUM,\n+    VEC_TOKEN,\n+    DEFVEC_OP,\n+    DEFVEC_I,\n+    DEFVEC_ALLOC,\n+    ELLIPSIS,\n+    PTR_ALIAS,\n+    NESTED_PTR,\n+    PARAM_IS,\n+    NUM,\n+    SCALAR,\n+    ID,\n+    STRING,\n+    CHAR,\n+    ARRAY,\n+\n+    /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n+       a meaningful value to be printed.  */\n+    FIRST_TOKEN_WITH_VALUE = PARAM_IS\n+  };\n #endif"}]}