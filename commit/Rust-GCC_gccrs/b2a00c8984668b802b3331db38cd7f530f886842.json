{"sha": "b2a00c8984668b802b3331db38cd7f530f886842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJhMDBjODk4NDY2OGI4MDJiMzMzMWRiMzhjZDdmNTMwZjg4Njg0Mg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2007-09-27T17:47:23Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-09-27T17:47:23Z"}, "message": "Makefile.in (dfp-filenames): Replace decimal_globals...\n\nlibgcc/\n\n2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* Makefile.in (dfp-filenames): Replace decimal_globals,\n\tdecimal_data, binarydecimal and convert_data with\n\tbid_decimal_globals, bid_decimal_data, bid_binarydecimal\n\tand bid_convert_data, respectively.\n\nlibgcc/config/libbid/\n\n2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* bid128_fromstring.c: Removed.\n\n\t* bid_dpd.c: New from libbid 2007-09-26.\n\t* bid128_to_int16.c: Likewise.\n\t* bid128_to_int8.c: Likewise.\n\t* bid128_to_uint8.c: Likewise.\n\t* bid128_to_uint16.c: Likewise.\n\t* bid64_to_int16.c: Likewise.\n\t* bid64_to_int8.c: Likewise.\n\t* bid64_to_uint16.c: Likewise.\n\t* bid64_to_uint8.c: Likewise.\n\n\t* bid128_2_str.h: Updated from libbid 2007-09-26.\n\t* bid128_2_str_macros.h: Likewise.\n\t* bid128_2_str_tables.c: Likewise.\n\t* bid128_add.c: Likewise.\n\t* bid128.c: Likewise.\n\t* bid128_compare.c: Likewise.\n\t* bid128_div.c: Likewise.\n\t* bid128_fma.c: Likewise.\n\t* bid128_logb.c: Likewise.\n\t* bid128_minmax.c: Likewise.\n\t* bid128_mul.c: Likewise.\n\t* bid128_next.c: Likewise.\n\t* bid128_noncomp.c: Likewise.\n\t* bid128_quantize.c: Likewise.\n\t* bid128_rem.c: Likewise.\n\t* bid128_round_integral.c: Likewise.\n\t* bid128_scalb.c: Likewise.\n\t* bid128_sqrt.c: Likewise.\n\t* bid128_string.c: Likewise.\n\t* bid128_to_int32.c: Likewise.\n\t* bid128_to_int64.c: Likewise.\n\t* bid128_to_uint32.c: Likewise.\n\t* bid128_to_uint64.c: Likewise.\n\t* bid32_to_bid128.c: Likewise.\n\t* bid32_to_bid64.c: Likewise.\n\t* bid64_add.c: Likewise.\n\t* bid64_compare.c: Likewise.\n\t* bid64_div.c: Likewise.\n\t* bid64_fma.c: Likewise.\n\t* bid64_logb.c: Likewise.\n\t* bid64_minmax.c: Likewise.\n\t* bid64_mul.c: Likewise.\n\t* bid64_next.c: Likewise.\n\t* bid64_noncomp.c: Likewise.\n\t* bid64_quantize.c: Likewise.\n\t* bid64_rem.c: Likewise.\n\t* bid64_round_integral.c: Likewise.\n\t* bid64_scalb.c: Likewise.\n\t* bid64_sqrt.c: Likewise.\n\t* bid64_string.c: Likewise.\n\t* bid64_to_bid128.c: Likewise.\n\t* bid64_to_int32.c: Likewise.\n\t* bid64_to_int64.c: Likewise.\n\t* bid64_to_uint32.c: Likewise.\n\t* bid64_to_uint64.c: Likewise.\n\t* bid_b2d.h: Likewise.\n\t* bid_binarydecimal.c: Likewise.\n\t* bid_conf.h: Likewise.\n\t* bid_convert_data.c: Likewise.\n\t* bid_decimal_data.c: Likewise.\n\t* bid_decimal_globals.c: Likewise.\n\t* bid_div_macros.h: Likewise.\n\t* bid_flag_operations.c: Likewise.\n\t* bid_from_int.c: Likewise.\n\t* bid_functions.h: Likewise.\n\t* bid_gcc_intrinsics.h: Likewise.\n\t* bid_inline_add.h: Likewise.\n\t* bid_internal.h: Likewise.\n\t* bid_round.c: Likewise.\n\t* bid_sqrt_macros.h: Likewise.\n\t* _addsub_dd.c: Likewise.\n\t* _addsub_sd.c: Likewise.\n\t* _addsub_td.c: Likewise.\n\t* _dd_to_df.c: Likewise.\n\t* _dd_to_di.c: Likewise.\n\t* _dd_to_sd.c: Likewise.\n\t* _dd_to_sf.c: Likewise.\n\t* _dd_to_si.c: Likewise.\n\t* _dd_to_td.c: Likewise.\n\t* _dd_to_tf.c: Likewise.\n\t* _dd_to_udi.c: Likewise.\n\t* _dd_to_usi.c: Likewise.\n\t* _dd_to_xf.c: Likewise.\n\t* _df_to_dd.c: Likewise.\n\t* _df_to_sd.c: Likewise.\n\t* _df_to_td.c: Likewise.\n\t* _di_to_dd.c: Likewise.\n\t* _di_to_sd.c: Likewise.\n\t* _di_to_td.c: Likewise.\n\t* _div_dd.c: Likewise.\n\t* _div_sd.c: Likewise.\n\t* _div_td.c: Likewise.\n\t* _eq_dd.c: Likewise.\n\t* _eq_sd.c: Likewise.\n\t* _eq_td.c: Likewise.\n\t* _ge_dd.c: Likewise.\n\t* _ge_sd.c: Likewise.\n\t* _ge_td.c: Likewise.\n\t* _gt_dd.c: Likewise.\n\t* _gt_sd.c: Likewise.\n\t* _gt_td.c: Likewise.\n\t* _isinfd128.c: Likewise.\n\t* _isinfd32.c: Likewise.\n\t* _isinfd64.c: Likewise.\n\t* _le_dd.c: Likewise.\n\t* _le_sd.c: Likewise.\n\t* _le_td.c: Likewise.\n\t* _lt_dd.c: Likewise.\n\t* _lt_sd.c: Likewise.\n\t* _lt_td.c: Likewise.\n\t* _mul_dd.c: Likewise.\n\t* _mul_sd.c: Likewise.\n\t* _mul_td.c: Likewise.\n\t* _ne_dd.c: Likewise.\n\t* _ne_sd.c: Likewise.\n\t* _ne_td.c: Likewise.\n\t* _sd_to_dd.c: Likewise.\n\t* _sd_to_df.c: Likewise.\n\t* _sd_to_di.c: Likewise.\n\t* _sd_to_sf.c: Likewise.\n\t* _sd_to_si.c: Likewise.\n\t* _sd_to_td.c: Likewise.\n\t* _sd_to_tf.c: Likewise.\n\t* _sd_to_udi.c: Likewise.\n\t* _sd_to_usi.c: Likewise.\n\t* _sd_to_xf.c: Likewise.\n\t* _sf_to_dd.c: Likewise.\n\t* _sf_to_sd.c: Likewise.\n\t* _sf_to_td.c: Likewise.\n\t* _si_to_dd.c: Likewise.\n\t* _si_to_sd.c: Likewise.\n\t* _si_to_td.c: Likewise.\n\t* _td_to_dd.c: Likewise.\n\t* _td_to_df.c: Likewise.\n\t* _td_to_di.c: Likewise.\n\t* _td_to_sd.c: Likewise.\n\t* _td_to_sf.c: Likewise.\n\t* _td_to_si.c: Likewise.\n\t* _td_to_tf.c: Likewise.\n\t* _td_to_udi.c: Likewise.\n\t* _td_to_usi.c: Likewise.\n\t* _td_to_xf.c: Likewise.\n\t* _tf_to_dd.c: Likewise.\n\t* _tf_to_sd.c: Likewise.\n\t* _tf_to_td.c: Likewise.\n\t* _udi_to_dd.c: Likewise.\n\t* _udi_to_sd.c: Likewise.\n\t* _udi_to_td.c: Likewise.\n\t* _unord_dd.c: Likewise.\n\t* _unord_sd.c: Likewise.\n\t* _unord_td.c: Likewise.\n\t* _usi_to_dd.c: Likewise.\n\t* _usi_to_sd.c: Likewise.\n\t* _usi_to_td.c: Likewise.\n\t* _xf_to_dd.c: Likewise.\n\t* _xf_to_sd.c: Likewise.\n\t* _xf_to_td.c: Likewise.\n\n2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* b2d.h: Renamed to ...\n\t* bid_b2d.h: This.\n\n\t* bid128_to_string.c: Renamed to ...\n\t* bid128_string.c: This.\n\n\t* bid_intrinsics.h: Renamed to ...\n\t* bid_gcc_intrinsics.h: This.\n\n\t* bid_string.c: Renamed to ...\n\t* bid64_string.c: This.\n\n\t* binarydecimal.c: Renamed to ...\n\t* bid_decimal_globals.c: This.\n\n\t* convert_data.c: Renamed to ...\n\t* bid_convert_data.c: This.\n\n\t* decimal_data.c: Renamed to ...\n\t* bid_decimal_data.c: This.\n\n\t* decimal_globals.c: Renamed to ...\n\t* bid_decimal_globals.c: This.\n\n\t* div_macros.h: Renamed to ...\n\t* bid_div_macros.h: This.\n\n\t* inline_bid_add.h: Renamed to ...\n\t* bid_inline_add.h: This.\n\n\t* sqrt_macros.h: Renamed to ...\n\t* bid_sqrt_macros.h: This.\n\nFrom-SVN: r128841", "tree": {"sha": "373fa862a43e43bb30e4f569c9c95e43119764f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/373fa862a43e43bb30e4f569c9c95e43119764f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2a00c8984668b802b3331db38cd7f530f886842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a00c8984668b802b3331db38cd7f530f886842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a00c8984668b802b3331db38cd7f530f886842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a00c8984668b802b3331db38cd7f530f886842/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e233ac979c0f179f858f3c86281835a4c09cece2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e233ac979c0f179f858f3c86281835a4c09cece2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e233ac979c0f179f858f3c86281835a4c09cece2"}], "stats": {"total": 326364, "additions": 190331, "deletions": 136033}, "files": [{"sha": "9cc057f01e7676512f6300b7eb34c8d48bec10ba", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -1,3 +1,10 @@\n+2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* Makefile.in (dfp-filenames): Replace decimal_globals,\n+\tdecimal_data, binarydecimal and convert_data with\n+\tbid_decimal_globals, bid_decimal_data, bid_binarydecimal\n+\tand bid_convert_data, respectively.\n+\n 2007-09-17  Chao-ying Fu  <fu@mips.com>\n \t    Nigel Stephens  <nigel@mips.com>\n "}, {"sha": "60feaff768e68e5c6c762a345660ba900119ba3a", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -478,9 +478,10 @@ endif\n dfp-filenames =\n ifneq ($(D32PBIT)$(D64PBIT)$(D128PBIT),)\n ifeq ($(enable_decimal_float),bid)\n-dfp-filenames += decimal_globals decimal_data binarydecimal \\\n-\t\t _isinfd32 _isinfd64 _isinfd128 bid64_noncomp bid128_noncomp \\\n-\t\t bid128_fma bid_round bid_from_int convert_data \\\n+dfp-filenames += bid_decimal_globals bid_decimal_data \\\n+\t\t bid_binarydecimal bid_convert_data \\\n+\t\t _isinfd32 _isinfd64 _isinfd128 bid64_noncomp \\\n+\t\t bid128_noncomp bid128_fma bid_round bid_from_int \\\n \t\t bid64_add bid128_add bid64_div bid128_div \\\n \t\t bid64_mul bid128_mul bid64_compare bid128_compare \\\n \t\t bid128 bid32_to_bid64 bid32_to_bid128 bid64_to_bid128 \\"}, {"sha": "d7f52794859b9612c2829d2ecee330437f1152bc", "filename": "libgcc/config/libbid/ChangeLog", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2FChangeLog?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -1,3 +1,200 @@\n+2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* bid128_fromstring.c: Removed.\n+\n+\t* bid_dpd.c: New from libbid 2007-09-26.\n+\t* bid128_to_int16.c: Likewise.\n+\t* bid128_to_int8.c: Likewise.\n+\t* bid128_to_uint8.c: Likewise.\n+\t* bid128_to_uint16.c: Likewise.\n+\t* bid64_to_int16.c: Likewise.\n+\t* bid64_to_int8.c: Likewise.\n+\t* bid64_to_uint16.c: Likewise.\n+\t* bid64_to_uint8.c: Likewise.\n+\n+\t* bid128_2_str.h: Updated from libbid 2007-09-26.\n+\t* bid128_2_str_macros.h: Likewise.\n+\t* bid128_2_str_tables.c: Likewise.\n+\t* bid128_add.c: Likewise.\n+\t* bid128.c: Likewise.\n+\t* bid128_compare.c: Likewise.\n+\t* bid128_div.c: Likewise.\n+\t* bid128_fma.c: Likewise.\n+\t* bid128_logb.c: Likewise.\n+\t* bid128_minmax.c: Likewise.\n+\t* bid128_mul.c: Likewise.\n+\t* bid128_next.c: Likewise.\n+\t* bid128_noncomp.c: Likewise.\n+\t* bid128_quantize.c: Likewise.\n+\t* bid128_rem.c: Likewise.\n+\t* bid128_round_integral.c: Likewise.\n+\t* bid128_scalb.c: Likewise.\n+\t* bid128_sqrt.c: Likewise.\n+\t* bid128_string.c: Likewise.\n+\t* bid128_to_int32.c: Likewise.\n+\t* bid128_to_int64.c: Likewise.\n+\t* bid128_to_uint32.c: Likewise.\n+\t* bid128_to_uint64.c: Likewise.\n+\t* bid32_to_bid128.c: Likewise.\n+\t* bid32_to_bid64.c: Likewise.\n+\t* bid64_add.c: Likewise.\n+\t* bid64_compare.c: Likewise.\n+\t* bid64_div.c: Likewise.\n+\t* bid64_fma.c: Likewise.\n+\t* bid64_logb.c: Likewise.\n+\t* bid64_minmax.c: Likewise.\n+\t* bid64_mul.c: Likewise.\n+\t* bid64_next.c: Likewise.\n+\t* bid64_noncomp.c: Likewise.\n+\t* bid64_quantize.c: Likewise.\n+\t* bid64_rem.c: Likewise.\n+\t* bid64_round_integral.c: Likewise.\n+\t* bid64_scalb.c: Likewise.\n+\t* bid64_sqrt.c: Likewise.\n+\t* bid64_string.c: Likewise.\n+\t* bid64_to_bid128.c: Likewise.\n+\t* bid64_to_int32.c: Likewise.\n+\t* bid64_to_int64.c: Likewise.\n+\t* bid64_to_uint32.c: Likewise.\n+\t* bid64_to_uint64.c: Likewise.\n+\t* bid_b2d.h: Likewise.\n+\t* bid_binarydecimal.c: Likewise.\n+\t* bid_conf.h: Likewise.\n+\t* bid_convert_data.c: Likewise.\n+\t* bid_decimal_data.c: Likewise.\n+\t* bid_decimal_globals.c: Likewise.\n+\t* bid_div_macros.h: Likewise.\n+\t* bid_flag_operations.c: Likewise.\n+\t* bid_from_int.c: Likewise.\n+\t* bid_functions.h: Likewise.\n+\t* bid_gcc_intrinsics.h: Likewise.\n+\t* bid_inline_add.h: Likewise.\n+\t* bid_internal.h: Likewise.\n+\t* bid_round.c: Likewise.\n+\t* bid_sqrt_macros.h: Likewise.\n+\t* _addsub_dd.c: Likewise.\n+\t* _addsub_sd.c: Likewise.\n+\t* _addsub_td.c: Likewise.\n+\t* _dd_to_df.c: Likewise.\n+\t* _dd_to_di.c: Likewise.\n+\t* _dd_to_sd.c: Likewise.\n+\t* _dd_to_sf.c: Likewise.\n+\t* _dd_to_si.c: Likewise.\n+\t* _dd_to_td.c: Likewise.\n+\t* _dd_to_tf.c: Likewise.\n+\t* _dd_to_udi.c: Likewise.\n+\t* _dd_to_usi.c: Likewise.\n+\t* _dd_to_xf.c: Likewise.\n+\t* _df_to_dd.c: Likewise.\n+\t* _df_to_sd.c: Likewise.\n+\t* _df_to_td.c: Likewise.\n+\t* _di_to_dd.c: Likewise.\n+\t* _di_to_sd.c: Likewise.\n+\t* _di_to_td.c: Likewise.\n+\t* _div_dd.c: Likewise.\n+\t* _div_sd.c: Likewise.\n+\t* _div_td.c: Likewise.\n+\t* _eq_dd.c: Likewise.\n+\t* _eq_sd.c: Likewise.\n+\t* _eq_td.c: Likewise.\n+\t* _ge_dd.c: Likewise.\n+\t* _ge_sd.c: Likewise.\n+\t* _ge_td.c: Likewise.\n+\t* _gt_dd.c: Likewise.\n+\t* _gt_sd.c: Likewise.\n+\t* _gt_td.c: Likewise.\n+\t* _isinfd128.c: Likewise.\n+\t* _isinfd32.c: Likewise.\n+\t* _isinfd64.c: Likewise.\n+\t* _le_dd.c: Likewise.\n+\t* _le_sd.c: Likewise.\n+\t* _le_td.c: Likewise.\n+\t* _lt_dd.c: Likewise.\n+\t* _lt_sd.c: Likewise.\n+\t* _lt_td.c: Likewise.\n+\t* _mul_dd.c: Likewise.\n+\t* _mul_sd.c: Likewise.\n+\t* _mul_td.c: Likewise.\n+\t* _ne_dd.c: Likewise.\n+\t* _ne_sd.c: Likewise.\n+\t* _ne_td.c: Likewise.\n+\t* _sd_to_dd.c: Likewise.\n+\t* _sd_to_df.c: Likewise.\n+\t* _sd_to_di.c: Likewise.\n+\t* _sd_to_sf.c: Likewise.\n+\t* _sd_to_si.c: Likewise.\n+\t* _sd_to_td.c: Likewise.\n+\t* _sd_to_tf.c: Likewise.\n+\t* _sd_to_udi.c: Likewise.\n+\t* _sd_to_usi.c: Likewise.\n+\t* _sd_to_xf.c: Likewise.\n+\t* _sf_to_dd.c: Likewise.\n+\t* _sf_to_sd.c: Likewise.\n+\t* _sf_to_td.c: Likewise.\n+\t* _si_to_dd.c: Likewise.\n+\t* _si_to_sd.c: Likewise.\n+\t* _si_to_td.c: Likewise.\n+\t* _td_to_dd.c: Likewise.\n+\t* _td_to_df.c: Likewise.\n+\t* _td_to_di.c: Likewise.\n+\t* _td_to_sd.c: Likewise.\n+\t* _td_to_sf.c: Likewise.\n+\t* _td_to_si.c: Likewise.\n+\t* _td_to_tf.c: Likewise.\n+\t* _td_to_udi.c: Likewise.\n+\t* _td_to_usi.c: Likewise.\n+\t* _td_to_xf.c: Likewise.\n+\t* _tf_to_dd.c: Likewise.\n+\t* _tf_to_sd.c: Likewise.\n+\t* _tf_to_td.c: Likewise.\n+\t* _udi_to_dd.c: Likewise.\n+\t* _udi_to_sd.c: Likewise.\n+\t* _udi_to_td.c: Likewise.\n+\t* _unord_dd.c: Likewise.\n+\t* _unord_sd.c: Likewise.\n+\t* _unord_td.c: Likewise.\n+\t* _usi_to_dd.c: Likewise.\n+\t* _usi_to_sd.c: Likewise.\n+\t* _usi_to_td.c: Likewise.\n+\t* _xf_to_dd.c: Likewise.\n+\t* _xf_to_sd.c: Likewise.\n+\t* _xf_to_td.c: Likewise.\n+\n+2007-09-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* b2d.h: Renamed to ...\n+\t* bid_b2d.h: This.\n+\n+\t* bid128_to_string.c: Renamed to ...\n+\t* bid128_string.c: This.\n+\n+\t* bid_intrinsics.h: Renamed to ...\n+\t* bid_gcc_intrinsics.h: This.\n+\n+\t* bid_string.c: Renamed to ...\n+\t* bid64_string.c: This.\n+\n+\t* binarydecimal.c: Renamed to ...\n+\t* bid_decimal_globals.c: This.\n+\n+\t* convert_data.c: Renamed to ...\n+\t* bid_convert_data.c: This.\n+\n+\t* decimal_data.c: Renamed to ...\n+\t* bid_decimal_data.c: This.\n+\n+\t* decimal_globals.c: Renamed to ...\n+\t* bid_decimal_globals.c: This.\n+\n+\t* div_macros.h: Renamed to ...\n+\t* bid_div_macros.h: This.\n+\n+\t* inline_bid_add.h: Renamed to ...\n+\t* bid_inline_add.h: This.\n+\n+\t* sqrt_macros.h: Renamed to ...\n+\t* bid_sqrt_macros.h: This.\n+\n 2007-07-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tUpdated from Intel BID library:"}, {"sha": "91ae58e973ef0e9e971ad6346a4cb1c31a009e13", "filename": "libgcc/config/libbid/_addsub_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_adddd3 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "758c9037fa26f0645521a34710c93b1eb9f58d48", "filename": "libgcc/config/libbid/_addsub_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_addsd3 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "bed0fb1644cb0b8c7c5382a14b66383c3783c10a", "filename": "libgcc/config/libbid/_addsub_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\" \n \n _Decimal128\n __bid_addtd3 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "339c4cb2e7ceee7ecc703f4c8fb3e3eea4b9b6ce", "filename": "libgcc/config/libbid/_dd_to_df.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DFtype\n __bid_truncdddf (_Decimal64 x) {"}, {"sha": "847138ffe7493cf19b39695ece450c4eb26e45d9", "filename": "libgcc/config/libbid/_dd_to_di.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DItype\n __bid_fixdddi (_Decimal64 x) {\n-  DItype res;\n+  DItype res = 0xbaddbaddbaddbaddull;\n   union decimal64 ux;\n \n   ux.d = x;\n   res = __bid64_to_int64_xint (ux.i);\n+\n   return (res);\n }\n "}, {"sha": "75a66adee204f6c4b2bfdf3d2db31e27b6c49d94", "filename": "libgcc/config/libbid/_dd_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal32\n __bid_truncddsd2 (_Decimal64 x) {"}, {"sha": "5f7f89df0a908baa242286ef0f3b0936cf43dcec", "filename": "libgcc/config/libbid/_dd_to_sf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SFtype\n __bid_truncddsf (_Decimal64 x) {"}, {"sha": "4be51238da9dab086b3b474f24b4525601d46f2d", "filename": "libgcc/config/libbid/_dd_to_si.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SItype\n __bid_fixddsi (_Decimal64 x) {\n-  SItype res;\n+  SItype res = 0xbaddbadd;\n   union decimal64 ux;\n \n   ux.d = x;\n   res = __bid64_to_int32_xint (ux.i);\n+\n   return (res);\n }\n "}, {"sha": "918374abb0a38f7902756b251ffd4cdeb9d11bdb", "filename": "libgcc/config/libbid/_dd_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal128\n __bid_extendddtd2 (_Decimal64 x) {"}, {"sha": "bb58f049be1bb20e7219e31fe3f73c451a6cd7c0", "filename": "libgcc/config/libbid/_dd_to_tf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n TFtype"}, {"sha": "4f784cc7914ecf16d61cb39d379974f8b7d393f9", "filename": "libgcc/config/libbid/_dd_to_udi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n UDItype\n __bid_fixunsdddi (_Decimal64 x) {\n-  UDItype res;\n+  UDItype res = 0xbaddbaddbaddbaddull;\n   union decimal64 ux;\n \n   ux.d = x;\n   res = __bid64_to_uint64_xint (ux.i);\n+\n   if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "721a3af660fb0774375f9773f8eb813f21c6d6e4", "filename": "libgcc/config/libbid/_dd_to_usi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n USItype\n __bid_fixunsddsi (_Decimal64 x) {\n-  USItype res;\n+  USItype res = 0xbaddbadd;\n   union decimal64 ux;\n \n   ux.d = x;\n   res = __bid64_to_uint32_xint (ux.i);\n+\n   if (res == 0x80000000) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "a8a93117d392acbadf2ce0c63355e9aa9b28b1a2", "filename": "libgcc/config/libbid/_dd_to_xf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n XFtype\n __bid_extendddxf (_Decimal64 x) {"}, {"sha": "e717752d1f0294328c8acb71c64d1dbe33a1d741", "filename": "libgcc/config/libbid/_df_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_extenddfdd (DFtype x) {"}, {"sha": "9ac9948fd5736f3fd8e0d67868fd3166e2a05f6e", "filename": "libgcc/config/libbid/_df_to_sd.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_truncdfsd (DFtype x) {\n   union decimal32 res;\n+\n   res.i = __binary64_to_bid32 (x);\n   return (res.d);\n }"}, {"sha": "f8d57f5390c163179b31963b15aeed20efae30f4", "filename": "libgcc/config/libbid/_df_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_extenddftd (DFtype x) {"}, {"sha": "03c8694a3b395fab2969e972eac6aa141d51fe3e", "filename": "libgcc/config/libbid/_di_to_dd.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_floatdidd (DItype x) {\n   union decimal64 res;\n+\n   res.i = __bid64_from_int64 (x);\n   return (res.d);\n }\n+"}, {"sha": "29565e21c7ee5e361dc7594e29546b97816f3ed0", "filename": "libgcc/config/libbid/_di_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_floatdisd (DItype x) {"}, {"sha": "b71f35190dc319c32eca43d5876f2ec12b7b540e", "filename": "libgcc/config/libbid/_di_to_td.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_floatditd (DItype x) {\n   union decimal128 res;\n+\n   res.i = __bid128_from_int64 (x);\n   return (res.d);\n }\n+"}, {"sha": "27e53b7779afdb044f789b709e79d9012cbda75b", "filename": "libgcc/config/libbid/_div_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_divdd3 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "9041b669aa608bb29e3e847c431bfe2a67a7b69f", "filename": "libgcc/config/libbid/_div_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_divsd3 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "5fe25b3cb0d790dc6a275104987b10c520f2dcad", "filename": "libgcc/config/libbid/_div_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_div_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_divtd3 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "d3dd96afbb007d834cd2a14eda2f92c430fcec66", "filename": "libgcc/config/libbid/_eq_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_eqdd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "fdfa1ecfa3b5b2c85e7d2fc5fb76c634944a1ebf", "filename": "libgcc/config/libbid/_eq_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_eqsd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "ed2d548f45daf47c3f08e03dacca318696ea4cd7", "filename": "libgcc/config/libbid/_eq_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_eq_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_eqtd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "c24fc9ba6004adbe490b10ac041a69f3c8c3dd63", "filename": "libgcc/config/libbid/_ge_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_gedd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "1bac3a59955f42f56065e508c2db6f432777311b", "filename": "libgcc/config/libbid/_ge_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_gesd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "0f3a1b29825fc0755432e50d88ef2328e9dfe2c3", "filename": "libgcc/config/libbid/_ge_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ge_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_getd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "936543a5a6486c6c91ebaed934ff5f3b324c62e8", "filename": "libgcc/config/libbid/_gt_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_gtdd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "c778a07545884ee4d31b2fd120a4b5d1f9191467", "filename": "libgcc/config/libbid/_gt_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_gtsd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "7de77676f728cd618b539a607ff9cad15fb9e5ca", "filename": "libgcc/config/libbid/_gt_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_gt_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_gttd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "9e48de662e2d0f0b36867c3b125727548d9bd687", "filename": "libgcc/config/libbid/_isinfd128.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n int\n isinfd128 (_Decimal128 x) {"}, {"sha": "6c012b0844445460f43b901f1f5cb947bbffee66", "filename": "libgcc/config/libbid/_isinfd32.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n int\n isinfd32 (_Decimal32 x) {"}, {"sha": "8748a3f7ef10c7a4b40c49b3581ac8b4314050b1", "filename": "libgcc/config/libbid/_isinfd64.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n int\n isinfd64 (_Decimal64 x) {"}, {"sha": "202c1b57ceb5d46c84cbc734e506bab64922ca06", "filename": "libgcc/config/libbid/_le_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_ledd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "c3f74a96261fd0b9ff7c91556003f65fcf072c6c", "filename": "libgcc/config/libbid/_le_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_lesd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "0cf48f6f84786276a90cf69cb4eaa48d90cedb1f", "filename": "libgcc/config/libbid/_le_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_le_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_letd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "2318fda353215ae0da73d2c781d6d4e941873c04", "filename": "libgcc/config/libbid/_lt_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_ltdd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "881123c800d7f73f71e0b012d7afbb93a92adda9", "filename": "libgcc/config/libbid/_lt_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_ltsd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "77bd173a75917ee56d5b3e749ec1dfa4bbd031ac", "filename": "libgcc/config/libbid/_lt_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_lt_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_lttd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "c45f097ce35015544a2f8a5859d3cf4c8ff10704", "filename": "libgcc/config/libbid/_mul_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_muldd3 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "b2e80a2958b8313e25a61f0ee71fd42eefc20e33", "filename": "libgcc/config/libbid/_mul_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_mulsd3 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "ce1b2a795069f8312d8612b8d492c980471cd615", "filename": "libgcc/config/libbid/_mul_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_mul_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_multd3 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "db331a17b19aa300e39875ab59f54f8564b2f2ef", "filename": "libgcc/config/libbid/_ne_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_nedd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "e598f06133f78f4b5f8cc7ae4903743b82cf9609", "filename": "libgcc/config/libbid/_ne_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_nesd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "d592d28e57c3dc97eb5643a68571a5843af0f3ec", "filename": "libgcc/config/libbid/_ne_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_ne_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_netd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "9eb099a9b0ba3fc84fd698d4533daae601330d8b", "filename": "libgcc/config/libbid/_sd_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal64\n __bid_extendsddd2 (_Decimal32 x) {"}, {"sha": "b8a7d00a161dbff10cbb273a9f37706325646c78", "filename": "libgcc/config/libbid/_sd_to_df.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DFtype\n __bid_extendsddf (_Decimal32 x) {"}, {"sha": "1777d77ee50962067e7148918f7d40f5bde29e5e", "filename": "libgcc/config/libbid/_sd_to_di.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,16 +28,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DItype\n __bid_fixsddi (_Decimal32 x) {\n-  DItype res;\n+  DItype res = 0xbaddbaddbaddbaddull;\n   UINT64 x64;\n   union decimal32 ux;\n \n   ux.d = x;\n   x64 = __bid32_to_bid64 (ux.i);\n   res = __bid64_to_int64_xint (x64);\n+\n   return (res);\n }\n "}, {"sha": "bd7ed1e4bd57aa560c63120d6c8ffbef5cff6f8c", "filename": "libgcc/config/libbid/_sd_to_sf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SFtype\n __bid_truncsdsf (_Decimal32 x) {"}, {"sha": "2cbb77b823e8d75944ce934bc9d0dfa83e8784e2", "filename": "libgcc/config/libbid/_sd_to_si.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,16 +28,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SItype\n __bid_fixsdsi (_Decimal32 x) {\n-  SItype res;\n+  SItype res = 0xbaddbadd;\n   UINT64 x64;\n   union decimal32 ux;\n \n   ux.d = x;\n   x64 = __bid32_to_bid64 (ux.i);\n   res = __bid64_to_int32_xint (x64);\n+\n   return (res);\n }\n "}, {"sha": "a5c794c6fc9e367ab57f771bd2d037bc2fa3c049", "filename": "libgcc/config/libbid/_sd_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal128\n __bid_extendsdtd2 (_Decimal32 x) {"}, {"sha": "6514e7491d60bd14c9b9ba7e6bde26d03863ef34", "filename": "libgcc/config/libbid/_sd_to_tf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n TFtype"}, {"sha": "40785bd6aced6841fa2426fd60bb0210a177e3d0", "filename": "libgcc/config/libbid/_sd_to_udi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,16 +28,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n UDItype\n __bid_fixunssddi (_Decimal32 x) {\n-  UDItype res;\n+  UDItype res = 0xbaddbaddbaddbaddull;\n   UINT64 x64;\n   union decimal32 ux;\n \n   ux.d = x;\n   x64 = __bid32_to_bid64 (ux.i);\n   res = __bid64_to_uint64_xint (x64);\n+\n   if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "9b3d9f36fa24507f9a6cb71f86769f923b064020", "filename": "libgcc/config/libbid/_sd_to_usi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,16 +28,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n USItype\n __bid_fixunssdsi (_Decimal32 x) {\n-  USItype res;\n+  USItype res = 0xbaddbadd;\n   UINT64 x64;\n   union decimal32 ux;\n \n   ux.d = x;\n   x64 = __bid32_to_bid64 (ux.i);\n   res = __bid64_to_uint32_xint (x64);\n+\n   if (res == 0x80000000) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "a73d45191c8286a8173f061054bb4cbe220c1c30", "filename": "libgcc/config/libbid/_sd_to_xf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n XFtype\n __bid_extendsdxf (_Decimal32 x) {"}, {"sha": "d9e4c0ecf9192548d66e9c082de8739ee23e069f", "filename": "libgcc/config/libbid/_sf_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_extendsfdd (SFtype x) {"}, {"sha": "0b9397d984dc26e374e424a2351be6f70ccc203b", "filename": "libgcc/config/libbid/_sf_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_extendsfsd (SFtype x) {"}, {"sha": "127460a1d2bf84c1a4cbc33e2b29891054f16ccb", "filename": "libgcc/config/libbid/_sf_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_extendsftd (SFtype x) {"}, {"sha": "b0847d9e0c0d1833bba49c8520400410363d8f12", "filename": "libgcc/config/libbid/_si_to_dd.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_floatsidd (SItype x) {\n   union decimal64 res;\n+\n   res.i = __bid64_from_int32 (x);\n   return (res.d);\n }"}, {"sha": "fc4efa0ed6e18372b27f4dc35c0e76b9f36b1fa3", "filename": "libgcc/config/libbid/_si_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_floatsisd (SItype x) {"}, {"sha": "737663b0551c672f7bde8463b198f49fdb3cce5f", "filename": "libgcc/config/libbid/_si_to_td.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_floatsitd (SItype x) {\n   union decimal128 res;\n+\n   res.i = __bid128_from_int32 (x);\n   return (res.d);\n }"}, {"sha": "7d909cbccafbbcf533226a8c18a2fa01de1bad62", "filename": "libgcc/config/libbid/_td_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal64\n __bid_trunctddd2 (_Decimal128 x) {"}, {"sha": "219e25616f29fb2f1540d5c0dbe9480d99aec9c9", "filename": "libgcc/config/libbid/_td_to_df.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DFtype\n __bid_trunctddf (_Decimal128 x) {"}, {"sha": "261222a451a9dcf21b0b45ce10ab740084f81599", "filename": "libgcc/config/libbid/_td_to_di.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n DItype\n __bid_fixtddi (_Decimal128 x) {\n-  DItype res;\n+  DItype res = 0xbaddbaddbaddbaddull;\n   union decimal128 ux;\n \n   ux.d = x;\n   res = __bid128_to_int64_xint (ux.i);\n+\n   return (res);\n }\n "}, {"sha": "f269c6539c729e8c0745868b48a91a8dcd170b28", "filename": "libgcc/config/libbid/_td_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n  \n _Decimal32\n __bid_trunctdsd2 (_Decimal128 x) {"}, {"sha": "4542ae9b5255dd66e90544796b93948b4535ba03", "filename": "libgcc/config/libbid/_td_to_sf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SFtype\n __bid_trunctdsf (_Decimal128 x) {"}, {"sha": "b16c66ee03fbda5fbcc7fb009cc97437002683cb", "filename": "libgcc/config/libbid/_td_to_si.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n SItype\n __bid_fixtdsi (_Decimal128 x) {\n-  SItype res;\n   union decimal128 ux;\n+  SItype res = 0xbaddbadd;\n \n   ux.d = x;\n   res = __bid128_to_int32_xint (ux.i);\n+\n   return (res);\n }\n "}, {"sha": "9f6c2417755a6c947d46ce3d5f44aac7aa30911d", "filename": "libgcc/config/libbid/_td_to_tf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n TFtype"}, {"sha": "47262a808b25baf49878dca1b3517a52008e8471", "filename": "libgcc/config/libbid/_td_to_udi.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,17 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n UDItype\n __bid_fixunstddi (_Decimal128 x) {\n-  UDItype res;\n+  UDItype res = 0xbaddbaddbaddbaddull;\n   union decimal128 ux;\n \n   ux.d = x;\n+\n   res = __bid128_to_uint64_xint (ux.i);\n+\n   if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "d489b082ac5e3e863d477df979fb9b747de950d2", "filename": "libgcc/config/libbid/_td_to_usi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,14 +28,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n USItype\n __bid_fixunstdsi (_Decimal128 x) {\n-  USItype res;\n+  USItype res = 0xbaddbadd;\n   union decimal128 ux;\n \n   ux.d = x;\n   res = __bid128_to_uint32_xint (ux.i);\n+\n   if (res == 0x80000000) res = 0; // for NaNs too\n   return (res);\n }"}, {"sha": "7dffbaa4bd4314f6699d442e3b705153dbfac992", "filename": "libgcc/config/libbid/_td_to_xf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n XFtype\n __bid_trunctdxf (_Decimal128 x) {"}, {"sha": "94d2f36bd910ca9068cf8c2d692abfb63e293b22", "filename": "libgcc/config/libbid/_tf_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n _Decimal64"}, {"sha": "b5c49892422120c5096bb7218b3eb1045b622dba", "filename": "libgcc/config/libbid/_tf_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n _Decimal32"}, {"sha": "b6eb6a0e239aaa6613e1d52bf75053ca8f8249c5", "filename": "libgcc/config/libbid/_tf_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n #if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n _Decimal128"}, {"sha": "3c424348ea4a27397fa00b9f26cbd98588ddec01", "filename": "libgcc/config/libbid/_udi_to_dd.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_floatunsdidd (UDItype x) {\n   union decimal64 res;\n+\n   res.i = __bid64_from_uint64 (x);\n   return (res.d);\n }\n+"}, {"sha": "2f381800df1d8c0f51a0581b4d74fb4e84a65e66", "filename": "libgcc/config/libbid/_udi_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_floatunsdisd (UDItype x) {"}, {"sha": "591b71e643008777a780cbe0281c80de32783b24", "filename": "libgcc/config/libbid/_udi_to_td.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_floatunsditd (UDItype x) {\n   union decimal128 res;\n+\n   res.i = __bid128_from_uint64 (x);\n   return (res.d);\n }\n+"}, {"sha": "da814883ac7bf61a178511919902c446a9042c0c", "filename": "libgcc/config/libbid/_unord_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_unorddd2 (_Decimal64 x, _Decimal64 y) {"}, {"sha": "0a1a3f3c806e96d2f4a2670f6f4430221d772f34", "filename": "libgcc/config/libbid/_unord_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_unordsd2 (_Decimal32 x, _Decimal32 y) {"}, {"sha": "038fd634b1f7953d8ef8b8a72c4ee715d10f18ae", "filename": "libgcc/config/libbid/_unord_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_unord_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n CMPtype\n __bid_unordtd2 (_Decimal128 x, _Decimal128 y) {"}, {"sha": "6feb39eceeaddf168122311e5184d438837f5fbc", "filename": "libgcc/config/libbid/_usi_to_dd.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_floatunssidd (USItype x) {\n   union decimal64 res;\n+\n   res.i = __bid64_from_uint32 (x);\n   return (res.d);\n }\n+"}, {"sha": "907de0f415dc471a0d879b055f42d0dd168278fc", "filename": "libgcc/config/libbid/_usi_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_floatunssisd (USItype x) {"}, {"sha": "31416f6cdb5c93af87fb981772a5d5c2ad5e5ce0", "filename": "libgcc/config/libbid/_usi_to_td.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,10 +28,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_floatunssitd (USItype x) {\n   union decimal128 res;\n+\n   res.i = __bid128_from_uint32 (x);\n   return (res.d);\n }\n+"}, {"sha": "314aa52810a5cd75951e2b07732034f3d9145a4a", "filename": "libgcc/config/libbid/_xf_to_dd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal64\n __bid_truncxfdd (XFtype x) {"}, {"sha": "6a8d4eb305178fedf9edd023285029773a8dec05", "filename": "libgcc/config/libbid/_xf_to_sd.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal32\n __bid_truncxfsd (XFtype x) {"}, {"sha": "b688638c5485e729dc14595db0c6e340418d8772", "filename": "libgcc/config/libbid/_xf_to_td.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_conf.h\"\n #include \"bid_functions.h\"\n+#include \"bid_gcc_intrinsics.h\"\n \n _Decimal128\n __bid_extendxftd (XFtype x) {"}, {"sha": "41b593516fb34238a60135dd1c2f93781dd66268", "filename": "libgcc/config/libbid/b2d.h", "status": "removed", "additions": 0, "deletions": 3050, "changes": 3050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fb2d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fb2d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fb2d.h?ref=e233ac979c0f179f858f3c86281835a4c09cece2"}, {"sha": "8f413068de3a2756d332057fdd3ace1a0f51e63f", "filename": "libgcc/config/libbid/bid128.c", "status": "modified", "additions": 2315, "deletions": 2019, "changes": 4334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "c773086bdf99db04f4fb1c5bb18cca5dfd185403", "filename": "libgcc/config/libbid/bid128_2_str.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -26,13 +26,13 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-extern UINT64 __bid_Twoto60_m_10to18;\n-extern UINT64 __bid_Twoto60;\n-extern UINT64 __bid_Inv_Tento9;\n-extern UINT32 __bid_Twoto30_m_10to9;\n-extern UINT32 __bid_Tento9;\n-extern UINT32 __bid_Tento6;\n-extern UINT32 __bid_Tento3;\n+extern UINT64 Twoto60_m_10to18;\n+extern UINT64 Twoto60;\n+extern UINT64 Inv_Tento9;\n+extern UINT32 Twoto30_m_10to9;\n+extern UINT32 Tento9;\n+extern UINT32 Tento6;\n+extern UINT32 Tento3;\n \n-extern char __bid_midi_tbl[1000][3];\n-extern UINT64 __bid_mod10_18_tbl[9][128];\n+extern char midi_tbl[1000][3];\n+extern UINT64 mod10_18_tbl[9][128];"}, {"sha": "e05d82c9b8aca92307b413c1322b8f10c526ef6e", "filename": "libgcc/config/libbid/bid128_2_str_macros.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -29,16 +29,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define __L0_Normalize_10to18( X_hi, X_lo )            \\\n {                                                      \\\n UINT64 L0_tmp;                                         \\\n-L0_tmp = (X_lo) + __bid_Twoto60_m_10to18;                    \\\n-if (L0_tmp & __bid_Twoto60)                                  \\\n+L0_tmp = (X_lo) + Twoto60_m_10to18;                    \\\n+if (L0_tmp & Twoto60)                                  \\\n  {(X_hi)=(X_hi)+1;(X_lo)=((L0_tmp<<4)>>4);}            \\\n }\n \n \n #define __L0_Normalize_10to9( X_hi, X_lo )             \\\n {                                                      \\\n UINT32 L0_tmp;                                         \\\n-L0_tmp = (X_lo) + __bid_Twoto30_m_10to9;                     \\\n+L0_tmp = (X_lo) + Twoto30_m_10to9;                     \\\n if (L0_tmp & 0x40000000)                               \\\n  {(X_hi)=(X_hi)+1;(X_lo)=((L0_tmp<<2)>>2);}            \\\n }\n@@ -76,10 +76,10 @@ UINT32 L0_X, L0_head, L0_mid, L0_tail, L0_tmp;         \\\n {                                                      \\\n UINT32 L1_X_hi, L1_X_lo;                               \\\n UINT64 L1_Xhi_64, L1_Xlo_64;                           \\\n-L1_Xhi_64 = ( ((X)>>28)*__bid_Inv_Tento9 ) >> 33;            \\\n-L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)__bid_Tento9;            \\\n-if (L1_Xlo_64 >= (UINT64)__bid_Tento9)                       \\\n- {L1_Xlo_64-=(UINT64)__bid_Tento9;L1_Xhi_64+=1;}             \\\n+L1_Xhi_64 = ( ((X)>>28)*Inv_Tento9 ) >> 33;            \\\n+L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)Tento9;            \\\n+if (L1_Xlo_64 >= (UINT64)Tento9)                       \\\n+ {L1_Xlo_64-=(UINT64)Tento9;L1_Xhi_64+=1;}             \\\n L1_X_hi=(UINT32)L1_Xhi_64; L1_X_lo=(UINT32)L1_Xlo_64;  \\\n __L0_Split_MiDi_3(L1_X_hi,(ptr));                      \\\n __L0_Split_MiDi_3(L1_X_lo,(ptr));                      \\\n@@ -89,18 +89,18 @@ __L0_Split_MiDi_3(L1_X_lo,(ptr));                      \\\n {                                                      \\\n UINT32 L1_X_hi, L1_X_lo;                               \\\n UINT64 L1_Xhi_64, L1_Xlo_64;                           \\\n-if ((X)>=(UINT64)__bid_Tento9){                              \\\n-  L1_Xhi_64 = ( ((X)>>28)*__bid_Inv_Tento9 ) >> 33;          \\\n-  L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)__bid_Tento9;          \\\n-  if (L1_Xlo_64 >= (UINT64)__bid_Tento9)                     \\\n-   {L1_Xlo_64-=(UINT64)__bid_Tento9;L1_Xhi_64+=1;}           \\\n+if ((X)>=(UINT64)Tento9){                              \\\n+  L1_Xhi_64 = ( ((X)>>28)*Inv_Tento9 ) >> 33;          \\\n+  L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)Tento9;          \\\n+  if (L1_Xlo_64 >= (UINT64)Tento9)                     \\\n+   {L1_Xlo_64-=(UINT64)Tento9;L1_Xhi_64+=1;}           \\\n   L1_X_hi=(UINT32)L1_Xhi_64;                           \\\n   L1_X_lo=(UINT32)L1_Xlo_64;                           \\\n-  if (L1_X_hi>=__bid_Tento6){                                \\\n+  if (L1_X_hi>=Tento6){                                \\\n      __L0_Split_MiDi_3(L1_X_hi,(ptr));                 \\\n      __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n   }                                                    \\\n-  else if (L1_X_hi>=__bid_Tento3){                           \\\n+  else if (L1_X_hi>=Tento3){                           \\\n      __L0_Split_MiDi_2(L1_X_hi,(ptr));                 \\\n      __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n   }                                                    \\\n@@ -111,10 +111,10 @@ if ((X)>=(UINT64)__bid_Tento9){                              \\\n }                                                      \\\n else {                                                 \\\n   L1_X_lo = (UINT32)(X);                               \\\n-  if (L1_X_lo>=__bid_Tento6){                                \\\n+  if (L1_X_lo>=Tento6){                                \\\n      __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n   }                                                    \\\n-  else if (L1_X_lo>=__bid_Tento3){                           \\\n+  else if (L1_X_lo>=Tento3){                           \\\n      __L0_Split_MiDi_2(L1_X_lo,(ptr));                 \\\n   }                                                    \\\n   else {                                               \\\n@@ -127,7 +127,7 @@ else {                                                 \\\n #define __L0_MiDi2Str( X, c_ptr )              \\\n {                                              \\\n char *L0_src;                                  \\\n- L0_src = __bid_midi_tbl[(X)];                       \\\n+ L0_src = midi_tbl[(X)];                       \\\n  *((c_ptr)++) = *(L0_src++);                   \\\n  *((c_ptr)++) = *(L0_src++);                   \\\n  *((c_ptr)++) = *(L0_src);                     \\\n@@ -136,7 +136,7 @@ char *L0_src;                                  \\\n #define __L0_MiDi2Str_Lead( X, c_ptr )         \\\n {                                              \\\n char *L0_src;                                  \\\n- L0_src = __bid_midi_tbl[(X)];                       \\\n+ L0_src = midi_tbl[(X)];                       \\\n  if ((X)>=100){                                \\\n  *((c_ptr)++) = *(L0_src++);                   \\\n  *((c_ptr)++) = *(L0_src++);                   \\"}, {"sha": "6d708f938391e949740b924d8b8fec55a73c9d4c", "filename": "libgcc/config/libbid/bid128_2_str_tables.c", "status": "modified", "additions": 495, "deletions": 371, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -28,15 +28,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bid_internal.h\"\n \n-UINT64 __bid_Twoto60_m_10to18 = 152921504606846976LL;\n-UINT64 __bid_Twoto60 = 0x1000000000000000LL;\n-UINT64 __bid_Inv_Tento9 = 2305843009LL;        /* floor(2^61/10^9) */\n-UINT32 __bid_Twoto30_m_10to9 = 73741824;\n-UINT32 __bid_Tento9 = 1000000000;\n-UINT32 __bid_Tento6 = 1000000;\n-UINT32 __bid_Tento3 = 1000;\n+UINT64 Twoto60_m_10to18 = 152921504606846976LL;\n+UINT64 Twoto60 = 0x1000000000000000LL;\n+UINT64 Inv_Tento9 = 2305843009LL;\t/* floor(2^61/10^9) */\n+UINT32 Twoto30_m_10to9 = 73741824;\n+UINT32 Tento9 = 1000000000;\n+UINT32 Tento6 = 1000000;\n+UINT32 Tento3 = 1000;\n \n-char __bid_midi_tbl[1000][3] = {\n+const char midi_tbl[1000][3] = {\n   \"000\", \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"007\", \"008\", \"009\",\n   \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\", \"019\",\n   \"020\", \"021\", \"022\", \"023\", \"024\", \"025\", \"026\", \"027\", \"028\", \"029\",\n@@ -139,385 +139,509 @@ char __bid_midi_tbl[1000][3] = {\n   \"990\", \"991\", \"992\", \"993\", \"994\", \"995\", \"996\", \"997\", \"998\", \"999\"\n };\n \n-UINT64 __bid_mod10_18_tbl[9][128] = {\n+const UINT64 mod10_18_tbl[9][128] = {\n   // 2^59 = 576460752303423488, A and B breakdown, where data = A*10^18 + B \n \n-  { \n-  0LL, 0LL, 0LL, 576460752303423488LL,        \n-      //  0*2^59,  1*2^59\n-  1LL, 152921504606846976LL, 1LL, 729382256910270464LL,        \n-      //  2*2^59,  3*2^59\n-  2LL, 305843009213693952LL, 2LL, 882303761517117440LL,        \n-      //  4*2^59,  5*2^59\n-  3LL, 458764513820540928LL, 4LL, 35225266123964416LL,        \n-      //  6*2^59,  7*2^59\n-  4LL, 611686018427387904LL, 5LL, 188146770730811392LL,        \n-      //  8*2^59,  9*2^59\n-  5LL, 764607523034234880LL, 6LL, 341068275337658368LL,        \n-  // 10*2^59, 11*2^59\n-  6LL, 917529027641081856LL, 7LL, 493989779944505344LL,        \n-      // 12*2^59, 13*2^59\n-  8LL, 70450532247928832LL, 8LL, 646911284551352320LL,        \n-      // 14*2^59, 15*2^59\n-  9LL, 223372036854775808LL, 9LL, 799832789158199296LL,        \n-      // 16*2^59, 17*2^59\n-  10LL, 376293541461622784LL, 10LL, 952754293765046272LL,        \n-      // 18*2^59, 19*2^59\n-  11LL, 529215046068469760LL, 12LL, 105675798371893248LL,        \n-      // 20*2^59, 21*2^59\n-  12LL, 682136550675316736LL, 13LL, 258597302978740224LL,        \n-      // 22*2^59, 23*2^59\n-  13LL, 835058055282163712LL, 14LL, 411518807585587200LL,        \n-      // 24*2^59, 25*2^59\n-  14LL, 987979559889010688LL, 15LL, 564440312192434176LL,        \n-      // 26*2^59, 27*2^59\n-  16LL, 140901064495857664LL, 16LL, 717361816799281152LL,        \n-      // 28*2^59, 29*2^59\n-  17LL, 293822569102704640LL, 17LL, 870283321406128128LL,        \n-      // 30*2^59, 31*2^59\n-  18LL, 446744073709551616LL, 19LL, 23204826012975104LL,        \n-      // 32*2^59, 33*2^59\n-  19LL, 599665578316398592LL, 20LL, 176126330619822080LL,        \n-      // 34*2^59, 35*2^59\n-  20LL, 752587082923245568LL, 21LL, 329047835226669056LL,        \n-      // 36*2^59, 37*2^59\n-  21LL, 905508587530092544LL, 22LL, 481969339833516032LL,        \n-      // 38*2^59, 39*2^59\n-  23LL, 58430092136939520LL, 23LL, 634890844440363008LL,        \n-      // 40*2^59, 41*2^59\n-  24LL, 211351596743786496LL, 24LL, 787812349047209984LL,        \n-      // 42*2^59, 43*2^59\n-  25LL, 364273101350633472LL, 25LL, 940733853654056960LL,        \n-      // 44*2^59, 45*2^59\n-  26LL, 517194605957480448LL, 27LL, 93655358260903936LL,        \n-      // 46*2^59, 47*2^59\n-  27LL, 670116110564327424LL, 28LL, 246576862867750912LL,        \n-      // 48*2^59, 49*2^59\n-  28LL, 823037615171174400LL, 29LL, 399498367474597888LL,        \n-      // 50*2^59, 51*2^59\n-  29LL, 975959119778021376LL, 30LL, 552419872081444864LL,        \n-      // 52*2^59, 53*2^59\n-  31LL, 128880624384868352LL, 31LL, 705341376688291840LL,        \n-      // 54*2^59, 55*2^59\n-  32LL, 281802128991715328LL, 32LL, 858262881295138816LL,        \n-      // 56*2^59, 57*2^59\n-  33LL, 434723633598562304LL, 34LL, 11184385901985792LL,        \n-      // 58*2^59, 59*2^59\n-  34LL, 587645138205409280LL, 35LL, 164105890508832768LL,        \n-      // 60*2^59, 61*2^59\n-  35LL, 740566642812256256LL, 36LL, 317027395115679744LL,        \n-      // 62*2^59, 63*2^59\n-  },\n+  {\n+   0LL, 0LL, 0LL, 576460752303423488LL,\n+   //  0*2^59,  1*2^59\n+   1LL, 152921504606846976LL, 1LL, 729382256910270464LL,\n+   //  2*2^59,  3*2^59\n+   2LL, 305843009213693952LL, 2LL, 882303761517117440LL,\n+   //  4*2^59,  5*2^59\n+   3LL, 458764513820540928LL, 4LL, 35225266123964416LL,\n+   //  6*2^59,  7*2^59\n+   4LL, 611686018427387904LL, 5LL, 188146770730811392LL,\n+   //  8*2^59,  9*2^59\n+   5LL, 764607523034234880LL, 6LL, 341068275337658368LL,\n+   // 10*2^59, 11*2^59\n+   6LL, 917529027641081856LL, 7LL, 493989779944505344LL,\n+   // 12*2^59, 13*2^59\n+   8LL, 70450532247928832LL, 8LL, 646911284551352320LL,\n+   // 14*2^59, 15*2^59\n+   9LL, 223372036854775808LL, 9LL, 799832789158199296LL,\n+   // 16*2^59, 17*2^59\n+   10LL, 376293541461622784LL, 10LL, 952754293765046272LL,\n+   // 18*2^59, 19*2^59\n+   11LL, 529215046068469760LL, 12LL, 105675798371893248LL,\n+   // 20*2^59, 21*2^59\n+   12LL, 682136550675316736LL, 13LL, 258597302978740224LL,\n+   // 22*2^59, 23*2^59\n+   13LL, 835058055282163712LL, 14LL, 411518807585587200LL,\n+   // 24*2^59, 25*2^59\n+   14LL, 987979559889010688LL, 15LL, 564440312192434176LL,\n+   // 26*2^59, 27*2^59\n+   16LL, 140901064495857664LL, 16LL, 717361816799281152LL,\n+   // 28*2^59, 29*2^59\n+   17LL, 293822569102704640LL, 17LL, 870283321406128128LL,\n+   // 30*2^59, 31*2^59\n+   18LL, 446744073709551616LL, 19LL, 23204826012975104LL,\n+   // 32*2^59, 33*2^59\n+   19LL, 599665578316398592LL, 20LL, 176126330619822080LL,\n+   // 34*2^59, 35*2^59\n+   20LL, 752587082923245568LL, 21LL, 329047835226669056LL,\n+   // 36*2^59, 37*2^59\n+   21LL, 905508587530092544LL, 22LL, 481969339833516032LL,\n+   // 38*2^59, 39*2^59\n+   23LL, 58430092136939520LL, 23LL, 634890844440363008LL,\n+   // 40*2^59, 41*2^59\n+   24LL, 211351596743786496LL, 24LL, 787812349047209984LL,\n+   // 42*2^59, 43*2^59\n+   25LL, 364273101350633472LL, 25LL, 940733853654056960LL,\n+   // 44*2^59, 45*2^59\n+   26LL, 517194605957480448LL, 27LL, 93655358260903936LL,\n+   // 46*2^59, 47*2^59\n+   27LL, 670116110564327424LL, 28LL, 246576862867750912LL,\n+   // 48*2^59, 49*2^59\n+   28LL, 823037615171174400LL, 29LL, 399498367474597888LL,\n+   // 50*2^59, 51*2^59\n+   29LL, 975959119778021376LL, 30LL, 552419872081444864LL,\n+   // 52*2^59, 53*2^59\n+   31LL, 128880624384868352LL, 31LL, 705341376688291840LL,\n+   // 54*2^59, 55*2^59\n+   32LL, 281802128991715328LL, 32LL, 858262881295138816LL,\n+   // 56*2^59, 57*2^59\n+   33LL, 434723633598562304LL, 34LL, 11184385901985792LL,\n+   // 58*2^59, 59*2^59\n+   34LL, 587645138205409280LL, 35LL, 164105890508832768LL,\n+   // 60*2^59, 61*2^59\n+   35LL, 740566642812256256LL, 36LL, 317027395115679744LL,\n+   // 62*2^59, 63*2^59\n+   },\n \n   {\n-  // 2^65 = 36*10^18 + 893488147419103232\n-  0LL, 0LL, 36LL, 893488147419103232LL,        \n-      //  0*2^65,  1*2^65\n-  73LL, 786976294838206464LL, 110LL, 680464442257309696LL,        \n-      //  2*2^65,  3*2^65\n-  147LL, 573952589676412928LL, 184LL, 467440737095516160LL,        \n-      //  4*2^65,  5*2^65\n-  221LL, 360928884514619392LL, 258LL, 254417031933722624LL,        \n-      //  6*2^65,  7*2^65\n-  295LL, 147905179352825856LL, 332LL, 41393326771929088LL,        \n-      //  8*2^65,  9*2^65\n-  368LL, 934881474191032320LL, 405LL, 828369621610135552LL,        \n-      //  0*2^65,  1*2^65\n-  442LL, 721857769029238784LL, 479LL, 615345916448342016LL,        \n-      //  2*2^65,  3*2^65\n-  516LL, 508834063867445248LL, 553LL, 402322211286548480LL,        \n-      //  4*2^65,  5*2^65\n-  590LL, 295810358705651712LL, 627LL, 189298506124754944LL,        \n-      //  6*2^65,  7*2^65\n-  664LL, 82786653543858176LL, 700LL, 976274800962961408LL,        \n-      //  8*2^65,  9*2^65\n-  737LL, 869762948382064640LL, 774LL, 763251095801167872LL,        \n-      //  0*2^65,  1*2^65\n-  811LL, 656739243220271104LL, 848LL, 550227390639374336LL,        \n-      //  2*2^65,  3*2^65\n-  885LL, 443715538058477568LL, 922LL, 337203685477580800LL,        \n-      //  4*2^65,  5*2^65\n-  959LL, 230691832896684032LL, 996LL, 124179980315787264LL,        \n-      //  6*2^65,  7*2^65\n-  1033LL, 17668127734890496LL, 1069LL, 911156275153993728LL,        \n-      //  8*2^65,  9*2^65\n-  1106LL, 804644422573096960LL, 1143LL, 698132569992200192LL,        \n-      //  0*2^65,  1*2^65\n-  1180LL, 591620717411303424LL, 1217LL, 485108864830406656LL,        \n-      //  2*2^65,  3*2^65\n-  1254LL, 378597012249509888LL, 1291LL, 272085159668613120LL,        \n-      //  4*2^65,  5*2^65\n-  1328LL, 165573307087716352LL, 1365LL, 59061454506819584LL,        \n-      //  6*2^65,  7*2^65\n-  1401LL, 952549601925922816LL, 1438LL, 846037749345026048LL,        \n-      //  8*2^65,  9*2^65\n-  1475LL, 739525896764129280LL, 1512LL, 633014044183232512LL,        \n-      //  0*2^65,  1*2^65\n-  1549LL, 526502191602335744LL, 1586LL, 419990339021438976LL,        \n-      //  2*2^65,  3*2^65\n-  1623LL, 313478486440542208LL, 1660LL, 206966633859645440LL,        \n-      //  4*2^65,  5*2^65\n-  1697LL, 100454781278748672LL, 1733LL, 993942928697851904LL,        \n-      //  6*2^65,  7*2^65\n-  1770LL, 887431076116955136LL, 1807LL, 780919223536058368LL,        \n-      //  8*2^65,  9*2^65\n-  1844LL, 674407370955161600LL, 1881LL, 567895518374264832LL,        \n-      //  0*2^65,  1*2^65\n-  1918LL, 461383665793368064LL, 1955LL, 354871813212471296LL,        \n-      //  2*2^65,  3*2^65\n-  1992LL, 248359960631574528LL, 2029LL, 141848108050677760LL,        \n-      //  4*2^65,  5*2^65\n-  2066LL, 35336255469780992LL, 2102LL, 928824402888884224LL,        \n-      //  6*2^65,  7*2^65\n-  2139LL, 822312550307987456LL, 2176LL, 715800697727090688LL,        \n-      //  8*2^65,  9*2^65\n-  2213LL, 609288845146193920LL, 2250LL, 502776992565297152LL,        \n-      //  0*2^65,  1*2^65\n-  2287LL, 396265139984400384LL, 2324LL, 289753287403503616LL,        \n-      //  2*2^65,  3*2^65\n-  },\n+   // 2^65 = 36*10^18 + 893488147419103232\n+   0LL, 0LL, 36LL, 893488147419103232LL,\n+   //  0*2^65,  1*2^65\n+   73LL, 786976294838206464LL, 110LL, 680464442257309696LL,\n+   //  2*2^65,  3*2^65\n+   147LL, 573952589676412928LL, 184LL, 467440737095516160LL,\n+   //  4*2^65,  5*2^65\n+   221LL, 360928884514619392LL, 258LL, 254417031933722624LL,\n+   //  6*2^65,  7*2^65\n+   295LL, 147905179352825856LL, 332LL, 41393326771929088LL,\n+   //  8*2^65,  9*2^65\n+   368LL, 934881474191032320LL, 405LL, 828369621610135552LL,\n+   //  0*2^65,  1*2^65\n+   442LL, 721857769029238784LL, 479LL, 615345916448342016LL,\n+   //  2*2^65,  3*2^65\n+   516LL, 508834063867445248LL, 553LL, 402322211286548480LL,\n+   //  4*2^65,  5*2^65\n+   590LL, 295810358705651712LL, 627LL, 189298506124754944LL,\n+   //  6*2^65,  7*2^65\n+   664LL, 82786653543858176LL, 700LL, 976274800962961408LL,\n+   //  8*2^65,  9*2^65\n+   737LL, 869762948382064640LL, 774LL, 763251095801167872LL,\n+   //  0*2^65,  1*2^65\n+   811LL, 656739243220271104LL, 848LL, 550227390639374336LL,\n+   //  2*2^65,  3*2^65\n+   885LL, 443715538058477568LL, 922LL, 337203685477580800LL,\n+   //  4*2^65,  5*2^65\n+   959LL, 230691832896684032LL, 996LL, 124179980315787264LL,\n+   //  6*2^65,  7*2^65\n+   1033LL, 17668127734890496LL, 1069LL, 911156275153993728LL,\n+   //  8*2^65,  9*2^65\n+   1106LL, 804644422573096960LL, 1143LL, 698132569992200192LL,\n+   //  0*2^65,  1*2^65\n+   1180LL, 591620717411303424LL, 1217LL, 485108864830406656LL,\n+   //  2*2^65,  3*2^65\n+   1254LL, 378597012249509888LL, 1291LL, 272085159668613120LL,\n+   //  4*2^65,  5*2^65\n+   1328LL, 165573307087716352LL, 1365LL, 59061454506819584LL,\n+   //  6*2^65,  7*2^65\n+   1401LL, 952549601925922816LL, 1438LL, 846037749345026048LL,\n+   //  8*2^65,  9*2^65\n+   1475LL, 739525896764129280LL, 1512LL, 633014044183232512LL,\n+   //  0*2^65,  1*2^65\n+   1549LL, 526502191602335744LL, 1586LL, 419990339021438976LL,\n+   //  2*2^65,  3*2^65\n+   1623LL, 313478486440542208LL, 1660LL, 206966633859645440LL,\n+   //  4*2^65,  5*2^65\n+   1697LL, 100454781278748672LL, 1733LL, 993942928697851904LL,\n+   //  6*2^65,  7*2^65\n+   1770LL, 887431076116955136LL, 1807LL, 780919223536058368LL,\n+   //  8*2^65,  9*2^65\n+   1844LL, 674407370955161600LL, 1881LL, 567895518374264832LL,\n+   //  0*2^65,  1*2^65\n+   1918LL, 461383665793368064LL, 1955LL, 354871813212471296LL,\n+   //  2*2^65,  3*2^65\n+   1992LL, 248359960631574528LL, 2029LL, 141848108050677760LL,\n+   //  4*2^65,  5*2^65\n+   2066LL, 35336255469780992LL, 2102LL, 928824402888884224LL,\n+   //  6*2^65,  7*2^65\n+   2139LL, 822312550307987456LL, 2176LL, 715800697727090688LL,\n+   //  8*2^65,  9*2^65\n+   2213LL, 609288845146193920LL, 2250LL, 502776992565297152LL,\n+   //  0*2^65,  1*2^65\n+   2287LL, 396265139984400384LL, 2324LL, 289753287403503616LL,\n+   //  2*2^65,  3*2^65\n+   },\n \n   {\n-  0LL, 0LL, 2361LL, 183241434822606848LL,\n-  4722LL, 366482869645213696LL, 7083LL, 549724304467820544LL,\n-  9444LL, 732965739290427392LL, 11805LL, 916207174113034240LL,\n-  14167LL, 99448608935641088LL, 16528LL, 282690043758247936LL,\n-  18889LL, 465931478580854784LL, 21250LL, 649172913403461632LL,\n-  23611LL, 832414348226068480LL, 25973LL, 15655783048675328LL,\n-  28334LL, 198897217871282176LL, 30695LL, 382138652693889024LL,\n-  33056LL, 565380087516495872LL, 35417LL, 748621522339102720LL,\n-  37778LL, 931862957161709568LL, 40140LL, 115104391984316416LL,\n-  42501LL, 298345826806923264LL, 44862LL, 481587261629530112LL,\n-  47223LL, 664828696452136960LL, 49584LL, 848070131274743808LL,\n-  51946LL, 31311566097350656LL, 54307LL, 214553000919957504LL,\n-  56668LL, 397794435742564352LL, 59029LL, 581035870565171200LL,\n-  61390LL, 764277305387778048LL, 63751LL, 947518740210384896LL,\n-  66113LL, 130760175032991744LL, 68474LL, 314001609855598592LL,\n-  70835LL, 497243044678205440LL, 73196LL, 680484479500812288LL,\n-  75557LL, 863725914323419136LL, 77919LL, 46967349146025984LL,\n-  80280LL, 230208783968632832LL, 82641LL, 413450218791239680LL,\n-  85002LL, 596691653613846528LL, 87363LL, 779933088436453376LL,\n-  89724LL, 963174523259060224LL, 92086LL, 146415958081667072LL,\n-  94447LL, 329657392904273920LL, 96808LL, 512898827726880768LL,\n-  99169LL, 696140262549487616LL, 101530LL, 879381697372094464LL,\n-  103892LL, 62623132194701312LL, 106253LL, 245864567017308160LL,\n-  108614LL, 429106001839915008LL, 110975LL, 612347436662521856LL,\n-  113336LL, 795588871485128704LL, 115697LL, 978830306307735552LL,\n-  118059LL, 162071741130342400LL, 120420LL, 345313175952949248LL,\n-  122781LL, 528554610775556096LL, 125142LL, 711796045598162944LL,\n-  127503LL, 895037480420769792LL, 129865LL, 78278915243376640LL,\n-  132226LL, 261520350065983488LL, 134587LL, 444761784888590336LL,\n-  136948LL, 628003219711197184LL, 139309LL, 811244654533804032LL,\n-  141670LL, 994486089356410880LL, 144032LL, 177727524179017728LL,\n-  146393LL, 360968959001624576LL, 148754LL, 544210393824231424LL,\n-  },\n+   0LL, 0LL, 2361LL, 183241434822606848LL,\n+   4722LL, 366482869645213696LL, 7083LL, 549724304467820544LL,\n+   9444LL, 732965739290427392LL, 11805LL, 916207174113034240LL,\n+   14167LL, 99448608935641088LL, 16528LL, 282690043758247936LL,\n+   18889LL, 465931478580854784LL, 21250LL, 649172913403461632LL,\n+   23611LL, 832414348226068480LL, 25973LL, 15655783048675328LL,\n+   28334LL, 198897217871282176LL, 30695LL, 382138652693889024LL,\n+   33056LL, 565380087516495872LL, 35417LL, 748621522339102720LL,\n+   37778LL, 931862957161709568LL, 40140LL, 115104391984316416LL,\n+   42501LL, 298345826806923264LL, 44862LL, 481587261629530112LL,\n+   47223LL, 664828696452136960LL, 49584LL, 848070131274743808LL,\n+   51946LL, 31311566097350656LL, 54307LL, 214553000919957504LL,\n+   56668LL, 397794435742564352LL, 59029LL, 581035870565171200LL,\n+   61390LL, 764277305387778048LL, 63751LL, 947518740210384896LL,\n+   66113LL, 130760175032991744LL, 68474LL, 314001609855598592LL,\n+   70835LL, 497243044678205440LL, 73196LL, 680484479500812288LL,\n+   75557LL, 863725914323419136LL, 77919LL, 46967349146025984LL,\n+   80280LL, 230208783968632832LL, 82641LL, 413450218791239680LL,\n+   85002LL, 596691653613846528LL, 87363LL, 779933088436453376LL,\n+   89724LL, 963174523259060224LL, 92086LL, 146415958081667072LL,\n+   94447LL, 329657392904273920LL, 96808LL, 512898827726880768LL,\n+   99169LL, 696140262549487616LL, 101530LL, 879381697372094464LL,\n+   103892LL, 62623132194701312LL, 106253LL, 245864567017308160LL,\n+   108614LL, 429106001839915008LL, 110975LL, 612347436662521856LL,\n+   113336LL, 795588871485128704LL, 115697LL, 978830306307735552LL,\n+   118059LL, 162071741130342400LL, 120420LL, 345313175952949248LL,\n+   122781LL, 528554610775556096LL, 125142LL, 711796045598162944LL,\n+   127503LL, 895037480420769792LL, 129865LL, 78278915243376640LL,\n+   132226LL, 261520350065983488LL, 134587LL, 444761784888590336LL,\n+   136948LL, 628003219711197184LL, 139309LL, 811244654533804032LL,\n+   141670LL, 994486089356410880LL, 144032LL, 177727524179017728LL,\n+   146393LL, 360968959001624576LL, 148754LL, 544210393824231424LL,\n+   },\n \n   {\n-  0LL, 0LL, 151115LL, 727451828646838272LL,\n-  302231LL, 454903657293676544LL, 453347LL, 182355485940514816LL,\n-  604462LL, 909807314587353088LL, 755578LL, 637259143234191360LL,\n-  906694LL, 364710971881029632LL, 1057810LL, 92162800527867904LL,\n-  1208925LL, 819614629174706176LL, 1360041LL, 547066457821544448LL,\n-  1511157LL, 274518286468382720LL, 1662273LL, 1970115115220992LL,\n-  1813388LL, 729421943762059264LL, 1964504LL, 456873772408897536LL,\n-  2115620LL, 184325601055735808LL, 2266735LL, 911777429702574080LL,\n-  2417851LL, 639229258349412352LL, 2568967LL, 366681086996250624LL,\n-  2720083LL, 94132915643088896LL, 2871198LL, 821584744289927168LL,\n-  3022314LL, 549036572936765440LL, 3173430LL, 276488401583603712LL,\n-  3324546LL, 3940230230441984LL, 3475661LL, 731392058877280256LL,\n-  3626777LL, 458843887524118528LL, 3777893LL, 186295716170956800LL,\n-  3929008LL, 913747544817795072LL, 4080124LL, 641199373464633344LL,\n-  4231240LL, 368651202111471616LL, 4382356LL, 96103030758309888LL,\n-  4533471LL, 823554859405148160LL, 4684587LL, 551006688051986432LL,\n-  4835703LL, 278458516698824704LL, 4986819LL, 5910345345662976LL,\n-  5137934LL, 733362173992501248LL, 5289050LL, 460814002639339520LL,\n-  5440166LL, 188265831286177792LL, 5591281LL, 915717659933016064LL,\n-  5742397LL, 643169488579854336LL, 5893513LL, 370621317226692608LL,\n-  6044629LL, 98073145873530880LL, 6195744LL, 825524974520369152LL,\n-  6346860LL, 552976803167207424LL, 6497976LL, 280428631814045696LL,\n-  6649092LL, 7880460460883968LL, 6800207LL, 735332289107722240LL,\n-  6951323LL, 462784117754560512LL, 7102439LL, 190235946401398784LL,\n-  7253554LL, 917687775048237056LL, 7404670LL, 645139603695075328LL,\n-  7555786LL, 372591432341913600LL, 7706902LL, 100043260988751872LL,\n-  7858017LL, 827495089635590144LL, 8009133LL, 554946918282428416LL,\n-  8160249LL, 282398746929266688LL, 8311365LL, 9850575576104960LL,\n-  8462480LL, 737302404222943232LL, 8613596LL, 464754232869781504LL,\n-  8764712LL, 192206061516619776LL, 8915827LL, 919657890163458048LL,\n-  9066943LL, 647109718810296320LL, 9218059LL, 374561547457134592LL,\n-  9369175LL, 102013376103972864LL, 9520290LL, 829465204750811136LL,\n-  },\n+   0LL, 0LL, 151115LL, 727451828646838272LL,\n+   302231LL, 454903657293676544LL, 453347LL, 182355485940514816LL,\n+   604462LL, 909807314587353088LL, 755578LL, 637259143234191360LL,\n+   906694LL, 364710971881029632LL, 1057810LL, 92162800527867904LL,\n+   1208925LL, 819614629174706176LL, 1360041LL, 547066457821544448LL,\n+   1511157LL, 274518286468382720LL, 1662273LL, 1970115115220992LL,\n+   1813388LL, 729421943762059264LL, 1964504LL, 456873772408897536LL,\n+   2115620LL, 184325601055735808LL, 2266735LL, 911777429702574080LL,\n+   2417851LL, 639229258349412352LL, 2568967LL, 366681086996250624LL,\n+   2720083LL, 94132915643088896LL, 2871198LL, 821584744289927168LL,\n+   3022314LL, 549036572936765440LL, 3173430LL, 276488401583603712LL,\n+   3324546LL, 3940230230441984LL, 3475661LL, 731392058877280256LL,\n+   3626777LL, 458843887524118528LL, 3777893LL, 186295716170956800LL,\n+   3929008LL, 913747544817795072LL, 4080124LL, 641199373464633344LL,\n+   4231240LL, 368651202111471616LL, 4382356LL, 96103030758309888LL,\n+   4533471LL, 823554859405148160LL, 4684587LL, 551006688051986432LL,\n+   4835703LL, 278458516698824704LL, 4986819LL, 5910345345662976LL,\n+   5137934LL, 733362173992501248LL, 5289050LL, 460814002639339520LL,\n+   5440166LL, 188265831286177792LL, 5591281LL, 915717659933016064LL,\n+   5742397LL, 643169488579854336LL, 5893513LL, 370621317226692608LL,\n+   6044629LL, 98073145873530880LL, 6195744LL, 825524974520369152LL,\n+   6346860LL, 552976803167207424LL, 6497976LL, 280428631814045696LL,\n+   6649092LL, 7880460460883968LL, 6800207LL, 735332289107722240LL,\n+   6951323LL, 462784117754560512LL, 7102439LL, 190235946401398784LL,\n+   7253554LL, 917687775048237056LL, 7404670LL, 645139603695075328LL,\n+   7555786LL, 372591432341913600LL, 7706902LL, 100043260988751872LL,\n+   7858017LL, 827495089635590144LL, 8009133LL, 554946918282428416LL,\n+   8160249LL, 282398746929266688LL, 8311365LL, 9850575576104960LL,\n+   8462480LL, 737302404222943232LL, 8613596LL, 464754232869781504LL,\n+   8764712LL, 192206061516619776LL, 8915827LL, 919657890163458048LL,\n+   9066943LL, 647109718810296320LL, 9218059LL, 374561547457134592LL,\n+   9369175LL, 102013376103972864LL, 9520290LL, 829465204750811136LL,\n+   },\n \n   {\n-  0LL, 0LL, 9671406LL, 556917033397649408LL,\n-  19342813LL, 113834066795298816LL, 29014219LL, 670751100192948224LL,\n-  38685626LL, 227668133590597632LL, 48357032LL, 784585166988247040LL,\n-  58028439LL, 341502200385896448LL, 67699845LL, 898419233783545856LL,\n-  77371252LL, 455336267181195264LL, 87042659LL, 12253300578844672LL,\n-  96714065LL, 569170333976494080LL, 106385472LL, 126087367374143488LL,\n-  116056878LL, 683004400771792896LL, 125728285LL, 239921434169442304LL,\n-  135399691LL, 796838467567091712LL, 145071098LL, 353755500964741120LL,\n-  154742504LL, 910672534362390528LL, 164413911LL, 467589567760039936LL,\n-  174085318LL, 24506601157689344LL, 183756724LL, 581423634555338752LL,\n-  193428131LL, 138340667952988160LL, 203099537LL, 695257701350637568LL,\n-  212770944LL, 252174734748286976LL, 222442350LL, 809091768145936384LL,\n-  232113757LL, 366008801543585792LL, 241785163LL, 922925834941235200LL,\n-  251456570LL, 479842868338884608LL, 261127977LL, 36759901736534016LL,\n-  270799383LL, 593676935134183424LL, 280470790LL, 150593968531832832LL,\n-  290142196LL, 707511001929482240LL, 299813603LL, 264428035327131648LL,\n-  309485009LL, 821345068724781056LL, 319156416LL, 378262102122430464LL,\n-  328827822LL, 935179135520079872LL, 338499229LL, 492096168917729280LL,\n-  348170636LL, 49013202315378688LL, 357842042LL, 605930235713028096LL,\n-  367513449LL, 162847269110677504LL, 377184855LL, 719764302508326912LL,\n-  386856262LL, 276681335905976320LL, 396527668LL, 833598369303625728LL,\n-  406199075LL, 390515402701275136LL, 415870481LL, 947432436098924544LL,\n-  425541888LL, 504349469496573952LL, 435213295LL, 61266502894223360LL,\n-  444884701LL, 618183536291872768LL, 454556108LL, 175100569689522176LL,\n-  464227514LL, 732017603087171584LL, 473898921LL, 288934636484820992LL,\n-  483570327LL, 845851669882470400LL, 493241734LL, 402768703280119808LL,\n-  502913140LL, 959685736677769216LL, 512584547LL, 516602770075418624LL,\n-  522255954LL, 73519803473068032LL, 531927360LL, 630436836870717440LL,\n-  541598767LL, 187353870268366848LL, 551270173LL, 744270903666016256LL,\n-  560941580LL, 301187937063665664LL, 570612986LL, 858104970461315072LL,\n-  580284393LL, 415022003858964480LL, 589955799LL, 971939037256613888LL,\n-  599627206LL, 528856070654263296LL, 609298613LL, 85773104051912704LL,\n-  },\n+   0LL, 0LL, 9671406LL, 556917033397649408LL,\n+   19342813LL, 113834066795298816LL, 29014219LL, 670751100192948224LL,\n+   38685626LL, 227668133590597632LL, 48357032LL, 784585166988247040LL,\n+   58028439LL, 341502200385896448LL, 67699845LL, 898419233783545856LL,\n+   77371252LL, 455336267181195264LL, 87042659LL, 12253300578844672LL,\n+   96714065LL, 569170333976494080LL, 106385472LL, 126087367374143488LL,\n+   116056878LL, 683004400771792896LL, 125728285LL, 239921434169442304LL,\n+   135399691LL, 796838467567091712LL, 145071098LL, 353755500964741120LL,\n+   154742504LL, 910672534362390528LL, 164413911LL, 467589567760039936LL,\n+   174085318LL, 24506601157689344LL, 183756724LL, 581423634555338752LL,\n+   193428131LL, 138340667952988160LL, 203099537LL, 695257701350637568LL,\n+   212770944LL, 252174734748286976LL, 222442350LL, 809091768145936384LL,\n+   232113757LL, 366008801543585792LL, 241785163LL, 922925834941235200LL,\n+   251456570LL, 479842868338884608LL, 261127977LL, 36759901736534016LL,\n+   270799383LL, 593676935134183424LL, 280470790LL, 150593968531832832LL,\n+   290142196LL, 707511001929482240LL, 299813603LL, 264428035327131648LL,\n+   309485009LL, 821345068724781056LL, 319156416LL, 378262102122430464LL,\n+   328827822LL, 935179135520079872LL, 338499229LL, 492096168917729280LL,\n+   348170636LL, 49013202315378688LL, 357842042LL, 605930235713028096LL,\n+   367513449LL, 162847269110677504LL, 377184855LL, 719764302508326912LL,\n+   386856262LL, 276681335905976320LL, 396527668LL, 833598369303625728LL,\n+   406199075LL, 390515402701275136LL, 415870481LL, 947432436098924544LL,\n+   425541888LL, 504349469496573952LL, 435213295LL, 61266502894223360LL,\n+   444884701LL, 618183536291872768LL, 454556108LL, 175100569689522176LL,\n+   464227514LL, 732017603087171584LL, 473898921LL, 288934636484820992LL,\n+   483570327LL, 845851669882470400LL, 493241734LL, 402768703280119808LL,\n+   502913140LL, 959685736677769216LL, 512584547LL, 516602770075418624LL,\n+   522255954LL, 73519803473068032LL, 531927360LL, 630436836870717440LL,\n+   541598767LL, 187353870268366848LL, 551270173LL, 744270903666016256LL,\n+   560941580LL, 301187937063665664LL, 570612986LL, 858104970461315072LL,\n+   580284393LL, 415022003858964480LL, 589955799LL, 971939037256613888LL,\n+   599627206LL, 528856070654263296LL, 609298613LL, 85773104051912704LL,\n+   },\n \n   {\n-  0LL, 0LL, 618970019LL, 642690137449562112LL,\n-  1237940039LL, 285380274899124224LL, 1856910058LL, 928070412348686336LL, \n-  2475880078LL, 570760549798248448LL, 3094850098LL, 213450687247810560LL, \n-  3713820117LL, 856140824697372672LL, 4332790137LL, 498830962146934784LL, \n-  4951760157LL, 141521099596496896LL, 5570730176LL, 784211237046059008LL,\n-  6189700196LL, 426901374495621120LL, 6808670216LL, 69591511945183232LL,\n-  7427640235LL, 712281649394745344LL, 8046610255LL, 354971786844307456LL,\n-  8665580274LL, 997661924293869568LL, 9284550294LL, 640352061743431680LL,\n-  9903520314LL, 283042199192993792LL, 10522490333LL, 925732336642555904LL,\n-  11141460353LL, 568422474092118016LL, 11760430373LL, 211112611541680128LL,\n-  12379400392LL, 853802748991242240LL, 12998370412LL, 496492886440804352LL,\n-  13617340432LL, 139183023890366464LL, 14236310451LL, 781873161339928576LL,\n-  14855280471LL, 424563298789490688LL, 15474250491LL, 67253436239052800LL,\n-  16093220510LL, 709943573688614912LL, 16712190530LL, 352633711138177024LL,\n-  17331160549LL, 995323848587739136LL, 17950130569LL, 638013986037301248LL,\n-  18569100589LL, 280704123486863360LL, 19188070608LL, 923394260936425472LL,\n-  19807040628LL, 566084398385987584LL, 20426010648LL, 208774535835549696LL,\n-  21044980667LL, 851464673285111808LL, 21663950687LL, 494154810734673920LL,\n-  22282920707LL, 136844948184236032LL, 22901890726LL, 779535085633798144LL,\n-  23520860746LL, 422225223083360256LL, 24139830766LL, 64915360532922368LL,\n-  24758800785LL, 707605497982484480LL, 25377770805LL, 350295635432046592LL,\n-  25996740824LL, 992985772881608704LL, 26615710844LL, 635675910331170816LL,\n-  27234680864LL, 278366047780732928LL, 27853650883LL, 921056185230295040LL,\n-  28472620903LL, 563746322679857152LL, 29091590923LL, 206436460129419264LL,\n-  29710560942LL, 849126597578981376LL, 30329530962LL, 491816735028543488LL,\n-  30948500982LL, 134506872478105600LL, 31567471001LL, 777197009927667712LL,\n-  32186441021LL, 419887147377229824LL, 32805411041LL, 62577284826791936LL,\n-  33424381060LL, 705267422276354048LL, 34043351080LL, 347957559725916160LL,\n-  34662321099LL, 990647697175478272LL, 35281291119LL, 633337834625040384LL,\n-  35900261139LL, 276027972074602496LL, 36519231158LL, 918718109524164608LL,\n-  37138201178LL, 561408246973726720LL, 37757171198LL, 204098384423288832LL,\n-  38376141217LL, 846788521872850944LL, 38995111237LL, 489478659322413056LL,\n-  },\n+   0LL, 0LL, 618970019LL, 642690137449562112LL,\n+   1237940039LL, 285380274899124224LL, 1856910058LL,\n+   928070412348686336LL,\n+   2475880078LL, 570760549798248448LL, 3094850098LL,\n+   213450687247810560LL,\n+   3713820117LL, 856140824697372672LL, 4332790137LL,\n+   498830962146934784LL,\n+   4951760157LL, 141521099596496896LL, 5570730176LL,\n+   784211237046059008LL,\n+   6189700196LL, 426901374495621120LL, 6808670216LL,\n+   69591511945183232LL,\n+   7427640235LL, 712281649394745344LL, 8046610255LL,\n+   354971786844307456LL,\n+   8665580274LL, 997661924293869568LL, 9284550294LL,\n+   640352061743431680LL,\n+   9903520314LL, 283042199192993792LL, 10522490333LL,\n+   925732336642555904LL,\n+   11141460353LL, 568422474092118016LL, 11760430373LL,\n+   211112611541680128LL,\n+   12379400392LL, 853802748991242240LL, 12998370412LL,\n+   496492886440804352LL,\n+   13617340432LL, 139183023890366464LL, 14236310451LL,\n+   781873161339928576LL,\n+   14855280471LL, 424563298789490688LL, 15474250491LL,\n+   67253436239052800LL,\n+   16093220510LL, 709943573688614912LL, 16712190530LL,\n+   352633711138177024LL,\n+   17331160549LL, 995323848587739136LL, 17950130569LL,\n+   638013986037301248LL,\n+   18569100589LL, 280704123486863360LL, 19188070608LL,\n+   923394260936425472LL,\n+   19807040628LL, 566084398385987584LL, 20426010648LL,\n+   208774535835549696LL,\n+   21044980667LL, 851464673285111808LL, 21663950687LL,\n+   494154810734673920LL,\n+   22282920707LL, 136844948184236032LL, 22901890726LL,\n+   779535085633798144LL,\n+   23520860746LL, 422225223083360256LL, 24139830766LL,\n+   64915360532922368LL,\n+   24758800785LL, 707605497982484480LL, 25377770805LL,\n+   350295635432046592LL,\n+   25996740824LL, 992985772881608704LL, 26615710844LL,\n+   635675910331170816LL,\n+   27234680864LL, 278366047780732928LL, 27853650883LL,\n+   921056185230295040LL,\n+   28472620903LL, 563746322679857152LL, 29091590923LL,\n+   206436460129419264LL,\n+   29710560942LL, 849126597578981376LL, 30329530962LL,\n+   491816735028543488LL,\n+   30948500982LL, 134506872478105600LL, 31567471001LL,\n+   777197009927667712LL,\n+   32186441021LL, 419887147377229824LL, 32805411041LL,\n+   62577284826791936LL,\n+   33424381060LL, 705267422276354048LL, 34043351080LL,\n+   347957559725916160LL,\n+   34662321099LL, 990647697175478272LL, 35281291119LL,\n+   633337834625040384LL,\n+   35900261139LL, 276027972074602496LL, 36519231158LL,\n+   918718109524164608LL,\n+   37138201178LL, 561408246973726720LL, 37757171198LL,\n+   204098384423288832LL,\n+   38376141217LL, 846788521872850944LL, 38995111237LL,\n+   489478659322413056LL,\n+   },\n \n   {\n-  0LL, 0LL, 39614081257LL, 132168796771975168LL, \n-  79228162514LL, 264337593543950336LL, 118842243771LL, 396506390315925504LL,\n-  158456325028LL, 528675187087900672LL, 198070406285LL, 660843983859875840LL,\n-  237684487542LL, 793012780631851008LL, 277298568799LL, 925181577403826176LL,\n-  316912650057LL, 57350374175801344LL, 356526731314LL, 189519170947776512LL,\n-  396140812571LL, 321687967719751680LL, 435754893828LL, 453856764491726848LL,\n-  475368975085LL, 586025561263702016LL, 514983056342LL, 718194358035677184LL,\n-  554597137599LL, 850363154807652352LL, 594211218856LL, 982531951579627520LL,\n-  633825300114LL, 114700748351602688LL, 673439381371LL, 246869545123577856LL,\n-  713053462628LL, 379038341895553024LL, 752667543885LL, 511207138667528192LL,\n-  792281625142LL, 643375935439503360LL, 831895706399LL, 775544732211478528LL,\n-  871509787656LL, 907713528983453696LL, 911123868914LL, 39882325755428864LL,\n-  950737950171LL, 172051122527404032LL, 990352031428LL, 304219919299379200LL,\n-  1029966112685LL, 436388716071354368LL, 1069580193942LL, 568557512843329536LL,\n-  1109194275199LL, 700726309615304704LL, 1148808356456LL, 832895106387279872LL,\n-  1188422437713LL, 965063903159255040LL, 1228036518971LL, 97232699931230208LL,\n-  1267650600228LL, 229401496703205376LL, 1307264681485LL, 361570293475180544LL,\n-  1346878762742LL, 493739090247155712LL, 1386492843999LL, 625907887019130880LL,\n-  1426106925256LL, 758076683791106048LL, 1465721006513LL, 890245480563081216LL,\n-  1505335087771LL, 22414277335056384LL, 1544949169028LL, 154583074107031552LL,\n-  1584563250285LL, 286751870879006720LL, 1624177331542LL, 418920667650981888LL,\n-  1663791412799LL, 551089464422957056LL, 1703405494056LL, 683258261194932224LL,\n-  1743019575313LL, 815427057966907392LL, 1782633656570LL, 947595854738882560LL,\n-  1822247737828LL, 79764651510857728LL, 1861861819085LL, 211933448282832896LL,\n-  1901475900342LL, 344102245054808064LL, 1941089981599LL, 476271041826783232LL,\n-  1980704062856LL, 608439838598758400LL, 2020318144113LL, 740608635370733568LL,\n-  2059932225370LL, 872777432142708736LL, 2099546306628LL, 4946228914683904LL,\n-  2139160387885LL, 137115025686659072LL, 2178774469142LL, 269283822458634240LL,\n-  2218388550399LL, 401452619230609408LL, 2258002631656LL, 533621416002584576LL,\n-  2297616712913LL, 665790212774559744LL, 2337230794170LL, 797959009546534912LL,\n-  2376844875427LL, 930127806318510080LL, 2416458956685LL, 62296603090485248LL,\n-  2456073037942LL, 194465399862460416LL, 2495687119199LL, 326634196634435584LL,\n-  },\n+   0LL, 0LL, 39614081257LL, 132168796771975168LL,\n+   79228162514LL, 264337593543950336LL, 118842243771LL,\n+   396506390315925504LL,\n+   158456325028LL, 528675187087900672LL, 198070406285LL,\n+   660843983859875840LL,\n+   237684487542LL, 793012780631851008LL, 277298568799LL,\n+   925181577403826176LL,\n+   316912650057LL, 57350374175801344LL, 356526731314LL,\n+   189519170947776512LL,\n+   396140812571LL, 321687967719751680LL, 435754893828LL,\n+   453856764491726848LL,\n+   475368975085LL, 586025561263702016LL, 514983056342LL,\n+   718194358035677184LL,\n+   554597137599LL, 850363154807652352LL, 594211218856LL,\n+   982531951579627520LL,\n+   633825300114LL, 114700748351602688LL, 673439381371LL,\n+   246869545123577856LL,\n+   713053462628LL, 379038341895553024LL, 752667543885LL,\n+   511207138667528192LL,\n+   792281625142LL, 643375935439503360LL, 831895706399LL,\n+   775544732211478528LL,\n+   871509787656LL, 907713528983453696LL, 911123868914LL,\n+   39882325755428864LL,\n+   950737950171LL, 172051122527404032LL, 990352031428LL,\n+   304219919299379200LL,\n+   1029966112685LL, 436388716071354368LL, 1069580193942LL,\n+   568557512843329536LL,\n+   1109194275199LL, 700726309615304704LL, 1148808356456LL,\n+   832895106387279872LL,\n+   1188422437713LL, 965063903159255040LL, 1228036518971LL,\n+   97232699931230208LL,\n+   1267650600228LL, 229401496703205376LL, 1307264681485LL,\n+   361570293475180544LL,\n+   1346878762742LL, 493739090247155712LL, 1386492843999LL,\n+   625907887019130880LL,\n+   1426106925256LL, 758076683791106048LL, 1465721006513LL,\n+   890245480563081216LL,\n+   1505335087771LL, 22414277335056384LL, 1544949169028LL,\n+   154583074107031552LL,\n+   1584563250285LL, 286751870879006720LL, 1624177331542LL,\n+   418920667650981888LL,\n+   1663791412799LL, 551089464422957056LL, 1703405494056LL,\n+   683258261194932224LL,\n+   1743019575313LL, 815427057966907392LL, 1782633656570LL,\n+   947595854738882560LL,\n+   1822247737828LL, 79764651510857728LL, 1861861819085LL,\n+   211933448282832896LL,\n+   1901475900342LL, 344102245054808064LL, 1941089981599LL,\n+   476271041826783232LL,\n+   1980704062856LL, 608439838598758400LL, 2020318144113LL,\n+   740608635370733568LL,\n+   2059932225370LL, 872777432142708736LL, 2099546306628LL,\n+   4946228914683904LL,\n+   2139160387885LL, 137115025686659072LL, 2178774469142LL,\n+   269283822458634240LL,\n+   2218388550399LL, 401452619230609408LL, 2258002631656LL,\n+   533621416002584576LL,\n+   2297616712913LL, 665790212774559744LL, 2337230794170LL,\n+   797959009546534912LL,\n+   2376844875427LL, 930127806318510080LL, 2416458956685LL,\n+   62296603090485248LL,\n+   2456073037942LL, 194465399862460416LL, 2495687119199LL,\n+   326634196634435584LL,\n+   },\n \n   {\n-  0LL, 0LL, 2535301200456LL, 458802993406410752LL,\n-  5070602400912LL, 917605986812821504LL, 7605903601369LL, 376408980219232256LL,\n-  10141204801825LL, 835211973625643008LL, 12676506002282LL, 294014967032053760LL,\n-  15211807202738LL, 752817960438464512LL, 17747108403195LL, 211620953844875264LL,\n-  20282409603651LL, 670423947251286016LL, 22817710804108LL, 129226940657696768LL,\n-  25353012004564LL, 588029934064107520LL, 27888313205021LL, 46832927470518272LL,\n-  30423614405477LL, 505635920876929024LL, 32958915605933LL, 964438914283339776LL,\n-  35494216806390LL, 423241907689750528LL, 38029518006846LL, 882044901096161280LL, 40564819207303LL, 340847894502572032LL, 43100120407759LL, 799650887908982784LL,\n-  45635421608216LL, 258453881315393536LL, 48170722808672LL, 717256874721804288LL,\n-  50706024009129LL, 176059868128215040LL, 53241325209585LL, 634862861534625792LL,\n-  55776626410042LL, 93665854941036544LL, 58311927610498LL, 552468848347447296LL,\n-  60847228810955LL, 11271841753858048LL, 63382530011411LL, 470074835160268800LL,\n-  65917831211867LL, 928877828566679552LL, 68453132412324LL, 387680821973090304LL,\n-  70988433612780LL, 846483815379501056LL, 73523734813237LL, 305286808785911808LL,\n-  76059036013693LL, 764089802192322560LL, 78594337214150LL, 222892795598733312LL,\n-  81129638414606LL, 681695789005144064LL, 83664939615063LL, 140498782411554816LL,\n-  86200240815519LL, 599301775817965568LL, 88735542015976LL, 58104769224376320LL,\n-  91270843216432LL, 516907762630787072LL, 93806144416888LL, 975710756037197824LL,\n-  96341445617345LL, 434513749443608576LL, 98876746817801LL, 893316742850019328LL,\n-  101412048018258LL, 352119736256430080LL, 103947349218714LL, 810922729662840832LL,\n-  106482650419171LL, 269725723069251584LL, 109017951619627LL, 728528716475662336LL,\n-  111553252820084LL, 187331709882073088LL, 114088554020540LL, 646134703288483840LL,\n-  116623855220997LL, 104937696694894592LL, 119159156421453LL, 563740690101305344LL,\n-  121694457621910LL, 22543683507716096LL, 124229758822366LL, 481346676914126848LL,\n-  126765060022822LL, 940149670320537600LL, 129300361223279LL, 398952663726948352LL,\n-  131835662423735LL, 857755657133359104LL, 134370963624192LL, 316558650539769856LL,\n-  136906264824648LL, 775361643946180608LL, 139441566025105LL, 234164637352591360LL,\n-  141976867225561LL, 692967630759002112LL, 144512168426018LL, 151770624165412864LL,\n-  147047469626474LL, 610573617571823616LL, 149582770826931LL, 69376610978234368LL,\n-  152118072027387LL, 528179604384645120LL, 154653373227843LL, 986982597791055872LL,\n-  157188674428300LL, 445785591197466624LL, 159723975628756LL, 904588584603877376LL,\n-  },\n+   0LL, 0LL, 2535301200456LL, 458802993406410752LL,\n+   5070602400912LL, 917605986812821504LL, 7605903601369LL,\n+   376408980219232256LL,\n+   10141204801825LL, 835211973625643008LL, 12676506002282LL,\n+   294014967032053760LL,\n+   15211807202738LL, 752817960438464512LL, 17747108403195LL,\n+   211620953844875264LL,\n+   20282409603651LL, 670423947251286016LL, 22817710804108LL,\n+   129226940657696768LL,\n+   25353012004564LL, 588029934064107520LL, 27888313205021LL,\n+   46832927470518272LL,\n+   30423614405477LL, 505635920876929024LL, 32958915605933LL,\n+   964438914283339776LL,\n+   35494216806390LL, 423241907689750528LL, 38029518006846LL,\n+   882044901096161280LL,\n+   40564819207303LL, 340847894502572032LL, 43100120407759LL,\n+   799650887908982784LL,\n+   45635421608216LL, 258453881315393536LL, 48170722808672LL,\n+   717256874721804288LL,\n+   50706024009129LL, 176059868128215040LL, 53241325209585LL,\n+   634862861534625792LL,\n+   55776626410042LL, 93665854941036544LL, 58311927610498LL,\n+   552468848347447296LL,\n+   60847228810955LL, 11271841753858048LL, 63382530011411LL,\n+   470074835160268800LL,\n+   65917831211867LL, 928877828566679552LL, 68453132412324LL,\n+   387680821973090304LL,\n+   70988433612780LL, 846483815379501056LL, 73523734813237LL,\n+   305286808785911808LL,\n+   76059036013693LL, 764089802192322560LL, 78594337214150LL,\n+   222892795598733312LL,\n+   81129638414606LL, 681695789005144064LL, 83664939615063LL,\n+   140498782411554816LL,\n+   86200240815519LL, 599301775817965568LL, 88735542015976LL,\n+   58104769224376320LL,\n+   91270843216432LL, 516907762630787072LL, 93806144416888LL,\n+   975710756037197824LL,\n+   96341445617345LL, 434513749443608576LL, 98876746817801LL,\n+   893316742850019328LL,\n+   101412048018258LL, 352119736256430080LL, 103947349218714LL,\n+   810922729662840832LL,\n+   106482650419171LL, 269725723069251584LL, 109017951619627LL,\n+   728528716475662336LL,\n+   111553252820084LL, 187331709882073088LL, 114088554020540LL,\n+   646134703288483840LL,\n+   116623855220997LL, 104937696694894592LL, 119159156421453LL,\n+   563740690101305344LL,\n+   121694457621910LL, 22543683507716096LL, 124229758822366LL,\n+   481346676914126848LL,\n+   126765060022822LL, 940149670320537600LL, 129300361223279LL,\n+   398952663726948352LL,\n+   131835662423735LL, 857755657133359104LL, 134370963624192LL,\n+   316558650539769856LL,\n+   136906264824648LL, 775361643946180608LL, 139441566025105LL,\n+   234164637352591360LL,\n+   141976867225561LL, 692967630759002112LL, 144512168426018LL,\n+   151770624165412864LL,\n+   147047469626474LL, 610573617571823616LL, 149582770826931LL,\n+   69376610978234368LL,\n+   152118072027387LL, 528179604384645120LL, 154653373227843LL,\n+   986982597791055872LL,\n+   157188674428300LL, 445785591197466624LL, 159723975628756LL,\n+   904588584603877376LL,\n+   },\n \n   {\n-  0LL, 0LL, 162259276829213LL, 363391578010288128LL,\n-  324518553658426LL, 726783156020576256LL, 486777830487640LL, 90174734030864384LL,\n-  649037107316853LL, 453566312041152512LL, 811296384146066LL, 816957890051440640LL,\n-  973555660975280LL, 180349468061728768LL, 1135814937804493LL, 543741046072016896LL,\n-  1298074214633706LL, 907132624082305024LL, 1460333491462920LL, 270524202092593152LL,\n-  1622592768292133LL, 633915780102881280LL, 1784852045121346LL, 997307358113169408LL,\n-  1947111321950560LL, 360698936123457536LL, 2109370598779773LL, 724090514133745664LL,\n-  2271629875608987LL, 87482092144033792LL, 2433889152438200LL, 450873670154321920LL,\n-  2596148429267413LL, 814265248164610048LL, 2758407706096627LL, 177656826174898176LL,\n-  2920666982925840LL, 541048404185186304LL, 3082926259755053LL, 904439982195474432LL,\n-  3245185536584267LL, 267831560205762560LL, 3407444813413480LL, 631223138216050688LL,\n-  3569704090242693LL, 994614716226338816LL, 3731963367071907LL, 358006294236626944LL,\n-  3894222643901120LL, 721397872246915072LL, 4056481920730334LL, 84789450257203200LL,\n-  4218741197559547LL, 448181028267491328LL, 4381000474388760LL, 811572606277779456LL,\n-  4543259751217974LL, 174964184288067584LL, 4705519028047187LL, 538355762298355712LL,\n-  4867778304876400LL, 901747340308643840LL, 5030037581705614LL, 265138918318931968LL,\n-  5192296858534827LL, 628530496329220096LL, 5354556135364040LL, 991922074339508224LL,\n-  5516815412193254LL, 355313652349796352LL, 5679074689022467LL, 718705230360084480LL,\n-  5841333965851681LL, 82096808370372608LL, 6003593242680894LL, 445488386380660736LL,\n-  6165852519510107LL, 808879964390948864LL, 6328111796339321LL, 172271542401236992LL,\n-  6490371073168534LL, 535663120411525120LL, 6652630349997747LL, 899054698421813248LL,\n-  6814889626826961LL, 262446276432101376LL, 6977148903656174LL, 625837854442389504LL,\n-  7139408180485387LL, 989229432452677632LL, 7301667457314601LL, 352621010462965760LL,\n-  7463926734143814LL, 716012588473253888LL, 7626186010973028LL, 79404166483542016LL,\n-  7788445287802241LL, 442795744493830144LL, 7950704564631454LL, 806187322504118272LL,\n-  8112963841460668LL, 169578900514406400LL, 8275223118289881LL, 532970478524694528LL,\n-  8437482395119094LL, 896362056534982656LL, 8599741671948308LL, 259753634545270784LL,\n-  8762000948777521LL, 623145212555558912LL, 8924260225606734LL, 986536790565847040LL,\n-  9086519502435948LL, 349928368576135168LL, 9248778779265161LL, 713319946586423296LL,\n-  9411038056094375LL, 76711524596711424LL, 9573297332923588LL, 440103102606999552LL,\n-  9735556609752801LL, 803494680617287680LL, 9897815886582015LL, 166886258627575808LL,\n-  10060075163411228LL, 530277836637863936LL, 10222334440240441LL, 893669414648152064LL\n-  }\n+   0LL, 0LL, 162259276829213LL, 363391578010288128LL,\n+   324518553658426LL, 726783156020576256LL, 486777830487640LL,\n+   90174734030864384LL,\n+   649037107316853LL, 453566312041152512LL, 811296384146066LL,\n+   816957890051440640LL,\n+   973555660975280LL, 180349468061728768LL, 1135814937804493LL,\n+   543741046072016896LL,\n+   1298074214633706LL, 907132624082305024LL, 1460333491462920LL,\n+   270524202092593152LL,\n+   1622592768292133LL, 633915780102881280LL, 1784852045121346LL,\n+   997307358113169408LL,\n+   1947111321950560LL, 360698936123457536LL, 2109370598779773LL,\n+   724090514133745664LL,\n+   2271629875608987LL, 87482092144033792LL, 2433889152438200LL,\n+   450873670154321920LL,\n+   2596148429267413LL, 814265248164610048LL, 2758407706096627LL,\n+   177656826174898176LL,\n+   2920666982925840LL, 541048404185186304LL, 3082926259755053LL,\n+   904439982195474432LL,\n+   3245185536584267LL, 267831560205762560LL, 3407444813413480LL,\n+   631223138216050688LL,\n+   3569704090242693LL, 994614716226338816LL, 3731963367071907LL,\n+   358006294236626944LL,\n+   3894222643901120LL, 721397872246915072LL, 4056481920730334LL,\n+   84789450257203200LL,\n+   4218741197559547LL, 448181028267491328LL, 4381000474388760LL,\n+   811572606277779456LL,\n+   4543259751217974LL, 174964184288067584LL, 4705519028047187LL,\n+   538355762298355712LL,\n+   4867778304876400LL, 901747340308643840LL, 5030037581705614LL,\n+   265138918318931968LL,\n+   5192296858534827LL, 628530496329220096LL, 5354556135364040LL,\n+   991922074339508224LL,\n+   5516815412193254LL, 355313652349796352LL, 5679074689022467LL,\n+   718705230360084480LL,\n+   5841333965851681LL, 82096808370372608LL, 6003593242680894LL,\n+   445488386380660736LL,\n+   6165852519510107LL, 808879964390948864LL, 6328111796339321LL,\n+   172271542401236992LL,\n+   6490371073168534LL, 535663120411525120LL, 6652630349997747LL,\n+   899054698421813248LL,\n+   6814889626826961LL, 262446276432101376LL, 6977148903656174LL,\n+   625837854442389504LL,\n+   7139408180485387LL, 989229432452677632LL, 7301667457314601LL,\n+   352621010462965760LL,\n+   7463926734143814LL, 716012588473253888LL, 7626186010973028LL,\n+   79404166483542016LL,\n+   7788445287802241LL, 442795744493830144LL, 7950704564631454LL,\n+   806187322504118272LL,\n+   8112963841460668LL, 169578900514406400LL, 8275223118289881LL,\n+   532970478524694528LL,\n+   8437482395119094LL, 896362056534982656LL, 8599741671948308LL,\n+   259753634545270784LL,\n+   8762000948777521LL, 623145212555558912LL, 8924260225606734LL,\n+   986536790565847040LL,\n+   9086519502435948LL, 349928368576135168LL, 9248778779265161LL,\n+   713319946586423296LL,\n+   9411038056094375LL, 76711524596711424LL, 9573297332923588LL,\n+   440103102606999552LL,\n+   9735556609752801LL, 803494680617287680LL, 9897815886582015LL,\n+   166886258627575808LL,\n+   10060075163411228LL, 530277836637863936LL, 10222334440240441LL,\n+   893669414648152064LL}\n };"}, {"sha": "9cb48135ef5ffd7699ef4681bfd927d240100062", "filename": "libgcc/config/libbid/bid128_add.c", "status": "modified", "additions": 2748, "deletions": 2242, "changes": 4990, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "fd78019f62c3c5f817b8f57593e73a11c76cf020", "filename": "libgcc/config/libbid/bid128_compare.c", "status": "modified", "additions": 3018, "deletions": 3278, "changes": 6296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "5adc6c7ef3d0f80bd4fadbc19b165dc4f39a159e", "filename": "libgcc/config/libbid/bid128_div.c", "status": "modified", "additions": 1709, "deletions": 317, "changes": 2026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -27,180 +27,657 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n #define BID_128RES\n-#include \"div_macros.h\"\n+#include \"bid_div_macros.h\"\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+#include <fenv.h>\n \n-extern UINT32 __bid_convert_table[5][128][2];\n-extern SINT8 __bid_factors[][2];\n-extern UINT8 __bid_packed_10000_zeros[];\n+#define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT\n+#endif\n+\n+extern UINT32 convert_table[5][128][2];\n+extern SINT8 factors[][2];\n+extern UINT8 packed_10000_zeros[];\n \n-BID128_FUNCTION_ARG2(__bid128_div, x, y)\n+BID128_FUNCTION_ARG2 (bid128_div, x, y)\n \n-  UINT256 CA4, CA4r, P256;\n-  UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n-  UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, X, PD;\n-  int_float fx, fy, f64;\n-  UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n-  int exponent_x = 0, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n-    digits_q, amount;\n-  int nzeros, i, j, k, d5;\n-  unsigned rmode;\n+     UINT256 CA4, CA4r, P256;\n+     UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n+     UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, PD,\n+       valid_y;\n+     int_float fx, fy, f64;\n+     UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+     int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+       digits_q, amount;\n+     int nzeros, i, j, k, d5;\n+     unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n \n+valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);\n \n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n     // test if x is NaN\n-    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull || // sNaN\n-          (y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull ||\t// sNaN\n+      (y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res.w[1] = (x.w[1]) & QUIET_MASK64;\n-      res.w[0] = x.w[0];\n-      BID_RETURN (res);\n-    }\n+  res.w[1] = (CX.w[1]) & QUIET_MASK64;\n+  res.w[0] = CX.w[0];\n+  BID_RETURN (res);\n+}\n     // x is Infinity?\n-    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // check if y is Inf. \n-      if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n-        // return NaN \n-      {\n+if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if y is Inf. \n+  if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+    // return NaN \n+  {\n #ifdef SET_STATUS_FLAGS\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-        res.w[1] = 0x7c00000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      }\n-      // y is NaN?\n-      if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n-        // return NaN \n-      {\n-        // return +/-Inf\n-        res.w[1] = ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | \n-            0x7800000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      }\n-    }\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is NaN?\n+  if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n+    // return NaN \n+  {\n+    // return +/-Inf\n+    res.w[1] = ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) |\n+      0x7800000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+}\n     // x is 0\n-    if ((y.w[1] & 0x7800000000000000ull) < 0x7800000000000000ull) {\n-      if ((!y.w[0]) && !(y.w[1] & 0x0001ffffffffffffull)) {\n+if ((y.w[1] & 0x7800000000000000ull) < 0x7800000000000000ull) {\n+  if ((!CY.w[0]) && !(CY.w[1] & 0x0001ffffffffffffull)) {\n #ifdef SET_STATUS_FLAGS\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-        // x=y=0, return NaN\n-        res.w[1] = 0x7c00000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      }\n-      // return 0\n-      res.w[1] = (x.w[1] ^ y.w[1]) & 0x8000000000000000ull;\n-      X = ((y.w[1]) << 1) >> 50;\n-      exponent_x = exponent_x - (int) X + DECIMAL_EXPONENT_BIAS_128;\n-      if (exponent_x > DECIMAL_MAX_EXPON_128)\n-        exponent_x = DECIMAL_MAX_EXPON_128;\n-      else if (exponent_x < 0)\n-        exponent_x = 0;\n-      res.w[1] |= (((UINT64) exponent_x) << 49);\n-      res.w[0] = 0;\n-      BID_RETURN (res);\n-    }\n+    // x=y=0, return NaN\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n   }\n-  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n-    // y is Inf. or NaN\n+  // return 0\n+  res.w[1] = (x.w[1] ^ y.w[1]) & 0x8000000000000000ull;\n+  exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+  if (exponent_x > DECIMAL_MAX_EXPON_128)\n+    exponent_x = DECIMAL_MAX_EXPON_128;\n+  else if (exponent_x < 0)\n+    exponent_x = 0;\n+  res.w[1] |= (((UINT64) exponent_x) << 49);\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+}\n+if (!valid_y) {\n+  // y is Inf. or NaN\n \n-    // test if y is NaN\n-    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+  // test if y is NaN\n+  if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) // sNaN\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res.w[1] = y.w[1] & QUIET_MASK64;\n-      res.w[0] = y.w[0];\n-      BID_RETURN (res);\n-    }\n-    // y is Infinity?\n-    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // return +/-0\n-      res.w[1] = sign_x ^ sign_y;\n-      res.w[0] = 0;\n-      BID_RETURN (res);\n-    }\n-    // y is 0, return +/-Inf\n+    res.w[1] = CY.w[1] & QUIET_MASK64;\n+    res.w[0] = CY.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res.w[1] = sign_x ^ sign_y;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n #ifdef SET_STATUS_FLAGS\n-    __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  res.w[1] =\n+    ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 33;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  if (!CR.w[1] && !CR.w[0]) {\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+\t\tpfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n #endif\n-    res.w[1] =\n-      ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n-    res.w[0] = 0;\n     BID_RETURN (res);\n   }\n-  diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  ed2 = 34 - digits_q;\n+  T128.w[0] = power10_table_128[ed2].w[0];\n+  T128.w[1] = power10_table_128[ed2].w[1];\n+  __mul_128x128_to_256 (CA4, CR, T128);\n+  diff_expon = diff_expon - ed2;\n+  __mul_128x128_low (CQ, CQ, T128);\n+\n+}\n+\n+__div_256_by_128 (&CQ, &CA4, CY);\n+\n+#ifdef SET_STATUS_FLAGS\n+if (CA4.w[0] || CA4.w[1]) {\n+  // set status flags\n+  __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+}\n+#ifndef LEAVE_TRAILING_ZEROS\n+else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+  // check whether result is exact\n+{\n+  // check whether CX, CY are short\n+  if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+    i = (int) CY.w[0] - 1;\n+    j = (int) CX.w[0] - 1;\n+    // difference in powers of 2 factors for Y and X\n+    nzeros = ed2 - factors[i][0] + factors[j][0];\n+    // difference in powers of 5 factors\n+    d5 = ed2 - factors[i][1] + factors[j][1];\n+    if (d5 < nzeros)\n+      nzeros = d5;\n+    // get P*(2^M[extra_digits])/10^extra_digits\n+    __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n \n-  if (__unsigned_compare_gt_128 (CY, CX)) {\n-    // CX < CY\n+    // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+    amount = recip_scale[nzeros];\n+    __shr_128_long (CQ, Qh, amount);\n \n-    // 2^64\n-    f64.i = 0x5f800000;\n+    diff_expon += nzeros;\n+  } else {\n+    // decompose Q as Qh*10^17 + Ql\n+    //T128 = reciprocals10_128[17];\n+    T128.w[0] = 0x44909befeb9fad49ull;\n+    T128.w[1] = 0x000b877aa3236a4bull;\n+    __mul_128x128_to_256 (P256, CQ, T128);\n+    //amount = recip_scale[17];\n+    Q_high = (P256.w[2] >> 44) | (P256.w[3] << (64 - 44));\n+    Q_low = CQ.w[0] - Q_high * 100000000000000000ull;\n+\n+    if (!Q_low) {\n+      diff_expon += 17;\n+\n+      tdigit[0] = Q_high & 0x3ffffff;\n+      tdigit[1] = 0;\n+      QX = Q_high >> 26;\n+      QX32 = QX;\n+      nzeros = 0;\n+\n+      for (j = 0; QX32; j++, QX32 >>= 7) {\n+\tk = (QX32 & 127);\n+\ttdigit[0] += convert_table[j][k][0];\n+\ttdigit[1] += convert_table[j][k][1];\n+\tif (tdigit[0] >= 100000000) {\n+\t  tdigit[0] -= 100000000;\n+\t  tdigit[1]++;\n+\t}\n+      }\n+\n+      if (tdigit[1] >= 100000000) {\n+\ttdigit[1] -= 100000000;\n+\tif (tdigit[1] >= 100000000)\n+\t  tdigit[1] -= 100000000;\n+      }\n+\n+      digit = tdigit[0];\n+      if (!digit && !tdigit[1])\n+\tnzeros += 16;\n+      else {\n+\tif (!digit) {\n+\t  nzeros += 8;\n+\t  digit = tdigit[1];\n+\t}\n+\t// decompose digit\n+\tPD = (UINT64) digit *0x068DB8BBull;\n+\tdigit_h = (UINT32) (PD >> 40);\n+\tdigit_low = digit - digit_h * 10000;\n \n-    // fx ~ CX,   fy ~ CY\n-    fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n-    fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n-    // expon_cy - expon_cx\n-    bin_index = (fy.i - fx.i) >> 23;\n+\tif (!digit_low)\n+\t  nzeros += 4;\n+\telse\n+\t  digit_h = digit_low;\n \n-    if (CX.w[1]) {\n-      T = __bid_power10_index_binexp_128[bin_index].w[0];\n-      __mul_64x128_short (CA, T, CX);\n+\tif (!(digit_h & 1))\n+\t  nzeros +=\n+\t    3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t  (digit_h & 7));\n+      }\n+\n+      if (nzeros) {\n+\t__mul_64x64_to_128 (CQ, Q_high, reciprocals10_64[nzeros]);\n+\n+\t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n+\tamount = short_recip_scale[nzeros];\n+\tCQ.w[0] = CQ.w[1] >> amount;\n+      } else\n+\tCQ.w[0] = Q_high;\n+      CQ.w[1] = 0;\n+\n+      diff_expon += nzeros;\n     } else {\n-      T128 = __bid_power10_index_binexp_128[bin_index];\n-      __mul_64x128_short (CA, CX.w[0], T128);\n+      tdigit[0] = Q_low & 0x3ffffff;\n+      tdigit[1] = 0;\n+      QX = Q_low >> 26;\n+      QX32 = QX;\n+      nzeros = 0;\n+\n+      for (j = 0; QX32; j++, QX32 >>= 7) {\n+\tk = (QX32 & 127);\n+\ttdigit[0] += convert_table[j][k][0];\n+\ttdigit[1] += convert_table[j][k][1];\n+\tif (tdigit[0] >= 100000000) {\n+\t  tdigit[0] -= 100000000;\n+\t  tdigit[1]++;\n+\t}\n+      }\n+\n+      if (tdigit[1] >= 100000000) {\n+\ttdigit[1] -= 100000000;\n+\tif (tdigit[1] >= 100000000)\n+\t  tdigit[1] -= 100000000;\n+      }\n+\n+      digit = tdigit[0];\n+      if (!digit && !tdigit[1])\n+\tnzeros += 16;\n+      else {\n+\tif (!digit) {\n+\t  nzeros += 8;\n+\t  digit = tdigit[1];\n+\t}\n+\t// decompose digit\n+\tPD = (UINT64) digit *0x068DB8BBull;\n+\tdigit_h = (UINT32) (PD >> 40);\n+\tdigit_low = digit - digit_h * 10000;\n+\n+\tif (!digit_low)\n+\t  nzeros += 4;\n+\telse\n+\t  digit_h = digit_low;\n+\n+\tif (!(digit_h & 1))\n+\t  nzeros +=\n+\t    3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t  (digit_h & 7));\n+      }\n+\n+      if (nzeros) {\n+\t// get P*(2^M[extra_digits])/10^extra_digits\n+\t__mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t//now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\tamount = recip_scale[nzeros];\n+\t__shr_128 (CQ, Qh, amount);\n+      }\n+      diff_expon += nzeros;\n+\n     }\n+  }\n+  get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+  BID_RETURN (res);\n+}\n+#endif\n+\n+if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n+  }\n+#endif\n+#endif\n+\n+} else {\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#endif\n+\n+  handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n+\t\t     CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+  BID_RETURN (res);\n+\n+}\n+\n+get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n+}\n+\n+\n+//#define LEAVE_TRAILING_ZEROS\n+\n+TYPE0_FUNCTION_ARGTYPE1_ARGTYPE2 (UINT128, bid128dd_div, UINT64, x,\n+\t\t\t\t  UINT64, y)\n+\n+     UINT256 CA4, CA4r, P256;\n+     UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n+     UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, PD,\n+       valid_y;\n+     int_float fx, fy, f64;\n+     UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+     int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+       digits_q, amount;\n+     int nzeros, i, j, k, d5;\n+     unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n+\n+valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], y);\n+\n+\t// unpack arguments, check for NaN or Infinity\n+CX.w[1] = 0;\n+if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {\n+#ifdef SET_STATUS_FLAGS\n+if ((y & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // test if x is NaN\n+if ((x & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+  if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);\n+  __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);\n+  res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);\n+  BID_RETURN (res);\n+}\n+\t   // x is Infinity?\n+if (((x) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if y is Inf.\n+  if ((((y) & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+    // return NaN \n+  {\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  if ((((y) & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {\n+  // otherwise return +/-Inf\n+  res.w[1] =\n+    (((x) ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+  }\n+}\n+\t   // x is 0\n+if ((((y) & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+    if(!CY.w[0]) {\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  // x=y=0, return NaN\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+\t   // return 0\n+res.w[1] = ((x) ^ (y)) & 0x8000000000000000ull;\n+if (((y) & 0x6000000000000000ull) == 0x6000000000000000ull)\n+  exponent_y = ((UINT32) ((y) >> 51)) & 0x3ff;\n+else\n+  exponent_y = ((UINT32) ((y) >> 53)) & 0x3ff;\n+exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+if (exponent_x > DECIMAL_MAX_EXPON_128)\n+  exponent_x = DECIMAL_MAX_EXPON_128;\n+else if (exponent_x < 0)\n+  exponent_x = 0;\n+res.w[1] |= (((UINT64) exponent_x) << 49);\n+res.w[0] = 0;\n+BID_RETURN (res);\n+}\n+}\n+\n+CY.w[1] = 0;\n+if (!valid_y) {\n+  // y is Inf. or NaN\n \n-    ed2 = 33;\n-    if (__unsigned_compare_gt_128 (CY, CA))\n-      ed2++;\n+  // test if y is NaN\n+  if ((y & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (CY.w[0] & 0x0003ffffffffffffull);\n+  __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);\n+  res.w[1] |= ((CY.w[0]) & 0xfc00000000000000ull);\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if (((y) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res.w[1] = sign_x ^ sign_y;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n+  res.w[1] =\n+    (((x) ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+  res.w[0] = 0;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n \n-    T128 = __bid_power10_table_128[ed2];\n-    __mul_128x128_to_256 (CA4, CA, T128);\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n \n-    ed2 += __bid_estimate_decimal_digits[bin_index];\n-    CQ.w[0] = CQ.w[1] = 0;\n-    diff_expon = diff_expon - ed2;\n+  // 2^64\n+  f64.i = 0x5f800000;\n \n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n   } else {\n-    // get CQ = CX/CY\n-    __div_128_by_128 (&CQ, &CR, CX, CY);\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n \n-    if (!CR.w[1] && !CR.w[0]) {\n-      get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n-                  pfpsf);\n-      BID_RETURN (res);\n-    }\n-    // get number of decimal digits in CQ\n-    // 2^64\n-    f64.i = 0x5f800000;\n-    fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n-    // binary expon. of CQ\n-    bin_expon = (fx.i - 0x3f800000) >> 23;\n+  ed2 = 33;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n \n-    digits_q = __bid_estimate_decimal_digits[bin_expon];\n-    TP128.w[0] = __bid_power10_index_binexp_128[bin_expon].w[0];\n-    TP128.w[1] = __bid_power10_index_binexp_128[bin_expon].w[1];\n-    if (__unsigned_compare_ge_128 (CQ, TP128))\n-      digits_q++;\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n \n-    ed2 = 34 - digits_q;\n-    T128.w[0] = __bid_power10_table_128[ed2].w[0];\n-    T128.w[1] = __bid_power10_table_128[ed2].w[1];\n-    __mul_128x128_to_256 (CA4, CR, T128);\n-    diff_expon = diff_expon - ed2;\n-    __mul_128x128_low (CQ, CQ, T128);\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n \n+  if (!CR.w[1] && !CR.w[0]) {\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+\t\tpfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n   }\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  ed2 = 34 - digits_q;\n+  T128.w[0] = power10_table_128[ed2].w[0];\n+  T128.w[1] = power10_table_128[ed2].w[1];\n+  __mul_128x128_to_256 (CA4, CR, T128);\n+  diff_expon = diff_expon - ed2;\n+  __mul_128x128_low (CQ, CQ, T128);\n+\n+}\n+\n+__div_256_by_128 (&CQ, &CA4, CY);\n \n-  __div_256_by_128 (&CQ, &CA4, CY);\n \n #ifdef SET_STATUS_FLAGS\n   if (CA4.w[0] || CA4.w[1]) {\n@@ -222,243 +699,1158 @@ BID128_FUNCTION_ARG2(__bid128_div, x, y)\n     if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n       i = (int) CY.w[0] - 1;\n       j = (int) CX.w[0] - 1;\n-      // difference in powers of 2 __bid_factors for Y and X\n-      nzeros = ed2 - __bid_factors[i][0] + __bid_factors[j][0];\n-      // difference in powers of 5 __bid_factors\n-      d5 = ed2 - __bid_factors[i][1] + __bid_factors[j][1];\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n       if (d5 < nzeros)\n-        nzeros = d5;\n+\tnzeros = d5;\n       // get P*(2^M[extra_digits])/10^extra_digits\n-      __mul_128x128_full (Qh, Ql, CQ, __bid_reciprocals10_128[nzeros]);\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];\n \n       // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n-      amount = __bid_recip_scale[nzeros];\n+      amount = recip_scale[nzeros];\n       __shr_128_long (CQ, Qh, amount);\n \n       diff_expon += nzeros;\n     } else {\n       // decompose Q as Qh*10^17 + Ql\n-      //T128 = __bid_reciprocals10_128[17];\n+      //T128 = reciprocals10_128[17];\n       T128.w[0] = 0x44909befeb9fad49ull;\n       T128.w[1] = 0x000b877aa3236a4bull;\n       __mul_128x128_to_256 (P256, CQ, T128);\n-      //amount = __bid_recip_scale[17];\n+      //amount = recip_scale[17];\n       Q_high = (P256.w[2] >> 44) | (P256.w[3] << (64 - 44));\n       Q_low = CQ.w[0] - Q_high * 100000000000000000ull;\n \n       if (!Q_low) {\n-        diff_expon += 17;\n-\n-        tdigit[0] = Q_high & 0x3ffffff;\n-        tdigit[1] = 0;\n-        QX = Q_high >> 26;\n-        QX32 = QX;\n-        nzeros = 0;\n-\n-        for (j = 0; QX32; j++, QX32 >>= 7) {\n-          k = (QX32 & 127);\n-          tdigit[0] += __bid_convert_table[j][k][0];\n-          tdigit[1] += __bid_convert_table[j][k][1];\n-          if (tdigit[0] >= 100000000) {\n-            tdigit[0] -= 100000000;\n-            tdigit[1]++;\n-          }\n-        }\n-\n-        if (tdigit[1] >= 100000000) {\n-          tdigit[1] -= 100000000;\n-          if (tdigit[1] >= 100000000)\n-            tdigit[1] -= 100000000;\n-        }\n-\n-        digit = tdigit[0];\n-        if (!digit && !tdigit[1])\n-          nzeros += 16;\n-        else {\n-          if (!digit) {\n-            nzeros += 8;\n-            digit = tdigit[1];\n-          }\n-          // decompose digit\n-          PD = (UINT64) digit *0x068DB8BBull;\n-          digit_h = (UINT32) (PD >> 40);\n-          digit_low = digit - digit_h * 10000;\n-\n-          if (!digit_low)\n-            nzeros += 4;\n-          else\n-            digit_h = digit_low;\n-\n-          if (!(digit_h & 1))\n-            nzeros +=\n-              3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n-                            (digit_h & 7));\n-        }\n-\n-        if (nzeros) {\n-          __mul_64x64_to_128 (CQ, Q_high, __bid_reciprocals10_64[nzeros]);\n-\n-          // now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n-          amount = __bid_short_recip_scale[nzeros];\n-          CQ.w[0] = CQ.w[1] >> amount;\n-        } else\n-          CQ.w[0] = Q_high;\n-        CQ.w[1] = 0;\n-\n-        diff_expon += nzeros;\n+\tdiff_expon += 17;\n+\n+\ttdigit[0] = Q_high & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_high >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  __mul_64x64_to_128 (CQ, Q_high, reciprocals10_64[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n+\t  amount = short_recip_scale[nzeros];\n+\t  CQ.w[0] = CQ.w[1] >> amount;\n+\t} else\n+\t  CQ.w[0] = Q_high;\n+\tCQ.w[1] = 0;\n+\n+\tdiff_expon += nzeros;\n       } else {\n-        tdigit[0] = Q_low & 0x3ffffff;\n-        tdigit[1] = 0;\n-        QX = Q_low >> 26;\n-        QX32 = QX;\n-        nzeros = 0;\n-\n-        for (j = 0; QX32; j++, QX32 >>= 7) {\n-          k = (QX32 & 127);\n-          tdigit[0] += __bid_convert_table[j][k][0];\n-          tdigit[1] += __bid_convert_table[j][k][1];\n-          if (tdigit[0] >= 100000000) {\n-            tdigit[0] -= 100000000;\n-            tdigit[1]++;\n-          }\n-        }\n-\n-        if (tdigit[1] >= 100000000) {\n-          tdigit[1] -= 100000000;\n-          if (tdigit[1] >= 100000000)\n-            tdigit[1] -= 100000000;\n-        }\n-\n-        digit = tdigit[0];\n-        if (!digit && !tdigit[1])\n-          nzeros += 16;\n-        else {\n-          if (!digit) {\n-            nzeros += 8;\n-            digit = tdigit[1];\n-          }\n-          // decompose digit\n-          PD = (UINT64) digit *0x068DB8BBull;\n-          digit_h = (UINT32) (PD >> 40);\n-          digit_low = digit - digit_h * 10000;\n-\n-          if (!digit_low)\n-            nzeros += 4;\n-          else\n-            digit_h = digit_low;\n-\n-          if (!(digit_h & 1))\n-            nzeros +=\n-              3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n-                            (digit_h & 7));\n-        }\n-\n-        if (nzeros) {\n-          // get P*(2^M[extra_digits])/10^extra_digits\n-          __mul_128x128_full (Qh, Ql, CQ, __bid_reciprocals10_128[nzeros]);\n-\n-          //now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n-          amount = __bid_recip_scale[nzeros];\n-          __shr_128 (CQ, Qh, amount);\n-        }\n-        diff_expon += nzeros;\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n \n       }\n     }\n-    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n-                pfpsf);\n+    get_BID128(&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n     BID_RETURN (res);\n   }\n #endif\n \n-  if (diff_expon >= 0) {\n+if (diff_expon >= 0) {\n #ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n     // rounding\n     // 2*CA4 - CY\n     CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n     CA4r.w[0] = CA4.w[0] + CA4.w[0];\n     __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n     CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n-\n     D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n     carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n-\n     CQ.w[0] += carry64;\n     if (CQ.w[0] < carry64)\n       CQ.w[1]++;\n-#else\n-#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+    break;\n+  case ROUNDING_TIES_AWAY:\n     // rounding\n     // 2*CA4 - CY\n     CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n     CA4r.w[0] = CA4.w[0] + CA4.w[0];\n     __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n     CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n-\n     D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n     carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n-\n     CQ.w[0] += carry64;\n     if (CQ.w[0] < carry64)\n       CQ.w[1]++;\n-#else\n-    rmode = rnd_mode;\n-    if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n-      rmode = 3 - rmode;\n-    switch (rmode) {\n-    case ROUNDING_TO_NEAREST: // round to nearest code\n-      // rounding\n-      // 2*CA4 - CY\n-      CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n-      CA4r.w[0] = CA4.w[0] + CA4.w[0];\n-      __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n-      CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n-      D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n-      carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n-      CQ.w[0] += carry64;\n-      if (CQ.w[0] < carry64)\n-        CQ.w[1]++;\n-      break;\n-    case ROUNDING_TIES_AWAY:\n-      // rounding\n-      // 2*CA4 - CY\n-      CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n-      CA4r.w[0] = CA4.w[0] + CA4.w[0];\n-      __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n-      CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n-      D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n-      carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n-      CQ.w[0] += carry64;\n-      if (CQ.w[0] < carry64)\n-        CQ.w[1]++;\n-      break;\n-    case ROUNDING_DOWN:\n-    case ROUNDING_TO_ZERO:\n-      break;\n-    default: // rounding up\n-      CQ.w[0]++;\n-      if (!CQ.w[0])\n-        CQ.w[1]++;\n-      break;\n-    }\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n+  }\n #endif\n #endif\n \n-  } else {\n+} else {\n #ifdef SET_STATUS_FLAGS\n-    if (CA4.w[0] || CA4.w[1]) {\n-      // set status flags\n-      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n-    }\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n #endif\n+  handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n+\t\t     CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+  BID_RETURN (res);\n \n-    handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n-                       CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n-    BID_RETURN (res);\n+}\n \n-  }\n+get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n+}\n \n-  get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n-  BID_RETURN (res);\n+\n+BID128_FUNCTION_ARGTYPE1_ARG128 (bid128dq_div, UINT64, x, y)\n+     UINT256 CA4, CA4r, P256;\n+     UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n+     UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, valid_y,\n+       PD;\n+     int_float fx, fy, f64;\n+     UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+     int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+       digits_q, amount;\n+     int nzeros, i, j, k, d5;\n+     unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n+\n+valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);\n+\n+\t// unpack arguments, check for NaN or Infinity\n+CX.w[1] = 0;\n+if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], x)) {\n+#ifdef SET_STATUS_FLAGS\n+if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // test if x is NaN\n+if ((x & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+  if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);\n+  __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);\n+  res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);\n+  BID_RETURN (res);\n+}\n+\t   // x is Infinity?\n+if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if y is Inf.\n+  if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+    // return NaN \n+  {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {\n+  // otherwise return +/-Inf\n+  res.w[1] =\n+    ((x ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+  }\n+}\n+\t   // x is 0\n+if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) {\n+  if ((!CY.w[0]) && !(CY.w[1] & 0x0001ffffffffffffull)) {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // x=y=0, return NaN\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // return 0\n+  res.w[1] = (x ^ y.w[1]) & 0x8000000000000000ull;\n+  exponent_x = exponent_x - exponent_y + (DECIMAL_EXPONENT_BIAS_128<<1) - DECIMAL_EXPONENT_BIAS;\n+  if (exponent_x > DECIMAL_MAX_EXPON_128)\n+    exponent_x = DECIMAL_MAX_EXPON_128;\n+  else if (exponent_x < 0)\n+    exponent_x = 0;\n+  res.w[1] |= (((UINT64) exponent_x) << 49);\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+}\n+exponent_x += (DECIMAL_EXPONENT_BIAS_128 - DECIMAL_EXPONENT_BIAS);\n+\n+if (!valid_y) {\n+  // y is Inf. or NaN\n+\n+  // test if y is NaN\n+  if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    res.w[1] = CY.w[1] & QUIET_MASK64;\n+    res.w[0] = CY.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res.w[1] = sign_x ^ sign_y;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n+  res.w[1] =\n+    ((x ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+  res.w[0] = 0;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 33;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  if (!CR.w[1] && !CR.w[0]) {\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+\t\tpfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  }\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  ed2 = 34 - digits_q;\n+  T128.w[0] = power10_table_128[ed2].w[0];\n+  T128.w[1] = power10_table_128[ed2].w[1];\n+  __mul_128x128_to_256 (CA4, CR, T128);\n+  diff_expon = diff_expon - ed2;\n+  __mul_128x128_low (CQ, CQ, T128);\n+\n+}\n+\n+__div_256_by_128 (&CQ, &CA4, CY);\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+    //printf(\"ed2=%d,nz=%d,a=%d,CQ=\"LX16\",\"LX16\", RH=\"LX16\", RL=\"LX16\"\\n\",ed2,nzeros,amount,CQ.w[1],CQ.w[0],reciprocals10_128[nzeros].w[1],reciprocals10_128[nzeros].w[0]);fflush(stdout);\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n+      if (d5 < nzeros)\n+\tnzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      //T128 = reciprocals10_128[17];\n+      T128.w[0] = 0x44909befeb9fad49ull;\n+      T128.w[1] = 0x000b877aa3236a4bull;\n+      __mul_128x128_to_256 (P256, CQ, T128);\n+      //amount = recip_scale[17];\n+      Q_high = (P256.w[2] >> 44) | (P256.w[3] << (64 - 44));\n+      Q_low = CQ.w[0] - Q_high * 100000000000000000ull;\n+\n+      if (!Q_low) {\n+\tdiff_expon += 17;\n+\n+\ttdigit[0] = Q_high & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_high >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  //printf(\"i=%d, nz=%d, digit=%d (%d, %016I64x %016I64x)\\n\",i,nzeros,digit_h,digit,PD,digit_h);fflush(stdout);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  __mul_64x64_to_128 (CQ, Q_high, reciprocals10_64[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n+\t  amount = short_recip_scale[nzeros];\n+\t  CQ.w[0] = CQ.w[1] >> amount;\n+\t} else\n+\t  CQ.w[0] = Q_high;\n+\tCQ.w[1] = 0;\n+\n+\tdiff_expon += nzeros;\n+      } else {\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  //printf(\"i=%d, nz=%d, digit=%d (%d, %016I64x %016I64x)\\n\",i,nzeros,digit_h,digit,PD,digit_h);fflush(stdout);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n+\n+      }\n+    }\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+\t\tpfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  }\n+#endif\n+\n+if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n+  }\n+#endif\n+#endif\n+\n+} else {\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#endif\n+  handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n+\t\t     CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+  BID_RETURN (res);\n+}\n+\n+get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n+\n+}\n+\n+\n+BID128_FUNCTION_ARG128_ARGTYPE2 (bid128qd_div, x, UINT64, y)\n+     UINT256 CA4, CA4r, P256;\n+     UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n+     UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, PD,\n+       valid_y;\n+     int_float fx, fy, f64;\n+     UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+     int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+       digits_q, amount;\n+     int nzeros, i, j, k, d5, rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n+\n+\n+valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], y);\n+\t// unpack arguments, check for NaN or Infinity\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    // test if x is NaN\n+if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+  if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull ||\t// sNaN\n+      (y & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[1] = (CX.w[1]) & QUIET_MASK64;\n+  res.w[0] = CX.w[0];\n+  BID_RETURN (res);\n+}\n+    // x is Infinity?\n+if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if y is Inf. \n+  if (((y & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+    // return NaN \n+  {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is NaN?\n+  if (((y & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n+    // return NaN \n+  {\n+    // return +/-Inf\n+    res.w[1] = ((x.w[1] ^ y) & 0x8000000000000000ull) |\n+      0x7800000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+}\n+    // x is 0\n+if ((y & 0x7800000000000000ull) < 0x7800000000000000ull) {\n+\tif (!CY.w[0]) {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // x=y=0, return NaN\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // return 0\n+  res.w[1] = (x.w[1] ^ y) & 0x8000000000000000ull;\n+  exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+  if (exponent_x > DECIMAL_MAX_EXPON_128)\n+    exponent_x = DECIMAL_MAX_EXPON_128;\n+  else if (exponent_x < 0)\n+    exponent_x = 0;\n+  res.w[1] |= (((UINT64) exponent_x) << 49);\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+}\n+CY.w[1] = 0;\n+if (!valid_y) {\n+  // y is Inf. or NaN\n+\n+  // test if y is NaN\n+  if ((y & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (CY.w[0] & 0x0003ffffffffffffull);\n+  __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);\n+  res.w[1] |= ((CY.w[0]) & 0xfc00000000000000ull);\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n+    // return +/-0\n+    res.w[1] = ((x.w[1] ^ y) & 0x8000000000000000ull);\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // y is 0\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  res.w[1] = (sign_x ^ sign_y) | INFINITY_MASK64;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 33;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  if (!CR.w[1] && !CR.w[0]) {\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+\t\tpfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  }\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  ed2 = 34 - digits_q;\n+  T128.w[0] = power10_table_128[ed2].w[0];\n+  T128.w[1] = power10_table_128[ed2].w[1];\n+  __mul_128x128_to_256 (CA4, CR, T128);\n+  diff_expon = diff_expon - ed2;\n+  __mul_128x128_low (CQ, CQ, T128);\n+\n+}\n+\n+__div_256_by_128 (&CQ, &CA4, CY);\n+\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n+      if (d5 < nzeros)\n+\tnzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      //T128 = reciprocals10_128[17];\n+      T128.w[0] = 0x44909befeb9fad49ull;\n+      T128.w[1] = 0x000b877aa3236a4bull;\n+      __mul_128x128_to_256 (P256, CQ, T128);\n+      //amount = recip_scale[17];\n+      Q_high = (P256.w[2] >> 44) | (P256.w[3] << (64 - 44));\n+      Q_low = CQ.w[0] - Q_high * 100000000000000000ull;\n+\n+      if (!Q_low) {\n+\tdiff_expon += 17;\n+\n+\ttdigit[0] = Q_high & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_high >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  __mul_64x64_to_128 (CQ, Q_high, reciprocals10_64[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n+\t  amount = short_recip_scale[nzeros];\n+\t  CQ.w[0] = CQ.w[1] >> amount;\n+\t} else\n+\t  CQ.w[0] = Q_high;\n+\tCQ.w[1] = 0;\n+\n+\tdiff_expon += nzeros;\n+      } else {\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n+\n+      }\n+    }\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  }\n+#endif\n+\n+if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n+  }\n+#endif\n+#endif\n+\n+} else {\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#endif\n+  handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n+\t\t     CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+  BID_RETURN (res);\n+\n+}\n+\n+get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n \n }"}, {"sha": "1d0ffb128ed42e4793c5eed4cc2ef545e9b66220", "filename": "libgcc/config/libbid/bid128_fma.c", "status": "modified", "additions": 1734, "deletions": 677, "changes": 2411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "196e1a0c545c1330f5cba4a2afc70e92f8a34434", "filename": "libgcc/config/libbid/bid128_logb.c", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -29,58 +29,35 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define BID_128RES\n #include \"bid_internal.h\"\n \n-BID128_FUNCTION_ARG1(__bid128_logb, x)\n+BID128_FUNCTION_ARG1_NORND_CUSTOMRESTYPE(int, bid128_logb, x)\n \n-  UINT128 CX, L, res;\n-  UINT64 sign_x, sign_e, logb_sign;\n+  UINT128 CX;\n+  UINT64 sign_x;\n   SINT64 D;\n   int_float f64, fx;\n   int exponent_x, bin_expon_cx, digits;\n \n   if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n-    res.w[1] = x.w[1];\n-    res.w[0] = x.w[0];\n-    // x is Infinity?\n-    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      if ((x.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)\n-        // +/-Inf, return Inf\n-        res.w[1] = 0x7800000000000000ull;\n-      BID_RETURN (res);\n-    }\n-    // x is 0 otherwise\n-\n #ifdef SET_STATUS_FLAGS\n-    // set status flags\n-    __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-    res.w[1] = 0xf800000000000000ull;\n-    res.w[0] = 0;\n-    BID_RETURN (res);\n+    BID_RETURN_VAL (0x80000000);\n   }\n   // find number of digits in coefficient\n   // 2^64\n   f64.i = 0x5f800000;\n   // fx ~ CX\n   fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n   bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n-  digits = __bid_estimate_decimal_digits[bin_expon_cx];\n-  // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n-  D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n-  if (D > 0\n-      || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+  digits = estimate_decimal_digits[bin_expon_cx];\n+  // scale = 38-estimate_decimal_digits[bin_expon_cx];\n+  D = CX.w[1] - power10_index_binexp_128[bin_expon_cx].w[1];\n+  if (D > 0 || (!D && CX.w[0] >= power10_index_binexp_128[bin_expon_cx].w[0])) {\n     digits++;\n+  }\n \n   exponent_x = exponent_x - DECIMAL_EXPONENT_BIAS_128 - 1 + digits;\n \n-  // extract sign and absolute value from exponent_x\n-  sign_e = ((SINT32) exponent_x) >> 31;\n-  exponent_x = (exponent_x + sign_e) ^ sign_e;\n-\n-  L.w[0] = exponent_x;\n-  L.w[1] = 0;\n-  logb_sign = sign_e << 63;\n-\n-  get_BID128_very_fast (&res, logb_sign, DECIMAL_EXPONENT_BIAS_128, L);\n-  BID_RETURN (res);\n+  BID_RETURN_VAL (exponent_x);\n \n }"}, {"sha": "a735a6b0a869d79c1fcfc9a08855e5e185ecaa75", "filename": "libgcc/config/libbid/bid128_minmax.c", "status": "modified", "additions": 523, "deletions": 330, "changes": 853, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -35,12 +35,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_minnum (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+bid128_minnum (UINT128 * pres, UINT128 * px,\n+\t       UINT128 * py _EXC_FLAGS_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n UINT128\n-__bid128_minnum (UINT128 x, UINT128 y) {\n+bid128_minnum (UINT128 x, UINT128 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -49,31 +50,101 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n   UINT128 sig_x, sig_y;\n   UINT192 sig_n_prime192;\n   UINT256 sig_n_prime256;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+  char x_is_zero = 0, y_is_zero = 0;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n-  // NaN (CASE1)\n-  // if x is NAN, then return y\n-  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+\n+  // check for non-canonical x\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    x.w[1] = x.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (x.w[0] > 0x38c15b09ffffffffull))) {\n+      x.w[1] = x.w[1] & 0xffffc00000000000ull;\n+      x.w[0] = 0x0ull;\n     }\n-    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN \n-      // set invalid flag \n-      ; // *pfpsf |= INVALID_EXCEPTION; \n-      // return quiet (y) \n-      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull; \n+  } else if ((x.w[1] & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+    x.w[1] = x.w[1] & (MASK_SIGN | MASK_INF);\n+    x.w[0] = 0x0ull;\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      x.w[1] = (x.w[1] & MASK_SIGN) | ((x.w[1] << 2) & MASK_EXP);\n+      x.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((x.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((x.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && x.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tx.w[1] = (x.w[1] & MASK_SIGN) | (x.w[1] & MASK_EXP);\n+\tx.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n     }\n-    res = y;\n-    BID_RETURN (res);\n   }\n-  // if y is NAN, then return x\n-  else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  // check for non-canonical y\n+  if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+    y.w[1] = y.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((y.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((y.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (y.w[0] > 0x38c15b09ffffffffull))) {\n+      y.w[1] = y.w[1] & 0xffffc00000000000ull;\n+      y.w[0] = 0x0ull;\n+    }\n+  } else if ((y.w[1] & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+    y.w[1] = y.w[1] & (MASK_SIGN | MASK_INF);\n+    y.w[0] = 0x0ull;\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      y.w[1] = (y.w[1] & MASK_SIGN) | ((y.w[1] << 2) & MASK_EXP);\n+      y.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((y.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((y.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && y.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\ty.w[1] = (y.w[1] & MASK_SIGN) | (y.w[1] & MASK_EXP);\n+\ty.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x.w[1] = x.w[1] & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n+    }\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y.w[1] = y.w[1] & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -98,47 +169,21 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n   sig_x.w[0] = x.w[0];\n   exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n \n-  // CHECK IF X IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n-      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_x = 1;\n-  else\n-    non_canon_x = 0;\n-\n   // CONVERT Y\n   exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n   sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n   sig_y.w[0] = y.w[0];\n \n-  // CHECK IF Y IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n-      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_y = 1;\n-  else\n-    non_canon_y = 0;\n-\n   // ZERO (CASE4)\n   // some properties:\n   //    (+ZERO == -ZERO) => therefore ignore the sign\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => ignore the exponent \n   //    field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+  if ((sig_x.w[1] == 0) && (sig_x.w[0] == 0)) {\n     x_is_zero = 1;\n   }\n-  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+  if ((sig_y.w[1] == 0) && (sig_y.w[0] == 0)) {\n     y_is_zero = 1;\n   }\n \n@@ -166,9 +211,9 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n   //    the significands\n   if (exp_y == exp_x) {\n     res = (((sig_x.w[1] > sig_y.w[1])\n-            || (sig_x.w[1] == sig_y.w[1]\n-                && sig_x.w[0] >= sig_y.w[0])) ^ ((x.w[1] & MASK_SIGN) ==\n-                                                 MASK_SIGN)) ? y : x;\n+\t    || (sig_x.w[1] == sig_y.w[1]\n+\t\t&& sig_x.w[0] >= sig_y.w[0])) ^ ((x.w[1] & MASK_SIGN) ==\n+\t\t\t\t\t\t MASK_SIGN)) ? y : x;\n     BID_RETURN (res);\n   }\n   // if both components are either bigger or smaller, it is clear what \n@@ -187,33 +232,33 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n   diff = exp_x - exp_y;\n \n   // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n-  if (diff > 0) { // to simplify the loop below,\n+  if (diff > 0) {\t// to simplify the loop below,\n     // if exp_x is 33 greater than exp_y, no need for compensation\n     if (diff > 33) {\n       // difference cannot be greater than 10^33\n       res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? y : x;\n       BID_RETURN (res);\n     }\n-    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n-      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+    if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, ten2k128[diff - 20]);\n       // if postitive, return whichever significand is larger \n       // (converse if negative)\n       res = ((((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n-              || (sig_n_prime256.w[1] > sig_y.w[1])\n-              || (sig_n_prime256.w[1] == sig_y.w[1]\n-                  && sig_n_prime256.w[0] >\n-                  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n-                                  MASK_SIGN)) ? y : x;\n+\t      || (sig_n_prime256.w[1] > sig_y.w[1])\n+\t      || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t  && sig_n_prime256.w[0] >\n+\t\t  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n+\t\t\t\t  MASK_SIGN)) ? y : x;\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_x);\n     // if postitive, return whichever significand is larger \n     // (converse if negative)\n     res =\n       (((sig_n_prime192.w[2] > 0) || (sig_n_prime192.w[1] > sig_y.w[1])\n-        || (sig_n_prime192.w[1] == sig_y.w[1]\n-            && sig_n_prime192.w[0] >\n-            sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? y : x;\n+\t|| (sig_n_prime192.w[1] == sig_y.w[1]\n+\t    && sig_n_prime192.w[0] >\n+\t    sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? y : x;\n     BID_RETURN (res);\n   }\n   diff = exp_y - exp_x;\n@@ -222,26 +267,29 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n     res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n     BID_RETURN (res);\n   }\n-  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+  if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n     // adjust the y significand upwards\n-    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, ten2k128[diff - 20]);\n     // if postitive, return whichever significand is larger \n     // (converse if negative)\n     res =\n       ((sig_n_prime256.w[3] != 0 || sig_n_prime256.w[2] != 0\n-        || (sig_n_prime256.w[1] > sig_x.w[1]\n-            || (sig_n_prime256.w[1] == sig_x.w[1]\n-                && sig_n_prime256.w[0] >\n-                sig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n-                                 MASK_SIGN)) ? x : y;\n+\t|| (sig_n_prime256.w[1] > sig_x.w[1]\n+\t    || (sig_n_prime256.w[1] == sig_x.w[1]\n+\t\t&& sig_n_prime256.w[0] >\n+\t\tsig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+\t\t\t\t MASK_SIGN)) ? x : y;\n     BID_RETURN (res);\n   }\n   // adjust the y significand upwards\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_y);\n   // if postitive, return whichever significand is larger (converse if negative)\n-  res = ((sig_n_prime192.w[2] != 0 || (sig_n_prime192.w[1] > sig_x.w[1] || \n-      (sig_n_prime192.w[1] == sig_x.w[1] && sig_n_prime192.w[0] > sig_x.w[0])))\n-       ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+  res =\n+    ((sig_n_prime192.w[2] != 0\n+      || (sig_n_prime192.w[1] > sig_x.w[1]\n+\t  || (sig_n_prime192.w[1] == sig_x.w[1]\n+\t      && sig_n_prime192.w[0] > sig_x.w[0])))\n+     ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n   BID_RETURN (res);\n }\n \n@@ -251,12 +299,13 @@ __bid128_minnum (UINT128 x, UINT128 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_minnum_mag (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+bid128_minnum_mag (UINT128 * pres, UINT128 * px,\n+\t\t   UINT128 * py _EXC_FLAGS_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n UINT128\n-__bid128_minnum_mag (UINT128 x, UINT128 y) {\n+bid128_minnum_mag (UINT128 x, UINT128 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -265,30 +314,100 @@ __bid128_minnum_mag (UINT128 x, UINT128 y) {\n   UINT128 sig_x, sig_y;\n   UINT192 sig_n_prime192;\n   UINT256 sig_n_prime256;\n-  char non_canon_x, non_canon_y;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n-  // NaN (CASE1)\n-  // if x is NAN, then return y\n-  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+\n+  // check for non-canonical x\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    x.w[1] = x.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (x.w[0] > 0x38c15b09ffffffffull))) {\n+      x.w[1] = x.w[1] & 0xffffc00000000000ull;\n+      x.w[0] = 0x0ull;\n     }\n-    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-      // set invalid flag\n-      ; // *pfpsf |= INVALID_EXCEPTION;\n-      // return quiet (y)\n-      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+  } else if ((x.w[1] & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+    x.w[1] = x.w[1] & (MASK_SIGN | MASK_INF);\n+    x.w[0] = 0x0ull;\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      x.w[1] = (x.w[1] & MASK_SIGN) | ((x.w[1] << 2) & MASK_EXP);\n+      x.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((x.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((x.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && x.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tx.w[1] = (x.w[1] & MASK_SIGN) | (x.w[1] & MASK_EXP);\n+\tx.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+  // check for non-canonical y\n+  if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+    y.w[1] = y.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((y.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((y.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (y.w[0] > 0x38c15b09ffffffffull))) {\n+      y.w[1] = y.w[1] & 0xffffc00000000000ull;\n+      y.w[0] = 0x0ull;\n+    }\n+  } else if ((y.w[1] & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+    y.w[1] = y.w[1] & (MASK_SIGN | MASK_INF);\n+    y.w[0] = 0x0ull;\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      y.w[1] = (y.w[1] & MASK_SIGN) | ((y.w[1] << 2) & MASK_EXP);\n+      y.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((y.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((y.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && y.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\ty.w[1] = (y.w[1] & MASK_SIGN) | (y.w[1] & MASK_EXP);\n+\ty.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x.w[1] = x.w[1] & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    // if y is NAN, then return x\n-    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y.w[1] = y.w[1] & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -302,7 +421,7 @@ __bid128_minnum_mag (UINT128 x, UINT128 y) {\n     // if x infinity, it has maximum magnitude.\n     // Check if magnitudes are equal.  If x is negative, return it.\n     res = ((x.w[1] & MASK_SIGN) == MASK_SIGN\n-           && (y.w[1] & MASK_INF) == MASK_INF) ? x : y;\n+\t   && (y.w[1] & MASK_INF) == MASK_INF) ? x : y;\n     BID_RETURN (res);\n   } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n     // x is finite, so if y is infinity, then x is less in magnitude\n@@ -314,120 +433,96 @@ __bid128_minnum_mag (UINT128 x, UINT128 y) {\n   sig_x.w[0] = x.w[0];\n   exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n \n-  // CHECK IF X IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n-      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_x = 1;\n-  else\n-    non_canon_x = 0;\n-\n   // CONVERT Y\n   exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n   sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n   sig_y.w[0] = y.w[0];\n \n-  // CHECK IF Y IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n-      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_y = 1;\n-  else\n-    non_canon_y = 0;\n-\n   // ZERO (CASE4)\n   // some properties:\n   //    (+ZERO == -ZERO) => therefore ignore the sign\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        therefore ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+  if ((sig_x.w[1] == 0) && (sig_x.w[0] == 0)) {\n     res = x;\n     BID_RETURN (res);\n   }\n-  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+  if ((sig_y.w[1] == 0) && (sig_y.w[0] == 0)) {\n     res = y;\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n   // check if exponents are the same and significands are the same\n   if (exp_y == exp_x && sig_x.w[1] == sig_y.w[1]\n       && sig_x.w[0] == sig_y.w[0]) {\n-    if (x.w[1] & 0x8000000000000000ull) { // x is negative\n+    if (x.w[1] & 0x8000000000000000ull) {\t// x is negative\n       res = x;\n       BID_RETURN (res);\n     } else {\n       res = y;\n       BID_RETURN (res);\n     }\n   } else if (((sig_x.w[1] > sig_y.w[1] || (sig_x.w[1] == sig_y.w[1]\n-               && sig_x.w[0] > sig_y.w[0])) && exp_x == exp_y)\n-             || ((sig_x.w[1] > sig_y.w[1]\n-                  || (sig_x.w[1] == sig_y.w[1]\n-                  && sig_x.w[0] >= sig_y.w[0]))\n-                 && exp_x > exp_y)) {\n+\t\t\t\t\t   && sig_x.w[0] > sig_y.w[0]))\n+\t      && exp_x == exp_y)\n+\t     || ((sig_x.w[1] > sig_y.w[1]\n+\t\t  || (sig_x.w[1] == sig_y.w[1]\n+\t\t      && sig_x.w[0] >= sig_y.w[0]))\n+\t\t && exp_x > exp_y)) {\n     // if both components are either bigger or smaller, it is clear what \n     // needs to be done; also if the magnitudes are equal\n     res = y;\n     BID_RETURN (res);\n   } else if (((sig_y.w[1] > sig_x.w[1] || (sig_y.w[1] == sig_x.w[1]\n-               && sig_y.w[0] > sig_x.w[0])) && exp_y == exp_x)\n-             || ((sig_y.w[1] > sig_x.w[1]\n-                  || (sig_y.w[1] == sig_x.w[1]\n-                  && sig_y.w[0] >= sig_x.w[0]))\n-                 && exp_y > exp_x)) {\n+\t\t\t\t\t   && sig_y.w[0] > sig_x.w[0]))\n+\t      && exp_y == exp_x)\n+\t     || ((sig_y.w[1] > sig_x.w[1]\n+\t\t  || (sig_y.w[1] == sig_x.w[1]\n+\t\t      && sig_y.w[0] >= sig_x.w[0]))\n+\t\t && exp_y > exp_x)) {\n     res = x;\n     BID_RETURN (res);\n   } else {\n-    ; // continue\n+    ;\t// continue\n   }\n   diff = exp_x - exp_y;\n   // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n-  if (diff > 0) { // to simplify the loop below,\n+  if (diff > 0) {\t// to simplify the loop below,\n     // if exp_x is 33 greater than exp_y, no need for compensation\n     if (diff > 33) {\n-      res = y; // difference cannot be greater than 10^33\n+      res = y;\t// difference cannot be greater than 10^33\n       BID_RETURN (res);\n     }\n-    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n-      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+    if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, ten2k128[diff - 20]);\n       // if positive, return whichever significand is larger \n       // (converse if negative)\n       if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n-          && sig_n_prime256.w[1] == sig_y.w[1]\n-          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n-        res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x; // if equal\n-        BID_RETURN (res);\n+\t  && sig_n_prime256.w[1] == sig_y.w[1]\n+\t  && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+\tres = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\t// if equal\n+\tBID_RETURN (res);\n       }\n       res = (((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n-             || (sig_n_prime256.w[1] > sig_y.w[1])\n-             || (sig_n_prime256.w[1] == sig_y.w[1]\n-                 && sig_n_prime256.w[0] > sig_y.w[0])) ? y : x;\n+\t     || (sig_n_prime256.w[1] > sig_y.w[1])\n+\t     || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t && sig_n_prime256.w[0] > sig_y.w[0])) ? y : x;\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_x);\n     // if positive, return whichever significand is larger \n     // (converse if negative)\n     if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n-        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+\t&& (sig_n_prime192.w[0] == sig_y.w[0])) {\n       // if = in magnitude, return +, (if possible)\n       res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n       BID_RETURN (res);\n     }\n     res = ((sig_n_prime192.w[2] > 0)\n-           || (sig_n_prime192.w[1] > sig_y.w[1])\n-           || (sig_n_prime192.w[1] == sig_y.w[1]\n-               && sig_n_prime192.w[0] > sig_y.w[0])) ? y : x;\n+\t   || (sig_n_prime192.w[1] > sig_y.w[1])\n+\t   || (sig_n_prime192.w[1] == sig_y.w[1]\n+\t       && sig_n_prime192.w[0] > sig_y.w[0])) ? y : x;\n     BID_RETURN (res);\n   }\n   diff = exp_y - exp_x;\n@@ -436,36 +531,37 @@ __bid128_minnum_mag (UINT128 x, UINT128 y) {\n     res = x;\n     BID_RETURN (res);\n   }\n-  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+  if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n     // adjust the y significand upwards\n-    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, ten2k128[diff - 20]);\n     // if positive, return whichever significand is larger \n     // (converse if negative)\n     if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n-        && sig_n_prime256.w[1] == sig_x.w[1]\n-        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+\t&& sig_n_prime256.w[1] == sig_x.w[1]\n+\t&& (sig_n_prime256.w[0] == sig_x.w[0])) {\n       // if = in magnitude, return +, (if possible)\n       res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n       BID_RETURN (res);\n     }\n     res = (sig_n_prime256.w[3] == 0 && sig_n_prime256.w[2] == 0\n-           && (sig_n_prime256.w[1] < sig_x.w[1]\n-               || (sig_n_prime256.w[1] == sig_x.w[1]\n-                   && sig_n_prime256.w[0] < sig_x.w[0]))) ? y : x;\n+\t   && (sig_n_prime256.w[1] < sig_x.w[1]\n+\t       || (sig_n_prime256.w[1] == sig_x.w[1]\n+\t\t   && sig_n_prime256.w[0] < sig_x.w[0]))) ? y : x;\n     BID_RETURN (res);\n   }\n   // adjust the y significand upwards\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_y);\n   // if positive, return whichever significand is larger (converse if negative)\n   if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_x.w[1]\n       && (sig_n_prime192.w[0] == sig_x.w[0])) {\n     // if = in magnitude, return +, if possible)\n     res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n     BID_RETURN (res);\n   }\n-  res = (sig_n_prime192.w[2] == 0 && (sig_n_prime192.w[1] < sig_x.w[1] || \n-      (sig_n_prime192.w[1] == sig_x.w[1] && \n-      sig_n_prime192.w[0] < sig_x.w[0]))) ? y : x;\n+  res = (sig_n_prime192.w[2] == 0\n+\t && (sig_n_prime192.w[1] < sig_x.w[1]\n+\t     || (sig_n_prime192.w[1] == sig_x.w[1]\n+\t\t && sig_n_prime192.w[0] < sig_x.w[0]))) ? y : x;\n   BID_RETURN (res);\n }\n \n@@ -475,12 +571,13 @@ __bid128_minnum_mag (UINT128 x, UINT128 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_maxnum (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+bid128_maxnum (UINT128 * pres, UINT128 * px,\n+\t       UINT128 * py _EXC_FLAGS_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n UINT128\n-__bid128_maxnum (UINT128 x, UINT128 y) {\n+bid128_maxnum (UINT128 x, UINT128 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -489,30 +586,101 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n   UINT128 sig_x, sig_y;\n   UINT192 sig_n_prime192;\n   UINT256 sig_n_prime256;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+  char x_is_zero = 0, y_is_zero = 0;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n-  // NaN (CASE1)\n-  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    // if x is NAN, then return y\n-    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+\n+  // check for non-canonical x\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    x.w[1] = x.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (x.w[0] > 0x38c15b09ffffffffull))) {\n+      x.w[1] = x.w[1] & 0xffffc00000000000ull;\n+      x.w[0] = 0x0ull;\n     }\n-    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-      // set invalid flag\n-      ; // *pfpsf |= INVALID_EXCEPTION;\n-      // return quiet (y)\n-      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+  } else if ((x.w[1] & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+    x.w[1] = x.w[1] & (MASK_SIGN | MASK_INF);\n+    x.w[0] = 0x0ull;\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      x.w[1] = (x.w[1] & MASK_SIGN) | ((x.w[1] << 2) & MASK_EXP);\n+      x.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((x.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((x.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && x.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tx.w[1] = (x.w[1] & MASK_SIGN) | (x.w[1] & MASK_EXP);\n+\tx.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+  // check for non-canonical y\n+  if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+    y.w[1] = y.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((y.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((y.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (y.w[0] > 0x38c15b09ffffffffull))) {\n+      y.w[1] = y.w[1] & 0xffffc00000000000ull;\n+      y.w[0] = 0x0ull;\n+    }\n+  } else if ((y.w[1] & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+    y.w[1] = y.w[1] & (MASK_SIGN | MASK_INF);\n+    y.w[0] = 0x0ull;\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      y.w[1] = (y.w[1] & MASK_SIGN) | ((y.w[1] << 2) & MASK_EXP);\n+      y.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((y.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((y.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && y.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\ty.w[1] = (y.w[1] & MASK_SIGN) | (y.w[1] & MASK_EXP);\n+\ty.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x.w[1] = x.w[1] & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    // if y is NAN, then return x\n-    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y.w[1] = y.w[1] & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -536,47 +704,21 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n   sig_x.w[0] = x.w[0];\n   exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n \n-  // CHECK IF X IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n-      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_x = 1;\n-  else\n-    non_canon_x = 0;\n-\n   // CONVERT Y\n   exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n   sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n   sig_y.w[0] = y.w[0];\n \n-  // CHECK IF Y IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n-      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_y = 1;\n-  else\n-    non_canon_y = 0;\n-\n   // ZERO (CASE4)\n   // some properties:\n   //    (+ZERO == -ZERO) => therefore ignore the sign\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        therefore ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+  if ((sig_x.w[1] == 0) && (sig_x.w[0] == 0)) {\n     x_is_zero = 1;\n   }\n-  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+  if ((sig_y.w[1] == 0) && (sig_y.w[0] == 0)) {\n     y_is_zero = 1;\n   }\n \n@@ -603,9 +745,9 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n   // if exponents are the same, then we have a simple comparison of \n   // the significands\n   if (exp_y == exp_x) {\n-    res = (((sig_x.w[1] > sig_y.w[1]) || (sig_x.w[1] == sig_y.w[1] && \n-        sig_x.w[0] >= sig_y.w[0])) ^ \n-        ((x.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+    res = (((sig_x.w[1] > sig_y.w[1]) || (sig_x.w[1] == sig_y.w[1] &&\n+\t\t\t\t\t  sig_x.w[0] >= sig_y.w[0])) ^\n+\t   ((x.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n     BID_RETURN (res);\n   }\n   // if both components are either bigger or smaller, it is clear what \n@@ -624,33 +766,33 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n   }\n   diff = exp_x - exp_y;\n   // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n-  if (diff > 0) { // to simplify the loop below,\n+  if (diff > 0) {\t// to simplify the loop below,\n     // if exp_x is 33 greater than exp_y, no need for compensation\n     if (diff > 33) {\n       // difference cannot be greater than 10^33\n       res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? x : y;\n       BID_RETURN (res);\n     }\n-    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n-      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+    if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, ten2k128[diff - 20]);\n       // if postitive, return whichever significand is larger \n       // (converse if negative)\n       res = ((((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n-              || (sig_n_prime256.w[1] > sig_y.w[1])\n-              || (sig_n_prime256.w[1] == sig_y.w[1]\n-                  && sig_n_prime256.w[0] >\n-                  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n-                                  MASK_SIGN)) ? x : y;\n+\t      || (sig_n_prime256.w[1] > sig_y.w[1])\n+\t      || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t  && sig_n_prime256.w[0] >\n+\t\t  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n+\t\t\t\t  MASK_SIGN)) ? x : y;\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_x);\n     // if postitive, return whichever significand is larger \n     // (converse if negative)\n     res =\n       (((sig_n_prime192.w[2] > 0) || (sig_n_prime192.w[1] > sig_y.w[1])\n-        || (sig_n_prime192.w[1] == sig_y.w[1]\n-            && sig_n_prime192.w[0] >\n-            sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+\t|| (sig_n_prime192.w[1] == sig_y.w[1]\n+\t    && sig_n_prime192.w[0] >\n+\t    sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n     BID_RETURN (res);\n   }\n   diff = exp_y - exp_x;\n@@ -659,27 +801,30 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n     res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n     BID_RETURN (res);\n   }\n-  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+  if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n     // adjust the y significand upwards\n-    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, ten2k128[diff - 20]);\n     // if postitive, return whichever significand is larger \n     // (converse if negative)\n     res =\n       ((sig_n_prime256.w[3] != 0 || sig_n_prime256.w[2] != 0\n-        || (sig_n_prime256.w[1] > sig_x.w[1]\n-            || (sig_n_prime256.w[1] == sig_x.w[1]\n-                && sig_n_prime256.w[0] >\n-                sig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) !=\n-                                 MASK_SIGN)) ? x : y;\n+\t|| (sig_n_prime256.w[1] > sig_x.w[1]\n+\t    || (sig_n_prime256.w[1] == sig_x.w[1]\n+\t\t&& sig_n_prime256.w[0] >\n+\t\tsig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) !=\n+\t\t\t\t MASK_SIGN)) ? x : y;\n     BID_RETURN (res);\n   }\n   // adjust the y significand upwards\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_y);\n   // if postitive, return whichever significand is larger (converse if negative)\n-  res = ((sig_n_prime192.w[2] != 0 || (sig_n_prime192.w[1] > sig_x.w[1] || \n-      (sig_n_prime192.w[1] == sig_x.w[1] && \n-      sig_n_prime192.w[0] > sig_x.w[0]))) ^ \n-      ((y.w[1] & MASK_SIGN) != MASK_SIGN)) ? x : y;\n+  res =\n+    ((sig_n_prime192.w[2] != 0\n+      || (sig_n_prime192.w[1] > sig_x.w[1]\n+\t  || (sig_n_prime192.w[1] == sig_x.w[1]\n+\t      && sig_n_prime192.w[0] >\n+\t      sig_x.w[0]))) ^ ((y.w[1] & MASK_SIGN) !=\n+\t\t\t       MASK_SIGN)) ? x : y;\n   BID_RETURN (res);\n }\n \n@@ -689,12 +834,13 @@ __bid128_maxnum (UINT128 x, UINT128 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_maxnum_mag (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+bid128_maxnum_mag (UINT128 * pres, UINT128 * px,\n+\t\t   UINT128 * py _EXC_FLAGS_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n UINT128\n-__bid128_maxnum_mag (UINT128 x, UINT128 y) {\n+bid128_maxnum_mag (UINT128 x, UINT128 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -703,30 +849,100 @@ __bid128_maxnum_mag (UINT128 x, UINT128 y) {\n   UINT128 sig_x, sig_y;\n   UINT192 sig_n_prime192;\n   UINT256 sig_n_prime256;\n-  char non_canon_x, non_canon_y;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n-  // NaN (CASE1)\n-  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    // if x is NAN, then return y\n-    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+\n+  // check for non-canonical x\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    x.w[1] = x.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (x.w[0] > 0x38c15b09ffffffffull))) {\n+      x.w[1] = x.w[1] & 0xffffc00000000000ull;\n+      x.w[0] = 0x0ull;\n     }\n-    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-      // set invalid flag\n-      ; // *pfpsf |= INVALID_EXCEPTION;\n-      // return quiet (y)\n-      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+  } else if ((x.w[1] & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+    x.w[1] = x.w[1] & (MASK_SIGN | MASK_INF);\n+    x.w[0] = 0x0ull;\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      x.w[1] = (x.w[1] & MASK_SIGN) | ((x.w[1] << 2) & MASK_EXP);\n+      x.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((x.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((x.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && x.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tx.w[1] = (x.w[1] & MASK_SIGN) | (x.w[1] & MASK_EXP);\n+\tx.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+  // check for non-canonical y\n+  if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+    y.w[1] = y.w[1] & 0xfe003fffffffffffull;\t// clear out G[6]-G[16]\n+    // check for non-canonical NaN payload\n+    if (((y.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t(((y.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull) &&\n+\t (y.w[0] > 0x38c15b09ffffffffull))) {\n+      y.w[1] = y.w[1] & 0xffffc00000000000ull;\n+      y.w[0] = 0x0ull;\n+    }\n+  } else if ((y.w[1] & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+    y.w[1] = y.w[1] & (MASK_SIGN | MASK_INF);\n+    y.w[0] = 0x0ull;\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[1] & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// G0_G1=11\n+      // non-canonical\n+      y.w[1] = (y.w[1] & MASK_SIGN) | ((y.w[1] << 2) & MASK_EXP);\n+      y.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      if ((y.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((y.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull &&\n+\t   y.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\ty.w[1] = (y.w[1] & MASK_SIGN) | (y.w[1] & MASK_EXP);\n+\ty.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x.w[1] = x.w[1] & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-    // if y is NAN, then return x\n-    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y.w[1] = y.w[1] & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -739,7 +955,7 @@ __bid128_maxnum_mag (UINT128 x, UINT128 y) {\n   if ((x.w[1] & MASK_INF) == MASK_INF) {\n     // if x infinity, it has maximum magnitude\n     res = ((x.w[1] & MASK_SIGN) == MASK_SIGN\n-           && (y.w[1] & MASK_INF) == MASK_INF) ? y : x;\n+\t   && (y.w[1] & MASK_INF) == MASK_INF) ? y : x;\n     BID_RETURN (res);\n   } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n     // x is finite, so if y is positive infinity, then x is less, return 0\n@@ -752,119 +968,95 @@ __bid128_maxnum_mag (UINT128 x, UINT128 y) {\n   sig_x.w[0] = x.w[0];\n   exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n \n-  // CHECK IF X IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n-      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_x = 1;\n-  else\n-    non_canon_x = 0;\n-\n   // CONVERT Y\n   exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n   sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n   sig_y.w[0] = y.w[0];\n \n-  // CHECK IF Y IS CANONICAL\n-  // 9999999999999999999999999999999999(decimal) = \n-  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n-  // [0, 10^34) is the 754r supported canonical range.  \n-  // If the value exceeds that, it is interpreted as 0.\n-  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n-      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n-      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n-    non_canon_y = 1;\n-  else\n-    non_canon_y = 0;\n-\n   // ZERO (CASE4)\n   // some properties:\n   //    (+ZERO == -ZERO) => therefore ignore the sign\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //         therefore ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+  if ((sig_x.w[1] == 0) && (sig_x.w[0] == 0)) {\n     res = y;\n     BID_RETURN (res);\n   }\n-  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+  if ((sig_y.w[1] == 0) && (sig_y.w[0] == 0)) {\n     res = x;\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n   if (exp_y == exp_x && sig_x.w[1] == sig_y.w[1]\n       && sig_x.w[0] == sig_y.w[0]) {\n     // check if exponents are the same and significands are the same\n-    if (x.w[1] & 0x8000000000000000ull) { // x is negative\n+    if (x.w[1] & 0x8000000000000000ull) {\t// x is negative\n       res = y;\n       BID_RETURN (res);\n     } else {\n       res = x;\n       BID_RETURN (res);\n     }\n   } else if (((sig_x.w[1] > sig_y.w[1] || (sig_x.w[1] == sig_y.w[1]\n-               && sig_x.w[0] > sig_y.w[0])) && exp_x == exp_y)\n-             || ((sig_x.w[1] > sig_y.w[1]\n-                  || (sig_x.w[1] == sig_y.w[1]\n-                  && sig_x.w[0] >= sig_y.w[0]))\n-                 && exp_x > exp_y)) {\n+\t\t\t\t\t   && sig_x.w[0] > sig_y.w[0]))\n+\t      && exp_x == exp_y)\n+\t     || ((sig_x.w[1] > sig_y.w[1]\n+\t\t  || (sig_x.w[1] == sig_y.w[1]\n+\t\t      && sig_x.w[0] >= sig_y.w[0]))\n+\t\t && exp_x > exp_y)) {\n     // if both components are either bigger or smaller, it is clear what \n     // needs to be done; also if the magnitudes are equal\n     res = x;\n     BID_RETURN (res);\n   } else if (((sig_y.w[1] > sig_x.w[1] || (sig_y.w[1] == sig_x.w[1]\n-               && sig_y.w[0] > sig_x.w[0])) && exp_y == exp_x)\n-             || ((sig_y.w[1] > sig_x.w[1]\n-                  || (sig_y.w[1] == sig_x.w[1]\n-                  && sig_y.w[0] >= sig_x.w[0]))\n-                 && exp_y > exp_x)) {\n+\t\t\t\t\t   && sig_y.w[0] > sig_x.w[0]))\n+\t      && exp_y == exp_x)\n+\t     || ((sig_y.w[1] > sig_x.w[1]\n+\t\t  || (sig_y.w[1] == sig_x.w[1]\n+\t\t      && sig_y.w[0] >= sig_x.w[0]))\n+\t\t && exp_y > exp_x)) {\n     res = y;\n     BID_RETURN (res);\n   } else {\n-    ;        // continue\n+    ;\t// continue\n   }\n   diff = exp_x - exp_y;\n   // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n-  if (diff > 0) { // to simplify the loop below,\n+  if (diff > 0) {\t// to simplify the loop below,\n     // if exp_x is 33 greater than exp_y, no need for compensation\n     if (diff > 33) {\n-      res = x; // difference cannot be greater than 10^33\n+      res = x;\t// difference cannot be greater than 10^33\n       BID_RETURN (res);\n     }\n-    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n-      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+    if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, ten2k128[diff - 20]);\n       // if postitive, return whichever significand is larger \n       // (converse if negative)\n       if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n-          && sig_n_prime256.w[1] == sig_y.w[1]\n-          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n-        res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y; // if equal\n-        BID_RETURN (res);\n+\t  && sig_n_prime256.w[1] == sig_y.w[1]\n+\t  && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+\tres = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\t// if equal\n+\tBID_RETURN (res);\n       }\n       res = (((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n-             || (sig_n_prime256.w[1] > sig_y.w[1])\n-             || (sig_n_prime256.w[1] == sig_y.w[1]\n-                 && sig_n_prime256.w[0] > sig_y.w[0])) ? x : y;\n+\t     || (sig_n_prime256.w[1] > sig_y.w[1])\n+\t     || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t && sig_n_prime256.w[0] > sig_y.w[0])) ? x : y;\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_x);\n     // if postitive, return whichever significand is larger (converse if negative)\n     if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n-        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+\t&& (sig_n_prime192.w[0] == sig_y.w[0])) {\n       // if equal, return positive magnitude\n       res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n       BID_RETURN (res);\n     }\n     res = ((sig_n_prime192.w[2] > 0)\n-           || (sig_n_prime192.w[1] > sig_y.w[1])\n-           || (sig_n_prime192.w[1] == sig_y.w[1]\n-               && sig_n_prime192.w[0] > sig_y.w[0])) ? x : y;\n+\t   || (sig_n_prime192.w[1] > sig_y.w[1])\n+\t   || (sig_n_prime192.w[1] == sig_y.w[1]\n+\t       && sig_n_prime192.w[0] > sig_y.w[0])) ? x : y;\n     BID_RETURN (res);\n   }\n   diff = exp_y - exp_x;\n@@ -873,35 +1065,36 @@ __bid128_maxnum_mag (UINT128 x, UINT128 y) {\n     res = y;\n     BID_RETURN (res);\n   }\n-  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+  if (diff > 19) {\t//128 by 128 bit multiply -> 256 bits\n     // adjust the y significand upwards\n-    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, ten2k128[diff - 20]);\n     // if postitive, return whichever significand is larger \n     // (converse if negative)\n     if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n-        && sig_n_prime256.w[1] == sig_x.w[1]\n-        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+\t&& sig_n_prime256.w[1] == sig_x.w[1]\n+\t&& (sig_n_prime256.w[0] == sig_x.w[0])) {\n       // if equal, return positive (if possible)\n       res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n       BID_RETURN (res);\n     }\n     res = (sig_n_prime256.w[3] == 0 && sig_n_prime256.w[2] == 0\n-           && (sig_n_prime256.w[1] < sig_x.w[1]\n-               || (sig_n_prime256.w[1] == sig_x.w[1]\n-                   && sig_n_prime256.w[0] < sig_x.w[0]))) ? x : y;\n+\t   && (sig_n_prime256.w[1] < sig_x.w[1]\n+\t       || (sig_n_prime256.w[1] == sig_x.w[1]\n+\t\t   && sig_n_prime256.w[0] < sig_x.w[0]))) ? x : y;\n     BID_RETURN (res);\n   }\n   // adjust the y significand upwards\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[diff], sig_y);\n   // if postitive, return whichever significand is larger (converse if negative)\n   if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_x.w[1]\n       && (sig_n_prime192.w[0] == sig_x.w[0])) {\n     // if equal, return positive (if possible)\n     res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n     BID_RETURN (res);\n   }\n-  res = (sig_n_prime192.w[2] == 0 && (sig_n_prime192.w[1] < sig_x.w[1] || \n-      (sig_n_prime192.w[1] == sig_x.w[1] && \n-      sig_n_prime192.w[0] < sig_x.w[0]))) ? x : y;\n+  res = (sig_n_prime192.w[2] == 0\n+\t && (sig_n_prime192.w[1] < sig_x.w[1]\n+\t     || (sig_n_prime192.w[1] == sig_x.w[1]\n+\t\t && sig_n_prime192.w[0] < sig_x.w[0]))) ? x : y;\n   BID_RETURN (res);\n }"}, {"sha": "5a60aed98be54988f1c451dadbd0576371e2d2b0", "filename": "libgcc/config/libbid/bid128_mul.c", "status": "modified", "additions": 356, "deletions": 1732, "changes": 2088, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -30,1775 +30,399 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_mul (UINT128 * pres, UINT128 * px,\n-            UINT128 *\n-            py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-            _EXC_INFO_PARAM) {\n-  UINT128 x = *px, y = *py;\n-\n+bid64dq_mul (UINT64 * pres, UINT64 * px, UINT128 * py\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n #if !DECIMAL_GLOBAL_ROUNDING\n   unsigned int rnd_mode = *prnd_mode;\n-\n #endif\n #else\n-UINT128\n-__bid128_mul (UINT128 x,\n-            UINT128 y _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-            _EXC_INFO_PARAM) {\n-\n+UINT64\n+bid64dq_mul (UINT64 x, UINT128 y\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n #endif\n-  UINT128 res;\n-  UINT64 x_sign, y_sign, sign;\n-  UINT64 x_exp, y_exp;\n-\n-  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n-  // Note: C2.w[1], C2.w[0] represent y_signif_hi, y_signif_lo (all are UINT64)\n-  UINT64 tmp64, tmp64A;\n-  BID_UI64DOUBLE tmp1, tmp2;\n-  int x_nr_bits, y_nr_bits;\n-  int q1, q2, ind, shift;\n-  UINT128 C1, C2;\n-  UINT128 Cstar;  // C* represents up to 34 decimal digits ~ 113 bits\n-  UINT384 fstar;\n-  int q;\n-  UINT128 P128, R128; // for underflow path\n-  UINT192 P192, R192; // for underflow path\n-  UINT256 C, P256, R256;\n-  UINT384 P384;\n-  UINT512 P512;\n-  int incr_exp = 0; // for underflow path\n-  int incr_exp1 = 0; // for underflow path\n-  int tmp_fpa = 0;  // if possible underflow and q>=34, use to undo the rounding\n-  UINT64 C1_hi, C2_hi;\n-  UINT64 C1_lo, C2_lo;\n-  int is_inexact = 0;\n-  int is_midpoint_lt_even = 0, is_midpoint_gt_even = 0;\n-  int is_inexact_lt_midpoint = 0, is_inexact_gt_midpoint = 0;\n-  int is_midpoint_lt_even1 = 0, is_midpoint_gt_even1 = 0;\n-  int is_inexact_lt_midpoint1 = 0, is_inexact_gt_midpoint1 = 0;\n-  int is_overflow = 0;\n-  int no_underflow = 0;\n+  UINT64 res = 0xbaddbaddbaddbaddull;\n+  UINT128 x1;\n \n-  // unpack the arguments\n-  // unpack x\n-  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n-  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n-  C1_hi = x.w[1] & MASK_COEFF;\n-  C1_lo = x.w[0];\n-\n-  // unpack y\n-  y_sign = y.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n-  y_exp = y.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n-  C2_hi = y.w[1] & MASK_COEFF;\n-  C2_lo = y.w[0];\n-  sign = x_sign ^ y_sign;\n-\n-  // check for NaN or Infinity\n-  if (((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL)\n-      || ((y.w[1] & MASK_SPECIAL) == MASK_SPECIAL)) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64_to_bid128 (&x1, &x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid64qq_mul (&res, &x1, py\n+\t       _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t       _EXC_INFO_ARG);\n+#else\n+  x1 = bid64_to_bid128 (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res = bid64qq_mul (x1, y\n+\t\t     _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t     _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-    // x is special or y is special\n-    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n \n-        // return quiet (x)\n-        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = x.w[0];\n-      } else { // x is QNaN\n-        if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-          // set invalid flag\n-          *pfpsf |= INVALID_EXCEPTION;\n-        }\n-        // return x\n-        res.w[1] = x.w[1];\n-        res.w[0] = x.w[0];\n-      }\n-      BID_RETURN (res);\n-    } else if ((y.w[1] & MASK_NAN) == MASK_NAN) { // y is NAN\n-      if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid64qd_mul (UINT64 * pres, UINT128 * px, UINT64 * py\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+  UINT64 y = *py;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT64\n+bid64qd_mul (UINT128 x, UINT64 y\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 res = 0xbaddbaddbaddbaddull;\n+  UINT128 y1;\n \n-        // return quiet (y)\n-        res.w[1] = y.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = y.w[0];\n-      } else { // y is QNaN\n-        // return y\n-        res.w[1] = y.w[1];\n-        res.w[0] = y.w[0];\n-      }\n-      BID_RETURN (res);\n-    } else { // neither x nor y is NaN; at least one is infinity\n-      if ((x.w[1] & MASK_ANY_INF) == MASK_INF) { // x is infinity\n-        if (((y.w[1] & MASK_ANY_INF) == MASK_INF) || (C2_hi != 0x0ull)\n-            || (C2_lo != 0x0ull)) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64_to_bid128 (&y1, &y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid64qq_mul (&res, px, &y1\n+\t       _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t       _EXC_INFO_ARG);\n+#else\n+  y1 = bid64_to_bid128 (y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res = bid64qq_mul (x, y1\n+\t\t     _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t     _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-          // y is infinity OR y is finite \n-          // if same sign, return +inf otherwise return -inf\n-          if (!sign) {\n-            res.w[1] = 0x7800000000000000ull; // +inf\n-            res.w[0] = 0x0000000000000000ull;\n-          } else { // x and y are infinities of opposite signs\n-            res.w[1] = 0xf800000000000000ull; // -inf\n-            res.w[0] = 0x0000000000000000ull;\n-          }\n-        } else { // if y is 0\n-          // set invalid flag\n-          *pfpsf |= INVALID_EXCEPTION;\n \n-          // return QNaN Indefinite\n-          res.w[1] = 0x7c00000000000000ull;\n-          res.w[0] = 0x0000000000000000ull;\n-        }\n-      } else { // x is not NaN or infinity, so y must be infinity\n-        if ((C1_hi != 0x0ull) || (C1_lo != 0x0ull)) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid64qq_mul (UINT64 * pres, UINT128 * px, UINT128 * py\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+  UINT128 x = *px, y = *py;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT64\n+bid64qq_mul (UINT128 x, UINT128 y\n+\t     _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+#endif\n \n-          // x is finite\n-          // if same sign, return +inf otherwise return -inf\n-          if (!sign) {\n-            res.w[1] = 0x7800000000000000ull; // +inf\n-            res.w[0] = 0x0000000000000000ull;\n-          } else { // y and x are of opposite signs\n-            res.w[1] = 0xf800000000000000ull; // -inf\n-            res.w[0] = 0x0000000000000000ull;\n-          }\n-        } else { // if x is 0\n-          // set invalid flag\n-          *pfpsf |= INVALID_EXCEPTION;\n+  UINT128 z = { {0x0000000000000000ull, 0x5ffe000000000000ull}\n+  };\n+  UINT64 res = 0xbaddbaddbaddbaddull;\n+  UINT64 x_sign, y_sign, p_sign;\n+  UINT64 x_exp, y_exp, p_exp;\n+  int true_p_exp;\n+  UINT128 C1, C2;\n \n-          // return QNaN Indefinite\n-          res.w[1] = 0x7c00000000000000ull;\n-          res.w[0] = 0x0000000000000000ull;\n-        }\n+  BID_SWAP128 (z);\n+  // skip cases where at least one operand is NaN or infinity\n+  if (!(((x.w[HIGH_128W] & MASK_NAN) == MASK_NAN) ||\n+\t((y.w[HIGH_128W] & MASK_NAN) == MASK_NAN) ||\n+\t((x.w[HIGH_128W] & MASK_ANY_INF) == MASK_INF) ||\n+\t((y.w[HIGH_128W] & MASK_ANY_INF) == MASK_INF))) {\n+    // x, y are 0 or f but not inf or NaN => unpack the arguments and check\n+    // for non-canonical values\n+\n+    x_sign = x.w[HIGH_128W] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+    C1.w[1] = x.w[HIGH_128W] & MASK_COEFF;\n+    C1.w[0] = x.w[LOW_128W];\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[HIGH_128W] & 0x6000000000000000ull) ==\n+\t0x6000000000000000ull) {\n+      // G0_G1=11 => non-canonical\n+      x_exp = (x.w[HIGH_128W] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+      C1.w[1] = 0;\t// significand high\n+      C1.w[0] = 0;\t// significand low\n+    } else {\t// G0_G1 != 11\n+      x_exp = x.w[HIGH_128W] & MASK_EXP;\t// biased and shifted left 49 bits\n+      if (C1.w[1] > 0x0001ed09bead87c0ull ||\n+\t  (C1.w[1] == 0x0001ed09bead87c0ull &&\n+\t   C1.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tC1.w[1] = 0;\n+\tC1.w[0] = 0;\n+      } else {\t// canonical          \n+\t;\n       }\n-      BID_RETURN (res);\n-    }\n-  }\n-  // test for non-canonical values:\n-  // - values whose encoding begins with x00, x01, or x10 and whose\n-  //   coefficient is larger than 10^34 -1, or\n-  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n-  //   and infinitis were eliminated already this test is reduced to\n-  //   checking for x10x)\n-\n-  // test for non-canonical values of the argument x\n-  if ((((C1_hi > 0x0001ed09bead87c0ull) || \n-      ((C1_hi == 0x0001ed09bead87c0ull) && (C1_lo > 0x378d8e63ffffffffull))) && \n-      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n-    // check for the case where the exponent is shifted right by 2 bits!\n-    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n-      x_exp = (x.w[1] << 2) & MASK_EXP; // same position as for G[0]G[1] != 11\n     }\n-    x.w[1] = x.w[1] & 0x8000000000000000ull; // preserve the sign bit\n-    x.w[0] = 0;\n-    C1_hi = 0;\n-    C1_lo = 0;\n-  }\n-  // test for non-canonical values of the argument y\n-  if ((((C2_hi > 0x0001ed09bead87c0ull)\n-       || ((C2_hi == 0x0001ed09bead87c0ull)\n-           && (C2_lo > 0x378d8e63ffffffffull)))\n-      && ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n-      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n-\n-    // check for the case where the exponent is shifted right by 2 bits!\n-    if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n-      y_exp = (y.w[1] << 2) & MASK_EXP; // same position as for G[0]G[1] != 11\n-    }\n-    y.w[1] = y.w[1] & 0x8000000000000000ull; // preserve the sign bit\n-    y.w[0] = 0;\n-    C2_hi = 0;\n-    C2_lo = 0;\n-  }\n-  if (((C1_hi == 0x0ull) && (C1_lo == 0x0ull)) || ((C2_hi == 0x0ull)\n-      && (C2_lo == 0x0ull))) {\n-\n-    // x is 0 and y is not special OR y is 0 and x is not special\n-    // if same sign, return +0 otherwise return -0\n-    ind = (x_exp >> 49) + (y_exp >> 49) - 6176;\n-    if (ind < 0)\n-      ind = 0;\n-    if (ind > 0x2fff)\n-      ind = 0x2fff; // 6111 + 6176\n-    if ((x.w[1] & MASK_SIGN) == (y.w[1] & MASK_SIGN)) {\n-      res.w[1] = 0x0000000000000000ull | ((UINT64) ind << 49); // +0.0\n-      res.w[0] = 0x0000000000000000ull;\n-    } else { // opposite signs\n-      res.w[1] = 0x8000000000000000ull | ((UINT64) ind << 49); // -0.0\n-      res.w[0] = 0x0000000000000000ull;\n-    }\n-    BID_RETURN (res);\n-  } else { // x and y are not special and are not zero\n-    // unpack x\n-    C1.w[1] = C1_hi;\n-    C1.w[0] = C1_lo;\n-\n-    // q1 = nr. of decimal digits in x\n-    // determine first the nr. of bits in x\n-    if (C1.w[1] == 0) {\n-      if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n-        // split the 64-bit value in two 32-bit halves to avoid rounding errors\n-        if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n-          tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n-          x_nr_bits =\n-            33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-        } else { // x < 2^32\n-          tmp1.d = (double) (C1.w[0]); // exact conversion\n-          x_nr_bits =\n-            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-      }} else { // if x < 2^53\n-        tmp1.d = (double) C1.w[0]; // exact conversion\n-        x_nr_bits =\n-          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-    }} else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n-      tmp1.d = (double) C1.w[1]; // exact conversion\n-      x_nr_bits =\n-        65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-    } q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n-    if (q1 == 0) {\n-      q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n-      if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-          || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-          && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n-        q1++;\n-    }\n-    C2.w[1] = C2_hi;\n-    C2.w[0] = C2_lo;\n-    if (C2.w[1] == 0) {\n-      if (C2.w[0] >= 0x0020000000000000ull) { // y >= 2^53\n-        // split the 64-bit value in two 32-bit halves to avoid rounding errors\n-        if (C2.w[0] >= 0x0000000100000000ull) { // y >= 2^32\n-          tmp2.d = (double) (C2.w[0] >> 32); // exact conversion\n-          y_nr_bits =\n-            32 + ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-        } else { // y < 2^32\n-          tmp2.d = (double) C2.w[0]; // exact conversion\n-          y_nr_bits =\n-            ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-      }} else { // if y < 2^53\n-        tmp2.d = (double) C2.w[0]; // exact conversion\n-        y_nr_bits =\n-          ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-    }} else { // C2.w[1] != 0 => nr. bits = 64 + nr_bits (C2.w[1])\n-      tmp2.d = (double) C2.w[1]; // exact conversion\n-      y_nr_bits =\n-        64 + ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-    } q2 = __bid_nr_digits[y_nr_bits].digits;\n-    if (q2 == 0) {\n-      q2 = __bid_nr_digits[y_nr_bits].digits1;\n-      if (C2.w[1] > __bid_nr_digits[y_nr_bits].threshold_hi\n-          || (C2.w[1] == __bid_nr_digits[y_nr_bits].threshold_hi\n-          && C2.w[0] >= __bid_nr_digits[y_nr_bits].threshold_lo))\n-        q2++;\n-    }\n-    // the exact product has either q1 + q2 - 1 or q1 + q2 decimal digits\n-    // where 2 <= q1 + q2 <= 68\n-    // calculate C' = C1 * C2 and determine q\n-    C.w[3] = C.w[2] = C.w[1] = C.w[0] = 0;\n-    if (q1 + q2 <= 19) { // if 2 <= q1 + q2 <= 19, C' = C1 * C2 fits in 64 bits\n-      C.w[0] = C1.w[0] * C2.w[0];\n-\n-      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n-      if (C.w[0] < __bid_ten2k64[q1 + q2 - 1])\n-        q = q1 + q2 - 1; // q in [1, 18]\n-      else\n-        q = q1 + q2; // q in [2, 19]\n-      // length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n-    } else if (q1 + q2 == 20) { // C' = C1 * C2 fits in 64 or 128 bits\n-      // q1 <= 19 and q2 <= 19 so both C1 and C2 fit in 64 bits\n-      __mul_64x64_to_128MACH (C, C1.w[0], C2.w[0]);\n-\n-      // if C' < 10^(q1+q2-1) = 10^19 then q = q1+q2-1 = 19 else q = q1+q2 = 20\n-      if (C.w[1] == 0 && C.w[0] < __bid_ten2k64[19]) { // 19 = q1+q2-1\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n-        q = 19; // 19 = q1 + q2 - 1\n-      } else {\n-\n-        // if (C.w[1] == 0)\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        q = 20; // 20 = q1 + q2\n-      }\n-    } else if (q1 + q2 <= 38) { // 21 <= q1 + q2 <= 38\n-      // C' = C1 * C2 fits in 64 or 128 bits\n-      // (64 bits possibly, but only when q1 + q2 = 21 and C' has 20 digits)\n-      // at least one of C1, C2 has at most 19 decimal digits & fits in 64 bits\n-      if (q1 <= 19) {\n-        __mul_128x64_to_128 (C, C1.w[0], C2);\n-      } else { // q2 <= 19\n-        __mul_128x64_to_128 (C, C2.w[0], C1);\n-      }\n-\n-      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n-      if (C.w[1] < __bid_ten2k128[q1 + q2 - 21].w[1]\n-          || (C.w[1] == __bid_ten2k128[q1 + q2 - 21].w[1]\n-          && C.w[0] < __bid_ten2k128[q1 + q2 - 21].w[0])) {\n-\n-        // if (C.w[1] == 0) // q = 20, necessarily\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        q = q1 + q2 - 1; // q in [20, 37]\n-      } else {\n-\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        q = q1 + q2; // q in [21, 38]\n-      }\n-    } else if (q1 + q2 == 39) { // C' = C1 * C2 fits in 128 or 192 bits\n-      // both C1 and C2 fit in 128 bits (actually in 113 bits)\n-      // may replace this by 128x128_to192\n-      __mul_128x128_to_256 (C, C1, C2); // C.w[3] is 0\n-      // if C' < 10^(q1+q2-1) = 10^38 then q = q1+q2-1 = 38 else q = q1+q2 = 39\n-      if (C.w[2] == 0 && (C.w[1] < __bid_ten2k128[18].w[1] || \n-          (C.w[1] == __bid_ten2k128[18].w[1] && C.w[0] < __bid_ten2k128[18].w[0]))) { \n-          // 18 = 38 - 20 = q1+q2-1 - 20\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        q = 38; // 38 = q1 + q2 - 1\n-      } else {\n-\n-        // if (C.w[2] == 0)\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        q = 39; // 39 = q1 + q2\n-      }\n-    } else if (q1 + q2 <= 57) { // 40 <= q1 + q2 <= 57\n-      // C' = C1 * C2 fits in 128 or 192 bits\n-      // (128 bits possibly, but only when q1 + q2 = 40 and C' has 39 digits)\n-      // both C1 and C2 fit in 128 bits (actually in 113 bits); at most one\n-      // may fit in 64 bits\n-      if (C1.w[1] == 0) { // C1 fits in 64 bits\n-        // __mul_64x128_full (REShi64, RESlo128, A64, B128)\n-        __mul_64x128_full (C.w[2], C, C1.w[0], C2);\n-      } else if (C2.w[1] == 0) { // C2 fits in 64 bits\n-        // __mul_64x128_full (REShi64, RESlo128, A64, B128)\n-        __mul_64x128_full (C.w[2], C, C2.w[0], C1);\n-      } else { // both C1 and C2 require 128 bits\n-        // may use __mul_128x128_to_192 (C.w[2], C.w[0], C2.w[0], C1);\n-        __mul_128x128_to_256 (C, C1, C2); // C.w[3] = 0\n-      }\n-\n-      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n-      if (C.w[2] < __bid_ten2k256[q1 + q2 - 40].w[2]\n-          || (C.w[2] == __bid_ten2k256[q1 + q2 - 40].w[2]\n-          && (C.w[1] < __bid_ten2k256[q1 + q2 - 40].w[1]\n-              || (C.w[1] == __bid_ten2k256[q1 + q2 - 40].w[1]\n-              && C.w[0] < __bid_ten2k256[q1 + q2 - 40].w[0])))) {\n-\n-        // if (C.w[2] == 0) // q = 39, necessarily\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        q = q1 + q2 - 1; // q in [39, 56]\n-      } else {\n-\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        q = q1 + q2; // q in [40, 57]\n-      }\n-    } else if (q1 + q2 == 58) { // C' = C1 * C2 fits in 192 or 256 bits\n-      // both C1 and C2 fit in 128 bits (actually in 113 bits); at most one\n-      // may fit in 64 bits\n-      if (C1.w[1] == 0) { // C1 * C2 will fit in 192 bits\n-        __mul_64x128_full (C.w[2], C, C1.w[0], C2); // may use 64x128_to_192\n-      } else if (C2.w[1] == 0) { // C1 * C2 will fit in 192 bits\n-        __mul_64x128_full (C.w[2], C, C2.w[0], C1); // may use 64x128_to_192\n-      } else { // C1 * C2 will fit in 192 bits or in 256 bits\n-        __mul_128x128_to_256 (C, C1, C2);\n-      }\n-\n-      // if C' < 10^(q1+q2-1) = 10^57 then q = q1+q2-1 = 57 else q = q1+q2 = 58\n-      if (C.w[3] == 0 && (C.w[2] < __bid_ten2k256[18].w[2] || \n-          (C.w[2] == __bid_ten2k256[18].w[2] && (C.w[1] < __bid_ten2k256[18].w[1] || \n-          (C.w[1] == __bid_ten2k256[18].w[1] && C.w[0] < __bid_ten2k256[18].w[0]))))) {\n-          // 18 = 57 - 39 = q1+q2-1 - 39\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        q = 57; // 57 = q1 + q2 - 1\n-      } else {\n-\n-        // if (C.w[3] == 0)\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n-        q = 58; // 58 = q1 + q2\n-      }\n-    } else { // if 59 <= q1 + q2 <= 68\n-      // C' = C1 * C2 fits in 192 or 256 bits\n-      // (192 bits possibly, but only when q1 + q2 = 59 and C' has 58 digits)\n-      // both C1 and C2 fit in 128 bits (actually in 113 bits); none fits in\n-      // 64 bits\n-      // may use __mul_128x128_to_192 (C.w[2], C.w[0], C2.w[0], C1);\n-      __mul_128x128_to_256 (C, C1, C2); // C.w[3] = 0\n-      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n-      if (C.w[3] < __bid_ten2k256[q1 + q2 - 40].w[3]\n-          || (C.w[3] == __bid_ten2k256[q1 + q2 - 40].w[3]\n-          && (C.w[2] < __bid_ten2k256[q1 + q2 - 40].w[2]\n-              || (C.w[2] == __bid_ten2k256[q1 + q2 - 40].w[2]\n-              && (C.w[1] < __bid_ten2k256[q1 + q2 - 40].w[1]\n-                  || (C.w[1] == __bid_ten2k256[q1 + q2 - 40].w[1]\n-                  && C.w[0] < __bid_ten2k256[q1 + q2 - 40].w[0])))))) {\n-\n-        // if (C.w[3] == 0) // q = 58, necessarily\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n-        // else\n-        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n-        q = q1 + q2 - 1; // q in [58, 67]\n-      } else {\n-\n-        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n-        q = q1 + q2; // q in [59, 68]\n+    y_sign = y.w[HIGH_128W] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+    C2.w[1] = y.w[HIGH_128W] & MASK_COEFF;\n+    C2.w[0] = y.w[LOW_128W];\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[HIGH_128W] & 0x6000000000000000ull) ==\n+\t0x6000000000000000ull) {\n+      // G0_G1=11 => non-canonical\n+      y_exp = (y.w[HIGH_128W] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+      C2.w[1] = 0;\t// significand high\n+      C2.w[0] = 0;\t// significand low \n+    } else {\t// G0_G1 != 11\n+      y_exp = y.w[HIGH_128W] & MASK_EXP;\t// biased and shifted left 49 bits\n+      if (C2.w[1] > 0x0001ed09bead87c0ull ||\n+\t  (C2.w[1] == 0x0001ed09bead87c0ull &&\n+\t   C2.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\tC2.w[1] = 0;\n+\tC2.w[0] = 0;\n+      } else {\t// canonical\n+\t;\n       }\n     }\n-    if (((UINT64) q << 49) + x_exp + y_exp <\n-        ((UINT64) P34 << 49) + EXP_MIN + BIN_EXP_BIAS) {\n-\n-      // possible underflow\n-      // q + ex + ey < P34 + EMIN <=> q - P34 < EMIN - ex - ey <=> q - P34 < ind\n-      goto _underflow_path;\n-    }\n-    if (q <= 34) { // 2 <= q <= 34 the result is exact, and fits in 113 bits\n-      tmp64 = x_exp + y_exp;\n-      if (tmp64 > EXP_MAX + BIN_EXP_BIAS) { // possible overflow\n-        ind = (tmp64 - EXP_MAX - BIN_EXP_BIAS) >> 49;\n-        if (ind > 34 - q) { // overflow in all rounding modes\n-          // |res| >= 10^p * 10^emax = 10^(p-1) * 10^(emax+1)\n-          // assemble the result\n-          if (rnd_mode == ROUNDING_TO_NEAREST\n-              || rnd_mode == ROUNDING_TIES_AWAY) {\n-            res.w[1] = sign | 0x7800000000000000ull;\n-            res.w[0] = 0x0ull;\n-          } else if (rnd_mode == ROUNDING_DOWN) {\n-            if (sign) { // res = -inf\n-              res.w[1] = 0xf800000000000000ull;\n-              res.w[0] = 0x0ull;\n-            } else { // res = +MAXFP\n-              res.w[1] = 0x5fffed09bead87c0ull;\n-              res.w[0] = 0x378d8e63ffffffffull;\n-            }\n-          } else if (rnd_mode == ROUNDING_UP) {\n-            if (sign) { // res = -MAXFP\n-              res.w[1] = 0xdfffed09bead87c0ull;\n-              res.w[0] = 0x378d8e63ffffffffull;\n-            } else { // res = +inf\n-              res.w[1] = 0x7800000000000000ull;\n-              res.w[0] = 0x0ull;\n-            }\n-          } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n-            // |res| = (10^34 - 1) * 10^6111 = +MAXFP\n-            res.w[1] = sign | 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull;\n-          }\n-\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-\n-          // set the overflow flag\n-          *pfpsf |= OVERFLOW_EXCEPTION;\n-\n-          // is_overflow = 1;\n-          BID_RETURN (res);\n-        } else { // tmp64 > EXP_MAX + BIN_EXP_BIAS but \n-          // ind = ((tmp64-EXP_MAX-BIN_EXP_BIAS)>>49) <= 34 - q\n-          // the exponent will be the maximum exponent\n-          // multiply C by 10^ind; the result fits in 34 digits\n-          if (ind <= 19) { // multiply by __bid_ten2k64[ind]\n-            if (q <= 19) { // 64x64 -> 128\n-              __mul_64x64_to_128MACH (C, C.w[0], __bid_ten2k64[ind]);\n-            } else { // 128 x 64 -> 128\n-              // may optimize to multiply 64 x 128 -> 128\n-              __mul_64x128_full (tmp64, C, __bid_ten2k64[ind], C);\n-            }\n-          } else { // if 20 <= ind <= 32 multiply by __bid_ten2k128[ind - 20]\n-            // it must be that C.w[1] = 0, as C < 10^14\n-            // may optimize to multiply 64 x 128 -> 128\n-            __mul_64x128_full (tmp64, C, C.w[0], __bid_ten2k128[ind - 20]);\n-          }\n-          res.w[0] = C.w[0];\n-          res.w[1] = C.w[1];\n-          res.w[1] |= EXP_MAX; // EXP MAX\n-        }\n-      } else {\n-        res.w[0] = C.w[0];\n-        res.w[1] = C.w[1];\n-        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-      }\n-      res.w[1] |= sign;\n-    } else if (q <= 38) { // 35 <= q <= 38; exact coefficient fits in 128 bits\n-      // C = C + 1/2 * 10^x where the result C fits in 127 bits\n-      ind = q - 35;\n-      tmp64 = C.w[0];\n-      C.w[0] = C.w[0] + __bid_midpoint64[ind];\n-      if (C.w[0] < tmp64)\n-        C.w[1]++;\n-\n-      // x = q - p = q - 34, 1 <= x <= 4\n-      // kx = 10^(-x) = __bid_ten2mk128M[ind]\n-      // C* = (C + 1/2 * 10^x) * 10^(-x)\n-      // the approximation of 10^(-x) was rounded up to 128 bits\n-      __mul_128x128_to_256 (P256, C, __bid_ten2mk128M[ind]);\n-      Cstar.w[1] = P256.w[3];\n-      Cstar.w[0] = P256.w[2];\n-      fstar.w[2] = Cstar.w[0] & __bid_maskhigh128M[ind]; // fstar.w[3|4|5]=0\n-      fstar.w[1] = P256.w[1];\n-      fstar.w[0] = P256.w[0];\n-\n-      // calculate C* and f*\n-      // C* is actually floor(C*) in this case\n-      // C* and f* need shifting and masking, as shown by\n-      // __bid_shiftright128M[] and __bid_maskhigh128M[]\n-      // the top Ex bits of 10^(-x) are T* = __bid_ten2mk128truncM[ind], e.g.\n-      // if x=1, T*=__bid_ten2mk128truncM[0]=0xcccccccccccccccccccccccccccccccc\n-      // if (0 < f* < 10^(-x)) then the result is a midpoint\n-      //   if floor(C*) is even then C* = floor(C*) - logical right\n-      //       shift; C* has p decimal digits, correct by Prop. 1)\n-      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n-      //       shift; C* has p decimal digits, correct by Pr. 1)\n-      // else\n-      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n-      //       correct by Property 1)\n-      // n = C* * 10^(e+x)\n-\n-      // shift right C* by Ex-128 = __bid_shiftright128M[ind]\n-      shift = __bid_shiftright128M[ind]; // 3 <= shift <= 13\n-      Cstar.w[0] = (Cstar.w[0] >> shift) | (Cstar.w[1] << (64 - shift));\n-      Cstar.w[1] = (Cstar.w[1] >> shift);\n-\n-      // determine inexactness of the rounding of C*\n-      // if (0 < f* - 1/2 < 10^(-x)) then\n-      //   the result is exact\n-      // else // if (f* - 1/2 > T*) then\n-      //   the result is inexact\n-      if (fstar.w[2] > __bid_one_half128M[ind]\n-          || (fstar.w[2] == __bid_one_half128M[ind]\n-          && (fstar.w[1] || fstar.w[0]))) {\n-\n-        // f* > 1/2 and the result may be exact\n-        // Calculate f* - 1/2\n-        tmp64 = fstar.w[2] - __bid_one_half128M[ind];\n-        if (tmp64 || fstar.w[1] > __bid_ten2mk128truncM[ind].w[1] || \n-            (fstar.w[1] == __bid_ten2mk128truncM[ind].w[1] && \n-            fstar.w[0] > __bid_ten2mk128truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          is_inexact_lt_midpoint = 1;\n-        }        // else the result is exact\n-      } else { // the result is inexact; f2* <= 1/2\n-        // set the inexact flag\n-        *pfpsf |= INEXACT_EXCEPTION;\n-        tmp_fpa = 1;\n-        is_inexact_gt_midpoint = 1;\n-      }\n-\n-      // check for midpoints (could do this before determining inexactness)\n-      if ((fstar.w[2] == 0) && (fstar.w[1] || fstar.w[0])\n-          && (fstar.w[1] < __bid_ten2mk128truncM[ind].w[1]\n-              || (fstar.w[1] == __bid_ten2mk128truncM[ind].w[1]\n-              && fstar.w[0] <= __bid_ten2mk128truncM[ind].w[0]))) {\n-\n-        // the result is a midpoint\n-        if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n-          // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n-          Cstar.w[0]--; // Cstar.w[0] is now even\n-          if (tmp_fpa == 1)\n-            tmp_fpa = 0;\n-          is_midpoint_gt_even = 1;\n-          is_inexact_lt_midpoint = 0;\n-          is_inexact_gt_midpoint = 0;\n-        } else { // else MP in [ODD, EVEN]\n-          is_midpoint_lt_even = 1;\n-          is_inexact_lt_midpoint = 0;\n-          is_inexact_gt_midpoint = 0;\n-        }\n-      }\n-      // check for rounding overflow\n-      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n-          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 2) << 49);\n-        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n-        Cstar.w[0] = 0x38c15b0a00000000ull;\n-\n-        // if rounding overflow made the exponent equal to emin, set underflow\n-        if (tmp64 == EXP_MIN + BIN_EXP_BIAS)\n-          *pfpsf |= UNDERFLOW_EXCEPTION;\n-      } else { // 10^33 <= Cstar <= 10^34 - 1\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 1) << 49); // ind+1 = q-34\n-      }\n-      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n-        // exp >= emax for the result rounded to nearest even\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY) {\n-          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n-\n-            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n-            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_DOWN) {\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0xf800000000000000ull; // -inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_UP) {\n-          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0x7800000000000000ull; // inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        }\n-        if (is_overflow) { // return for overflow\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-\n-          // set the overflow flag\n-          *pfpsf |= OVERFLOW_EXCEPTION;\n-\n-          // is_overflow = 1;\n-          BID_RETURN (res);\n-        }\n-      } else {\n-        res.w[0] = Cstar.w[0];\n-        res.w[1] = Cstar.w[1];\n-        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-      }\n-      res.w[1] |= sign;\n-    } else if (q <= 57) { // 39 <= q <= 57; exact coefficient takes 128-192 bits\n-      // C = C + 1/2 * 10^x where the result C fits in 190 bits\n-      // (10^57 - 1 + 1/2 * 10^23 can be represented with 190 bits)\n-      // x = q - p = q - 34, 5 <= x <= 23\n-      // kx = 10^(-x) = __bid_ten2mk192M[ind]\n-      // C* = (C + 1/2 * 10^x) * 10^(-x)\n-      // the approximation of 10^(-x) was rounded up to 192 bits\n-      ind = q - 39; // 0 <= ind <= 18\n-      tmp64 = C.w[0];\n-      tmp64A = C.w[1];\n-\n-      // Note:\n-      // if 5 <= x <= 19 <=> 0 <= ind <= 14 then\n-      //   f* has 256 bits\n-      // else // if 20 <= x <= 23 <=> 15 <= ind <= 18 then\n-      //   f* has 320 bits\n-      if (ind <= 14) { // x - 1 = q - 35 = ind + 4 <= 18 \n-        // add one 64-bit word\n-        C.w[0] = C.w[0] + __bid_midpoint64[ind + 4];\n-        if (C.w[0] < tmp64)\n-          C.w[1]++;\n-        if (C.w[1] < tmp64A)\n-          C.w[2]++;\n-        __mul_192x192_to_384 (P384, C, __bid_ten2mk192M[ind])\n-          // calculate C* and f*; C* is actually floor(C*) in this case\n-          // C* and f* need shifting and masking, as shown by \n-          // __bid_shiftright192M[] and __bid_maskhigh192M[]\n-          // C* has 128 bits; P384.w[5], P384.w[4], P384.w[3] need to be\n-          // shifted right by Ex-192 = __bid_shiftright192M[ind]\n-          shift = __bid_shiftright192M[ind]; // 16 <= shift <= 63\n-        Cstar.w[0] = (P384.w[3] >> shift) | (P384.w[4] << (64 - shift));\n-        Cstar.w[1] = (P384.w[4] >> shift) | (P384.w[5] << (64 - shift));\n-\n-        // f* has 256 bits\n-        fstar.w[3] = P384.w[3] & __bid_maskhigh192M[ind];\n-        fstar.w[2] = P384.w[2];\n-        fstar.w[1] = P384.w[1];\n-        fstar.w[0] = P384.w[0];\n-\n-        // the top Ex bits of 10^(-x) are T* = __bid_ten2mk192truncM[ind], e.g. \n-        // if x=5, T* = __bid_ten2mk192truncM[0] =\n-        //   0xa7c5ac471b4784230fcf80dc33721d53cddd6e04c0592103\n-        // if (0 < f* < 10^(-x)) then the result is a midpoint\n-        //   if floor(C*) is even then C* = floor(C*) - logical right\n-        //       shift; C* has p decimal digits, correct by Prop. 1)\n-        //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n-        //       shift; C* has p decimal digits, correct by Pr. 1)\n-        // else\n-        //   C* = floor(C*) (logical right shift; C has p decimal digits,\n-        //       correct by Property 1)\n-        // n = C* * 10^(e+x)\n-\n-        // determine inexactness of the rounding of C*\n-        // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n-        //   the result is exact\n-        // else // if (f* - 1/2 >= T*) then\n-        //   the result is inexact\n-        if (fstar.w[3] > __bid_one_half192M[ind]\n-            || (fstar.w[3] == __bid_one_half192M[ind]\n-            && (fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n-\n-          // f* > 1/2 and the result may be exact\n-          // Calculate f* - 1/2\n-          tmp64 = fstar.w[3] - __bid_one_half192M[ind];\n-          if (tmp64 || fstar.w[2] > __bid_ten2mk192truncM[ind].w[2] || \n-              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n-              fstar.w[1] > __bid_ten2mk192truncM[ind].w[1]) || \n-              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n-              fstar.w[1] == __bid_ten2mk192truncM[ind].w[1] && \n-              fstar.w[0] > __bid_ten2mk192truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n-            // set the inexact flag\n-            *pfpsf |= INEXACT_EXCEPTION;\n-            is_inexact_lt_midpoint = 1;\n-          }        // else the result is exact\n-        } else { // the result is inexact; f2* <= 1/2\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          tmp_fpa = 1;\n-          is_inexact_gt_midpoint = 1;\n-        }\n-\n-        // check for midpoints (could do this before determining inexactness)\n-        if ((fstar.w[3] == 0)\n-            && (fstar.w[2] || fstar.w[1] || fstar.w[0])\n-            && (fstar.w[2] < __bid_ten2mk192truncM[ind].w[2]\n-                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n-                && fstar.w[1] < __bid_ten2mk192truncM[ind].w[1])\n-                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n-                && fstar.w[1] == __bid_ten2mk192truncM[ind].w[1]\n-                && fstar.w[0] <= __bid_ten2mk192truncM[ind].w[0]))) {\n-\n-          // the result is a midpoint\n-          if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n-            // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n-            Cstar.w[0]--; // Cstar.w[0] is now even\n-            if (tmp_fpa == 1)\n-              tmp_fpa = 0;\n-            is_midpoint_gt_even = 1;\n-            is_inexact_lt_midpoint = 0;\n-            is_inexact_gt_midpoint = 0;\n-          } else { // else MP in [ODD, EVEN]\n-            is_midpoint_lt_even = 1;\n-            is_inexact_lt_midpoint = 0;\n-            is_inexact_gt_midpoint = 0;\n-          }\n-        }\n-      } else { // if ind >= 15 <=> x - 1 = q - 35 = ind + 4 >= 19\n-        // add two 64-bit words\n-        C.w[0] = C.w[0] + __bid_midpoint128[ind - 15].w[0];\n-        C.w[1] = C.w[1] + __bid_midpoint128[ind - 15].w[1];\n-        if (C.w[0] < tmp64)\n-          C.w[1]++;\n-        if (C.w[1] < tmp64A)\n-          C.w[2]++;\n-        __mul_192x192_to_384 (P384, C, __bid_ten2mk192M[ind])\n-          // calculate C* and f*; C* is actually floor(C*) in this case\n-          // C* and f* need shifting and masking, as shown by\n-          // __bid_shiftright192M[] and __bid_maskhigh192M[]\n-          // C* has 128 bits; P384.w[5], P384.w[4], need to be\n-          // shifted right by Ex-256 = __bid_shiftright192M[ind]\n-          shift = __bid_shiftright192M[ind]; // 2 <= shift <= 12\n-        Cstar.w[0] = (P384.w[4] >> shift) | (P384.w[5] << (64 - shift));\n-        Cstar.w[1] = (P384.w[5] >> shift);\n-\n-        // f* has 320 bits\n-        fstar.w[4] = P384.w[4] & __bid_maskhigh192M[ind];\n-        fstar.w[3] = P384.w[3];\n-        fstar.w[2] = P384.w[2];\n-        fstar.w[1] = P384.w[1];\n-        fstar.w[0] = P384.w[0];\n-\n-        // the top Ex bits of 10^(-x) are T* = __bid_ten2mk192truncM[ind], e.g. \n-        // if x=23, T* = __bid_ten2mk192truncM[18] =\n-        //   0xc16d9a0095928a2775b7053c0f1782938d6f439b43088650\n-        // if (0 < f* < 10^(-x)) then the result is a midpoint\n-        //   if floor(C*) is even then C* = floor(C*) - logical right\n-        //       shift; C* has p decimal digits, correct by Prop. 1)\n-        //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n-        //       shift; C* has p decimal digits, correct by Pr. 1)\n-        // else\n-        //   C* = floor(C*) (logical right shift; C has p decimal digits,\n-        //       correct by Property 1)\n-        // n = C* * 10^(e+x)\n-\n-        // determine inexactness of the rounding of C*\n-        // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n-        //   the result is exact\n-        // else // if (f* - 1/2 >= T*) then\n-        //   the result is inexact\n-        if (fstar.w[4] > __bid_one_half192M[ind]\n-            || (fstar.w[4] == __bid_one_half192M[ind]\n-            && (fstar.w[3] || fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n-\n-          // f* > 1/2 and the result may be exact\n-          // Calculate f* - 1/2\n-          tmp64 = fstar.w[4] - __bid_one_half192M[ind];\n-          if (tmp64 || fstar.w[3] || fstar.w[2] > __bid_ten2mk192truncM[ind].w[2] || \n-              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n-              fstar.w[1] > __bid_ten2mk192truncM[ind].w[1]) || \n-              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n-              fstar.w[1] == __bid_ten2mk192truncM[ind].w[1] && \n-              fstar.w[0] > __bid_ten2mk192truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n-            // set the inexact flag\n-            *pfpsf |= INEXACT_EXCEPTION;\n-            is_inexact_lt_midpoint = 1;\n-          } // else the result is exact\n-        } else { // the result is inexact; f2* <= 1/2\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          tmp_fpa = 1;\n-          is_inexact_gt_midpoint = 1;\n-        }\n+    p_sign = x_sign ^ y_sign;\t// sign of the product\n+\n+    true_p_exp = (x_exp >> 49) - 6176 + (y_exp >> 49) - 6176;\n+    // true_p_exp, p_exp are used only for 0 * 0, 0 * f, or f * 0 \n+    if (true_p_exp < -398)\n+      p_exp = 0;\t// cannot be less than EXP_MIN\n+    else if (true_p_exp > 369)\n+      p_exp = (UINT64) (369 + 398) << 53;\t// cannot be more than EXP_MAX\n+    else\n+      p_exp = (UINT64) (true_p_exp + 398) << 53;\n+\n+    if ((C1.w[1] == 0x0 && C1.w[0] == 0x0) ||\n+\t(C2.w[1] == 0x0 && C2.w[0] == 0x0)) {\n+      // x = 0 or y = 0\n+      // the result is 0\n+      res = p_sign | p_exp;\t// preferred exponent in [EXP_MIN, EXP_MAX]\n+      BID_RETURN (res)\n+    }\t// else continue\n+  }\n+  // swap x and y - ensure that a NaN in x has 'higher precedence' than one in y\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64qqq_fma (&res, &y, &x, &z\n+\t\t_RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t_EXC_INFO_ARG);\n+#else\n+  res = bid64qqq_fma (y, x, z\n+\t\t      _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t      _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-        // check for midpoints (could do this before determining inexactness)\n-        if ((fstar.w[4] == 0) && (fstar.w[3] == 0)\n-            && (fstar.w[2] || fstar.w[1] || fstar.w[0])\n-            && (fstar.w[2] < __bid_ten2mk192truncM[ind].w[2]\n-                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n-                && fstar.w[1] < __bid_ten2mk192truncM[ind].w[1])\n-                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n-                && fstar.w[1] == __bid_ten2mk192truncM[ind].w[1]\n-                && fstar.w[0] <= __bid_ten2mk192truncM[ind].w[0]))) {\n \n-          // the result is a midpoint\n-          if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n-            // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n-            Cstar.w[0]--; // Cstar.w[0] is now even\n-            if (tmp_fpa == 1)\n-              tmp_fpa = 0;\n-            is_midpoint_gt_even = 1;\n-            is_inexact_lt_midpoint = 0;\n-            is_inexact_gt_midpoint = 0;\n-          } else { // else MP in [ODD, EVEN]\n-            is_midpoint_lt_even = 1;\n-            is_inexact_lt_midpoint = 0;\n-            is_inexact_gt_midpoint = 0;\n-          }\n-        }\n-      }\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid128dd_mul (UINT128 * pres, UINT64 * px, UINT64 * py\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+  UINT64 x = *px, y = *py;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT128\n+bid128dd_mul (UINT64 x, UINT64 y\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res = { {0xbaddbaddbaddbaddull, 0xbaddbaddbaddbaddull}\n+  };\n+  UINT128 x1, y1;\n \n-      // check for rounding overflow\n-      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n-          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 6) << 49);\n-        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n-        Cstar.w[0] = 0x38c15b0a00000000ull;\n-      } else { // 10^33 <= Cstar <= 10^34 - 1\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 5) << 49); // ind+5 = q-34\n-      }\n-      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n-        // exp >= emax for the result rounded to nearest even\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY) {\n-          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64_to_bid128 (&x1, &x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid64_to_bid128 (&y1, &y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid128_mul (&res, &x1, &y1\n+\t      _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t      _EXC_INFO_ARG);\n+#else\n+  x1 = bid64_to_bid128 (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  y1 = bid64_to_bid128 (y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res = bid128_mul (x1, y1\n+\t\t    _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t    _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n-            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_DOWN) {\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0xf800000000000000ull; // -inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_UP) {\n-          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0x7800000000000000ull; // inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        }\n-        if (is_overflow) { // return for overflow\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n \n-          // set the overflow flag\n-          *pfpsf |= OVERFLOW_EXCEPTION;\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid128dq_mul (UINT128 * pres, UINT64 * px, UINT128 * py\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT128\n+bid128dq_mul (UINT64 x, UINT128 y\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res = { {0xbaddbaddbaddbaddull, 0xbaddbaddbaddbaddull}\n+  };\n+  UINT128 x1;\n \n-          // is_overflow = 1;\n-        BID_RETURN (res)}\n-      } else {\n-        res.w[0] = Cstar.w[0];\n-        res.w[1] = Cstar.w[1];\n-        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-      }\n-      res.w[1] |= sign;\n-    } else { // if (58 <= q <= 68) exact coefficient takes 192-226 bits\n-      // C = C + 1/2 * 10^x where the result C fits in 226 bits\n-      // (10^68 - 1 + 1/2 * 10^34 can be represented with 226 bits)\n-      // x = q - p = q - 34, 24 <= x <= 34\n-      // kx = 10^(-x) = __bid_ten2mk256M[ind]\n-      // C* = (C + 1/2 * 10^x) * 10^(-x)\n-      // the approximation of 10^(-x) was rounded up to 256 bits\n-      ind = q - 58; // 0 <= ind <= 10\n-      tmp64 = C.w[0];\n-      tmp64A = C.w[1];\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64_to_bid128 (&x1, &x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid128_mul (&res, &x1, py\n+\t      _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t      _EXC_INFO_ARG);\n+#else\n+  x1 = bid64_to_bid128 (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res = bid128_mul (x1, y\n+\t\t    _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t    _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-      // Note:\n-      // f* has 384 bits (more than 320 bits)\n-      // x - 1 = q - 35 = ind + 23\n-      // add two 64-bit words; e.g. for ind=0 <=> q=58, add 1/2*10^24\n-      C.w[0] = C.w[0] + __bid_midpoint128[ind + 4].w[0];\n-      C.w[1] = C.w[1] + __bid_midpoint128[ind + 4].w[1];\n-      if (C.w[0] < tmp64)\n-        C.w[1]++;\n-      if (C.w[1] < tmp64A)\n-        C.w[2]++;\n-      if (C.w[2] == 0)\n-        C.w[3]++;\n-      __mul_256x256_to_512 (P512, C, __bid_ten2mk256M[ind])\n-        // calculate C* and f*; C* is actually floor(C*) in this case\n-        // C* and f* need shifting and masking, as shown by \n-        // __bid_shiftright256M[] and __bid_maskhigh256M[]\n-        // C* has 128 bits; P512.w[7], P512.w[6], P512.w[5] need to be\n-        // shifted right by Ex-320 = __bid_shiftright256M[ind]\n-        shift = __bid_shiftright256M[ind]; // 15 <= shift <= 48\n-      if (shift == 32) {\n-        Cstar.w[0] =\n-          ((P512.w[5] >> 31) >> 1) | ((P512.w[6] << 31) << 1);\n-        Cstar.w[1] =\n-          ((P512.w[6] >> 31) >> 1) | ((P512.w[7] << 31) << 1);\n-      } else {\n-        Cstar.w[0] = (P512.w[5] >> shift) | (P512.w[6] << (64 - shift));\n-        Cstar.w[1] = (P512.w[6] >> shift) | (P512.w[7] << (64 - shift));\n-      }\n-      // f* has 384 bits\n-      fstar.w[5] = P512.w[5] & __bid_maskhigh256M[ind];\n-      fstar.w[4] = P512.w[4];\n-      fstar.w[3] = P512.w[3];\n-      fstar.w[2] = P512.w[2];\n-      fstar.w[1] = P512.w[1];\n-      fstar.w[0] = P512.w[0];\n \n-      // the top Ex bits of 10^(-x) are T* = __bid_ten2mk256truncM[ind], e.g. \n-      // if x=24, T* = __bid_ten2mk256truncM[0] =\n-      //   0x9abe14cd44753b52c4926a9672793542d78c3615cf3a050cf23472530ce6e3ec =~\n-      //   10^(-24) * 2^335\n-      // if (0 < f* < 10^(-x)) then the result is a midpoint\n-      //   if floor(C*) is even then C* = floor(C*) - logical right\n-      //       shift; C* has p decimal digits, correct by Prop. 1)\n-      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n-      //       shift; C* has p decimal digits, correct by Pr. 1)\n-      // else\n-      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n-      //       correct by Property 1)\n-      // n = C* * 10^(e+x)\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid128qd_mul (UINT128 * pres, UINT128 * px, UINT64 * py\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+  UINT64 y = *py;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT128\n+bid128qd_mul (UINT128 x, UINT64 y\n+\t      _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res = { {0xbaddbaddbaddbaddull, 0xbaddbaddbaddbaddull}\n+  };\n+  UINT128 y1;\n \n-      // determine inexactness of the rounding of C*\n-      // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n-      //   the result is exact\n-      // else // if (f* - 1/2 >= T*) then\n-      //   the result is inexact\n-      if (fstar.w[5] > __bid_one_half256M[ind]\n-          || (fstar.w[5] == __bid_one_half256M[ind]\n-          && (fstar.w[4] || fstar.w[3] || fstar.w[2] || fstar.w[1]\n-              || fstar.w[0]))) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid64_to_bid128 (&y1, &y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid128_mul (&res, px, &y1\n+\t      _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t      _EXC_INFO_ARG);\n+#else\n+  y1 = bid64_to_bid128 (y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res = bid128_mul (x, y1\n+\t\t    _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t    _EXC_INFO_ARG);\n+#endif\n+  BID_RETURN (res);\n+}\n \n-        // f* > 1/2 and the result may be exact\n-        // Calculate f* - 1/2\n-        tmp64 = fstar.w[5] - __bid_one_half256M[ind]; // tmp64 >= 0\n-        if (tmp64 || fstar.w[4] || fstar.w[3] > __bid_ten2mk256truncM[ind].w[3] || \n-            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n-            fstar.w[2] > __bid_ten2mk256truncM[ind].w[2]) || \n-            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n-            fstar.w[2] == __bid_ten2mk256truncM[ind].w[2] && \n-            fstar.w[1] > __bid_ten2mk256truncM[ind].w[1]) || \n-            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n-            fstar.w[2] == __bid_ten2mk256truncM[ind].w[2] && \n-            fstar.w[1] == __bid_ten2mk256truncM[ind].w[1] && \n-            fstar.w[0] > __bid_ten2mk256truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          is_inexact_lt_midpoint = 1;\n-        } // else the result is exact\n-      } else { // the result is inexact; f2* <= 1/2\n-        // set the inexact flag\n-        *pfpsf |= INEXACT_EXCEPTION;\n-        tmp_fpa = 1;\n-        is_inexact_gt_midpoint = 1;\n-      }\n \n-      // check for midpoints (could do this before determining inexactness)\n-      if ((fstar.w[5] == 0) && (fstar.w[4] == 0)\n-          && (fstar.w[3] || fstar.w[2] || fstar.w[1] || fstar.w[0])\n-          && (fstar.w[3] < __bid_ten2mk256truncM[ind].w[3]\n-              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n-              && fstar.w[2] < __bid_ten2mk256truncM[ind].w[2])\n-              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n-              && fstar.w[2] == __bid_ten2mk256truncM[ind].w[2]\n-              && fstar.w[1] < __bid_ten2mk256truncM[ind].w[1])\n-              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n-              && fstar.w[2] == __bid_ten2mk256truncM[ind].w[2]\n-              && fstar.w[1] == __bid_ten2mk256truncM[ind].w[1]\n-              && fstar.w[0] <= __bid_ten2mk256truncM[ind].w[1]))) {\n+// bid128_mul stands for bid128qq_mul\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+bid128_mul (UINT128 * pres, UINT128 * px,\n+\t    UINT128 *\n+\t    py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t    _EXC_INFO_PARAM) {\n+  UINT128 x = *px, y = *py;\n \n-        // the result is a midpoint\n-        if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n-          // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n-          Cstar.w[0]--; // Cstar.w[0] is now even\n-          if (tmp_fpa == 1)\n-            tmp_fpa = 0;\n-          is_midpoint_gt_even = 1;\n-          is_inexact_lt_midpoint = 0;\n-          is_inexact_gt_midpoint = 0;\n-        } else { // else MP in [ODD, EVEN]\n-          is_midpoint_lt_even = 1;\n-          is_inexact_lt_midpoint = 0;\n-          is_inexact_gt_midpoint = 0;\n-        }\n-      }\n-      // check for rounding overflow\n-      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n-          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 25) << 49);\n-        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n-        Cstar.w[0] = 0x38c15b0a00000000ull;\n-      } else { // 10^33 <= Cstar <= 10^34 - 1\n-        tmp64 = x_exp + y_exp + ((UINT64) (ind + 24) << 49); // ind+24 = q-34\n-      }\n-      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n-        // exp >= emax for the result rounded to nearest even\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY) {\n-          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n \n-            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n-            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_DOWN) {\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0xf800000000000000ull; // -inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else if (rnd_mode == ROUNDING_UP) {\n-          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n-              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n-              Cstar.w[1] == 0x0001ed09bead87c0ull && \n-              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n-              is_inexact_lt_midpoint))) {\n-            res.w[1] = 0x7800000000000000ull; // inf\n-            res.w[0] = 0x0ull;\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n-          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = +MAXFP\n-            res.w[1] = 0x5fffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n-              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n-              Cstar.w[1] == 0x0000314dc6448d93ull && \n-              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n-              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n-            // res = -MAXFP\n-            res.w[1] = 0xdfffed09bead87c0ull;\n-            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n-            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n-            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n-            is_overflow = 1;\n-          } else { // not overflow\n-            res.w[0] = Cstar.w[0];\n-            res.w[1] = Cstar.w[1];\n-            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n-          }\n-        }\n-        if (is_overflow) { // return for overflow\n-          // set the inexact flag\n-          *pfpsf |= INEXACT_EXCEPTION;\n+#endif\n+#else\n+UINT128\n+bid128_mul (UINT128 x,\n+\t    UINT128 y _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t    _EXC_INFO_PARAM) {\n \n-          // set the overflow flag\n-          *pfpsf |= OVERFLOW_EXCEPTION;\n+#endif\n+  UINT128 z = { {0x0000000000000000ull, 0x5ffe000000000000ull}\n+  };\n+  UINT128 res = { {0xbaddbaddbaddbaddull, 0xbaddbaddbaddbaddull}\n+  };\n+  UINT64 x_sign, y_sign, p_sign;\n+  UINT64 x_exp, y_exp, p_exp;\n+  int true_p_exp;\n+  UINT128 C1, C2;\n \n-          // is_overflow = 1;\n-          BID_RETURN (res);\n-        }\n-      } else {\n-        res.w[0] = Cstar.w[0];\n-        res.w[1] = Cstar.w[1];\n-        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+  // skip cases where at least one operand is NaN or infinity\n+  if (!(((x.w[1] & MASK_NAN) == MASK_NAN) ||\n+\t((y.w[1] & MASK_NAN) == MASK_NAN) ||\n+\t((x.w[1] & MASK_ANY_INF) == MASK_INF) ||\n+\t((y.w[1] & MASK_ANY_INF) == MASK_INF))) {\n+    // x, y are 0 or f but not inf or NaN => unpack the arguments and check\n+    // for non-canonical values\n+\n+    x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+    C1.w[1] = x.w[1] & MASK_COEFF;\n+    C1.w[0] = x.w[0];\n+    // check for non-canonical values - treated as zero\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      // G0_G1=11 => non-canonical\n+      x_exp = (x.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+      C1.w[1] = 0;\t// significand high\n+      C1.w[0] = 0;\t// significand low\n+    } else {\t// G0_G1 != 11\n+      x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+      if (C1.w[1] > 0x0001ed09bead87c0ull ||\n+\t  (C1.w[1] == 0x0001ed09bead87c0ull &&\n+\t   C1.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tC1.w[1] = 0;\n+\tC1.w[0] = 0;\n+      } else {\t// canonical          \n+\t;\n       }\n-      res.w[1] |= sign;\n     }\n-\n-    // general correction from RN to RA, RM, RP, RZ\n-    if (rnd_mode != ROUNDING_TO_NEAREST && !is_overflow) { // overflow is solved\n-      x_exp = res.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n-      C1_hi = res.w[1] & MASK_COEFF;\n-      C1_lo = res.w[0];\n-      if ((!sign && ((rnd_mode == ROUNDING_UP && is_inexact_lt_midpoint) || \n-          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_UP) && \n-          is_midpoint_gt_even))) || \n-          (sign && ((rnd_mode == ROUNDING_DOWN && is_inexact_lt_midpoint) || \n-          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_DOWN) && \n-          is_midpoint_gt_even)))) {\n-\n-        // C1 = C1 + 1\n-        C1_lo = C1_lo + 1;\n-        if (C1_lo == 0) { // rounding overflow in the low 64 bits\n-          C1_hi = C1_hi + 1;\n-          if (C1_hi == 0x0001ed09bead87c0ull\n-              && C1_lo == 0x378d8e6400000000ull) {\n-\n-            // C1 = 10^34 => rounding overflow\n-            C1_hi = 0x0000314dc6448d93ull;\n-            C1_lo = 0x38c15b0a00000000ull; // 10^33\n-            x_exp = x_exp + EXP_P1;\n-          }\n-        }\n-      } else if ((is_midpoint_lt_even || is_inexact_gt_midpoint)\n-          && ((sign && (rnd_mode == ROUNDING_UP || \n-          rnd_mode == ROUNDING_TO_ZERO)) || \n-          (!sign && (rnd_mode == ROUNDING_DOWN || \n-          rnd_mode == ROUNDING_TO_ZERO)))) {\n-\n-        // C1 = C1 - 1\n-        C1_lo = C1_lo - 1;\n-        if (C1_lo == 0xffffffffffffffffull)\n-          C1_hi--;\n-\n-        // check if we crossed into the lower decade\n-        if (C1_hi == 0x0000314dc6448d93ull && C1_lo == 0x38c15b09ffffffffull) {\n-          // 10^33 - 1\n-          C1_hi = 0x0001ed09bead87c0ull; // 10^34 - 1\n-          C1_lo = 0x378d8e63ffffffffull;\n-          x_exp = x_exp - EXP_P1; // no underflow (TO CHECK)\n-        }\n-      } else {\n-        ; // exact, the result is already correct\n+    y_sign = y.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+    C2.w[1] = y.w[1] & MASK_COEFF;\n+    C2.w[0] = y.w[0];\n+    // check for non-canonical values - treated as zero\n+    if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      // G0_G1=11 => non-canonical\n+      y_exp = (y.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+      C2.w[1] = 0;\t// significand high\n+      C2.w[0] = 0;\t// significand low \n+    } else {\t// G0_G1 != 11\n+      y_exp = y.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+      if (C2.w[1] > 0x0001ed09bead87c0ull ||\n+\t  (C2.w[1] == 0x0001ed09bead87c0ull &&\n+\t   C2.w[0] > 0x378d8e63ffffffffull)) {\n+\t// y is non-canonical if coefficient is larger than 10^34 -1\n+\tC2.w[1] = 0;\n+\tC2.w[0] = 0;\n+      } else {\t// canonical\n+\t;\n       }\n-\n-      // assemble the result\n-      res.w[1] = x_exp | C1_hi;\n-      res.w[0] = C1_lo;\n     }\n-    res.w[1] |= sign;\n-    BID_RETURN (res);\n+    p_sign = x_sign ^ y_sign;\t// sign of the product\n+\n+    true_p_exp = (x_exp >> 49) - 6176 + (y_exp >> 49) - 6176;\n+    // true_p_exp, p_exp are used only for 0 * 0, 0 * f, or f * 0 \n+    if (true_p_exp < -6176)\n+      p_exp = 0;\t// cannot be less than EXP_MIN\n+    else if (true_p_exp > 6111)\n+      p_exp = (UINT64) (6111 + 6176) << 49;\t// cannot be more than EXP_MAX\n+    else\n+      p_exp = (UINT64) (true_p_exp + 6176) << 49;\n+\n+    if ((C1.w[1] == 0x0 && C1.w[0] == 0x0) ||\n+\t(C2.w[1] == 0x0 && C2.w[0] == 0x0)) {\n+      // x = 0 or y = 0\n+      // the result is 0\n+      res.w[1] = p_sign | p_exp;\t// preferred exponent in [EXP_MIN, EXP_MAX]\n+      res.w[0] = 0x0;\n+      BID_SWAP128 (res);\n+      BID_RETURN (res)\n+    }\t// else continue\n   }\n-_underflow_path:\n-  // got here because q - P34 < ind where ind = EMIN - ex - ey\n-  // q is the number of digits in C; ind is the [positive] exponent of the\n-  // negative power of 10 that must multiply C in order to make the result's\n-  // exponent equal to e_min - P34 + 1 = -6176\n-  ind =\n-    (int) (((SINT64) EXP_MIN + (SINT64) BIN_EXP_BIAS - (SINT64) x_exp -\n-            (SINT64) y_exp) >> 49);\n-\n-  // q - P34 < ind => -P34 + 1 < ind => -P34 + 2 <= ind\n-  // ind = EMIN - ex - ey < -6176 + 6176 + 6176 = 6176\n-  if (q < ind) { // q - ind < 0; result rounds to 0 when rounding to nearest\n-    // set the inexact and underflow flags\n-    *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n-    res.w[1] = EXP_MIN; // EXP_MIN = 0x0\n-    res.w[0] = 0x0;\n-    if (rnd_mode != ROUNDING_TO_NEAREST) {\n-      if ((rnd_mode == ROUNDING_DOWN && sign) || \n-          (rnd_mode == ROUNDING_UP && !sign))\n-        res.w[0] = 0x0000000000000001ull;\n-    }\n-  } else if (q == ind) { // q - ind = 0; result rounds to 0 or +/-1*10^EMIN\n-    // set the inexact and underflow flags\n-    *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n-\n-    // if C <= 5*10^(q-1) then C = 0 else C = 1\n-    if (q <= 19) {\n-      if (C.w[0] == __bid_midpoint64[q - 1]) { // C = 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n-            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else if (C.w[0] < __bid_midpoint64[q - 1]) { // C < 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && !sign)\n-            || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else { // C > 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && sign)\n-            || (rnd_mode == ROUNDING_UP && !sign)) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        }\n-      }\n-    } else if (q <= 38) { // 20 <= q <= 38\n-      // if q <= P34 = 34 the exact result rounded to P34 digits with unbounded \n-      // exponent will have an exponent smaller than e_min; otherwise if\n-      // 35 <= q <= 38, it depends\n-      if (C.w[1] == __bid_midpoint128[q - 20].w[1] && \n-          C.w[0] == __bid_midpoint128[q - 20].w[0]) { // C = 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n-            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else if (C.w[1] < __bid_midpoint128[q - 20].w[1] || \n-          (C.w[1] == __bid_midpoint128[q - 20].w[1] && \n-          C.w[0] < __bid_midpoint128[q - 20].w[0])) { // C < 0.5 * 10^emin \n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && !sign)\n-            || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else { // C > 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && sign)\n-            || (rnd_mode == ROUNDING_UP && !sign)) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        }\n-      }\n-    } else if (q <= 58) { // 39 <= q <= 58\n-      // Note: for q = 58 C may take 256 bits, so need to test C.w[3]\n-      if (C.w[3] == 0x0 && C.w[2] == __bid_midpoint192[q - 39].w[2] && \n-          C.w[1] == __bid_midpoint192[q - 39].w[1] && \n-          C.w[0] == __bid_midpoint192[q - 39].w[0]) { // C = 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n-            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else if ((C.w[3] == 0x0 && C.w[2] < __bid_midpoint192[q - 39].w[2]) || \n-          (C.w[3] == 0x0 && C.w[2] == __bid_midpoint192[q - 39].w[2] && \n-          C.w[1] < __bid_midpoint192[q - 39].w[1]) || (C.w[3] == 0x0 && \n-          C.w[2] == __bid_midpoint192[q - 39].w[2] && \n-          C.w[1] == __bid_midpoint192[q - 39].w[1] && \n-          C.w[0] < __bid_midpoint192[q - 39].w[0])) { // C < 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && !sign)\n-            || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else { // C > 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && sign)\n-            || (rnd_mode == ROUNDING_UP && !sign)) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        }\n-      }\n-    } else { // if (q <= 68), i.e. 59 <= q <= 68\n-      if (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n-          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n-          C.w[1] == __bid_midpoint256[q - 59].w[1] && \n-          C.w[0] == __bid_midpoint256[q - 59].w[0]) { // C = 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n-            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else if (C.w[3] < __bid_midpoint256[q - 59].w[3] || \n-          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n-          C.w[2] < __bid_midpoint256[q - 59].w[2]) || \n-          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n-          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n-          C.w[1] < __bid_midpoint256[q - 59].w[1]) || \n-          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n-          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n-          C.w[1] == __bid_midpoint256[q - 59].w[1] && \n-          C.w[0] < __bid_midpoint256[q - 59].w[0])) { // C < 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && !sign)\n-            || (rnd_mode == ROUNDING_UP && sign)\n-            || rnd_mode == ROUNDING_TO_ZERO) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        }\n-      } else { // C > 0.5 * 10^emin\n-        if (rnd_mode == ROUNDING_TO_NEAREST\n-            || rnd_mode == ROUNDING_TIES_AWAY\n-            || (rnd_mode == ROUNDING_DOWN && sign)\n-            || (rnd_mode == ROUNDING_UP && !sign)) {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 1;\n-        } else {\n-          res.w[1] = EXP_MIN;\n-          res.w[0] = 0;\n-        }\n-      }\n-    }\n-  } else { // if 0 < q - ind < P34 <=> 1 <= q - ind <= P34 - 1 = 33\n-    // In general -P34 + 2 <= ind <= 6176 => -P34 + 2 <= ind < q =>\n-    // -P34 + 2 <= ind <= q - 1\n-    if (rnd_mode != ROUNDING_TO_NEAREST) {\n-      is_inexact_lt_midpoint = 0;\n-      is_inexact_gt_midpoint = 0;\n-      is_midpoint_lt_even = 0;\n-      is_midpoint_gt_even = 0;\n-    }\n-    if (ind <= 0) { // 0 <= -ind\n-      // the result is exact\n-      res.w[1] = (x_exp + y_exp - BIN_EXP_BIAS) | C.w[1];\n-      res.w[0] = C.w[0];\n-\n-      // because the result is exact the U and I status flags are not set\n-    } else {\n-\n-      // if ind > 0 <=> 1 <= ind <= q - 1; must remove ind digits\n-      // from C, which may have up to 68 digits; note that q >= ind + 1 >= 2\n-      // Note: there is no underflow in some cases when the coefficient of\n-      // the result is 10^33 or 10^33 - 1\n-      if (q <= 18) { // 2 <= q <= 18\n-        __bid_round64_2_18 (q, ind, C.w[0], &res.w[0], &incr_exp,\n-                      &is_midpoint_lt_even, &is_midpoint_gt_even,\n-                      &is_inexact_lt_midpoint, &is_inexact_gt_midpoint);\n-        if (incr_exp) {\n-\n-          // multiply by 10; this cannot be 10^33\n-          __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n-          res.w[1] |= (UINT64) EXP_MIN;\n-        } else { // underflow\n-          res.w[1] = (UINT64) EXP_MIN;\n-        }\n-        if (is_midpoint_lt_even || is_midpoint_gt_even\n-            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n-\n-          // set the inexact and underflow flags\n-          *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n-        }\n-      } else if (q <= 38) { // 19 <= q <= 38\n-        P128.w[1] = C.w[1];\n-        P128.w[0] = C.w[0];\n-        __bid_round128_19_38 (q, ind, P128, &res, &incr_exp,\n-                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n-                        &is_inexact_lt_midpoint,\n-                        &is_inexact_gt_midpoint);\n-        if (incr_exp) {\n-\n-          // multiply by 10 and check is this is 10^33, because in that case\n-          // it is possible that this is not underflow\n-          if (q - ind <= 19) {\n-            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n-          } else { // if 20 <= q - ind\n-            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n-          }\n-          if ((q - ind + 1) == P34) { // the result is 10^(P34-1)\n-            // if the result rounded directly to P34 digits is the same, then\n-            // there is no underflow\n-            __bid_round128_19_38 (q, ind - 1, P128, &R128, &incr_exp1,\n-                            &is_midpoint_lt_even1,\n-                            &is_midpoint_gt_even1,\n-                            &is_inexact_lt_midpoint1,\n-                            &is_inexact_gt_midpoint1);\n-            if (res.w[1] == R128.w[1] && res.w[0] == R128.w[0]) {\n-              no_underflow = 1;\n-            }\n-          }\n-          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n-        } else { // underflow\n-          // res.w[1] = (UINT64)EXP_MIN | res.w[1]; // redundant\n-        }\n-        if (is_midpoint_lt_even || is_midpoint_gt_even\n-            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n-\n-          // set the inexact and underflow flags\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          is_inexact = 1;\n-          if (!no_underflow)\n-            *pfpsf |= UNDERFLOW_EXCEPTION;\n-        }\n-      } else if (q <= 57) { // 39 <= q <= 57\n-        P192.w[2] = C.w[2];\n-        P192.w[1] = C.w[1];\n-        P192.w[0] = C.w[0];\n-        __bid_round192_39_57 (q, ind, P192, &R192, &incr_exp,\n-                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n-                        &is_inexact_lt_midpoint,\n-                        &is_inexact_gt_midpoint);\n-        if (incr_exp) {\n-\n-          // multiply by 10 and check is this is 10^33, because in that case\n-          // it is possible that this is not underflow\n-          res.w[1] = R192.w[1]; // res has q - ind digits\n-          res.w[0] = R192.w[0];\n-          if (q - ind <= 19) {\n-            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n-          } else { // if 20 <= q - ind\n-            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n-          }\n-          if ((q - ind + 1) == P34) { // the result is 10^(P34-1) \n-            // if the result rounded directly to P34 digits is the same, then\n-            // there is no underflow\n-            __bid_round192_39_57 (q, ind - 1, P192, &R192, &incr_exp1,\n-                            &is_midpoint_lt_even1,\n-                            &is_midpoint_gt_even1,\n-                            &is_inexact_lt_midpoint1,\n-                            &is_inexact_gt_midpoint1);\n-            if (res.w[1] == R192.w[1] && res.w[0] == R192.w[0]) {\n-              no_underflow = 1;\n-            }\n-          }\n-          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n-        } else { // underflow\n-          res.w[1] = (UINT64) EXP_MIN | R192.w[1];\n-          res.w[0] = R192.w[0];\n-        }\n-        if (is_midpoint_lt_even || is_midpoint_gt_even\n-            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n-\n-          // set the inexact and underflow flags\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          is_inexact = 1;\n-          if (!no_underflow)\n-            *pfpsf |= UNDERFLOW_EXCEPTION;\n-        }\n-      } else if (q <= 76) { // 58 <= q <= 76 (actually 58 <= q <= 68)\n-        P256.w[3] = C.w[3];\n-        P256.w[2] = C.w[2];\n-        P256.w[1] = C.w[1];\n-        P256.w[0] = C.w[0];\n-        __bid_round256_58_76 (q, ind, P256, &R256, &incr_exp,\n-                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n-                        &is_inexact_lt_midpoint,\n-                        &is_inexact_gt_midpoint);\n-        if (incr_exp) {\n-\n-          // multiply by 10 and check is this is 10^33, because in that case\n-          // it is possible that this is not underflow\n-          res.w[1] = R256.w[1]; // res has q - ind digits\n-          res.w[0] = R256.w[0];\n-          if (q - ind <= 19) {\n-            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n-          } else { // if 20 <= q - ind\n-            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n-          }\n-          if ((q - ind + 1) == P34) { // the result is 10^(P34-1) \n-            // if the result rounded directly to P34 digits is the same, then\n-            // there is no underflow\n-            __bid_round256_58_76 (q, ind - 1, P256, &R256, &incr_exp1,\n-                            &is_midpoint_lt_even1,\n-                            &is_midpoint_gt_even1,\n-                            &is_inexact_lt_midpoint1,\n-                            &is_inexact_gt_midpoint1);\n-            if (res.w[1] == R256.w[1] && res.w[0] == R256.w[0]) {\n-              no_underflow = 1;\n-            }\n-          }\n-          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n-        } else { // underflow\n-          res.w[1] = (UINT64) EXP_MIN | R256.w[1];\n-          res.w[0] = R256.w[0];\n-        }\n-        if (is_midpoint_lt_even || is_midpoint_gt_even\n-            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n-\n-          // set the inexact and underflow flags\n-          *pfpsf |= INEXACT_EXCEPTION;\n-          is_inexact = 1;\n-          if (!no_underflow)\n-            *pfpsf |= UNDERFLOW_EXCEPTION;\n-        }\n-      }\n-    }\n \n-    // general correction from RN to RA, RM, RP, RZ\n-    if (rnd_mode != ROUNDING_TO_NEAREST) {\n-      x_exp = res.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n-      // this must be e_min\n-      C1_hi = res.w[1] & MASK_COEFF;\n-      C1_lo = res.w[0];\n-      if ((!sign && ((rnd_mode == ROUNDING_UP && is_inexact_lt_midpoint) || \n-          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_UP) && \n-          is_midpoint_gt_even))) || \n-          (sign && ((rnd_mode == ROUNDING_DOWN && is_inexact_lt_midpoint) || \n-          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_DOWN) && \n-          is_midpoint_gt_even)))) {\n-\n-        // C1 = C1 + 1\n-        C1_lo = C1_lo + 1;\n-        if (C1_lo == 0) { // rounding overflow in the low 64 bits\n-          C1_hi = C1_hi + 1;\n-          if (C1_hi == 0x0001ed09bead87c0ull\n-              && C1_lo == 0x378d8e6400000000ull) {\n-\n-            // C1 = 10^34 => rounding overflow (not possible) TO CHECK\n-            C1_hi = 0x0000314dc6448d93ull;\n-            C1_lo = 0x38c15b0a00000000ull; // 10^33\n-            x_exp = x_exp + EXP_P1; // this must be e_min\n-          }\n-        }\n-      } else if ((is_midpoint_lt_even || is_inexact_gt_midpoint) && \n-          ((sign && \n-          (rnd_mode == ROUNDING_UP || rnd_mode == ROUNDING_TO_ZERO)) || \n-          (!sign && \n-          (rnd_mode == ROUNDING_DOWN || rnd_mode == ROUNDING_TO_ZERO)))) {\n-\n-        // C1 = C1 - 1 (the exponent is emin already)\n-        C1_lo = C1_lo - 1;\n-        if (C1_lo == 0xffffffffffffffffull)\n-          C1_hi--;\n-\n-        // cannot cross into the lower decade anymore, but the result can be 0\n-      } else {\n-        ; // exact, the result is already correct\n-      }\n-\n-      // no overflow is possible\n-      // assemble the result\n-      res.w[1] = x_exp | C1_hi;\n-      res.w[0] = C1_lo;\n-\n-      // Now fix the case where the general rounding routine returned a non-tiny\n-      // result, but after the correction for rounding modes other than to\n-      // nearest, the result is less in magnitude than 100...0[34] * 10^(-6176)\n-      // (this is due to the fact that the general rounding routine works only\n-      // with rounding to nearest)\n-      if (is_inexact && (x_exp == EXP_MIN)\n-          && (C1_hi < 0x0000314dc6448d93ull\n-              || (C1_hi == 0x0000314dc6448d93ull\n-              && C1_lo < 0x38c15b0a00000000ull))) {\n-        *pfpsf |= UNDERFLOW_EXCEPTION;\n-      }\n-    }\n-  }\n-  res.w[1] |= sign;\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n+  BID_SWAP128 (z);\n+  // swap x and y - ensure that a NaN in x has 'higher precedence' than one in y\n+#if DECIMAL_CALL_BY_REFERENCE\n+  bid128_fma (&res, &y, &x, &z\n+\t      _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t      _EXC_INFO_ARG);\n+#else\n+  res = bid128_fma (y, x, z\n+\t\t    _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t    _EXC_INFO_ARG);\n+#endif\n   BID_RETURN (res);\n }"}, {"sha": "1f7d2b113b3ab4f072c323e25e8e8bab5a2d348b", "filename": "libgcc/config/libbid/bid128_next.c", "status": "modified", "additions": 427, "deletions": 351, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -35,14 +35,14 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_nextup (UINT128 * pres,\n-               UINT128 *\n-               px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_nextup (UINT128 * pres,\n+\t       UINT128 *\n+\t       px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n UINT128\n-__bid128_nextup (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-               _EXC_INFO_PARAM) {\n+bid128_nextup (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t       _EXC_INFO_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -52,176 +52,185 @@ __bid128_nextup (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n   BID_UI64DOUBLE tmp1;\n   int x_nr_bits;\n   int q1, ind;\n-  UINT128 C1;   // C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+  UINT128 C1;\t\t\t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   // unpack the argument\n-  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n-  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n   C1.w[1] = x.w[1] & MASK_COEFF;\n   C1.w[0] = x.w[0];\n \n   // check for NaN or Infinity\n   if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n     // x is special\n-    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n-        // return quiet (x)\n-        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = x.w[0];\n-      } else { // x is QNaN\n-        // return x\n-        res.w[1] = x.w[1];\n-        res.w[0] = x.w[0];\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      // if x = NaN, then res = Q (x)\n+      // check first for non-canonical NaN payload\n+      if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t  (((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull)\n+\t   && (x.w[0] > 0x38c15b09ffffffffull))) {\n+\tx.w[1] = x.w[1] & 0xffffc00000000000ull;\n+\tx.w[0] = 0x0ull;\n       }\n-    } else { // x is not NaN, so it must be infinity\n-      if (!x_sign) { // x is +inf\n-        res.w[1] = 0x7800000000000000ull; // +inf\n-        res.w[0] = 0x0000000000000000ull;\n-      } else { // x is -inf\n-        res.w[1] = 0xdfffed09bead87c0ull; // -MAXFP = -999...99 * 10^emax\n-        res.w[0] = 0x378d8e63ffffffffull;\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out also G[6]-G[16]\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return x\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out G[6]-G[16]\n+\tres.w[0] = x.w[0];\n+      }\n+    } else {\t// x is not NaN, so it must be infinity\n+      if (!x_sign) {\t// x is +inf\n+\tres.w[1] = 0x7800000000000000ull;\t// +inf\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf\n+\tres.w[1] = 0xdfffed09bead87c0ull;\t// -MAXFP = -999...99 * 10^emax\n+\tres.w[0] = 0x378d8e63ffffffffull;\n       }\n     }\n     BID_RETURN (res);\n   }\n-  // test for non-canonical values of the argument x\n-  // - values whose encoding begins with x00, x01, or x10 and whose\n-  //   coefficient is larger than 10^34 -1, or\n-  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n-  //   and infinitis were eliminated already this test is reduced to\n-  //   checking for x10x)\n-  if ((((C1.w[1] > 0x0001ed09bead87c0ull) || \n-      ((C1.w[1] == 0x0001ed09bead87c0ull) && (C1.w[0] > 0x378d8e63ffffffffull)))\n-      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n-    x.w[1] = 0;\n-    x.w[0] = 0;\n-    C1.w[1] = 0;\n-    C1.w[0] = 0;\n+  // check for non-canonical values (treated as zero)\n+  if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\t// G0_G1=11\n+    // non-canonical\n+    x_exp = (x.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+    C1.w[1] = 0;\t// significand high\n+    C1.w[0] = 0;\t// significand low\n+  } else {\t// G0_G1 != 11\n+    x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+    if (C1.w[1] > 0x0001ed09bead87c0ull ||\n+\t(C1.w[1] == 0x0001ed09bead87c0ull\n+\t && C1.w[0] > 0x378d8e63ffffffffull)) {\n+      // x is non-canonical if coefficient is larger than 10^34 -1\n+      C1.w[1] = 0;\n+      C1.w[0] = 0;\n+    } else {\t// canonical\n+      ;\n+    }\n   }\n \n   if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n     // x is +/-0\n-    res.w[1] = 0x0000000000000000ull; // +1 * 10^emin\n+    res.w[1] = 0x0000000000000000ull;\t// +1 * 10^emin\n     res.w[0] = 0x0000000000000001ull;\n-  } else { // x is not special and is not zero\n+  } else {\t// x is not special and is not zero\n     if (x.w[1] == 0x5fffed09bead87c0ull\n-        && x.w[0] == 0x378d8e63ffffffffull) {\n+\t&& x.w[0] == 0x378d8e63ffffffffull) {\n       // x = +MAXFP = 999...99 * 10^emax\n-      res.w[1] = 0x7800000000000000ull; // +inf\n+      res.w[1] = 0x7800000000000000ull;\t// +inf\n       res.w[0] = 0x0000000000000000ull;\n     } else if (x.w[1] == 0x8000000000000000ull\n-               && x.w[0] == 0x0000000000000001ull) {\n+\t       && x.w[0] == 0x0000000000000001ull) {\n       // x = -MINFP = 1...99 * 10^emin\n-      res.w[1] = 0x8000000000000000ull; // -0\n+      res.w[1] = 0x8000000000000000ull;\t// -0\n       res.w[0] = 0x0000000000000000ull;\n-    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+    } else {\t// -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n       // can add/subtract 1 ulp to the significand\n \n       // Note: we could check here if x >= 10^34 to speed up the case q1 = 34\n       // q1 = nr. of decimal digits in x\n       // determine first the nr. of bits in x\n       if (C1.w[1] == 0) {\n-        if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n-          // split the 64-bit value in two 32-bit halves to avoid rnd errors\n-          if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n-            tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n-            x_nr_bits =\n-              33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n-                    0x3ff);\n-          } else { // x < 2^32\n-            tmp1.d = (double) (C1.w[0]); // exact conversion\n-            x_nr_bits =\n-              1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-          }\n-        } else { // if x < 2^53\n-          tmp1.d = (double) C1.w[0]; // exact conversion\n-          x_nr_bits =\n-            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-        }\n-      } else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n-        tmp1.d = (double) C1.w[1]; // exact conversion\n-        x_nr_bits =\n-          65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\tif (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+\t  // split the 64-bit value in two 32-bit halves to avoid rnd errors\n+\t  if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\t    tmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\t    x_nr_bits =\n+\t      33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+\t\t    0x3ff);\n+\t  } else {\t// x < 2^32\n+\t    tmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\t    x_nr_bits =\n+\t      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+\t\t   0x3ff);\n+\t  }\n+\t} else {\t// if x < 2^53\n+\t  tmp1.d = (double) C1.w[0];\t// exact conversion\n+\t  x_nr_bits =\n+\t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t}\n+      } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+\ttmp1.d = (double) C1.w[1];\t// exact conversion\n+\tx_nr_bits =\n+\t  65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      q1 = nr_digits[x_nr_bits - 1].digits;\n       if (q1 == 0) {\n-        q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n-        if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-            || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-            && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n-          q1++;\n+\tq1 = nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1.w[1] > nr_digits[x_nr_bits - 1].threshold_hi\n+\t    || (C1.w[1] == nr_digits[x_nr_bits - 1].threshold_hi\n+\t\t&& C1.w[0] >= nr_digits[x_nr_bits - 1].threshold_lo))\n+\t  q1++;\n       }\n       // if q1 < P34 then pad the significand with zeros\n       if (q1 < P34) {\n-        exp = (x_exp >> 49) - 6176;\n-        if (exp + 6176 > P34 - q1) {\n-          ind = P34 - q1; // 1 <= ind <= P34 - 1\n-          // pad with P34 - q1 zeros, until exponent = emin\n-          // C1 = C1 * 10^ind\n-          if (q1 <= 19) { // 64-bit C1\n-            if (ind <= 19) { // 64-bit 10^ind and 64-bit C1\n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 128-bit 10^ind and 64-bit C1\n-              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-            }\n-          } else { // C1 is (most likely) 128-bit\n-            if (ind <= 14) { // 64-bit 10^ind and 128-bit C1 (most likely)\n-              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n-            } else if (ind <= 19) { // 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n-              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-            }\n-          }\n-          x_exp = x_exp - ((UINT64) ind << 49);\n-        } else { // pad with zeros until the exponent reaches emin\n-          ind = exp + 6176;\n-          // C1 = C1 * 10^ind\n-          if (ind <= 19) { // 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n-            if (q1 <= 19) { // 64-bit C1, 64-bit 10^ind \n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n-              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n-            }\n-          } else { // if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n-            // 64-bit C1, 128-bit 10^ind\n-            __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-          }\n-          x_exp = EXP_MIN;\n-        }\n+\texp = (x_exp >> 49) - 6176;\n+\tif (exp + 6176 > P34 - q1) {\n+\t  ind = P34 - q1;\t// 1 <= ind <= P34 - 1\n+\t  // pad with P34 - q1 zeros, until exponent = emin\n+\t  // C1 = C1 * 10^ind\n+\t  if (q1 <= 19) {\t// 64-bit C1\n+\t    if (ind <= 19) {\t// 64-bit 10^ind and 64-bit C1\n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 128-bit 10^ind and 64-bit C1\n+\t      __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t    }\n+\t  } else {\t// C1 is (most likely) 128-bit\n+\t    if (ind <= 14) {\t// 64-bit 10^ind and 128-bit C1 (most likely)\n+\t      __mul_128x64_to_128 (C1, ten2k64[ind], C1);\n+\t    } else if (ind <= 19) {\t// 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n+\t      __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t    }\n+\t  }\n+\t  x_exp = x_exp - ((UINT64) ind << 49);\n+\t} else {\t// pad with zeros until the exponent reaches emin\n+\t  ind = exp + 6176;\n+\t  // C1 = C1 * 10^ind\n+\t  if (ind <= 19) {\t// 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n+\t    if (q1 <= 19) {\t// 64-bit C1, 64-bit 10^ind \n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n+\t      __mul_128x64_to_128 (C1, ten2k64[ind], C1);\n+\t    }\n+\t  } else {\t// if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n+\t    // 64-bit C1, 128-bit 10^ind\n+\t    __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t  }\n+\t  x_exp = EXP_MIN;\n+\t}\n       }\n-      if (!x_sign) { // x > 0\n-        // add 1 ulp (add 1 to the significand)\n-        C1.w[0]++;\n-        if (C1.w[0] == 0)\n-          C1.w[1]++;\n-        if (C1.w[1] == 0x0001ed09bead87c0ull && \n-            C1.w[0] == 0x378d8e6400000000ull) { // if  C1 = 10^34\n-          C1.w[1] = 0x0000314dc6448d93ull; // C1 = 10^33\n-          C1.w[0] = 0x38c15b0a00000000ull;\n-          x_exp = x_exp + EXP_P1;\n-        }\n-      } else { // x < 0\n-        // subtract 1 ulp (subtract 1 from the significand)\n-        C1.w[0]--;\n-        if (C1.w[0] == 0xffffffffffffffffull)\n-          C1.w[1]--;\n-        if (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && \n-            C1.w[0] == 0x38c15b09ffffffffull) { // if  C1 = 10^33 - 1\n-          C1.w[1] = 0x0001ed09bead87c0ull; // C1 = 10^34 - 1\n-          C1.w[0] = 0x378d8e63ffffffffull;\n-          x_exp = x_exp - EXP_P1;\n-        }\n+      if (!x_sign) {\t// x > 0\n+\t// add 1 ulp (add 1 to the significand)\n+\tC1.w[0]++;\n+\tif (C1.w[0] == 0)\n+\t  C1.w[1]++;\n+\tif (C1.w[1] == 0x0001ed09bead87c0ull && C1.w[0] == 0x378d8e6400000000ull) {\t// if  C1 = 10^34\n+\t  C1.w[1] = 0x0000314dc6448d93ull;\t// C1 = 10^33\n+\t  C1.w[0] = 0x38c15b0a00000000ull;\n+\t  x_exp = x_exp + EXP_P1;\n+\t}\n+      } else {\t// x < 0\n+\t// subtract 1 ulp (subtract 1 from the significand)\n+\tC1.w[0]--;\n+\tif (C1.w[0] == 0xffffffffffffffffull)\n+\t  C1.w[1]--;\n+\tif (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && C1.w[0] == 0x38c15b09ffffffffull) {\t// if  C1 = 10^33 - 1\n+\t  C1.w[1] = 0x0001ed09bead87c0ull;\t// C1 = 10^34 - 1\n+\t  C1.w[0] = 0x378d8e63ffffffffull;\n+\t  x_exp = x_exp - EXP_P1;\n+\t}\n       }\n       // assemble the result\n       res.w[1] = x_sign | x_exp | C1.w[1];\n       res.w[0] = C1.w[0];\n-    }        // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n-  }        // end x is not special and is not zero\n+    }\t// end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  }\t// end x is not special and is not zero\n   BID_RETURN (res);\n }\n \n@@ -231,14 +240,14 @@ __bid128_nextup (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_nextdown (UINT128 * pres,\n-                 UINT128 *\n-                 px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_nextdown (UINT128 * pres,\n+\t\t UINT128 *\n+\t\t px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n UINT128\n-__bid128_nextdown (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-                 _EXC_INFO_PARAM) {\n+bid128_nextdown (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t _EXC_INFO_PARAM) {\n #endif\n \n   UINT128 res;\n@@ -248,174 +257,183 @@ __bid128_nextdown (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n   BID_UI64DOUBLE tmp1;\n   int x_nr_bits;\n   int q1, ind;\n-  UINT128 C1;   // C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+  UINT128 C1;\t\t\t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   // unpack the argument\n-  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n-  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n   C1.w[1] = x.w[1] & MASK_COEFF;\n   C1.w[0] = x.w[0];\n \n   // check for NaN or Infinity\n   if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n     // x is special\n-    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n-        // return quiet (x)\n-        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = x.w[0];\n-      } else { // x is QNaN\n-        // return x\n-        res.w[1] = x.w[1];\n-        res.w[0] = x.w[0];\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      // if x = NaN, then res = Q (x)\n+      // check first for non-canonical NaN payload\n+      if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t  (((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull)\n+\t   && (x.w[0] > 0x38c15b09ffffffffull))) {\n+\tx.w[1] = x.w[1] & 0xffffc00000000000ull;\n+\tx.w[0] = 0x0ull;\n+      }\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out also G[6]-G[16]\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return x\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out G[6]-G[16]\n+\tres.w[0] = x.w[0];\n       }\n-    } else { // x is not NaN, so it must be infinity\n-      if (!x_sign) { // x is +inf\n-        res.w[1] = 0x5fffed09bead87c0ull; // +MAXFP = +999...99 * 10^emax\n-        res.w[0] = 0x378d8e63ffffffffull;\n-      } else { // x is -inf\n-        res.w[1] = 0xf800000000000000ull; // -inf\n-        res.w[0] = 0x0000000000000000ull;\n+    } else {\t// x is not NaN, so it must be infinity\n+      if (!x_sign) {\t// x is +inf\n+\tres.w[1] = 0x5fffed09bead87c0ull;\t// +MAXFP = +999...99 * 10^emax\n+\tres.w[0] = 0x378d8e63ffffffffull;\n+      } else {\t// x is -inf\n+\tres.w[1] = 0xf800000000000000ull;\t// -inf\n+\tres.w[0] = 0x0000000000000000ull;\n       }\n     }\n     BID_RETURN (res);\n   }\n-  // test for non-canonical values of the argument x\n-  // - values whose encoding begins with x00, x01, or x10 and whose\n-  //   coefficient is larger than 10^34 -1, or\n-  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n-  //   and infinitis were eliminated already this test is reduced to\n-  //   checking for x10x)\n-  if ((((C1.w[1] > 0x0001ed09bead87c0ull) || ((C1.w[1] == 0x0001ed09bead87c0ull)\n-      && (C1.w[0] > 0x378d8e63ffffffffull))) && \n-      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n-    x.w[1] = 0;\n-    x.w[0] = 0;\n-    C1.w[1] = 0;\n-    C1.w[0] = 0;\n+  // check for non-canonical values (treated as zero)\n+  if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\t// G0_G1=11\n+    // non-canonical\n+    x_exp = (x.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+    C1.w[1] = 0;\t// significand high\n+    C1.w[0] = 0;\t// significand low\n+  } else {\t// G0_G1 != 11\n+    x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+    if (C1.w[1] > 0x0001ed09bead87c0ull ||\n+\t(C1.w[1] == 0x0001ed09bead87c0ull\n+\t && C1.w[0] > 0x378d8e63ffffffffull)) {\n+      // x is non-canonical if coefficient is larger than 10^34 -1\n+      C1.w[1] = 0;\n+      C1.w[0] = 0;\n+    } else {\t// canonical\n+      ;\n+    }\n   }\n \n   if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n     // x is +/-0\n-    res.w[1] = 0x8000000000000000ull; // -1 * 10^emin\n+    res.w[1] = 0x8000000000000000ull;\t// -1 * 10^emin\n     res.w[0] = 0x0000000000000001ull;\n-  } else { // x is not special and is not zero\n+  } else {\t// x is not special and is not zero\n     if (x.w[1] == 0xdfffed09bead87c0ull\n-        && x.w[0] == 0x378d8e63ffffffffull) {\n+\t&& x.w[0] == 0x378d8e63ffffffffull) {\n       // x = -MAXFP = -999...99 * 10^emax\n-      res.w[1] = 0xf800000000000000ull; // -inf\n+      res.w[1] = 0xf800000000000000ull;\t// -inf\n       res.w[0] = 0x0000000000000000ull;\n-    } else if (x.w[1] == 0x0ull && x.w[0] == 0x0000000000000001ull) { // +MINFP\n-      res.w[1] = 0x0000000000000000ull; // +0\n+    } else if (x.w[1] == 0x0ull && x.w[0] == 0x0000000000000001ull) {\t// +MINFP\n+      res.w[1] = 0x0000000000000000ull;\t// +0\n       res.w[0] = 0x0000000000000000ull;\n-    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+    } else {\t// -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n       // can add/subtract 1 ulp to the significand\n \n       // Note: we could check here if x >= 10^34 to speed up the case q1 = 34\n       // q1 = nr. of decimal digits in x\n       // determine first the nr. of bits in x\n       if (C1.w[1] == 0) {\n-        if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n-          // split the 64-bit value in two 32-bit halves to avoid rnd errors\n-          if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n-            tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n-            x_nr_bits =\n-              33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n-                    0x3ff);\n-          } else { // x < 2^32\n-            tmp1.d = (double) (C1.w[0]); // exact conversion\n-            x_nr_bits =\n-              1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-          }\n-        } else { // if x < 2^53\n-          tmp1.d = (double) C1.w[0]; // exact conversion\n-          x_nr_bits =\n-            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-        }\n-      } else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n-        tmp1.d = (double) C1.w[1]; // exact conversion\n-        x_nr_bits =\n-          65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\tif (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+\t  // split the 64-bit value in two 32-bit halves to avoid rnd errors\n+\t  if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\t    tmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\t    x_nr_bits =\n+\t      33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+\t\t    0x3ff);\n+\t  } else {\t// x < 2^32\n+\t    tmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\t    x_nr_bits =\n+\t      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+\t\t   0x3ff);\n+\t  }\n+\t} else {\t// if x < 2^53\n+\t  tmp1.d = (double) C1.w[0];\t// exact conversion\n+\t  x_nr_bits =\n+\t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t}\n+      } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+\ttmp1.d = (double) C1.w[1];\t// exact conversion\n+\tx_nr_bits =\n+\t  65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      q1 = nr_digits[x_nr_bits - 1].digits;\n       if (q1 == 0) {\n-        q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n-        if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-            || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-            && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n-          q1++;\n+\tq1 = nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1.w[1] > nr_digits[x_nr_bits - 1].threshold_hi\n+\t    || (C1.w[1] == nr_digits[x_nr_bits - 1].threshold_hi\n+\t\t&& C1.w[0] >= nr_digits[x_nr_bits - 1].threshold_lo))\n+\t  q1++;\n       }\n       // if q1 < P then pad the significand with zeros\n       if (q1 < P34) {\n-        exp = (x_exp >> 49) - 6176;\n-        if (exp + 6176 > P34 - q1) {\n-          ind = P34 - q1; // 1 <= ind <= P34 - 1\n-          // pad with P34 - q1 zeros, until exponent = emin\n-          // C1 = C1 * 10^ind\n-          if (q1 <= 19) { // 64-bit C1\n-            if (ind <= 19) { // 64-bit 10^ind and 64-bit C1\n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 128-bit 10^ind and 64-bit C1\n-              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-            }\n-          } else { // C1 is (most likely) 128-bit\n-            if (ind <= 14) { // 64-bit 10^ind and 128-bit C1 (most likely)\n-              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n-            } else if (ind <= 19) { // 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n-              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-            }\n-          }\n-          x_exp = x_exp - ((UINT64) ind << 49);\n-        } else { // pad with zeros until the exponent reaches emin\n-          ind = exp + 6176;\n-          // C1 = C1 * 10^ind\n-          if (ind <= 19) { // 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n-            if (q1 <= 19) { // 64-bit C1, 64-bit 10^ind \n-              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n-            } else { // 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n-              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n-            }\n-          } else { // if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n-            // 64-bit C1, 128-bit 10^ind\n-            __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n-          }\n-          x_exp = EXP_MIN;\n-        }\n+\texp = (x_exp >> 49) - 6176;\n+\tif (exp + 6176 > P34 - q1) {\n+\t  ind = P34 - q1;\t// 1 <= ind <= P34 - 1\n+\t  // pad with P34 - q1 zeros, until exponent = emin\n+\t  // C1 = C1 * 10^ind\n+\t  if (q1 <= 19) {\t// 64-bit C1\n+\t    if (ind <= 19) {\t// 64-bit 10^ind and 64-bit C1\n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 128-bit 10^ind and 64-bit C1\n+\t      __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t    }\n+\t  } else {\t// C1 is (most likely) 128-bit\n+\t    if (ind <= 14) {\t// 64-bit 10^ind and 128-bit C1 (most likely)\n+\t      __mul_128x64_to_128 (C1, ten2k64[ind], C1);\n+\t    } else if (ind <= 19) {\t// 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n+\t      __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t    }\n+\t  }\n+\t  x_exp = x_exp - ((UINT64) ind << 49);\n+\t} else {\t// pad with zeros until the exponent reaches emin\n+\t  ind = exp + 6176;\n+\t  // C1 = C1 * 10^ind\n+\t  if (ind <= 19) {\t// 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n+\t    if (q1 <= 19) {\t// 64-bit C1, 64-bit 10^ind \n+\t      __mul_64x64_to_128MACH (C1, C1.w[0], ten2k64[ind]);\n+\t    } else {\t// 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n+\t      __mul_128x64_to_128 (C1, ten2k64[ind], C1);\n+\t    }\n+\t  } else {\t// if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n+\t    // 64-bit C1, 128-bit 10^ind\n+\t    __mul_128x64_to_128 (C1, C1.w[0], ten2k128[ind - 20]);\n+\t  }\n+\t  x_exp = EXP_MIN;\n+\t}\n       }\n-      if (x_sign) { // x < 0\n-        // add 1 ulp (add 1 to the significand)\n-        C1.w[0]++;\n-        if (C1.w[0] == 0)\n-          C1.w[1]++;\n-        if (C1.w[1] == 0x0001ed09bead87c0ull && \n-            C1.w[0] == 0x378d8e6400000000ull) { // if  C1 = 10^34\n-          C1.w[1] = 0x0000314dc6448d93ull; // C1 = 10^33\n-          C1.w[0] = 0x38c15b0a00000000ull;\n-          x_exp = x_exp + EXP_P1;\n-        }\n-      } else { // x > 0\n-        // subtract 1 ulp (subtract 1 from the significand)\n-        C1.w[0]--;\n-        if (C1.w[0] == 0xffffffffffffffffull)\n-          C1.w[1]--;\n-        if (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && \n-            C1.w[0] == 0x38c15b09ffffffffull) { // if  C1 = 10^33 - 1\n-          C1.w[1] = 0x0001ed09bead87c0ull; // C1 = 10^34 - 1\n-          C1.w[0] = 0x378d8e63ffffffffull;\n-          x_exp = x_exp - EXP_P1;\n-        }\n+      if (x_sign) {\t// x < 0\n+\t// add 1 ulp (add 1 to the significand)\n+\tC1.w[0]++;\n+\tif (C1.w[0] == 0)\n+\t  C1.w[1]++;\n+\tif (C1.w[1] == 0x0001ed09bead87c0ull && C1.w[0] == 0x378d8e6400000000ull) {\t// if  C1 = 10^34\n+\t  C1.w[1] = 0x0000314dc6448d93ull;\t// C1 = 10^33\n+\t  C1.w[0] = 0x38c15b0a00000000ull;\n+\t  x_exp = x_exp + EXP_P1;\n+\t}\n+      } else {\t// x > 0\n+\t// subtract 1 ulp (subtract 1 from the significand)\n+\tC1.w[0]--;\n+\tif (C1.w[0] == 0xffffffffffffffffull)\n+\t  C1.w[1]--;\n+\tif (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && C1.w[0] == 0x38c15b09ffffffffull) {\t// if  C1 = 10^33 - 1\n+\t  C1.w[1] = 0x0001ed09bead87c0ull;\t// C1 = 10^34 - 1\n+\t  C1.w[0] = 0x378d8e63ffffffffull;\n+\t  x_exp = x_exp - EXP_P1;\n+\t}\n       }\n       // assemble the result\n       res.w[1] = x_sign | x_exp | C1.w[1];\n       res.w[0] = C1.w[0];\n-    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n-  } // end x is not special and is not zero\n+    }\t// end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  }\t// end x is not special and is not zero\n   BID_RETURN (res);\n }\n \n@@ -425,108 +443,164 @@ __bid128_nextdown (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_nextafter (UINT128 * pres, UINT128 * px,\n-                  UINT128 *\n-                  py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) \n+bid128_nextafter (UINT128 * pres, UINT128 * px,\n+\t\t  UINT128 *\n+\t\t  py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) \n {\n   UINT128 x = *px;\n   UINT128 y = *py;\n   UINT128 xnswp = *px;\n   UINT128 ynswp = *py;\n #else\n UINT128\n-__bid128_nextafter (UINT128 x,\n-                  UINT128 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-                  _EXC_INFO_PARAM) {\n+bid128_nextafter (UINT128 x,\n+\t\t  UINT128 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t  _EXC_INFO_PARAM) {\n   UINT128 xnswp = x;\n   UINT128 ynswp = y;\n #endif\n \n   UINT128 res;\n-  UINT128 tmp1, tmp2;\n-  FPSC tmp_fpsf = 0; // dummy fpsf for calls to comparison functions\n+  UINT128 tmp1, tmp2, tmp3;\n+  FPSC tmp_fpsf = 0;\t\t// dummy fpsf for calls to comparison functions\n   int res1, res2;\n+  UINT64 x_exp;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n+\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n   // check for NaNs\n   if (((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL)\n       || ((y.w[1] & MASK_SPECIAL) == MASK_SPECIAL)) {\n     // x is special or y is special\n-\n-    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n-        // return quiet (x)\n-        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = x.w[0];\n-      } else { // x is QNaN\n-        if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-          // set invalid flag\n-          *pfpsf |= INVALID_EXCEPTION;\n-        }\n-        // return x\n-        res.w[1] = x.w[1];\n-        res.w[0] = x.w[0];\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      // if x = NaN, then res = Q (x)\n+      // check first for non-canonical NaN payload\n+      if (((x.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t  (((x.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull)\n+\t   && (x.w[0] > 0x38c15b09ffffffffull))) {\n+\tx.w[1] = x.w[1] & 0xffffc00000000000ull;\n+\tx.w[0] = 0x0ull;\n+      }\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out also G[6]-G[16]\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return x\n+\tres.w[1] = x.w[1] & 0xfc003fffffffffffull;\t// clear out G[6]-G[16]\n+\tres.w[0] = x.w[0];\n+\tif ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  // set invalid flag\n+\t  *pfpsf |= INVALID_EXCEPTION;\n+\t}\n+      }\n+      BID_RETURN (res)\n+    } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+      // if x = NaN, then res = Q (x)\n+      // check first for non-canonical NaN payload\n+      if (((y.w[1] & 0x00003fffffffffffull) > 0x0000314dc6448d93ull) ||\n+\t  (((y.w[1] & 0x00003fffffffffffull) == 0x0000314dc6448d93ull)\n+\t   && (y.w[0] > 0x38c15b09ffffffffull))) {\n+\ty.w[1] = y.w[1] & 0xffffc00000000000ull;\n+\ty.w[0] = 0x0ull;\n+      }\n+      if ((y.w[1] & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres.w[1] = y.w[1] & 0xfc003fffffffffffull;\t// clear out also G[6]-G[16]\n+\tres.w[0] = y.w[0];\n+      } else {\t// x is QNaN\n+\t// return x\n+\tres.w[1] = y.w[1] & 0xfc003fffffffffffull;\t// clear out G[6]-G[16]\n+\tres.w[0] = y.w[0];\n       }\n-      BID_RETURN (res);\n-    } else if ((y.w[1] & MASK_NAN) == MASK_NAN) { // y is NAN\n-      if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n-        // set invalid flag\n-        *pfpsf |= INVALID_EXCEPTION;\n-        // return quiet (y)\n-        res.w[1] = y.w[1] & 0xfdffffffffffffffull;\n-        res.w[0] = y.w[0];\n-      } else { // y is QNaN\n-        // return y\n-        res.w[1] = y.w[1];\n-        res.w[0] = y.w[0];\n+      BID_RETURN (res)\n+    } else {\t// at least one is infinity\n+      if ((x.w[1] & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+\tx.w[1] = x.w[1] & (MASK_SIGN | MASK_INF);\n+\tx.w[0] = 0x0ull;\n+      }\n+      if ((y.w[1] & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+\ty.w[1] = y.w[1] & (MASK_SIGN | MASK_INF);\n+\ty.w[0] = 0x0ull;\n       }\n-      BID_RETURN (res);\n-    } else {\n-      ; // let infinities fall through\n     }\n   }\n   // neither x nor y is NaN\n-  tmp_fpsf = *pfpsf; // save fpsf\n+\n+  // if not infinity, check for non-canonical values x (treated as zero)\n+  if ((x.w[1] & MASK_ANY_INF) != MASK_INF) {\t// x != inf\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\t// G0_G1=11\n+      // non-canonical\n+      x_exp = (x.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+      x.w[1] = (x.w[1] & MASK_SIGN) | x_exp;\n+      x.w[0] = 0x0ull;\n+    } else {\t// G0_G1 != 11\n+      x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+      if ((x.w[1] & MASK_COEFF) > 0x0001ed09bead87c0ull ||\n+\t  ((x.w[1] & MASK_COEFF) == 0x0001ed09bead87c0ull\n+\t   && x.w[0] > 0x378d8e63ffffffffull)) {\n+\t// x is non-canonical if coefficient is larger than 10^34 -1\n+\tx.w[1] = (x.w[1] & MASK_SIGN) | x_exp;\n+\tx.w[0] = 0x0ull;\n+      } else {\t// canonical\n+\t;\n+      }\n+    }\n+  }\n+  // no need to check for non-canonical y\n+\n+  // neither x nor y is NaN\n+  tmp_fpsf = *pfpsf;\t// save fpsf\n #if DECIMAL_CALL_BY_REFERENCE\n-  __bid128_quiet_equal (&res1, &xnswp,\n-                      &ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n-  __bid128_quiet_greater (&res2, &xnswp,\n-                        &ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  bid128_quiet_equal (&res1, &xnswp,\n+\t\t      &ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t      _EXC_INFO_ARG);\n+  bid128_quiet_greater (&res2, &xnswp,\n+\t\t\t&ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t_EXC_INFO_ARG);\n #else\n   res1 =\n-    __bid128_quiet_equal (xnswp,\n-                        ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    bid128_quiet_equal (xnswp,\n+\t\t\tynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t_EXC_INFO_ARG);\n   res2 =\n-    __bid128_quiet_greater (xnswp,\n-                          ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n-                          _EXC_INFO_ARG);\n+    bid128_quiet_greater (xnswp,\n+\t\t\t  ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t  _EXC_INFO_ARG);\n #endif\n-  *pfpsf = tmp_fpsf; // restore fpsf\n-  if (res1) { // x = y\n+  *pfpsf = tmp_fpsf;\t// restore fpsf\n+\n+  if (res1) {\t// x = y\n     // return x with the sign of y\n-    res.w[1] = \n-        (x.w[1] & 0x7fffffffffffffffull) | (y.w[1] & 0x8000000000000000ull);\n+    res.w[1] =\n+      (x.w[1] & 0x7fffffffffffffffull) | (y.\n+\t\t\t\t\t  w[1] & 0x8000000000000000ull);\n     res.w[0] = x.w[0];\n-  } else if (res2) { // x > y\n+  } else if (res2) {\t// x > y\n #if DECIMAL_CALL_BY_REFERENCE\n-    __bid128_nextdown (&res,\n-                     &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    bid128_nextdown (&res,\n+\t\t     &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t     _EXC_INFO_ARG);\n #else\n     res =\n-      __bid128_nextdown (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+      bid128_nextdown (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t       _EXC_INFO_ARG);\n #endif\n-    BID_SWAP128(res);\n-  } else { // x < y\n+    BID_SWAP128 (res);\n+  } else {\t// x < y\n #if DECIMAL_CALL_BY_REFERENCE\n-    __bid128_nextup (&res,\n-                   &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    bid128_nextup (&res,\n+\t\t   &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #else\n-    res = __bid128_nextup (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    res =\n+      bid128_nextup (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #endif\n-    BID_SWAP128(res);\n+    BID_SWAP128 (res);\n   }\n   // if the operand x is finite but the result is infinite, signal \n   // overflow and inexact\n@@ -539,29 +613,31 @@ __bid128_nextafter (UINT128 x,\n   }\n   // if the result is in (-10^emin, 10^emin), and is different from the\n   // operand x, signal underflow and inexact\n-  tmp1.w[HIGH_128W] = 0x0000314dc6448d93ull; \n-  tmp1.w[LOW_128W] = 0x38c15b0a00000000ull; // +100...0[34] * 10^emin\n+  tmp1.w[HIGH_128W] = 0x0000314dc6448d93ull;\n+  tmp1.w[LOW_128W] = 0x38c15b0a00000000ull;\t// +100...0[34] * 10^emin\n   tmp2.w[HIGH_128W] = res.w[1] & 0x7fffffffffffffffull;\n   tmp2.w[LOW_128W] = res.w[0];\n-  tmp_fpsf = *pfpsf; // save fpsf\n+  tmp3.w[HIGH_128W] = res.w[1];\n+  tmp3.w[LOW_128W] = res.w[0];\n+  tmp_fpsf = *pfpsf;\t// save fpsf\n #if DECIMAL_CALL_BY_REFERENCE\n-  __bid128_quiet_greater (&res1, &tmp1,\n-                        &tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n-                        _EXC_INFO_ARG);\n-  __bid128_quiet_not_equal (&res2, &xnswp,\n-                          &res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n-                          _EXC_INFO_ARG);\n+  bid128_quiet_greater (&res1, &tmp1,\n+\t\t\t&tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t_EXC_INFO_ARG);\n+  bid128_quiet_not_equal (&res2, &xnswp,\n+\t\t\t  &tmp3 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t  _EXC_INFO_ARG);\n #else\n   res1 =\n-    __bid128_quiet_greater (tmp1,\n-                          tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n-                          _EXC_INFO_ARG);\n+    bid128_quiet_greater (tmp1,\n+\t\t\t  tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t  _EXC_INFO_ARG);\n   res2 =\n-    __bid128_quiet_not_equal (xnswp,\n-                            res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n-                            _EXC_INFO_ARG);\n+    bid128_quiet_not_equal (xnswp,\n+\t\t\t    tmp3 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t    _EXC_INFO_ARG);\n #endif\n-  *pfpsf = tmp_fpsf; // restore fpsf\n+  *pfpsf = tmp_fpsf;\t// restore fpsf\n   if (res1 && res2) {\n     // set the inexact flag \n     *pfpsf |= INEXACT_EXCEPTION;"}, {"sha": "576c1485cfa09fb32718a17610fc204eff9fe524", "filename": "libgcc/config/libbid/bid128_noncomp.c", "status": "modified", "additions": 386, "deletions": 381, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -31,34 +31,34 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /*****************************************************************************\n  *\n  *    BID128 non-computational functions:\n- *         - __bid128_isSigned\n- *         - __bid128_isNormal\n- *         - __bid128_isSubnormal\n- *         - __bid128_isFinite\n- *         - __bid128_isZero\n- *         - __bid128_isInf\n- *         - __bid128_isSignaling\n- *         - __bid128_isCanonical\n- *         - __bid128_isNaN\n- *         - __bid128_copy\n- *         - __bid128_negate\n- *         - __bid128_abs\n- *         - __bid128_copySign\n- *         - __bid128_class\n- *         - __bid128_totalOrder\n- *         - __bid128_totalOrderMag\n- *         - __bid128_sameQuantum\n- *         - __bid128_radix\n+ *         - bid128_isSigned\n+ *         - bid128_isNormal\n+ *         - bid128_isSubnormal\n+ *         - bid128_isFinite\n+ *         - bid128_isZero\n+ *         - bid128_isInf\n+ *         - bid128_isSignaling\n+ *         - bid128_isCanonical\n+ *         - bid128_isNaN\n+ *         - bid128_copy\n+ *         - bid128_negate\n+ *         - bid128_abs\n+ *         - bid128_copySign\n+ *         - bid128_class\n+ *         - bid128_totalOrder\n+ *         - bid128_totalOrderMag\n+ *         - bid128_sameQuantum\n+ *         - bid128_radix\n  ****************************************************************************/\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isSigned (int *pres,\n-                 UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSigned (int *pres,\n+\t\t UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isSigned (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSigned (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -69,27 +69,27 @@ __bid128_isSigned (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // return 1 iff x is not zero, nor NaN nor subnormal nor infinity\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isNormal (int *pres,\n-                 UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isNormal (int *pres,\n+\t\t UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT64 x_exp, C1_hi, C1_lo;\n   BID_UI64DOUBLE tmp1;\n   int exp, q, x_nr_bits;\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   // test for special values - infinity or NaN\n   if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n     // x is special\n     res = 0;\n     BID_RETURN (res);\n   }\n   // unpack x \n-  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n   C1_hi = x.w[1] & MASK_COEFF;\n   C1_lo = x.w[0];\n   // test for zero\n@@ -99,9 +99,9 @@ __bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   }\n   // test for non-canonical values of the argument x\n   if ((((C1_hi > 0x0001ed09bead87c0ull)\n-       || ((C1_hi == 0x0001ed09bead87c0ull)\n-           && (C1_lo > 0x378d8e63ffffffffull)))\n-      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+\t|| ((C1_hi == 0x0001ed09bead87c0ull)\n+\t    && (C1_lo > 0x378d8e63ffffffffull)))\n+       && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n       || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n     res = 0;\n     BID_RETURN (res);\n@@ -111,33 +111,33 @@ __bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   // q = nr. of decimal digits in x\n   // determine first the nr. of bits in x\n   if (C1_hi == 0) {\n-    if (C1_lo >= 0x0020000000000000ull) { // x >= 2^53\n+    if (C1_lo >= 0x0020000000000000ull) {\t// x >= 2^53\n       // split the 64-bit value in two 32-bit halves to avoid rounding errors\n-      if (C1_lo >= 0x0000000100000000ull) { // x >= 2^32\n-        tmp1.d = (double) (C1_lo >> 32); // exact conversion\n-        x_nr_bits =\n-          33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-      } else { // x < 2^32\n-        tmp1.d = (double) (C1_lo); // exact conversion\n-        x_nr_bits =\n-          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      if (C1_lo >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1_lo >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1_lo);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-    } else { // if x < 2^53\n-      tmp1.d = (double) C1_lo; // exact conversion\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1_lo;\t// exact conversion\n       x_nr_bits =\n-        1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n     }\n-  } else { // C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n-    tmp1.d = (double) C1_hi; // exact conversion\n+  } else {\t// C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n+    tmp1.d = (double) C1_hi;\t// exact conversion\n     x_nr_bits =\n       65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n   }\n-  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  q = nr_digits[x_nr_bits - 1].digits;\n   if (q == 0) {\n-    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n-    if (C1_hi > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-        || (C1_hi == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-        && C1_lo >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+    q = nr_digits[x_nr_bits - 1].digits1;\n+    if (C1_hi > nr_digits[x_nr_bits - 1].threshold_hi ||\n+\t(C1_hi == nr_digits[x_nr_bits - 1].threshold_hi &&\n+\t C1_lo >= nr_digits[x_nr_bits - 1].threshold_lo))\n       q++;\n   }\n   exp = (int) (x_exp >> 49) - 6176;\n@@ -154,27 +154,27 @@ __bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // return 1 iff x is not zero, nor NaN nor normal nor infinity\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isSubnormal (int *pres,\n-                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSubnormal (int *pres,\n+\t\t    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT64 x_exp, C1_hi, C1_lo;\n   BID_UI64DOUBLE tmp1;\n   int exp, q, x_nr_bits;\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   // test for special values - infinity or NaN\n   if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n     // x is special\n     res = 0;\n     BID_RETURN (res);\n   }\n   // unpack x \n-  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n   C1_hi = x.w[1] & MASK_COEFF;\n   C1_lo = x.w[0];\n   // test for zero\n@@ -184,9 +184,9 @@ __bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   }\n   // test for non-canonical values of the argument x\n   if ((((C1_hi > 0x0001ed09bead87c0ull)\n-       || ((C1_hi == 0x0001ed09bead87c0ull)\n-           && (C1_lo > 0x378d8e63ffffffffull)))\n-      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+\t|| ((C1_hi == 0x0001ed09bead87c0ull)\n+\t    && (C1_lo > 0x378d8e63ffffffffull)))\n+       && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n       || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n     res = 0;\n     BID_RETURN (res);\n@@ -196,33 +196,33 @@ __bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   // q = nr. of decimal digits in x\n   // determine first the nr. of bits in x\n   if (C1_hi == 0) {\n-    if (C1_lo >= 0x0020000000000000ull) { // x >= 2^53\n+    if (C1_lo >= 0x0020000000000000ull) {\t// x >= 2^53\n       // split the 64-bit value in two 32-bit halves to avoid rounding errors\n-      if (C1_lo >= 0x0000000100000000ull) { // x >= 2^32\n-        tmp1.d = (double) (C1_lo >> 32); // exact conversion\n-        x_nr_bits =\n-          33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-      } else { // x < 2^32\n-        tmp1.d = (double) (C1_lo); // exact conversion\n-        x_nr_bits =\n-          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      if (C1_lo >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1_lo >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1_lo);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-    } else { // if x < 2^53\n-      tmp1.d = (double) C1_lo; // exact conversion\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1_lo;\t// exact conversion\n       x_nr_bits =\n-        1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n     }\n-  } else { // C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n-    tmp1.d = (double) C1_hi; // exact conversion\n+  } else {\t// C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n+    tmp1.d = (double) C1_hi;\t// exact conversion\n     x_nr_bits =\n       65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n   }\n-  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  q = nr_digits[x_nr_bits - 1].digits;\n   if (q == 0) {\n-    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n-    if (C1_hi > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-        || (C1_hi == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n-        && C1_lo >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+    q = nr_digits[x_nr_bits - 1].digits1;\n+    if (C1_hi > nr_digits[x_nr_bits - 1].threshold_hi ||\n+\t(C1_hi == nr_digits[x_nr_bits - 1].threshold_hi &&\n+\t C1_lo >= nr_digits[x_nr_bits - 1].threshold_lo))\n       q++;\n   }\n   exp = (int) (x_exp >> 49) - 6176;\n@@ -237,11 +237,12 @@ __bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isFinite (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isFinite (int *pres,\n+\t\t UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isFinite (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isFinite (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   res = ((x.w[HIGH_128W] & MASK_INF) != MASK_INF);\n@@ -250,28 +251,26 @@ __bid128_isFinite (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isZero (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isZero (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isZero (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isZero (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT128 sig_x;\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   if ((x.w[1] & MASK_INF) == MASK_INF) {\n     res = 0;\n     BID_RETURN (res);\n   }\n   sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n   sig_x.w[0] = x.w[0];\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) || // significand is non-canonical\n-      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n-      (sig_x.w[0] > 0x378d8e63ffffffffull)) || // significand is non-canonical\n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull && \n-      (x.w[1] & MASK_INF) != MASK_INF) || // significand is non-canonical\n-      (sig_x.w[1] == 0 && sig_x.w[0] == 0)) { // significand is 0\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) ||\t// significand is non-canonical\n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && (sig_x.w[0] > 0x378d8e63ffffffffull)) ||\t// significand is non-canonical\n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull && (x.w[1] & MASK_INF) != MASK_INF) ||\t// significand is non-canonical\n+      (sig_x.w[1] == 0 && sig_x.w[0] == 0)) {\t// significand is 0\n     res = 1;\n     BID_RETURN (res);\n   }\n@@ -281,11 +280,11 @@ __bid128_isZero (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isInf (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isInf (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isInf (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isInf (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   res = ((x.w[HIGH_128W] & MASK_INF) == MASK_INF)\n@@ -295,12 +294,12 @@ __bid128_isInf (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isSignaling (int *pres,\n-                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSignaling (int *pres,\n+\t\t    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isSignaling (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isSignaling (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -311,34 +310,34 @@ __bid128_isSignaling (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // return 1 iff x is a canonical number ,infinity, or NaN.\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isCanonical (int *pres,\n-                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isCanonical (int *pres,\n+\t\t    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isCanonical (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isCanonical (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT128 sig_x;\n \n-  BID_SWAP128(x);\n-  if ((x.w[1] & MASK_NAN) == MASK_NAN) { // NaN\n+  BID_SWAP128 (x);\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// NaN\n     if (x.w[1] & 0x01ffc00000000000ull) {\n       res = 0;\n       BID_RETURN (res);\n     }\n-    sig_x.w[1] = x.w[1] & 0x00003fffffffffffull; // 46 bits\n-    sig_x.w[0] = x.w[0]; // 64 bits\n+    sig_x.w[1] = x.w[1] & 0x00003fffffffffffull;\t// 46 bits\n+    sig_x.w[0] = x.w[0];\t// 64 bits\n     // payload must be < 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n     if (sig_x.w[1] < 0x0000314dc6448d93ull\n-        || (sig_x.w[1] == 0x0000314dc6448d93ull\n-        && sig_x.w[0] < 0x38c15b0a00000000ull)) {\n+\t|| (sig_x.w[1] == 0x0000314dc6448d93ull\n+\t    && sig_x.w[0] < 0x38c15b0a00000000ull)) {\n       res = 1;\n     } else {\n       res = 0;\n     }\n     BID_RETURN (res);\n-  } else if ((x.w[1] & MASK_INF) == MASK_INF) { // infinity\n+  } else if ((x.w[1] & MASK_INF) == MASK_INF) {\t// infinity\n     if ((x.w[1] & 0x03ffffffffffffffull) || x.w[0]) {\n       res = 0;\n     } else {\n@@ -351,8 +350,8 @@ __bid128_isCanonical (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   sig_x.w[0] = x.w[0];\n   // a canonical number has a coefficient < 10^34 \n   //    (0x0001ed09_bead87c0_378d8e64_00000000)\n-  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) || // significand is non-canonical\n-      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && (sig_x.w[0] > 0x378d8e63ffffffffull)) ||        // significand is non-canonical\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) ||\t// significand is non-canonical\n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && (sig_x.w[0] > 0x378d8e63ffffffffull)) ||\t// significand is non-canonical\n       ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n     res = 0;\n   } else {\n@@ -363,11 +362,11 @@ __bid128_isCanonical (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_isNaN (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isNaN (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_isNaN (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_isNaN (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -378,12 +377,12 @@ __bid128_isNaN (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, with no change\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_copy (UINT128 * pres,\n-             UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_copy (UINT128 * pres,\n+\t     UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n UINT128\n-__bid128_copy (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_copy (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 res;\n \n@@ -394,12 +393,12 @@ __bid128_copy (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, reversing the sign\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_negate (UINT128 * pres,\n-               UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_negate (UINT128 * pres,\n+\t       UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n UINT128\n-__bid128_negate (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_negate (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 res;\n \n@@ -411,12 +410,12 @@ __bid128_negate (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, changing the sign to positive\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_abs (UINT128 * pres,\n-            UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_abs (UINT128 * pres,\n+\t    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n UINT128\n-__bid128_abs (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_abs (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 res;\n \n@@ -428,36 +427,37 @@ __bid128_abs (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies operand x to destination in the same format as x, but with the sign of y\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_copySign (UINT128 * pres, UINT128 * px,\n-                 UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_copySign (UINT128 * pres, UINT128 * px,\n+\t\t UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n UINT128\n-__bid128_copySign (UINT128 x, UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_copySign (UINT128 x, UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 res;\n \n-  x.w[HIGH_128W] = (x.w[HIGH_128W] & ~MASK_SIGN) | (y.w[HIGH_128W] & MASK_SIGN);\n+  x.w[HIGH_128W] =\n+    (x.w[HIGH_128W] & ~MASK_SIGN) | (y.w[HIGH_128W] & MASK_SIGN);\n   res = x;\n   BID_RETURN (res);\n }\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_class (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_class (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT256 sig_x_prime256;\n   UINT192 sig_x_prime192;\n   UINT128 sig_x;\n   int exp_x;\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n     if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\n       res = signalingNaN;\n@@ -480,7 +480,7 @@ __bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   // check for zero or non-canonical\n   if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n       || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n-          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+\t  && (sig_x.w[0] > 0x378d8e63ffffffffull))\n       || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)\n       || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n     if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n@@ -495,31 +495,29 @@ __bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   // (less than the smallest normal value)\n   //  the smallest normal value is 1 x 10^-6143 = 10^33 x 10^-6176\n   //  if (exp_x - 6176 < -6143)\n-  if (exp_x < 33) { // sig_x * 10^exp_x\n+  if (exp_x < 33) {\t// sig_x * 10^exp_x\n     if (exp_x > 19) {\n       __mul_128x128_to_256 (sig_x_prime256, sig_x,\n-                            __bid_ten2k128[exp_x - 20]);\n+\t\t\t    ten2k128[exp_x - 20]);\n       // 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n       if ((sig_x_prime256.w[3] == 0) && (sig_x_prime256.w[2] == 0)\n-          && ((sig_x_prime256.w[1] < 0x0000314dc6448d93ull)\n-              || ((sig_x_prime256.w[1] == 0x0000314dc6448d93ull)\n-              && (sig_x_prime256.w[0] < 0x38c15b0a00000000ull)))) {\n-        res =\n-          ((x.w[1] & MASK_SIGN) ==\n-           MASK_SIGN) ? negativeSubnormal : positiveSubnormal;\n-        BID_RETURN (res);\n+\t  && ((sig_x_prime256.w[1] < 0x0000314dc6448d93ull)\n+\t      || ((sig_x_prime256.w[1] == 0x0000314dc6448d93ull)\n+\t\t  && (sig_x_prime256.w[0] < 0x38c15b0a00000000ull)))) {\n+\tres = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? negativeSubnormal :\n+\t  positiveSubnormal;\n+\tBID_RETURN (res);\n       }\n     } else {\n-      __mul_64x128_to_192 (sig_x_prime192, __bid_ten2k64[exp_x], sig_x);\n+      __mul_64x128_to_192 (sig_x_prime192, ten2k64[exp_x], sig_x);\n       // 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n       if ((sig_x_prime192.w[2] == 0)\n-          && ((sig_x_prime192.w[1] < 0x0000314dc6448d93ull)\n-              || ((sig_x_prime192.w[1] == 0x0000314dc6448d93ull)\n-              && (sig_x_prime192.w[0] < 0x38c15b0a00000000ull)))) {\n-        res =\n-          ((x.w[1] & MASK_SIGN) ==\n-           MASK_SIGN) ? negativeSubnormal : positiveSubnormal;\n-        BID_RETURN (res);\n+\t  && ((sig_x_prime192.w[1] < 0x0000314dc6448d93ull)\n+\t      || ((sig_x_prime192.w[1] == 0x0000314dc6448d93ull)\n+\t\t  && (sig_x_prime192.w[0] < 0x38c15b0a00000000ull)))) {\n+\tres = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? negativeSubnormal :\n+\t  positiveSubnormal;\n+\tBID_RETURN (res);\n       }\n     }\n   }\n@@ -535,24 +533,25 @@ __bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // If exactly one operand is infinite or exactly one operand is NaN, then false\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_sameQuantum (int *pres, UINT128 * px,\n-                    UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_sameQuantum (int *pres, UINT128 * px,\n+\t\t    UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n int\n-__bid128_sameQuantum (UINT128 x,\n-                    UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_sameQuantum (UINT128 x,\n+\t\t    UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n+  UINT64 x_exp, y_exp;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n   // if both operands are NaN, return true\n   if ((x.w[1] & MASK_NAN) == MASK_NAN\n       || ((y.w[1] & MASK_NAN) == MASK_NAN)) {\n     res = ((x.w[1] & MASK_NAN) == MASK_NAN\n-           && (y.w[1] & MASK_NAN) == MASK_NAN);\n+\t   && (y.w[1] & MASK_NAN) == MASK_NAN);\n     BID_RETURN (res);\n   }\n   // if both operands are INF, return true\n@@ -563,22 +562,30 @@ __bid128_sameQuantum (UINT128 x,\n     BID_RETURN (res);\n   }\n   // decode exponents for both numbers, and return true if they match\n-  res =\n-    ((x.w[1] >> 49) & 0x0000000000003fffull) ==\n-    ((y.w[1] >> 49) & 0x0000000000003fffull);\n+  if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\t// G0_G1=11\n+    x_exp = (x.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+  } else {\t// G0_G1 != 11\n+    x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+  }\n+  if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\t// G0_G1=11\n+    y_exp = (y.w[1] << 2) & MASK_EXP;\t// biased and shifted left 49 bits\n+  } else {\t// G0_G1 != 11\n+    y_exp = y.w[1] & MASK_EXP;\t// biased and shifted left 49 bits\n+  }\n+  res = (x_exp == y_exp);\n   BID_RETURN (res);\n }\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_totalOrder (int *pres, UINT128 * px,\n-                   UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_totalOrder (int *pres, UINT128 * px,\n+\t\t   UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n int\n-__bid128_totalOrder (UINT128 x,\n-                   UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_totalOrder (UINT128 x,\n+\t\t   UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   int exp_x, exp_y;\n@@ -587,112 +594,109 @@ __bid128_totalOrder (UINT128 x,\n   UINT256 sig_n_prime256;\n   char x_is_zero = 0, y_is_zero = 0;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n   // NaN (CASE 1)\n   // if x and y are unordered numerically because either operand is NaN\n   //    (1) totalOrder(-NaN, number) is true\n   //    (2) totalOrder(number, +NaN) is true\n   //    (3) if x and y are both NaN:\n   //       i) negative sign bit < positive sign bit\n-  //       ii) signaling < quiet fir +NaN, reverse for -NaN\n+  //       ii) signaling < quiet for +NaN, reverse for -NaN\n   //       iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  //       iv) else if bitwise identical (in canonical form), return 1\n   if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n     // if x is -NaN\n     if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n       // return true, unless y is -NaN also\n       if ((y.w[1] & MASK_NAN) != MASK_NAN\n-          || (y.w[1] & MASK_SIGN) != MASK_SIGN) {\n-        res = 1; // y is a number, return 1\n-        BID_RETURN (res);\n-      } else { // if y and x are both -NaN\n-        // if x and y are both -SNaN or both -QNaN, we have to compare payloads\n-        // this statement evaluates to true if both are SNaN or QNaN\n-        if (!\n-            (((y.w[1] & MASK_SNAN) ==\n-              MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n-          // it comes down to the payload.  we want to return true if x has a\n-          // larger payload, but first we must calculate the payload.\n-          pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n-          pyld_y.w[0] = y.w[0];\n-          pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n-          pyld_x.w[0] = x.w[0];\n-          if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n-              || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n-                  && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n-              || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n-            // if y is zero, x must be less than or numerically equal\n-            // y's payload is 0\n-            res = 1;\n-            BID_RETURN (res);\n-          }\n-          // if x is zero and y isn't, x has the smaller payload\n-          // definitely (since we know y isn't 0 at this point)\n-          if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n-              || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n-                  && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n-              || (pyld_x.w[0] == 0 && pyld_x.w[1] == 0)) {\n-            // x's payload is 0\n-            res = 0;\n-            BID_RETURN (res);\n-          }\n-          res = ((pyld_x.w[1] > pyld_y.w[1])\n-                 || (pyld_x.w[1] == pyld_y.w[1]\n-                     && pyld_x.w[0] >= pyld_y.w[0]));\n-          BID_RETURN (res);\n-        } else {\n-          // either x = -SNaN and y = -QNaN or x = -QNaN and y = -SNaN\n-          res = (y.w[1] & MASK_SNAN) == MASK_SNAN;\n-          // totalOrder (-QNaN, -SNaN) == 1\n-          BID_RETURN (res);\n-        }\n+\t  || (y.w[1] & MASK_SIGN) != MASK_SIGN) {\n+\tres = 1;\t// y is a number, return 1\n+\tBID_RETURN (res);\n+      } else {\t// if y and x are both -NaN\n+\tpyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+\tpyld_x.w[0] = x.w[0];\n+\tpyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+\tpyld_y.w[0] = y.w[0];\n+\tif ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+\t    || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+\t\t&& (pyld_x.w[0] > 0x38c15b09ffffffffull))) {\n+\t  pyld_x.w[1] = 0;\n+\t  pyld_x.w[0] = 0;\n+\t}\n+\tif ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+\t    || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+\t\t&& (pyld_y.w[0] > 0x38c15b09ffffffffull))) {\n+\t  pyld_y.w[1] = 0;\n+\t  pyld_y.w[0] = 0;\n+\t}\n+\t// if x and y are both -SNaN or both -QNaN, we have to compare payloads\n+\t// this statement evaluates to true if both are SNaN or QNaN\n+\tif (!\n+\t    (((y.w[1] & MASK_SNAN) == MASK_SNAN) ^\n+\t     ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+\t  // it comes down to the payload.  we want to return true if x has a\n+\t  // larger payload, or if the payloads are equal (canonical forms\n+\t  // are bitwise identical)\n+\t  if ((pyld_x.w[1] > pyld_y.w[1]) ||\n+\t      ((pyld_x.w[1] == pyld_y.w[1])\n+\t       && (pyld_x.w[0] >= pyld_y.w[0])))\n+\t    res = 1;\n+\t  else\n+\t    res = 0;\n+\t  BID_RETURN (res);\n+\t} else {\n+\t  // either x = -SNaN and y = -QNaN or x = -QNaN and y = -SNaN\n+\t  res = ((y.w[1] & MASK_SNAN) == MASK_SNAN);\n+\t  // totalOrder (-QNaN, -SNaN) == 1\n+\t  BID_RETURN (res);\n+\t}\n       }\n-    } else { // x is +NaN\n+    } else {\t// x is +NaN\n       // return false, unless y is +NaN also\n       if ((y.w[1] & MASK_NAN) != MASK_NAN\n-          || (y.w[1] & MASK_SIGN) == MASK_SIGN) {\n-        res = 0; // y is a number, return 1\n-        BID_RETURN (res);\n+\t  || (y.w[1] & MASK_SIGN) == MASK_SIGN) {\n+\tres = 0;\t// y is a number, return 1\n+\tBID_RETURN (res);\n       } else {\n-        // x and y are both +NaN; \n-        // must investigate payload if both quiet or both signaling\n-        // this xnor statement will be true if both x and y are +QNaN or +SNaN\n-        if (!\n-            (((y.w[1] & MASK_SNAN) ==\n-              MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n-          // it comes down to the payload.  we want to return true if x has a\n-          // smaller payload, but first we must calculate the payload.\n-          pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n-          pyld_y.w[0] = y.w[0];\n-          pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n-          pyld_x.w[0] = x.w[0];\n-          // if x is zero and y isn't, x has the smaller payload definitely \n-          // (since we know y isn't 0 at this point)\n-          if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n-              || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n-                  && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n-              || (pyld_x.w[1] == 0 && pyld_x.w[0] == 0)) {\n-            res = 1;\n-            BID_RETURN (res);\n-          }\n-          if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n-              || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n-                  && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n-              || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n-            // if y is zero, x must be less than or numerically equal\n-            res = 0;\n-            BID_RETURN (res);\n-          }\n-          res = ((pyld_x.w[1] < pyld_y.w[1])\n-                 || (pyld_x.w[1] == pyld_y.w[1]\n-                     && pyld_x.w[0] <= pyld_y.w[0]));\n-          BID_RETURN (res);\n-        } else {\n-          // return true if y is +QNaN and x is +SNaN \n-          // (we know they're different bc of xor if_stmt above)\n-          res = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n-          BID_RETURN (res);\n-        }\n+\t// x and y are both +NaN; \n+\tpyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+\tpyld_x.w[0] = x.w[0];\n+\tpyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+\tpyld_y.w[0] = y.w[0];\n+\tif ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+\t    || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+\t\t&& (pyld_x.w[0] > 0x38c15b09ffffffffull))) {\n+\t  pyld_x.w[1] = 0;\n+\t  pyld_x.w[0] = 0;\n+\t}\n+\tif ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+\t    || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+\t\t&& (pyld_y.w[0] > 0x38c15b09ffffffffull))) {\n+\t  pyld_y.w[1] = 0;\n+\t  pyld_y.w[0] = 0;\n+\t}\n+\t// if x and y are both +SNaN or both +QNaN, we have to compare payloads\n+\t// this statement evaluates to true if both are SNaN or QNaN\n+\tif (!\n+\t    (((y.w[1] & MASK_SNAN) == MASK_SNAN) ^\n+\t     ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+\t  // it comes down to the payload.  we want to return true if x has a\n+\t  // smaller payload, or if the payloads are equal (canonical forms\n+\t  // are bitwise identical)\n+\t  if ((pyld_x.w[1] < pyld_y.w[1]) ||\n+\t      ((pyld_x.w[1] == pyld_y.w[1])\n+\t       && (pyld_x.w[0] <= pyld_y.w[0])))\n+\t    res = 1;\n+\t  else\n+\t    res = 0;\n+\t  BID_RETURN (res);\n+\t} else {\n+\t  // either x = SNaN and y = QNaN or x = QNaN and y = SNaN\n+\t  res = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n+\t  // totalOrder (-QNaN, -SNaN) == 1\n+\t  BID_RETURN (res);\n+\t}\n       }\n     }\n   } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\n@@ -710,8 +714,8 @@ __bid128_totalOrder (UINT128 x,\n   // OPPOSITE SIGNS (CASE 3)\n   // if signs are opposite, return 1 if x is negative \n   // (if x < y, totalOrder is true)\n-  if (((x.w[1] & MASK_SIGN) == MASK_SIGN) ^ \n-      ((y.w[1] & MASK_SIGN) == MASK_SIGN)) {\n+  if (((x.w[1] & MASK_SIGN) == MASK_SIGN) ^ ((y.w[1] & MASK_SIGN) ==\n+\t\t\t\t\t     MASK_SIGN)) {\n     res = ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n     BID_RETURN (res);\n   }\n@@ -744,11 +748,11 @@ __bid128_totalOrder (UINT128 x,\n   //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n   // [0, 10^34) is the 754r supported canonical range.  \n   // If the value exceeds that, it is interpreted as 0.\n-  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) || \n-      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n-      (sig_x.w[0] > 0x378d8e63ffffffffull))) && \n-      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) ||\n+\t((sig_x.w[1] == 0x0001ed09bead87c0ull) &&\n+\t (sig_x.w[0] > 0x378d8e63ffffffffull))) &&\n+       ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) ||\n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) ||\n       ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n     x_is_zero = 1;\n     // check for the case where the exponent is shifted right by 2 bits!\n@@ -766,11 +770,11 @@ __bid128_totalOrder (UINT128 x,\n   //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n   // [0, 10^34) is the 754r supported canonical range.  \n   // If the value exceeds that, it is interpreted as 0.\n-  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) || \n-      ((sig_y.w[1] == 0x0001ed09bead87c0ull) && \n-      (sig_y.w[0] > 0x378d8e63ffffffffull))) && \n-      ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) ||\n+\t((sig_y.w[1] == 0x0001ed09bead87c0ull) &&\n+\t (sig_y.w[0] > 0x378d8e63ffffffffull))) &&\n+       ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) ||\n+      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) ||\n       ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n     y_is_zero = 1;\n     // check for the case where the exponent is shifted right by 2 bits!\n@@ -829,41 +833,41 @@ __bid128_totalOrder (UINT128 x,\n     // otherwise adjust the x significand upwards\n     if (exp_x - exp_y > 19) {\n       __mul_128x128_to_256 (sig_n_prime256, sig_x,\n-                            __bid_ten2k128[exp_x - exp_y - 20]);\n+\t\t\t    ten2k128[exp_x - exp_y - 20]);\n       // the compensated significands are equal (ie \"x and y represent the same\n       // entities\") return 1 if (negative && expx > expy) || \n       // (positive && expx < expy)\n       if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-          && (sig_n_prime256.w[1] == sig_y.w[1])\n-          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n-        // the case exp_x == exp_y  cannot occur, because all bits must be \n-        // the same - would have been caught if (x == y)\n-        res = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n-        BID_RETURN (res);\n+\t  && (sig_n_prime256.w[1] == sig_y.w[1])\n+\t  && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+\t// the case exp_x == exp_y  cannot occur, because all bits must be \n+\t// the same - would have been caught if (x == y)\n+\tres = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+\tBID_RETURN (res);\n       }\n       // if positive, return 1 if adjusted x is smaller than y\n       res = (((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-              && ((sig_n_prime256.w[1] < sig_y.w[1])\n-                  || (sig_n_prime256.w[1] == sig_y.w[1]\n-                      && sig_n_prime256.w[0] <\n-                      sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n-                                       MASK_SIGN));\n+\t      && ((sig_n_prime256.w[1] < sig_y.w[1])\n+\t\t  || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t      && sig_n_prime256.w[0] <\n+\t\t      sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+\t\t\t\t       MASK_SIGN));\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_x - exp_y], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[exp_x - exp_y], sig_x);\n     // if positive, return whichever significand is larger \n     // (converse if negative)\n     if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n-        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+\t&& (sig_n_prime192.w[0] == sig_y.w[0])) {\n       res = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n       BID_RETURN (res);\n     }\n     res = (((sig_n_prime192.w[2] == 0)\n-            && ((sig_n_prime192.w[1] < sig_y.w[1])\n-                || (sig_n_prime192.w[1] == sig_y.w[1]\n-                    && sig_n_prime192.w[0] <\n-                    sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n-                                     MASK_SIGN));\n+\t    && ((sig_n_prime192.w[1] < sig_y.w[1])\n+\t\t|| (sig_n_prime192.w[1] == sig_y.w[1]\n+\t\t    && sig_n_prime192.w[0] <\n+\t\t    sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+\t\t\t\t     MASK_SIGN));\n     BID_RETURN (res);\n   }\n   // if exp_x is 33 less than exp_y, it is definitely smaller, \n@@ -875,54 +879,54 @@ __bid128_totalOrder (UINT128 x,\n   if (exp_y - exp_x > 19) {\n     // adjust the y significand upwards\n     __mul_128x128_to_256 (sig_n_prime256, sig_y,\n-                          __bid_ten2k128[exp_y - exp_x - 20]);\n+\t\t\t  ten2k128[exp_y - exp_x - 20]);\n     // if x and y represent the same entities and both are negative\n     // return true iff exp_x <= exp_y\n     if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-        && (sig_n_prime256.w[1] == sig_x.w[1])\n-        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+\t&& (sig_n_prime256.w[1] == sig_x.w[1])\n+\t&& (sig_n_prime256.w[0] == sig_x.w[0])) {\n       res = (exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n       BID_RETURN (res);\n     }\n     // values are not equal, for positive numbers return 1 if x is less than y\n     // and 0 otherwise\n     res = (((sig_n_prime256.w[3] != 0) ||\n-            // if upper128 bits of compensated y are non-zero, y is bigger\n-            (sig_n_prime256.w[2] != 0) ||\n-            // if upper128 bits of compensated y are non-zero, y is bigger\n-            (sig_n_prime256.w[1] > sig_x.w[1]) ||\n-            // if compensated y is bigger, y is bigger\n-            (sig_n_prime256.w[1] == sig_x.w[1]\n-             && sig_n_prime256.w[0] >\n-             sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+\t    // if upper128 bits of compensated y are non-zero, y is bigger\n+\t    (sig_n_prime256.w[2] != 0) ||\n+\t    // if upper128 bits of compensated y are non-zero, y is bigger\n+\t    (sig_n_prime256.w[1] > sig_x.w[1]) ||\n+\t    // if compensated y is bigger, y is bigger\n+\t    (sig_n_prime256.w[1] == sig_x.w[1]\n+\t     && sig_n_prime256.w[0] >\n+\t     sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n     BID_RETURN (res);\n   }\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_y - exp_x], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[exp_y - exp_x], sig_y);\n   if ((sig_n_prime192.w[2] == 0) && (sig_n_prime192.w[1] == sig_x.w[1])\n       && (sig_n_prime192.w[0] == sig_x.w[0])) {\n     res = (exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n     BID_RETURN (res);\n   }\n   res = (((sig_n_prime192.w[2] != 0) ||\n-          // if upper128 bits of compensated y are non-zero, y is bigger\n-          (sig_n_prime192.w[1] > sig_x.w[1]) ||\n-          // if compensated y is bigger, y is bigger\n-          (sig_n_prime192.w[1] == sig_x.w[1]\n-           && sig_n_prime192.w[0] >\n-           sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+\t  // if upper128 bits of compensated y are non-zero, y is bigger\n+\t  (sig_n_prime192.w[1] > sig_x.w[1]) ||\n+\t  // if compensated y is bigger, y is bigger\n+\t  (sig_n_prime192.w[1] == sig_x.w[1]\n+\t   && sig_n_prime192.w[0] >\n+\t   sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n   BID_RETURN (res);\n }\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_totalOrderMag (int *pres, UINT128 * px,\n-                      UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_totalOrderMag (int *pres, UINT128 * px,\n+\t\t      UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n   UINT128 y = *py;\n #else\n int\n-__bid128_totalOrderMag (UINT128 x,\n-                      UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_totalOrderMag (UINT128 x,\n+\t\t      UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   int exp_x, exp_y;\n@@ -931,62 +935,63 @@ __bid128_totalOrderMag (UINT128 x,\n   UINT256 sig_n_prime256;\n   char x_is_zero = 0, y_is_zero = 0;\n \n-  BID_SWAP128(x);\n-  BID_SWAP128(y);\n+  BID_SWAP128 (x);\n+  BID_SWAP128 (y);\n   x.w[1] = x.w[1] & 0x7fffffffffffffffull;\n   y.w[1] = y.w[1] & 0x7fffffffffffffffull;\n \n   // NaN (CASE 1)\n   // if x and y are unordered numerically because either operand is NaN\n   //    (1) totalOrder(number, +NaN) is true\n   //    (2) if x and y are both NaN:\n-  //       i) signaling < quiet fir +NaN\n+  //       i) signaling < quiet for +NaN\n   //       ii) lesser payload < greater payload for +NaN\n+  //       iii) else if bitwise identical (in canonical form), return 1\n   if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n     // x is +NaN\n     // return false, unless y is +NaN also\n     if ((y.w[1] & MASK_NAN) != MASK_NAN) {\n-      res = 0; // y is a number, return 0\n+      res = 0;\t// y is a number, return 0\n       BID_RETURN (res);\n     } else {\n       // x and y are both +NaN; \n-      // must investigate payload if both quiet or both signaling\n-      // this xnor statement will be true if both x and y are +QNaN or +SNaN\n+      pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+      pyld_x.w[0] = x.w[0];\n+      pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+      pyld_y.w[0] = y.w[0];\n+      if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+\t  || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+\t      && (pyld_x.w[0] > 0x38c15b09ffffffffull))) {\n+\tpyld_x.w[1] = 0;\n+\tpyld_x.w[0] = 0;\n+      }\n+      if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+\t  || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+\t      && (pyld_y.w[0] > 0x38c15b09ffffffffull))) {\n+\tpyld_y.w[1] = 0;\n+\tpyld_y.w[0] = 0;\n+      }\n+      // if x and y are both +SNaN or both +QNaN, we have to compare payloads\n+      // this statement evaluates to true if both are SNaN or QNaN\n       if (!\n-          (((y.w[1] & MASK_SNAN) ==\n-            MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n-        // it comes down to the payload.  we want to return true if x has a\n-        // smaller payload, but first we must calculate the payload.\n-        pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n-        pyld_y.w[0] = y.w[0];\n-        pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n-        pyld_x.w[0] = x.w[0];\n-        // if x is zero and y isn't, x has the smaller payload definitely \n-        // (since we know y isn't 0 at this point)\n-        if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n-            || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n-                && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n-            || (pyld_x.w[1] == 0 && pyld_x.w[0] == 0)) {\n-          res = 1;\n-          BID_RETURN (res);\n-        }\n-        if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n-            || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n-                && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n-            || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n-          // if y is zero, x must be less than or numerically equal\n-          res = 0;\n-          BID_RETURN (res);\n-        }\n-        res = ((pyld_x.w[1] < pyld_y.w[1])\n-               || (pyld_x.w[1] == pyld_y.w[1]\n-                   && pyld_x.w[0] <= pyld_y.w[0]));\n-        BID_RETURN (res);\n+\t  (((y.w[1] & MASK_SNAN) == MASK_SNAN) ^\n+\t   ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+\t// it comes down to the payload.  we want to return true if x has a\n+\t// smaller payload, or if the payloads are equal (canonical forms\n+\t// are bitwise identical)\n+\tif ((pyld_x.w[1] < pyld_y.w[1]) ||\n+\t    ((pyld_x.w[1] == pyld_y.w[1])\n+\t     && (pyld_x.w[0] <= pyld_y.w[0]))) {\n+\t  res = 1;\n+\t} else {\n+\t  res = 0;\n+\t}\n+\tBID_RETURN (res);\n       } else {\n-        // return true if y is +QNaN and x is +SNaN \n-        // (we know they're different bc of xor if_stmt above)\n-        res = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n-        BID_RETURN (res);\n+\t// either x = SNaN and y = QNaN or x = QNaN and y = SNaN\n+\tres = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n+\t// totalOrder (-QNaN, -SNaN) == 1\n+\tBID_RETURN (res);\n       }\n     }\n   } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\n@@ -1013,7 +1018,7 @@ __bid128_totalOrderMag (UINT128 x,\n     res = 1;\n     BID_RETURN (res);\n   } else {\n-    ; // continue\n+    ;\t// continue\n   }\n \n   // CONVERT x\n@@ -1026,11 +1031,11 @@ __bid128_totalOrderMag (UINT128 x,\n   //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n   // [0, 10^34) is the 754r supported canonical range.  \n   // If the value exceeds that, it is interpreted as 0.\n-  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) || \n-      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n-      (sig_x.w[0] > 0x378d8e63ffffffffull))) && \n-      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) ||\n+\t((sig_x.w[1] == 0x0001ed09bead87c0ull) &&\n+\t (sig_x.w[0] > 0x378d8e63ffffffffull))) &&\n+       ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) ||\n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) ||\n       ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n     x_is_zero = 1;\n     // check for the case where the exponent is shifted right by 2 bits!\n@@ -1048,11 +1053,11 @@ __bid128_totalOrderMag (UINT128 x,\n   //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n   // [0, 10^34) is the 754r supported canonical range.  \n   // If the value exceeds that, it is interpreted as 0.\n-  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) || \n-      ((sig_y.w[1] == 0x0001ed09bead87c0ull) && \n-      (sig_y.w[0] > 0x378d8e63ffffffffull))) && \n-      ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n-      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) ||\n+\t((sig_y.w[1] == 0x0001ed09bead87c0ull) &&\n+\t (sig_y.w[0] > 0x378d8e63ffffffffull))) &&\n+       ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) ||\n+      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) ||\n       ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n     y_is_zero = 1;\n     // check for the case where the exponent is shifted right by 2 bits!\n@@ -1101,43 +1106,43 @@ __bid128_totalOrderMag (UINT128 x,\n     // if exp_x is 33 greater than exp_y, it is definitely larger, \n     // so no need for compensation\n     if (exp_x - exp_y > 33) {\n-      res = 0; // difference cannot be greater than 10^33\n+      res = 0;\t// difference cannot be greater than 10^33\n       BID_RETURN (res);\n     }\n     // otherwise adjust the x significand upwards\n     if (exp_x - exp_y > 19) {\n       __mul_128x128_to_256 (sig_n_prime256, sig_x,\n-                            __bid_ten2k128[exp_x - exp_y - 20]);\n+\t\t\t    ten2k128[exp_x - exp_y - 20]);\n       // the compensated significands are equal (ie \"x and y represent the same\n       // entities\") return 1 if (negative && expx > expy) || \n       // (positive && expx < expy)\n       if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-          && (sig_n_prime256.w[1] == sig_y.w[1])\n-          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n-        // the case (exp_x == exp_y) cannot occur, because all bits must be \n-        // the same - would have been caught if (x == y)\n-        res = (exp_x <= exp_y);\n-        BID_RETURN (res);\n+\t  && (sig_n_prime256.w[1] == sig_y.w[1])\n+\t  && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+\t// the case (exp_x == exp_y) cannot occur, because all bits must be \n+\t// the same - would have been caught if (x == y)\n+\tres = (exp_x <= exp_y);\n+\tBID_RETURN (res);\n       }\n       // since positive, return 1 if adjusted x is smaller than y\n       res = ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-             && ((sig_n_prime256.w[1] < sig_y.w[1])\n-                 || (sig_n_prime256.w[1] == sig_y.w[1]\n-                     && sig_n_prime256.w[0] < sig_y.w[0])));\n+\t     && ((sig_n_prime256.w[1] < sig_y.w[1])\n+\t\t || (sig_n_prime256.w[1] == sig_y.w[1]\n+\t\t     && sig_n_prime256.w[0] < sig_y.w[0])));\n       BID_RETURN (res);\n     }\n-    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_x - exp_y], sig_x);\n+    __mul_64x128_to_192 (sig_n_prime192, ten2k64[exp_x - exp_y], sig_x);\n     // if positive, return whichever significand is larger \n     // (converse if negative)\n     if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n-        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+\t&& (sig_n_prime192.w[0] == sig_y.w[0])) {\n       res = (exp_x <= exp_y);\n       BID_RETURN (res);\n     }\n     res = ((sig_n_prime192.w[2] == 0)\n-           && ((sig_n_prime192.w[1] < sig_y.w[1])\n-               || (sig_n_prime192.w[1] == sig_y.w[1]\n-                   && sig_n_prime192.w[0] < sig_y.w[0])));\n+\t   && ((sig_n_prime192.w[1] < sig_y.w[1])\n+\t       || (sig_n_prime192.w[1] == sig_y.w[1]\n+\t\t   && sig_n_prime192.w[0] < sig_y.w[0])));\n     BID_RETURN (res);\n   }\n   // if exp_x is 33 less than exp_y, it is definitely smaller, \n@@ -1149,50 +1154,50 @@ __bid128_totalOrderMag (UINT128 x,\n   if (exp_y - exp_x > 19) {\n     // adjust the y significand upwards\n     __mul_128x128_to_256 (sig_n_prime256, sig_y,\n-                          __bid_ten2k128[exp_y - exp_x - 20]);\n+\t\t\t  ten2k128[exp_y - exp_x - 20]);\n     if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n-        && (sig_n_prime256.w[1] == sig_x.w[1])\n-        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+\t&& (sig_n_prime256.w[1] == sig_x.w[1])\n+\t&& (sig_n_prime256.w[0] == sig_x.w[0])) {\n       res = (exp_x <= exp_y);\n       BID_RETURN (res);\n     }\n     // values are not equal, for positive numbers return 1 if x is less than y\n     // and 0 otherwise\n     res = ((sig_n_prime256.w[3] != 0) ||\n-           // if upper128 bits of compensated y are non-zero, y is bigger\n-           (sig_n_prime256.w[2] != 0) ||\n-           // if upper128 bits of compensated y are non-zero, y is bigger\n-           (sig_n_prime256.w[1] > sig_x.w[1]) ||\n-           // if compensated y is bigger, y is bigger\n-           (sig_n_prime256.w[1] == sig_x.w[1]\n-            && sig_n_prime256.w[0] > sig_x.w[0]));\n+\t   // if upper128 bits of compensated y are non-zero, y is bigger\n+\t   (sig_n_prime256.w[2] != 0) ||\n+\t   // if upper128 bits of compensated y are non-zero, y is bigger\n+\t   (sig_n_prime256.w[1] > sig_x.w[1]) ||\n+\t   // if compensated y is bigger, y is bigger\n+\t   (sig_n_prime256.w[1] == sig_x.w[1]\n+\t    && sig_n_prime256.w[0] > sig_x.w[0]));\n     BID_RETURN (res);\n   }\n-  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_y - exp_x], sig_y);\n+  __mul_64x128_to_192 (sig_n_prime192, ten2k64[exp_y - exp_x], sig_y);\n   if ((sig_n_prime192.w[2] == 0) && (sig_n_prime192.w[1] == sig_x.w[1])\n       && (sig_n_prime192.w[0] == sig_x.w[0])) {\n     res = (exp_x <= exp_y);\n     BID_RETURN (res);\n   }\n   res = ((sig_n_prime192.w[2] != 0) ||\n-         // if upper128 bits of compensated y are non-zero, y is bigger\n-         (sig_n_prime192.w[1] > sig_x.w[1]) ||\n-         // if compensated y is bigger, y is bigger\n-         (sig_n_prime192.w[1] == sig_x.w[1]\n-          && sig_n_prime192.w[0] > sig_x.w[0]));\n+\t // if upper128 bits of compensated y are non-zero, y is bigger\n+\t (sig_n_prime192.w[1] > sig_x.w[1]) ||\n+\t // if compensated y is bigger, y is bigger\n+\t (sig_n_prime192.w[1] == sig_x.w[1]\n+\t  && sig_n_prime192.w[0] > sig_x.w[0]));\n   BID_RETURN (res);\n }\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid128_radix (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_radix (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n int\n-__bid128_radix (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid128_radix (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n-  if (x.w[LOW_128W])        // dummy test\n+  if (x.w[LOW_128W])\t// dummy test\n     res = 10;\n   else\n     res = 10;"}, {"sha": "83f7345c834ff4ae891596f3bc7127bf3360a277", "filename": "libgcc/config/libbid/bid128_quantize.c", "status": "modified", "additions": 189, "deletions": 180, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -29,242 +29,251 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define BID_128RES\n #include \"bid_internal.h\"\n \n-BID128_FUNCTION_ARG2(__bid128_quantize, x, y)\n+BID128_FUNCTION_ARG2 (bid128_quantize, x, y)\n \n-  UINT256 CT;\n-  UINT128 CX, CY, T, CX2, CR, Stemp, res, REM_H, C2N;\n-  UINT64 sign_x, sign_y, remainder_h, carry, CY64;\n-  int_float tempx;\n-  int exponent_x = 0, exponent_y = 0, digits_x, extra_digits, amount;\n-  int expon_diff, total_digits, bin_expon_cx, rmode, status;\n+     UINT256 CT;\n+     UINT128 CX, CY, T, CX2, CR, Stemp, res, REM_H, C2N;\n+     UINT64 sign_x, sign_y, remainder_h, carry, CY64, valid_x;\n+     int_float tempx;\n+     int exponent_x, exponent_y, digits_x, extra_digits, amount;\n+     int expon_diff, total_digits, bin_expon_cx, rmode, status;\n+\n+valid_x = unpack_BID128_value (&sign_x, &exponent_x, &CX, x);\n \n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n+if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n     // y is Inf. or NaN\n #ifdef SET_STATUS_FLAGS\n-    if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n-      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n \n     // test if y is NaN\n-    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n-        // set status flags\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n-      }\n+  if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  }\n #endif\n-      res.w[1] = y.w[1] & QUIET_MASK64;\n-      res.w[0] = y.w[0];\n-      BID_RETURN (res);\n-    }\n+  if ((x.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull) {\n+    res.w[1] = CY.w[1] & QUIET_MASK64;\n+    res.w[0] = CY.w[0];\n+  } else {\n+    res.w[1] = CX.w[1] & QUIET_MASK64;\n+    res.w[0] = CX.w[0];\n+  }\n+  BID_RETURN (res);\n+}\n     // y is Infinity?\n-    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // check if x is not Inf.\n-      if (((x.w[1] & 0x7c00000000000000ull) < 0x7800000000000000ull)) {\n-        // return NaN \n+if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if x is not Inf.\n+  if (((x.w[1] & 0x7c00000000000000ull) < 0x7800000000000000ull)) {\n+    // return NaN \n #ifdef SET_STATUS_FLAGS\n-        // set status flags\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    // set status flags\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-        res.w[1] = 0x7c00000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      } else if (((x.w[1] & 0x7c00000000000000ull) <= 0x7800000000000000ull)) {\n-        res.w[1] = x.w[1];\n-        res.w[0] = x.w[0];\n-        BID_RETURN (res);\n-      }\n-    }\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  } else\n+    if (((x.w[1] & 0x7c00000000000000ull) <= 0x7800000000000000ull)) {\n+    res.w[1] = CX.w[1] & QUIET_MASK64;\n+    res.w[0] = CX.w[0];\n+    BID_RETURN (res);\n   }\n+}\n \n-  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n-    // test if x is NaN or Inf\n-    if ((x.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull) {\n+}\n+\n+if (!valid_x) {\n+  // test if x is NaN or Inf\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      // set status flags\n-      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    // set status flags\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res.w[1] = 0x7c00000000000000ull;\n-      res.w[0] = x.w[0];\n-      BID_RETURN (res);\n-    } else if ((x.w[1] & 0x7c00000000000000ull) ==\n-               0x7c00000000000000ull) {\n-      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  } else if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-        // set status flags\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+      // set status flags\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      }\n-      res.w[1] = x.w[1] & QUIET_MASK64;\n-      res.w[0] = x.w[0];\n-      BID_RETURN (res);\n-    }\n-    if (!CX.w[1] && !CX.w[0]) {\n-      get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n-      BID_RETURN (res);\n     }\n+    res.w[1] = CX.w[1] & QUIET_MASK64;\n+    res.w[0] = CX.w[0];\n+    BID_RETURN (res);\n   }\n-  // get number of decimal digits in coefficient_x\n-  if (CX.w[1]) {\n-    tempx.d = (float) CX.w[1];\n-    bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f + 64;\n-  } else {\n-    tempx.d = (float) CX.w[0];\n-    bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+  if (!CX.w[1] && !CX.w[0]) {\n+    get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+    BID_RETURN (res);\n   }\n-  digits_x = __bid_estimate_decimal_digits[bin_expon_cx];\n-  if (CX.w[1] > __bid_power10_table_128[digits_x].w[1]\n-      || (CX.w[1] == __bid_power10_table_128[digits_x].w[1]\n-          && CX.w[0] >= __bid_power10_table_128[digits_x].w[0]))\n-    digits_x++;\n+}\n+  // get number of decimal digits in coefficient_x\n+if (CX.w[1]) {\n+  tempx.d = (float) CX.w[1];\n+  bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f + 64;\n+} else {\n+  tempx.d = (float) CX.w[0];\n+  bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+}\n \n-  expon_diff = exponent_x - exponent_y;\n-  total_digits = digits_x + expon_diff;\n+digits_x = estimate_decimal_digits[bin_expon_cx];\n+if (CX.w[1] > power10_table_128[digits_x].w[1]\n+    || (CX.w[1] == power10_table_128[digits_x].w[1]\n+\t&& CX.w[0] >= power10_table_128[digits_x].w[0]))\n+  digits_x++;\n \n-  if ((UINT32) total_digits <= 34) {\n-    if (expon_diff >= 0) {\n-      T = __bid_power10_table_128[expon_diff];\n-      __mul_128x128_low (CX2, T, CX);\n-      get_BID128_very_fast (&res, sign_x, exponent_y, CX2);\n-      BID_RETURN (res);\n-    }\n+expon_diff = exponent_x - exponent_y;\n+total_digits = digits_x + expon_diff;\n+\n+if ((UINT32) total_digits <= 34) {\n+  if (expon_diff >= 0) {\n+    T = power10_table_128[expon_diff];\n+    __mul_128x128_low (CX2, T, CX);\n+    get_BID128_very_fast (&res, sign_x, exponent_y, CX2);\n+    BID_RETURN (res);\n+  }\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n-    rmode = rnd_mode;\n-    if (sign_x && (unsigned) (rmode - 1) < 2)\n-      rmode = 3 - rmode;\n+  rmode = rnd_mode;\n+  if (sign_x && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n #else\n-    rmode = 0;\n+  rmode = 0;\n #endif\n #else\n-    rmode = 0;\n+  rmode = 0;\n #endif\n-    // must round off -expon_diff digits\n-    extra_digits = -expon_diff;\n-    __add_128_128 (CX, CX, __bid_round_const_table_128[rmode][extra_digits]);\n+  // must round off -expon_diff digits\n+  extra_digits = -expon_diff;\n+  __add_128_128 (CX, CX, round_const_table_128[rmode][extra_digits]);\n \n-    // get P*(2^M[extra_digits])/10^extra_digits\n-    __mul_128x128_to_256 (CT, CX, __bid_reciprocals10_128[extra_digits]);\n+  // get P*(2^M[extra_digits])/10^extra_digits\n+  __mul_128x128_to_256 (CT, CX, reciprocals10_128[extra_digits]);\n \n-    // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-    amount = __bid_recip_scale[extra_digits];\n-    CX2.w[0] = CT.w[2];\n-    CX2.w[1] = CT.w[3];\n-    if (amount >= 64) {\n-      CR.w[1] = 0;\n-      CR.w[0] = CX2.w[1] >> (amount - 64);\n-    } else {\n-      __shr_128 (CR, CX2, amount);\n-    }\n+  // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+  amount = recip_scale[extra_digits];\n+  CX2.w[0] = CT.w[2];\n+  CX2.w[1] = CT.w[3];\n+  if (amount >= 64) {\n+    CR.w[1] = 0;\n+    CR.w[0] = CX2.w[1] >> (amount - 64);\n+  } else {\n+    __shr_128 (CR, CX2, amount);\n+  }\n \n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n-    if (rnd_mode == 0)\n+  if (rnd_mode == 0)\n #endif\n-      if (CR.w[0] & 1) {\n-        // check whether fractional part of initial_P/10^extra_digits is \n-        // exactly .5 this is the same as fractional part of \n-        // (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n+    if (CR.w[0] & 1) {\n+      // check whether fractional part of initial_P/10^extra_digits is \n+      // exactly .5 this is the same as fractional part of \n+      // (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n \n-        // get remainder\n-        if (amount >= 64) {\n-          remainder_h = CX2.w[0] | (CX2.w[1] << (128 - amount));\n-        } else\n-          remainder_h = CX2.w[0] << (64 - amount);\n+      // get remainder\n+      if (amount >= 64) {\n+\tremainder_h = CX2.w[0] | (CX2.w[1] << (128 - amount));\n+      } else\n+\tremainder_h = CX2.w[0] << (64 - amount);\n \n-        // test whether fractional part is 0\n-        if (!remainder_h\n-            && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-                || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-                    && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0]))) {\n-          CR.w[0]--;\n-        }\n+      // test whether fractional part is 0\n+      if (!remainder_h\n+\t  && (CT.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t      || (CT.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t  && CT.w[0] < reciprocals10_128[extra_digits].w[0]))) {\n+\tCR.w[0]--;\n       }\n+    }\n #endif\n \n #ifdef SET_STATUS_FLAGS\n-    status = INEXACT_EXCEPTION;\n+  status = INEXACT_EXCEPTION;\n \n-    // get remainder\n-    if (amount >= 64) {\n-      REM_H.w[1] = (CX2.w[1] << (128 - amount));\n-      REM_H.w[0] = CX2.w[0];\n-    } else {\n-      REM_H.w[1] = CX2.w[0] << (64 - amount);\n-      REM_H.w[0] = 0;\n-    }\n+  // get remainder\n+  if (amount >= 64) {\n+    REM_H.w[1] = (CX2.w[1] << (128 - amount));\n+    REM_H.w[0] = CX2.w[0];\n+  } else {\n+    REM_H.w[1] = CX2.w[0] << (64 - amount);\n+    REM_H.w[0] = 0;\n+  }\n \n-    switch (rmode) {\n-    case ROUNDING_TO_NEAREST:\n-    case ROUNDING_TIES_AWAY:\n-      // test whether fractional part is 0\n-      if (REM_H.w[1] == 0x8000000000000000ull && !REM_H.w[0]\n-          && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-              || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-                  && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n-        status = EXACT_STATUS;\n-      break;\n-    case ROUNDING_DOWN:\n-    case ROUNDING_TO_ZERO:\n-      if (!(REM_H.w[1] | REM_H.w[0])\n-          && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-              || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-                  && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n-        status = EXACT_STATUS;\n-      break;\n-    default:\n-      // round up\n-      __add_carry_out (Stemp.w[0], CY64, CT.w[0],\n-                       __bid_reciprocals10_128[extra_digits].w[0]);\n-      __add_carry_in_out (Stemp.w[1], carry, CT.w[1],\n-                          __bid_reciprocals10_128[extra_digits].w[1], CY64);\n-      if (amount < 64) {\n-        C2N.w[1] = 0;\n-        C2N.w[0] = ((UINT64) 1) << amount;\n-        REM_H.w[0] = REM_H.w[1] >> (64 - amount);\n-        REM_H.w[1] = 0;\n-      } else {\n-        C2N.w[1] = ((UINT64) 1) << (amount - 64);\n-        C2N.w[0] = 0;\n-        REM_H.w[1] >>= (128 - amount);\n-      }\n-      REM_H.w[0] += carry;\n-      if (REM_H.w[0] < carry)\n-        REM_H.w[1]++;\n-      if (__unsigned_compare_ge_128 (REM_H, C2N))\n-        status = EXACT_STATUS;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\n+  case ROUNDING_TIES_AWAY:\n+    // test whether fractional part is 0\n+    if (REM_H.w[1] == 0x8000000000000000ull && !REM_H.w[0]\n+\t&& (CT.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t    || (CT.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t&& CT.w[0] < reciprocals10_128[extra_digits].w[0])))\n+      status = EXACT_STATUS;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    if (!(REM_H.w[1] | REM_H.w[0])\n+\t&& (CT.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t    || (CT.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t&& CT.w[0] < reciprocals10_128[extra_digits].w[0])))\n+      status = EXACT_STATUS;\n+    break;\n+  default:\n+    // round up\n+    __add_carry_out (Stemp.w[0], CY64, CT.w[0],\n+\t\t     reciprocals10_128[extra_digits].w[0]);\n+    __add_carry_in_out (Stemp.w[1], carry, CT.w[1],\n+\t\t\treciprocals10_128[extra_digits].w[1], CY64);\n+    if (amount < 64) {\n+      C2N.w[1] = 0;\n+      C2N.w[0] = ((UINT64) 1) << amount;\n+      REM_H.w[0] = REM_H.w[1] >> (64 - amount);\n+      REM_H.w[1] = 0;\n+    } else {\n+      C2N.w[1] = ((UINT64) 1) << (amount - 64);\n+      C2N.w[0] = 0;\n+      REM_H.w[1] >>= (128 - amount);\n     }\n+    REM_H.w[0] += carry;\n+    if (REM_H.w[0] < carry)\n+      REM_H.w[1]++;\n+    if (__unsigned_compare_ge_128 (REM_H, C2N))\n+      status = EXACT_STATUS;\n+  }\n \n-    __set_status_flags (pfpsf, status);\n+  __set_status_flags (pfpsf, status);\n \n #endif\n-    get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n-    BID_RETURN (res);\n-  }\n-  if (total_digits < 0) {\n-    CR.w[1] = CR.w[0] = 0;\n+  get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n+  BID_RETURN (res);\n+}\n+if (total_digits < 0) {\n+  CR.w[1] = CR.w[0] = 0;\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n-    rmode = rnd_mode;\n-    if (sign_x && (unsigned) (rmode - 1) < 2)\n-      rmode = 3 - rmode;\n-    if (rmode == ROUNDING_UP)\n-      CR.w[0] = 1;\n+  rmode = rnd_mode;\n+  if (sign_x && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  if (rmode == ROUNDING_UP)\n+    CR.w[0] = 1;\n #endif\n #endif\n #ifdef SET_STATUS_FLAGS\n-    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n #endif\n-    get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n-    BID_RETURN (res);\n-  }\n+  get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n+  BID_RETURN (res);\n+}\n   // else  more than 34 digits in coefficient\n #ifdef SET_STATUS_FLAGS\n-  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-  res.w[1] = 0x7c00000000000000ull;\n-  res.w[0] = 0;\n-  BID_RETURN (res);\n+res.w[1] = 0x7c00000000000000ull;\n+res.w[0] = 0;\n+BID_RETURN (res);\n \n }"}, {"sha": "f3e5546befd7d31af65d5438d8e3f82d9dde2840", "filename": "libgcc/config/libbid/bid128_rem.c", "status": "modified", "additions": 158, "deletions": 155, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -27,193 +27,196 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n #define BID_128RES\n-#include \"div_macros.h\"\n+#include \"bid_div_macros.h\"\n \n \n-BID128_FUNCTION_ARG2(__bid128_rem, x, y)\n+BID128_FUNCTION_ARG2_NORND_CUSTOMRESTYPE (UINT128, bid128_rem, x, y)\n \n-  UINT256 P256;\n-  UINT128 CX, CY, CX2, CQ, CR, T, CXS, P128, res;\n-  UINT64 sign_x, sign_y;\n-  SINT64 D;\n-  int_float f64, fx;\n-  int exponent_x = 0, exponent_y, diff_expon, bin_expon_cx, scale, scale0;\n+     UINT256 P256;\n+     UINT128 CX, CY, CX2, CQ, CR, T, CXS, P128, res;\n+     UINT64 sign_x, sign_y, valid_y;\n+     SINT64 D;\n+     int_float f64, fx;\n+     int exponent_x, exponent_y, diff_expon, bin_expon_cx, scale,\n+       scale0;\n \n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+\n+valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);\n+\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n #ifdef SET_STATUS_FLAGS\n-    if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n-      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n     // test if x is NaN\n-    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res.w[1] = x.w[1] & QUIET_MASK64;\n-      res.w[0] = x.w[0];\n-      BID_RETURN (res);\n-    }\n+  res.w[1] = CX.w[1] & QUIET_MASK64;\n+  res.w[0] = CX.w[0];\n+  BID_RETURN (res);\n+}\n     // x is Infinity?\n-    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // check if y is Inf.\n-      if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n-        // return NaN \n-      {\n+if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  // check if y is Inf.\n+  if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n+    // return NaN \n+  {\n #ifdef SET_STATUS_FLAGS\n-        // set status flags\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    // set status flags\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-        res.w[1] = 0x7c00000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      }\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n \n-    }\n+}\n     // x is 0\n-    if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) { // not Inf/NaN\n-      if ((!y.w[0]) && !(y.w[1] & 0x0001ffffffffffffull)) {\n+if ((!CY.w[1]) && (!CY.w[0])) {\n #ifdef SET_STATUS_FLAGS\n-        // set status flags\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  // set status flags\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-        // x=y=0, return NaN\n-        res.w[1] = 0x7c00000000000000ull;\n-        res.w[0] = 0;\n-        BID_RETURN (res);\n-      }\n-      // return 0\n-      exponent_y = (y.w[1] >> 49) & 0x3fff;\n-      if (exponent_x > exponent_y)\n-        exponent_x = exponent_y;\n-\n-      res.w[1] = sign_x | (((UINT64) exponent_x) << 49);\n-      res.w[0] = 0;\n-      BID_RETURN (res);\n-    }\n-  }\n-  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n-    // y is Inf. or NaN\n+  // x=y=0, return NaN\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+if (valid_y || ((y.w[1] & NAN_MASK64) == INFINITY_MASK64)) {\n+  // return 0\n+  if ((exponent_x > exponent_y)\n+      && ((y.w[1] & NAN_MASK64) != INFINITY_MASK64))\n+    exponent_x = exponent_y;\n+\n+  res.w[1] = sign_x | (((UINT64) exponent_x) << 49);\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+}\n+if (!valid_y) {\n+  // y is Inf. or NaN\n \n-    // test if y is NaN\n-    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+  // test if y is NaN\n+  if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n-        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+    if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res.w[1] = y.w[1] & QUIET_MASK64;\n-      res.w[0] = y.w[0];\n-      BID_RETURN (res);\n-    }\n-    // y is Infinity?\n-    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // return x\n-      res.w[1] = x.w[1];\n-      res.w[0] = x.w[0];\n-      BID_RETURN (res);\n-    }\n-    // y is 0\n+    res.w[1] = CY.w[1] & QUIET_MASK64;\n+    res.w[0] = CY.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return x\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is 0\n #ifdef SET_STATUS_FLAGS\n-    // set status flags\n-    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  // set status flags\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-    res.w[1] = 0x7c00000000000000ull;\n-    res.w[0] = 0;\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+}\n+\n+diff_expon = exponent_x - exponent_y;\n+\n+if (diff_expon <= 0) {\n+  diff_expon = -diff_expon;\n+\n+  if (diff_expon > 34) {\n+    // |x|<|y| in this case\n+    res = x;\n     BID_RETURN (res);\n   }\n+  // set exponent of y to exponent_x, scale coefficient_y\n+  T = power10_table_128[diff_expon];\n+  __mul_128x128_to_256 (P256, CY, T);\n \n-  diff_expon = exponent_x - exponent_y;\n-\n-  if (diff_expon <= 0) {\n-    diff_expon = -diff_expon;\n-\n-    if (diff_expon > 34) {\n-      // |x|<|y| in this case\n-      res = x;\n-      BID_RETURN (res);\n-    }\n-    // set exponent of y to exponent_x, scale coefficient_y\n-    T = __bid_power10_table_128[diff_expon];\n-    __mul_128x128_to_256 (P256, CY, T);\n-\n-    if (P256.w[2] || P256.w[3]) {\n-      // |x|<|y| in this case\n-      res = x;\n-      BID_RETURN (res);\n-    }\n-\n-    CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n-    CX2.w[0] = CX.w[0] << 1;\n-    if (__unsigned_compare_ge_128 (P256, CX2)) {\n-      // |x|<|y| in this case\n-      res = x;\n-      BID_RETURN (res);\n-    }\n-\n-    P128.w[0] = P256.w[0];\n-    P128.w[1] = P256.w[1];\n-    __div_128_by_128 (&CQ, &CR, CX, P128);\n-\n-    CX2.w[1] = (CR.w[1] << 1) | (CR.w[0] >> 63);\n-    CX2.w[0] = CR.w[0] << 1;\n-    if ((__unsigned_compare_gt_128 (CX2, P256))\n-        || (CX2.w[1] == P256.w[1] && CX2.w[0] == P256.w[0]\n-            && (CQ.w[0] & 1))) {\n-      __sub_128_128 (CR, P256, CR);\n-      sign_x ^= 0x8000000000000000ull;\n-    }\n-\n-    get_BID128_very_fast (&res, sign_x, exponent_x, CR);\n+  if (P256.w[2] || P256.w[3]) {\n+    // |x|<|y| in this case\n+    res = x;\n     BID_RETURN (res);\n   }\n-  // 2^64\n-  f64.i = 0x5f800000;\n-\n-  scale0 = 38;\n-  if (!CY.w[1])\n-    scale0 = 34;\n-\n-  while (diff_expon > 0) {\n-    // get number of digits in CX and scale=38-digits\n-    // fx ~ CX\n-    fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n-    bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n-    scale = scale0 - __bid_estimate_decimal_digits[bin_expon_cx];\n-    // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n-    D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n-    if (D > 0\n-        || (!D\n-            && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n-      scale--;\n-\n-    if (diff_expon >= scale)\n-      diff_expon -= scale;\n-    else {\n-      scale = diff_expon;\n-      diff_expon = 0;\n-    }\n-\n-    T = __bid_power10_table_128[scale];\n-    __mul_128x128_low (CXS, CX, T);\n-\n-    __div_128_by_128 (&CQ, &CX, CXS, CY);\n-\n-    // check for remainder == 0\n-    if (!CX.w[1] && !CX.w[0]) {\n-      get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n-      BID_RETURN (res);\n-    }\n-  }\n \n   CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n   CX2.w[0] = CX.w[0] << 1;\n-  if ((__unsigned_compare_gt_128 (CX2, CY))\n-      || (CX2.w[1] == CY.w[1] && CX2.w[0] == CY.w[0] && (CQ.w[0] & 1))) {\n-    __sub_128_128 (CX, CY, CX);\n+  if (__unsigned_compare_ge_128 (P256, CX2)) {\n+    // |x|<|y| in this case\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+\n+  P128.w[0] = P256.w[0];\n+  P128.w[1] = P256.w[1];\n+  __div_128_by_128 (&CQ, &CR, CX, P128);\n+\n+  CX2.w[1] = (CR.w[1] << 1) | (CR.w[0] >> 63);\n+  CX2.w[0] = CR.w[0] << 1;\n+  if ((__unsigned_compare_gt_128 (CX2, P256))\n+      || (CX2.w[1] == P256.w[1] && CX2.w[0] == P256.w[0]\n+\t  && (CQ.w[0] & 1))) {\n+    __sub_128_128 (CR, P256, CR);\n     sign_x ^= 0x8000000000000000ull;\n   }\n \n-  get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+  get_BID128_very_fast (&res, sign_x, exponent_x, CR);\n   BID_RETURN (res);\n+}\n+  // 2^64\n+f64.i = 0x5f800000;\n+\n+scale0 = 38;\n+if (!CY.w[1])\n+  scale0 = 34;\n+\n+while (diff_expon > 0) {\n+  // get number of digits in CX and scale=38-digits\n+  // fx ~ CX\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+  scale = scale0 - estimate_decimal_digits[bin_expon_cx];\n+  // scale = 38-estimate_decimal_digits[bin_expon_cx];\n+  D = CX.w[1] - power10_index_binexp_128[bin_expon_cx].w[1];\n+  if (D > 0\n+      || (!D && CX.w[0] >= power10_index_binexp_128[bin_expon_cx].w[0]))\n+    scale--;\n+\n+  if (diff_expon >= scale)\n+    diff_expon -= scale;\n+  else {\n+    scale = diff_expon;\n+    diff_expon = 0;\n+  }\n+\n+  T = power10_table_128[scale];\n+  __mul_128x128_low (CXS, CX, T);\n+\n+  __div_128_by_128 (&CQ, &CX, CXS, CY);\n+\n+  // check for remainder == 0\n+  if (!CX.w[1] && !CX.w[0]) {\n+    get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+    BID_RETURN (res);\n+  }\n+}\n+\n+CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+CX2.w[0] = CX.w[0] << 1;\n+if ((__unsigned_compare_gt_128 (CX2, CY))\n+    || (CX2.w[1] == CY.w[1] && CX2.w[0] == CY.w[0] && (CQ.w[0] & 1))) {\n+  __sub_128_128 (CX, CY, CX);\n+  sign_x ^= 0x8000000000000000ull;\n+}\n+\n+get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+BID_RETURN (res);\n }"}, {"sha": "d517095a77042c4eabe3e54cd1403df759352983", "filename": "libgcc/config/libbid/bid128_round_integral.c", "status": "modified", "additions": 1631, "deletions": 1587, "changes": 3218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "fa354b1080b57abac17b45ff84b35f3678583c6c", "filename": "libgcc/config/libbid/bid128_scalb.c", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -34,53 +34,68 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n \n \n-BID128_FUNCTION_ARG128_ARGTYPE2(__bid128_scalb, x, int, n)\n+BID128_FUNCTION_ARG128_ARGTYPE2 (bid128_scalb, x, int, n)\n \n-UINT128 CX, CX2, CX8, res;\n-  UINT64 sign_x;\n-  int exponent_x, rmode;\n+     UINT128 CX, CX2, CX8, res;\n+     SINT64 exp64;\n+     UINT64 sign_x;\n+     int exponent_x, rmode;\n \n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n     // x is Inf. or NaN or 0\n-    res.w[1] = x.w[1];\n-    res.w[0] = x.w[0];\n-    BID_RETURN (res);\n-  }\n+#ifdef SET_STATUS_FLAGS\n+if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+res.w[1] = CX.w[1] & QUIET_MASK64;\n+res.w[0] = CX.w[0];\n+if (!CX.w[1]) {\n+       exp64 = (SINT64) exponent_x + (SINT64) n;\n+\t   if(exp64<0) exp64=0;\n+\t   if(exp64>MAX_DECIMAL_EXPONENT_128) exp64=MAX_DECIMAL_EXPONENT_128;\n+       exponent_x = exp64;\n+  get_BID128_very_fast (&res, sign_x, exponent_x, CX);\n+}\n+BID_RETURN (res);\n+}\n \n-  exponent_x += n;\n+exp64 = (SINT64) exponent_x + (SINT64) n;\n+exponent_x = exp64;\n \n-  if ((UINT32) exponent_x <= MAX_DECIMAL_EXPONENT_128) {\n-    get_BID128_very_fast (&res, sign_x, exponent_x, CX);\n-    BID_RETURN (res);\n-  }\n+if ((UINT32) exponent_x <= MAX_DECIMAL_EXPONENT_128) {\n+  get_BID128_very_fast (&res, sign_x, exponent_x, CX);\n+  BID_RETURN (res);\n+}\n   // check for overflow\n-  if (exponent_x > MAX_DECIMAL_EXPONENT_128) {\n-    if (CX.w[1] < 0x314dc6448d93ull) {\n-      // try to normalize coefficient\n-      do {\n-\tCX8.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n-\tCX8.w[0] = CX.w[0] << 3;\n-\tCX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n-\tCX2.w[0] = CX.w[0] << 1;\n-\t__add_128_128 (CX, CX2, CX8);\n-\n-\texponent_x--;\n-      }\n-      while (CX.w[1] < 0x314dc6448d93ull\n-\t     && exponent_x > MAX_DECIMAL_EXPONENT_128);\n-\n-      if (exponent_x <= MAX_DECIMAL_EXPONENT_128) {\n-\tget_BID128_very_fast (&res, sign_x, exponent_x, CX);\n-\tBID_RETURN (res);\n-      }\n+if (exp64 > MAX_DECIMAL_EXPONENT_128) {\n+  if (CX.w[1] < 0x314dc6448d93ull) {\n+    // try to normalize coefficient\n+    do {\n+      CX8.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n+      CX8.w[0] = CX.w[0] << 3;\n+      CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+      CX2.w[0] = CX.w[0] << 1;\n+      __add_128_128 (CX, CX2, CX8);\n+\n+      exponent_x--;\n+      exp64--;\n     }\n+    while (CX.w[1] < 0x314dc6448d93ull\n+\t   && exp64 > MAX_DECIMAL_EXPONENT_128);\n+\n   }\n+  if (exp64 <= MAX_DECIMAL_EXPONENT_128) {\n+    get_BID128_very_fast (&res, sign_x, exponent_x, CX);\n+    BID_RETURN (res);\n+  } else\n+    exponent_x = 0x7fffffff;\t// overflow\n+}\n   // exponent < 0\n   // the BID pack routine will round the coefficient\n-  rmode = rnd_mode;\n-  get_BID128 (&res, sign_x, exponent_x, CX, (unsigned int *) &rmode,\n-\t      pfpsf);\n-  BID_RETURN (res);\n+rmode = rnd_mode;\n+get_BID128 (&res, sign_x, exponent_x, CX, (unsigned int *) &rmode,\n+\t    pfpsf);\n+BID_RETURN (res);\n \n }"}, {"sha": "0677c39e95175576cb002480369af337d3b15f34", "filename": "libgcc/config/libbid/bid128_sqrt.c", "status": "modified", "additions": 473, "deletions": 182, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -27,252 +27,543 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n #define BID_128RES\n-#include \"sqrt_macros.h\"\n+#include \"bid_internal.h\"\n+#include \"bid_sqrt_macros.h\"\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+#include <fenv.h>\n \n-BID128_FUNCTION_ARG1(__bid128_sqrt, x)\n+#define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT\n+#endif\n+\n+BID128_FUNCTION_ARG1 (bid128_sqrt, x)\n \n-  UINT256 M256, C256, C4, C8;\n-  UINT128 CX, CX1, CX2, A10, S2, T128, TP128, CS, CSM, res;\n-  UINT64 sign_x, Carry;\n-  SINT64 D;\n-  int_float fx, f64;\n-  int exponent_x = 0, bin_expon_cx;\n-  int digits, scale, exponent_q;\n+     UINT256 M256, C256, C4, C8;\n+     UINT128 CX, CX1, CX2, A10, S2, T128, TP128, CS, CSM, res;\n+     UINT64 sign_x, Carry;\n+     SINT64 D;\n+     int_float fx, f64;\n+     int exponent_x, bin_expon_cx;\n+     int digits, scale, exponent_q;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n \n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n-    res.w[1] = x.w[1];\n-    res.w[0] = x.w[0];\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+res.w[1] = CX.w[1];\n+res.w[0] = CX.w[0];\n     // NaN ?\n-    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n #ifdef SET_STATUS_FLAGS\n-      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+  if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-\t  res.w[1] &= QUIET_MASK64;\n-      BID_RETURN (res);\n-    }\n+  res.w[1] = CX.w[1] & QUIET_MASK64;\n+  BID_RETURN (res);\n+}\n     // x is Infinity?\n-    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      if (sign_x) {\n-\t// -Inf, return NaN\n-\tres.w[1] = 0x7c00000000000000ull;\n-#ifdef SET_STATUS_FLAGS\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-      }\n-      BID_RETURN (res);\n-    }\n-    // x is 0 otherwise\n-\n-    res.w[1] =\n-      sign_x |\n-      ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1) <<\n-       49);\n-    BID_RETURN (res);\n-  }\n+if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  res.w[1] = CX.w[1];\n   if (sign_x) {\n+    // -Inf, return NaN\n     res.w[1] = 0x7c00000000000000ull;\n-    res.w[0] = 0;\n #ifdef SET_STATUS_FLAGS\n     __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-    BID_RETURN (res);\n   }\n+  BID_RETURN (res);\n+}\n+    // x is 0 otherwise\n+\n+res.w[1] =\n+  sign_x |\n+  ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1) << 49);\n+res.w[0] = 0;\n+BID_RETURN (res);\n+}\n+if (sign_x) {\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n   // 2^64\n-  f64.i = 0x5f800000;\n+f64.i = 0x5f800000;\n \n   // fx ~ CX\n-  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n-  bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n-  digits = __bid_estimate_decimal_digits[bin_expon_cx];\n-\n-  A10 = CX;\n-  if (exponent_x & 1) {\n-    A10.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n-    A10.w[0] = CX.w[0] << 3;\n-    CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n-    CX2.w[0] = CX.w[0] << 1;\n-    __add_128_128 (A10, A10, CX2);\n-  }\n+fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+digits = estimate_decimal_digits[bin_expon_cx];\n \n-  CS.w[0] = short_sqrt128 (A10);\n-  CS.w[1] = 0;\n+A10 = CX;\n+if (exponent_x & 1) {\n+  A10.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n+  A10.w[0] = CX.w[0] << 3;\n+  CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+  CX2.w[0] = CX.w[0] << 1;\n+  __add_128_128 (A10, A10, CX2);\n+}\n+\n+CS.w[0] = short_sqrt128 (A10);\n+CS.w[1] = 0;\n   // check for exact result\n-  if (CS.w[0] * CS.w[0] == A10.w[0]) {\n-    __mul_64x64_to_128_fast (S2, CS.w[0], CS.w[0]);\n-    if (S2.w[1] == A10.w[1])\t// && S2.w[0]==A10.w[0])\n-    {\n-      get_BID128_very_fast (&res, 0,\n-\t\t\t    (exponent_x +\n-\t\t\t     DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n-      BID_RETURN (res);\n-    }\n+if (CS.w[0] * CS.w[0] == A10.w[0]) {\n+  __mul_64x64_to_128_fast (S2, CS.w[0], CS.w[0]);\n+  if (S2.w[1] == A10.w[1])\t// && S2.w[0]==A10.w[0])\n+  {\n+    get_BID128_very_fast (&res, 0,\n+\t\t\t  (exponent_x +\n+\t\t\t   DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n   }\n+}\n   // get number of digits in CX\n-  D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n-  if (D > 0\n-      || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n-    digits++;\n+D = CX.w[1] - power10_index_binexp_128[bin_expon_cx].w[1];\n+if (D > 0\n+    || (!D && CX.w[0] >= power10_index_binexp_128[bin_expon_cx].w[0]))\n+  digits++;\n \n   // if exponent is odd, scale coefficient by 10\n-  scale = 67 - digits;\n-  exponent_q = exponent_x - scale;\n-  scale += (exponent_q & 1);\t// exp. bias is even\n+scale = 67 - digits;\n+exponent_q = exponent_x - scale;\n+scale += (exponent_q & 1);\t// exp. bias is even\n \n-  if (scale > 38) {\n-    T128 = __bid_power10_table_128[scale - 37];\n-    __mul_128x128_low (CX1, CX, T128);\n+if (scale > 38) {\n+  T128 = power10_table_128[scale - 37];\n+  __mul_128x128_low (CX1, CX, T128);\n \n-    TP128 = __bid_power10_table_128[37];\n-    __mul_128x128_to_256 (C256, CX1, TP128);\n-  } else {\n-    T128 = __bid_power10_table_128[scale];\n-    __mul_128x128_to_256 (C256, CX, T128);\n-  }\n+  TP128 = power10_table_128[37];\n+  __mul_128x128_to_256 (C256, CX1, TP128);\n+} else {\n+  T128 = power10_table_128[scale];\n+  __mul_128x128_to_256 (C256, CX, T128);\n+}\n \n \n   // 4*C256\n-  C4.w[3] = (C256.w[3] << 2) | (C256.w[2] >> 62);\n-  C4.w[2] = (C256.w[2] << 2) | (C256.w[1] >> 62);\n-  C4.w[1] = (C256.w[1] << 2) | (C256.w[0] >> 62);\n-  C4.w[0] = C256.w[0] << 2;\n+C4.w[3] = (C256.w[3] << 2) | (C256.w[2] >> 62);\n+C4.w[2] = (C256.w[2] << 2) | (C256.w[1] >> 62);\n+C4.w[1] = (C256.w[1] << 2) | (C256.w[0] >> 62);\n+C4.w[0] = C256.w[0] << 2;\n \n-  long_sqrt128 (&CS, C256);\n+long_sqrt128 (&CS, C256);\n \n #ifndef IEEE_ROUND_NEAREST\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-  if (!((rnd_mode) & 3)) {\n+if (!((rnd_mode) & 3)) {\n #endif\n #endif\n-    // compare to midpoints\n-    CSM.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n-    CSM.w[0] = (CS.w[0] + CS.w[0]) | 1;\n-    // CSM^2\n-    //__mul_128x128_to_256(M256, CSM, CSM);\n-    __sqr128_to_256 (M256, CSM);\n-\n-    if (C4.w[3] > M256.w[3]\n-\t|| (C4.w[3] == M256.w[3]\n-\t    && (C4.w[2] > M256.w[2]\n-\t\t|| (C4.w[2] == M256.w[2]\n-\t\t    && (C4.w[1] > M256.w[1]\n-\t\t\t|| (C4.w[1] == M256.w[1]\n-\t\t\t    && C4.w[0] > M256.w[0])))))) {\n-      // round up\n-      CS.w[0]++;\n+  // compare to midpoints\n+  CSM.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+  CSM.w[0] = (CS.w[0] + CS.w[0]) | 1;\n+  // CSM^2\n+  //__mul_128x128_to_256(M256, CSM, CSM);\n+  __sqr128_to_256 (M256, CSM);\n+\n+  if (C4.w[3] > M256.w[3]\n+      || (C4.w[3] == M256.w[3]\n+\t  && (C4.w[2] > M256.w[2]\n+\t      || (C4.w[2] == M256.w[2]\n+\t\t  && (C4.w[1] > M256.w[1]\n+\t\t      || (C4.w[1] == M256.w[1]\n+\t\t\t  && C4.w[0] > M256.w[0])))))) {\n+    // round up\n+    CS.w[0]++;\n+    if (!CS.w[0])\n+      CS.w[1]++;\n+  } else {\n+    C8.w[1] = (CS.w[1] << 3) | (CS.w[0] >> 61);\n+    C8.w[0] = CS.w[0] << 3;\n+    // M256 - 8*CSM\n+    __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] - Carry;\n+\n+    // if CSM' > C256, round up\n+    if (M256.w[3] > C4.w[3]\n+\t|| (M256.w[3] == C4.w[3]\n+\t    && (M256.w[2] > C4.w[2]\n+\t\t|| (M256.w[2] == C4.w[2]\n+\t\t    && (M256.w[1] > C4.w[1]\n+\t\t\t|| (M256.w[1] == C4.w[1]\n+\t\t\t    && M256.w[0] > C4.w[0])))))) {\n+      // round down\n       if (!CS.w[0])\n-\tCS.w[1]++;\n-    } else {\n-      C8.w[1] = (CS.w[1] << 3) | (CS.w[0] >> 61);\n-      C8.w[0] = CS.w[0] << 3;\n-      // M256 - 8*CSM\n-      __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n-      __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n-      __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n-      M256.w[3] = M256.w[3] - Carry;\n-\n-      // if CSM' > C256, round up\n-      if (M256.w[3] > C4.w[3]\n-\t  || (M256.w[3] == C4.w[3]\n-\t      && (M256.w[2] > C4.w[2]\n-\t\t  || (M256.w[2] == C4.w[2]\n-\t\t      && (M256.w[1] > C4.w[1]\n-\t\t\t  || (M256.w[1] == C4.w[1]\n-\t\t\t      && M256.w[0] > C4.w[0])))))) {\n-\t// round down\n-\tif (!CS.w[0])\n-\t  CS.w[1]--;\n-\tCS.w[0]--;\n-      }\n+\tCS.w[1]--;\n+      CS.w[0]--;\n     }\n+  }\n #ifndef IEEE_ROUND_NEAREST\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-  } else {\n-    __sqr128_to_256 (M256, CS);\n-    C8.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n-    C8.w[0] = CS.w[0] << 1;\n+} else {\n+  __sqr128_to_256 (M256, CS);\n+  C8.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+  C8.w[0] = CS.w[0] << 1;\n+  if (M256.w[3] > C256.w[3]\n+      || (M256.w[3] == C256.w[3]\n+\t  && (M256.w[2] > C256.w[2]\n+\t      || (M256.w[2] == C256.w[2]\n+\t\t  && (M256.w[1] > C256.w[1]\n+\t\t      || (M256.w[1] == C256.w[1]\n+\t\t\t  && M256.w[0] > C256.w[0])))))) {\n+    __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] - Carry;\n+    M256.w[0]++;\n+    if (!M256.w[0]) {\n+      M256.w[1]++;\n+      if (!M256.w[1]) {\n+\tM256.w[2]++;\n+\tif (!M256.w[2])\n+\t  M256.w[3]++;\n+      }\n+    }\n+\n+    if (!CS.w[0])\n+      CS.w[1]--;\n+    CS.w[0]--;\n+\n     if (M256.w[3] > C256.w[3]\n \t|| (M256.w[3] == C256.w[3]\n \t    && (M256.w[2] > C256.w[2]\n \t\t|| (M256.w[2] == C256.w[2]\n \t\t    && (M256.w[1] > C256.w[1]\n \t\t\t|| (M256.w[1] == C256.w[1]\n \t\t\t    && M256.w[0] > C256.w[0])))))) {\n-      __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n-      __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n-      __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n-      M256.w[3] = M256.w[3] - Carry;\n-      M256.w[0]++;\n-      if (!M256.w[0]) {\n-\tM256.w[1]++;\n-\tif (!M256.w[1]) {\n-\t  M256.w[2]++;\n-\t  if (!M256.w[2])\n-\t    M256.w[3]++;\n-\t}\n-      }\n \n       if (!CS.w[0])\n \tCS.w[1]--;\n       CS.w[0]--;\n+    }\n+  }\n \n-      if (M256.w[3] > C256.w[3]\n-\t  || (M256.w[3] == C256.w[3]\n-\t      && (M256.w[2] > C256.w[2]\n-\t\t  || (M256.w[2] == C256.w[2]\n-\t\t      && (M256.w[1] > C256.w[1]\n-\t\t\t  || (M256.w[1] == C256.w[1]\n-\t\t\t      && M256.w[0] > C256.w[0])))))) {\n-\n-\tif (!CS.w[0])\n-\t  CS.w[1]--;\n-\tCS.w[0]--;\n+  else {\n+    __add_carry_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __add_carry_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __add_carry_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] + Carry;\n+    M256.w[0]++;\n+    if (!M256.w[0]) {\n+      M256.w[1]++;\n+      if (!M256.w[1]) {\n+\tM256.w[2]++;\n+\tif (!M256.w[2])\n+\t  M256.w[3]++;\n       }\n     }\n+    if (M256.w[3] < C256.w[3]\n+\t|| (M256.w[3] == C256.w[3]\n+\t    && (M256.w[2] < C256.w[2]\n+\t\t|| (M256.w[2] == C256.w[2]\n+\t\t    && (M256.w[1] < C256.w[1]\n+\t\t\t|| (M256.w[1] == C256.w[1]\n+\t\t\t    && M256.w[0] <= C256.w[0])))))) {\n \n-    else {\n-      __add_carry_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n-      __add_carry_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n-      __add_carry_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n-      M256.w[3] = M256.w[3] + Carry;\n-      M256.w[0]++;\n-      if (!M256.w[0]) {\n-\tM256.w[1]++;\n-\tif (!M256.w[1]) {\n-\t  M256.w[2]++;\n-\t  if (!M256.w[2])\n-\t    M256.w[3]++;\n-\t}\n+      CS.w[0]++;\n+      if (!CS.w[0])\n+\tCS.w[1]++;\n+    }\n+  }\n+  // RU?\n+  if ((rnd_mode) == ROUNDING_UP) {\n+    CS.w[0]++;\n+    if (!CS.w[0])\n+      CS.w[1]++;\n+  }\n+\n+}\n+#endif\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+__set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+#endif\n+get_BID128_fast (&res, 0,\n+\t\t (exponent_q + DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n+}\n+\n+\n+\n+BID128_FUNCTION_ARGTYPE1 (bid128d_sqrt, UINT64, x)\n+\n+     UINT256 M256, C256, C4, C8;\n+     UINT128 CX, CX1, CX2, A10, S2, T128, TP128, CS, CSM, res;\n+     UINT64 sign_x, Carry;\n+     SINT64 D;\n+     int_float fx, f64;\n+     int exponent_x, bin_expon_cx;\n+     int digits, scale, exponent_q;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+     fexcept_t binaryflags = 0;\n+#endif\n+\n+\t// unpack arguments, check for NaN or Infinity\n+   // unpack arguments, check for NaN or Infinity\n+CX.w[1] = 0;\n+if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], x)) {\n+res.w[1] = CX.w[0];\n+res.w[0] = 0;\n+\t   // NaN ?\n+if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+  if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);\n+  __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);\n+  res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);\n+  BID_RETURN (res);\n+}\n+\t   // x is Infinity?\n+if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+  if (sign_x) {\n+    // -Inf, return NaN\n+    res.w[1] = 0x7c00000000000000ull;\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  }\n+  BID_RETURN (res);\n+}\n+\t   // x is 0 otherwise\n+\n+exponent_x =\n+  exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_128;\n+res.w[1] =\n+  sign_x | ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1)\n+\t    << 49);\n+res.w[0] = 0;\n+BID_RETURN (res);\n+}\n+if (sign_x) {\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+exponent_x =\n+  exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_128;\n+\n+\t   // 2^64\n+f64.i = 0x5f800000;\n+\n+\t   // fx ~ CX\n+fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+digits = estimate_decimal_digits[bin_expon_cx];\n+\n+A10 = CX;\n+if (exponent_x & 1) {\n+  A10.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n+  A10.w[0] = CX.w[0] << 3;\n+  CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+  CX2.w[0] = CX.w[0] << 1;\n+  __add_128_128 (A10, A10, CX2);\n+}\n+\n+CS.w[0] = short_sqrt128 (A10);\n+CS.w[1] = 0;\n+\t   // check for exact result\n+if (CS.w[0] * CS.w[0] == A10.w[0]) {\n+  __mul_64x64_to_128_fast (S2, CS.w[0], CS.w[0]);\n+  if (S2.w[1] == A10.w[1]) {\n+    get_BID128_very_fast (&res, 0,\n+\t\t\t  (exponent_x + DECIMAL_EXPONENT_BIAS_128) >> 1,\n+\t\t\t  CS);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  }\n+}\n+\t   // get number of digits in CX\n+D = CX.w[1] - power10_index_binexp_128[bin_expon_cx].w[1];\n+if (D > 0\n+    || (!D && CX.w[0] >= power10_index_binexp_128[bin_expon_cx].w[0]))\n+  digits++;\n+\n+\t\t// if exponent is odd, scale coefficient by 10\n+scale = 67 - digits;\n+exponent_q = exponent_x - scale;\n+scale += (exponent_q & 1);\t// exp. bias is even\n+\n+if (scale > 38) {\n+  T128 = power10_table_128[scale - 37];\n+  __mul_128x128_low (CX1, CX, T128);\n+\n+  TP128 = power10_table_128[37];\n+  __mul_128x128_to_256 (C256, CX1, TP128);\n+} else {\n+  T128 = power10_table_128[scale];\n+  __mul_128x128_to_256 (C256, CX, T128);\n+}\n+\n+\n+\t   // 4*C256\n+C4.w[3] = (C256.w[3] << 2) | (C256.w[2] >> 62);\n+C4.w[2] = (C256.w[2] << 2) | (C256.w[1] >> 62);\n+C4.w[1] = (C256.w[1] << 2) | (C256.w[0] >> 62);\n+C4.w[0] = C256.w[0] << 2;\n+\n+long_sqrt128 (&CS, C256);\n+\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+if (!((rnd_mode) & 3)) {\n+#endif\n+#endif\n+  // compare to midpoints\n+  CSM.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+  CSM.w[0] = (CS.w[0] + CS.w[0]) | 1;\n+  // CSM^2\n+  //__mul_128x128_to_256(M256, CSM, CSM);\n+  __sqr128_to_256 (M256, CSM);\n+\n+  if (C4.w[3] > M256.w[3]\n+      || (C4.w[3] == M256.w[3]\n+\t  && (C4.w[2] > M256.w[2]\n+\t      || (C4.w[2] == M256.w[2]\n+\t\t  && (C4.w[1] > M256.w[1]\n+\t\t      || (C4.w[1] == M256.w[1]\n+\t\t\t  && C4.w[0] > M256.w[0])))))) {\n+    // round up\n+    CS.w[0]++;\n+    if (!CS.w[0])\n+      CS.w[1]++;\n+  } else {\n+    C8.w[1] = (CS.w[1] << 3) | (CS.w[0] >> 61);\n+    C8.w[0] = CS.w[0] << 3;\n+    // M256 - 8*CSM\n+    __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] - Carry;\n+\n+    // if CSM' > C256, round up\n+    if (M256.w[3] > C4.w[3]\n+\t|| (M256.w[3] == C4.w[3]\n+\t    && (M256.w[2] > C4.w[2]\n+\t\t|| (M256.w[2] == C4.w[2]\n+\t\t    && (M256.w[1] > C4.w[1]\n+\t\t\t|| (M256.w[1] == C4.w[1]\n+\t\t\t    && M256.w[0] > C4.w[0])))))) {\n+      // round down\n+      if (!CS.w[0])\n+\tCS.w[1]--;\n+      CS.w[0]--;\n+    }\n+  }\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+} else {\n+  __sqr128_to_256 (M256, CS);\n+  C8.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+  C8.w[0] = CS.w[0] << 1;\n+  if (M256.w[3] > C256.w[3]\n+      || (M256.w[3] == C256.w[3]\n+\t  && (M256.w[2] > C256.w[2]\n+\t      || (M256.w[2] == C256.w[2]\n+\t\t  && (M256.w[1] > C256.w[1]\n+\t\t      || (M256.w[1] == C256.w[1]\n+\t\t\t  && M256.w[0] > C256.w[0])))))) {\n+    __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] - Carry;\n+    M256.w[0]++;\n+    if (!M256.w[0]) {\n+      M256.w[1]++;\n+      if (!M256.w[1]) {\n+\tM256.w[2]++;\n+\tif (!M256.w[2])\n+\t  M256.w[3]++;\n       }\n-      if (M256.w[3] < C256.w[3]\n-\t  || (M256.w[3] == C256.w[3]\n-\t      && (M256.w[2] < C256.w[2]\n-\t\t  || (M256.w[2] == C256.w[2]\n-\t\t      && (M256.w[1] < C256.w[1]\n-\t\t\t  || (M256.w[1] == C256.w[1]\n-\t\t\t      && M256.w[0] <= C256.w[0])))))) {\n-\n-\tCS.w[0]++;\n-\tif (!CS.w[0])\n-\t  CS.w[1]++;\n+    }\n+\n+    if (!CS.w[0])\n+      CS.w[1]--;\n+    CS.w[0]--;\n+\n+    if (M256.w[3] > C256.w[3]\n+\t|| (M256.w[3] == C256.w[3]\n+\t    && (M256.w[2] > C256.w[2]\n+\t\t|| (M256.w[2] == C256.w[2]\n+\t\t    && (M256.w[1] > C256.w[1]\n+\t\t\t|| (M256.w[1] == C256.w[1]\n+\t\t\t    && M256.w[0] > C256.w[0])))))) {\n+\n+      if (!CS.w[0])\n+\tCS.w[1]--;\n+      CS.w[0]--;\n+    }\n+  }\n+\n+  else {\n+    __add_carry_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+    __add_carry_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+    __add_carry_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+    M256.w[3] = M256.w[3] + Carry;\n+    M256.w[0]++;\n+    if (!M256.w[0]) {\n+      M256.w[1]++;\n+      if (!M256.w[1]) {\n+\tM256.w[2]++;\n+\tif (!M256.w[2])\n+\t  M256.w[3]++;\n       }\n     }\n-    // RU?\n-    if ((rnd_mode) == ROUNDING_UP) {\n+    if (M256.w[3] < C256.w[3]\n+\t|| (M256.w[3] == C256.w[3]\n+\t    && (M256.w[2] < C256.w[2]\n+\t\t|| (M256.w[2] == C256.w[2]\n+\t\t    && (M256.w[1] < C256.w[1]\n+\t\t\t|| (M256.w[1] == C256.w[1]\n+\t\t\t    && M256.w[0] <= C256.w[0])))))) {\n+\n       CS.w[0]++;\n       if (!CS.w[0])\n \tCS.w[1]++;\n     }\n-\n   }\n+  // RU?\n+  if ((rnd_mode) == ROUNDING_UP) {\n+    CS.w[0]++;\n+    if (!CS.w[0])\n+      CS.w[1]++;\n+  }\n+\n+}\n #endif\n #endif\n \n #ifdef SET_STATUS_FLAGS\n-  __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+__set_status_flags (pfpsf, INEXACT_EXCEPTION);\n #endif\n-  get_BID128_fast (&res, 0,\n-\t\t   (exponent_q + DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n-  BID_RETURN (res);\n+get_BID128_fast (&res, 0, (exponent_q + DECIMAL_EXPONENT_BIAS_128) >> 1,\n+\t\t CS);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+BID_RETURN (res);\n+\n+\n }"}, {"sha": "313d1bd57c5d744a7060d4fbe0b581164247a616", "filename": "libgcc/config/libbid/bid128_string.c", "status": "renamed", "additions": 286, "deletions": 6, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_string.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -26,8 +26,243 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+/*****************************************************************************\n+ *    BID128_to_string\n+ ****************************************************************************/\n+\n #define BID_128RES\n+#include <stdio.h>\n #include \"bid_internal.h\"\n+#include \"bid128_2_str.h\"\n+#include \"bid128_2_str_macros.h\"\n+\n+extern int bid128_coeff_2_string (UINT64 X_hi, UINT64 X_lo,\n+\t\t\t\t  char *char_ptr);\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+bid128_to_string (char *str,\n+\t\t  UINT128 *\n+\t\t  px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t  _EXC_INFO_PARAM) {\n+  UINT128 x;\n+#else\n+\n+void\n+bid128_to_string (char *str, UINT128 x \n+    _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  int ind;\n+  UINT128 C1;\n+  unsigned int k = 0; // pointer in the string\n+  unsigned int d0, d123;\n+  UINT64 HI_18Dig, LO_18Dig, Tmp;\n+  UINT32 MiDi[12], *ptr;\n+  char *c_ptr_start, *c_ptr;\n+  int midi_ind, k_lcv, len;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+  x = *px;\n+#endif\n+\n+  BID_SWAP128(x);\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+\t// set invalid flag\n+    str[0] = ((SINT64)x.w[1]<0)? '-':'+'; \n+\tstr[1] = 'S';\n+\tstr[2] = 'N';\n+\tstr[3] = 'a';\n+\tstr[4] = 'N';\n+\tstr[5] = '\\0';\n+      } else { // x is QNaN\n+    str[0] = ((SINT64)x.w[1]<0)? '-':'+'; \n+\tstr[1] = 'Q';\n+\tstr[2] = 'N';\n+\tstr[3] = 'a';\n+\tstr[4] = 'N';\n+\tstr[5] = '\\0';\n+      }\n+    } else { // x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) { // x is +inf\n+\tstr[0] = '+';\n+\tstr[1] = 'I';\n+\tstr[2] = 'n';\n+\tstr[3] = 'f';\n+\tstr[4] = '\\0';\n+      } else { // x is -inf \n+\tstr[0] = '-';\n+\tstr[1] = 'I';\n+\tstr[2] = 'n';\n+\tstr[3] = 'f';\n+\tstr[4] = '\\0';\n+      }\n+    }\n+    return;\n+  } else if (((x.w[1] & MASK_COEFF) == 0x0ull) && (x.w[0] == 0x0ull)) {\n+    // x is 0\n+    len = 0;\n+\n+    //determine if +/-\n+    if (x.w[1] & MASK_SIGN)\n+      str[len++] = '-';\n+    else\n+      str[len++] = '+';\n+    str[len++] = '0';\n+    str[len++] = 'E';\n+\n+    // extract the exponent and print\n+    exp = (int) (((x.w[1] & MASK_EXP) >> 49) - 6176);\n+\tif(exp > (((0x5ffe)>>1) - (6176))) {\n+\t\texp = (int) ((((x.w[1]<<2) & MASK_EXP) >> 49) - 6176);\n+\t}\n+    if (exp >= 0) {\n+      str[len++] = '+';\n+      len += sprintf (str + len, \"%u\", exp);// should not use sprintf (should \n+      // use sophisticated algorithm, since we know range of exp is limited)\n+      str[len++] = '\\0';\n+    } else {\n+      len += sprintf (str + len, \"%d\", exp);// should not use sprintf (should \n+      // use sophisticated algorithm, since we know range of exp is limited)\n+      str[len++] = '\\0';\n+    }\n+    return;\n+  } else { // x is not special and is not zero\n+    // unpack x\n+    x_sign = x.w[1] & MASK_SIGN;// 0 for positive, MASK_SIGN for negative\n+    x_exp = x.w[1] & MASK_EXP;// biased and shifted left 49 bit positions\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)\n+       x_exp = (x.w[1]<<2) & MASK_EXP;// biased and shifted left 49 bit positions\n+    C1.w[1] = x.w[1] & MASK_COEFF;\n+    C1.w[0] = x.w[0];\n+    exp = (x_exp >> 49) - 6176;\n+\n+    // determine sign's representation as a char\n+    if (x_sign)\n+      str[k++] = '-';// negative number\n+    else\n+      str[k++] = '+';// positive number\n+\n+    // determine coefficient's representation as a decimal string\n+\n+    // if zero or non-canonical, set coefficient to '0'\n+    if ((C1.w[1] > 0x0001ed09bead87c0ull) || \n+        (C1.w[1] == 0x0001ed09bead87c0ull && \n+        (C1.w[0] > 0x378d8e63ffffffffull)) || \n+        ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+        ((C1.w[1] == 0) && (C1.w[0] == 0))) {\n+      str[k++] = '0';\n+    } else {\n+      /* ****************************************************\n+         This takes a bid coefficient in C1.w[1],C1.w[0] \n+         and put the converted character sequence at location \n+         starting at &(str[k]). The function returns the number\n+         of MiDi returned. Note that the character sequence \n+         does not have leading zeros EXCEPT when the input is of\n+         zero value. It will then output 1 character '0'\n+         The algorithm essentailly tries first to get a sequence of\n+         Millenial Digits \"MiDi\" and then uses table lookup to get the\n+         character strings of these MiDis.\n+         **************************************************** */\n+      /* Algorithm first decompose possibly 34 digits in hi and lo\n+         18 digits. (The high can have at most 16 digits). It then\n+         uses macro that handle 18 digit portions.\n+         The first step is to get hi and lo such that\n+         2^(64) C1.w[1] + C1.w[0] = hi * 10^18  + lo,   0 <= lo < 10^18.\n+         We use a table lookup method to obtain the hi and lo 18 digits.\n+         [C1.w[1],C1.w[0]] = c_8 2^(107) + c_7 2^(101) + ... + c_0 2^(59) + d\n+         where 0 <= d < 2^59 and each c_j has 6 bits. Because d fits in\n+         18 digits,  we set hi = 0, and lo = d to begin with.\n+         We then retrieve from a table, for j = 0, 1, ..., 8\n+         that gives us A and B where c_j 2^(59+6j) = A * 10^18 + B.\n+         hi += A ; lo += B; After each accumulation into lo, we normalize \n+         immediately. So at the end, we have the decomposition as we need. */\n+\n+      Tmp = C1.w[0] >> 59;\n+      LO_18Dig = (C1.w[0] << 5) >> 5;\n+      Tmp += (C1.w[1] << 5);\n+      HI_18Dig = 0;\n+      k_lcv = 0;\n+      // Tmp = {C1.w[1]{49:0}, C1.w[0]{63:59}}\n+      // Lo_18Dig = {C1.w[0]{58:0}}\n+\n+      while (Tmp) {\n+\tmidi_ind = (int) (Tmp & 0x000000000000003FLL);\n+\tmidi_ind <<= 1;\n+\tTmp >>= 6;\n+\tHI_18Dig += mod10_18_tbl[k_lcv][midi_ind++];\n+\tLO_18Dig += mod10_18_tbl[k_lcv++][midi_ind];\n+\t__L0_Normalize_10to18 (HI_18Dig, LO_18Dig);\n+      }\n+      ptr = MiDi;\n+      if (HI_18Dig == 0LL) {\n+\t__L1_Split_MiDi_6_Lead (LO_18Dig, ptr);\n+      } else {\n+\t__L1_Split_MiDi_6_Lead (HI_18Dig, ptr);\n+\t__L1_Split_MiDi_6 (LO_18Dig, ptr);\n+      }\n+      len = ptr - MiDi;\n+      c_ptr_start = &(str[k]);\n+      c_ptr = c_ptr_start;\n+\n+      /* now convert the MiDi into character strings */\n+      __L0_MiDi2Str_Lead (MiDi[0], c_ptr);\n+      for (k_lcv = 1; k_lcv < len; k_lcv++) {\n+\t__L0_MiDi2Str (MiDi[k_lcv], c_ptr);\n+      }\n+      k = k + (c_ptr - c_ptr_start);\n+    }\n+\n+    // print E and sign of exponent\n+    str[k++] = 'E';\n+    if (exp < 0) {\n+      exp = -exp;\n+      str[k++] = '-';\n+    } else {\n+      str[k++] = '+';\n+    }\n+\n+    // determine exponent's representation as a decimal string\n+    // d0 = exp / 1000;\n+    // Use Property 1\n+    d0 = (exp * 0x418a) >> 24;// 0x418a * 2^-24 = (10^(-3))RP,15\n+    d123 = exp - 1000 * d0;\n+\n+    if (d0) { // 1000 <= exp <= 6144 => 4 digits to return\n+      str[k++] = d0 + 0x30;// ASCII for decimal digit d0\n+      ind = 3 * d123;\n+      str[k++] = char_table3[ind];\n+      str[k++] = char_table3[ind + 1];\n+      str[k++] = char_table3[ind + 2];\n+    } else { // 0 <= exp <= 999 => d0 = 0\n+      if (d123 < 10) { // 0 <= exp <= 9 => 1 digit to return\n+\tstr[k++] = d123 + 0x30;// ASCII\n+      } else if (d123 < 100) { // 10 <= exp <= 99 => 2 digits to return\n+\tind = 2 * (d123 - 10);\n+\tstr[k++] = char_table2[ind];\n+\tstr[k++] = char_table2[ind + 1];\n+      } else { // 100 <= exp <= 999 => 3 digits to return\n+\tind = 3 * d123;\n+\tstr[k++] = char_table3[ind];\n+\tstr[k++] = char_table3[ind + 1];\n+\tstr[k++] = char_table3[ind + 2];\n+      }\n+    }\n+    str[k] = '\\0';\n+\n+  }\n+  return;\n+\n+}\n+\n \n #define MAX_FORMAT_DIGITS_128   34\n #define MAX_STRING_DIGITS_128   100\n@@ -37,28 +272,33 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid128_from_string (UINT128 * pres,\n+bid128_from_string (UINT128 * pres,\n                     char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n                     _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #else\n \n UINT128\n-__bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n                     _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 CX, res;\n-  UINT64 sign_x, coeff_high, coeff_low, coeff2, coeff_l2, carry,\n+  UINT64 sign_x, coeff_high, coeff_low, coeff2, coeff_l2, carry = 0x0ull,\n     scale_high, right_radix_leading_zeros;\n   int ndigits_before, ndigits_after, ndigits_total, dec_expon, sgn_exp,\n     i, d2, rdx_pt_enc;\n   char c, buffer[MAX_STRING_DIGITS_128];\n+  int save_rnd_mode;\n+  int save_fpsf;\n \n #if DECIMAL_CALL_BY_REFERENCE\n #if !DECIMAL_GLOBAL_ROUNDING\n   _IDEC_round rnd_mode = *prnd_mode;\n #endif\n #endif\n \n+  save_rnd_mode = rnd_mode; // dummy\n+  save_fpsf = *pfpsf; // dummy\n+\n   right_radix_leading_zeros = rdx_pt_enc = 0;\n \n   // if null string, return NaN\n@@ -333,7 +573,7 @@ __bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n       if (CX.w[0] < coeff_low)\n         CX.w[1]++;\n     }\n-    get_BID128_string (&res, sign_x, dec_expon, CX);\n+    get_BID128 (&res, sign_x, dec_expon, CX,&rnd_mode,pfpsf);\n     BID_RETURN (res);\n   } else {\n     // simply round using the digits that were read\n@@ -358,6 +598,8 @@ __bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n       coeff_l2 = coeff_low + coeff_low;\n       coeff_low = (coeff_l2 << 2) + coeff_l2 + buffer[i] - '0';\n     }\n+\tswitch(rnd_mode) {\n+\tcase ROUNDING_TO_NEAREST:\n     carry = ((unsigned) ('4' - buffer[i])) >> 31;\n     if ((buffer[i] == '5' && !(coeff_low & 1)) || dec_expon < 0) {\n       if (dec_expon >= 0) {\n@@ -371,6 +613,43 @@ __bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n         }\n       }\n     }\n+\tbreak;\n+\n+\tcase ROUNDING_DOWN:\n+\t\tif(sign_x) \n+      for (; i < ndigits_total; i++) {\n+        if (buffer[i] > '0') {\n+          carry = 1;\n+          break;\n+        }\n+      }\n+\t\tbreak;\n+\tcase ROUNDING_UP:\n+\t\tif(!sign_x) \n+      for (; i < ndigits_total; i++) {\n+        if (buffer[i] > '0') {\n+          carry = 1;\n+          break;\n+        }\n+      }\n+\t\tbreak;\n+\tcase ROUNDING_TO_ZERO:\n+\t\tcarry=0;\n+\t\tbreak;\n+\tcase ROUNDING_TIES_AWAY:\n+    carry = ((unsigned) ('4' - buffer[i])) >> 31;\n+    if (dec_expon < 0) {\n+      for (; i < ndigits_total; i++) {\n+        if (buffer[i] > '0') {\n+          carry = 1;\n+          break;\n+        }\n+      }\n+    }\n+\t\tbreak;\n+\n+\n+\t}\n     // now form the coefficient as coeff_high*10^17+coeff_low+carry\n     scale_high = 100000000000000000ull;\n     if (dec_expon < 0) {\n@@ -381,7 +660,7 @@ __bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n       }\n       if (dec_expon == -MAX_FORMAT_DIGITS_128\n           && coeff_high > 50000000000000000ull)\n-        carry = 0;\n+        carry = 0; \n     }\n \n     __mul_64x64_to_128_fast (CX, coeff_high, scale_high);\n@@ -391,7 +670,8 @@ __bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n     if (CX.w[0] < coeff_low)\n       CX.w[1]++;\n \n-    get_BID128_string (&res, sign_x, dec_expon, CX);\n+\n+    get_BID128(&res, sign_x, dec_expon, CX, &rnd_mode, pfpsf);\n     BID_RETURN (res);\n   }\n }", "previous_filename": "libgcc/config/libbid/bid128_fromstring.c"}, {"sha": "aa4636ff537b7ee574b7629c630a70d8a66cb2bd", "filename": "libgcc/config/libbid/bid128_to_int16.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int16.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define SIZE_MASK      0xffff8000\n+#define INVALID_RESULT 0x8000\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_rnint, UINT128, x,\n+\t\t\t       bid128_to_int32_rnint, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_xrnint, UINT128,\n+\t\t\t       x, bid128_to_int32_xrnint, int,\n+\t\t\t       SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_rninta, UINT128,\n+\t\t\t       x, bid128_to_int32_rninta, int,\n+\t\t\t       SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_xrninta, UINT128,\n+\t\t\t       x, bid128_to_int32_xrninta, int,\n+\t\t\t       SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_int, UINT128, x,\n+\t\t\t       bid128_to_int32_int, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_xint, UINT128, x,\n+\t\t\t       bid128_to_int32_xint, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_floor, UINT128, x,\n+\t\t\t       bid128_to_int32_floor, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_ceil, UINT128, x,\n+\t\t\t       bid128_to_int32_ceil, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_xfloor, UINT128,\n+\t\t\t       x, bid128_to_int32_xfloor, int,\n+\t\t\t       SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (short, bid128_to_int16_xceil, UINT128, x,\n+\t\t\t       bid128_to_int32_xceil, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)"}, {"sha": "08b980b24e6059fbd09e7cb400592b1001391a75", "filename": "libgcc/config/libbid/bid128_to_int32.c", "status": "modified", "additions": 3341, "deletions": 3334, "changes": 6675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "4d09a0058a905c7b937a3b52bcc7531b730ac37f", "filename": "libgcc/config/libbid/bid128_to_int64.c", "status": "modified", "additions": 2643, "deletions": 2623, "changes": 5266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "ba90caab59aa58a08229421803d901aaa9842bf5", "filename": "libgcc/config/libbid/bid128_to_int8.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int8.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define SIZE_MASK      0xffffff80\n+#define INVALID_RESULT 0x80\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_rnint, UINT128, x,\n+\t\t\t       bid128_to_int32_rnint, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_xrnint, UINT128, x,\n+\t\t\t       bid128_to_int32_xrnint, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_rninta, UINT128, x,\n+\t\t\t       bid128_to_int32_rninta, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_xrninta, UINT128, x,\n+\t\t\t       bid128_to_int32_xrninta, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_int, UINT128, x,\n+\t\t\t       bid128_to_int32_int, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_xint, UINT128, x,\n+\t\t\t       bid128_to_int32_xint, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_floor, UINT128, x,\n+\t\t\t       bid128_to_int32_floor, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_ceil, UINT128, x,\n+\t\t\t       bid128_to_int32_ceil, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_xfloor, UINT128, x,\n+\t\t\t       bid128_to_int32_xfloor, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)\n+\n+BID_TO_SMALL_INT_CVT_FUNCTION (char, bid128_to_int8_xceil, UINT128, x,\n+\t\t\t       bid128_to_int32_xceil, int, SIZE_MASK,\n+\t\t\t       INVALID_RESULT)"}, {"sha": "ea94979b90bdf729305cb621f10d037f895db31c", "filename": "libgcc/config/libbid/bid128_to_string.c", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c?ref=e233ac979c0f179f858f3c86281835a4c09cece2", "patch": "@@ -1,260 +0,0 @@\n-/* Copyright (C) 2007  Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301, USA.  */\n-\n-/*****************************************************************************\n- *    BID128_to_string\n- ****************************************************************************/\n-\n-#include <stdio.h>\n-#include \"bid_internal.h\"\n-#include \"bid128_2_str.h\"\n-#include \"bid128_2_str_macros.h\"\n-\n-extern int __bid128_coeff_2_string (UINT64 X_hi, UINT64 X_lo,\n-\t\t\t\t  char *char_ptr);\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-\n-void\n-__bid128_to_string (char *str,\n-\t\t  UINT128 *\n-\t\t  px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t  _EXC_INFO_PARAM) {\n-  UINT128 x;\n-#else\n-\n-void\n-__bid128_to_string (char *str,\n-\t\t  UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n-\t\t  _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n-#endif\n-  UINT64 x_sign;\n-  UINT64 x_exp;\n-  int exp; \t// unbiased exponent\n-  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n-  int ind;\n-  UINT128 C1;\n-  unsigned int k = 0; // pointer in the string\n-  unsigned int d0, d123;\n-  UINT64 HI_18Dig, LO_18Dig, Tmp;\n-  UINT32 MiDi[12], *ptr;\n-  char *c_ptr_start, *c_ptr;\n-  int midi_ind, k_lcv, len;\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-#if !DECIMAL_GLOBAL_ROUNDING\n-  _IDEC_round rnd_mode = *prnd_mode;\n-#endif\n-  x = *px;\n-#endif\n-\n-  // check for NaN or Infinity\n-  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n-    // x is special\n-    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n-\t// set invalid flag\n-\t*pfpsf |= INVALID_EXCEPTION;\n-\tstr[0] = 'S';\n-\tstr[1] = 'N';\n-\tstr[2] = 'a';\n-\tstr[3] = 'N';\n-\tstr[4] = '\\0';\n-      } else { // x is QNaN\n-\tstr[0] = 'Q';\n-\tstr[1] = 'N';\n-\tstr[2] = 'a';\n-\tstr[3] = 'N';\n-\tstr[4] = '\\0';\n-      }\n-    } else { // x is not a NaN, so it must be infinity\n-      if ((x.w[1] & MASK_SIGN) == 0x0ull) { // x is +inf\n-\tstr[0] = '+';\n-\tstr[1] = 'I';\n-\tstr[2] = 'n';\n-\tstr[3] = 'f';\n-\tstr[4] = '\\0';\n-      } else { // x is -inf \n-\tstr[0] = '-';\n-\tstr[1] = 'I';\n-\tstr[2] = 'n';\n-\tstr[3] = 'f';\n-\tstr[4] = '\\0';\n-      }\n-    }\n-    return;\n-  } else if (((x.w[1] & MASK_COEFF) == 0x0ull) && (x.w[0] == 0x0ull)) {\n-    // x is 0\n-    len = 0;\n-\n-    //determine if +/-\n-    if (x.w[1] & MASK_SIGN)\n-      str[len++] = '-';\n-    else\n-      str[len++] = '+';\n-    str[len++] = '0';\n-    str[len++] = 'E';\n-\n-    // extract the exponent and print\n-    exp = (int) (((x.w[1] & MASK_EXP) >> 49) - 6176);\n-    if (exp >= 0) {\n-      str[len++] = '+';\n-      len += sprintf (str + len, \"%u\", exp);// should not use sprintf (should \n-      // use sophisticated algorithm, since we know range of exp is limited)\n-      str[len++] = '\\0';\n-    } else {\n-      len += sprintf (str + len, \"%d\", exp);// should not use sprintf (should \n-      // use sophisticated algorithm, since we know range of exp is limited)\n-      str[len++] = '\\0';\n-    }\n-    return;\n-  } else { // x is not special and is not zero\n-    // unpack x\n-    x_sign = x.w[1] & MASK_SIGN;// 0 for positive, MASK_SIGN for negative\n-    x_exp = x.w[1] & MASK_EXP;// biased and shifted left 49 bit positions\n-    C1.w[1] = x.w[1] & MASK_COEFF;\n-    C1.w[0] = x.w[0];\n-    exp = (x_exp >> 49) - 6176;\n-\n-    // determine sign's representation as a char\n-    if (x_sign)\n-      str[k++] = '-';// negative number\n-    else\n-      str[k++] = '+';// positive number\n-\n-    // determine coefficient's representation as a decimal string\n-\n-    // if zero or non-canonical, set coefficient to '0'\n-    if ((C1.w[1] > 0x0001ed09bead87c0ull) || \n-        (C1.w[1] == 0x0001ed09bead87c0ull && \n-        (C1.w[0] > 0x378d8e63ffffffffull)) || \n-        ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n-        ((C1.w[1] == 0) && (C1.w[0] == 0))) {\n-      str[k++] = '0';\n-    } else {\n-      /* ****************************************************\n-         This takes a bid coefficient in C1.w[1],C1.w[0] \n-         and put the converted character sequence at location \n-         starting at &(str[k]). The function returns the number\n-         of MiDi returned. Note that the character sequence \n-         does not have leading zeros EXCEPT when the input is of\n-         zero value. It will then output 1 character '0'\n-         The algorithm essentailly tries first to get a sequence of\n-         Millenial Digits \"MiDi\" and then uses table lookup to get the\n-         character strings of these MiDis.\n-         **************************************************** */\n-      /* Algorithm first decompose possibly 34 digits in hi and lo\n-         18 digits. (The high can have at most 16 digits). It then\n-         uses macro that handle 18 digit portions.\n-         The first step is to get hi and lo such that\n-         2^(64) C1.w[1] + C1.w[0] = hi * 10^18  + lo,   0 <= lo < 10^18.\n-         We use a table lookup method to obtain the hi and lo 18 digits.\n-         [C1.w[1],C1.w[0]] = c_8 2^(107) + c_7 2^(101) + ... + c_0 2^(59) + d\n-         where 0 <= d < 2^59 and each c_j has 6 bits. Because d fits in\n-         18 digits,  we set hi = 0, and lo = d to begin with.\n-         We then retrieve from a table, for j = 0, 1, ..., 8\n-         that gives us A and B where c_j 2^(59+6j) = A * 10^18 + B.\n-         hi += A ; lo += B; After each accumulation into lo, we normalize \n-         immediately. So at the end, we have the decomposition as we need. */\n-\n-      Tmp = C1.w[0] >> 59;\n-      LO_18Dig = (C1.w[0] << 5) >> 5;\n-      Tmp += (C1.w[1] << 5);\n-      HI_18Dig = 0;\n-      k_lcv = 0;\n-      // Tmp = {C1.w[1]{49:0}, C1.w[0]{63:59}}\n-      // Lo_18Dig = {C1.w[0]{58:0}}\n-\n-      while (Tmp) {\n-\tmidi_ind = (int) (Tmp & 0x000000000000003FLL);\n-\tmidi_ind <<= 1;\n-\tTmp >>= 6;\n-\tHI_18Dig += __bid_mod10_18_tbl[k_lcv][midi_ind++];\n-\tLO_18Dig += __bid_mod10_18_tbl[k_lcv++][midi_ind];\n-\t__L0_Normalize_10to18 (HI_18Dig, LO_18Dig);\n-      }\n-      ptr = MiDi;\n-      if (HI_18Dig == 0LL) {\n-\t__L1_Split_MiDi_6_Lead (LO_18Dig, ptr);\n-      } else {\n-\t__L1_Split_MiDi_6_Lead (HI_18Dig, ptr);\n-\t__L1_Split_MiDi_6 (LO_18Dig, ptr);\n-      }\n-      len = ptr - MiDi;\n-      c_ptr_start = &(str[k]);\n-      c_ptr = c_ptr_start;\n-\n-      /* now convert the MiDi into character strings */\n-      __L0_MiDi2Str_Lead (MiDi[0], c_ptr);\n-      for (k_lcv = 1; k_lcv < len; k_lcv++) {\n-\t__L0_MiDi2Str (MiDi[k_lcv], c_ptr);\n-      }\n-      k = k + (c_ptr - c_ptr_start);\n-    }\n-\n-    // print E and sign of exponent\n-    str[k++] = 'E';\n-    if (exp < 0) {\n-      exp = -exp;\n-      str[k++] = '-';\n-    } else {\n-      str[k++] = '+';\n-    }\n-\n-    // determine exponent's representation as a decimal string\n-    // d0 = exp / 1000;\n-    // Use Property 1\n-    d0 = (exp * 0x418a) >> 24;// 0x418a * 2^-24 = (10^(-3))RP,15\n-    d123 = exp - 1000 * d0;\n-\n-    if (d0) { // 1000 <= exp <= 6144 => 4 digits to return\n-      str[k++] = d0 + 0x30;// ASCII for decimal digit d0\n-      ind = 3 * d123;\n-      str[k++] = __bid_char_table3[ind];\n-      str[k++] = __bid_char_table3[ind + 1];\n-      str[k++] = __bid_char_table3[ind + 2];\n-    } else { // 0 <= exp <= 999 => d0 = 0\n-      if (d123 < 10) { // 0 <= exp <= 9 => 1 digit to return\n-\tstr[k++] = d123 + 0x30;// ASCII\n-      } else if (d123 < 100) { // 10 <= exp <= 99 => 2 digits to return\n-\tind = 2 * (d123 - 10);\n-\tstr[k++] = __bid_char_table2[ind];\n-\tstr[k++] = __bid_char_table2[ind + 1];\n-      } else { // 100 <= exp <= 999 => 3 digits to return\n-\tind = 3 * d123;\n-\tstr[k++] = __bid_char_table3[ind];\n-\tstr[k++] = __bid_char_table3[ind + 1];\n-\tstr[k++] = __bid_char_table3[ind + 2];\n-      }\n-    }\n-    str[k] = '\\0';\n-\n-  }\n-  return;\n-\n-}"}, {"sha": "b23d0c7c867cb69ec8053afce3cc4b4213a76648", "filename": "libgcc/config/libbid/bid128_to_uint16.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint16.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -0,0 +1,73 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define SIZE_MASK      0xffff0000\n+#define INVALID_RESULT 0x8000\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_rnint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_rnint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_xrnint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xrnint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_rninta,\n+\t\t\t\tUINT128, x, bid128_to_uint32_rninta,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short,\n+\t\t\t\tbid128_to_uint16_xrninta, UINT128, x,\n+\t\t\t\tbid128_to_uint32_xrninta, unsigned int,\n+\t\t\t\tSIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_int,\n+\t\t\t\tUINT128, x, bid128_to_uint32_int,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_xint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_floor,\n+\t\t\t\tUINT128, x, bid128_to_uint32_floor,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_ceil,\n+\t\t\t\tUINT128, x, bid128_to_uint32_ceil,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_xfloor,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xfloor,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned short, bid128_to_uint16_xceil,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xceil,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)"}, {"sha": "cf51d67b091b987124f5b56db249d8221afc7a00", "filename": "libgcc/config/libbid/bid128_to_uint32.c", "status": "modified", "additions": 3199, "deletions": 3167, "changes": 6366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "d8ec7110079d7af36e98ba661806f469bebc6c11", "filename": "libgcc/config/libbid/bid128_to_uint64.c", "status": "modified", "additions": 2917, "deletions": 2893, "changes": 5810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "5ecf4206ee0a47c17f70c98700a707f9d68a8063", "filename": "libgcc/config/libbid/bid128_to_uint8.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint8.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define SIZE_MASK      0xffffff00\n+#define INVALID_RESULT 0x80\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_rnint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_rnint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_xrnint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xrnint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_rninta,\n+\t\t\t\tUINT128, x, bid128_to_uint32_rninta,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_xrninta,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xrninta,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_int,\n+\t\t\t\tUINT128, x, bid128_to_uint32_int,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_xint,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xint,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_floor,\n+\t\t\t\tUINT128, x, bid128_to_uint32_floor,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_ceil,\n+\t\t\t\tUINT128, x, bid128_to_uint32_ceil,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_xfloor,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xfloor,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)\n+\n+BID_TO_SMALL_UINT_CVT_FUNCTION (unsigned char, bid128_to_uint8_xceil,\n+\t\t\t\tUINT128, x, bid128_to_uint32_xceil,\n+\t\t\t\tunsigned int, SIZE_MASK, INVALID_RESULT)"}, {"sha": "ed8e7f9847c41152c9ff07987c1bd29333983b9d", "filename": "libgcc/config/libbid/bid32_to_bid128.c", "status": "modified", "additions": 102, "deletions": 60, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -29,31 +29,38 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define BID_128RES\n #include \"bid_internal.h\"\n \n-/*\n+/* \n  * Takes a BID32 as input and converts it to a BID128 and returns it.\n  */\n-TYPE0_FUNCTION_ARGTYPE1_NORND(UINT128, __bid32_to_bid128, UINT32, x)\n-\n-  UINT128 new_coeff, res;\n-  UINT32 sign_x;\n-  int exponent_x = 0;\n-  UINT32 coefficient_x = 0;\n-\n-  if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n-    if (((x) & 0x78000000) == 0x78000000) {\n-      res.w[0] = 0;\n-      res.w[1] = ((UINT64) (x)) << 32;\n-      BID_RETURN (res);\n-    }\n-  }\n+TYPE0_FUNCTION_ARGTYPE1_NORND (UINT128, bid32_to_bid128, UINT32, x)\n+\n+     UINT128 new_coeff, res;\n+     UINT32 sign_x;\n+     int exponent_x;\n+     UINT32 coefficient_x;\n+\n+if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+if (((x) & 0x78000000) == 0x78000000) {\n+#ifdef SET_STATUS_FLAGS\n+  if (((x) & 0x7e000000) == 0x7e000000)\t// sNaN\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[0] = (coefficient_x & 0x000fffff);\n+  __mul_64x128_low (res, res.w[0], power10_table_128[27]);\n+  res.w[1] |=\n+    ((((UINT64) coefficient_x) << 32) & 0xfc00000000000000ull);\n \n-  new_coeff.w[0] = coefficient_x;\n-  new_coeff.w[1] = 0;\n-  get_BID128_very_fast (&res, ((UINT64) sign_x) << 32,\n-\t\t\texponent_x + DECIMAL_EXPONENT_BIAS_128 -\n-\t\t\tDECIMAL_EXPONENT_BIAS_32, new_coeff);\n   BID_RETURN (res);\n-} // convert_bid32_to_bid128\n+}\n+}\n+\n+new_coeff.w[0] = coefficient_x;\n+new_coeff.w[1] = 0;\n+get_BID128_very_fast (&res, ((UINT64) sign_x) << 32,\n+\t\t      exponent_x + DECIMAL_EXPONENT_BIAS_128 -\n+\t\t      DECIMAL_EXPONENT_BIAS_32, new_coeff);\n+BID_RETURN (res);\n+}\t// convert_bid32_to_bid128\n \n \n /*\n@@ -62,23 +69,23 @@ TYPE0_FUNCTION_ARGTYPE1_NORND(UINT128, __bid32_to_bid128, UINT32, x)\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid128_to_bid32 (UINT32 * pres,\n+bid128_to_bid32 (UINT32 * pres,\n \t\t UINT128 *\n \t\t px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t _EXC_INFO_PARAM) {\n   UINT128 x = *px;\n #else\n \n UINT32\n-__bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t\t _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n-  UINT128 CX, T128, TP128, Qh, Ql, Qh1, Stemp, Tmp, Tmp1;\n+  UINT128 CX, T128, TP128, Qh, Ql, Qh1, Stemp, Tmp, Tmp1, CX1;\n   UINT64 sign_x, carry, cy;\n   SINT64 D;\n   UINT32 res;\n   int_float f64, fx;\n-  int exponent_x = 0, extra_digits, amount, bin_expon_cx;\n+  int exponent_x, extra_digits, amount, bin_expon_cx, uf_check = 0;\n   unsigned rmode, status;\n \n #if DECIMAL_CALL_BY_REFERENCE\n@@ -87,25 +94,32 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n #endif\n #endif\n \n-  BID_SWAP128(x);\n+  BID_SWAP128 (x);\n   // unpack arguments, check for NaN or Infinity or 0\n-  if (!unpack_BID128 (&sign_x, &exponent_x, &CX, &x)) {\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n     if (((x.w[1]) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      res = ((UINT32) (x.w[1] >> 32)) & 0xfc000000;\n+      Tmp.w[1] = (CX.w[1] & 0x00003fffffffffffull);\n+      Tmp.w[0] = CX.w[0];\n+      TP128 = reciprocals10_128[27];\n+      __mul_128x128_full (Qh, Ql, Tmp, TP128);\n+      amount = recip_scale[27] - 64;\n+      res = ((CX.w[1] >> 32) & 0xfc000000) | (Qh.w[1] >> amount);\n+#ifdef SET_STATUS_FLAGS\n+      if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n       BID_RETURN_VAL (res);\n     }\n     // x is 0\n-    amount =\n+    exponent_x =\n       exponent_x - DECIMAL_EXPONENT_BIAS_128 + DECIMAL_EXPONENT_BIAS_32;\n-    if (((unsigned) amount) > DECIMAL_MAX_EXPON_32) {\n-      sign_x >>= 32;\n-      if (amount < 0)\n-\tres = sign_x;\n-      res =\n-\tget_BID32 ((UINT32) (sign_x >> 32), DECIMAL_MAX_EXPON_32, 0,\n-\t\t   rnd_mode, pfpsf);\n-      BID_RETURN_VAL (res);\n-    }\n+    if (exponent_x < 0)\n+      exponent_x = 0;\n+    if (exponent_x > DECIMAL_MAX_EXPON_32)\n+      exponent_x = DECIMAL_MAX_EXPON_32;\n+    res = (sign_x >> 32) | (exponent_x << 23);\n+    BID_RETURN_VAL (res);\n+\n   }\n \n   if (CX.w[1] || (CX.w[0] >= 10000000)) {\n@@ -115,10 +129,12 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n     // fx ~ CX\n     fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n     bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n-    extra_digits = __bid_estimate_decimal_digits[bin_expon_cx] - 7;\n-    // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n-    D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n-    if (D > 0 || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+    extra_digits = estimate_decimal_digits[bin_expon_cx] - 7;\n+    // scale = 38-estimate_decimal_digits[bin_expon_cx];\n+    D = CX.w[1] - power10_index_binexp_128[bin_expon_cx].w[1];\n+    if (D > 0\n+\t|| (!D\n+\t    && CX.w[0] >= power10_index_binexp_128[bin_expon_cx].w[0]))\n       extra_digits++;\n \n     exponent_x += extra_digits;\n@@ -134,13 +150,36 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n #else\n     rmode = 0;\n #endif\n-    T128 = __bid_round_const_table_128[rmode][extra_digits];\n+    if (exponent_x <\n+\tDECIMAL_EXPONENT_BIAS_128 - DECIMAL_EXPONENT_BIAS_32) {\n+      uf_check = 1;\n+      if (-extra_digits + exponent_x - DECIMAL_EXPONENT_BIAS_128 +\n+\t  DECIMAL_EXPONENT_BIAS_32 + 35 >= 0) {\n+\tif (exponent_x ==\n+\t    DECIMAL_EXPONENT_BIAS_128 - DECIMAL_EXPONENT_BIAS_32 - 1) {\n+\t  T128 = round_const_table_128[rmode][extra_digits];\n+\t  __add_carry_out (CX1.w[0], carry, T128.w[0], CX.w[0]);\n+\t  CX1.w[1] = CX.w[1] + T128.w[1] + carry;\n+\t  if (__unsigned_compare_ge_128\n+\t      (CX1, power10_table_128[extra_digits + 7]))\n+\t    uf_check = 0;\n+\t}\n+\textra_digits =\n+\t  extra_digits + DECIMAL_EXPONENT_BIAS_128 -\n+\t  DECIMAL_EXPONENT_BIAS_32 - exponent_x;\n+\texponent_x =\n+\t  DECIMAL_EXPONENT_BIAS_128 - DECIMAL_EXPONENT_BIAS_32;\n+      } else\n+\trmode = ROUNDING_TO_ZERO;\n+    }\n+\n+    T128 = round_const_table_128[rmode][extra_digits];\n     __add_carry_out (CX.w[0], carry, T128.w[0], CX.w[0]);\n     CX.w[1] = CX.w[1] + T128.w[1] + carry;\n \n-    TP128 = __bid_reciprocals10_128[extra_digits];\n+    TP128 = reciprocals10_128[extra_digits];\n     __mul_128x128_full (Qh, Ql, CX, TP128);\n-    amount = __bid_recip_scale[extra_digits];\n+    amount = recip_scale[extra_digits];\n \n     if (amount >= 64) {\n       CX.w[0] = Qh.w[1] >> (amount - 64);\n@@ -160,15 +199,14 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t__shl_128_long (Qh1, Qh, (128 - amount));\n \n \tif (!Qh1.w[1] && !Qh1.w[0]\n-\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0]))) {\n+\t    && (Ql.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < reciprocals10_128[extra_digits].w[0]))) {\n \t  CX.w[0]--;\n \t}\n       }\n #endif\n \n-#ifdef SET_STATUS_FLAGS\n \n     {\n       status = INEXACT_EXCEPTION;\n@@ -180,25 +218,25 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n       case ROUNDING_TIES_AWAY:\n \t// test whether fractional part is 0\n \tif (Qh1.w[1] == 0x8000000000000000ull && (!Qh1.w[0])\n-\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+\t    && (Ql.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < reciprocals10_128[extra_digits].w[0])))\n \t  status = EXACT_STATUS;\n \tbreak;\n       case ROUNDING_DOWN:\n       case ROUNDING_TO_ZERO:\n \tif ((!Qh1.w[1]) && (!Qh1.w[0])\n-\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+\t    && (Ql.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < reciprocals10_128[extra_digits].w[0])))\n \t  status = EXACT_STATUS;\n \tbreak;\n       default:\n \t// round up\n \t__add_carry_out (Stemp.w[0], cy, Ql.w[0],\n-\t\t\t __bid_reciprocals10_128[extra_digits].w[0]);\n+\t\t\t reciprocals10_128[extra_digits].w[0]);\n \t__add_carry_in_out (Stemp.w[1], carry, Ql.w[1],\n-\t\t\t    __bid_reciprocals10_128[extra_digits].w[1], cy);\n+\t\t\t    reciprocals10_128[extra_digits].w[1], cy);\n \t__shr_128_long (Qh, Qh1, (128 - amount));\n \tTmp.w[0] = 1;\n \tTmp.w[1] = 0;\n@@ -210,11 +248,15 @@ __bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t  status = EXACT_STATUS;\n       }\n \n-      if (status != EXACT_STATUS)\n+      if (status != EXACT_STATUS) {\n+\tif (uf_check) {\n+\t  status |= UNDERFLOW_EXCEPTION;\n+\t}\n+#ifdef SET_STATUS_FLAGS\n \t__set_status_flags (pfpsf, status);\n-    }\n-\n #endif\n+      }\n+    }\n \n   }\n "}, {"sha": "cc4aa92d9514756b425a3bb2fe7ac981612303a0", "filename": "libgcc/config/libbid/bid32_to_bid64.c", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -31,29 +31,37 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /*\n  * Takes a BID32 as input and converts it to a BID64 and returns it.\n  */\n-TYPE0_FUNCTION_ARGTYPE1_NORND(UINT64, __bid32_to_bid64, UINT32, x)\n+TYPE0_FUNCTION_ARGTYPE1_NORND (UINT64, bid32_to_bid64, UINT32, x)\n \n-  UINT64 res;\n-  UINT32 sign_x;\n-  int exponent_x = 0;\n-  UINT32 coefficient_x = 0;\n+     UINT64 res;\n+     UINT32 sign_x;\n+     int exponent_x;\n+     UINT32 coefficient_x;\n \n-  if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n     // Inf, NaN, 0\n-    if (((x) & 0x78000000) == 0x78000000) {\n-      res = ((UINT64) (x)) << 32;\n-      BID_RETURN (res);\n-    }\n+if (((x) & 0x78000000) == 0x78000000) {\n+  if (((x) & 0x7e000000) == 0x7e000000) {\t// sNaN\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n   }\n+  res = (coefficient_x & 0x000fffff);\n+  res *= 1000000000;\n+  res |= ((((UINT64) coefficient_x) << 32) & 0xfc00000000000000ull);\n \n-  res =\n-    very_fast_get_BID64_small_mantissa (((UINT64) sign_x) << 32,\n-\t\t\t\t\texponent_x +\n-\t\t\t\t\tDECIMAL_EXPONENT_BIAS -\n-\t\t\t\t\tDECIMAL_EXPONENT_BIAS_32,\n-\t\t\t\t\t(UINT64) coefficient_x);\n   BID_RETURN (res);\n-} // convert_bid32_to_bid64\n+}\n+}\n+\n+res =\n+very_fast_get_BID64_small_mantissa (((UINT64) sign_x) << 32,\n+\t\t\t\t    exponent_x +\n+\t\t\t\t    DECIMAL_EXPONENT_BIAS -\n+\t\t\t\t    DECIMAL_EXPONENT_BIAS_32,\n+\t\t\t\t    (UINT64) coefficient_x);\n+BID_RETURN (res);\n+}\t// convert_bid32_to_bid64\n \n \n /*\n@@ -62,23 +70,23 @@ TYPE0_FUNCTION_ARGTYPE1_NORND(UINT64, __bid32_to_bid64, UINT32, x)\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_to_bid32 (UINT32 * pres,\n+bid64_to_bid32 (UINT32 * pres,\n \t\tUINT64 *\n \t\tpx _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t_EXC_INFO_PARAM) {\n   UINT64 x;\n #else\n \n UINT32\n-__bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t\t_EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 Q;\n   UINT64 sign_x, coefficient_x, remainder_h, carry, Stemp;\n   UINT32 res;\n   int_float tempx;\n-  int exponent_x, bin_expon_cx, extra_digits, rmode, amount;\n-  unsigned status=0;\n+  int exponent_x, bin_expon_cx, extra_digits, rmode = 0, amount;\n+  unsigned status = 0;\n \n #if DECIMAL_CALL_BY_REFERENCE\n #if !DECIMAL_GLOBAL_ROUNDING\n@@ -90,7 +98,13 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n   // unpack arguments, check for NaN or Infinity, 0\n   if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n     if (((x) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      res = ((UINT32) ((x) >> 32)) & 0xfc000000;\n+      res = (coefficient_x & 0x0003ffffffffffffull);\n+      res /= 1000000000ull;\n+      res |= ((coefficient_x >> 32) & 0xfc000000);\n+#ifdef SET_STATUS_FLAGS\n+      if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n       BID_RETURN (res);\n     }\n     exponent_x =\n@@ -103,15 +117,16 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n     BID_RETURN (res);\n   }\n \n-\texponent_x = exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_32;\n+  exponent_x =\n+    exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_32;\n \n   // check number of digits\n   if (coefficient_x >= 10000000) {\n     tempx.d = (float) coefficient_x;\n     bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n-    extra_digits = __bid_estimate_decimal_digits[bin_expon_cx] - 7;\n+    extra_digits = estimate_decimal_digits[bin_expon_cx] - 7;\n     // add test for range\n-    if (coefficient_x >= __bid_power10_index_binexp[bin_expon_cx])\n+    if (coefficient_x >= power10_index_binexp[bin_expon_cx])\n       extra_digits++;\n \n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n@@ -126,18 +141,22 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n     rmode = 0;\n #endif\n \n-    coefficient_x += __bid_round_const_table[rmode][extra_digits];\n     exponent_x += extra_digits;\n-\tif((exponent_x<0) && (exponent_x + MAX_FORMAT_DIGITS_32 >= 0)) {\n-\t\textra_digits -= exponent_x;\n-\t\texponent_x = 0;\n-\t\tstatus = UNDERFLOW_EXCEPTION;\n-\t}\n+    if ((exponent_x < 0) && (exponent_x + MAX_FORMAT_DIGITS_32 >= 0)) {\n+      status = UNDERFLOW_EXCEPTION;\n+      if (exponent_x == -1)\n+\tif (coefficient_x + round_const_table[rmode][extra_digits] >=\n+\t    power10_table_128[extra_digits + 7].w[0])\n+\t  status = 0;\n+      extra_digits -= exponent_x;\n+      exponent_x = 0;\n+    }\n+    coefficient_x += round_const_table[rmode][extra_digits];\n     __mul_64x64_to_128 (Q, coefficient_x,\n-\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\t\t\treciprocals10_64[extra_digits]);\n \n     // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n-    amount = __bid_short_recip_scale[extra_digits];\n+    amount = short_recip_scale[extra_digits];\n \n     coefficient_x = Q.w[1] >> amount;\n \n@@ -147,12 +166,12 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n #endif\n       if (coefficient_x & 1) {\n \t// check whether fractional part of initial_P/10^extra_digits \n-        // is exactly .5\n+\t// is exactly .5\n \n \t// get remainder\n \tremainder_h = Q.w[1] << (64 - amount);\n \n-\tif (!remainder_h && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\tif (!remainder_h && (Q.w[0] < reciprocals10_64[extra_digits]))\n \t  coefficient_x--;\n       }\n #endif\n@@ -169,18 +188,18 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n       case ROUNDING_TIES_AWAY:\n \t// test whether fractional part is 0\n \tif (remainder_h == 0x8000000000000000ull\n-\t    && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t    && (Q.w[0] < reciprocals10_64[extra_digits]))\n \t  status = EXACT_STATUS;\n \tbreak;\n       case ROUNDING_DOWN:\n       case ROUNDING_TO_ZERO:\n-\tif (!remainder_h && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\tif (!remainder_h && (Q.w[0] < reciprocals10_64[extra_digits]))\n \t  status = EXACT_STATUS;\n \tbreak;\n       default:\n \t// round up\n \t__add_carry_out (Stemp, carry, Q.w[0],\n-\t\t\t __bid_reciprocals10_64[extra_digits]);\n+\t\t\t reciprocals10_64[extra_digits]);\n \tif ((remainder_h >> (64 - amount)) + carry >=\n \t    (((UINT64) 1) << amount))\n \t  status = EXACT_STATUS;\n@@ -196,9 +215,7 @@ __bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \n   res =\n     get_BID32 ((UINT32) (sign_x >> 32),\n-\t       exponent_x,\n-\t       coefficient_x, rnd_mode,\n-\t       pfpsf);\n+\t       exponent_x, coefficient_x, rnd_mode, pfpsf);\n   BID_RETURN (res);\n \n }"}, {"sha": "617a947e059dff67febe32e724342cef829ed59e", "filename": "libgcc/config/libbid/bid64_add.c", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -62,20 +62,20 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"bid_internal.h\"\n \n #if DECIMAL_CALL_BY_REFERENCE\n-void __bid64_add (UINT64 * pres, UINT64 * px,\n+void bid64_add (UINT64 * pres, UINT64 * px,\n \t\tUINT64 *\n \t\tpy _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t_EXC_INFO_PARAM);\n #else\n-UINT64 __bid64_add (UINT64 x,\n-\t\t      UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n-\t\t      _EXC_MASKS_PARAM _EXC_INFO_PARAM);\n+UINT64 bid64_add (UINT64 x,\n+\t\t  UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t  _EXC_MASKS_PARAM _EXC_INFO_PARAM);\n #endif\n \n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_sub (UINT64 * pres, UINT64 * px,\n+bid64_sub (UINT64 * pres, UINT64 * px,\n \t   UINT64 *\n \t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t   _EXC_INFO_PARAM) {\n@@ -86,21 +86,21 @@ __bid64_sub (UINT64 * pres, UINT64 * px,\n   // check if y is not NaN\n   if (((y & NAN_MASK64) != NAN_MASK64))\n     y ^= 0x8000000000000000ull;\n-  __bid64_add (pres, px,\n+  bid64_add (pres, px,\n \t     &y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t     _EXC_INFO_ARG);\n }\n #else\n \n UINT64\n-__bid64_sub (UINT64 x,\n+bid64_sub (UINT64 x,\n \t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   // check if y is not NaN\n   if (((y & NAN_MASK64) != NAN_MASK64))\n     y ^= 0x8000000000000000ull;\n \n-  return __bid64_add (x,\n+  return bid64_add (x,\n \t\t    y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t    _EXC_INFO_ARG);\n }\n@@ -111,15 +111,15 @@ __bid64_sub (UINT64 x,\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_add (UINT64 * pres, UINT64 * px,\n+bid64_add (UINT64 * pres, UINT64 * px,\n \t   UINT64 *\n \t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t   _EXC_INFO_PARAM) {\n   UINT64 x, y;\n #else\n \n UINT64\n-__bid64_add (UINT64 x,\n+bid64_add (UINT64 x,\n \t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -132,7 +132,7 @@ __bid64_add (UINT64 x,\n     rem_a;\n   UINT64 saved_ca, saved_cb, C0_64, C64, remainder_h, T1, carry, tmp;\n   int_double tempx;\n-  int exponent_x = 0, exponent_y = 0, exponent_a, exponent_b, diff_dec_expon;\n+  int exponent_x, exponent_y, exponent_a, exponent_b, diff_dec_expon;\n   int bin_expon_ca, extra_digits, amount, scale_k, scale_ca;\n   unsigned rmode, status;\n \n@@ -158,15 +158,15 @@ __bid64_add (UINT64 x,\n \t  || ((y & SNAN_MASK64) == SNAN_MASK64))\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = x & QUIET_MASK64;\n+      res = coefficient_x & QUIET_MASK64;\n       BID_RETURN (res);\n     }\n     // x is Infinity?\n     if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n       // check if y is Inf\n       if (((y & NAN_MASK64) == INFINITY_MASK64)) {\n \tif (sign_x == (y & 0x8000000000000000ull)) {\n-\t  res = x;\n+\t  res = coefficient_x;\n \t  BID_RETURN (res);\n \t}\n \t// return NaN\n@@ -180,7 +180,7 @@ __bid64_add (UINT64 x,\n       }\n       // check if y is NaN\n       if (((y & NAN_MASK64) == NAN_MASK64)) {\n-\tres = y & QUIET_MASK64;\n+\tres = coefficient_y & QUIET_MASK64;\n #ifdef SET_STATUS_FLAGS\n \tif (((y & SNAN_MASK64) == SNAN_MASK64))\n \t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n@@ -189,20 +189,13 @@ __bid64_add (UINT64 x,\n       }\n       // otherwise return +/-Inf\n       {\n-\tres = x;\n+\tres = coefficient_x;\n \tBID_RETURN (res);\n       }\n     }\n     // x is 0\n     {\n-      if ((y & SPECIAL_ENCODING_MASK64) == SPECIAL_ENCODING_MASK64) {\n-\texponent_y = ((UINT32) (y >> 51)) & 0x3ff;\n-\tif (exponent_y <= exponent_x) {\n-\t  res = y;\n-\t  BID_RETURN (res);\n-\t}\n-      } else if (y & 0x001fffffffffffffull) {\n-\texponent_y = ((UINT32) (y >> 53)) & 0x3ff;\n+      if (((y & INFINITY_MASK64) != INFINITY_MASK64) && coefficient_y) {\n \tif (exponent_y <= exponent_x) {\n \t  res = y;\n \t  BID_RETURN (res);\n@@ -218,15 +211,15 @@ __bid64_add (UINT64 x,\n       if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = y & QUIET_MASK64;\n+      res = coefficient_y & QUIET_MASK64;\n       BID_RETURN (res);\n     }\n     // y is 0\n-    if (!coefficient_x) { // x==0\n+    if (!coefficient_x) {\t// x==0\n       if (exponent_x <= exponent_y)\n-\tres = ((x << 1) >> 1);\n+\tres = ((UINT64) exponent_x) << 53;\n       else\n-\tres = ((y << 1) >> 1);\n+\tres = ((UINT64) exponent_y) << 53;\n       if (sign_x == sign_y)\n \tres |= sign_x;\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n@@ -272,13 +265,13 @@ __bid64_add (UINT64 x,\n   if (diff_dec_expon > MAX_FORMAT_DIGITS) {\n     // normalize a to a 16-digit coefficient\n \n-    scale_ca = __bid_estimate_decimal_digits[bin_expon_ca];\n-    if (coefficient_a >= __bid_power10_table_128[scale_ca].w[0])\n+    scale_ca = estimate_decimal_digits[bin_expon_ca];\n+    if (coefficient_a >= power10_table_128[scale_ca].w[0])\n       scale_ca++;\n \n     scale_k = 16 - scale_ca;\n \n-    coefficient_a *= __bid_power10_table_128[scale_k].w[0];\n+    coefficient_a *= power10_table_128[scale_k].w[0];\n \n     diff_dec_expon -= scale_k;\n     exponent_a -= scale_k;\n@@ -341,7 +334,8 @@ __bid64_add (UINT64 x,\n \t// check special case here\n \tif ((coefficient_a == 1000000000000000ull)\n \t    && (diff_dec_expon == MAX_FORMAT_DIGITS + 1)\n-\t    && (sign_a ^ sign_b) && (coefficient_b > 5000000000000000ull)) {\n+\t    && (sign_a ^ sign_b)\n+\t    && (coefficient_b > 5000000000000000ull)) {\n \tcoefficient_a = 9999999999999999ull;\n \texponent_a--;\n       }\n@@ -353,11 +347,11 @@ __bid64_add (UINT64 x,\n     }\n   }\n   // test whether coefficient_a*10^(exponent_a-exponent_b)  may exceed 2^62\n-  if (bin_expon_ca + __bid_estimate_bin_expon[diff_dec_expon] < 60) {\n+  if (bin_expon_ca + estimate_bin_expon[diff_dec_expon] < 60) {\n     // coefficient_a*10^(exponent_a-exponent_b)<2^63\n \n     // multiply by 10^(exponent_a-exponent_b)\n-    coefficient_a *= __bid_power10_table_128[diff_dec_expon].w[0];\n+    coefficient_a *= power10_table_128[diff_dec_expon].w[0];\n \n     // sign mask\n     sign_b = ((SINT64) sign_b) >> 63;\n@@ -375,7 +369,7 @@ __bid64_add (UINT64 x,\n     sign_s &= 0x8000000000000000ull;\n \n     // coefficient_a < 10^16 ?\n-    if (coefficient_a < __bid_power10_table_128[MAX_FORMAT_DIGITS].w[0]) {\n+    if (coefficient_a < power10_table_128[MAX_FORMAT_DIGITS].w[0]) {\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n       if (rnd_mode == ROUNDING_DOWN && (!coefficient_a)\n@@ -390,9 +384,9 @@ __bid64_add (UINT64 x,\n \n     // already know coefficient_a<10^19\n     // coefficient_a < 10^17 ?\n-    if (coefficient_a < __bid_power10_table_128[17].w[0])\n+    if (coefficient_a < power10_table_128[17].w[0])\n       extra_digits = 1;\n-    else if (coefficient_a < __bid_power10_table_128[18].w[0])\n+    else if (coefficient_a < power10_table_128[18].w[0])\n       extra_digits = 2;\n     else\n       extra_digits = 3;\n@@ -408,14 +402,14 @@ __bid64_add (UINT64 x,\n #else\n     rmode = 0;\n #endif\n-    coefficient_a += __bid_round_const_table[rmode][extra_digits];\n+    coefficient_a += round_const_table[rmode][extra_digits];\n \n     // get P*(2^M[extra_digits])/10^extra_digits\n     __mul_64x64_to_128 (CT, coefficient_a,\n-\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\t\t\treciprocals10_64[extra_digits]);\n \n     // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-    amount = __bid_short_recip_scale[extra_digits];\n+    amount = short_recip_scale[extra_digits];\n     C64 = CT.w[1] >> amount;\n \n   } else {\n@@ -435,16 +429,16 @@ __bid64_add (UINT64 x,\n #endif\n \n     // check whether we can take faster path\n-    scale_ca = __bid_estimate_decimal_digits[bin_expon_ca];\n+    scale_ca = estimate_decimal_digits[bin_expon_ca];\n \n     sign_ab = sign_a ^ sign_b;\n     sign_ab = ((SINT64) sign_ab) >> 63;\n \n     // T1 = 10^(16-diff_dec_expon)\n-    T1 = __bid_power10_table_128[16 - diff_dec_expon].w[0];\n+    T1 = power10_table_128[16 - diff_dec_expon].w[0];\n \n     // get number of digits in coefficient_a\n-    if (coefficient_a >= __bid_power10_table_128[scale_ca].w[0]) {\n+    if (coefficient_a >= power10_table_128[scale_ca].w[0]) {\n       scale_ca++;\n     }\n \n@@ -453,81 +447,82 @@ __bid64_add (UINT64 x,\n     // addition\n     saved_ca = coefficient_a - T1;\n     coefficient_a =\n-      (SINT64) saved_ca *(SINT64) __bid_power10_table_128[scale_k].w[0];\n+      (SINT64) saved_ca *(SINT64) power10_table_128[scale_k].w[0];\n     extra_digits = diff_dec_expon - scale_k;\n \n     // apply sign\n     saved_cb = (coefficient_b + sign_ab) ^ sign_ab;\n     // add 10^16 and rounding constant\n     coefficient_b =\n       saved_cb + 10000000000000000ull +\n-      __bid_round_const_table[rmode][extra_digits];\n+      round_const_table[rmode][extra_digits];\n \n     // get P*(2^M[extra_digits])/10^extra_digits\n     __mul_64x64_to_128 (CT, coefficient_b,\n-\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\t\t\treciprocals10_64[extra_digits]);\n \n     // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-    amount = __bid_short_recip_scale[extra_digits];\n+    amount = short_recip_scale[extra_digits];\n     C0_64 = CT.w[1] >> amount;\n \n     // result coefficient \n     C64 = C0_64 + coefficient_a;\n     // filter out difficult (corner) cases\n     // this test ensures the number of digits in coefficient_a does not change \n     // after adding (the appropriately scaled and rounded) coefficient_b\n-    if ((UINT64) (C64 - 1000000000000000ull - 1) > 9000000000000000ull - 2) {\n+    if ((UINT64) (C64 - 1000000000000000ull - 1) >\n+\t9000000000000000ull - 2) {\n       if (C64 >= 10000000000000000ull) {\n \t// result has more than 16 digits\n \tif (!scale_k) {\n \t  // must divide coeff_a by 10\n \t  saved_ca = saved_ca + T1;\n-\t  __mul_64x64_to_128 (CA, saved_ca, 0x3333333333333334ull); \n-              //__bid_reciprocals10_64[1]);\n+\t  __mul_64x64_to_128 (CA, saved_ca, 0x3333333333333334ull);\n+\t  //reciprocals10_64[1]);\n \t  coefficient_a = CA.w[1] >> 1;\n \t  rem_a =\n \t    saved_ca - (coefficient_a << 3) - (coefficient_a << 1);\n \t  coefficient_a = coefficient_a - T1;\n \n-\t  saved_cb += rem_a * __bid_power10_table_128[diff_dec_expon].w[0];\n+\t  saved_cb += rem_a * power10_table_128[diff_dec_expon].w[0];\n \t} else\n \t  coefficient_a =\n \t    (SINT64) (saved_ca - T1 -\n-\t\t      (T1 << 3)) * (SINT64) __bid_power10_table_128[scale_k -\n+\t\t      (T1 << 3)) * (SINT64) power10_table_128[scale_k -\n \t\t\t\t\t\t\t      1].w[0];\n \n \textra_digits++;\n \tcoefficient_b =\n \t  saved_cb + 100000000000000000ull +\n-\t  __bid_round_const_table[rmode][extra_digits];\n+\t  round_const_table[rmode][extra_digits];\n \n \t// get P*(2^M[extra_digits])/10^extra_digits\n \t__mul_64x64_to_128 (CT, coefficient_b,\n-\t\t\t    __bid_reciprocals10_64[extra_digits]);\n+\t\t\t    reciprocals10_64[extra_digits]);\n \n \t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-\tamount = __bid_short_recip_scale[extra_digits];\n+\tamount = short_recip_scale[extra_digits];\n \tC0_64 = CT.w[1] >> amount;\n \n \t// result coefficient \n \tC64 = C0_64 + coefficient_a;\n       } else if (C64 <= 1000000000000000ull) {\n \t// less than 16 digits in result\n \tcoefficient_a =\n-\t  (SINT64) saved_ca *(SINT64) __bid_power10_table_128[scale_k +\n+\t  (SINT64) saved_ca *(SINT64) power10_table_128[scale_k +\n \t\t\t\t\t\t\t1].w[0];\n \t//extra_digits --;\n \texponent_b--;\n \tcoefficient_b =\n \t  (saved_cb << 3) + (saved_cb << 1) + 100000000000000000ull +\n-\t  __bid_round_const_table[rmode][extra_digits];\n+\t  round_const_table[rmode][extra_digits];\n \n \t// get P*(2^M[extra_digits])/10^extra_digits\n \t__mul_64x64_to_128 (CT_new, coefficient_b,\n-\t\t\t    __bid_reciprocals10_64[extra_digits]);\n+\t\t\t    reciprocals10_64[extra_digits]);\n \n \t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-\tamount = __bid_short_recip_scale[extra_digits];\n+\tamount = short_recip_scale[extra_digits];\n \tC0_64 = CT_new.w[1] >> amount;\n \n \t// result coefficient \n@@ -559,7 +554,7 @@ __bid64_add (UINT64 x,\n       remainder_h = CT.w[1] << (64 - amount);\n \n       // test whether fractional part is 0\n-      if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits])) {\n+      if (!remainder_h && (CT.w[0] < reciprocals10_64[extra_digits])) {\n \tC64--;\n       }\n     }\n@@ -576,19 +571,19 @@ __bid64_add (UINT64 x,\n   case ROUNDING_TIES_AWAY:\n     // test whether fractional part is 0\n     if ((remainder_h == 0x8000000000000000ull)\n-\t&& (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t&& (CT.w[0] < reciprocals10_64[extra_digits]))\n       status = EXACT_STATUS;\n     break;\n   case ROUNDING_DOWN:\n   case ROUNDING_TO_ZERO:\n-    if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+    if (!remainder_h && (CT.w[0] < reciprocals10_64[extra_digits]))\n       status = EXACT_STATUS;\n     //if(!C64 && rmode==ROUNDING_DOWN) sign_s=sign_y;\n     break;\n   default:\n     // round up\n     __add_carry_out (tmp, carry, CT.w[0],\n-\t\t     __bid_reciprocals10_64[extra_digits]);\n+\t\t     reciprocals10_64[extra_digits]);\n     if ((remainder_h >> (64 - amount)) + carry >=\n \t(((UINT64) 1) << amount))\n       status = EXACT_STATUS;"}, {"sha": "de22d59fd65489ae52cb2e2ad6827008ce16fff1", "filename": "libgcc/config/libbid/bid64_compare.c", "status": "modified", "additions": 95, "deletions": 389, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -38,15 +38,15 @@ static const UINT64 mult_factor[16] = {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_equal (int *pres, UINT64 * px,\n+bid64_quiet_equal (int *pres, UINT64 * px,\n \t\t   UINT64 *\n \t\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t   _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_equal (UINT64 x,\n+bid64_quiet_equal (UINT64 x,\n \t\t   UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t   _EXC_INFO_PARAM) {\n #endif\n@@ -60,7 +60,7 @@ __bid64_quiet_equal (UINT64 x,\n   // rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -76,6 +76,11 @@ __bid64_quiet_equal (UINT64 x,\n     res = (((x ^ y) & MASK_SIGN) != MASK_SIGN);\n     BID_RETURN (res);\n   }\n+  // ONE INFINITY (CASE3')\n+  if (((x & MASK_INF) == MASK_INF) || ((y & MASK_INF) == MASK_INF)) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n@@ -130,12 +135,12 @@ __bid64_quiet_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n-  if (exp_x > exp_y) { // to simplify the loop below,\n-    SWAP (exp_x, exp_y, exp_t); // put the larger exp in y,\n-    SWAP (sig_x, sig_y, sig_t); // and the smaller exp in x\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n+    SWAP (exp_x, exp_y, exp_t);\t// put the larger exp in y,\n+    SWAP (sig_x, sig_y, sig_t);\t// and the smaller exp in x\n   }\n   if (exp_y - exp_x > 15) {\n-    res = 0; // difference cannot be greater than 10^15\n+    res = 0;\t// difference cannot be greater than 10^15\n     BID_RETURN (res);\n   }\n   for (lcv = 0; lcv < (exp_y - exp_x); lcv++) {\n@@ -152,15 +157,15 @@ __bid64_quiet_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_greater (int *pres, UINT64 * px,\n+bid64_quiet_greater (int *pres, UINT64 * px,\n \t\t     UINT64 *\n \t\t     py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t     _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_greater (UINT64 x,\n+bid64_quiet_greater (UINT64 x,\n \t\t     UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t     _EXC_INFO_PARAM) {\n #endif\n@@ -175,7 +180,7 @@ __bid64_quiet_greater (UINT64 x,\n   // return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -276,7 +281,7 @@ __bid64_quiet_greater (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 greater than exp_y, no need for compensation\n-  if (exp_x - exp_y > 15) { // difference cannot be greater than 10^15\n+  if (exp_x - exp_y > 15) {\t// difference cannot be greater than 10^15\n     if (x & MASK_SIGN)\t// if both are negative\n       res = 0;\n     else\t// if both are positive\n@@ -292,7 +297,7 @@ __bid64_quiet_greater (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -323,15 +328,15 @@ __bid64_quiet_greater (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_greater_equal (int *pres, UINT64 * px,\n+bid64_quiet_greater_equal (int *pres, UINT64 * px,\n \t\t\t   UINT64 *\n \t\t\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t   _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_greater_equal (UINT64 x,\n+bid64_quiet_greater_equal (UINT64 x,\n \t\t\t   UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t   _EXC_INFO_PARAM) {\n #endif\n@@ -345,7 +350,7 @@ __bid64_quiet_greater_equal (UINT64 x,\n   // if either number is NAN, the comparison is unordered : return 1\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -364,7 +369,7 @@ __bid64_quiet_greater_equal (UINT64 x,\n       res = (((y & MASK_INF) == MASK_INF)\n \t     && (y & MASK_SIGN) == MASK_SIGN);\n       BID_RETURN (res);\n-    } else { // x is pos_inf, no way for it to be less than y\n+    } else {\t// x is pos_inf, no way for it to be less than y\n       res = 1;\n       BID_RETURN (res);\n     }\n@@ -456,7 +461,7 @@ __bid64_quiet_greater_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -490,15 +495,15 @@ __bid64_quiet_greater_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_greater_unordered (int *pres, UINT64 * px,\n+bid64_quiet_greater_unordered (int *pres, UINT64 * px,\n \t\t\t       UINT64 *\n \t\t\t       py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t       _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_greater_unordered (UINT64 x,\n+bid64_quiet_greater_unordered (UINT64 x,\n \t\t\t       UINT64 y _EXC_FLAGS_PARAM\n \t\t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -513,7 +518,7 @@ __bid64_quiet_greater_unordered (UINT64 x,\n   // return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -624,7 +629,7 @@ __bid64_quiet_greater_unordered (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -655,15 +660,15 @@ __bid64_quiet_greater_unordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_less (int *pres, UINT64 * px,\n+bid64_quiet_less (int *pres, UINT64 * px,\n \t\t  UINT64 *\n \t\t  py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) \n {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_less (UINT64 x,\n+bid64_quiet_less (UINT64 x,\n \t\t  UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t  _EXC_INFO_PARAM) {\n #endif\n@@ -677,7 +682,7 @@ __bid64_quiet_less (UINT64 x,\n   // if either number is NAN, the comparison is unordered : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -790,7 +795,7 @@ __bid64_quiet_less (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -824,15 +829,15 @@ __bid64_quiet_less (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_less_equal (int *pres, UINT64 * px,\n+bid64_quiet_less_equal (int *pres, UINT64 * px,\n \t\t\tUINT64 *\n \t\t\tpy _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t_EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_less_equal (UINT64 x,\n+bid64_quiet_less_equal (UINT64 x,\n \t\t\tUINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t_EXC_INFO_PARAM) {\n #endif\n@@ -847,7 +852,7 @@ __bid64_quiet_less_equal (UINT64 x,\n   //     return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -958,7 +963,7 @@ __bid64_quiet_less_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -992,15 +997,15 @@ __bid64_quiet_less_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_less_unordered (int *pres, UINT64 * px,\n+bid64_quiet_less_unordered (int *pres, UINT64 * px,\n \t\t\t    UINT64 *\n \t\t\t    py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t    _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_less_unordered (UINT64 x,\n+bid64_quiet_less_unordered (UINT64 x,\n \t\t\t    UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t    _EXC_INFO_PARAM) {\n #endif\n@@ -1014,7 +1019,7 @@ __bid64_quiet_less_unordered (UINT64 x,\n   // if either number is NAN, the comparison is unordered : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -1126,7 +1131,7 @@ __bid64_quiet_less_unordered (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -1160,15 +1165,15 @@ __bid64_quiet_less_unordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_not_equal (int *pres, UINT64 * px,\n+bid64_quiet_not_equal (int *pres, UINT64 * px,\n \t\t       UINT64 *\n \t\t       py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t       _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_not_equal (UINT64 x,\n+bid64_quiet_not_equal (UINT64 x,\n \t\t       UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t       _EXC_INFO_PARAM) {\n #endif\n@@ -1182,7 +1187,7 @@ __bid64_quiet_not_equal (UINT64 x,\n   // rather than equal : return 1\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -1198,6 +1203,11 @@ __bid64_quiet_not_equal (UINT64 x,\n     res = (((x ^ y) & MASK_SIGN) == MASK_SIGN);\n     BID_RETURN (res);\n   }\n+  // ONE INFINITY (CASE3')\n+  if (((x & MASK_INF) == MASK_INF) || ((y & MASK_INF) == MASK_INF)) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n@@ -1255,9 +1265,9 @@ __bid64_quiet_not_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n-  if (exp_x > exp_y) { // to simplify the loop below,\n-    SWAP (exp_x, exp_y, exp_t); // put the larger exp in y,\n-    SWAP (sig_x, sig_y, sig_t); // and the smaller exp in x\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n+    SWAP (exp_x, exp_y, exp_t);\t// put the larger exp in y,\n+    SWAP (sig_x, sig_y, sig_t);\t// and the smaller exp in x\n   }\n \n   if (exp_y - exp_x > 15) {\n@@ -1285,15 +1295,15 @@ __bid64_quiet_not_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_not_greater (int *pres, UINT64 * px,\n+bid64_quiet_not_greater (int *pres, UINT64 * px,\n \t\t\t UINT64 *\n \t\t\t py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_not_greater (UINT64 x,\n+bid64_quiet_not_greater (UINT64 x,\n \t\t\t UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t _EXC_INFO_PARAM) {\n #endif\n@@ -1308,7 +1318,7 @@ __bid64_quiet_not_greater (UINT64 x,\n   //   rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -1428,7 +1438,7 @@ __bid64_quiet_not_greater (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -1469,15 +1479,15 @@ __bid64_quiet_not_greater (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_not_less (int *pres, UINT64 * px,\n+bid64_quiet_not_less (int *pres, UINT64 * px,\n \t\t      UINT64 *\n \t\t      py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t      _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_not_less (UINT64 x,\n+bid64_quiet_not_less (UINT64 x,\n \t\t      UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t      _EXC_INFO_PARAM) {\n #endif\n@@ -1491,7 +1501,7 @@ __bid64_quiet_not_less (UINT64 x,\n   // if either number is NAN, the comparison is unordered : return 1\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -1613,7 +1623,7 @@ __bid64_quiet_not_less (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -1654,15 +1664,15 @@ __bid64_quiet_not_less (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_ordered (int *pres, UINT64 * px,\n+bid64_quiet_ordered (int *pres, UINT64 * px,\n \t\t     UINT64 *\n \t\t     py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t     _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_ordered (UINT64 x,\n+bid64_quiet_ordered (UINT64 x,\n \t\t     UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t     _EXC_INFO_PARAM) {\n #endif\n@@ -1672,7 +1682,7 @@ __bid64_quiet_ordered (UINT64 x,\n   // if either number is NAN, the comparison is ordered, rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 0;\n     BID_RETURN (res);\n@@ -1684,15 +1694,15 @@ __bid64_quiet_ordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_quiet_unordered (int *pres, UINT64 * px,\n+bid64_quiet_unordered (int *pres, UINT64 * px,\n \t\t       UINT64 *\n \t\t       py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t       _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_quiet_unordered (UINT64 x,\n+bid64_quiet_unordered (UINT64 x,\n \t\t       UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t       _EXC_INFO_PARAM) {\n #endif\n@@ -1703,7 +1713,7 @@ __bid64_quiet_unordered (UINT64 x,\n   //     rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n     if ((x & MASK_SNAN) == MASK_SNAN || (y & MASK_SNAN) == MASK_SNAN) {\n-      *pfpsf |= INVALID_EXCEPTION; // set exception if sNaN\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if sNaN\n     }\n     res = 1;\n     BID_RETURN (res);\n@@ -1715,138 +1725,15 @@ __bid64_quiet_unordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_equal (int *pres, UINT64 * px,\n-\t\t       UINT64 *\n-\t\t       py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t       _EXC_INFO_PARAM) {\n-  UINT64 x = *px;\n-  UINT64 y = *py;\n-#else\n-int\n-__bid64_signaling_equal (UINT64 x,\n-\t\t       UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t       _EXC_INFO_PARAM) {\n-#endif\n-  int res;\n-  int exp_x, exp_y, exp_t;\n-  UINT64 sig_x, sig_y, sig_t;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y, lcv;\n-\n-  // NaN (CASE1)\n-  // if either number is NAN, the comparison is unordered, \n-  //     rather than equal : return 0\n-  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-  // SIMPLE (CASE2)\n-  // if all the bits are the same, these numbers are equivalent.\n-  if (x == y) {\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-  // INFINITY (CASE3)\n-  if (((x & MASK_INF) == MASK_INF) && ((y & MASK_INF) == MASK_INF)) {\n-    res = (((x ^ y) & MASK_SIGN) != MASK_SIGN);\n-    BID_RETURN (res);\n-  }\n-  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n-  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n-    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n-  } else {\n-    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n-    sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n-  }\n-\n-  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n-  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n-    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n-  } else {\n-    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n-    sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n-  }\n-\n-  // ZERO (CASE4)\n-  // some properties:\n-  // (+ZERO==-ZERO) => therefore ignore the sign\n-  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n-  //     therefore ignore the exponent field\n-  //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n-    x_is_zero = 1;\n-  }\n-  if (non_canon_y || sig_y == 0) {\n-    y_is_zero = 1;\n-  }\n-\n-  if (x_is_zero && y_is_zero) {\n-    res = 1;\n-    BID_RETURN (res);\n-  } else if ((x_is_zero && !y_is_zero) || (!x_is_zero && y_is_zero)) {\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-  // OPPOSITE SIGN (CASE5)\n-  // now, if the sign bits differ => not equal : return 0\n-  if ((x ^ y) & MASK_SIGN) {\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-  // REDUNDANT REPRESENTATIONS (CASE6)\n-  if (exp_x > exp_y) { // to simplify the loop below,\n-    SWAP (exp_x, exp_y, exp_t); // put the larger exp in y,\n-    SWAP (sig_x, sig_y, sig_t); // and the smaller exp in x\n-  }\n-\n-  if (exp_y - exp_x > 15) {\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-  // difference cannot be greater than 10^15\n-\n-  for (lcv = 0; lcv < (exp_y - exp_x); lcv++) {\n-\n-    // recalculate y's significand upwards\n-    sig_y = sig_y * 10;\n-    if (sig_y > 9999999999999999ull) {\n-      res = 0;\n-      BID_RETURN (res);\n-    }\n-  }\n-\n-  {\n-    res = sig_y == sig_x;\n-    BID_RETURN (res);\n-  }\n-\n-}\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-void\n-__bid64_signaling_greater (int *pres, UINT64 * px,\n+bid64_signaling_greater (int *pres, UINT64 * px,\n \t\t\t UINT64 *\n \t\t\t py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_greater (UINT64 x,\n+bid64_signaling_greater (UINT64 x,\n \t\t\t UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t _EXC_INFO_PARAM) {\n #endif\n@@ -1860,7 +1747,7 @@ __bid64_signaling_greater (UINT64 x,\n   // if either number is NAN, the comparison is unordered, \n   //     rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 0;\n     BID_RETURN (res);\n   }\n@@ -1979,7 +1866,7 @@ __bid64_signaling_greater (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2020,15 +1907,15 @@ __bid64_signaling_greater (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_greater_equal (int *pres, UINT64 * px,\n+bid64_signaling_greater_equal (int *pres, UINT64 * px,\n \t\t\t       UINT64 *\n \t\t\t       py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t       _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_greater_equal (UINT64 x,\n+bid64_signaling_greater_equal (UINT64 x,\n \t\t\t       UINT64 y _EXC_FLAGS_PARAM\n \t\t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -2041,7 +1928,7 @@ __bid64_signaling_greater_equal (UINT64 x,\n   // NaN (CASE1)\n   // if either number is NAN, the comparison is unordered : return 1\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 0;\n     BID_RETURN (res);\n   }\n@@ -2161,7 +2048,7 @@ __bid64_signaling_greater_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2202,15 +2089,15 @@ __bid64_signaling_greater_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_greater_unordered (int *pres, UINT64 * px,\n+bid64_signaling_greater_unordered (int *pres, UINT64 * px,\n \t\t\t\t   UINT64 *\n \t\t\t\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t\t   _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_greater_unordered (UINT64 x,\n+bid64_signaling_greater_unordered (UINT64 x,\n \t\t\t\t   UINT64 y _EXC_FLAGS_PARAM\n \t\t\t\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -2224,7 +2111,7 @@ __bid64_signaling_greater_unordered (UINT64 x,\n   // if either number is NAN, the comparison is unordered, \n   // rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 1;\n     BID_RETURN (res);\n   }\n@@ -2343,7 +2230,7 @@ __bid64_signaling_greater_unordered (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2383,15 +2270,15 @@ __bid64_signaling_greater_unordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_less (int *pres, UINT64 * px,\n+bid64_signaling_less (int *pres, UINT64 * px,\n \t\t      UINT64 *\n \t\t      py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t      _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_less (UINT64 x,\n+bid64_signaling_less (UINT64 x,\n \t\t      UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t      _EXC_INFO_PARAM) {\n #endif\n@@ -2404,7 +2291,7 @@ __bid64_signaling_less (UINT64 x,\n   // NaN (CASE1)\n   // if either number is NAN, the comparison is unordered : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 0;\n     BID_RETURN (res);\n   }\n@@ -2524,7 +2411,7 @@ __bid64_signaling_less (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2565,15 +2452,15 @@ __bid64_signaling_less (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_less_equal (int *pres, UINT64 * px,\n+bid64_signaling_less_equal (int *pres, UINT64 * px,\n \t\t\t    UINT64 *\n \t\t\t    py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t    _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_less_equal (UINT64 x,\n+bid64_signaling_less_equal (UINT64 x,\n \t\t\t    UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t    _EXC_INFO_PARAM) {\n #endif\n@@ -2587,7 +2474,7 @@ __bid64_signaling_less_equal (UINT64 x,\n   // if either number is NAN, the comparison is unordered, \n   // rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 0;\n     BID_RETURN (res);\n   }\n@@ -2705,7 +2592,7 @@ __bid64_signaling_less_equal (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2746,15 +2633,15 @@ __bid64_signaling_less_equal (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_less_unordered (int *pres, UINT64 * px,\n+bid64_signaling_less_unordered (int *pres, UINT64 * px,\n \t\t\t\tUINT64 *\n \t\t\t\tpy _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t\t_EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_less_unordered (UINT64 x,\n+bid64_signaling_less_unordered (UINT64 x,\n \t\t\t\tUINT64 y _EXC_FLAGS_PARAM\n \t\t\t\t_EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -2767,7 +2654,7 @@ __bid64_signaling_less_unordered (UINT64 x,\n   // NaN (CASE1)\n   // if either number is NAN, the comparison is unordered : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 1;\n     BID_RETURN (res);\n   }\n@@ -2887,7 +2774,7 @@ __bid64_signaling_less_unordered (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -2928,138 +2815,15 @@ __bid64_signaling_less_unordered (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_not_equal (int *pres, UINT64 * px,\n-\t\t\t   UINT64 *\n-\t\t\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t   _EXC_INFO_PARAM) {\n-  UINT64 x = *px;\n-  UINT64 y = *py;\n-#else\n-int\n-__bid64_signaling_not_equal (UINT64 x,\n-\t\t\t   UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t   _EXC_INFO_PARAM) {\n-#endif\n-  int res;\n-  int exp_x, exp_y, exp_t;\n-  UINT64 sig_x, sig_y, sig_t;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y, lcv;\n-\n-  // NaN (CASE1)\n-  // if either number is NAN, the comparison is unordered, \n-  // rather than equal : return 1\n-  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-  // SIMPLE (CASE2)\n-  // if all the bits are the same, these numbers are equivalent.\n-  if (x == y) {\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-  // INFINITY (CASE3)\n-  if (((x & MASK_INF) == MASK_INF) && ((y & MASK_INF) == MASK_INF)) {\n-    res = (((x ^ y) & MASK_SIGN) == MASK_SIGN);\n-    BID_RETURN (res);\n-  }\n-  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n-  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n-    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n-  } else {\n-    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n-    sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n-  }\n-\n-  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n-  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n-    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n-  } else {\n-    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n-    sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n-  }\n-\n-  // ZERO (CASE4)\n-  // some properties:\n-  // (+ZERO==-ZERO) => therefore ignore the sign\n-  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n-  //      therefore ignore the exponent field\n-  //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n-    x_is_zero = 1;\n-  }\n-  if (non_canon_y || sig_y == 0) {\n-    y_is_zero = 1;\n-  }\n-\n-  if (x_is_zero && y_is_zero) {\n-    res = 0;\n-    BID_RETURN (res);\n-  } else if ((x_is_zero && !y_is_zero) || (!x_is_zero && y_is_zero)) {\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-  // OPPOSITE SIGN (CASE5)\n-  // now, if the sign bits differ => not equal : return 1\n-  if ((x ^ y) & MASK_SIGN) {\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-  // REDUNDANT REPRESENTATIONS (CASE6)\n-  if (exp_x > exp_y) { // to simplify the loop below,\n-    SWAP (exp_x, exp_y, exp_t); // put the larger exp in y,\n-    SWAP (sig_x, sig_y, sig_t); // and the smaller exp in x\n-  }\n-\n-  if (exp_y - exp_x > 15) {\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-  // difference cannot be greater than 10^16\n-\n-  for (lcv = 0; lcv < (exp_y - exp_x); lcv++) {\n-\n-    // recalculate y's significand upwards\n-    sig_y = sig_y * 10;\n-    if (sig_y > 9999999999999999ull) {\n-      res = 1;\n-      BID_RETURN (res);\n-    }\n-  }\n-\n-  {\n-    res = sig_y != sig_x;\n-    BID_RETURN (res);\n-  }\n-\n-}\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-void\n-__bid64_signaling_not_greater (int *pres, UINT64 * px,\n+bid64_signaling_not_greater (int *pres, UINT64 * px,\n \t\t\t     UINT64 *\n \t\t\t     py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t     _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_not_greater (UINT64 x,\n+bid64_signaling_not_greater (UINT64 x,\n \t\t\t     UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t     _EXC_INFO_PARAM) {\n #endif\n@@ -3073,7 +2837,7 @@ __bid64_signaling_not_greater (UINT64 x,\n   // if either number is NAN, the comparison is unordered, \n   // rather than equal : return 0\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 1;\n     BID_RETURN (res);\n   }\n@@ -3191,7 +2955,7 @@ __bid64_signaling_not_greater (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -3232,15 +2996,15 @@ __bid64_signaling_not_greater (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_signaling_not_less (int *pres, UINT64 * px,\n+bid64_signaling_not_less (int *pres, UINT64 * px,\n \t\t\t  UINT64 *\n \t\t\t  py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t  _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_signaling_not_less (UINT64 x,\n+bid64_signaling_not_less (UINT64 x,\n \t\t\t  UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t\t  _EXC_INFO_PARAM) {\n #endif\n@@ -3253,7 +3017,7 @@ __bid64_signaling_not_less (UINT64 x,\n   // NaN (CASE1)\n   // if either number is NAN, the comparison is unordered : return 1\n   if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n+    *pfpsf |= INVALID_EXCEPTION;\t// set invalid exception if NaN\n     res = 1;\n     BID_RETURN (res);\n   }\n@@ -3373,7 +3137,7 @@ __bid64_signaling_not_less (UINT64 x,\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -3411,61 +3175,3 @@ __bid64_signaling_not_less (UINT64 x,\n     BID_RETURN (res);\n   }\n }\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-void\n-__bid64_signaling_ordered (int *pres, UINT64 * px,\n-\t\t\t UINT64 *\n-\t\t\t py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t _EXC_INFO_PARAM) {\n-  UINT64 x = *px;\n-  UINT64 y = *py;\n-#else\n-int\n-__bid64_signaling_ordered (UINT64 x,\n-\t\t\t UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t _EXC_INFO_PARAM) {\n-#endif\n-  int res;\n-\n-  // NaN (CASE1)\n-  // if either number is NAN, the comparison is ordered, \n-  // rather than equal : return 0\n-  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n-    res = 0;\n-    BID_RETURN (res);\n-  } else {\n-    res = 1;\n-    BID_RETURN (res);\n-  }\n-}\n-\n-#if DECIMAL_CALL_BY_REFERENCE\n-void\n-__bid64_signaling_unordered (int *pres, UINT64 * px,\n-\t\t\t   UINT64 *\n-\t\t\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t   _EXC_INFO_PARAM) {\n-  UINT64 x = *px;\n-  UINT64 y = *py;\n-#else\n-int\n-__bid64_signaling_unordered (UINT64 x,\n-\t\t\t   UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t   _EXC_INFO_PARAM) {\n-#endif\n-  int res;\n-\n-  // NaN (CASE1)\n-  // if either number is NAN, the comparison is unordered, \n-  // rather than equal : return 0\n-  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    *pfpsf |= INVALID_EXCEPTION; // set invalid exception if NaN\n-    res = 1;\n-    BID_RETURN (res);\n-  } else {\n-    res = 0;\n-    BID_RETURN (res);\n-  }\n-}"}, {"sha": "7357f3dbdafb78d000ceca809c8137f3e4a36dd8", "filename": "libgcc/config/libbid/bid64_div.c", "status": "modified", "additions": 1336, "deletions": 33, "changes": 1369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -59,24 +59,30 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n  ****************************************************************************/\n \n #include \"bid_internal.h\"\n+#include \"bid_div_macros.h\"\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+#include <fenv.h>\n \n-extern UINT32 __bid_convert_table[5][128][2];\n-extern SINT8 __bid_factors[][2];\n-extern UINT8 __bid_packed_10000_zeros[];\n+#define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT\n+#endif\n+\n+extern UINT32 convert_table[5][128][2];\n+extern SINT8 factors[][2];\n+extern UINT8 packed_10000_zeros[];\n \n \n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_div (UINT64 * pres, UINT64 * px,\n+bid64_div (UINT64 * pres, UINT64 * px,\n \t   UINT64 *\n \t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t   _EXC_INFO_PARAM) {\n   UINT64 x, y;\n #else\n \n UINT64\n-__bid64_div (UINT64 x,\n+bid64_div (UINT64 x,\n \t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -88,11 +94,14 @@ __bid64_div (UINT64 x,\n   int_double t_scale, tempq, temp_b;\n   int_float tempx, tempy;\n   double da, db, dq, da_h, da_l;\n-  int exponent_x = 0, exponent_y = 0, bin_expon_cx;\n+  int exponent_x, exponent_y, bin_expon_cx;\n   int diff_expon, ed1, ed2, bin_index;\n   int rmode, amount;\n   int nzeros, i, j, k, d5;\n   UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  fexcept_t binaryflags = 0;\n+#endif\n \n #if DECIMAL_CALL_BY_REFERENCE\n #if !DECIMAL_GLOBAL_ROUNDING\n@@ -119,25 +128,28 @@ __bid64_div (UINT64 x,\n       if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      BID_RETURN (x & QUIET_MASK64);\n+      BID_RETURN (coefficient_x & QUIET_MASK64);\n     }\n     // x is Infinity?\n     if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n       // check if y is Inf or NaN\n       if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n \t// y==Inf, return NaN \n+\tif ((y & NAN_MASK64) == INFINITY_MASK64) {\t// Inf/Inf\n #ifdef SET_STATUS_FLAGS\n-\tif ((y & NAN_MASK64) == INFINITY_MASK64)\t// Inf/Inf\n \t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-\tBID_RETURN (NAN_MASK64);\n+\t  BID_RETURN (NAN_MASK64);\n+\t}\n+      } else {\n+\t// otherwise return +/-Inf\n+\tBID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n+\t\t    INFINITY_MASK64);\n       }\n-      // otherwise return +/-Inf\n-      BID_RETURN (((x ^ y) & 0x8000000000000000ull) | INFINITY_MASK64);\n     }\n     // x==0\n-    if (((y & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n-\t&& !(y << (64 - 53))) {\n+    if (((y & INFINITY_MASK64) != INFINITY_MASK64)\n+\t&& !(coefficient_y)) {\n       // y==0 , return NaN\n #ifdef SET_STATUS_FLAGS\n       __set_status_flags (pfpsf, INVALID_EXCEPTION);\n@@ -169,7 +181,7 @@ __bid64_div (UINT64 x,\n       if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      BID_RETURN (y & QUIET_MASK64);\n+      BID_RETURN (coefficient_y & QUIET_MASK64);\n     }\n     // y is Infinity?\n     if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n@@ -182,7 +194,9 @@ __bid64_div (UINT64 x,\n #endif\n     BID_RETURN ((sign_x ^ sign_y) | INFINITY_MASK64);\n   }\n-\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+  (void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n   diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n \n   if (coefficient_x < coefficient_y) {\n@@ -193,16 +207,16 @@ __bid64_div (UINT64 x,\n     tempy.d = (float) coefficient_y;\n     bin_index = (tempy.i - tempx.i) >> 23;\n \n-    A = coefficient_x * __bid_power10_index_binexp[bin_index];\n+    A = coefficient_x * power10_index_binexp[bin_index];\n     B = coefficient_y;\n \n     temp_b.d = (double) B;\n \n     // compare A, B\n     DU = (A - B) >> 63;\n     ed1 = 15 + (int) DU;\n-    ed2 = __bid_estimate_decimal_digits[bin_index] + ed1;\n-    T = __bid_power10_table_128[ed1].w[0];\n+    ed2 = estimate_decimal_digits[bin_index] + ed1;\n+    T = power10_table_128[ed1].w[0];\n     __mul_64x64_to_128 (CA, A, T);\n \n     Q = 0;\n@@ -243,19 +257,22 @@ __bid64_div (UINT64 x,\n       res =\n \tget_BID64 (sign_x ^ sign_y, diff_expon, (Q + R), rnd_mode,\n \t\t   pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n       BID_RETURN (res);\n     }\n     // get decimal digits of Q\n-    DU = __bid_power10_index_binexp[bin_expon_cx] - Q - 1;\n+    DU = power10_index_binexp[bin_expon_cx] - Q - 1;\n     DU >>= 63;\n \n-    ed2 = 16 - __bid_estimate_decimal_digits[bin_expon_cx] - (int) DU;\n+    ed2 = 16 - estimate_decimal_digits[bin_expon_cx] - (int) DU;\n \n-    T = __bid_power10_table_128[ed2].w[0];\n+    T = power10_table_128[ed2].w[0];\n     __mul_64x64_to_128 (CA, R, T);\n     B = coefficient_y;\n \n-    Q *= __bid_power10_table_128[ed2].w[0];\n+    Q *= power10_table_128[ed2].w[0];\n     diff_expon -= ed2;\n \n   }\n@@ -340,17 +357,17 @@ __bid64_div (UINT64 x,\n     if ((coefficient_x <= 1024) && (coefficient_y <= 1024)) {\n       i = (int) coefficient_y - 1;\n       j = (int) coefficient_x - 1;\n-      // difference in powers of 2 __bid_factors for Y and X\n-      nzeros = ed2 - __bid_factors[i][0] + __bid_factors[j][0];\n-      // difference in powers of 5 __bid_factors\n-      d5 = ed2 - __bid_factors[i][1] + __bid_factors[j][1];\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n       if (d5 < nzeros)\n \tnzeros = d5;\n \n-      __mul_64x64_to_128 (CT, Q, __bid_reciprocals10_64[nzeros]);\n+      __mul_64x64_to_128 (CT, Q, reciprocals10_64[nzeros]);\n \n       // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-      amount = __bid_short_recip_scale[nzeros];\n+      amount = short_recip_scale[nzeros];\n       Q = CT.w[1] >> amount;\n \n       diff_expon += nzeros;\n@@ -363,8 +380,8 @@ __bid64_div (UINT64 x,\n \n       for (j = 0; QX32; j++, QX32 >>= 7) {\n \tk = (QX32 & 127);\n-\ttdigit[0] += __bid_convert_table[j][k][0];\n-\ttdigit[1] += __bid_convert_table[j][k][1];\n+\ttdigit[0] += convert_table[j][k][0];\n+\ttdigit[1] += convert_table[j][k][1];\n \tif (tdigit[0] >= 100000000) {\n \t  tdigit[0] -= 100000000;\n \t  tdigit[1]++;\n@@ -391,15 +408,15 @@ __bid64_div (UINT64 x,\n \n \tif (!(digit_h & 1))\n \t  nzeros +=\n-\t    3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n+\t    3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n \t\t\t  (digit_h & 7));\n       }\n \n       if (nzeros) {\n-\t__mul_64x64_to_128 (CT, Q, __bid_reciprocals10_64[nzeros]);\n+\t__mul_64x64_to_128 (CT, Q, reciprocals10_64[nzeros]);\n \n \t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-\tamount = __bid_short_recip_scale[nzeros];\n+\tamount = short_recip_scale[nzeros];\n \tQ = CT.w[1] >> amount;\n       }\n       diff_expon += nzeros;\n@@ -409,6 +426,9 @@ __bid64_div (UINT64 x,\n       res =\n \tfast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, Q,\n \t\t\t\t rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n       BID_RETURN (res);\n     }\n   }\n@@ -476,6 +496,9 @@ __bid64_div (UINT64 x,\n     res =\n       fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, Q, rnd_mode,\n \t\t\t       pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n     BID_RETURN (res);\n   } else {\n     // UF occurs\n@@ -489,9 +512,1289 @@ __bid64_div (UINT64 x,\n     rmode = rnd_mode;\n     res =\n       get_BID64_UF (sign_x ^ sign_y, diff_expon, Q, R, rmode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\n+  }\n+}\n+\n+\n+\n+TYPE0_FUNCTION_ARGTYPE1_ARG128 (UINT64, bid64dq_div, UINT64, x, y)\n+     UINT256 CA4 =\n+       { {0x0ull, 0x0ull, 0x0ull, 0x0ull} }, CA4r, P256, QB256;\n+UINT128 CX, CY, T128, CQ, CQ2, CR, CA, TP128, Qh, Ql, Tmp;\n+UINT64 sign_x, sign_y, T, carry64, D, Q_low, QX, valid_y, PD, res;\n+int_float fx, fy, f64;\n+UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+  digits_q, amount;\n+int nzeros, i, j, k, d5, done = 0;\n+unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+fexcept_t binaryflags = 0;\n+#endif\n+\n+valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);\n+\n+\t// unpack arguments, check for NaN or Infinity\n+CX.w[1] = 0;\n+if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {\n+#ifdef SET_STATUS_FLAGS\n+    if (((y.w[1] & SNAN_MASK64) == SNAN_MASK64) ||\t// y is sNaN\n+\t\t((x & SNAN_MASK64) == SNAN_MASK64))\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  // test if x is NaN\n+  if (((x) & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    res = CX.w[0];\n+    BID_RETURN (res & QUIET_MASK64);\n+  }\n+  // x is Infinity?\n+  if (((x) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // check if y is Inf.\n+    if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+      // return NaN \n+    {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+\tif (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {\n+    // otherwise return +/-Inf\n+    res =\n+      (((x) ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+    BID_RETURN (res);\n+\t}\n+  }\n+  // x is 0\n+  if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) {\n+    if ((!CY.w[0]) && !(CY.w[1] & 0x0001ffffffffffffull)) {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      // x=y=0, return NaN\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+    // return 0\n+    res = ((x) ^ y.w[1]) & 0x8000000000000000ull;\n+    exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+    if (exponent_x > DECIMAL_MAX_EXPON_64)\n+      exponent_x = DECIMAL_MAX_EXPON_64;\n+    else if (exponent_x < 0)\n+      exponent_x = 0;\n+    res |= (((UINT64) exponent_x) << 53);\n+    BID_RETURN (res);\n+  }\n+}\n+exponent_x += (DECIMAL_EXPONENT_BIAS_128 - DECIMAL_EXPONENT_BIAS);\n+if (!valid_y) {\n+  // y is Inf. or NaN\n+\n+  // test if y is NaN\n+  if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    Tmp.w[1] = (CY.w[1] & 0x00003fffffffffffull);\n+    Tmp.w[0] = CY.w[0];\n+    TP128 = reciprocals10_128[18];\n+    __mul_128x128_full (Qh, Ql, Tmp, TP128);\n+    amount = recip_scale[18];\n+    __shr_128 (Tmp, Qh, amount);\n+    res = (CY.w[1] & 0xfc00000000000000ull) | Tmp.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res = sign_x ^ sign_y;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n+  res =\n+    (((x) ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 15;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  if (digits_q <= 16) {\n+    if (!CR.w[1] && !CR.w[0]) {\n+      res = get_BID64 (sign_x ^ sign_y, diff_expon,\n+\t\t       CQ.w[0], rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+      BID_RETURN (res);\n+    }\n+\n+    ed2 = 16 - digits_q;\n+    T128.w[0] = power10_table_128[ed2].w[0];\n+    __mul_64x128_to_192 (CA4, (T128.w[0]), CR);\n+    diff_expon = diff_expon - ed2;\n+    CQ.w[0] *= T128.w[0];\n+  } else {\n+    ed2 = digits_q - 16;\n+    diff_expon += ed2;\n+    T128 = reciprocals10_128[ed2];\n+    __mul_128x128_to_256 (P256, CQ, T128);\n+    amount = recip_scale[ed2];\n+    CQ.w[0] = (P256.w[2] >> amount) | (P256.w[3] << (64 - amount));\n+    CQ.w[1] = 0;\n+\n+    __mul_64x64_to_128 (CQ2, CQ.w[0], (power10_table_128[ed2].w[0]));\n+\n+    __mul_64x64_to_128 (QB256, CQ2.w[0], CY.w[0]);\n+    QB256.w[1] += CQ2.w[0] * CY.w[1] + CQ2.w[1] * CY.w[0];\n+\n+    CA4.w[1] = CX.w[1] - QB256.w[1];\n+    CA4.w[0] = CX.w[0] - QB256.w[0];\n+    if (CX.w[0] < QB256.w[0])\n+      CA4.w[1]--;\n+    if (CR.w[0] || CR.w[1])\n+      CA4.w[0] |= 1;\n+    done = 1;\n+\n+  }\n+\n+}\n+if (!done) {\n+  __div_256_by_128 (&CQ, &CA4, CY);\n+}\n+\n+ \n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n+      if (d5 < nzeros)\n+\tnzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      Q_low = CQ.w[0];\n+\n+      {\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n+\n+      }\n+    }\n+\tif(diff_expon>=0){\n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],\n+\t\t\t       rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\t}\n+  }\n+#endif\n+\n+  if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break; \n+  }\n+#endif\n+#endif\n+  \n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0], rnd_mode,\n+\t\t\t       pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  } else {\n+    // UF occurs\n+\n+#ifdef SET_STATUS_FLAGS\n+    if ((diff_expon + 16 < 0)) {\n+      // set status flags\n+      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+    }\n+#endif\n+    rmode = rnd_mode;\n+    res =\n+      get_BID64_UF (sign_x ^ sign_y, diff_expon, CQ.w[0], CA4.w[1] | CA4.w[0], rmode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\n+  }\n+\n+}\n+\n+\n+//#define LEAVE_TRAILING_ZEROS\n+\n+TYPE0_FUNCTION_ARG128_ARGTYPE2 (UINT64, bid64qd_div, x, UINT64, y)\n+\n+     UINT256 CA4 =\n+       { {0x0ull, 0x0ull, 0x0ull, 0x0ull} }, CA4r, P256, QB256;\n+UINT128 CX, CY, T128, CQ, CQ2, CR, CA, TP128, Qh, Ql, Tmp;\n+UINT64 sign_x, sign_y, T, carry64, D, Q_low, QX, PD, res, valid_y;\n+int_float fx, fy, f64;\n+UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+  digits_q, amount;\n+int nzeros, i, j, k, d5, done = 0;\n+unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+fexcept_t binaryflags = 0;\n+#endif\n+\n+valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], (y));\n+\n+\t// unpack arguments, check for NaN or Infinity\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+  // test if x is NaN\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull ||\t// sNaN\n+\t(y & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      Tmp.w[1] = (CX.w[1] & 0x00003fffffffffffull);\n+      Tmp.w[0] = CX.w[0];\n+      TP128 = reciprocals10_128[18];\n+      __mul_128x128_full (Qh, Ql, Tmp, TP128);\n+      amount = recip_scale[18];\n+      __shr_128 (Tmp, Qh, amount);\n+      res = (CX.w[1] & 0xfc00000000000000ull) | Tmp.w[0];\n+    BID_RETURN (res);\n+  }\n+  // x is Infinity?\n+  if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // check if y is Inf.\n+    if (((y & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+      // return NaN \n+    {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+\tif (((y & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {\n+    // otherwise return +/-Inf\n+    res =\n+      ((x.w[1] ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+    BID_RETURN (res);\n+\t}\n+  }\n+  // x is 0\n+  if (((y & INFINITY_MASK64) != INFINITY_MASK64) &&\n+      !(CY.w[0])) {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // x=y=0, return NaN\n+    res = 0x7c00000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // return 0\n+  if (((y & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+\t  if (!CY.w[0]) {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+\t  }\n+    exponent_x =\n+      exponent_x - exponent_y - DECIMAL_EXPONENT_BIAS_128 +\n+      (DECIMAL_EXPONENT_BIAS << 1);\n+    if (exponent_x > DECIMAL_MAX_EXPON_64)\n+      exponent_x = DECIMAL_MAX_EXPON_64;\n+    else if (exponent_x < 0)\n+      exponent_x = 0;\n+    res = (sign_x ^ sign_y) | (((UINT64) exponent_x) << 53);\n+    BID_RETURN (res);\n+  }\n+}\n+CY.w[1] = 0;\n+if (!valid_y) {\n+  // y is Inf. or NaN\n+\n+  // test if y is NaN\n+  if ((y & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    BID_RETURN (CY.w[0] & QUIET_MASK64);\n+  }\n+  // y is Infinity?\n+  if (((y) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res = sign_x ^ sign_y;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n+  res =\n+    ((x.w[1] ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon =\n+  exponent_x - exponent_y - DECIMAL_EXPONENT_BIAS_128 +\n+  (DECIMAL_EXPONENT_BIAS << 1);\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 15;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  if (digits_q <= 16) {\n+    if (!CR.w[1] && !CR.w[0]) {\n+      res = get_BID64 (sign_x ^ sign_y, diff_expon,\n+\t\t       CQ.w[0], rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+      BID_RETURN (res);\n+    }\n+\n+    ed2 = 16 - digits_q;\n+    T128.w[0] = power10_table_128[ed2].w[0];\n+    __mul_64x128_to_192 (CA4, (T128.w[0]), CR);\n+    diff_expon = diff_expon - ed2;\n+    CQ.w[0] *= T128.w[0];\n+  } else {\n+    ed2 = digits_q - 16;\n+    diff_expon += ed2;\n+    T128 = reciprocals10_128[ed2];\n+    __mul_128x128_to_256 (P256, CQ, T128);\n+    amount = recip_scale[ed2];\n+    CQ.w[0] = (P256.w[2] >> amount) | (P256.w[3] << (64 - amount));\n+    CQ.w[1] = 0;\n+\n+    __mul_64x64_to_128 (CQ2, CQ.w[0], (power10_table_128[ed2].w[0])); \n+\n+    __mul_64x64_to_128 (QB256, CQ2.w[0], CY.w[0]);\n+    QB256.w[1] += CQ2.w[0] * CY.w[1] + CQ2.w[1] * CY.w[0];\n+\n+    CA4.w[1] = CX.w[1] - QB256.w[1];\n+    CA4.w[0] = CX.w[0] - QB256.w[0];\n+    if (CX.w[0] < QB256.w[0])\n+      CA4.w[1]--;\n+    if (CR.w[0] || CR.w[1])\n+      CA4.w[0] |= 1;\n+    done = 1;\n+\tif(CA4.w[1]|CA4.w[0]) {\n+    __mul_64x128_low(CY, (power10_table_128[ed2].w[0]),CY);\n+\t}\n+\n+  }\n+\n+}\n+\n+if (!done) {\n+  __div_256_by_128 (&CQ, &CA4, CY);\n+}\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else \n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+\t  if(!done) {\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n+      if (d5 < nzeros)\n+\t\tnzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      //T128 = reciprocals10_128[17];\n+      Q_low = CQ.w[0];\n+\n+      {\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n+\n+      }\n+    }\n+\t  }\n+\tif(diff_expon>=0){\n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],\n+\t\t\t       rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n     BID_RETURN (res);\n+\t}\n+  }\n+#endif\n \n+  if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  //if(CQ.w[0]<carry64)\n+  //CQ.w[1] ++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n   }\n+#endif\n+#endif\n \n+  \n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0], rnd_mode,\n+\t\t\t       pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  } else {\n+    // UF occurs\n+\n+#ifdef SET_STATUS_FLAGS\n+    if ((diff_expon + 16 < 0)) {\n+      // set status flags\n+      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+    }\n+#endif\n+    rmode = rnd_mode;\n+    res =\n+      get_BID64_UF (sign_x ^ sign_y, diff_expon, CQ.w[0], CA4.w[1] | CA4.w[0], rmode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\n+  }\n+\n+}\n+\n+//#define LEAVE_TRAILING_ZEROS\n+\n+extern UINT32 convert_table[5][128][2];\n+extern SINT8 factors[][2];\n+extern UINT8 packed_10000_zeros[];\n+\n+\n+//UINT64* bid64_div128x128(UINT64 res, UINT128 *px, UINT128 *py, unsigned rnd_mode, unsigned *pfpsf) \n+\n+TYPE0_FUNCTION_ARG128_ARG128 (UINT64, bid64qq_div, x, y)\n+     UINT256 CA4 =\n+       { {0x0ull, 0x0ull, 0x0ull, 0x0ull} }, CA4r, P256, QB256;\n+UINT128 CX, CY, T128, CQ, CQ2, CR, CA, TP128, Qh, Ql, Tmp;\n+UINT64 sign_x, sign_y, T, carry64, D, Q_low, QX, valid_y, PD, res;\n+int_float fx, fy, f64;\n+UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+  digits_q, amount;\n+int nzeros, i, j, k, d5, done = 0;\n+unsigned rmode;\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+fexcept_t binaryflags = 0;\n+#endif\n+\n+valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);\n+\n+\t// unpack arguments, check for NaN or Infinity\n+if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+  // test if x is NaN\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull ||\t// sNaN\n+\t(y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      Tmp.w[1] = (CX.w[1] & 0x00003fffffffffffull);\n+      Tmp.w[0] = CX.w[0];\n+      TP128 = reciprocals10_128[18];\n+      __mul_128x128_full (Qh, Ql, Tmp, TP128);\n+      amount = recip_scale[18];\n+      __shr_128 (Tmp, Qh, amount);\n+      res = (CX.w[1] & 0xfc00000000000000ull) | Tmp.w[0];\n+    BID_RETURN (res);\n+  }\n+  // x is Infinity?\n+  if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // check if y is Inf.\n+    if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+      // return NaN \n+    {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+\tif (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {\n+    // otherwise return +/-Inf\n+    res =\n+      ((x.w[1] ^ y.\n+\tw[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+    BID_RETURN (res);\n+\t}\n+  }\n+  // x is 0\n+  if (((y.w[1] & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+  if ((!CY.w[0]) && !(CY.w[1] & 0x0001ffffffffffffull)) {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // x=y=0, return NaN\n+    res = 0x7c00000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // return 0\n+  res = (x.w[1] ^ y.w[1]) & 0x8000000000000000ull;\n+  exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+  if (exponent_x > DECIMAL_MAX_EXPON_64)\n+    exponent_x = DECIMAL_MAX_EXPON_64;\n+  else if (exponent_x < 0)\n+    exponent_x = 0;\n+  res |= (((UINT64) exponent_x) << 53);\n+  BID_RETURN (res);\n+  }\n+}\n+if (!valid_y) {\n+  // y is Inf. or NaN\n+\n+  // test if y is NaN\n+  if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      Tmp.w[1] = (CY.w[1] & 0x00003fffffffffffull);\n+      Tmp.w[0] = CY.w[0];\n+      TP128 = reciprocals10_128[18];\n+      __mul_128x128_full (Qh, Ql, Tmp, TP128);\n+      amount = recip_scale[18];\n+      __shr_128 (Tmp, Qh, amount);\n+      res = (CY.w[1] & 0xfc00000000000000ull) | Tmp.w[0];\n+    BID_RETURN (res);\n+  }\n+  // y is Infinity?\n+  if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+    // return +/-0\n+    res = sign_x ^ sign_y;\n+    BID_RETURN (res);\n+  }\n+  // y is 0, return +/-Inf\n+  res =\n+    ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+  BID_RETURN (res);\n+}\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+(void) fegetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+\n+if (__unsigned_compare_gt_128 (CY, CX)) {\n+  // CX < CY\n+\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX,   fy ~ CY\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+  // expon_cy - expon_cx\n+  bin_index = (fy.i - fx.i) >> 23;\n+\n+  if (CX.w[1]) {\n+    T = power10_index_binexp_128[bin_index].w[0];\n+    __mul_64x128_short (CA, T, CX);\n+  } else {\n+    T128 = power10_index_binexp_128[bin_index];\n+    __mul_64x128_short (CA, CX.w[0], T128);\n+  }\n+\n+  ed2 = 15;\n+  if (__unsigned_compare_gt_128 (CY, CA))\n+    ed2++;\n+\n+  T128 = power10_table_128[ed2];\n+  __mul_128x128_to_256 (CA4, CA, T128);\n+\n+  ed2 += estimate_decimal_digits[bin_index];\n+  CQ.w[0] = CQ.w[1] = 0;\n+  diff_expon = diff_expon - ed2;\n+\n+} else {\n+  // get CQ = CX/CY\n+  __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+  // get number of decimal digits in CQ\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+  // binary expon. of CQ\n+  bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+  digits_q = estimate_decimal_digits[bin_expon];\n+  TP128.w[0] = power10_index_binexp_128[bin_expon].w[0];\n+  TP128.w[1] = power10_index_binexp_128[bin_expon].w[1];\n+  if (__unsigned_compare_ge_128 (CQ, TP128))\n+    digits_q++;\n+\n+  if (digits_q <= 16) {\n+    if (!CR.w[1] && !CR.w[0]) {\n+      res = get_BID64 (sign_x ^ sign_y, diff_expon,\n+\t\t       CQ.w[0], rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+      BID_RETURN (res);\n+    }\n+\n+    ed2 = 16 - digits_q;\n+    T128.w[0] = power10_table_128[ed2].w[0];\n+    __mul_64x128_to_192 (CA4, (T128.w[0]), CR);\n+    diff_expon = diff_expon - ed2;\n+    CQ.w[0] *= T128.w[0];\n+  } else {\n+    ed2 = digits_q - 16;\n+    diff_expon += ed2;\n+    T128 = reciprocals10_128[ed2];\n+    __mul_128x128_to_256 (P256, CQ, T128);\n+    amount = recip_scale[ed2];\n+    CQ.w[0] = (P256.w[2] >> amount) | (P256.w[3] << (64 - amount));\n+    CQ.w[1] = 0;\n+\n+    __mul_64x64_to_128 (CQ2, CQ.w[0], (power10_table_128[ed2].w[0]));\n+\n+    __mul_64x64_to_128 (QB256, CQ2.w[0], CY.w[0]);\n+    QB256.w[1] += CQ2.w[0] * CY.w[1] + CQ2.w[1] * CY.w[0];\n+\n+    CA4.w[1] = CX.w[1] - QB256.w[1];\n+    CA4.w[0] = CX.w[0] - QB256.w[0];\n+    if (CX.w[0] < QB256.w[0])\n+      CA4.w[1]--;\n+    if (CR.w[0] || CR.w[1])\n+      CA4.w[0] |= 1;\n+    done = 1;\n+\tif(CA4.w[1]|CA4.w[0]) {\n+    __mul_64x128_low(CY, (power10_table_128[ed2].w[0]),CY);\n+\t}\n+  }\n+\n+}\n+\n+if (!done) {\n+  __div_256_by_128 (&CQ, &CA4, CY);\n+}\n+\n+ \n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else \n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+\t  if(!done) {\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 factors for Y and X\n+      nzeros = ed2 - factors[i][0] + factors[j][0];\n+      // difference in powers of 5 factors\n+      d5 = ed2 - factors[i][1] + factors[j][1];\n+      if (d5 < nzeros)\n+\tnzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      //T128 = reciprocals10_128[17];\n+      Q_low = CQ.w[0];\n+\n+      {\n+\ttdigit[0] = Q_low & 0x3ffffff;\n+\ttdigit[1] = 0;\n+\tQX = Q_low >> 26;\n+\tQX32 = QX;\n+\tnzeros = 0;\n+\n+\tfor (j = 0; QX32; j++, QX32 >>= 7) {\n+\t  k = (QX32 & 127);\n+\t  tdigit[0] += convert_table[j][k][0];\n+\t  tdigit[1] += convert_table[j][k][1];\n+\t  if (tdigit[0] >= 100000000) {\n+\t    tdigit[0] -= 100000000;\n+\t    tdigit[1]++;\n+\t  }\n+\t}\n+\n+\tif (tdigit[1] >= 100000000) {\n+\t  tdigit[1] -= 100000000;\n+\t  if (tdigit[1] >= 100000000)\n+\t    tdigit[1] -= 100000000;\n+\t}\n+\n+\tdigit = tdigit[0];\n+\tif (!digit && !tdigit[1])\n+\t  nzeros += 16;\n+\telse {\n+\t  if (!digit) {\n+\t    nzeros += 8;\n+\t    digit = tdigit[1];\n+\t  }\n+\t  // decompose digit\n+\t  PD = (UINT64) digit *0x068DB8BBull;\n+\t  digit_h = (UINT32) (PD >> 40);\n+\t  digit_low = digit - digit_h * 10000;\n+\n+\t  if (!digit_low)\n+\t    nzeros += 4;\n+\t  else\n+\t    digit_h = digit_low;\n+\n+\t  if (!(digit_h & 1))\n+\t    nzeros +=\n+\t      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t    (digit_h & 7));\n+\t}\n+\n+\tif (nzeros) {\n+\t  // get P*(2^M[extra_digits])/10^extra_digits\n+\t  __mul_128x128_full (Qh, Ql, CQ, reciprocals10_128[nzeros]);\n+\n+\t  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+\t  amount = recip_scale[nzeros];\n+\t  __shr_128 (CQ, Qh, amount);\n+\t}\n+\tdiff_expon += nzeros;\n+\n+      }\n+    }\n+\t  }\n+\tif(diff_expon>=0){\n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],\n+\t\t\t       rnd_mode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\t}\n+  }\n+#endif\n+\n+  if(diff_expon>=0) {\n+\n+#ifdef IEEE_ROUND_NEAREST\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+  CQ.w[0] += carry64;\n+  //if(CQ.w[0]<carry64)\n+  //CQ.w[1] ++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  // rounding\n+  // 2*CA4 - CY\n+  CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+  CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+  __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+  CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+  D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+  carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+  CQ.w[0] += carry64;\n+  if (CQ.w[0] < carry64)\n+    CQ.w[1]++;\n+#else\n+  rmode = rnd_mode;\n+  if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\t// round to nearest code\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    break;\n+  default:\t// rounding up\n+    CQ.w[0]++;\n+    if (!CQ.w[0])\n+      CQ.w[1]++;\n+    break;\n+  }\n+#endif\n+#endif\n+\n+  \n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0], rnd_mode,\n+\t\t\t       pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+  } else {\n+    // UF occurs\n+\n+#ifdef SET_STATUS_FLAGS\n+    if ((diff_expon + 16 < 0)) {\n+      // set status flags\n+      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+    }\n+#endif\n+    rmode = rnd_mode;\n+    res =\n+      get_BID64_UF (sign_x ^ sign_y, diff_expon, CQ.w[0], CA4.w[1] | CA4.w[0], rmode, pfpsf);\n+#ifdef UNCHANGED_BINARY_STATUS_FLAGS\n+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);\n+#endif\n+    BID_RETURN (res);\n+\n+  }\n \n }"}, {"sha": "6073d59a39bb1c2462faeb3a6189e8f44c0ba93b", "filename": "libgcc/config/libbid/bid64_fma.c", "status": "modified", "additions": 201, "deletions": 317, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -33,147 +33,51 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n  *  Algorithm description:\n  *\n  *  if multiplication is guranteed exact (short coefficients)\n- *     call the unpacked arg. equivalent of __bid64_add(x*y, z)\n+ *     call the unpacked arg. equivalent of bid64_add(x*y, z)\n  *  else \n  *     get full coefficient_x*coefficient_y product\n  *     call subroutine to perform addition of 64-bit argument \n  *                                         to 128-bit product\n  *\n  ****************************************************************************/\n \n-#include \"inline_bid_add.h\"\n-\n-//////////////////////////////////////////////////////////////////////////\n-//\n-//  If coefficient_z is less than 16 digits long, normalize to 16 digits\n-//\n-/////////////////////////////////////////////////////////////////////////\n-\n-#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-  #ifndef IEEE_ROUND_NEAREST\n-static UINT64\n-__bid_normalize (UINT64 sign_z, int exponent_z,\n-               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n-               int rounding_mode, unsigned *fpsc) {\n-  #else\n-static UINT64\n-__bid_normalize (UINT64 z, UINT64 sign_z, int exponent_z,\n-               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n-               int rounding_mode, unsigned *fpsc) {\n-  #endif\n-#else\n-static UINT64\n-__bid_normalize (UINT64 z, UINT64 sign_z, int exponent_z,\n-               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n-               int rounding_mode, unsigned *fpsc) {\n-#endif\n-  SINT64 D;\n-  int_double tempx;\n-  int digits_z, bin_expon, scale, rmode;\n-\n-#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-#ifndef IEEE_ROUND_NEAREST\n-  rmode = rounding_mode;\n-  if (sign_z && (unsigned) (rmode - 1) < 2)\n-    rmode = 3 - rmode;\n-#else\n-  if (coefficient_z >= __bid_power10_table_128[15].w[0])\n-    return z;\n-#endif\n-#endif\n-#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n-  if (coefficient_z >= __bid_power10_table_128[15].w[0])\n-    return z;\n-#endif\n-\n-  //--- get number of bits in the coefficients of x and y ---\n-  tempx.d = (double) coefficient_z;\n-  bin_expon = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n-  // get number of decimal digits in the coeff_x\n-  digits_z = __bid_estimate_decimal_digits[bin_expon];\n-  if (coefficient_z >= __bid_power10_table_128[digits_z].w[0])\n-    digits_z++;\n-\n-  scale = 16 - digits_z;\n-  exponent_z -= scale;\n-  if (exponent_z < 0) {\n-    scale += exponent_z;\n-    exponent_z = 0;\n-  }\n-  coefficient_z *= __bid_power10_table_128[scale].w[0];\n-\n-#ifdef SET_STATUS_FLAGS\n-  if (round_flag) {\n-    __set_status_flags (fpsc, INEXACT_EXCEPTION);\n-    if (coefficient_z < 1000000000000000ull)\n-      __set_status_flags (fpsc, UNDERFLOW_EXCEPTION);\n-    else if ((coefficient_z == 1000000000000000ull) && !exponent_z\n-\t     && ((SINT64) (round_dir ^ sign_z) < 0) && round_flag\n-\t     && (rmode == ROUNDING_DOWN || rmode == ROUNDING_TO_ZERO))\n-      __set_status_flags (fpsc, UNDERFLOW_EXCEPTION);\n-  }\n-#endif\n-\n-#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-#ifndef IEEE_ROUND_NEAREST\n-  if (round_flag && (rmode & 3)) {\n-    D = round_dir ^ sign_z;\n-\n-    if (rmode == ROUNDING_UP) {\n-      if (D >= 0)\n-\tcoefficient_z++;\n-    } else {\n-      if (D < 0)\n-\tcoefficient_z--;\n-      if (coefficient_z < 1000000000000000ull && exponent_z) {\n-\tcoefficient_z = 9999999999999999ull;\n-\texponent_z--;\n-      }\n-    }\n-  }\n-#endif\n-#endif\n-\n-  return get_BID64 (sign_z, exponent_z, coefficient_z, rounding_mode,\n-\t\t    fpsc);\n-}\n-\n+#include \"bid_inline_add.h\"\n \n #if DECIMAL_CALL_BY_REFERENCE\n-extern void __bid64_mul (UINT64 * pres, UINT64 * px,\n+extern void bid64_mul (UINT64 * pres, UINT64 * px,\n \t\t       UINT64 *\n \t\t       py _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM);\n #else\n \n-extern UINT64 __bid64_mul (UINT64 x,\n-\t\t\t     UINT64 y _RND_MODE_PARAM\n-\t\t\t     _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t\t\t     _EXC_INFO_PARAM);\n+extern UINT64 bid64_mul (UINT64 x,\n+\t\t\t UINT64 y _RND_MODE_PARAM\n+\t\t\t _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t _EXC_INFO_PARAM);\n #endif\n \n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_fma (UINT64 * pres, UINT64 * px, UINT64 * py,\n+bid64_fma (UINT64 * pres, UINT64 * px, UINT64 * py,\n \t   UINT64 *\n \t   pz _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t   _EXC_INFO_PARAM) {\n   UINT64 x, y, z;\n #else\n \n UINT64\n-__bid64_fma (UINT64 x, UINT64 y,\n+bid64_fma (UINT64 x, UINT64 y,\n \t   UINT64 z _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 P, PU, CT, CZ;\n   UINT64 sign_x, sign_y, coefficient_x, coefficient_y, sign_z,\n     coefficient_z;\n   UINT64 C64, remainder_y, res;\n-  UINT64 CYh, CY0L, T;\n+  UINT64 CYh, CY0L, T, valid_x, valid_y, valid_z;\n   int_double tempx, tempy;\n-  int extra_digits, exponent_x = 0, exponent_y = 0, bin_expon_cx, bin_expon_cy,\n+  int extra_digits, exponent_x, exponent_y, bin_expon_cx, bin_expon_cy,\n     bin_expon_product, rmode;\n   int digits_p, bp, final_exponent, exponent_z, digits_z, ez, ey,\n     scale_z, uf_status;\n@@ -187,201 +91,198 @@ __bid64_fma (UINT64 x, UINT64 y,\n   z = *pz;\n #endif\n \n-  // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n-    // x is Inf. or NaN\n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n+  valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);\n+  valid_z = unpack_BID64 (&sign_z, &exponent_z, &coefficient_z, z);\n \n-    // test if x is NaN\n-    if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-#ifdef SET_STATUS_FLAGS\n-      if (((x & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n-\t  ((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n-\t  ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-      BID_RETURN (x & QUIET_MASK64);\n-    }\n-    // x is Infinity?\n-    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // check if y is 0\n-      if (((y & 0x6000000000000000ull) != 0x6000000000000000ull)\n-\t  && !(y << (64 - 53))) {\n-\t// y==0, return NaN\n-#ifdef SET_STATUS_FLAGS\n-\tif ((z & 0x7e00000000000000ull) != 0x7c00000000000000ull)\n-\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-\tBID_RETURN (0x7c00000000000000ull);\n+  // unpack arguments, check for NaN, Infinity, or 0\n+  if (!valid_x || !valid_y || !valid_z) {\n+\n+    if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+      // if x = {0, f, inf, NaN}, y = NaN, z = {0, f, inf, NaN} then res = Q (y)\n+      // check first for non-canonical NaN payload\n+      y = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+      if ((y & 0x0003ffffffffffffull) > 999999999999999ull) {\n+\ty = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n       }\n-      // test if z is Inf of oposite sign\n-      if (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n-\t  && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n-\t// return NaN \n-#ifdef SET_STATUS_FLAGS\n-\tif (((y & 0x7e00000000000000ull) != 0x7c00000000000000ull) ||\t// qNaN\n-\t    ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n-\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-\tBID_RETURN (0x7c00000000000000ull);\n+      if ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (y)\n+\tres = y & 0xfdffffffffffffffull;\n+      } else {\t// y is QNaN\n+\t// return y\n+\tres = y;\n+\t// if z = SNaN or x = SNaN signal invalid exception\n+\tif ((z & MASK_SNAN) == MASK_SNAN\n+\t    || (x & MASK_SNAN) == MASK_SNAN) {\n+\t  // set invalid flag\n+\t  *pfpsf |= INVALID_EXCEPTION;\n+\t}\n       }\n-      if ((y & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-#ifdef SET_STATUS_FLAGS\n-\tif (((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n-\t    ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n-\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-\tBID_RETURN (y & QUIET_MASK64);\n+      BID_RETURN (res)\n+    } else if ((z & MASK_NAN) == MASK_NAN) {\t// z is NAN\n+      // if x = {0, f, inf, NaN}, y = {0, f, inf}, z = NaN then res = Q (z)\n+      // check first for non-canonical NaN payload\n+      z = z & 0xfe03ffffffffffffull;\t// clear G6-G12\n+      if ((z & 0x0003ffffffffffffull) > 999999999999999ull) {\n+\tz = z & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n       }\n-      if ((z & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-#ifdef SET_STATUS_FLAGS\n-\tif (((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n-\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-\tBID_RETURN (z & QUIET_MASK64);\n+      if ((z & MASK_SNAN) == MASK_SNAN) {\t// z is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (z)\n+\tres = z & 0xfdffffffffffffffull;\n+      } else {\t// z is QNaN\n+\t// return z\n+\tres = z;\n+\t// if x = SNaN signal invalid exception\n+\tif ((x & MASK_SNAN) == MASK_SNAN) {\n+\t  // set invalid flag\n+\t  *pfpsf |= INVALID_EXCEPTION;\n+\t}\n       }\n-      // otherwise return +/-Inf\n-      BID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n-\t\t  0x7800000000000000ull);\n-    }\n-    // x is 0\n-    if (((y & 0x7800000000000000ull) != 0x7800000000000000ull)\n-\t&& ((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n-      if ((z & 0x6000000000000000ull) == 0x6000000000000000ull) {\n-\texponent_z = ((UINT32) (z >> 51)) & 0x3ff;\n-\tcoefficient_z =\n-\t  (z & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n-      } else {\n-\texponent_z = ((UINT32) (z >> 53)) & 0x3ff;\n-\tcoefficient_z = z & 0x001fffffffffffffull;\n+      BID_RETURN (res)\n+    } else if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      // if x = NaN, y = {0, f, inf}, z = {0, f, inf} then res = Q (x)\n+      // check first for non-canonical NaN payload\n+      x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+      if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\n+\tx = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n       }\n-\n-      if (coefficient_z) {\n-\tif ((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n-\t  exponent_y =\n-\t    exponent_x - DECIMAL_EXPONENT_BIAS +\n-\t    (((UINT32) (y >> 51)) & 0x3ff);\n-\telse\n-\t  exponent_y =\n-\t    exponent_x - DECIMAL_EXPONENT_BIAS +\n-\t    (((UINT32) (y >> 53)) & 0x3ff);\n-\n-\tsign_z = z & 0x8000000000000000ull;\n-\n-\tif (exponent_y >= exponent_z)\n-\t  BID_RETURN (z);\n-\tres =\n-\t  add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n-\t\t      &rnd_mode, pfpsf);\n-\tBID_RETURN (res);\n+      if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres = x & 0xfdffffffffffffffull;\n+      } else {\t// x is QNaN\n+\t// return x\n+\tres = x;\t// clear out G[6]-G[16]\n       }\n+      BID_RETURN (res)\n     }\n-  }\n-  if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n-    // y is Inf. or NaN\n \n-    // test if y is NaN\n-    if ((y & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    if (!valid_x) {\n+      // x is Inf. or 0\n+\n+      // x is Infinity?\n+      if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+\t// check if y is 0\n+\tif (!coefficient_y) {\n+\t  // y==0, return NaN\n #ifdef SET_STATUS_FLAGS\n-      if (((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n-\t  ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+\t  if ((z & 0x7e00000000000000ull) != 0x7c00000000000000ull)\n+\t    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      BID_RETURN (y & QUIET_MASK64);\n-    }\n-    // y is Infinity?\n-    if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      // check if x is 0\n-      if (((x & 0x6000000000000000ull) != 0x6000000000000000ull)\n-\t  && !(x << (64 - 53))) {\n-\t// y==0, return NaN\n+\t  BID_RETURN (0x7c00000000000000ull);\n+\t}\n+\t// test if z is Inf of oposite sign\n+\tif (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n+\t    && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n+\t  // return NaN \n #ifdef SET_STATUS_FLAGS\n-\tif ((z & 0x7e00000000000000ull) != 0x7c00000000000000ull)\n \t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-\tBID_RETURN (0x7c00000000000000ull);\n+\t  BID_RETURN (0x7c00000000000000ull);\n+\t}\n+\t// otherwise return +/-Inf\n+\tBID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n+\t\t    0x7800000000000000ull);\n       }\n-      // test if z is Inf of oposite sign\n-      if (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n-\t  && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n+      // x is 0\n+      if (((y & 0x7800000000000000ull) != 0x7800000000000000ull)\n+\t  && ((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+\n+\tif (coefficient_z) {\n+\t  exponent_y = exponent_x - DECIMAL_EXPONENT_BIAS + exponent_y;\n+\n+\t  sign_z = z & 0x8000000000000000ull;\n+\n+\t  if (exponent_y >= exponent_z)\n+\t    BID_RETURN (z);\n+\t  res =\n+\t    add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n+\t\t\t&rnd_mode, pfpsf);\n+\t  BID_RETURN (res);\n+\t}\n+      }\n+    }\n+    if (!valid_y) {\n+      // y is Inf. or 0\n+\n+      // y is Infinity?\n+      if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+\t// check if x is 0\n+\tif (!coefficient_x) {\n+\t  // y==0, return NaN\n #ifdef SET_STATUS_FLAGS\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-\t// return NaN\n-\tBID_RETURN (0x7c00000000000000ull);\n-      }\n-      if ((z & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+\t  BID_RETURN (0x7c00000000000000ull);\n+\t}\n+\t// test if z is Inf of oposite sign\n+\tif (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n+\t    && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n #ifdef SET_STATUS_FLAGS\n-\tif (((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n \t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-\tBID_RETURN (z & QUIET_MASK64);\n-      }\n-      // otherwise return +/-Inf\n-      BID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n-\t\t  0x7800000000000000ull);\n-    }\n-    // y is 0 \n-    if (((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n-      if ((z & 0x6000000000000000ull) == 0x6000000000000000ull) {\n-\texponent_z = ((UINT32) (z >> 51)) & 0x3ff;\n-\tcoefficient_z =\n-\t  (z & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n-      } else {\n-\texponent_z = ((UINT32) (z >> 53)) & 0x3ff;\n-\tcoefficient_z = z & 0x001fffffffffffffull;\n+\t  // return NaN\n+\t  BID_RETURN (0x7c00000000000000ull);\n+\t}\n+\t// otherwise return +/-Inf\n+\tBID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n+\t\t    0x7800000000000000ull);\n       }\n+      // y is 0 \n+      if (((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n \n-      if (coefficient_z) {\n-\texponent_y += exponent_x - DECIMAL_EXPONENT_BIAS;\n+\tif (coefficient_z) {\n+\t  exponent_y += exponent_x - DECIMAL_EXPONENT_BIAS;\n \n-\tsign_z = z & 0x8000000000000000ull;\n+\t  sign_z = z & 0x8000000000000000ull;\n \n-\tif (exponent_y >= exponent_z)\n-\t  BID_RETURN (z);\n-\tres =\n-\t  add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n-\t\t      &rnd_mode, pfpsf);\n-\tBID_RETURN (res);\n+\t  if (exponent_y >= exponent_z)\n+\t    BID_RETURN (z);\n+\t  res =\n+\t    add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n+\t\t\t&rnd_mode, pfpsf);\n+\t  BID_RETURN (res);\n+\t}\n       }\n     }\n-  }\n \n-  if (!unpack_BID64 (&sign_z, &exponent_z, &coefficient_z, z)) {\n-    // y is Inf. or NaN or 0\n+    if (!valid_z) {\n+      // y is Inf. or 0\n \n-    // test if y is NaN/Inf\n-    if ((z & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-#ifdef SET_STATUS_FLAGS\n-      if ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n-\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n-#endif\n-      BID_RETURN (z & QUIET_MASK64);\n-    }\n-    // z is 0, return x*y\n-    if ((!coefficient_x) || (!coefficient_y)) {\n-      //0+/-0\n-      exponent_x += exponent_y - DECIMAL_EXPONENT_BIAS;\n-      if (exponent_x > DECIMAL_MAX_EXPON_64)\n-\texponent_x = DECIMAL_MAX_EXPON_64;\n-      else if (exponent_x < 0)\n-\texponent_x = 0;\n-      if (exponent_x <= exponent_z)\n-\tres = ((UINT64) exponent_x) << 53;\n-      else\n-\tres = ((z << 1) >> 1);\n-      if ((sign_x ^ sign_y) == sign_z)\n-\tres |= sign_z;\n+      // test if y is NaN/Inf\n+      if ((z & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+\tBID_RETURN (coefficient_z & QUIET_MASK64);\n+      }\n+      // z is 0, return x*y\n+      if ((!coefficient_x) || (!coefficient_y)) {\n+\t//0+/-0\n+\texponent_x += exponent_y - DECIMAL_EXPONENT_BIAS;\n+\tif (exponent_x > DECIMAL_MAX_EXPON_64)\n+\t  exponent_x = DECIMAL_MAX_EXPON_64;\n+\telse if (exponent_x < 0)\n+\t  exponent_x = 0;\n+\tif (exponent_x <= exponent_z)\n+\t  res = ((UINT64) exponent_x) << 53;\n+\telse\n+\t  res = ((UINT64) exponent_z) << 53;\n+\tif ((sign_x ^ sign_y) == sign_z)\n+\t  res |= sign_z;\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n-      else if (rnd_mode == ROUNDING_DOWN)\n-\tres |= 0x8000000000000000ull;\n+\telse if (rnd_mode == ROUNDING_DOWN)\n+\t  res |= 0x8000000000000000ull;\n #endif\n #endif\n-      BID_RETURN (res);\n+\tBID_RETURN (res);\n+      }\n     }\n   }\n \n-\n   /* get binary coefficients of x and y */\n \n   //--- get number of bits in the coefficients of x and y ---\n@@ -404,8 +305,8 @@ __bid64_fma (UINT64 x, UINT64 y,\n     final_exponent = exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS;\n     if ((final_exponent > 0) || (!coefficient_z)) {\n       res =\n-\tget_add64 (sign_z, exponent_z, coefficient_z, sign_x ^ sign_y,\n-\t\t   final_exponent, C64, rnd_mode, pfpsf);\n+\tget_add64 (sign_x ^ sign_y,\n+\t\t   final_exponent, C64, sign_z, exponent_z, coefficient_z, rnd_mode, pfpsf);\n       BID_RETURN (res);\n     } else {\n       P.w[0] = C64;\n@@ -415,12 +316,12 @@ __bid64_fma (UINT64 x, UINT64 y,\n   } else {\n     if (!coefficient_z) {\n #if DECIMAL_CALL_BY_REFERENCE\n-      __bid64_mul (&res, px,\n+      bid64_mul (&res, px,\n \t\t py _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t _EXC_INFO_ARG);\n #else\n       res =\n-\t__bid64_mul (x,\n+\tbid64_mul (x,\n \t\t   y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t   _EXC_INFO_ARG);\n #endif\n@@ -435,9 +336,9 @@ __bid64_fma (UINT64 x, UINT64 y,\n     __tight_bin_range_128 (bp, P, bin_expon_product);\n \n     // get number of decimal digits in the product\n-    digits_p = __bid_estimate_decimal_digits[bp];\n-    if (!(__unsigned_compare_gt_128 (__bid_power10_table_128[digits_p], P)))\n-      digits_p++;\t// if __bid_power10_table_128[digits_p] <= P\n+    digits_p = estimate_decimal_digits[bp];\n+    if (!(__unsigned_compare_gt_128 (power10_table_128[digits_p], P)))\n+      digits_p++;\t// if power10_table_128[digits_p] <= P\n \n     // determine number of decimal digits to be rounded out\n     extra_digits = digits_p - MAX_FORMAT_DIGITS;\n@@ -451,56 +352,37 @@ __bid64_fma (UINT64 x, UINT64 y,\n       tempx.d = (double) coefficient_z;\n       bin_expon_cx = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n       // get number of decimal digits in the coeff_x\n-      digits_z = __bid_estimate_decimal_digits[bin_expon_cx];\n-      if (coefficient_z >= __bid_power10_table_128[digits_z].w[0])\n+      digits_z = estimate_decimal_digits[bin_expon_cx];\n+      if (coefficient_z >= power10_table_128[digits_z].w[0])\n \tdigits_z++;\n       // underflow\n       if ((final_exponent + 16 < 0)\n \t  || (exponent_z + digits_z > 33 + final_exponent)) {\n-#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-  #ifndef IEEE_ROUND_NEAREST\n-        res = __bid_normalize (sign_z, exponent_z, coefficient_z,\n-                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-  #else\n-        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n-                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-  #endif\n-#else\n-        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n-                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-#endif\n+\tres =\n+\t  BID_normalize (sign_z, exponent_z, coefficient_z,\n+\t\t\t sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n \tBID_RETURN (res);\n       }\n \n       ez = exponent_z + digits_z - 16;\n       if (ez < 0)\n \tez = 0;\n       scale_z = exponent_z - ez;\n-      coefficient_z *= __bid_power10_table_128[scale_z].w[0];\n+      coefficient_z *= power10_table_128[scale_z].w[0];\n       ey = final_exponent - extra_digits;\n       extra_digits = ez - ey;\n       if (extra_digits > 33) {\n-#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n-  #ifndef IEEE_ROUND_NEAREST\n-\tres = __bid_normalize (sign_z, exponent_z, coefficient_z,\n-                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-  #else\n-        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n-                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-\n-  #endif\n-#else\n-\tres = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n+\tres =\n+\t  BID_normalize (sign_z, exponent_z, coefficient_z,\n \t\t\t sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n-#endif\n \tBID_RETURN (res);\n       }\n       //else  // extra_digits<=32\n \n       if (extra_digits > 17) {\n \tCYh = __truncate (P, 16);\n \t// get remainder\n-\tT = __bid_power10_table_128[16].w[0];\n+\tT = power10_table_128[16].w[0];\n \t__mul_64x64_to_64 (CY0L, CYh, T);\n \tremainder_y = P.w[0] - CY0L;\n \n@@ -512,12 +394,12 @@ __bid64_fma (UINT64 x, UINT64 y,\n \n       // align coeff_x, CYh\n       __mul_64x64_to_128 (CZ, coefficient_z,\n-\t\t\t  __bid_power10_table_128[extra_digits].w[0]);\n+\t\t\t  power10_table_128[extra_digits].w[0]);\n \n       if (sign_z == (sign_y ^ sign_x)) {\n \t__add_128_128 (CT, CZ, P);\n \tif (__unsigned_compare_ge_128\n-\t    (CT, __bid_power10_table_128[16 + extra_digits])) {\n+\t    (CT, power10_table_128[16 + extra_digits])) {\n \t  extra_digits++;\n \t  ez++;\n \t}\n@@ -534,11 +416,12 @@ __bid64_fma (UINT64 x, UINT64 y,\n \t  CT.w[1] = 0 - CT.w[1];\n \t  if (CT.w[0])\n \t    CT.w[1]--;\n-\t}\n+\t} else if(!(CT.w[1]|CT.w[0]))\n+\t\tsign_z = (rnd_mode!=ROUNDING_DOWN)? 0: 0x8000000000000000ull;\n \tif (ez\n \t    &&\n \t    (__unsigned_compare_gt_128\n-\t     (__bid_power10_table_128[15 + extra_digits], CT))) {\n+\t     (power10_table_128[15 + extra_digits], CT))) {\n \t  extra_digits--;\n \t  ez--;\n \t}\n@@ -548,13 +431,13 @@ __bid64_fma (UINT64 x, UINT64 y,\n       uf_status = 0;\n       if ((!ez)\n \t  &&\n-\t  __unsigned_compare_gt_128 (__bid_power10_table_128\n+\t  __unsigned_compare_gt_128 (power10_table_128\n \t\t\t\t     [extra_digits + 15], CT)) {\n \trmode = rnd_mode;\n \tif (sign_z && (unsigned) (rmode - 1) < 2)\n \t  rmode = 3 - rmode;\n-\t//__add_128_64(PU, CT, __bid_round_const_table[rmode][extra_digits]);\n-\tPU = __bid_power10_table_128[extra_digits + 15];\n+\t//__add_128_64(PU, CT, round_const_table[rmode][extra_digits]);\n+\tPU = power10_table_128[extra_digits + 15];\n \tPU.w[0]--;\n \tif (__unsigned_compare_gt_128 (PU, CT)\n \t    || (rmode == ROUNDING_DOWN)\n@@ -566,22 +449,22 @@ __bid64_fma (UINT64 x, UINT64 y,\n \t      uf_status = UNDERFLOW_EXCEPTION;\n \t    else {\n \t      if (remainder_y && (sign_z != (sign_y ^ sign_x)))\n-\t\tremainder_y = __bid_power10_table_128[16].w[0] - remainder_y;\n+\t\tremainder_y = power10_table_128[16].w[0] - remainder_y;\n \n-\t      if (__bid_power10_table_128[15].w[0] > remainder_y)\n+\t      if (power10_table_128[15].w[0] > remainder_y)\n \t\tuf_status = UNDERFLOW_EXCEPTION;\n \t    }\n \t  } else\t// RN or RN_away\n \t  {\n \t    if (remainder_y && (sign_z != (sign_y ^ sign_x)))\n-\t      remainder_y = __bid_power10_table_128[16].w[0] - remainder_y;\n+\t      remainder_y = power10_table_128[16].w[0] - remainder_y;\n \n \t    if (!extra_digits) {\n-\t      remainder_y += __bid_round_const_table[rmode][15];\n-\t      if (remainder_y < __bid_power10_table_128[16].w[0])\n+\t      remainder_y += round_const_table[rmode][15];\n+\t      if (remainder_y < power10_table_128[16].w[0])\n \t\tuf_status = UNDERFLOW_EXCEPTION;\n \t    } else {\n-\t      if (remainder_y < __bid_round_const_table[rmode][16])\n+\t      if (remainder_y < round_const_table[rmode][16])\n \t\tuf_status = UNDERFLOW_EXCEPTION;\n \t    }\n \t  }\n@@ -619,8 +502,9 @@ __bid64_fma (UINT64 x, UINT64 y,\n     C64 = __low_64 (P);\n \n     res =\n-      get_add64 (sign_z, exponent_z, coefficient_z, sign_x ^ sign_y,\n-\t\t exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS, C64,\n+      get_add64 (sign_x ^ sign_y,\n+\t\t exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS, C64, \n+\t\t sign_z, exponent_z, coefficient_z, \n \t\t rnd_mode, pfpsf);\n     BID_RETURN (res);\n   }"}, {"sha": "b0f1fd15c3d06a6dd3caad46dd4c7b12db550b5e", "filename": "libgcc/config/libbid/bid64_logb.c", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -34,67 +34,40 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_logb (UINT64 * pres,\n-\t    UINT64 *\n-\t    px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t    _EXC_INFO_PARAM) {\n+bid64_logb (int * pres, UINT64 * px\n+\t    _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x;\n #else\n \n-UINT64\n-__bid64_logb (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n-\t    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+int\n+bid64_logb (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n-  UINT64 sign_x, coefficient_x, res;\n-  UINT64 logb_coeff, logb_sign;\n-  SINT32 sign_e;\n-  int exponent_x;\n+  UINT64 sign_x, coefficient_x;\n+  int_double dx;\n+  int exponent_x, bin_expon_cx, digits;\n \n #if DECIMAL_CALL_BY_REFERENCE\n-#if !DECIMAL_GLOBAL_ROUNDING\n-  _IDEC_round rnd_mode = *prnd_mode;\n-#endif\n   x = *px;\n #endif\n-\n   // unpack arguments, check for NaN or Infinity\n   if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n     // x is Inf. or NaN\n-\n-    // test if x is NaN\n-    if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n-      res = x;\n-      BID_RETURN (res);\n-    }\n-    // x is Infinity?\n-    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      res = 0x7800000000000000ull;\n-      BID_RETURN (res);\n-    }\n-    // x is 0\n-    {\n #ifdef SET_STATUS_FLAGS\n-      __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = 0xf800000000000000ull;\n-      BID_RETURN (res);\n-    }\n+      BID_RETURN (0x80000000);\n   }\n+  // find number of digits in coefficient\n+  if (coefficient_x >= 1000000000000000ull) {\n+    digits = 16;\n+  } else {\n+    dx.d = (double)coefficient_x;   // exact conversion;\n+    bin_expon_cx = (int)(dx.i >> 52) - 1023;\n+    digits = estimate_decimal_digits[bin_expon_cx];\n+    if (coefficient_x >= power10_table_128[digits].w[0])\n+      digits++;\n+  }\n+  exponent_x = exponent_x - DECIMAL_EXPONENT_BIAS + digits - 1;\n \n-  exponent_x =\n-    exponent_x - DECIMAL_EXPONENT_BIAS + MAX_FORMAT_DIGITS - 1;\n-\n-  // extract sign and absolute value from exponent_x\n-  sign_e = ((SINT32) exponent_x) >> 31;\n-  exponent_x = (exponent_x + sign_e) ^ sign_e;\n-\n-  logb_coeff = exponent_x;\n-  logb_sign = sign_e & 1;\n-  logb_sign <<= 63;\n-\n-  res =\n-    very_fast_get_BID64_small_mantissa (logb_sign,\n-\t\t\t\t\tDECIMAL_EXPONENT_BIAS,\n-\t\t\t\t\tlogb_coeff);\n-  BID_RETURN (res);\n+  BID_RETURN (exponent_x);\n }"}, {"sha": "1b466bc1ece553669ebbe876f31f43f2d97de0f4", "filename": "libgcc/config/libbid/bid64_minmax.c", "status": "modified", "additions": 289, "deletions": 150, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -42,41 +42,87 @@ static const UINT64 mult_factor[16] = {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_minnum (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+bid64_minnum (UINT64 * pres, UINT64 * px, UINT64 * py _EXC_FLAGS_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_minnum (UINT64 x, UINT64 y) {\n+bid64_minnum (UINT64 x, UINT64 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT64 res;\n   int exp_x, exp_y;\n   UINT64 sig_x, sig_y;\n   UINT128 sig_n_prime;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+  char x_is_zero = 0, y_is_zero = 0;\n \n-  // NaN (CASE1)\n-  // if x is NAN, then return y\n-  if ((x & MASK_NAN) == MASK_NAN) {\n-    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  // check for non-canonical x\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NaN\n+    x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n     }\n-    // check if y is SNaN\n-    if ((y & MASK_SNAN) == MASK_SNAN) {\n-      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN \n-      // return quiet (SNaN) \n-      ; // y = y & 0xfdffffffffffffffull;\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    x = x & (MASK_SIGN | MASK_INF);\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\tx = (x & MASK_SIGN) | ((x & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical \n+  }\n+\n+  // check for non-canonical y\n+  if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN\n+    y = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((y & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      y = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n     }\n-    res = y;\n-    BID_RETURN (res);\n+  } else if ((y & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    y = y & (MASK_SIGN | MASK_INF);\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((y & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\ty = (y & MASK_SIGN) | ((y & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical\n   }\n-  // if y is NAN, then return x\n-  else if ((y & MASK_NAN) == MASK_NAN) {\n-    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x = x & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n+    }\n+    BID_RETURN (res);\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y = y & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -107,30 +153,18 @@ __bid64_minnum (UINT64 x, UINT64 y) {\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n   } else {\n     exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n     sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n   }\n \n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n     sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n   } else {\n     exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n     sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n   }\n \n   // ZERO (CASE4)\n@@ -140,10 +174,10 @@ __bid64_minnum (UINT64 x, UINT64 y) {\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n+  if (sig_x == 0) {\n     x_is_zero = 1;\n   }\n-  if (non_canon_y || sig_y == 0) {\n+  if (sig_y == 0) {\n     y_is_zero = 1;\n   }\n \n@@ -180,7 +214,7 @@ __bid64_minnum (UINT64 x, UINT64 y) {\n   }\n   // if exp_x is 15 greater than exp_y, no need for compensation\n   if (exp_x - exp_y > 15) {\n-    res = ((x & MASK_SIGN) != MASK_SIGN) ? y : x; // difference cannot be >10^15\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? y : x;\t// difference cannot be >10^15\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 less than exp_y, no need for compensation\n@@ -189,7 +223,7 @@ __bid64_minnum (UINT64 x, UINT64 y) {\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n \n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n@@ -227,40 +261,87 @@ __bid64_minnum (UINT64 x, UINT64 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_minnum_mag (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+bid64_minnum_mag (UINT64 * pres, UINT64 * px,\n+\t\t  UINT64 * py _EXC_FLAGS_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_minnum_mag (UINT64 x, UINT64 y) {\n+bid64_minnum_mag (UINT64 x, UINT64 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT64 res;\n   int exp_x, exp_y;\n   UINT64 sig_x, sig_y;\n   UINT128 sig_n_prime;\n-  char non_canon_x, non_canon_y;\n \n-  // NaN (CASE1)\n-  if ((x & MASK_NAN) == MASK_NAN) {\n-    // if x is NAN, then return y\n-    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  // check for non-canonical x\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NaN\n+    x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n     }\n-    // check if y is SNaN\n-    if ((y & MASK_SNAN) == MASK_SNAN) {\n-      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n-      // return quiet (SNaN)\n-      ; // y = y & 0xfdffffffffffffffull;\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    x = x & (MASK_SIGN | MASK_INF);\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\tx = (x & MASK_SIGN) | ((x & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical \n+  }\n+\n+  // check for non-canonical y\n+  if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN\n+    y = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((y & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      y = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    y = y & (MASK_SIGN | MASK_INF);\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((y & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\ty = (y & MASK_SIGN) | ((y & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x = x & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y & MASK_NAN) == MASK_NAN) {\n-    // if y is NAN, then return x\n-    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y = y & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -285,30 +366,18 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n   } else {\n     exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n     sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n   }\n \n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n     sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n   } else {\n     exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n     sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n   }\n \n   // ZERO (CASE4)\n@@ -318,12 +387,12 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n-    res = x; // x_is_zero, its magnitude must be smaller than y\n+  if (sig_x == 0) {\n+    res = x;\t// x_is_zero, its magnitude must be smaller than y\n     BID_RETURN (res);\n   }\n-  if (non_canon_y || sig_y == 0) {\n-    res = y; // y_is_zero, its magnitude must be smaller than x\n+  if (sig_y == 0) {\n+    res = y;\t// y_is_zero, its magnitude must be smaller than x\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n@@ -339,7 +408,7 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n   }\n   // if exp_x is 15 greater than exp_y, no need for compensation\n   if (exp_x - exp_y > 15) {\n-    res = y; // difference cannot be greater than 10^15\n+    res = y;\t// difference cannot be greater than 10^15\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 less than exp_y, no need for compensation\n@@ -348,7 +417,7 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -369,8 +438,8 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n \t\t\t  mult_factor[exp_y - exp_x]);\n \n   if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n-    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x; \n-        // two numbers are equal, return either\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    // two numbers are equal, return either\n     BID_RETURN (res);\n   }\n \n@@ -384,40 +453,87 @@ __bid64_minnum_mag (UINT64 x, UINT64 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_maxnum (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+bid64_maxnum (UINT64 * pres, UINT64 * px, UINT64 * py _EXC_FLAGS_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_maxnum (UINT64 x, UINT64 y) {\n+bid64_maxnum (UINT64 x, UINT64 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT64 res;\n   int exp_x, exp_y;\n   UINT64 sig_x, sig_y;\n   UINT128 sig_n_prime;\n-  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+  char x_is_zero = 0, y_is_zero = 0;\n \n-  // NaN (CASE1)\n-  if ((x & MASK_NAN) == MASK_NAN) {\n-    // if x is NAN, then return y\n-    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  // check for non-canonical x\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NaN\n+    x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n     }\n-    // check if y is SNaN\n-    if ((y & MASK_SNAN) == MASK_SNAN) {\n-      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n-      // return quiet (SNaN)\n-      ; // y = y & 0xfdffffffffffffffull;\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    x = x & (MASK_SIGN | MASK_INF);\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\tx = (x & MASK_SIGN) | ((x & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical \n+  }\n+\n+  // check for non-canonical y\n+  if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN\n+    y = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((y & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      y = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    y = y & (MASK_SIGN | MASK_INF);\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((y & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\ty = (y & MASK_SIGN) | ((y & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x = x & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y & MASK_NAN) == MASK_NAN) {\n-    // if y is NAN, then return x\n-    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y = y & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -449,30 +565,18 @@ __bid64_maxnum (UINT64 x, UINT64 y) {\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n   } else {\n     exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n     sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n   }\n \n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n     sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n   } else {\n     exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n     sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n   }\n \n   // ZERO (CASE4)\n@@ -482,10 +586,10 @@ __bid64_maxnum (UINT64 x, UINT64 y) {\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n+  if (sig_x == 0) {\n     x_is_zero = 1;\n   }\n-  if (non_canon_y || sig_y == 0) {\n+  if (sig_y == 0) {\n     y_is_zero = 1;\n   }\n \n@@ -522,8 +626,8 @@ __bid64_maxnum (UINT64 x, UINT64 y) {\n   }\n   // if exp_x is 15 greater than exp_y, no need for compensation\n   if (exp_x - exp_y > 15) {\n-    res = ((x & MASK_SIGN) != MASK_SIGN) ? x : y; \n-        // difference cannot be > 10^15\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? x : y;\n+    // difference cannot be > 10^15\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 less than exp_y, no need for compensation\n@@ -532,7 +636,7 @@ __bid64_maxnum (UINT64 x, UINT64 y) {\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -568,40 +672,87 @@ __bid64_maxnum (UINT64 x, UINT64 y) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_maxnum_mag (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+bid64_maxnum_mag (UINT64 * pres, UINT64 * px,\n+\t\t  UINT64 * py _EXC_FLAGS_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_maxnum_mag (UINT64 x, UINT64 y) {\n+bid64_maxnum_mag (UINT64 x, UINT64 y _EXC_FLAGS_PARAM) {\n #endif\n \n   UINT64 res;\n   int exp_x, exp_y;\n   UINT64 sig_x, sig_y;\n   UINT128 sig_n_prime;\n-  char non_canon_x, non_canon_y;\n \n-  // NaN (CASE1)\n-  if ((x & MASK_NAN) == MASK_NAN) {\n-    // if x is NAN, then return y\n-    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  // check for non-canonical x\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NaN\n+    x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n     }\n-    // check if y is SNaN\n-    if ((y & MASK_SNAN) == MASK_SNAN) {\n-      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n-      // return quiet (SNaN)\n-      ; // y = y & 0xfdffffffffffffffull;\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    x = x & (MASK_SIGN | MASK_INF);\n+  } else {\t// x is not special\n+    // check for non-canonical values - treated as zero\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\tx = (x & MASK_SIGN) | ((x & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical \n+  }\n+\n+  // check for non-canonical y\n+  if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN\n+    y = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((y & 0x0003ffffffffffffull) > 999999999999999ull) {\n+      y = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    y = y & (MASK_SIGN | MASK_INF);\n+  } else {\t// y is not special\n+    // check for non-canonical values - treated as zero\n+    if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11, then the exponent is G[0:w+1]\n+      if (((y & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\ty = (y & MASK_SIGN) | ((y & MASK_BINARY_EXPONENT2) << 2);\n+      }\t// else canonical\n+    }\t// else canonical\n+  }\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNaN\n+      // if x is SNAN, then return quiet (x)\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      x = x & 0xfdffffffffffffffull;\t// quietize x\n+      res = x;\n+    } else {\t// x is QNaN\n+      if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n+\t  *pfpsf |= INVALID_EXCEPTION;\t// set invalid flag\n+\t}\n+\tres = x;\n+      } else {\n+\tres = y;\n+      }\n     }\n-    res = y;\n     BID_RETURN (res);\n-  } else if ((y & MASK_NAN) == MASK_NAN) {\n-    // if y is NAN, then return x\n-    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n-      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\t// y is NaN, but x is not\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      *pfpsf |= INVALID_EXCEPTION;\t// set exception if SNaN\n+      y = y & 0xfdffffffffffffffull;\t// quietize y\n+      res = y;\n+    } else {\n+      // will return x (which is not NaN)\n+      res = x;\n     }\n-    res = x;\n     BID_RETURN (res);\n   }\n   // SIMPLE (CASE2)\n@@ -626,30 +777,18 @@ __bid64_maxnum_mag (UINT64 x, UINT64 y) {\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_x > 9999999999999999ull) {\n-      non_canon_x = 1;\n-    } else {\n-      non_canon_x = 0;\n-    }\n   } else {\n     exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n     sig_x = (x & MASK_BINARY_SIG1);\n-    non_canon_x = 0;\n   }\n \n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n     exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n     sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (sig_y > 9999999999999999ull) {\n-      non_canon_y = 1;\n-    } else {\n-      non_canon_y = 0;\n-    }\n   } else {\n     exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n     sig_y = (y & MASK_BINARY_SIG1);\n-    non_canon_y = 0;\n   }\n \n   // ZERO (CASE4)\n@@ -659,12 +798,12 @@ __bid64_maxnum_mag (UINT64 x, UINT64 y) {\n   //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n   //        ignore the exponent field\n   //    (Any non-canonical # is considered 0)\n-  if (non_canon_x || sig_x == 0) {\n-    res = y; // x_is_zero, its magnitude must be smaller than y\n+  if (sig_x == 0) {\n+    res = y;\t// x_is_zero, its magnitude must be smaller than y\n     BID_RETURN (res);\n   }\n-  if (non_canon_y || sig_y == 0) {\n-    res = x; // y_is_zero, its magnitude must be smaller than x\n+  if (sig_y == 0) {\n+    res = x;\t// y_is_zero, its magnitude must be smaller than x\n     BID_RETURN (res);\n   }\n   // REDUNDANT REPRESENTATIONS (CASE6)\n@@ -680,7 +819,7 @@ __bid64_maxnum_mag (UINT64 x, UINT64 y) {\n   }\n   // if exp_x is 15 greater than exp_y, no need for compensation\n   if (exp_x - exp_y > 15) {\n-    res = x; // difference cannot be greater than 10^15\n+    res = x;\t// difference cannot be greater than 10^15\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 less than exp_y, no need for compensation\n@@ -689,7 +828,7 @@ __bid64_maxnum_mag (UINT64 x, UINT64 y) {\n     BID_RETURN (res);\n   }\n   // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n-  if (exp_x > exp_y) { // to simplify the loop below,\n+  if (exp_x > exp_y) {\t// to simplify the loop below,\n     // otherwise adjust the x significand upwards\n     __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n \t\t\t    mult_factor[exp_x - exp_y]);\n@@ -710,8 +849,8 @@ __bid64_maxnum_mag (UINT64 x, UINT64 y) {\n \t\t\t  mult_factor[exp_y - exp_x]);\n \n   if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n-    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y; \n-        // two numbers are equal, return either\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    // two numbers are equal, return either\n     BID_RETURN (res);\n   }\n "}, {"sha": "5dc71aed071476c73a10ff4642db9d0435ff70e8", "filename": "libgcc/config/libbid/bid64_mul.c", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -50,15 +50,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_mul (UINT64 * pres, UINT64 * px,\n+bid64_mul (UINT64 * pres, UINT64 * px,\n \t   UINT64 *\n \t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t   _EXC_INFO_PARAM) {\n   UINT64 x, y;\n #else\n \n UINT64\n-__bid64_mul (UINT64 x,\n+bid64_mul (UINT64 x,\n \t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n@@ -67,7 +67,7 @@ __bid64_mul (UINT64 x,\n   UINT64 C64, remainder_h, carry, CY, res;\n   UINT64 valid_x, valid_y;\n   int_double tempx, tempy;\n-  int extra_digits, exponent_x = 0, exponent_y = 0, bin_expon_cx, bin_expon_cy,\n+  int extra_digits, exponent_x, exponent_y, bin_expon_cx, bin_expon_cy,\n     bin_expon_product;\n   int rmode, digits_p, bp, amount, amount2, final_exponent, round_up;\n   unsigned status, uf_status;\n@@ -98,13 +98,13 @@ __bid64_mul (UINT64 x,\n       if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      BID_RETURN (x & QUIET_MASK64);\n+      BID_RETURN (coefficient_x & QUIET_MASK64);\n     }\n     // x is Infinity?\n     if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n       // check if y is 0\n-      if (((y & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n-\t  && !(y << (64 - 53))) {\n+      if (((y & INFINITY_MASK64) != INFINITY_MASK64)\n+\t  && !coefficient_y) {\n #ifdef SET_STATUS_FLAGS\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n@@ -114,7 +114,7 @@ __bid64_mul (UINT64 x,\n       // check if y is NaN\n       if ((y & NAN_MASK64) == NAN_MASK64)\n \t// y==NaN , return NaN\n-\tBID_RETURN (y & QUIET_MASK64);\n+\tBID_RETURN (coefficient_y & QUIET_MASK64);\n       // otherwise return +/-Inf\n       BID_RETURN (((x ^ y) & 0x8000000000000000ull) | INFINITY_MASK64);\n     }\n@@ -143,13 +143,12 @@ __bid64_mul (UINT64 x,\n       if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      BID_RETURN (y & QUIET_MASK64);\n+      BID_RETURN (coefficient_y & QUIET_MASK64);\n     }\n     // y is Infinity?\n     if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n       // check if x is 0\n-      if (((x & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n-\t  && !(x << (64 - 53))) {\n+      if (!coefficient_x) {\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n \t// x==0, return NaN\n \tBID_RETURN (NAN_MASK64);\n@@ -200,9 +199,9 @@ __bid64_mul (UINT64 x,\n     __tight_bin_range_128 (bp, P, bin_expon_product);\n \n     // get number of decimal digits in the product\n-    digits_p = __bid_estimate_decimal_digits[bp];\n-    if (!(__unsigned_compare_gt_128 (__bid_power10_table_128[digits_p], P)))\n-      digits_p++;\t// if __bid_power10_table_128[digits_p] <= P\n+    digits_p = estimate_decimal_digits[bp];\n+    if (!(__unsigned_compare_gt_128 (power10_table_128[digits_p], P)))\n+      digits_p++;\t// if power10_table_128[digits_p] <= P\n \n     // determine number of decimal digits to be rounded out\n     extra_digits = digits_p - MAX_FORMAT_DIGITS;\n@@ -236,18 +235,18 @@ __bid64_mul (UINT64 x,\n \n \tuf_status = UNDERFLOW_EXCEPTION;\n \tif (final_exponent == -1) {\n-\t  __add_128_64 (PU, P, __bid_round_const_table[rmode][extra_digits]);\n+\t  __add_128_64 (PU, P, round_const_table[rmode][extra_digits]);\n \t  if (__unsigned_compare_ge_128\n-\t      (PU, __bid_power10_table_128[extra_digits + 16]))\n+\t      (PU, power10_table_128[extra_digits + 16]))\n \t    uf_status = 0;\n \t}\n \textra_digits -= final_exponent;\n \tfinal_exponent = 0;\n \n \tif (extra_digits > 17) {\n-\t  __mul_128x128_full (Q_high, Q_low, P, __bid_reciprocals10_128[16]);\n+\t  __mul_128x128_full (Q_high, Q_low, P, reciprocals10_128[16]);\n \n-\t  amount = __bid_recip_scale[16];\n+\t  amount = recip_scale[16];\n \t  __shr_128 (P, Q_high, amount);\n \n \t  // get sticky bits\n@@ -258,11 +257,11 @@ __bid64_mul (UINT64 x,\n \t  remainder_h = remainder_h & Q_high.w[0];\n \n \t  extra_digits -= 16;\n-\t  if (remainder_h || (Q_low.w[1] > __bid_reciprocals10_128[16].w[1]\n+\t  if (remainder_h || (Q_low.w[1] > reciprocals10_128[16].w[1]\n \t\t\t      || (Q_low.w[1] ==\n-\t\t\t\t  __bid_reciprocals10_128[16].w[1]\n+\t\t\t\t  reciprocals10_128[16].w[1]\n \t\t\t\t  && Q_low.w[0] >=\n-\t\t\t\t  __bid_reciprocals10_128[16].w[0]))) {\n+\t\t\t\t  reciprocals10_128[16].w[0]))) {\n \t    round_up = 1;\n \t    __set_status_flags (pfpsf,\n \t\t\t\tUNDERFLOW_EXCEPTION |\n@@ -287,14 +286,14 @@ __bid64_mul (UINT64 x,\n \n       // add a constant to P, depending on rounding mode\n       // 0.5*10^(digits_p - 16) for round-to-nearest\n-      __add_128_64 (P, P, __bid_round_const_table[rmode][extra_digits]);\n+      __add_128_64 (P, P, round_const_table[rmode][extra_digits]);\n \n       // get P*(2^M[extra_digits])/10^extra_digits\n       __mul_128x128_full (Q_high, Q_low, P,\n-\t\t\t  __bid_reciprocals10_128[extra_digits]);\n+\t\t\t  reciprocals10_128[extra_digits]);\n \n       // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n-      amount = __bid_recip_scale[extra_digits];\n+      amount = recip_scale[extra_digits];\n       __shr_128 (C128, Q_high, amount);\n \n       C64 = __low_64 (C128);\n@@ -305,7 +304,7 @@ __bid64_mul (UINT64 x,\n #endif\n \tif ((C64 & 1) && !round_up) {\n \t  // check whether fractional part of initial_P/10^extra_digits \n-          // is exactly .5\n+\t  // is exactly .5\n \t  // this is the same as fractional part of \n \t  // (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n \n@@ -314,10 +313,10 @@ __bid64_mul (UINT64 x,\n \n \t  // test whether fractional part is 0\n \t  if (!remainder_h\n-\t      && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t  || (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t      && (Q_low.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t  || (Q_low.w[1] == reciprocals10_128[extra_digits].w[1]\n \t\t      && Q_low.w[0] <\n-\t\t      __bid_reciprocals10_128[extra_digits].w[0]))) {\n+\t\t      reciprocals10_128[extra_digits].w[0]))) {\n \t    C64--;\n \t  }\n \t}\n@@ -334,27 +333,27 @@ __bid64_mul (UINT64 x,\n       case ROUNDING_TIES_AWAY:\n \t// test whether fractional part is 0\n \tif (remainder_h == 0x8000000000000000ull\n-\t    && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t|| (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t    && (Q_low.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Q_low.w[1] == reciprocals10_128[extra_digits].w[1]\n \t\t    && Q_low.w[0] <\n-\t\t    __bid_reciprocals10_128[extra_digits].w[0])))\n+\t\t    reciprocals10_128[extra_digits].w[0])))\n \t  status = EXACT_STATUS;\n \tbreak;\n       case ROUNDING_DOWN:\n       case ROUNDING_TO_ZERO:\n \tif (!remainder_h\n-\t    && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n-\t\t|| (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t    && (Q_low.w[1] < reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Q_low.w[1] == reciprocals10_128[extra_digits].w[1]\n \t\t    && Q_low.w[0] <\n-\t\t    __bid_reciprocals10_128[extra_digits].w[0])))\n+\t\t    reciprocals10_128[extra_digits].w[0])))\n \t  status = EXACT_STATUS;\n \tbreak;\n       default:\n \t// round up\n \t__add_carry_out (Stemp.w[0], CY, Q_low.w[0],\n-\t\t\t __bid_reciprocals10_128[extra_digits].w[0]);\n+\t\t\t reciprocals10_128[extra_digits].w[0]);\n \t__add_carry_in_out (Stemp.w[1], carry, Q_low.w[1],\n-\t\t\t    __bid_reciprocals10_128[extra_digits].w[1], CY);\n+\t\t\t    reciprocals10_128[extra_digits].w[1], CY);\n \tif ((remainder_h >> (64 - amount)) + carry >=\n \t    (((UINT64) 1) << amount))\n \t  status = EXACT_STATUS;"}, {"sha": "158121e788adf8bf95d5a06f5cc7f5ab3f3d6aa8", "filename": "libgcc/config/libbid/bid64_next.c", "status": "modified", "additions": 177, "deletions": 137, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -34,13 +34,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_nextup (UINT64 * pres,\n+bid64_nextup (UINT64 * pres,\n \t      UINT64 *\n \t      px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n UINT64\n-__bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t      _EXC_INFO_PARAM) {\n #endif\n \n@@ -50,107 +50,112 @@ __bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n   BID_UI64DOUBLE tmp1;\n   int x_nr_bits;\n   int q1, ind;\n-  UINT64 C1; \t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+  UINT64 C1;\t\t\t// C1 represents x_signif (UINT64)\n \n   // check for NaNs and infinities\n-  if ((x & MASK_SNAN) == MASK_SNAN) { // check for SNaN\n-    // set invalid flag\n-    *pfpsf |= INVALID_EXCEPTION;\n-    // return quiet (SNaN)\n-    res = x & 0xfdffffffffffffffull;\n-    BID_RETURN (res);\n-  } else if ((x & MASK_NAN) == MASK_NAN) { // check for QNaN\n-    res = x;\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// check for NaN\n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull)\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+    else\n+      x = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// SNaN\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    } else {\t// QNaN\n+      res = x;\n+    }\n     BID_RETURN (res);\n-  } else if ((x & MASK_INF) == MASK_INF) { // check for Infinity\n-    if (!(x & 0x8000000000000000ull)) { // x is +inf\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    if (!(x & 0x8000000000000000ull)) {\t// x is +inf\n       res = 0x7800000000000000ull;\n-    } else { // x is -inf\n-      res = 0xf7fb86f26fc0ffffull; // -MAXFP = -999...99 * 10^emax\n+    } else {\t// x is -inf\n+      res = 0xf7fb86f26fc0ffffull;\t// -MAXFP = -999...99 * 10^emax\n     }\n     BID_RETURN (res);\n   }\n   // unpack the argument\n-  x_sign = x & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51; // biased\n+    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51;\t// biased\n     C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (C1 > 9999999999999999ull) { // non-canonical\n+    if (C1 > 9999999999999999ull) {\t// non-canonical\n       x_exp = 0;\n       C1 = 0;\n     }\n   } else {\n-    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53; // biased\n+    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53;\t// biased\n     C1 = x & MASK_BINARY_SIG1;\n   }\n \n   // check for zeros (possibly from non-canonical values)\n   if (C1 == 0x0ull) {\n     // x is 0\n-    res = 0x0000000000000001ull; // MINFP = 1 * 10^emin\n-  } else { // x is not special and is not zero\n+    res = 0x0000000000000001ull;\t// MINFP = 1 * 10^emin\n+  } else {\t// x is not special and is not zero\n     if (x == 0x77fb86f26fc0ffffull) {\n       // x = +MAXFP = 999...99 * 10^emax\n-      res = 0x7800000000000000ull; // +inf\n+      res = 0x7800000000000000ull;\t// +inf\n     } else if (x == 0x8000000000000001ull) {\n       // x = -MINFP = 1...99 * 10^emin\n-      res = 0x8000000000000000ull; // -0\n-    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+      res = 0x8000000000000000ull;\t// -0\n+    } else {\t// -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n       // can add/subtract 1 ulp to the significand\n \n       // Note: we could check here if x >= 10^16 to speed up the case q1 =16 \n       // q1 = nr. of decimal digits in x (1 <= q1 <= 54)\n       //  determine first the nr. of bits in x\n-      if (C1 >= MASK_BINARY_OR2) { // x >= 2^53\n+      if (C1 >= MASK_BINARY_OR2) {\t// x >= 2^53\n \t// split the 64-bit value in two 32-bit halves to avoid rounding errors\n-\tif (C1 >= 0x0000000100000000ull) { // x >= 2^32\n-\t  tmp1.d = (double) (C1 >> 32); // exact conversion\n+\tif (C1 >= 0x0000000100000000ull) {\t// x >= 2^32\n+\t  tmp1.d = (double) (C1 >> 32);\t// exact conversion\n \t  x_nr_bits =\n \t    33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-\t} else { // x < 2^32\n-\t  tmp1.d = (double) C1; // exact conversion\n+\t} else {\t// x < 2^32\n+\t  tmp1.d = (double) C1;\t// exact conversion\n \t  x_nr_bits =\n \t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n \t}\n-      } else { // if x < 2^53\n-\ttmp1.d = (double) C1; // exact conversion\n+      } else {\t// if x < 2^53\n+\ttmp1.d = (double) C1;\t// exact conversion\n \tx_nr_bits =\n \t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      q1 = nr_digits[x_nr_bits - 1].digits;\n       if (q1 == 0) {\n-\tq1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n-\tif (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq1 = nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1 >= nr_digits[x_nr_bits - 1].threshold_lo)\n \t  q1++;\n       }\n       // if q1 < P16 then pad the significand with zeros\n       if (q1 < P16) {\n-\tif ((SINT64)x_exp > P16 - q1) {\n-\t  ind = P16 - q1; // 1 <= ind <= P16 - 1\n+\tif (x_exp > (UINT64) (P16 - q1)) {\n+\t  ind = P16 - q1;\t// 1 <= ind <= P16 - 1\n \t  // pad with P16 - q1 zeros, until exponent = emin\n \t  // C1 = C1 * 10^ind\n-\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  C1 = C1 * ten2k64[ind];\n \t  x_exp = x_exp - ind;\n-\t} else { // pad with zeros until the exponent reaches emin\n+\t} else {\t// pad with zeros until the exponent reaches emin\n \t  ind = x_exp;\n-\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  C1 = C1 * ten2k64[ind];\n \t  x_exp = EXP_MIN;\n \t}\n       }\n-      if (!x_sign) { // x > 0\n+      if (!x_sign) {\t// x > 0\n \t// add 1 ulp (add 1 to the significand)\n \tC1++;\n-\tif (C1 == 0x002386f26fc10000ull) { // if  C1 = 10^16\n-\t  C1 = 0x00038d7ea4c68000ull; // C1 = 10^15\n+\tif (C1 == 0x002386f26fc10000ull) {\t// if  C1 = 10^16\n+\t  C1 = 0x00038d7ea4c68000ull;\t// C1 = 10^15\n \t  x_exp++;\n \t}\n \t// Ok, because MAXFP = 999...99 * 10^emax was caught already\n-      } else { // x < 0\n+      } else {\t// x < 0\n \t// subtract 1 ulp (subtract 1 from the significand)\n \tC1--;\n-\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) { // if  C1 = 10^15 - 1\n-\t  C1 = 0x002386f26fc0ffffull; // C1 = 10^16 - 1\n+\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) {\t// if  C1 = 10^15 - 1\n+\t  C1 = 0x002386f26fc0ffffull;\t// C1 = 10^16 - 1\n \t  x_exp--;\n \t}\n       }\n@@ -160,11 +165,11 @@ __bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \tres =\n \t  x_sign | (x_exp << 51) | MASK_STEERING_BITS | (C1 &\n \t\t\t\t\t\t\t MASK_BINARY_SIG2);\n-      } else { // significand fits in 53 bits\n+      } else {\t// significand fits in 53 bits\n \tres = x_sign | (x_exp << 53) | C1;\n       }\n-    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n-  } // end x is not special and is not zero\n+    }\t// end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  }\t// end x is not special and is not zero\n   BID_RETURN (res);\n }\n \n@@ -174,13 +179,13 @@ __bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_nextdown (UINT64 * pres,\n+bid64_nextdown (UINT64 * pres,\n \t\tUINT64 *\n \t\tpx _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n UINT64\n-__bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t_EXC_INFO_PARAM) {\n #endif\n \n@@ -190,108 +195,113 @@ __bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n   BID_UI64DOUBLE tmp1;\n   int x_nr_bits;\n   int q1, ind;\n-  UINT64 C1; \t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+  UINT64 C1;\t\t\t// C1 represents x_signif (UINT64)\n \n   // check for NaNs and infinities\n-  if ((x & MASK_SNAN) == MASK_SNAN) { // check for SNaN\n-    // set invalid flag\n-    *pfpsf |= INVALID_EXCEPTION;\n-    // return quiet (SNaN)\n-    res = x & 0xfdffffffffffffffull;\n-    BID_RETURN (res);\n-  } else if ((x & MASK_NAN) == MASK_NAN) { // check for QNaN\n-    res = x;\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// check for NaN \n+    if ((x & 0x0003ffffffffffffull) > 999999999999999ull)\n+      x = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits \n+    else\n+      x = x & 0xfe03ffffffffffffull;\t// clear G6-G12 \n+    if ((x & MASK_SNAN) == MASK_SNAN) {\t// SNaN \n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    } else {\t// QNaN \n+      res = x;\n+    }\n     BID_RETURN (res);\n-  } else if ((x & MASK_INF) == MASK_INF) { // check for Infinity\n-    if (x & 0x8000000000000000ull) { // x is -inf\n+  } else if ((x & MASK_INF) == MASK_INF) {\t// check for Infinity\n+    if (x & 0x8000000000000000ull) {\t// x is -inf\n       res = 0xf800000000000000ull;\n-    } else { // x is +inf\n-      res = 0x77fb86f26fc0ffffull; // +MAXFP = +999...99 * 10^emax\n+    } else {\t// x is +inf\n+      res = 0x77fb86f26fc0ffffull;\t// +MAXFP = +999...99 * 10^emax\n     }\n     BID_RETURN (res);\n   }\n   // unpack the argument\n-  x_sign = x & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n   // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n   if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n-    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51; // biased\n+    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51;\t// biased\n     C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n-    if (C1 > 9999999999999999ull) { // non-canonical\n+    if (C1 > 9999999999999999ull) {\t// non-canonical\n       x_exp = 0;\n       C1 = 0;\n     }\n   } else {\n-    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53; // biased\n+    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53;\t// biased\n     C1 = x & MASK_BINARY_SIG1;\n   }\n \n   // check for zeros (possibly from non-canonical values)\n   if (C1 == 0x0ull) {\n     // x is 0\n-    res = 0x8000000000000001ull; // -MINFP = -1 * 10^emin\n-  } else { // x is not special and is not zero\n+    res = 0x8000000000000001ull;\t// -MINFP = -1 * 10^emin\n+  } else {\t// x is not special and is not zero\n     if (x == 0xf7fb86f26fc0ffffull) {\n       // x = -MAXFP = -999...99 * 10^emax\n-      res = 0xf800000000000000ull; // -inf\n+      res = 0xf800000000000000ull;\t// -inf\n     } else if (x == 0x0000000000000001ull) {\n       // x = +MINFP = 1...99 * 10^emin\n-      res = 0x0000000000000000ull; // -0\n-    } else { // -MAXFP + 1ulp <= x <= -MINFP OR MINFP + 1 ulp <= x <= MAXFP\n+      res = 0x0000000000000000ull;\t// -0\n+    } else {\t// -MAXFP + 1ulp <= x <= -MINFP OR MINFP + 1 ulp <= x <= MAXFP\n       // can add/subtract 1 ulp to the significand\n \n       // Note: we could check here if x >= 10^16 to speed up the case q1 =16 \n       // q1 = nr. of decimal digits in x (1 <= q1 <= 16)\n       //  determine first the nr. of bits in x\n-      if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+      if (C1 >= 0x0020000000000000ull) {\t// x >= 2^53\n \t// split the 64-bit value in two 32-bit halves to avoid \n \t// rounding errors\n-\tif (C1 >= 0x0000000100000000ull) { // x >= 2^32\n-\t  tmp1.d = (double) (C1 >> 32); // exact conversion\n+\tif (C1 >= 0x0000000100000000ull) {\t// x >= 2^32\n+\t  tmp1.d = (double) (C1 >> 32);\t// exact conversion\n \t  x_nr_bits =\n \t    33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n-\t} else { // x < 2^32\n-\t  tmp1.d = (double) C1; // exact conversion\n+\t} else {\t// x < 2^32\n+\t  tmp1.d = (double) C1;\t// exact conversion\n \t  x_nr_bits =\n \t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n \t}\n-      } else { // if x < 2^53\n-\ttmp1.d = (double) C1; // exact conversion\n+      } else {\t// if x < 2^53\n+\ttmp1.d = (double) C1;\t// exact conversion\n \tx_nr_bits =\n \t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n       }\n-      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      q1 = nr_digits[x_nr_bits - 1].digits;\n       if (q1 == 0) {\n-\tq1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n-\tif (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq1 = nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1 >= nr_digits[x_nr_bits - 1].threshold_lo)\n \t  q1++;\n       }\n       // if q1 < P16 then pad the significand with zeros\n       if (q1 < P16) {\n-\tif ((SINT64)x_exp > P16 - q1) {\n-\t  ind = P16 - q1; // 1 <= ind <= P16 - 1\n+\tif (x_exp > (UINT64) (P16 - q1)) {\n+\t  ind = P16 - q1;\t// 1 <= ind <= P16 - 1\n \t  // pad with P16 - q1 zeros, until exponent = emin\n \t  // C1 = C1 * 10^ind\n-\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  C1 = C1 * ten2k64[ind];\n \t  x_exp = x_exp - ind;\n-\t} else { // pad with zeros until the exponent reaches emin\n+\t} else {\t// pad with zeros until the exponent reaches emin\n \t  ind = x_exp;\n-\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  C1 = C1 * ten2k64[ind];\n \t  x_exp = EXP_MIN;\n \t}\n       }\n-      if (x_sign) { // x < 0\n+      if (x_sign) {\t// x < 0\n \t// add 1 ulp (add 1 to the significand)\n \tC1++;\n-\tif (C1 == 0x002386f26fc10000ull) { // if  C1 = 10^16\n-\t  C1 = 0x00038d7ea4c68000ull; // C1 = 10^15\n+\tif (C1 == 0x002386f26fc10000ull) {\t// if  C1 = 10^16\n+\t  C1 = 0x00038d7ea4c68000ull;\t// C1 = 10^15\n \t  x_exp++;\n \t  // Ok, because -MAXFP = -999...99 * 10^emax was caught already\n \t}\n-      } else { // x > 0\n+      } else {\t// x > 0\n \t// subtract 1 ulp (subtract 1 from the significand)\n \tC1--;\n-\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) { // if  C1 = 10^15 - 1\n-\t  C1 = 0x002386f26fc0ffffull; // C1 = 10^16 - 1\n+\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) {\t// if  C1 = 10^15 - 1\n+\t  C1 = 0x002386f26fc0ffffull;\t// C1 = 10^16 - 1\n \t  x_exp--;\n \t}\n       }\n@@ -301,11 +311,11 @@ __bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \tres =\n \t  x_sign | (x_exp << 51) | MASK_STEERING_BITS | (C1 &\n \t\t\t\t\t\t\t MASK_BINARY_SIG2);\n-      } else { // significand fits in 53 bits\n+      } else {\t// significand fits in 53 bits\n \tres = x_sign | (x_exp << 53) | C1;\n       }\n-    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n-  } // end x is not special and is not zero\n+    }\t// end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  }\t// end x is not special and is not zero\n   BID_RETURN (res);\n }\n \n@@ -315,92 +325,122 @@ __bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_nextafter (UINT64 * pres, UINT64 * px,\n+bid64_nextafter (UINT64 * pres, UINT64 * px,\n \t\t UINT64 *\n \t\t py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_nextafter (UINT64 x,\n+bid64_nextafter (UINT64 x,\n \t\t UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t _EXC_INFO_PARAM) {\n #endif\n \n   UINT64 res;\n   UINT64 tmp1, tmp2;\n-  FPSC tmp_fpsf = 0; // dummy fpsf for calls to comparison functions\n+  FPSC tmp_fpsf = 0;\t\t// dummy fpsf for calls to comparison functions\n   int res1, res2;\n \n+  // check for NaNs or infinities\n+  if (((x & MASK_SPECIAL) == MASK_SPECIAL) ||\n+      ((y & MASK_SPECIAL) == MASK_SPECIAL)) {\n+    // x is NaN or infinity or y is NaN or infinity\n \n-  // check for NaNs\n-  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n-    // x is NaN or y is NaN\n-\n-    if ((x & MASK_NAN) == MASK_NAN) { // x is NAN\n-      if ((x & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+    if ((x & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x & 0x0003ffffffffffffull) > 999999999999999ull)\n+\tx = x & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+      else\n+\tx = x & 0xfe03ffffffffffffull;\t// clear G6-G12\n+      if ((x & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n \t// set invalid flag\n \t*pfpsf |= INVALID_EXCEPTION;\n \t// return quiet (x)\n \tres = x & 0xfdffffffffffffffull;\n-\tres = x;\n-      } else { // x is QNaN\n-\tif ((y & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+      } else {\t// x is QNaN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n \t  // set invalid flag\n \t  *pfpsf |= INVALID_EXCEPTION;\n \t}\n \t// return x\n \tres = x;\n       }\n       BID_RETURN (res);\n-    } else if ((y & MASK_NAN) == MASK_NAN) { // y is NAN\n-      if ((y & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+    } else if ((y & MASK_NAN) == MASK_NAN) {\t// y is NAN\n+      if ((y & 0x0003ffffffffffffull) > 999999999999999ull)\n+\ty = y & 0xfe00000000000000ull;\t// clear G6-G12 and the payload bits\n+      else\n+\ty = y & 0xfe03ffffffffffffull;\t// clear G6-G12\n+      if ((y & MASK_SNAN) == MASK_SNAN) {\t// y is SNAN\n \t// set invalid flag\n \t*pfpsf |= INVALID_EXCEPTION;\n \t// return quiet (y)\n \tres = y & 0xfdffffffffffffffull;\n-\tres = y;\n-      } else { // y is QNaN\n+      } else {\t// y is QNaN\n \t// return y\n \tres = y;\n       }\n       BID_RETURN (res);\n-    } else {\n-      ; // let infinities fall through\n+    } else {\t// at least one is infinity\n+      if ((x & MASK_ANY_INF) == MASK_INF) {\t// x = inf\n+\tx = x & (MASK_SIGN | MASK_INF);\n+      }\n+      if ((y & MASK_ANY_INF) == MASK_INF) {\t// y = inf\n+\ty = y & (MASK_SIGN | MASK_INF);\n+      }\n     }\n   }\n   // neither x nor y is NaN\n-  tmp_fpsf = *pfpsf; // save fpsf\n+\n+  // if not infinity, check for non-canonical values x (treated as zero)\n+  if ((x & MASK_ANY_INF) != MASK_INF) {\t// x != inf\n+    // unpack x\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      // if the steering bits are 11 (condition will be 0), then\n+      // the exponent is G[0:w+1]\n+      if (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+\t  9999999999999999ull) {\n+\t// non-canonical\n+\tx = (x & MASK_SIGN) | ((x & MASK_BINARY_EXPONENT2) << 2);\n+      }\n+    } else {\t// if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS) x is unch.\n+      ;\t// canonical\n+    }\n+  }\n+  // no need to check for non-canonical y\n+\n+  // neither x nor y is NaN\n+  tmp_fpsf = *pfpsf;\t// save fpsf\n #if DECIMAL_CALL_BY_REFERENCE\n-  __bid64_quiet_equal (&res1, px,\n+  bid64_quiet_equal (&res1, px,\n \t\t     py _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n-  __bid64_quiet_greater (&res2, px,\n+  bid64_quiet_greater (&res2, px,\n \t\t       py _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #else\n   res1 =\n-    __bid64_quiet_equal (x,\n+    bid64_quiet_equal (x,\n \t\t       y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n   res2 =\n-    __bid64_quiet_greater (x,\n+    bid64_quiet_greater (x,\n \t\t\t y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #endif\n-  *pfpsf = tmp_fpsf; // restore fpsf\n-  if (res1) { // x = y\n+  *pfpsf = tmp_fpsf;\t// restore fpsf\n+  if (res1) {\t// x = y\n     // return x with the sign of y\n-    res = (x & 0x7fffffffffffffffull) | (y & 0x8000000000000000ull);\n-  } else if (res2) { // x > y\n+    res = (y & 0x8000000000000000ull) | (x & 0x7fffffffffffffffull);\n+  } else if (res2) {\t// x > y\n #if DECIMAL_CALL_BY_REFERENCE\n-    __bid64_nextdown (&res,\n+    bid64_nextdown (&res,\n \t\t    px _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #else\n     res =\n-      __bid64_nextdown (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+      bid64_nextdown (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #endif\n-  } else { // x < y\n+  } else {\t// x < y\n #if DECIMAL_CALL_BY_REFERENCE\n-    __bid64_nextup (&res, px _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    bid64_nextup (&res, px _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #else\n-    res = __bid64_nextup (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+    res = bid64_nextup (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n #endif\n   }\n   // if the operand x is finite but the result is infinite, signal\n@@ -413,30 +453,30 @@ __bid64_nextafter (UINT64 x,\n   }\n   // if the result is in (-10^emin, 10^emin), and is different from the\n   // operand x, signal underflow and inexact \n-  tmp1 = 0x00038d7ea4c68000ull; // +100...0[16] * 10^emin\n+  tmp1 = 0x00038d7ea4c68000ull;\t// +100...0[16] * 10^emin\n   tmp2 = res & 0x7fffffffffffffffull;\n-  tmp_fpsf = *pfpsf; // save fpsf\n+  tmp_fpsf = *pfpsf;\t// save fpsf\n #if DECIMAL_CALL_BY_REFERENCE\n-  __bid64_quiet_greater (&res1, &tmp1,\n+  bid64_quiet_greater (&res1, &tmp1,\n \t\t       &tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t       _EXC_INFO_ARG);\n-  __bid64_quiet_not_equal (&res2, &x,\n+  bid64_quiet_not_equal (&res2, &x,\n \t\t\t &res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t\t _EXC_INFO_ARG);\n #else\n   res1 =\n-    __bid64_quiet_greater (tmp1,\n+    bid64_quiet_greater (tmp1,\n \t\t\t tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t\t _EXC_INFO_ARG);\n   res2 =\n-    __bid64_quiet_not_equal (x,\n+    bid64_quiet_not_equal (x,\n \t\t\t   res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n \t\t\t   _EXC_INFO_ARG);\n #endif\n-  *pfpsf = tmp_fpsf; // restore fpsf\n+  *pfpsf = tmp_fpsf;\t// restore fpsf\n   if (res1 && res2) {\n-    // if (__bid64_quiet_greater (tmp1, tmp2, &tmp_fpsf) &&\n-    // __bid64_quiet_not_equal (x, res, &tmp_fpsf)) {\n+    // if (bid64_quiet_greater (tmp1, tmp2, &tmp_fpsf) &&\n+    // bid64_quiet_not_equal (x, res, &tmp_fpsf)) {\n     // set the inexact flag\n     *pfpsf |= INEXACT_EXCEPTION;\n     // set the underflow flag"}, {"sha": "a811c6fa61e2b09af3d75b5f3f00d7286f72f1c7", "filename": "libgcc/config/libbid/bid64_noncomp.c", "status": "modified", "additions": 93, "deletions": 90, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -38,33 +38,33 @@ static const UINT64 mult_factor[16] = {\n \n /*****************************************************************************\n  *    BID64 non-computational functions:\n- *         - __bid64_isSigned\n- *         - __bid64_isNormal\n- *         - __bid64_isSubnormal\n- *         - __bid64_isFinite\n- *         - __bid64_isZero\n- *         - __bid64_isInf\n- *         - __bid64_isSignaling\n- *         - __bid64_isCanonical\n- *         - __bid64_isNaN\n- *         - __bid64_copy\n- *         - __bid64_negate\n- *         - __bid64_abs\n- *         - __bid64_copySign\n- *         - __bid64_class\n- *         - __bid64_sameQuantum\n- *         - __bid64_totalOrder\n- *         - __bid64_totalOrderMag\n- *         - __bid64_radix\n+ *         - bid64_isSigned\n+ *         - bid64_isNormal\n+ *         - bid64_isSubnormal\n+ *         - bid64_isFinite\n+ *         - bid64_isZero\n+ *         - bid64_isInf\n+ *         - bid64_isSignaling\n+ *         - bid64_isCanonical\n+ *         - bid64_isNaN\n+ *         - bid64_copy\n+ *         - bid64_negate\n+ *         - bid64_abs\n+ *         - bid64_copySign\n+ *         - bid64_class\n+ *         - bid64_sameQuantum\n+ *         - bid64_totalOrder\n+ *         - bid64_totalOrderMag\n+ *         - bid64_radix\n  ****************************************************************************/\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isSigned (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isSigned (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isSigned (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isSigned (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -75,33 +75,33 @@ __bid64_isSigned (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // return 1 iff x is not zero, nor NaN nor subnormal nor infinity\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isNormal (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isNormal (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isNormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isNormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT128 sig_x_prime;\n   UINT64 sig_x;\n   unsigned int exp_x;\n \n-  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NaN\n+  if ((x & MASK_INF) == MASK_INF) {\t// x is either INF or NaN\n     res = 0;\n   } else {\n     // decode number into exponent and significand\n     if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n       sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n       // check for zero or non-canonical\n       if (sig_x > 9999999999999999ull || sig_x == 0) {\n-\tres = 0; // zero or non-canonical\n+\tres = 0;\t// zero or non-canonical\n \tBID_RETURN (res);\n       }\n       exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     } else {\n       sig_x = (x & MASK_BINARY_SIG1);\n       if (sig_x == 0) {\n-\tres = 0; // zero\n+\tres = 0;\t// zero\n \tBID_RETURN (res);\n       }\n       exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n@@ -112,12 +112,12 @@ __bid64_isNormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n       __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n       if (sig_x_prime.w[1] == 0\n \t  && sig_x_prime.w[0] < 1000000000000000ull) {\n-\tres = 0; // subnormal\n+\tres = 0;\t// subnormal\n       } else {\n-\tres = 1; // normal\n+\tres = 1;\t// normal\n       }\n     } else {\n-      res = 1; // normal\n+      res = 1;\t// normal\n     }\n   }\n   BID_RETURN (res);\n@@ -126,34 +126,34 @@ __bid64_isNormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // return 1 iff x is not zero, nor NaN nor normal nor infinity\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isSubnormal (int *pres,\n+bid64_isSubnormal (int *pres,\n \t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isSubnormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isSubnormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT128 sig_x_prime;\n   UINT64 sig_x;\n   unsigned int exp_x;\n \n-  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NaN\n+  if ((x & MASK_INF) == MASK_INF) {\t// x is either INF or NaN\n     res = 0;\n   } else {\n     // decode number into exponent and significand\n     if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n       sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n       // check for zero or non-canonical\n       if (sig_x > 9999999999999999ull || sig_x == 0) {\n-\tres = 0; // zero or non-canonical\n+\tres = 0;\t// zero or non-canonical\n \tBID_RETURN (res);\n       }\n       exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n     } else {\n       sig_x = (x & MASK_BINARY_SIG1);\n       if (sig_x == 0) {\n-\tres = 0; // zero\n+\tres = 0;\t// zero\n \tBID_RETURN (res);\n       }\n       exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n@@ -164,12 +164,12 @@ __bid64_isSubnormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n       __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n       if (sig_x_prime.w[1] == 0\n \t  && sig_x_prime.w[0] < 1000000000000000ull) {\n-\tres = 1; // subnormal\n+\tres = 1;\t// subnormal\n       } else {\n-\tres = 0; // normal\n+\tres = 0;\t// normal\n       }\n     } else {\n-      res = 0; // normal\n+      res = 0;\t// normal\n     }\n   }\n   BID_RETURN (res);\n@@ -178,11 +178,11 @@ __bid64_isSubnormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n //iff x is zero, subnormal or normal (not infinity or NaN)\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isFinite (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isFinite (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isFinite (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isFinite (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -192,11 +192,11 @@ __bid64_isFinite (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isZero (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isZero (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isZero (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isZero (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -218,11 +218,11 @@ __bid64_isZero (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isInf (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isInf (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isInf (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isInf (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -232,12 +232,12 @@ __bid64_isInf (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isSignaling (int *pres,\n+bid64_isSignaling (int *pres,\n \t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isSignaling (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isSignaling (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -247,19 +247,19 @@ __bid64_isSignaling (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isCanonical (int *pres,\n+bid64_isCanonical (int *pres,\n \t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isCanonical (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isCanonical (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n-  if ((x & MASK_NAN) == MASK_NAN) { // NaN\n+  if ((x & MASK_NAN) == MASK_NAN) {\t// NaN\n     if (x & 0x01fc000000000000ull) {\n       res = 0;\n-    } else if ((x & 0x0003ffffffffffffull) > 999999999999999ull) { // payload\n+    } else if ((x & 0x0003ffffffffffffull) > 999999999999999ull) {\t// payload\n       res = 0;\n     } else {\n       res = 1;\n@@ -270,23 +270,23 @@ __bid64_isCanonical (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n     } else {\n       res = 1;\n     }\n-  } else if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) { // 54-bit coeff.\n+  } else if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\t// 54-bit coeff.\n     res =\n       (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) <=\n        9999999999999999ull);\n-  } else { // 53-bit coeff.\n+  } else {\t// 53-bit coeff.\n     res = 1;\n   }\n   BID_RETURN (res);\n }\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_isNaN (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isNaN (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_isNaN (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_isNaN (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n \n@@ -297,11 +297,11 @@ __bid64_isNaN (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, with no change\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_copy (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_copy (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n UINT64\n-__bid64_copy (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_copy (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT64 res;\n \n@@ -312,12 +312,12 @@ __bid64_copy (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, reversing the sign\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_negate (UINT64 * pres,\n+bid64_negate (UINT64 * pres,\n \t      UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n UINT64\n-__bid64_negate (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_negate (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT64 res;\n \n@@ -328,11 +328,11 @@ __bid64_negate (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // copies a floating-point operand x to destination y, changing the sign to positive\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_abs (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_abs (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n UINT64\n-__bid64_abs (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_abs (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT64 res;\n \n@@ -344,13 +344,13 @@ __bid64_abs (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // with the sign of y\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_copySign (UINT64 * pres, UINT64 * px,\n+bid64_copySign (UINT64 * pres, UINT64 * px,\n \t\tUINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n UINT64\n-__bid64_copySign (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_copySign (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT64 res;\n \n@@ -360,11 +360,11 @@ __bid64_copySign (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_class (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_class (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_class (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_class (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   UINT128 sig_x_prime;\n@@ -413,7 +413,7 @@ __bid64_class (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   }\n   // if exponent is less than -383, number may be subnormal\n   //  if (exp_x - 398 < -383)\n-  if (exp_x < 15) { // sig_x *10^exp_x\n+  if (exp_x < 15) {\t// sig_x *10^exp_x\n     __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n     if (sig_x_prime.w[1] == 0\n \t&& (sig_x_prime.w[0] < 1000000000000000ull)) {\n@@ -435,13 +435,13 @@ __bid64_class (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n // If exactly one operand is infinite or exactly one operand is NaN, then false\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_sameQuantum (int *pres, UINT64 * px,\n+bid64_sameQuantum (int *pres, UINT64 * px,\n \t\t   UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_sameQuantum (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_sameQuantum (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   unsigned int exp_x, exp_y;\n@@ -473,13 +473,13 @@ __bid64_sameQuantum (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_totalOrder (int *pres, UINT64 * px,\n+bid64_totalOrder (int *pres, UINT64 * px,\n \t\t  UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   int exp_x, exp_y;\n@@ -493,23 +493,25 @@ __bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   //    (2) totalOrder(number, +NaN) is true\n   //    (3) if x and y are both NaN:\n   //           i) negative sign bit < positive sign bit\n-  //           ii) signaling < quiet fir +NaN, reverse for -NaN\n+  //           ii) signaling < quiet for +NaN, reverse for -NaN\n   //           iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  //           iv) else if bitwise identical (in canonical form), return 1\n   if ((x & MASK_NAN) == MASK_NAN) {\n     // if x is -NaN\n     if ((x & MASK_SIGN) == MASK_SIGN) {\n       // return true, unless y is -NaN also\n       if ((y & MASK_NAN) != MASK_NAN || (y & MASK_SIGN) != MASK_SIGN) {\n-\tres = 1; // y is a number, return 1\n+\tres = 1;\t// y is a number, return 1\n \tBID_RETURN (res);\n-      } else { // if y and x are both -NaN\n+      } else {\t// if y and x are both -NaN\n \t// if x and y are both -sNaN or both -qNaN, we have to compare payloads\n \t// this xnor statement evaluates to true if both are sNaN or qNaN\n \tif (!\n \t    (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n \t\t\t\t\t       MASK_SNAN))) {\n \t  // it comes down to the payload.  we want to return true if x has a\n-\t  // larger payload, but first we must calculate the payload.\n+\t  // larger payload, or if the payloads are equal (canonical forms\n+\t  // are bitwise identical)\n \t  pyld_y = y & 0x0003ffffffffffffull;\n \t  pyld_x = x & 0x0003ffffffffffffull;\n \t  if (pyld_y > 999999999999999ull || pyld_y == 0) {\n@@ -529,14 +531,14 @@ __bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \t  BID_RETURN (res);\n \t} else {\n \t  // either x = -sNaN and y = -qNaN or x = -qNaN and y = -sNaN\n-\t  res = (y & MASK_SNAN) == MASK_SNAN; // totalOrder(-qNaN, -sNaN) == 1\n+\t  res = (y & MASK_SNAN) == MASK_SNAN;\t// totalOrder(-qNaN, -sNaN) == 1\n \t  BID_RETURN (res);\n \t}\n       }\n-    } else { // x is +NaN\n+    } else {\t// x is +NaN\n       // return false, unless y is +NaN also\n       if ((y & MASK_NAN) != MASK_NAN || (y & MASK_SIGN) == MASK_SIGN) {\n-\tres = 0; // y is a number, return 1\n+\tres = 0;\t// y is a number, return 1\n \tBID_RETURN (res);\n       } else {\n \t// x and y are both +NaN; \n@@ -546,7 +548,8 @@ __bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n \t    (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n \t\t\t\t\t       MASK_SNAN))) {\n \t  // it comes down to the payload.  we want to return true if x has a\n-\t  // smaller payload, but first we must calculate the payload.\n+\t  // smaller payload, or if the payloads are equal (canonical forms\n+\t  // are bitwise identical)\n \t  pyld_y = y & 0x0003ffffffffffffull;\n \t  pyld_x = x & 0x0003ffffffffffffull;\n \t  // if x is zero and y isn't, x has the smaller \n@@ -736,16 +739,16 @@ __bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   BID_RETURN (res);\n }\n \n-//totalOrderMag is TotalOrder(abs(x), abs(y))\n+// totalOrderMag is TotalOrder(abs(x), abs(y))\n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_totalOrderMag (int *pres, UINT64 * px,\n+bid64_totalOrderMag (int *pres, UINT64 * px,\n \t\t     UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n   UINT64 y = *py;\n #else\n int\n-__bid64_totalOrderMag (UINT64 x,\n+bid64_totalOrderMag (UINT64 x,\n \t\t     UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n@@ -754,20 +757,19 @@ __bid64_totalOrderMag (UINT64 x,\n   UINT128 sig_n_prime;\n   char x_is_zero = 0, y_is_zero = 0;\n \n-  // NaN (CASE1)\n+  // NaN (CASE 1)\n   // if x and y are unordered numerically because either operand is NaN\n-  //    (1) totalOrder(-NaN, number) is true\n-  //    (2) totalOrder(number, +NaN) is true\n-  //    (3) if x and y are both NaN:\n-  //           i) negative sign bit < positive sign bit\n-  //           ii) signaling < quiet fir +NaN, reverse for -NaN\n-  //           iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  //    (1) totalOrder(number, +NaN) is true\n+  //    (2) if x and y are both NaN:\n+  //       i) signaling < quiet for +NaN\n+  //       ii) lesser payload < greater payload for +NaN\n+  //       iii) else if bitwise identical (in canonical form), return 1\n   if ((x & MASK_NAN) == MASK_NAN) {\n     // x is +NaN\n \n     // return false, unless y is +NaN also\n     if ((y & MASK_NAN) != MASK_NAN) {\n-      res = 0; // y is a number, return 1\n+      res = 0;\t// y is a number, return 1\n       BID_RETURN (res);\n \n     } else {\n@@ -779,7 +781,8 @@ __bid64_totalOrderMag (UINT64 x,\n \t  (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n \t\t\t\t\t     MASK_SNAN))) {\n \t// it comes down to the payload.  we want to return true if x has a\n-\t// smaller payload, but first we must calculate the payload.\n+\t// smaller payload, or if the payloads are equal (canonical forms\n+\t// are bitwise identical)\n \tpyld_y = y & 0x0003ffffffffffffull;\n \tpyld_x = x & 0x0003ffffffffffffull;\n \t// if x is zero and y isn't, x has the smaller \n@@ -893,7 +896,7 @@ __bid64_totalOrderMag (UINT64 x,\n   // if exp_x is 15 greater than exp_y, it is definitely \n   // larger, so no need for compensation\n   if (exp_x - exp_y > 15) {\n-    res = 0; // difference cannot be greater than 10^15\n+    res = 0;\t// difference cannot be greater than 10^15\n     BID_RETURN (res);\n   }\n   // if exp_x is 15 less than exp_y, it is definitely \n@@ -941,11 +944,11 @@ __bid64_totalOrderMag (UINT64 x,\n \n #if DECIMAL_CALL_BY_REFERENCE\n void\n-__bid64_radix (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_radix (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x = *px;\n #else\n int\n-__bid64_radix (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_radix (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   int res;\n   if (x)\t// dummy test"}, {"sha": "c46354cd60cca7f1fd236aa4ac2de5cfdbe5f560", "filename": "libgcc/config/libbid/bid64_quantize.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -35,23 +35,24 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_quantize (UINT64 * pres, UINT64 * px,\n+bid64_quantize (UINT64 * pres, UINT64 * px,\n \t\tUINT64 *\n \t\tpy _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n \t\t_EXC_INFO_PARAM) {\n   UINT64 x, y;\n #else\n \n UINT64\n-__bid64_quantize (UINT64 x,\n+bid64_quantize (UINT64 x,\n \t\tUINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n \t\t_EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 CT;\n-  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, remainder_h, C64;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, remainder_h, C64,\n+    valid_x;\n   UINT64 tmp, carry, res;\n   int_float tempx;\n-  int exponent_x, exponent_y = 0, digits_x, extra_digits, amount, amount2;\n+  int exponent_x, exponent_y, digits_x, extra_digits, amount, amount2;\n   int expon_diff, total_digits, bin_expon_cx;\n   unsigned rmode, status;\n \n@@ -63,6 +64,7 @@ __bid64_quantize (UINT64 x,\n   y = *py;\n #endif\n \n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n   // unpack arguments, check for NaN or Infinity\n   if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n     // Inf. or NaN or 0\n@@ -72,9 +74,9 @@ __bid64_quantize (UINT64 x,\n #endif\n \n     // x=Inf, y=Inf?\n-    if (((x << 1) == 0xf000000000000000ull)\n-\t&& ((y << 1) == 0xf000000000000000ull)) {\n-      res = x;\n+    if (((coefficient_x << 1) == 0xf000000000000000ull)\n+\t&& ((coefficient_y << 1) == 0xf000000000000000ull)) {\n+      res = coefficient_x;\n       BID_RETURN (res);\n     }\n     // Inf or NaN?\n@@ -85,12 +87,18 @@ __bid64_quantize (UINT64 x,\n \t      ((x & 0x7c00000000000000ull) < 0x7800000000000000ull)))\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = 0x7c00000000000000ull;\n-      BID_RETURN (res);\n+      if ((y & NAN_MASK64) != NAN_MASK64)\n+\tcoefficient_y = 0;\n+      if ((x & NAN_MASK64) != NAN_MASK64) {\n+\tres = 0x7c00000000000000ull | (coefficient_y & QUIET_MASK64);\n+\tif (((y & NAN_MASK64) != NAN_MASK64) && ((x & NAN_MASK64) == 0x7800000000000000ull))\n+\t\tres = x;\n+\tBID_RETURN (res);\n+      }\n     }\n   }\n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+  if (!valid_x) {\n     // x is Inf. or NaN or 0\n \n     // Inf or NaN?\n@@ -100,7 +108,9 @@ __bid64_quantize (UINT64 x,\n \t  || ((x & 0x7c00000000000000ull) == 0x7800000000000000ull))\t//Inf \n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = 0x7c00000000000000ull;\n+      if ((x & NAN_MASK64) != NAN_MASK64)\n+\tcoefficient_x = 0;\n+      res = 0x7c00000000000000ull | (coefficient_x & QUIET_MASK64);\n       BID_RETURN (res);\n     }\n \n@@ -110,8 +120,8 @@ __bid64_quantize (UINT64 x,\n   // get number of decimal digits in coefficient_x\n   tempx.d = (float) coefficient_x;\n   bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n-  digits_x = __bid_estimate_decimal_digits[bin_expon_cx];\n-  if (coefficient_x >= __bid_power10_table_128[digits_x].w[0])\n+  digits_x = estimate_decimal_digits[bin_expon_cx];\n+  if (coefficient_x >= power10_table_128[digits_x].w[0])\n     digits_x++;\n \n   expon_diff = exponent_x - exponent_y;\n@@ -120,7 +130,7 @@ __bid64_quantize (UINT64 x,\n   // check range of scaled coefficient\n   if ((UINT32) (total_digits + 1) <= 17) {\n     if (expon_diff >= 0) {\n-      coefficient_x *= __bid_power10_table_128[expon_diff].w[0];\n+      coefficient_x *= power10_table_128[expon_diff].w[0];\n       res = very_fast_get_BID64 (sign_x, exponent_y, coefficient_x);\n       BID_RETURN (res);\n     }\n@@ -137,22 +147,22 @@ __bid64_quantize (UINT64 x,\n #else\n     rmode = 0;\n #endif\n-    coefficient_x += __bid_round_const_table[rmode][extra_digits];\n+    coefficient_x += round_const_table[rmode][extra_digits];\n \n     // get P*(2^M[extra_digits])/10^extra_digits\n     __mul_64x64_to_128 (CT, coefficient_x,\n-\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\t\t\treciprocals10_64[extra_digits]);\n \n     // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n-    amount = __bid_short_recip_scale[extra_digits];\n+    amount = short_recip_scale[extra_digits];\n     C64 = CT.w[1] >> amount;\n #ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n #ifndef IEEE_ROUND_NEAREST\n     if (rnd_mode == 0)\n #endif\n       if (C64 & 1) {\n \t// check whether fractional part of initial_P/10^extra_digits \n-        // is exactly .5\n+\t// is exactly .5\n \t// this is the same as fractional part of \n \t//   (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n \n@@ -164,7 +174,7 @@ __bid64_quantize (UINT64 x,\n \tremainder_h = remainder_h & CT.w[1];\n \n \t// test whether fractional part is 0\n-\tif (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits])) {\n+\tif (!remainder_h && (CT.w[0] < reciprocals10_64[extra_digits])) {\n \t  C64--;\n \t}\n       }\n@@ -179,19 +189,19 @@ __bid64_quantize (UINT64 x,\n     case ROUNDING_TIES_AWAY:\n       // test whether fractional part is 0\n       if ((remainder_h == 0x8000000000000000ull)\n-\t  && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t  && (CT.w[0] < reciprocals10_64[extra_digits]))\n \tstatus = EXACT_STATUS;\n       break;\n     case ROUNDING_DOWN:\n     case ROUNDING_TO_ZERO:\n-      if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+      if (!remainder_h && (CT.w[0] < reciprocals10_64[extra_digits]))\n \tstatus = EXACT_STATUS;\n       //if(!C64 && rmode==ROUNDING_DOWN) sign_s=sign_y;\n       break;\n     default:\n       // round up\n       __add_carry_out (tmp, carry, CT.w[0],\n-\t\t       __bid_reciprocals10_64[extra_digits]);\n+\t\t       reciprocals10_64[extra_digits]);\n       if ((remainder_h >> (64 - amount)) + carry >=\n \t  (((UINT64) 1) << amount))\n \tstatus = EXACT_STATUS;"}, {"sha": "99bf3772de0966255183e61b057b3fedf0cfacdc", "filename": "libgcc/config/libbid/bid64_rem.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "patch": "@@ -56,32 +56,33 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #if DECIMAL_CALL_BY_REFERENCE\n \n void\n-__bid64_rem (UINT64 * pres, UINT64 * px,\n+bid64_rem (UINT64 * pres, UINT64 * px,\n \t   UINT64 *\n-\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n-\t   _EXC_INFO_PARAM) {\n+\t   py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n   UINT64 x, y;\n #else\n \n UINT64\n-__bid64_rem (UINT64 x,\n-\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n-\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+bid64_rem (UINT64 x,\n+\t   UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n #endif\n   UINT128 CY;\n   UINT64 sign_x, sign_y, coefficient_x, coefficient_y, res;\n-  UINT64 Q, R, R2, T;\n+  UINT64 Q, R, R2, T, valid_y, valid_x;\n   int_float tempx;\n-  int exponent_x = 0, exponent_y, bin_expon, e_scale;\n+  int exponent_x, exponent_y, bin_expon, e_scale;\n   int digits_x, diff_expon;\n \n #if DECIMAL_CALL_BY_REFERENCE\n   x = *px;\n   y = *py;\n #endif\n \n+  valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);\n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n+\n   // unpack arguments, check for NaN or Infinity\n-  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+  if (!valid_x) {\n     // x is Inf. or NaN or 0\n #ifdef SET_STATUS_FLAGS\n     if ((y & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n@@ -94,24 +95,24 @@ __bid64_rem (UINT64 x,\n       if (((x & SNAN_MASK64) == SNAN_MASK64))\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = x & QUIET_MASK64;;\n+      res = coefficient_x & QUIET_MASK64;;\n       BID_RETURN (res);\n     }\n     // x is Infinity?\n     if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      if (((y & NAN_MASK64) != NAN_MASK64)) {\n #ifdef SET_STATUS_FLAGS\n-      if (((y & NAN_MASK64) != NAN_MASK64))\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      // return NaN\n-      res = 0x7c00000000000000ull;\n-      BID_RETURN (res);\n+\t// return NaN\n+\tres = 0x7c00000000000000ull;\n+\tBID_RETURN (res);\n+      }\n     }\n     // x is 0\n     // return x if y != 0\n     if (((y & 0x7800000000000000ull) < 0x7800000000000000ull) &&\n-\t(((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n-\t || (y << (64 - 53)))) {\n+\tcoefficient_y) {\n       if ((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n \texponent_y = (y >> 51) & 0x3ff;\n       else\n@@ -128,7 +129,7 @@ __bid64_rem (UINT64 x,\n     }\n \n   }\n-  if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n+  if (!valid_y) {\n     // y is Inf. or NaN\n \n     // test if y is NaN\n@@ -137,12 +138,12 @@ __bid64_rem (UINT64 x,\n       if (((y & SNAN_MASK64) == SNAN_MASK64))\n \t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n #endif\n-      res = y & QUIET_MASK64;;\n+      res = coefficient_y & QUIET_MASK64;;\n       BID_RETURN (res);\n     }\n     // y is Infinity?\n     if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n-      res = x;\n+      res = very_fast_get_BID64 (sign_x, exponent_x, coefficient_x);\n       BID_RETURN (res);\n     }\n     // y is 0, return NaN\n@@ -166,7 +167,7 @@ __bid64_rem (UINT64 x,\n       BID_RETURN (res);\n     }\n     // set exponent of y to exponent_x, scale coefficient_y\n-    T = __bid_power10_table_128[diff_expon].w[0];\n+    T = power10_table_128[diff_expon].w[0];\n     __mul_64x64_to_128 (CY, coefficient_y, T);\n \n     if (CY.w[1] || CY.w[0] > (coefficient_x << 1)) {\n@@ -192,9 +193,9 @@ __bid64_rem (UINT64 x,\n     // get number of digits in coeff_x\n     tempx.d = (float) coefficient_x;\n     bin_expon = ((tempx.i >> 23) & 0xff) - 0x7f;\n-    digits_x = __bid_estimate_decimal_digits[bin_expon];\n+    digits_x = estimate_decimal_digits[bin_expon];\n     // will not use this test, dividend will have 18 or 19 digits\n-    //if(coefficient_x >= __bid_power10_table_128[digits_x].w[0])\n+    //if(coefficient_x >= power10_table_128[digits_x].w[0])\n     //      digits_x++;\n \n     e_scale = 18 - digits_x;\n@@ -206,7 +207,7 @@ __bid64_rem (UINT64 x,\n     }\n \n     // scale dividend to 18 or 19 digits\n-    coefficient_x *= __bid_power10_table_128[e_scale].w[0];\n+    coefficient_x *= power10_table_128[e_scale].w[0];\n \n     // quotient\n     Q = coefficient_x / coefficient_y;"}, {"sha": "c777ed81195c75b3b221f2992bf9950c11fa4ff9", "filename": "libgcc/config/libbid/bid64_round_integral.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "5124f137d793ce2b531d16b3f3f1987757700429", "filename": "libgcc/config/libbid/bid64_scalb.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "1098ede90df7cefdba5fdaff1cb53f9e89cfd620", "filename": "libgcc/config/libbid/bid64_sqrt.c", "status": "modified", "additions": 367, "deletions": 8, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "3c2396e00f9a49f9af0ec9a3426a8a13aec520e7", "filename": "libgcc/config/libbid/bid64_string.c", "status": "renamed", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_string.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/bid_string.c"}, {"sha": "ac0cf781f05f1b39892831d6cddbd057fe261017", "filename": "libgcc/config/libbid/bid64_to_bid128.c", "status": "modified", "additions": 78, "deletions": 67, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "4c22cd27d9c5ad3df62ed7e2dc9ea39ddb3246ba", "filename": "libgcc/config/libbid/bid64_to_int16.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int16.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "b4e62371b6ae622ef4b875d124af5d7036083737", "filename": "libgcc/config/libbid/bid64_to_int32.c", "status": "modified", "additions": 565, "deletions": 567, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "bce2baf6dfaa051679e1b251b001e7e8b646beaf", "filename": "libgcc/config/libbid/bid64_to_int64.c", "status": "modified", "additions": 554, "deletions": 554, "changes": 1108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "63f345701f66b6048181960b7beb15096a4cd23c", "filename": "libgcc/config/libbid/bid64_to_int8.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int8.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "789e95b2a21be86e1265ea1a8e31e2e98438b4e6", "filename": "libgcc/config/libbid/bid64_to_uint16.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint16.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "cf11e65748cf3a05f5ded7f0dd4b2e9a7a6543c9", "filename": "libgcc/config/libbid/bid64_to_uint32.c", "status": "modified", "additions": 534, "deletions": 534, "changes": 1068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "7b1d31f8dfd7b4a4bceeeb8723e550ba22e168ed", "filename": "libgcc/config/libbid/bid64_to_uint64.c", "status": "modified", "additions": 539, "deletions": 539, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "660fb22bb84ac5c0ec53b32b19466f8ae90fc0a9", "filename": "libgcc/config/libbid/bid64_to_uint8.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint8.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "44044b0d46152385837ca8e4f2cc0936d576f34b", "filename": "libgcc/config/libbid/bid_b2d.h", "status": "added", "additions": 3060, "deletions": 0, "changes": 3060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_b2d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_b2d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_b2d.h?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "f0be6eb05f91e798e0bcb897626e80122b316f43", "filename": "libgcc/config/libbid/bid_binarydecimal.c", "status": "added", "additions": 147484, "deletions": 0, "changes": 147484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_binarydecimal.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "d93ab6a2a3e8cb9cb384dc298d44861d492e9110", "filename": "libgcc/config/libbid/bid_conf.h", "status": "modified", "additions": 620, "deletions": 88, "changes": 708, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "0c34fd2068c2a76ee2f1ae1372f863bbc7a7cb66", "filename": "libgcc/config/libbid/bid_convert_data.c", "status": "renamed", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_convert_data.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_convert_data.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_convert_data.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/convert_data.c"}, {"sha": "9a5f9ba0abde1901dedcbaa96605ec4ee32c8368", "filename": "libgcc/config/libbid/bid_decimal_data.c", "status": "renamed", "additions": 443, "deletions": 228, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_data.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_data.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_data.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/decimal_data.c"}, {"sha": "e8efd44561b9ce8d5bc6d255b6e025208d32bcaa", "filename": "libgcc/config/libbid/bid_decimal_globals.c", "status": "renamed", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_decimal_globals.c?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/decimal_globals.c"}, {"sha": "7773d97ebb00d8ba13d4c47da40c41b4489578d9", "filename": "libgcc/config/libbid/bid_div_macros.h", "status": "renamed", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_div_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_div_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_div_macros.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/div_macros.h"}, {"sha": "d82b2a65a7f8e3a1b46da493a7921b74acd7e92d", "filename": "libgcc/config/libbid/bid_dpd.c", "status": "added", "additions": 787, "deletions": 0, "changes": 787, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_dpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_dpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_dpd.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "d025e635f88cd87f829d4a48d737d452184f82ee", "filename": "libgcc/config/libbid/bid_flag_operations.c", "status": "modified", "additions": 101, "deletions": 54, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "bebc1351c243c9abb715eb96a1ec53ab4e2e84f7", "filename": "libgcc/config/libbid/bid_from_int.c", "status": "modified", "additions": 84, "deletions": 79, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "afccd22bc2bccf0bd093e0a798990a1bec575bf3", "filename": "libgcc/config/libbid/bid_functions.h", "status": "modified", "additions": 1815, "deletions": 1207, "changes": 3022, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "6bae1350baf05a5609502faf664f594696617de7", "filename": "libgcc/config/libbid/bid_gcc_intrinsics.h", "status": "renamed", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_gcc_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_gcc_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_gcc_intrinsics.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/bid_intrinsics.h"}, {"sha": "791b6e2fd8badeffed322a0918a1d703466c5bc4", "filename": "libgcc/config/libbid/bid_inline_add.h", "status": "renamed", "additions": 189, "deletions": 111, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_inline_add.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_inline_add.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_inline_add.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/inline_bid_add.h"}, {"sha": "d389646870baf3d56642afd222d7aa2fd597384c", "filename": "libgcc/config/libbid/bid_internal.h", "status": "modified", "additions": 226, "deletions": 186, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "7cf5e76ceac516dc29b3792d19c628505100e239", "filename": "libgcc/config/libbid/bid_round.c", "status": "modified", "additions": 260, "deletions": 310, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_round.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_round.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_round.c?ref=b2a00c8984668b802b3331db38cd7f530f886842"}, {"sha": "37f0bc6a62fdf96cb18db470615fcebc58b72c17", "filename": "libgcc/config/libbid/bid_sqrt_macros.h", "status": "renamed", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_sqrt_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a00c8984668b802b3331db38cd7f530f886842/libgcc%2Fconfig%2Flibbid%2Fbid_sqrt_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_sqrt_macros.h?ref=b2a00c8984668b802b3331db38cd7f530f886842", "previous_filename": "libgcc/config/libbid/sqrt_macros.h"}, {"sha": "f0097f0c0f76cbb5dff481122a78a3c5939e902d", "filename": "libgcc/config/libbid/binarydecimal.c", "status": "removed", "additions": 0, "deletions": 100387, "changes": 100387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e233ac979c0f179f858f3c86281835a4c09cece2/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c?ref=e233ac979c0f179f858f3c86281835a4c09cece2"}]}