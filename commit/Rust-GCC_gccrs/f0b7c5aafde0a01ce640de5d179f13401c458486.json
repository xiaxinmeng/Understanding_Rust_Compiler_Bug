{"sha": "f0b7c5aafde0a01ce640de5d179f13401c458486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBiN2M1YWFmZGUwYTAxY2U2NDBkZTVkMTc5ZjEzNDAxYzQ1ODQ4Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-24T21:02:20Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-24T21:02:20Z"}, "message": "Initial revision\n\nFrom-SVN: r241", "tree": {"sha": "939efb2afc0413bc6e81c5a00d775d24dae0cb0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/939efb2afc0413bc6e81c5a00d775d24dae0cb0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0b7c5aafde0a01ce640de5d179f13401c458486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b7c5aafde0a01ce640de5d179f13401c458486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0b7c5aafde0a01ce640de5d179f13401c458486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b7c5aafde0a01ce640de5d179f13401c458486/comments", "author": null, "committer": null, "parents": [{"sha": "e071c188e8f9802e2b99ebb1b8edf5c71301e478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e071c188e8f9802e2b99ebb1b8edf5c71301e478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e071c188e8f9802e2b99ebb1b8edf5c71301e478"}], "stats": {"total": 605, "additions": 605, "deletions": 0}, "files": [{"sha": "ceb8d97a0cb02d082a2366f05b465e773722121b", "filename": "gcc/config/m68k/hp320.h", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b7c5aafde0a01ce640de5d179f13401c458486/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b7c5aafde0a01ce640de5d179f13401c458486/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=f0b7c5aafde0a01ce640de5d179f13401c458486", "patch": "@@ -0,0 +1,605 @@\n+/* Definitions of target machine for GNU compiler.  HP-UX 68000/68020 version.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Define USE_GAS if GCC is supposed to work with the GNU assembler,\n+   GNU linker and GNU debugger using DBX debugging information.\n+   (In other words, much of HPUX has been cast aside.)\n+   Undefine USE_GAS if you want GCC to feed the HP assembler.  */\n+\n+/* #define USE_GAS */  /* Use hp320g.h if you want this.  */\n+\n+/* Control assembler-syntax conditionals in m68k.md.  */\n+\n+#ifndef USE_GAS\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS\t\t\t/* Uses SGS assembler */\n+#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n+#define HPUX_ASM\n+#endif\n+\n+/* Be compatible with system stddef.h.  */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define\tTARGET_DEFAULT 7\n+#endif\n+\n+/* Define __HAVE_68881__ in preprocessor, unless -msoft-float is specified.\n+   This will control the use of inline 68881 insns in certain macros.  */\n+\n+#ifdef HPUX_ASM\n+\n+#define ASM_SPEC \"%{m68000:+X}%{mc68000:+X}\"\n+\n+#if TARGET_DEFAULT & 02  /* -m68881 is the default */\n+\n+/* These definitions differ from those used for GAS by defining __HPUX_ASM__.\n+   This is needed because some programs, particularly GDB, need to\n+   know which assembler is being used so that the correct `asm'\n+   instructions can be used. */\n+\n+#define CPP_SPEC \\\n+\"%{!msoft-float:-D__HAVE_68881__ }\\\n+%{!ansi:%{!mc68000:%{!m68000:-Dmc68020}} -D_HPUX_SOURCE} -D__HPUX_ASM__\"\n+\n+#else /* default is -msoft-float */\n+\n+#define CPP_SPEC \\\n+\"%{m68881:-D__HAVE_68881__ }\\\n+%{!ansi:%{!mc68000:%{!m68000:-Dmc68020}} -D_HPUX_SOURCE} -D__HPUX_ASM__\"\n+\n+#endif /* default is -msoft-float */\n+\n+#else /* not HPUX_ASM */\n+\n+#if TARGET_DEFAULT & 02  /* -m68881 is the default */\n+\n+#define CPP_SPEC \\\n+\"%{!msoft-float:-D__HAVE_68881__ }\\\n+%{!ansi:%{!mc68000:%{!m68000:-Dmc68020}} -D_HPUX_SOURCE}\"\n+\n+#else /* default is -msoft-float */\n+\n+#define CPP_SPEC \\\n+\"%{m68881:-D__HAVE_68881__ }\\\n+%{!ansi:%{!mc68000:%{!m68000:-Dmc68020}} -D_HPUX_SOURCE}\"\n+\n+#endif /* default is -msoft-float */\n+\n+\n+/* -m68000 requires special flags to the assembler.  */\n+#define ASM_SPEC \\\n+ \"%{m68000:-mc68000}%{mc68000:-mc68000}%{!mc68000:%{!m68000:-mc68020}}\"\n+\n+/* special directory for gnu libs on hp-ux system */\n+#define MD_STARTFILE_PREFIX \"/usr/local/lib/gnu/\"\n+\n+#endif /* Not HPUX_ASM */\n+\n+/* Names to predefine in the preprocessor for this target machine\n+   (for non-strict-ANSI programs only).  */\n+/* These are the ones defined by HPUX cc, plus mc68000 for uniformity with\n+   GCC on other 68000 systems.  */\n+\n+#define CPP_PREDEFINES \"-Dhp9000s200 -Dhp9000s300 -DPWB -Dhpux -Dunix -D__hp9000s300 -D__hp9000s200 -D__PWB -D__hpux -D__unix\"\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* hpux doesn't use static area for struct returns. */\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n+#if 0  /* No longer correct in HPUX version 6.5.  */\n+/* Function calls don't save any fp registers on hpux.  */\n+#undef CALL_USED_REGISTERS\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+ {1, 1, 0, 0, 0, 0, 0, 0,\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 1,\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1}\n+#endif /* 0 */\n+\n+#ifdef HPUX_ASM\n+\n+/* Override parts of m68k.h to fit the HPUX assembler.  */\n+\n+#undef TARGET_VERSION\n+#undef REGISTER_NAMES\n+#undef FUNCTION_PROLOGUE\n+#undef FUNCTION_EPILOGUE\n+#undef ASM_OUTPUT_REG_PUSH\n+#undef ASM_OUTPUT_REG_POP\n+#undef ASM_FILE_START\n+#undef ASM_APP_ON\n+#undef ASM_APP_OFF\n+#undef TEXT_SECTION_ASM_OP\n+#undef DATA_SECTION_ASM_OP\n+#undef ASM_OUTPUT_DOUBLE\n+#undef ASM_OUTPUT_FLOAT\n+#undef ASM_OUTPUT_INT\n+#undef ASM_OUTPUT_SHORT\n+#undef ASM_OUTPUT_CHAR\n+#undef ASM_OUTPUT_BYTE\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#undef ASM_OUTPUT_ALIGN\n+#undef ASM_OUTPUT_SKIP\n+#undef ASM_OUTPUT_COMMON\n+#undef ASM_OUTPUT_LOCAL\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#undef PRINT_OPERAND\n+#undef PRINT_OPERAND_ADDRESS\n+#undef FUNCTION_PROFILER\n+#undef ASM_GLOBALIZE_LABEL\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+\n+#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/hpux syntax)\");\n+\n+#define REGISTER_NAMES \\\n+{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n+ \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = (SIZE);\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    { if (fsize < 0x8000)\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tlink.w %%a6,&%d\\n\", -fsize);\t\t\\\n+      else if (TARGET_68020)\t\t\t\t\t\\\n+        fprintf (FILE, \"\\tlink.l %%a6,&%d\\n\", -fsize);\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tlink.w %%a6,&0\\n\\tsub.l &%d,%%sp\\n\", fsize); }  \\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if (mask != 0)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tfmovem &0x%x,-(%%sp)\\n\", mask & 0xff);       \\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (15 - regno);\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n+  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n+  else if (mask) fprintf (FILE, \"\\tmovm.l &0x%x,-(%%sp)\\n\", mask); }\n+\n+#define FUNCTION_PROFILER(FILE, LABEL_NO) \\\n+   fprintf (FILE, \"\\tmov.l &LP%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO));\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs;\t\t\t\t\t\t\\\n+  int offset, foffset;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = (SIZE);\t\t\t\t\t\t\\\n+  int big = 0;\t\t\t\t\t\t\t\\\n+  nregs = 0;  fmask = 0;\t\t\t\t\t\\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n+  foffset = nregs * 12;\t\t\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  offset = foffset + nregs * 4;\t\t\t\t\t\\\n+  if (offset + fsize >= 0x8000 && frame_pointer_needed)\t\t\\\n+    { fprintf (FILE, \"\\tmov.l &%d,%%a0\\n\", -fsize);\t\t\\\n+      fsize = 0, big = 1; }\t\t\t\t\t\\\n+  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%a6,%%a0.l),%s\\n\",\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\",\t\t\t\\\n+\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%a6),%s\\n\",\t\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n+  else if (mask) {\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%a6,%%a0.l),&0x%x\\n\",\t\\\n+\t       offset + fsize, mask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l (%%sp)+,&0x%x\\n\", mask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%a6),&0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask); }\t\t\t\t\\\n+  if (fmask) {\t\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(%%a6,%%a0.l),&0x%x\\n\",\t\\\n+\t       foffset + fsize, fmask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem (%%sp)+,&0x%x\\n\", fmask);\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(%%a6),&0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask); }\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tunlk %%a6\\n\");\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\trtd &%d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\trts\\n\"); }\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n+\n+/* For HPUX versions before 6.5, define this macro as empty.  */\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  if (TARGET_68020)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_68881)\t\t\t\t\t\t\t\\\n+\t fprintf (FILE, \"\\tversion 3\\n\"); /* 68020 fp regs saved */\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t fprintf (FILE, \"\\tversion 2\\n\"); /* 68020 no fp regs saved */\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tversion 1\\n\");\t/* 68010 */\n+\n+#define ASM_APP_ON \"\"\n+\n+#define ASM_APP_OFF \"\"\n+\n+#define TEXT_SECTION_ASM_OP \"text\"\n+\n+#define DATA_SECTION_ASM_OP \"data\"\n+\n+#define\tASCII_DATA_ASM_OP \"\\tbyte\"\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u,2\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\tglobal \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+do{  if (PREFIX[0] == 'L' && PREFIX[1] == 'I')\t\t\\\n+    fprintf(FILE, \"\\tset %s%d,.+2\\n\", PREFIX, NUM);\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM);\t\t\\\n+} while(0)\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tdouble 0f%.20g\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tfloat 0f%.9g\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tbyte 0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\tlong L%d\\n\", VALUE)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tshort L%d-L%d\\n\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) == 1)\t\t\t\\\n+    fprintf (FILE, \"\\tlalign 2\\n\");\t\\\n+  else if ((LOG) != 0)\t\t\t\\\n+    abort ();\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tspace %u\\n\", (SIZE))\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME)\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n+  else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"-(%%sp)\");\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"(%%sp)+\");\t\t\t\\\n+  else if (CODE == '@') fprintf (FILE, \"(%%sp)\");\t\t\t\\\n+  else if (CODE == '!') fprintf (FILE, \"%%cc\");\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"&0f%.9g\", u1.f);\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"&0x%x\", u1.i); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"&0f%.20g\", u.d); }\t\t\t\t\\\n+  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"L%d-LI%d(%%pc,%s.w\",\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"L%d-LI%d(%%pc,%s.l\",\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t\t\\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"L%d-LI%d(%%pc,%s.w)\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d.w\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+#define\tASM_OUTPUT_ASCII(f, p, size)\t\\\n+{ register int i;\t\t\t\\\n+  int inside;\t\t\t\t\\\n+  inside = FALSE;\t\t\t\\\n+  for (i = 0; i < (size); i++) {\t\\\n+    if (i % 8 == 0) {\t\t\t\\\n+      if (i != 0) {\t\t\t\\\n+\tif (inside)\t\t\t\\\n+\t  putc('\"', (f));\t\t\\\n+\tputc('\\n', (f));\t\t\\\n+\tinside = FALSE;\t\t\t\\\n+      }\t\t\t\t\t\\\n+      fprintf((f), \"%s \", ASCII_DATA_ASM_OP);\t\\\n+    }\t\t\t\t\t\\\n+    if ((p)[i] < 32 || (p)[i] == '\\\\' || (p)[i] == '\"' || (p)[i] == 127) {\t\\\n+      if (inside) {\t\t\t\\\n+\tputc('\"', (f));\t\t\t\\\n+\tinside = FALSE;\t\t\t\\\n+      }\t\t\t\t\t\\\n+      if (i % 8 != 0)\t\t\t\\\n+\tputc(',', (f));\t\t\t\\\n+      fprintf((f), \"%d\", (p)[i]);\t\\\n+    } else {\t\t\t\t\\\n+      if (!inside) {\t\t\t\\\n+\tif (i % 8 != 0)\t\t\t\\\n+\t  putc(',', (f));\t\t\\\n+\tputc('\"', (f));\t\t\t\\\n+\tinside = TRUE;\t\t\t\\\n+      }\t\t\t\t\t\\\n+      putc((p)[i], (f));\t\t\\\n+    }\t\t\t\t\t\\\n+  }\t\t\t\t\t\\\n+  if (inside)\t\t\t\t\\\n+    putc('\"', (f));\t\t\t\\\n+  putc('\\n', (f));\t\t\t\\\n+}\n+\n+/* Translate Motorola opcodes such as `jbeq'\n+   into SGS opcodes such as `beq.w'.\n+   Delete the `e' in `move...' and `fmove'.\n+   Change `ftst' to `ftest'.  */\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+  else if ((PTR)[0] == 'f')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n+\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n+      else if (!strncmp ((PTR), \"ftst\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4; }\t\t\\\n+}\n+\n+/* Prevent output of `gcc_compiled.:'.  */\n+\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+#else /* not HPUX_ASM */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tmovl #LP%d,d0\\n\\tjsr mcount\\n\", (LABELNO));\n+\n+#endif /* not HPUX_ASM */"}]}