{"sha": "7f3d273a22571f6dd578c079dbdba9340790c8c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YzZDI3M2EyMjU3MWY2ZGQ1NzhjMDc5ZGJkYmE5MzQwNzkwYzhjMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:25:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:25:43Z"}, "message": "[multiple changes]\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_strm.adb: Minor reformatting.\n\n2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Build_Wrapper): New procedure, subsidiary to\n\tAnalyze_Associations, to create a wrapper around operators that\n\tare actuals to formal subprograms. This is done in GNATProve\n\tmode in order to propagate the contracts of the operators to\n\tthe body of the instance.\n\nFrom-SVN: r213363", "tree": {"sha": "047edbc0cc4961fde196361f084e5fd0cdd7a076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/047edbc0cc4961fde196361f084e5fd0cdd7a076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f3d273a22571f6dd578c079dbdba9340790c8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3d273a22571f6dd578c079dbdba9340790c8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3d273a22571f6dd578c079dbdba9340790c8c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3d273a22571f6dd578c079dbdba9340790c8c2/comments", "author": null, "committer": null, "parents": [{"sha": "f4510e5e6dcb5fe385e5e636a95f87b2a8209361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4510e5e6dcb5fe385e5e636a95f87b2a8209361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4510e5e6dcb5fe385e5e636a95f87b2a8209361"}], "stats": {"total": 156, "additions": 154, "deletions": 2}, "files": [{"sha": "0b297d55ab6e6e479b51b64d5f364421b4b1cf77", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7f3d273a22571f6dd578c079dbdba9340790c8c2", "patch": "@@ -1,3 +1,15 @@\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_strm.adb: Minor reformatting.\n+\n+2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Build_Wrapper): New procedure, subsidiary to\n+\tAnalyze_Associations, to create a wrapper around operators that\n+\tare actuals to formal subprograms. This is done in GNATProve\n+\tmode in order to propagate the contracts of the operators to\n+\tthe body of the instance.\n+\n 2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_attr.adb (Analyze_Attribute, case 'Old):  The reference is"}, {"sha": "dfb5f0dd2e093583b674d04ed09615ecf7ccf1a3", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=7f3d273a22571f6dd578c079dbdba9340790c8c2", "patch": "@@ -155,7 +155,6 @@ package body Exp_Strm is\n       Decls := New_List;\n       Ranges := New_List;\n       Indx  := First_Index (Typ);\n-\n       for J in 1 .. Dim loop\n          Lnam := New_External_Name ('L', J);\n          Hnam := New_External_Name ('H', J);\n@@ -435,7 +434,6 @@ package body Exp_Strm is\n       Pnam : out Entity_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (Nod);\n-\n    begin\n       Pnam :=\n         Make_Defining_Identifier (Loc,\n@@ -636,6 +634,7 @@ package body Exp_Strm is\n                  Relocate_Node (Strm))));\n \n          Set_Do_Range_Check (Res);\n+\n          if Base_Type (P_Type) /= Base_Type (U_Type) then\n             Res := Unchecked_Convert_To (Base_Type (P_Type), Res);\n          end if;"}, {"sha": "2cae224bc2867358469abf660e7836513c3fc63c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3d273a22571f6dd578c079dbdba9340790c8c2/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=7f3d273a22571f6dd578c079dbdba9340790c8c2", "patch": "@@ -954,6 +954,11 @@ package body Sem_Ch12 is\n       --  In Ada 2005, indicates partial parameterization of a formal\n       --  package. As usual an other association must be last in the list.\n \n+      function Build_Wrapper (Formal : Entity_Id) return Node_Id;\n+      --  In GNATProve mode, create a wrapper function for actuals that are\n+      --  operators, in order to propagate their contract to the renaming\n+      --  declarations generated for them.\n+\n       procedure Check_Overloaded_Formal_Subprogram (Formal : Entity_Id);\n       --  Apply RM 12.3 (9): if a formal subprogram is overloaded, the instance\n       --  cannot have a named association for it. AI05-0025 extends this rule\n@@ -1001,6 +1006,126 @@ package body Sem_Ch12 is\n       --  anonymous types, the presence a formal equality will introduce an\n       --  implicit declaration for the corresponding inequality.\n \n+      -------------------\n+      -- Build_Wrapper --\n+      -------------------\n+\n+      function Build_Wrapper (Formal : Entity_Id) return Node_Id is\n+         Loc     : constant Source_Ptr := Sloc (I_Node);\n+         Op_Name : constant Name_Id := Chars (Formal);\n+         Typ     : constant Entity_Id := Etype (Formal);\n+\n+         Decl   : Node_Id;\n+         Expr   : Node_Id;\n+         F1, F2 : Entity_Id;\n+         Func   : Entity_Id;\n+         Spec   : Node_Id;\n+\n+         L, R   : Node_Id;\n+\n+      begin\n+         --  Create entities for wrapper function and its formals\n+\n+         F1 := Make_Temporary (Loc, 'A');\n+         F2 := Make_Temporary (Loc, 'B');\n+         L  := New_Occurrence_Of (F1, Loc);\n+         R  := New_Occurrence_Of (F2, Loc);\n+\n+         Func := Make_Temporary (Loc, 'F');\n+\n+         Spec := Make_Function_Specification (Loc,\n+               Defining_Unit_Name => Func,\n+\n+            Parameter_Specifications => New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => F1,\n+                Parameter_Type => Make_Identifier (Loc, Chars (Typ))),\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => F2,\n+                Parameter_Type => Make_Identifier (Loc, Chars (Typ)))),\n+\n+            Result_Definition => Make_Identifier (Loc, Chars (Typ)));\n+\n+         --  Build expression as an operator node that corresponds to the\n+         --  name of the actual, starting with binary operators.\n+\n+         if Op_Name = Name_Op_And then\n+            Expr := Make_Op_And (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Or then\n+            Expr := Make_Op_Or (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Xor then\n+            Expr := Make_Op_Xor (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Eq then\n+            Expr := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Ne then\n+            Expr := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Le then\n+            Expr := Make_Op_Le (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Gt then\n+            Expr := Make_Op_Gt (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Ge then\n+            Expr := Make_Op_Ge (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Lt then\n+            Expr := Make_Op_Lt (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Add then\n+            Expr := Make_Op_Add (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Subtract then\n+            Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Concat then\n+            Expr := Make_Op_Concat (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Multiply then\n+            Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Divide then\n+            Expr := Make_Op_Divide (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Mod then\n+            Expr := Make_Op_Mod (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Rem then\n+            Expr := Make_Op_Rem (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Expon then\n+            Expr := Make_Op_Expon (Loc, Left_Opnd => L, Right_Opnd => R);\n+\n+         --  Unary operators.\n+\n+         elsif Op_Name = Name_Op_Add\n+           and then No (Next_Formal (First_Formal (Actual)))\n+         then\n+            Expr := Make_Op_Plus (Loc, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Subtract\n+           and then No (Next_Formal (First_Formal (Actual)))\n+         then\n+            Expr := Make_Op_Minus (Loc, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Abs then\n+            Expr := Make_Op_Abs (Loc, Right_Opnd => R);\n+\n+         elsif Op_Name = Name_Op_Not then\n+            Expr := Make_Op_Not (Loc, Right_Opnd => R);\n+         end if;\n+\n+         Decl := Make_Expression_Function (Loc,\n+                    Specification => Spec,\n+                    Expression => Expr);\n+\n+         return Decl;\n+      end Build_Wrapper;\n+\n       ----------------------------------------\n       -- Check_Overloaded_Formal_Subprogram --\n       ----------------------------------------\n@@ -1521,6 +1646,22 @@ package body Sem_Ch12 is\n                        Instantiate_Formal_Subprogram\n                          (Formal, Match, Analyzed_Formal));\n \n+                     if GNATprove_Mode then\n+                        if Nkind (Match) = N_Operator_Symbol then\n+                           Append_To (Assoc,\n+                             Build_Wrapper\n+                               (Defining_Entity (Analyzed_Formal)));\n+\n+                        elsif Box_Present (Formal)\n+                           and then Nkind (Defining_Entity (Analyzed_Formal))\n+                             = N_Defining_Operator_Symbol\n+                        then\n+                           Append_To (Assoc,\n+                             Build_Wrapper\n+                               (Defining_Entity (Analyzed_Formal)));\n+                        end if;\n+                     end if;\n+\n                      --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package.\n "}]}