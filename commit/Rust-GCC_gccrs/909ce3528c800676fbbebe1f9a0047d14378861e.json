{"sha": "909ce3528c800676fbbebe1f9a0047d14378861e", "node_id": "C_kwDOANBUbNoAKDkwOWNlMzUyOGM4MDA2NzZmYmJlYmUxZjlhMDA0N2QxNDM3ODg2MWU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-02-28T14:27:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-16T08:42:03Z"}, "message": "[Ada] Fix implementation issues with equality for untagged record types\n\nThis moves the implementation of AI12-0101 + AI05-0123 from the expander\nto the semantic analyzer and completes the implementation of AI12-0413,\nwhich are both binding interpretations in Ada 2012, fixing a few bugs in\nthe process and removing a fair amount of duplicated code throughout.\n\ngcc/ada/\n\n\t* einfo-utils.adb (Remove_Entity): Fix couple of oversights.\n\t* exp_ch3.adb (Is_User_Defined_Equality): Delete.\n\t(User_Defined_Eq): Call Get_User_Defined_Equality.\n\t(Make_Eq_Body): Likewise.\n\t(Predefined_Primitive_Eq_Body): Call Is_User_Defined_Equality.\n\t* exp_ch4.adb (Build_Eq_Call): Call Get_User_Defined_Equality.\n\t(Is_Equality): Delete.\n\t(User_Defined_Primitive_Equality_Op): Likewise.\n\t(Find_Aliased_Equality): Call Is_User_Defined_Equality.\n\t(Expand_N_Op_Eq): Call Underlying_Type unconditionally.\n\tDo not implement AI12-0101 + AI05-0123 here.\n\t(Expand_Set_Membership): Call Resolve_Membership_Equality.\n\t* exp_ch6.adb (Expand_Call_Helper): Remove obsolete code.\n\t* sem_aux.ads (Is_Record_Or_Limited_Type): Delete.\n\t* sem_aux.adb (Is_Record_Or_Limited_Type): Likewise.\n\t* sem_ch4.ads (Nondispatching_Call_To_Abstract_Operation): Declare.\n\t* sem_ch4.adb (Analyze_Call): Call Call_Abstract_Operation.\n\t(Analyze_Membership_Op): Call Resolve_Membership_Equality.\n\t(Nondispatching_Call_To_Abstract_Operation): New procedure.\n\t(Remove_Abstract_Operations): Call it.\n\t* sem_ch6.adb (Check_Untagged_Equality): Remove obsolete error and\n\tcall Is_User_Defined_Equality.\n\t* sem_ch7.adb (Inspect_Untagged_Record_Completion): New procedure\n\timplementing AI12-0101 + AI05-0123.\n\t(Analyze_Package_Specification): Call it.\n\t(Declare_Inherited_Private_Subprograms): Minor tweak.\n\t(Uninstall_Declarations): Likewise.\n\t* sem_disp.adb (Check_Direct_Call): Adjust to new implementation\n\tof Is_User_Defined_Equality.\n\t* sem_res.ads (Resolve_Membership_Equality): Declare.\n\t* sem_res.adb (Resolve): Replace direct error handling with call to\n\tNondispatching_Call_To_Abstract_Operation\n\t(Resolve_Call): Likewise.\n\t(Resolve_Equality_Op): Likewise.  mplement AI12-0413.\n\t(Resolve_Membership_Equality): New procedure.\n\t(Resolve_Membership_Op): Call Get_User_Defined_Equality.\n\t* sem_util.ads (Get_User_Defined_Eq): Rename into...\n\t(Get_User_Defined_Equality): ...this.\n\t* sem_util.adb (Get_User_Defined_Eq): Rename into...\n\t(Get_User_Defined_Equality): ...this. Call Is_User_Defined_Equality.\n\t(Is_User_Defined_Equality): Also check the profile but remove tests\n\ton Comes_From_Source and Parent.\n\t* sinfo.ads (Generic_Parent_Type): Adjust field description.\n\t* uintp.ads (Ubool): Invoke user-defined equality in predicate.", "tree": {"sha": "1bf9a64c974a2716b5532be690c6534afa708a54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf9a64c974a2716b5532be690c6534afa708a54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/909ce3528c800676fbbebe1f9a0047d14378861e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909ce3528c800676fbbebe1f9a0047d14378861e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909ce3528c800676fbbebe1f9a0047d14378861e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909ce3528c800676fbbebe1f9a0047d14378861e/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a39b25f6f52f6eab159a096551e2576fa0890cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a39b25f6f52f6eab159a096551e2576fa0890cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a39b25f6f52f6eab159a096551e2576fa0890cd"}], "stats": {"total": 649, "additions": 317, "deletions": 332}, "files": [{"sha": "cf61ec7de2816bbbde91557ac3351876ab3961cf", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -2520,11 +2520,13 @@ package body Einfo.Utils is\n \n       elsif Id = First then\n          Set_First_Entity (Scop, Next);\n+         Set_Prev_Entity (Next, Empty);  --  Empty <-- First_Entity\n \n       --  The eliminated entity was the tail of the entity chain\n \n       elsif Id = Last then\n          Set_Last_Entity (Scop, Prev);\n+         Set_Next_Entity (Prev, Empty);  --  Last_Entity --> Empty\n \n       --  Otherwise the eliminated entity comes from the middle of the entity\n       --  chain."}, {"sha": "f2deff74522d99cf57f943da6c14e204c10e639e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 27, "deletions": 66, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -271,9 +271,6 @@ package body Exp_Ch3 is\n    --  in a case statement, recursively. This latter pattern may occur for the\n    --  initialization procedure of an unchecked union.\n \n-   function Is_User_Defined_Equality (Prim : Node_Id) return Boolean;\n-   --  Returns true if Prim is a user defined equality function\n-\n    function Make_Eq_Body\n      (Typ     : Entity_Id;\n       Eq_Name : Name_Id) return Node_Id;\n@@ -4487,7 +4484,6 @@ package body Exp_Ch3 is\n       Comp     : Entity_Id;\n       Decl     : Node_Id;\n       Op       : Entity_Id;\n-      Prim     : Elmt_Id;\n       Eq_Op    : Entity_Id;\n \n       function User_Defined_Eq (T : Entity_Id) return Entity_Id;\n@@ -4506,7 +4502,7 @@ package body Exp_Ch3 is\n          if Present (Op) then\n             return Op;\n          else\n-            return Get_User_Defined_Eq (T);\n+            return Get_User_Defined_Equality (T);\n          end if;\n       end User_Defined_Eq;\n \n@@ -4532,23 +4528,14 @@ package body Exp_Ch3 is\n       --  If there is a user-defined equality for the type, we do not create\n       --  the implicit one.\n \n-      Prim := First_Elmt (Collect_Primitive_Operations (Typ));\n-      Eq_Op := Empty;\n-      while Present (Prim) loop\n-         if Chars (Node (Prim)) = Name_Op_Eq\n-           and then Comes_From_Source (Node (Prim))\n-\n-         --  Don't we also need to check formal types and return type as in\n-         --  User_Defined_Eq above???\n-\n-         then\n-            Eq_Op := Node (Prim);\n+      Eq_Op := Get_User_Defined_Equality (Typ);\n+      if Present (Eq_Op) then\n+         if Comes_From_Source (Eq_Op) then\n             Build_Eq := False;\n-            exit;\n+         else\n+            Eq_Op := Empty;\n          end if;\n-\n-         Next_Elmt (Prim);\n-      end loop;\n+      end if;\n \n       --  If the type is derived, inherit the operation, if present, from the\n       --  parent type. It may have been declared after the type derivation. If\n@@ -4557,35 +4544,28 @@ package body Exp_Ch3 is\n       --  flags. Ditto for inequality.\n \n       if No (Eq_Op) and then Is_Derived_Type (Typ) then\n-         Prim := First_Elmt (Collect_Primitive_Operations (Etype (Typ)));\n-         while Present (Prim) loop\n-            if Chars (Node (Prim)) = Name_Op_Eq then\n-               Copy_TSS (Node (Prim), Typ);\n-               Build_Eq := False;\n+         Eq_Op := Get_User_Defined_Equality (Etype (Typ));\n+         if Present (Eq_Op) then\n+            Copy_TSS (Eq_Op, Typ);\n+            Build_Eq := False;\n \n-               declare\n-                  Op    : constant Entity_Id := User_Defined_Eq (Typ);\n-                  Eq_Op : constant Entity_Id := Node (Prim);\n-                  NE_Op : constant Entity_Id := Next_Entity (Eq_Op);\n+            declare\n+               Op    : constant Entity_Id := User_Defined_Eq (Typ);\n+               NE_Op : constant Entity_Id := Next_Entity (Eq_Op);\n \n-               begin\n-                  if Present (Op) then\n-                     Set_Alias (Op, Eq_Op);\n-                     Set_Is_Abstract_Subprogram\n-                       (Op, Is_Abstract_Subprogram (Eq_Op));\n+            begin\n+               if Present (Op) then\n+                  Set_Alias (Op, Eq_Op);\n+                  Set_Is_Abstract_Subprogram\n+                    (Op, Is_Abstract_Subprogram (Eq_Op));\n \n-                     if Chars (Next_Entity (Op)) = Name_Op_Ne then\n-                        Set_Is_Abstract_Subprogram\n-                          (Next_Entity (Op), Is_Abstract_Subprogram (NE_Op));\n-                     end if;\n+                  if Chars (Next_Entity (Op)) = Name_Op_Ne then\n+                     Set_Is_Abstract_Subprogram\n+                       (Next_Entity (Op), Is_Abstract_Subprogram (NE_Op));\n                   end if;\n-               end;\n-\n-               exit;\n-            end if;\n-\n-            Next_Elmt (Prim);\n-         end loop;\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       --  If not inherited and not user-defined, build body as for a type with\n@@ -9828,18 +9808,6 @@ package body Exp_Ch3 is\n       return True;\n    end Is_Null_Statement_List;\n \n-   ------------------------------\n-   -- Is_User_Defined_Equality --\n-   ------------------------------\n-\n-   function Is_User_Defined_Equality (Prim : Node_Id) return Boolean is\n-   begin\n-      return Chars (Prim) = Name_Op_Eq\n-        and then Etype (First_Formal (Prim)) =\n-                 Etype (Next_Formal (First_Formal (Prim)))\n-        and then Base_Type (Etype (Prim)) = Standard_Boolean;\n-   end Is_User_Defined_Equality;\n-\n    ----------------------------------------\n    -- Make_Controlling_Function_Wrappers --\n    ----------------------------------------\n@@ -11212,15 +11180,8 @@ package body Exp_Ch3 is\n \n          Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n          while Present (Prim) loop\n-            if Chars (Node (Prim)) = Name_Op_Eq\n+            if Is_User_Defined_Equality (Node (Prim))\n               and then not Is_Internal (Node (Prim))\n-\n-              --  The predefined equality primitive must have exactly two\n-              --  formals whose type is this tagged type.\n-\n-              and then Number_Formals (Node (Prim)) = 2\n-              and then Etype (First_Formal (Node (Prim))) = Tag_Typ\n-              and then Etype (Last_Formal (Node (Prim))) = Tag_Typ\n             then\n                Eq_Needed := False;\n                Eq_Name := No_Name;\n@@ -11236,7 +11197,7 @@ package body Exp_Ch3 is\n \n          Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n          while Present (Prim) loop\n-            if Chars (Node (Prim)) = Name_Op_Eq\n+            if Is_User_Defined_Equality (Node (Prim))\n               and then Is_Internal (Node (Prim))\n             then\n                Eq_Needed := True;"}, {"sha": "99fac5f8b6b5655fa35f4908c22a06af058e8afe", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 145, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -425,36 +425,21 @@ package body Exp_Ch4 is\n       Lhs : Node_Id;\n       Rhs : Node_Id) return Node_Id\n    is\n-      Prim   : Node_Id;\n-      Prim_E : Elmt_Id;\n+      Eq : constant Entity_Id := Get_User_Defined_Equality (Typ);\n \n    begin\n-      Prim_E := First_Elmt (Collect_Primitive_Operations (Typ));\n-      while Present (Prim_E) loop\n-         Prim := Node (Prim_E);\n+      if Present (Eq) then\n+         if Is_Abstract_Subprogram (Eq) then\n+            return Make_Raise_Program_Error (Loc,\n+               Reason =>  PE_Explicit_Raise);\n \n-         --  Locate primitive equality with the right signature\n-\n-         if Chars (Prim) = Name_Op_Eq\n-           and then Etype (First_Formal (Prim)) =\n-                    Etype (Next_Formal (First_Formal (Prim)))\n-           and then Etype (Prim) = Standard_Boolean\n-         then\n-            if Is_Abstract_Subprogram (Prim) then\n-               return\n-                 Make_Raise_Program_Error (Loc,\n-                   Reason => PE_Explicit_Raise);\n-\n-            else\n-               return\n-                 Make_Function_Call (Loc,\n-                   Name                   => New_Occurrence_Of (Prim, Loc),\n-                   Parameter_Associations => New_List (Lhs, Rhs));\n-            end if;\n+         else\n+            return\n+              Make_Function_Call (Loc,\n+                Name                   => New_Occurrence_Of (Eq, Loc),\n+                Parameter_Associations => New_List (Lhs, Rhs));\n          end if;\n-\n-         Next_Elmt (Prim_E);\n-      end loop;\n+      end if;\n \n       --  If not found, predefined operation will be used\n \n@@ -7817,21 +7802,10 @@ package body Exp_Ch4 is\n       --  build and analyze call, adding conversions if the operation is\n       --  inherited.\n \n-      function Is_Equality (Subp : Entity_Id;\n-                            Typ  : Entity_Id := Empty) return Boolean;\n-      --  Determine whether arbitrary Entity_Id denotes a function with the\n-      --  right name and profile for an equality op, specifically for the\n-      --  base type Typ if Typ is nonempty.\n-\n       function Find_Equality (Prims : Elist_Id) return Entity_Id;\n       --  Find a primitive equality function within primitive operation list\n       --  Prims.\n \n-      function User_Defined_Primitive_Equality_Op\n-        (Typ : Entity_Id) return Entity_Id;\n-      --  Find a user-defined primitive equality function for a given untagged\n-      --  record type, ignoring visibility. Return Empty if no such op found.\n-\n       function Has_Unconstrained_UU_Component (Typ : Entity_Id) return Boolean;\n       --  Determines whether a type has a subcomponent of an unconstrained\n       --  Unchecked_Union subtype. Typ is a record type.\n@@ -8080,43 +8054,6 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Standard_Boolean, Suppress => All_Checks);\n       end Build_Equality_Call;\n \n-      -----------------\n-      -- Is_Equality --\n-      -----------------\n-\n-      function Is_Equality (Subp : Entity_Id;\n-                            Typ  : Entity_Id := Empty) return Boolean is\n-         Formal_1 : Entity_Id;\n-         Formal_2 : Entity_Id;\n-      begin\n-         --  The equality function carries name \"=\", returns Boolean, and has\n-         --  exactly two formal parameters of an identical type.\n-\n-         if Ekind (Subp) = E_Function\n-           and then Chars (Subp) = Name_Op_Eq\n-           and then Base_Type (Etype (Subp)) = Standard_Boolean\n-         then\n-            Formal_1 := First_Formal (Subp);\n-            Formal_2 := Empty;\n-\n-            if Present (Formal_1) then\n-               Formal_2 := Next_Formal (Formal_1);\n-            end if;\n-\n-            return\n-              Present (Formal_1)\n-                and then Present (Formal_2)\n-                and then No (Next_Formal (Formal_2))\n-                and then Base_Type (Etype (Formal_1)) =\n-                         Base_Type (Etype (Formal_2))\n-                and then\n-                  (not Present (Typ)\n-                    or else Implementation_Base_Type (Etype (Formal_1)) = Typ);\n-         end if;\n-\n-         return False;\n-      end Is_Equality;\n-\n       -------------------\n       -- Find_Equality --\n       -------------------\n@@ -8139,7 +8076,7 @@ package body Exp_Ch4 is\n \n             Candid := Prim;\n             while Present (Candid) loop\n-               if Is_Equality (Candid) then\n+               if Is_User_Defined_Equality (Candid) then\n                   return Candid;\n                end if;\n \n@@ -8178,43 +8115,6 @@ package body Exp_Ch4 is\n          return Eq_Prim;\n       end Find_Equality;\n \n-      ----------------------------------------\n-      -- User_Defined_Primitive_Equality_Op --\n-      ----------------------------------------\n-\n-      function User_Defined_Primitive_Equality_Op\n-        (Typ : Entity_Id) return Entity_Id\n-      is\n-         Enclosing_Scope : constant Entity_Id := Scope (Typ);\n-         E : Entity_Id;\n-      begin\n-         for Private_Entities in Boolean loop\n-            if Private_Entities then\n-               if Ekind (Enclosing_Scope) /= E_Package then\n-                  exit;\n-               end if;\n-               E := First_Private_Entity (Enclosing_Scope);\n-\n-            else\n-               E := First_Entity (Enclosing_Scope);\n-            end if;\n-\n-            while Present (E) loop\n-               if Is_Equality (E, Typ) then\n-                  return E;\n-               end if;\n-               Next_Entity (E);\n-            end loop;\n-         end loop;\n-\n-         if Is_Derived_Type (Typ) then\n-            return User_Defined_Primitive_Equality_Op\n-                     (Implementation_Base_Type (Etype (Typ)));\n-         end if;\n-\n-         return Empty;\n-      end User_Defined_Primitive_Equality_Op;\n-\n       ------------------------------------\n       -- Has_Unconstrained_UU_Component --\n       ------------------------------------\n@@ -8358,14 +8258,7 @@ package body Exp_Ch4 is\n \n       --  Deal with private types\n \n-      Typl := A_Typ;\n-\n-      if Ekind (Typl) = E_Private_Type then\n-         Typl := Underlying_Type (Typl);\n-\n-      elsif Ekind (Typl) = E_Private_Subtype then\n-         Typl := Underlying_Type (Base_Type (Typl));\n-      end if;\n+      Typl := Underlying_Type (A_Typ);\n \n       --  It may happen in error situations that the underlying type is not\n       --  set. The error will be detected later, here we just defend the\n@@ -8529,15 +8422,6 @@ package body Exp_Ch4 is\n                  (Find_Equality (Primitive_Operations (Typl)));\n             end if;\n \n-         --  See AI12-0101 (which only removes a legality rule) and then\n-         --  AI05-0123 (which then applies in the previously illegal case).\n-         --  AI12-0101 is a binding interpretation.\n-\n-         elsif Ada_Version >= Ada_2012\n-           and then Present (User_Defined_Primitive_Equality_Op (Typl))\n-         then\n-            Build_Equality_Call (User_Defined_Primitive_Equality_Op (Typl));\n-\n          --  Ada 2005 (AI-216): Program_Error is raised when evaluating the\n          --  predefined equality operator for a type which has a subcomponent\n          --  of an Unchecked_Union type whose nominal subtype is unconstrained.\n@@ -13132,23 +13016,11 @@ package body Exp_Ch4 is\n          if (Is_Entity_Name (Alt) and then Is_Type (Entity (Alt)))\n            or else Nkind (Alt) = N_Range\n          then\n-            Cond :=\n-              Make_In (Sloc (Alt),\n-                Left_Opnd  => L,\n-                Right_Opnd => R);\n-         else\n-            Cond :=\n-              Make_Op_Eq (Sloc (Alt),\n-                Left_Opnd  => L,\n-                Right_Opnd => R);\n-\n-            if Is_Record_Or_Limited_Type (Etype (Alt)) then\n+            Cond := Make_In (Sloc (Alt), Left_Opnd  => L, Right_Opnd => R);\n \n-               --  We reset the Entity in order to use the primitive equality\n-               --  of the type, as per RM 4.5.2 (28.1/4).\n-\n-               Set_Entity (Cond, Empty);\n-            end if;\n+         else\n+            Cond := Make_Op_Eq (Sloc (Alt), Left_Opnd  => L, Right_Opnd => R);\n+            Resolve_Membership_Equality (Cond, Etype (Alt));\n          end if;\n \n          return Cond;"}, {"sha": "db5ec357bea734c4aeb91ac6c2adba3c86824b5d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -4475,16 +4475,6 @@ package body Exp_Ch6 is\n \n          Set_Entity (Name (Call_Node), Parent_Subp);\n \n-         --  Move this check to sem???\n-\n-         if Is_Abstract_Subprogram (Parent_Subp)\n-           and then not In_Instance\n-         then\n-            Error_Msg_NE\n-              (\"cannot call abstract subprogram &!\",\n-               Name (Call_Node), Parent_Subp);\n-         end if;\n-\n          --  Inspect all formals of derived subprogram Subp. Compare parameter\n          --  types with the parent subprogram and check whether an actual may\n          --  need a type conversion to the corresponding formal of the parent"}, {"sha": "ffbfc712b31207801ad5de633d606fd33dd82ba5", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -1261,15 +1261,6 @@ package body Sem_Aux is\n       end if;\n    end Is_Limited_View;\n \n-   -------------------------------\n-   -- Is_Record_Or_Limited_Type --\n-   -------------------------------\n-\n-   function Is_Record_Or_Limited_Type (Typ : Entity_Id) return Boolean is\n-   begin\n-      return Is_Record_Type (Typ) or else Is_Limited_Type (Typ);\n-   end Is_Record_Or_Limited_Type;\n-\n    ----------------------\n    -- Nearest_Ancestor --\n    ----------------------"}, {"sha": "66cbcfbb97c6f969840831826efa341380eb3c10", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -334,9 +334,6 @@ package Sem_Aux is\n    --  these types). This older routine overlaps with the previous one, this\n    --  should be cleaned up???\n \n-   function Is_Record_Or_Limited_Type (Typ : Entity_Id) return Boolean;\n-   --  Return True if Typ requires is a record or limited type.\n-\n    function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id;\n    --  Given a subtype Typ, this function finds out the nearest ancestor from\n    --  which constraints and predicates are inherited. There is no simple link"}, {"sha": "8fe20772a691e278b436baa87c3a336d514260c7", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -1253,19 +1253,11 @@ package body Sem_Ch4 is\n          --  If the nonoverloaded interpretation is a call to an abstract\n          --  nondispatching operation, then flag an error and return.\n \n-         --  Should this be incorporated in Remove_Abstract_Operations (which\n-         --  currently only deals with cases where the name is overloaded)? ???\n-\n          if Is_Overloadable (Nam_Ent)\n            and then Is_Abstract_Subprogram (Nam_Ent)\n            and then not Is_Dispatching_Operation (Nam_Ent)\n          then\n-            Set_Etype (N, Any_Type);\n-\n-            Error_Msg_Sloc := Sloc (Nam_Ent);\n-            Error_Msg_NE\n-              (\"cannot call abstract operation& declared#\", N, Nam_Ent);\n-\n+            Nondispatching_Call_To_Abstract_Operation (N, Nam_Ent);\n             return;\n          end if;\n \n@@ -3386,18 +3378,11 @@ package body Sem_Ch4 is\n             Check_Fully_Declared (Entity (R), R);\n \n          elsif Ada_Version >= Ada_2012 and then Find_Interp then\n-            if Nkind (N) = N_In then\n-               Op := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n-            else\n-               Op := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n-            end if;\n+            Op := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n+            Resolve_Membership_Equality (Op, Etype (L));\n \n-            if Is_Record_Or_Limited_Type (Etype (L)) then\n-\n-               --  We reset the Entity in order to use the primitive equality\n-               --  of the type, as per RM 4.5.2 (28.1/4).\n-\n-               Set_Entity (Op, Empty);\n+            if Nkind (N) = N_Not_In then\n+               Op := Make_Op_Not (Loc, Op);\n             end if;\n \n             Rewrite (N, Op);\n@@ -7872,6 +7857,42 @@ package body Sem_Ch4 is\n       return Etype (N) /= Any_Type;\n    end Has_Possible_Literal_Aspects;\n \n+   -----------------------------------------------\n+   -- Nondispatching_Call_To_Abstract_Operation --\n+   -----------------------------------------------\n+\n+   procedure Nondispatching_Call_To_Abstract_Operation\n+     (N : Node_Id;\n+      Abstract_Op : Entity_Id)\n+   is\n+      Typ : constant Entity_Id := Etype (N);\n+\n+   begin\n+      --  In an instance body, this is a runtime check, but one we know will\n+      --  fail, so give an appropriate warning. As usual this kind of warning\n+      --  is an error in SPARK mode.\n+\n+      Error_Msg_Sloc := Sloc (Abstract_Op);\n+\n+      if In_Instance_Body and then SPARK_Mode /= On then\n+         Error_Msg_NE\n+           (\"??cannot call abstract operation& declared#\",\n+            N, Abstract_Op);\n+         Error_Msg_N (\"\\Program_Error [??\", N);\n+         Rewrite (N,\n+           Make_Raise_Program_Error (Sloc (N),\n+           Reason => PE_Explicit_Raise));\n+         Analyze (N);\n+         Set_Etype (N, Typ);\n+\n+      else\n+         Error_Msg_NE\n+           (\"cannot call abstract operation& declared#\",\n+            N, Abstract_Op);\n+         Set_Etype (N, Any_Type);\n+      end if;\n+   end Nondispatching_Call_To_Abstract_Operation;\n+\n    ----------------------------------------------\n    -- Possible_Type_For_Conditional_Expression --\n    ----------------------------------------------\n@@ -8191,10 +8212,7 @@ package body Sem_Ch4 is\n \n                --  Removal of abstract operation left no viable candidate\n \n-               Set_Etype (N, Any_Type);\n-               Error_Msg_Sloc := Sloc (Abstract_Op);\n-               Error_Msg_NE\n-                 (\"cannot call abstract operation& declared#\", N, Abstract_Op);\n+               Nondispatching_Call_To_Abstract_Operation (N, Abstract_Op);\n \n             --  In Ada 2005, an abstract operation may disable predefined\n             --  operators. Since the context is not yet known, we mark the"}, {"sha": "ed2b132aaeb02fba0231e558021e63a49e927fc5", "filename": "gcc/ada/sem_ch4.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -67,6 +67,12 @@ package Sem_Ch4  is\n    --  The resolution of the construct requires some semantic information\n    --  on the prefix and the indexes.\n \n+   procedure Nondispatching_Call_To_Abstract_Operation\n+     (N           : Node_Id;\n+      Abstract_Op : Entity_Id);\n+   --  Give an error, or a warning and rewrite N to raise Program_Error because\n+   --  it is a nondispatching call to an abstract operation.\n+\n    function Try_Object_Operation\n      (N                : Node_Id;\n       CW_Test_Only     : Boolean := False;"}, {"sha": "dbcb2556fe3d9e186ae15a1fb00c2757049e845e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -190,14 +190,12 @@ package body Sem_Ch6 is\n    --  in posting the warning message.\n \n    procedure Check_Untagged_Equality (Eq_Op : Entity_Id);\n-   --  In Ada 2012, a primitive equality operator on an untagged record type\n-   --  must appear before the type is frozen, and have the same visibility as\n-   --  that of the type. This procedure checks that this rule is met, and\n-   --  otherwise emits an error on the subprogram declaration and a warning\n-   --  on the earlier freeze point if it is easy to locate. In Ada 2012 mode,\n-   --  this routine outputs errors (or warnings if -gnatd.E is set). In earlier\n-   --  versions of Ada, warnings are output if Warn_On_Ada_2012_Incompatibility\n-   --  is set, otherwise the call has no effect.\n+   --  In Ada 2012, a primitive equality operator for an untagged record type\n+   --  must appear before the type is frozen. This procedure checks that this\n+   --  rule is met, and otherwise gives an error on the subprogram declaration\n+   --  and a warning on the earlier freeze point if it is easy to pinpoint. In\n+   --  earlier versions of Ada, the call has not effect, unless compatibility\n+   --  warnings are requested by means of Warn_On_Ada_2012_Incompatibility.\n \n    procedure Enter_Overloaded_Entity (S : Entity_Id);\n    --  This procedure makes S, a new overloaded entity, into the first visible\n@@ -9511,12 +9509,12 @@ package body Sem_Ch6 is\n \n    begin\n       --  This check applies only if we have a subprogram declaration with an\n-      --  untagged record type that is conformant to the predefined op.\n+      --  untagged record type that is conformant to the predefined operator.\n \n       if Nkind (Decl) /= N_Subprogram_Declaration\n         or else not Is_Record_Type (Typ)\n         or else Is_Tagged_Type (Typ)\n-        or else Etype (Next_Formal (First_Formal (Eq_Op))) /= Typ\n+        or else not Is_User_Defined_Equality (Eq_Op)\n       then\n          return;\n       end if;\n@@ -9628,22 +9626,7 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n-      --  Here if type is not frozen yet. It is illegal to have a primitive\n-      --  equality declared in the private part if the type is visible\n-      --  (RM 4.5.2(9.8)).\n-\n-      elsif not In_Same_List (Parent (Typ), Decl)\n-        and then not Is_Limited_Type (Typ)\n-      then\n-         if Ada_Version >= Ada_2012 then\n-            Error_Msg_N\n-              (\"equality operator appears too late<<\", Eq_Op);\n-         else\n-            Error_Msg_N\n-              (\"equality operator appears too late (Ada 2012)?y?\", Eq_Op);\n-         end if;\n-\n-      --  Finally check for AI12-0352: declaration of a user-defined primitive\n+      --  Now check for AI12-0352: the declaration of a user-defined primitive\n       --  equality operation for a record type T is illegal if it occurs after\n       --  a type has been derived from T.\n "}, {"sha": "4ba1d32cf7c056670a988e7e8f952bb499ef5415", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 94, "deletions": 7, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -1313,6 +1313,11 @@ package body Sem_Ch7 is\n       --  Reject completion of an incomplete or private type declarations\n       --  having a known discriminant part by an unchecked union.\n \n+      procedure Inspect_Untagged_Record_Completion (Decls : List_Id);\n+      --  Find out whether a nonlimited untagged record completion has got a\n+      --  primitive equality operator and, if so, make it so that it will be\n+      --  used as the predefined operator of the private view of the record.\n+\n       procedure Install_Parent_Private_Declarations (Inst_Id : Entity_Id);\n       --  Given the package entity of a generic package instantiation or\n       --  formal package whose corresponding generic is a child unit, installs\n@@ -1437,7 +1442,7 @@ package body Sem_Ch7 is\n          Decl := First (Decls);\n          while Present (Decl) loop\n \n-            --  We are looking at an incomplete or private type declaration\n+            --  We are looking for an incomplete or private type declaration\n             --  with a known_discriminant_part whose full view is an\n             --  Unchecked_Union. The seemingly useless check with Is_Type\n             --  prevents cascaded errors when routines defined only for type\n@@ -1461,6 +1466,79 @@ package body Sem_Ch7 is\n          end loop;\n       end Inspect_Unchecked_Union_Completion;\n \n+      ----------------------------------------\n+      -- Inspect_Untagged_Record_Completion --\n+      ----------------------------------------\n+\n+      procedure Inspect_Untagged_Record_Completion (Decls : List_Id) is\n+         Decl : Node_Id;\n+\n+      begin\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n+\n+            --  We are looking for a full type declaration of an untagged\n+            --  record with a private declaration and primitive operations.\n+\n+            if Nkind (Decl) in N_Full_Type_Declaration\n+              and then Is_Record_Type (Defining_Identifier (Decl))\n+              and then not Is_Limited_Type (Defining_Identifier (Decl))\n+              and then not Is_Tagged_Type (Defining_Identifier (Decl))\n+              and then Has_Private_Declaration (Defining_Identifier (Decl))\n+              and then Has_Primitive_Operations (Defining_Identifier (Decl))\n+            then\n+               declare\n+                  Prim_List : constant Elist_Id :=\n+                     Collect_Primitive_Operations (Defining_Identifier (Decl));\n+\n+                  Ne_Id   : Entity_Id;\n+                  Op_Decl : Node_Id;\n+                  Op_Id   : Entity_Id;\n+                  Prim    : Elmt_Id;\n+\n+               begin\n+                  Prim := First_Elmt (Prim_List);\n+                  while Present (Prim) loop\n+                     Op_Id   := Node (Prim);\n+                     Op_Decl := Declaration_Node (Op_Id);\n+                     if Nkind (Op_Decl) in N_Subprogram_Specification then\n+                        Op_Decl := Parent (Op_Decl);\n+                     end if;\n+\n+                     --  We are looking for an equality operator immediately\n+                     --  visible and declared in the private part followed by\n+                     --  the synthesized inequality operator.\n+\n+                     if Is_User_Defined_Equality (Op_Id)\n+                       and then Is_Immediately_Visible (Op_Id)\n+                       and then List_Containing (Op_Decl) = Decls\n+                     then\n+                        Ne_Id := Next_Entity (Op_Id);\n+                        pragma Assert (Ekind (Ne_Id) = E_Function\n+                          and then Corresponding_Equality (Ne_Id) = Op_Id);\n+\n+                        --  Move them from the private part of the entity list\n+                        --  up to the end of the visible part of the same list.\n+\n+                        Remove_Entity (Op_Id);\n+                        Remove_Entity (Ne_Id);\n+\n+                        Link_Entities\n+                          (Prev_Entity (First_Private_Entity (Id)), Op_Id);\n+                        Link_Entities (Op_Id, Ne_Id);\n+                        Link_Entities (Ne_Id, First_Private_Entity (Id));\n+                        exit;\n+                     end if;\n+\n+                     Next_Elmt (Prim);\n+                  end loop;\n+               end;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end Inspect_Untagged_Record_Completion;\n+\n       -----------------------------------------\n       -- Install_Parent_Private_Declarations --\n       -----------------------------------------\n@@ -1718,7 +1796,7 @@ package body Sem_Ch7 is\n       end if;\n \n       --  Analyze private part if present. The flag In_Private_Part is reset\n-      --  in End_Package_Scope.\n+      --  in Uninstall_Declarations.\n \n       L := Last_Entity (Id);\n \n@@ -1815,6 +1893,14 @@ package body Sem_Ch7 is\n          Inspect_Unchecked_Union_Completion (Priv_Decls);\n       end if;\n \n+      --  Implement AI12-0101 (which only removes a legality rule) and then\n+      --  AI05-0123 (which directly applies in the previously illegal case)\n+      --  in Ada 2012. Note that AI12-0101 is a binding interpretation.\n+\n+      if Present (Priv_Decls) and then Ada_Version >= Ada_2012 then\n+         Inspect_Untagged_Record_Completion (Priv_Decls);\n+      end if;\n+\n       if Ekind (Id) = E_Generic_Package\n         and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n         and then Present (Priv_Decls)\n@@ -2172,9 +2258,8 @@ package body Sem_Ch7 is\n                   --  a derived scalar type). Further declarations cannot\n                   --  include inherited operations of the type.\n \n-                  if Present (Prim_Op) then\n-                     exit when Ekind (Prim_Op) not in Overloadable_Kind;\n-                  end if;\n+                  exit when Present (Prim_Op)\n+                    and then not Is_Overloadable (Prim_Op);\n                end loop;\n             end if;\n          end if;\n@@ -3093,10 +3178,12 @@ package body Sem_Ch7 is\n \n       if not In_Private_Part (P) then\n          return;\n-      else\n-         Set_In_Private_Part (P, False);\n       end if;\n \n+      --  Reset the flag now\n+\n+      Set_In_Private_Part (P, False);\n+\n       --  Make private entities invisible and exchange full and private\n       --  declarations for private types. Id is now the first private entity\n       --  in the package."}, {"sha": "2ab14439e945de32702c3c142d0d48dd75379b64", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -566,7 +566,10 @@ package body Sem_Disp is\n          --  when it is user-defined.\n \n          if Is_Predefined_Dispatching_Operation (Subp_Entity)\n-           and then not Is_User_Defined_Equality (Subp_Entity)\n+           and then not (Is_User_Defined_Equality (Subp_Entity)\n+                          and then Comes_From_Source (Subp_Entity)\n+                          and then Nkind (Parent (Subp_Entity)) =\n+                                                      N_Function_Specification)\n          then\n             return;\n          end if;"}, {"sha": "12735daab6d4344d3bed7a72df346b7b9708d42c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 81, "deletions": 19, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -3215,11 +3215,11 @@ package body Sem_Res is\n          then\n             Get_First_Interp (N, I, It);\n             while Present (It.Typ) loop\n-               if Present (It.Abstract_Op) and then\n-                 Etype (It.Abstract_Op) = Typ\n+               if Present (It.Abstract_Op)\n+                 and then Etype (It.Abstract_Op) = Typ\n                then\n-                  Error_Msg_NE\n-                    (\"cannot call abstract subprogram &!\", N, It.Abstract_Op);\n+                  Nondispatching_Call_To_Abstract_Operation\n+                    (N, It.Abstract_Op);\n                   return;\n                end if;\n \n@@ -7063,24 +7063,19 @@ package body Sem_Res is\n       --  If the subprogram is a primitive operation, check whether or not\n       --  it is a correct dispatching call.\n \n-      if Is_Overloadable (Nam)\n-        and then Is_Dispatching_Operation (Nam)\n-      then\n+      if Is_Overloadable (Nam) and then Is_Dispatching_Operation (Nam) then\n          Check_Dispatching_Call (N);\n \n-      elsif Ekind (Nam) /= E_Subprogram_Type\n-        and then Is_Abstract_Subprogram (Nam)\n-        and then not In_Instance\n-      then\n-         Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Nam);\n+      --  If the subprogram is an abstract operation, then flag an error\n+\n+      elsif Is_Overloadable (Nam) and then Is_Abstract_Subprogram (Nam) then\n+         Nondispatching_Call_To_Abstract_Operation (N, Nam);\n       end if;\n \n       --  If this is a dispatching call, generate the appropriate reference,\n       --  for better source navigation in GNAT Studio.\n \n-      if Is_Overloadable (Nam)\n-        and then Present (Controlling_Argument (N))\n-      then\n+      if Is_Overloadable (Nam) and then Present (Controlling_Argument (N)) then\n          Generate_Reference (Nam, Subp, 'R');\n \n       --  Normal case, not a dispatching call: generate a call reference\n@@ -8918,6 +8913,41 @@ package body Sem_Res is\n          Resolve (L, T);\n          Resolve (R, T);\n \n+         --  AI12-0413: user-defined primitive equality of an untagged record\n+         --  type hides the predefined equality operator, including within a\n+         --  generic, and if it is declared abstract, results in an illegal\n+         --  instance if the operator is used in the spec, or in the raising\n+         --  of Program_Error if used in the body of an instance.\n+\n+         if Nkind (N) = N_Op_Eq\n+           and then In_Instance\n+           and then Ada_Version >= Ada_2012\n+         then\n+            declare\n+               U : constant Entity_Id := Underlying_Type (T);\n+\n+               Eq : Entity_Id;\n+\n+            begin\n+               if Present (U)\n+                 and then Is_Record_Type (U)\n+                 and then not Is_Tagged_Type (U)\n+               then\n+                  Eq := Get_User_Defined_Equality (T);\n+\n+                  if Present (Eq) then\n+                     if Is_Abstract_Subprogram (Eq) then\n+                        Nondispatching_Call_To_Abstract_Operation (N, Eq);\n+                     else\n+                        Rewrite_Operator_As_Call (N, Eq);\n+                     end if;\n+\n+                     return;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n          --  If the unique type is a class-wide type then it will be expanded\n          --  into a dispatching call to the predefined primitive. Therefore we\n          --  check here for potential violation of such restriction.\n@@ -8977,16 +9007,16 @@ package body Sem_Res is\n          if Nkind (N) = N_Op_Eq\n            or else Comes_From_Source (Entity (N))\n            or else Ekind (Entity (N)) = E_Operator\n-           or else Is_Intrinsic_Subprogram\n-                     (Corresponding_Equality (Entity (N)))\n+           or else\n+             Is_Intrinsic_Subprogram (Corresponding_Equality (Entity (N)))\n          then\n             Analyze_Dimension (N);\n             Eval_Relational_Op (N);\n \n          elsif Nkind (N) = N_Op_Ne\n            and then Is_Abstract_Subprogram (Entity (N))\n          then\n-            Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n+            Nondispatching_Call_To_Abstract_Operation (N, Entity (N));\n          end if;\n       end if;\n    end Resolve_Equality_Op;\n@@ -9837,6 +9867,38 @@ package body Sem_Res is\n       Eval_Logical_Op (N);\n    end Resolve_Logical_Op;\n \n+   ---------------------------------\n+   -- Resolve_Membership_Equality --\n+   ---------------------------------\n+\n+   procedure Resolve_Membership_Equality (N : Node_Id; Typ : Entity_Id) is\n+      Utyp : constant Entity_Id := Underlying_Type (Typ);\n+\n+   begin\n+      --  RM 4.5.2(4.1/3): if the type is limited, then it shall have a visible\n+      --  primitive equality operator. This means that we can use the regular\n+      --  visibility-based resolution and reset Entity in order to trigger it.\n+\n+      if Is_Limited_Type (Typ) then\n+         Set_Entity (N, Empty);\n+\n+      --  RM 4.5.2(28.1/3): if the type is a record, then the membership test\n+      --  uses the primitive equality for the type [even if it is not visible].\n+      --  We only deal with the untagged case here, because the tagged case is\n+      --  handled uniformly in the expander.\n+\n+      elsif Is_Record_Type (Utyp) and then not Is_Tagged_Type (Utyp) then\n+         declare\n+            Eq_Id : constant Entity_Id := Get_User_Defined_Equality (Typ);\n+\n+         begin\n+            if Present (Eq_Id) then\n+               Rewrite_Operator_As_Call (N, Eq_Id);\n+            end if;\n+         end;\n+      end if;\n+   end Resolve_Membership_Equality;\n+\n    ---------------------------\n    -- Resolve_Membership_Op --\n    ---------------------------\n@@ -9953,7 +10015,7 @@ package body Sem_Res is\n          --  following warning appears useful for the most common case.\n \n          if Is_Scalar_Type (Etype (L))\n-           and then Present (Get_User_Defined_Eq (Etype (L)))\n+           and then Present (Get_User_Defined_Equality (Etype (L)))\n          then\n             Error_Msg_NE\n               (\"membership test on& uses predefined equality?\", N, Etype (L));"}, {"sha": "4e97b7ac2504c2458f3dc3f63f5baeac6505a9e7", "filename": "gcc/ada/sem_res.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -125,6 +125,9 @@ package Sem_Res is\n    --  own type. For now we assume that the prefix cannot be overloaded and\n    --  the name of the entry plays no role in the resolution.\n \n+   procedure Resolve_Membership_Equality (N : Node_Id; Typ : Entity_Id);\n+   --  Resolve the equality operator in an individual membership test\n+\n    function Valid_Conversion\n      (N           : Node_Id;\n       Target      : Entity_Id;"}, {"sha": "1ea9fd938981e33376cb81eca80715d59cc2473b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -11770,32 +11770,25 @@ package body Sem_Util is\n       return Task_Body_Procedure (Underlying_Type (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n-   -------------------------\n-   -- Get_User_Defined_Eq --\n-   -------------------------\n+   -------------------------------\n+   -- Get_User_Defined_Equality --\n+   -------------------------------\n \n-   function Get_User_Defined_Eq (E : Entity_Id) return Entity_Id is\n+   function Get_User_Defined_Equality (E : Entity_Id) return Entity_Id is\n       Prim : Elmt_Id;\n-      Op   : Entity_Id;\n \n    begin\n       Prim := First_Elmt (Collect_Primitive_Operations (E));\n       while Present (Prim) loop\n-         Op := Node (Prim);\n-\n-         if Chars (Op) = Name_Op_Eq\n-           and then Etype (Op) = Standard_Boolean\n-           and then Etype (First_Formal (Op)) = E\n-           and then Etype (Next_Formal (First_Formal (Op))) = E\n-         then\n-            return Op;\n+         if Is_User_Defined_Equality (Node (Prim)) then\n+            return Node (Prim);\n          end if;\n \n          Next_Elmt (Prim);\n       end loop;\n \n       return Empty;\n-   end Get_User_Defined_Eq;\n+   end Get_User_Defined_Equality;\n \n    ---------------\n    -- Get_Views --\n@@ -21498,15 +21491,31 @@ package body Sem_Util is\n    ------------------------------\n \n    function Is_User_Defined_Equality (Id : Entity_Id) return Boolean is\n+      F1, F2 : Entity_Id;\n+\n    begin\n-      return Ekind (Id) = E_Function\n+      --  An equality operator is a function that carries the name \"=\", returns\n+      --  Boolean, and has exactly two formal parameters of an identical type.\n+\n+      if Ekind (Id) = E_Function\n         and then Chars (Id) = Name_Op_Eq\n-        and then Comes_From_Source (Id)\n+        and then Base_Type (Etype (Id)) = Standard_Boolean\n+      then\n+         F1 := First_Formal (Id);\n+\n+         if No (F1) then\n+            return False;\n+         end if;\n \n-        --  Internally generated equalities have a full type declaration\n-        --  as their parent.\n+         F2 := Next_Formal (F1);\n \n-        and then Nkind (Parent (Id)) = N_Function_Specification;\n+         return Present (F2)\n+           and then No (Next_Formal (F2))\n+           and then Base_Type (Etype (F1)) = Base_Type (Etype (F2));\n+\n+      else\n+         return False;\n+      end if;\n    end Is_User_Defined_Equality;\n \n    -----------------------------"}, {"sha": "323f43f94de56603068d6f8a111c7a20886e17cd", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -1338,7 +1338,7 @@ package Sem_Util is\n    --  Given an entity for a task type or subtype, retrieves the\n    --  Task_Body_Procedure field from the corresponding task type declaration.\n \n-   function Get_User_Defined_Eq (E : Entity_Id) return Entity_Id;\n+   function Get_User_Defined_Equality (E : Entity_Id) return Entity_Id;\n    --  For a type entity, return the entity of the primitive equality function\n    --  for the type if it exists, otherwise return Empty.\n "}, {"sha": "19f761832ac6b4de80e2ee9291e2e7dfee5bb018", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -2826,7 +2826,7 @@ package Sinfo is\n       --  Defining_Identifier\n       --  Null_Exclusion_Present\n       --  Subtype_Indication\n-      --  Generic_Parent_Type (set for an actual derived type).\n+      --  Generic_Parent_Type (for actual of formal private or derived type)\n       --  Exception_Junk\n \n       -------------------------------"}, {"sha": "55f5b971754f5269033ded46ce71b1698e4153f6", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909ce3528c800676fbbebe1f9a0047d14378861e/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=909ce3528c800676fbbebe1f9a0047d14378861e", "patch": "@@ -105,7 +105,8 @@ package Uintp is\n    subtype Upos is Valid_Uint with Predicate => Upos >= Uint_1; -- positive\n    subtype Nonzero_Uint is Valid_Uint with Predicate => Nonzero_Uint /= Uint_0;\n    subtype Unegative is Valid_Uint with Predicate => Unegative < Uint_0;\n-   subtype Ubool is Valid_Uint with Predicate => Ubool in Uint_0 | Uint_1;\n+   subtype Ubool is Valid_Uint with\n+     Predicate => Ubool = Uint_0 or else Ubool = Uint_1;\n    subtype Opt_Ubool is Uint with\n      Predicate => No (Opt_Ubool) or else Opt_Ubool in Ubool;\n "}]}