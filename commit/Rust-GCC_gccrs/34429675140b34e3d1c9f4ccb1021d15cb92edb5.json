{"sha": "34429675140b34e3d1c9f4ccb1021d15cb92edb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0Mjk2NzUxNDBiMzRlM2QxYzlmNGNjYjEwMjFkMTVjYjkyZWRiNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-07-20T14:21:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-07-20T14:21:05Z"}, "message": "PR c++/6709 (DR 743)\n\n\tPR c++/6709 (DR 743)\n\tPR c++/42603 (DR 950)\ngcc/cp/\n\t* parser.c (token_is_decltype, cp_lexer_next_token_is_decltype): New.\n\t(cp_parser_nested_name_specifier_opt): Allow decltype.\n\t(cp_parser_qualifying_entity): Likewise.\n\t(cp_parser_decltype): Replace source tokens with CPP_DECLTYPE.\n\t(cp_parser_simple_type_specifier): Handle decltype as scope.\n\t(cp_parser_base_specifier): Allow decltype.\n\t(cp_parser_base_clause): Don't crash on null base.\n\t* parser.h (CPP_KEYWORD, CPP_TEMPLATE_ID): Move to c-common.h.\n\t(CPP_NESTED_NAME_SPECIFIER, N_CP_TTYPES): Likewise.\ngcc/c-family/\n\t* c-common.h (CPP_KEYWORD, CPP_TEMPLATE_ID): Move from cp/parser.h.\n\t(CPP_NESTED_NAME_SPECIFIER, N_CP_TTYPES): Likewise.\n\t(CPP_DECLTYPE): New.\n\t* c-common.c (c_parse_error): Handle CPP_DECLTYPE.\n\nFrom-SVN: r176513", "tree": {"sha": "9e56cc48852c32e97103a681ceb85db78262ad17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e56cc48852c32e97103a681ceb85db78262ad17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34429675140b34e3d1c9f4ccb1021d15cb92edb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34429675140b34e3d1c9f4ccb1021d15cb92edb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34429675140b34e3d1c9f4ccb1021d15cb92edb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34429675140b34e3d1c9f4ccb1021d15cb92edb5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff3ac0f47166f4ef3c6a22623bfadba6e419dbb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3ac0f47166f4ef3c6a22623bfadba6e419dbb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff3ac0f47166f4ef3c6a22623bfadba6e419dbb1"}], "stats": {"total": 234, "additions": 185, "deletions": 49}, "files": [{"sha": "c5f2306ca62290dab967342c557fbe31f33fcb9f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -1,3 +1,12 @@\n+2011-07-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/6709 (DR 743)\n+\tPR c++/42603 (DR 950)\n+\t* c-common.h (CPP_KEYWORD, CPP_TEMPLATE_ID): Move from cp/parser.h.\n+\t(CPP_NESTED_NAME_SPECIFIER, N_CP_TTYPES): Likewise.\n+\t(CPP_DECLTYPE): New.\n+\t* c-common.c (c_parse_error): Handle CPP_DECLTYPE.\n+\n 2011-07-19  Richard Guenther  <rguenther@suse.de>\n \n \t* c-common.c (pointer_int_sum): Use fold_build_pointer_plus."}, {"sha": "6078d948ae4284101dc6a64438dbd0b000b2485a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -8329,6 +8329,8 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n     message = catenate_messages (gmsgid, \" before %<#pragma%>\");\n   else if (token_type == CPP_PRAGMA_EOL)\n     message = catenate_messages (gmsgid, \" before end of line\");\n+  else if (token_type == CPP_DECLTYPE)\n+    message = catenate_messages (gmsgid, \" before %<decltype%>\");\n   else if (token_type < N_TTYPES)\n     {\n       message = catenate_messages (gmsgid, \" before %qs token\");"}, {"sha": "13aae0f3ecc5a92d9e8622b7486fb2c615a0a404", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -320,6 +320,30 @@ struct c_common_resword\n   const unsigned int disable   : 16;\n };\n \n+/* Extra cpp_ttype values for C++.  */\n+\n+/* A token type for keywords, as opposed to ordinary identifiers.  */\n+#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))\n+\n+/* A token type for template-ids.  If a template-id is processed while\n+   parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;\n+   the value of the CPP_TEMPLATE_ID is whatever was returned by\n+   cp_parser_template_id.  */\n+#define CPP_TEMPLATE_ID ((enum cpp_ttype) (CPP_KEYWORD + 1))\n+\n+/* A token type for nested-name-specifiers.  If a\n+   nested-name-specifier is processed while parsing tentatively, it is\n+   replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the\n+   CPP_NESTED_NAME_SPECIFIER is whatever was returned by\n+   cp_parser_nested_name_specifier_opt.  */\n+#define CPP_NESTED_NAME_SPECIFIER ((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))\n+\n+/* A token type for pre-parsed C++0x decltype.  */\n+#define CPP_DECLTYPE ((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))\n+\n+/* The number of token types, including C++-specific ones.  */\n+#define N_CP_TTYPES ((int) (CPP_DECLTYPE + 1))\n+\n /* Disable mask.  Keywords are disabled if (reswords[i].disable &\n    mask) is _true_.  Thus for keywords which are present in all\n    languages the disable field is zero.  */"}, {"sha": "37fa0522fc71246d8639de17c80b8a7ac1ecf65f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -1,4 +1,16 @@\n-2011-07-19  Jason Merrill  <jason@redhat.com>\n+2011-07-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/6709 (DR 743)\n+\tPR c++/42603 (DR 950)\n+\t* parser.c (token_is_decltype, cp_lexer_next_token_is_decltype): New.\n+\t(cp_parser_nested_name_specifier_opt): Allow decltype.\n+\t(cp_parser_qualifying_entity): Likewise.\n+\t(cp_parser_decltype): Replace source tokens with CPP_DECLTYPE.\n+\t(cp_parser_simple_type_specifier): Handle decltype as scope.\n+\t(cp_parser_base_specifier): Allow decltype.\n+\t(cp_parser_base_clause): Don't crash on null base.\n+\t* parser.h (CPP_KEYWORD, CPP_TEMPLATE_ID): Move to c-common.h.\n+\t(CPP_NESTED_NAME_SPECIFIER, N_CP_TTYPES): Likewise.\n \n \tPR c++/49785\n \t* pt.c (coerce_template_parms): Handle non-pack after pack."}, {"sha": "b8dc48e04ca15d86940f665559928528aa69974a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 113, "deletions": 29, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -663,6 +663,24 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n     }\n }\n \n+/* Returns TRUE iff the token T begins a decltype type.  */\n+\n+static bool\n+token_is_decltype (cp_token *t)\n+{\n+  return (t->keyword == RID_DECLTYPE\n+\t  || t->type == CPP_DECLTYPE);\n+}\n+\n+/* Returns TRUE iff the next token begins a decltype type.  */\n+\n+static bool\n+cp_lexer_next_token_is_decltype (cp_lexer *lexer)\n+{\n+  cp_token *t = cp_lexer_peek_token (lexer);\n+  return token_is_decltype (t);\n+}\n+\n /* Return a pointer to the Nth token in the token stream.  If N is 1,\n    then this is precisely equivalent to cp_lexer_peek_token (except\n    that it is not inline).  One would like to disallow that case, but\n@@ -4313,6 +4331,9 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       /* A template-id can start a nested-name-specifier.  */\n       else if (token->type == CPP_TEMPLATE_ID)\n \t;\n+      /* DR 743: decltype can be used in a nested-name-specifier.  */\n+      else if (token_is_decltype (token))\n+\t;\n       else\n \t{\n \t  /* If the next token is not an identifier, then it is\n@@ -4386,6 +4407,28 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t     class-or-namespace-name.  */\n \t  parser->scope = old_scope;\n \t  parser->qualifying_scope = saved_qualifying_scope;\n+\n+\t  /* If the next token is a decltype, and the one after that is a\n+\t     `::', then the decltype has failed to resolve to a class or\n+\t     enumeration type.  Give this error even when parsing\n+\t     tentatively since it can't possibly be valid--and we're going\n+\t     to replace it with a CPP_NESTED_NAME_SPECIFIER below, so we\n+\t     won't get another chance.*/\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_DECLTYPE)\n+\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t  == CPP_SCOPE))\n+\t    {\n+\t      token = cp_lexer_consume_token (parser->lexer);\n+\t      error_at (token->location, \"decltype evaluates to %qT, \"\n+\t\t\t\"which is not a class or enumeration type\",\n+\t\t\ttoken->u.value);\n+\t      parser->scope = error_mark_node;\n+\t      error_p = true;\n+\t      /* As below.  */\n+\t      success = true;\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    }\n+\n \t  if (cp_parser_uncommitted_to_tentative_parse_p (parser))\n \t    break;\n \t  /* If the next token is an identifier, and the one after\n@@ -4585,6 +4628,19 @@ cp_parser_qualifying_entity (cp_parser *parser,\n   bool only_class_p;\n   bool successful_parse_p;\n \n+  /* DR 743: decltype can appear in a nested-name-specifier.  */\n+  if (cp_lexer_next_token_is_decltype (parser->lexer))\n+    {\n+      scope = cp_parser_decltype (parser);\n+      if (TREE_CODE (scope) != ENUMERAL_TYPE\n+\t  && !MAYBE_CLASS_TYPE_P (scope))\n+\t{\n+\t  cp_parser_simulate_error (parser);\n+\t  return error_mark_node;\n+\t}\n+      return TYPE_NAME (scope);\n+    }\n+\n   /* Before we try to parse the class-name, we must save away the\n      current PARSER->SCOPE since cp_parser_class_name will destroy\n      it.  */\n@@ -10197,6 +10253,14 @@ cp_parser_decltype (cp_parser *parser)\n   bool saved_integral_constant_expression_p;\n   bool saved_non_integral_constant_expression_p;\n   cp_token *id_expr_start_token;\n+  cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (start_token->type == CPP_DECLTYPE)\n+    {\n+      /* Already parsed.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      return start_token->u.value;\n+    }\n \n   /* Look for the `decltype' token.  */\n   if (!cp_parser_require_keyword (parser, RID_DECLTYPE, RT_DECLTYPE))\n@@ -10350,14 +10414,6 @@ cp_parser_decltype (cp_parser *parser)\n   parser->non_integral_constant_expression_p\n     = saved_non_integral_constant_expression_p;\n \n-  if (expr == error_mark_node)\n-    {\n-      /* Skip everything up to the closing `)'.  */\n-      cp_parser_skip_to_closing_parenthesis (parser, true, false,\n-                                             /*consume_paren=*/true);\n-      return error_mark_node;\n-    }\n-  \n   /* Parse to the closing `)'.  */\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     {\n@@ -10366,8 +10422,17 @@ cp_parser_decltype (cp_parser *parser)\n       return error_mark_node;\n     }\n \n-  return finish_decltype_type (expr, id_expression_or_member_access_p,\n+  expr = finish_decltype_type (expr, id_expression_or_member_access_p,\n \t\t\t       tf_warning_or_error);\n+\n+  /* Replace the decltype with a CPP_DECLTYPE so we don't need to parse\n+     it again.  */\n+  start_token->type = CPP_DECLTYPE;\n+  start_token->u.value = expr;\n+  start_token->keyword = RID_MAX;\n+  cp_lexer_purge_tokens_after (parser->lexer, start_token);\n+\n+  return expr;\n }\n \n /* Special member functions [gram.special] */\n@@ -12679,15 +12744,13 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       break;\n \n     case RID_DECLTYPE:\n-      /* Parse the `decltype' type.  */\n-      type = cp_parser_decltype (parser);\n-\n-      if (decl_specs)\n-\tcp_parser_set_decl_spec_type (decl_specs, type,\n-\t\t\t\t      token->location,\n-\t\t\t\t      /*user_defined_p=*/true);\n-\n-      return type;\n+      /* Since DR 743, decltype can either be a simple-type-specifier by\n+\t itself or begin a nested-name-specifier.  Parsing it will replace\n+\t it with a CPP_DECLTYPE, so just rewind and let the CPP_DECLTYPE\n+\t handling below decide what to do.  */\n+      cp_parser_decltype (parser);\n+      cp_lexer_set_token_position (parser->lexer, token);\n+      break;\n \n     case RID_TYPEOF:\n       /* Consume the `typeof' token.  */\n@@ -12719,6 +12782,20 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       break;\n     }\n \n+  /* If token is an already-parsed decltype not followed by ::,\n+     it's a simple-type-specifier.  */\n+  if (token->type == CPP_DECLTYPE\n+      && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_SCOPE)\n+    {\n+      type = token->u.value;\n+      if (decl_specs)\n+\tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      token->location,\n+\t\t\t\t      /*user_defined_p=*/true);\n+      cp_lexer_consume_token (parser->lexer);\n+      return type;\n+    }\n+\n   /* If the type-specifier was for a built-in type, we're done.  */\n   if (type)\n     {\n@@ -18232,12 +18309,11 @@ cp_parser_base_clause (cp_parser* parser)\n         }\n \n       /* Add BASE to the front of the list.  */\n-      if (base != error_mark_node)\n+      if (base && base != error_mark_node)\n \t{\n           if (pack_expansion_p)\n             /* Make this a pack expansion type. */\n             TREE_VALUE (base) = make_pack_expansion (TREE_VALUE (base));\n-          \n \n           if (!check_for_bare_parameter_packs (TREE_VALUE (base)))\n             {\n@@ -18379,19 +18455,27 @@ cp_parser_base_specifier (cp_parser* parser)\n   class_scope_p = (parser->scope && TYPE_P (parser->scope));\n   template_p = class_scope_p && cp_parser_optional_template_keyword (parser);\n \n-  /* Finally, look for the class-name.  */\n-  type = cp_parser_class_name (parser,\n-\t\t\t       class_scope_p,\n-\t\t\t       template_p,\n-\t\t\t       typename_type,\n-\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t       /*class_head_p=*/false,\n-\t\t\t       /*is_declaration=*/true);\n+  if (!parser->scope\n+      && cp_lexer_next_token_is_decltype (parser->lexer))\n+    /* DR 950 allows decltype as a base-specifier.  */\n+    type = cp_parser_decltype (parser);\n+  else\n+    {\n+      /* Otherwise, look for the class-name.  */\n+      type = cp_parser_class_name (parser,\n+\t\t\t\t   class_scope_p,\n+\t\t\t\t   template_p,\n+\t\t\t\t   typename_type,\n+\t\t\t\t   /*check_dependency_p=*/true,\n+\t\t\t\t   /*class_head_p=*/false,\n+\t\t\t\t   /*is_declaration=*/true);\n+      type = TREE_TYPE (type);\n+    }\n \n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  return finish_base_specifier (TREE_TYPE (type), access, virtual_p);\n+  return finish_base_specifier (type, access, virtual_p);\n }\n \n /* Exception handling [gram.exception] */"}, {"sha": "33582fbc0f189579d6c90e8e78df265d6109244a", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -23,25 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"c-family/c-pragma.h\"\n \n-/* A token type for keywords, as opposed to ordinary identifiers.  */\n-#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))\n-\n-/* A token type for template-ids.  If a template-id is processed while\n-   parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;\n-   the value of the CPP_TEMPLATE_ID is whatever was returned by\n-   cp_parser_template_id.  */\n-#define CPP_TEMPLATE_ID ((enum cpp_ttype) (CPP_KEYWORD + 1))\n-\n-/* A token type for nested-name-specifiers.  If a\n-   nested-name-specifier is processed while parsing tentatively, it is\n-   replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the\n-   CPP_NESTED_NAME_SPECIFIER is whatever was returned by\n-   cp_parser_nested_name_specifier_opt.  */\n-#define CPP_NESTED_NAME_SPECIFIER ((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))\n-\n-/* The number of token types, including C++-specific ones.  */\n-#define N_CP_TTYPES ((int) (CPP_NESTED_NAME_SPECIFIER + 1))\n-\n /* A token's value and its associated deferred access checks and\n    qualifying scope.  */\n "}, {"sha": "faa412beca01de94412895670b78f930863a3b27", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -1,3 +1,9 @@\n+2011-07-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/6709 (DR 743)\n+\tPR c++/42603 (DR 950)\n+\t* g++.dg/cpp0x/decltype21.C: New.\n+\n 2011-07-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/18908"}, {"sha": "ee73bfbc36c8dbfd05575e670e683e8dd57170db", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype21.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34429675140b34e3d1c9f4ccb1021d15cb92edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype21.C?ref=34429675140b34e3d1c9f4ccb1021d15cb92edb5", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/6709 (DR 743)\n+// PR c++/42603 (DR 950)\n+// { dg-options -std=c++0x }\n+\n+template <class T>\n+T make();\n+\n+struct p { typedef int t; };\n+struct c : decltype(make<p>()) {};\n+\n+decltype(make<p>())::t t;\n+\n+int f();\n+decltype(f())::t t2;\t\t// { dg-error \"not a class\" }\n+\n+struct D: decltype(f()) { };\t// { dg-error \"not a class\" }\n+\n+// { dg-prune-output \"expected initializer\" }"}]}