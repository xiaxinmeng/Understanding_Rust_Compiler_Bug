{"sha": "c5830edf8594b13767b8282856b01f0f9be9dd20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4MzBlZGY4NTk0YjEzNzY3YjgyODI4NTZiMDFmMGY5YmU5ZGQyMA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-07-12T02:20:04Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-07-12T02:20:04Z"}, "message": "re PR tree-optimization/32663 (revision 126369 went into an infinite loop)\n\n2007-07-11  Daniel Berlin  <dberlin@dberlin.org>\n\n\tPR tree-optimization/32663\n\t\n\t* tree.h (VALUE_HANDLE_VUSES): Remove.\n\t(struct tree_value_handle): Remove vuses.\n\n\t* tree-vn.c (create_value_handle_for_expr): Don't set\n\tVALUE_HANDLE_VUSES. \n\n\t* tree-ssa-pre.c (expression_vuses): New.\n\t(alloc_expression_id): Set up expression_vuses.\n\t(get_expression_vuses): New.\n\t(set_expression_vuses): Ditto.\n\t(clear_expression_ids): Modify for expression_vuses.\n\t(phi_translate_1): Ditto.\n\t(phi_translate_set): Ditto.\n\t(value_dies_in_block_x): Ditto\n\t(valid_in_sets): Ditto.\n\t(add_to_sets): Ditto.\n\t(find_existing_value_expr): Ditto.\n\t(create_value_handle_for_expr): Ditto.\n\t(make_values_for_stmt): Ditto.\n\t(vuse_equiv): Remove.\n\nFrom-SVN: r126568", "tree": {"sha": "73dbf6f42eb0c468aa7f779cd17fefd04ecebed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73dbf6f42eb0c468aa7f779cd17fefd04ecebed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5830edf8594b13767b8282856b01f0f9be9dd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5830edf8594b13767b8282856b01f0f9be9dd20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5830edf8594b13767b8282856b01f0f9be9dd20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5830edf8594b13767b8282856b01f0f9be9dd20/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "433e6a8cf26e3d3164250884b088dd396c131b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433e6a8cf26e3d3164250884b088dd396c131b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/433e6a8cf26e3d3164250884b088dd396c131b9f"}], "stats": {"total": 320, "additions": 250, "deletions": 70}, "files": [{"sha": "da5976d2e5b9c5e5d7e9566f54ce355fb813ea7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -1,3 +1,28 @@\n+2007-07-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tPR tree-optimization/32663\n+\t\n+\t* tree.h (VALUE_HANDLE_VUSES): Remove.\n+\t(struct tree_value_handle): Remove vuses.\n+\n+\t* tree-vn.c (create_value_handle_for_expr): Don't set\n+\tVALUE_HANDLE_VUSES. \n+\n+\t* tree-ssa-pre.c (expression_vuses): New.\n+\t(alloc_expression_id): Set up expression_vuses.\n+\t(get_expression_vuses): New.\n+\t(set_expression_vuses): Ditto.\n+\t(clear_expression_ids): Modify for expression_vuses.\n+\t(phi_translate_1): Ditto.\n+\t(phi_translate_set): Ditto.\n+\t(value_dies_in_block_x): Ditto\n+\t(valid_in_sets): Ditto.\n+\t(add_to_sets): Ditto.\n+\t(find_existing_value_expr): Ditto.\n+\t(create_value_handle_for_expr): Ditto.\n+\t(make_values_for_stmt): Ditto.\n+\t(vuse_equiv): Remove.\n+\n 2007-07-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* Makefile.in (mostlyclean): Remove object files."}, {"sha": "54b392fcf7627a6c080fdc6d1c6666549fe7715d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -1,3 +1,7 @@\n+2007-07-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* gfortran.fortran-torture/compile/pr32663.f90: New test.\n+\n 2007-07-11  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/31027"}, {"sha": "34f4a01db00bc1422e70634a46296bb8bb995ab0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21559.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -37,7 +37,7 @@ void foo (void)\n /* Second, we should thread the edge out of the loop via the break\n    statement.  We also realize that the final bytes == 0 test is useless,\n    and thread over it.  */\n-/* { dg-final { scan-tree-dump-times \"Threaded jump\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 3 \"vrp1\" } } */\n \n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "03896adab0f67713a3638ece295805e9bc41c231", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/pr32663.f", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr32663.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr32663.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr32663.f?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -0,0 +1,147 @@\n+      SUBROUTINE DIMOID(DEN,RLMO,SSQU,STRI,ATMU,IATM,IWHI,MAPT,INAT,\n+     *   IATB,L1,L2,M1,M2,NATS,NOSI,NCAT,NSWE)\n+C\n+      IMPLICIT DOUBLE PRECISION(A-H,O-Z)\n+C\n+      DIMENSION RLMO(L1,L1),SSQU(L1,L1),STRI(L2),ATMU(NATS),DEN(M2)\n+      DIMENSION IATM(NATS,M1),IWHI(M1+NATS),MAPT(M1),INAT(M1+NATS)\n+      DIMENSION IATB(NATS,M1)\n+C\n+      PARAMETER (MXATM=500, MXSH=1000, MXGTOT=5000, MXAO=2047)\n+C\n+      LOGICAL GOPARR,DSKWRK,MASWRK\n+C\n+      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,\n+     *                ZAN(MXATM),C(3,MXATM)\n+      COMMON /IOFILE/ IR,IW,IP,IJKO,IJKT,IDAF,NAV,IODA(400)\n+      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),\n+     *                CF(MXGTOT),CG(MXGTOT),\n+     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),\n+     *                KNG(MXSH),KLOC(MXSH),KMIN(MXSH),\n+     *                KMAX(MXSH),NSHELL\n+      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,\n+     *                MOOUTA(MXAO),MOOUTB(MXAO)\n+      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK\n+      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)\n+C\n+C\n+      DO 920 II=1,M1\n+         INAT(II) = 0\n+  920 CONTINUE\n+C\n+\n+      DO 900 IO = NOUTA+1,NUMLOC\n+         IZ = IO - NOUTA\n+         DO 895 II=NST,NEND\n+            ATMU(II) = 0.0D+00\n+            IATM(II,IZ) = 0\n+  895    CONTINUE\n+         IFUNC = 0\n+         DO 890 ISHELL = 1,NSHELL\n+            IAT = KATOM(ISHELL)\n+            IST = KMIN(ISHELL)\n+            IEN = KMAX(ISHELL)\n+            DO 880 INO = IST,IEN\n+               IFUNC = IFUNC + 1\n+               IF (IAT.LT.NST.OR.IAT.GT.NEND) GOTO 880\n+               ZINT  = 0.0D+00\n+               DO 870 II = 1,L1\n+                  ZINT = ZINT + RLMO(II,IO)*SSQU(II,IFUNC)\n+  870          CONTINUE\n+               ATMU(IAT) = ATMU(IAT) + RLMO(IFUNC,IO)*ZINT\n+  880       CONTINUE\n+  890    CONTINUE\n+         IF (MASWRK) WRITE(IW,9010) IZ,(ATMU(II),II=NST,NEND)\n+  900 CONTINUE\n+C\n+      NOSI = 0\n+      DO 700 II=1,M1\n+         NO=0\n+         DO 720 JJ=1,NAT\n+            NO = NO + 1\n+  720    CONTINUE\n+  740    CONTINUE\n+         IF (NO.GT.1.OR.NO.EQ.0) THEN\n+            NOSI = NOSI + 1\n+            IWHI(NOSI) = II\n+         ENDIF\n+        IF (MASWRK)\n+     *     WRITE(IW,9030) II,(IATM(J,II),A(IATM(J,II)),J=1,NO)\n+  700 CONTINUE\n+C\n+      IF (MASWRK) THEN\n+         WRITE(IW,9035) NOSI\n+         IF (NOSI.GT.0) THEN\n+            WRITE(IW,9040) (IWHI(I),I=1,NOSI)\n+            WRITE(IW,9040)\n+         ELSE\n+            WRITE(IW,9040)\n+         ENDIF\n+      ENDIF\n+C\n+      CALL DCOPY(L1*L1,RLMO,1,SSQU,1)\n+      CALL DCOPY(M2,DEN,1,STRI,1)\n+C\n+      IP2 = NOUTA\n+      IS2 = M1+NOUTA-NOSI\n+      DO 695 II=1,NAT\n+         INAT(II) = 0\n+  695 CONTINUE\n+C\n+      DO 690 IAT=1,NAT\n+         DO 680 IORB=1,M1\n+            IP1 = IORB + NOUTA\n+            IF (IATM(1,IORB).NE.IAT) GOTO 680\n+            IF (IATM(2,IORB).NE.0) GOTO 680\n+            INAT(IAT) = INAT(IAT) + 1\n+            IP2 = IP2 + 1\n+            CALL DCOPY(L1,SSQU(1,IP1),1,RLMO(1,IP2),1)\n+            CALL ICOPY(NAT,IATM(1,IORB),1,IATB(1,IP2-NOUTA),1)\n+            MAPT(IORB) = IP2-NOUTA\n+  680    CONTINUE\n+         DO 670 IORB=1,NOSI\n+            IS1 = IWHI(IORB) + NOUTA\n+            IF (IAT.EQ.NAT.AND.IATM(1,IWHI(IORB)).EQ.0) GOTO 675\n+            IF (IATM(1,IWHI(IORB)).NE.IAT) GOTO 670\n+  675       CONTINUE\n+            IS2 = IS2 + 1\n+            MAPT(IWHI(IORB)) = IS2-NOUTA\n+  670    CONTINUE\n+  690 CONTINUE\n+C\n+      NSWE = 0\n+      NCAT = 0\n+      LASP = 1\n+      NLAST = 0\n+      DO 620 II=1,NAT\n+         NSWE = NSWE + (IWHI(II)*(IWHI(II)-1))/2\n+         NCAT = NCAT + 1\n+         INAT(NCAT) = LASP + NLAST\n+         LASP = INAT(NCAT)\n+         NLAST = IWHI(II)\n+         IWHI(NCAT) = II\n+  620 CONTINUE\n+C\n+      DO 610 II=1,NOSI\n+         NCAT = NCAT + 1\n+         INAT(NCAT) = LASP + NLAST\n+         LASP = INAT(NCAT)\n+         NLAST = 1\n+         IWHI(NCAT) = 0\n+  610 CONTINUE\n+C\n+      RETURN\n+C\n+ 8000 FORMAT(/1X,'** MULLIKEN ATOMIC POPULATIONS FOR EACH NON-FROZEN ',\n+     *       'LOCALIZED ORBITAL **')\n+ 9000 FORMAT(/3X,'ATOM',2X,100(I2,1X,A4))\n+ 9005 FORMAT(1X,'LMO')\n+ 9010 FORMAT(1X,I3,3X,100F7.3)\n+ 9015 FORMAT(/1X,'** ATOMIC POPULATIONS GREATER THAN ',F4.2,\n+     *   ' ARE CONSIDERED MAJOR **')\n+ 9020 FORMAT(/2X,'LMO',3X,'MAJOR CONTRIBUTIONS FROM ATOM(S)')\n+ 9030 FORMAT(2X,I3,2X,100(I2,1X,A2,2X))\n+ 9035 FORMAT(/1X,'NO OF LMOS INVOLVING MORE THAN ONE ATOM =',I3)\n+ 9040 FORMAT(1X,'THESE ARE LMOS :',100I3)\n+C\n+      END"}, {"sha": "c37ab53326ce7896aa01320b82b7a06e7baae263", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -185,6 +185,12 @@ Boston, MA 02110-1301, USA.  */\n /* Next global expression id number.  */\n static unsigned int next_expression_id;\n \n+typedef VEC(tree, gc) *vuse_vec;\n+DEF_VEC_P (vuse_vec);\n+DEF_VEC_ALLOC_P (vuse_vec, heap);\n+\n+static VEC(vuse_vec, heap) *expression_vuses;\n+\t\t\t\t\t\t \n /* Mapping from expression to id number we can use in bitmap sets.  */\n static VEC(tree, heap) *expressions;\n \n@@ -203,6 +209,7 @@ alloc_expression_id (tree expr)\n   ann->aux = XNEW (unsigned int);\n   * ((unsigned int *)ann->aux) = next_expression_id++;\n   VEC_safe_push (tree, heap, expressions, expr);\n+  VEC_safe_push (vuse_vec, heap, expression_vuses, NULL);\n   return next_expression_id - 1;\n }\n \n@@ -240,6 +247,25 @@ expression_for_id (unsigned int id)\n   return VEC_index (tree, expressions, id);\n }\n \n+/* Return the expression vuses for EXPR, if there are any.  */\n+\n+static inline vuse_vec\n+get_expression_vuses (tree expr)\n+{\n+  return VEC_index (vuse_vec, expression_vuses,\n+\t\t    get_or_alloc_expression_id (expr));\n+}\n+\n+/* Set the expression vuses for EXPR to VUSES.  */\n+\n+static inline void\n+set_expression_vuses (tree expr, vuse_vec vuses)\n+{\n+  VEC_replace (vuse_vec, expression_vuses,\n+\t       get_or_alloc_expression_id (expr), vuses);\n+}\n+\n+\n /* Free the expression id field in all of our expressions,\n    and then destroy the expressions array.  */\n \n@@ -255,6 +281,7 @@ clear_expression_ids (void)\n       tree_common_ann (expr)->aux = NULL;\n     }\n   VEC_free (tree, heap, expressions);\n+  VEC_free (vuse_vec, heap, expression_vuses);\n }\n \n static bool in_fre = false;\n@@ -956,13 +983,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n   /* Phi translations of a given expression don't change.  */\n   if (EXPR_P (expr) || GIMPLE_STMT_P (expr))\n     {\n-      tree vh;\n-\n-      vh = get_value_handle (expr);\n-      if (vh && TREE_CODE (vh) == VALUE_HANDLE)\n-\tphitrans = phi_trans_lookup (expr, pred, VALUE_HANDLE_VUSES (vh));\n-      else\n-\tphitrans = phi_trans_lookup (expr, pred, NULL);\n+      phitrans = phi_trans_lookup (expr, pred, get_expression_vuses (expr));\n     }\n   else\n     phitrans = phi_trans_lookup (expr, pred, NULL);\n@@ -995,10 +1016,9 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    tree oldsc = CALL_EXPR_STATIC_CHAIN (expr);\n \t    tree newfn, newsc = NULL;\n \t    tree newexpr = NULL_TREE;\n-\t    tree vh = get_value_handle (expr);\n \t    bool invariantarg = false;\n \t    int i, nargs;\n-\t    VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n+\t    VEC (tree, gc) *vuses = get_expression_vuses (expr);\n \t    VEC (tree, gc) *tvuses;\n \n \t    newfn = phi_translate_1 (find_leader_in_sets (oldfn, set1, set2),\n@@ -1084,6 +1104,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n+\t\tset_expression_vuses (newexpr, tvuses);\n \t      }\n \t    phi_trans_add (oldexpr, expr, pred, tvuses);\n \t  }\n@@ -1095,14 +1116,16 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \tVEC (tree, gc) * oldvuses = NULL;\n \tVEC (tree, gc) * newvuses = NULL;\n \n-\toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n+\toldvuses = get_expression_vuses (expr);\n \tif (oldvuses)\n \t  newvuses = translate_vuses_through_block (oldvuses, phiblock,\n \t\t\t\t\t\t    pred);\n \n \tif (oldvuses != newvuses)\n-\t  vn_lookup_or_add_with_vuses (expr, newvuses);\n-\n+\t  {\n+\t    vn_lookup_or_add_with_vuses (expr, newvuses);\n+\t    set_expression_vuses (expr, newvuses);\n+\t  }\n \tphi_trans_add (oldexpr, expr, pred, newvuses);\n       }\n       return expr;\n@@ -1160,7 +1183,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t  }\n \n-\toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n+\toldvuses = get_expression_vuses (expr);\n \tif (oldvuses)\n \t  newvuses = translate_vuses_through_block (oldvuses, phiblock,\n \t\t\t\t\t\t    pred);\n@@ -1195,6 +1218,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      {\n \t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, newvuses);\n+\t\tset_expression_vuses (newexpr, newvuses);\n \t      }\n \t    expr = newexpr;\n \t  }\n@@ -1360,14 +1384,8 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n \t we won't look them up that way, or use the result, anyway.  */\n       if (translated && !is_gimple_min_invariant (translated))\n \t{\n-\t  tree vh = get_value_handle (translated);\n-\t  VEC (tree, gc) *vuses;\n-\n-\t  /* The value handle itself may also be an invariant, in\n-\t     which case, it has no vuses.  */\n-\t  vuses = !is_gimple_min_invariant (vh)\n-\t    ? VALUE_HANDLE_VUSES (vh) : NULL;\n-\t  phi_trans_add (expr, translated, pred, vuses);\n+\t  phi_trans_add (expr, translated, pred,\n+\t\t\t get_expression_vuses (translated));\n \t}\n \n       if (translated != NULL)\n@@ -1413,19 +1431,19 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n   return NULL;\n }\n \n-/* Determine if VALUE, a memory operation, is ANTIC_IN at the top of\n+/* Determine if EXPR, a memory expressionn, is ANTIC_IN at the top of\n    BLOCK by seeing if it is not killed in the block.  Note that we are\n    only determining whether there is a store that kills it.  Because\n    of the order in which clean iterates over values, we are guaranteed\n    that altered operands will have caused us to be eliminated from the\n    ANTIC_IN set already.  */\n \n static bool\n-value_dies_in_block_x (tree vh, basic_block block)\n+value_dies_in_block_x (tree expr, basic_block block)\n {\n   int i;\n   tree vuse;\n-  VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n+  VEC (tree, gc) *vuses = get_expression_vuses (expr);\n \n   /* Conservatively, a value dies if it's vuses are defined in this\n      block, unless they come from phi nodes (which are merge operations,\n@@ -1462,7 +1480,6 @@ static bool\n valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t       basic_block block)\n {\n- tree vh = get_value_handle (expr);\n  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_binary:\n@@ -1504,7 +1521,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t\tif (!union_contains_value (set1, set2, arg))\n \t\t  return false;\n \t      }\n-\t    return !value_dies_in_block_x (vh, block);\n+\t    return !value_dies_in_block_x (expr, block);\n \t  }\n \treturn false;\n       }\n@@ -1540,7 +1557,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t\t    && !union_contains_value (set1, set2, op3))\n \t\t  return false;\n \t    }\n-\t    return !value_dies_in_block_x (vh, block);\n+\t    return !value_dies_in_block_x (expr, block);\n \t  }\n       }\n       return false;\n@@ -1552,7 +1569,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n       }\n \n     case tcc_declaration:\n-      return !value_dies_in_block_x (vh, block);\n+      return !value_dies_in_block_x (expr, block);\n \n     default:\n       /* No other cases should be encountered.  */\n@@ -2905,11 +2922,11 @@ add_to_exp_gen (basic_block block, tree op)\n    any).  */\n \n static inline void\n-add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n+add_to_sets (tree var, tree expr, VEC(tree, gc) *vuses, bitmap_set_t s1,\n \t     bitmap_set_t s2)\n {\n   tree val;\n-  val = vn_lookup_or_add_with_stmt (expr, stmt);\n+  val = vn_lookup_or_add_with_vuses (expr, vuses);\n \n   /* VAR and EXPR may be the same when processing statements for which\n      we are not computing value numbers (e.g., non-assignments, or\n@@ -2928,15 +2945,15 @@ add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n    and return it if it exists.  */\n \n static inline tree\n-find_existing_value_expr (tree t, tree stmt)\n+find_existing_value_expr (tree t, VEC (tree, gc) *vuses)\n {\n   bitmap_iterator bi;\n   unsigned int bii;\n   tree vh;\n   bitmap_set_t exprset;\n \n   if (REFERENCE_CLASS_P (t) || TREE_CODE (t) == CALL_EXPR || DECL_P (t))\n-    vh = vn_lookup_with_stmt (t, stmt);\n+    vh = vn_lookup_with_vuses (t, vuses);\n   else\n     vh = vn_lookup (t);\n   \n@@ -2960,7 +2977,7 @@ find_existing_value_expr (tree t, tree stmt)\n    any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n \n static inline tree\n-create_value_expr_from (tree expr, basic_block block, tree stmt)\n+create_value_expr_from (tree expr, basic_block block, VEC (tree, gc) *vuses)\n {\n   int i;\n   enum tree_code code = TREE_CODE (expr);\n@@ -3008,9 +3025,10 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       /* Recursively value-numberize reference ops and tree lists.  */\n       if (REFERENCE_CLASS_P (op))\n \t{\n-\t  tree tempop = create_value_expr_from (op, block, stmt);\n+\t  tree tempop = create_value_expr_from (op, block, vuses);\n \t  op = tempop ? tempop : op;\n-\t  val = vn_lookup_or_add_with_stmt (op, stmt);\n+\t  val = vn_lookup_or_add_with_vuses (op, vuses);\n+\t  set_expression_vuses (op, vuses);\n \t}\n       else\n \t{\n@@ -3024,7 +3042,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \n       TREE_OPERAND (vexpr, i) = val;\n     }\n-  efi = find_existing_value_expr (vexpr, stmt);\n+  efi = find_existing_value_expr (vexpr, vuses);\n   if (efi)\n     return efi;\n   get_or_alloc_expression_id (vexpr);\n@@ -3289,22 +3307,6 @@ make_values_for_phi (tree phi, basic_block block)\n     }\n }\n \n-/* Return true if both the statement and the value handles have no\n-   vuses, or both the statement and the value handle do have vuses.  \n-\n-   Unlike SCCVN, PRE needs not only to know equivalence, but what the\n-   actual vuses are so it can translate them through blocks.  Thus,\n-   we have to make a new value handle if the existing one has no\n-   vuses but needs them.  */\n-\n-static bool\n-vuse_equiv (tree vh1, tree stmt)\n-{\n-  bool stmt_has_vuses = !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES);\n-  return (VALUE_HANDLE_VUSES (vh1) && stmt_has_vuses)\n-    || (!VALUE_HANDLE_VUSES (vh1) && !stmt_has_vuses);\n-}\n-\n /* Create value handles for STMT in BLOCK.  Return true if we handled\n    the statement.  */\n \n@@ -3316,8 +3318,10 @@ make_values_for_stmt (tree stmt, basic_block block)\n   tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   tree valvh = NULL_TREE;\n   tree lhsval;\n+  VEC (tree, gc) *vuses = NULL;\n   \n   valvh = get_sccvn_value (lhs);\n+\n   if (valvh)\n     {\n       vn_add (lhs, valvh);\n@@ -3340,28 +3344,29 @@ make_values_for_stmt (tree stmt, basic_block block)\n     }\n   \n   lhsval = valvh ? valvh : get_value_handle (lhs);\n-  \n+  vuses = copy_vuses_from_stmt (stmt);\n   STRIP_USELESS_TYPE_CONVERSION (rhs);\n   if (can_value_number_operation (rhs)\n       && (!lhsval || !is_gimple_min_invariant (lhsval)))\n     {\n       /* For value numberable operation, create a\n \t duplicate expression with the operands replaced\n \t with the value handles of the original RHS.  */\n-      tree newt = create_value_expr_from (rhs, block, stmt);\n+      tree newt = create_value_expr_from (rhs, block, vuses);\n       if (newt)\n \t{\n+\t  set_expression_vuses (newt, vuses);\n \t  /* If we already have a value number for the LHS, reuse\n \t     it rather than creating a new one.  */\n-\t  if (lhsval && vuse_equiv (lhsval, stmt))\n+\t  if (lhsval)\n \t    {\n \t      set_value_handle (newt, lhsval);\n \t      if (!is_gimple_min_invariant (lhsval))\n \t\tadd_to_value (lhsval, newt);\n \t    }\n \t  else\n \t    {\n-\t      tree val = vn_lookup_or_add_with_stmt (newt, stmt);\n+\t      tree val = vn_lookup_or_add_with_vuses (newt, vuses);\n \t      vn_add (lhs, val);\n \t    }\n \t  \n@@ -3382,6 +3387,7 @@ make_values_for_stmt (tree stmt, basic_block block)\n       \n       if (lhsval)\n \t{\n+\t  set_expression_vuses (rhs, vuses);\n \t  set_value_handle (rhs, lhsval);\n \t  if (!is_gimple_min_invariant (lhsval))\n \t    add_to_value (lhsval, rhs);\n@@ -3393,7 +3399,8 @@ make_values_for_stmt (tree stmt, basic_block block)\n \t  /* Compute a value number for the RHS of the statement\n \t     and add its value to the AVAIL_OUT set for the block.\n \t     Add the LHS to TMP_GEN.  */\n-\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block),\n+\t  set_expression_vuses (rhs, vuses);\n+\t  add_to_sets (lhs, rhs, vuses, TMP_GEN (block),\n \t\t       AVAIL_OUT (block));\n \t}\n       /* None of the rest of these can be PRE'd.  */"}, {"sha": "a04bb2157bffb997f75c6f68a707e7b9fb23d116", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -1431,6 +1431,14 @@ try_to_simplify (tree stmt, tree rhs)\n \t  /* For references, see if we find a result for the lookup,\n \t     and use it if we do.  */\n \tcase tcc_declaration:\n+\t  /* Pull out any truly constant values.  */\n+\t  if (TREE_READONLY (rhs)\n+\t      && TREE_STATIC (rhs)\n+\t      && DECL_INITIAL (rhs)\n+\t      && is_gimple_min_invariant (DECL_INITIAL (rhs)))\n+\t    return DECL_INITIAL (rhs);\n+\n+\t    /* Fallthrough. */\n \tcase tcc_reference:\n \t  {\n \t    tree result = vn_reference_lookup (rhs,"}, {"sha": "3a22df0712f7688096124dbea603c8a67f6e6f8c", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -108,9 +108,6 @@ set_value_handle (tree e, tree v)\n     gcc_assert (is_gimple_min_invariant (e));\n }\n \n-\n-\n-\n /* A comparison function for use in qsort to compare vuses.  Simply\n    subtracts version numbers.  */\n \n@@ -329,16 +326,14 @@ vn_lookup_with_vuses (tree expr, VEC (tree, gc) *vuses)\n }\n \n static tree\n-create_value_handle_for_expr (tree expr, VEC (tree, gc) *vuses)\n+create_value_handle_for_expr (tree expr, VEC(tree, gc) *vuses)\n {\n   tree v;\n   \n   v = make_value_handle (TREE_TYPE (expr));\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     print_creation_to_file (v, expr, vuses);\n-  if (vuses)\n-    VALUE_HANDLE_VUSES (v) = vuses;\n   return v;\n }\n "}, {"sha": "7b051ebb0afcd420cac4be75c5e4c6ac54851762", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5830edf8594b13767b8282856b01f0f9be9dd20/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c5830edf8594b13767b8282856b01f0f9be9dd20", "patch": "@@ -3340,9 +3340,6 @@ struct tree_statement_list\n #define VALUE_HANDLE_EXPR_SET(NODE)\t\\\n   (VALUE_HANDLE_CHECK (NODE)->value_handle.expr_set)\n \n-#define VALUE_HANDLE_VUSES(NODE)        \\\n-  (VALUE_HANDLE_CHECK (NODE)->value_handle.vuses)\n-\n /* Defined and used in tree-ssa-pre.c.  */\n \n struct tree_value_handle GTY(())\n@@ -3356,9 +3353,6 @@ struct tree_value_handle GTY(())\n      conveniently dense form starting at 0, so that we can make\n      bitmaps of value handles.  */\n   unsigned int id;\n-\n-  /* Set of virtual uses represented by this handle.  */\n-  VEC (tree, gc) *vuses;\n };\n \f\n /* Define the overall contents of a tree node."}]}