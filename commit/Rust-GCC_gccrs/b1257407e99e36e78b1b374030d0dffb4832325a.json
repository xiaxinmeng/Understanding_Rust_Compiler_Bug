{"sha": "b1257407e99e36e78b1b374030d0dffb4832325a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyNTc0MDdlOTllMzZlNzhiMWIzNzQwMzBkMGRmZmI0ODMyMzI1YQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-12-15T08:51:16Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-12-15T08:51:16Z"}, "message": "combine.c: Remove force_to_mode's fourth parameter.\n\n2005-12-15  Paolo Bonzini  <bonzini@gnu.org>\n\n        * combine.c: Remove force_to_mode's fourth parameter.\n        (force_to_mode): Do not handle REG.\n        (canon_reg_for_combine): New.\n        (make_field_assignment): Use it where the removed argument was non-NULL.\n\nFrom-SVN: r108564", "tree": {"sha": "f2f143e03964f3649076f3fb07e7aee5370d4f8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2f143e03964f3649076f3fb07e7aee5370d4f8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1257407e99e36e78b1b374030d0dffb4832325a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1257407e99e36e78b1b374030d0dffb4832325a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1257407e99e36e78b1b374030d0dffb4832325a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1257407e99e36e78b1b374030d0dffb4832325a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d561bdfde8e2b4d7134910b78f2d351b52d1e931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d561bdfde8e2b4d7134910b78f2d351b52d1e931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d561bdfde8e2b4d7134910b78f2d351b52d1e931"}], "stats": {"total": 196, "additions": 147, "deletions": 49}, "files": [{"sha": "de3e458cc0d6d4732c44569e8438471e0ead6cf9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1257407e99e36e78b1b374030d0dffb4832325a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1257407e99e36e78b1b374030d0dffb4832325a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1257407e99e36e78b1b374030d0dffb4832325a", "patch": "@@ -1,3 +1,10 @@\n+2005-12-15  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * combine.c: Remove force_to_mode's fourth parameter.\n+        (force_to_mode): Do not handle REG.\n+        (canon_reg_for_combine): New.\n+        (make_field_assignment): Use it where the removed argument was non-NULL.\n+\n 2005-12-15  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/25406"}, {"sha": "d09461b3a5beb5e821168ccacb4a729d4b1ed877", "filename": "gcc/combine.c", "status": "modified", "additions": 140, "deletions": 49, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1257407e99e36e78b1b374030d0dffb4832325a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1257407e99e36e78b1b374030d0dffb4832325a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b1257407e99e36e78b1b374030d0dffb4832325a", "patch": "@@ -385,8 +385,9 @@ static rtx extract_left_shift (rtx, int);\n static rtx make_compound_operation (rtx, enum rtx_code);\n static int get_pos_from_mask (unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT *);\n+static rtx canon_reg_for_combine (rtx, rtx);\n static rtx force_to_mode (rtx, enum machine_mode,\n-\t\t\t  unsigned HOST_WIDE_INT, rtx, int);\n+\t\t\t  unsigned HOST_WIDE_INT, int);\n static rtx if_then_else_cond (rtx, rtx *, rtx *);\n static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n static int rtx_equal_for_field_assignment_p (rtx, rtx);\n@@ -4264,7 +4265,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t    GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))))\n \tSUBST (XEXP (x, 0),\n \t       force_to_mode (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t      GET_MODE_MASK (mode), NULL_RTX, 0));\n+\t\t\t      GET_MODE_MASK (mode), 0));\n \n       /* (truncate:SI ({sign,zero}_extend:DI foo:SI)) == foo:SI.  */\n       if ((GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n@@ -4864,7 +4865,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t      ((HOST_WIDE_INT) 1\n \t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n \t\t\t      - 1,\n-\t\t\t      NULL_RTX, 0));\n+\t\t\t      0));\n       break;\n \n     case VEC_SELECT:\n@@ -5266,7 +5267,7 @@ simplify_set (rtx x)\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      src = force_to_mode (src, mode, ~(HOST_WIDE_INT) 0, NULL_RTX, 0);\n+      src = force_to_mode (src, mode, ~(HOST_WIDE_INT) 0, 0);\n       SUBST (SET_SRC (x), src);\n     }\n \n@@ -6395,7 +6396,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? ~(unsigned HOST_WIDE_INT) 0\n \t\t\t     : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n-\t\t\t     NULL_RTX, 0);\n+\t\t\t     0);\n \n       /* If this extraction is going into the destination of a SET,\n \t make a STRICT_LOW_PART unless we made a MEM.  */\n@@ -6585,7 +6586,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t\t     ? ~(unsigned HOST_WIDE_INT) 0\n \t\t\t     : ((((unsigned HOST_WIDE_INT) 1 << len) - 1)\n \t\t\t\t<< orig_pos),\n-\t\t\t     NULL_RTX, 0);\n+\t\t\t     0);\n     }\n \n   /* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we\n@@ -6918,7 +6919,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t    && subreg_lowpart_p (x))\n \t  {\n \t    rtx newer = force_to_mode (tem, mode, ~(HOST_WIDE_INT) 0,\n-\t\t\t\t       NULL_RTX, 0);\n+\t\t\t\t       0);\n \t    \n \t    /* If we have something other than a SUBREG, we might have\n \t       done an expansion, so rerun ourselves.  */\n@@ -6991,6 +6992,105 @@ get_pos_from_mask (unsigned HOST_WIDE_INT m, unsigned HOST_WIDE_INT *plen)\n   return pos;\n }\n \f\n+/* If X refers to a register that equals REG in value, replace these\n+   references with REG.  */\n+static rtx\n+canon_reg_for_combine (rtx x, rtx reg)\n+{\n+  rtx op0, op1, op2;\n+  const char *fmt;\n+  int i;\n+  bool copied;\n+\n+  enum rtx_code code = GET_CODE (x);\n+  switch (GET_RTX_CLASS (code))\n+    {\n+    case RTX_UNARY:\n+      op0 = canon_reg_for_combine (XEXP (x, 0), reg);\n+      if (op0 != XEXP (x, 0))\n+\treturn simplify_gen_unary (GET_CODE (x), GET_MODE (x), op0,\n+\t\t\t\t   GET_MODE (reg));\n+      break;\n+\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n+      op0 = canon_reg_for_combine (XEXP (x, 0), reg);\n+      op1 = canon_reg_for_combine (XEXP (x, 1), reg);\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n+\treturn simplify_gen_binary (GET_CODE (x), GET_MODE (x), op0, op1);\n+      break;\n+\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n+      op0 = canon_reg_for_combine (XEXP (x, 0), reg);\n+      op1 = canon_reg_for_combine (XEXP (x, 1), reg);\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n+\treturn simplify_gen_relational (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t\tGET_MODE (op0), op0, op1);\n+      break;\n+\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n+      op0 = canon_reg_for_combine (XEXP (x, 0), reg);\n+      op1 = canon_reg_for_combine (XEXP (x, 1), reg);\n+      op2 = canon_reg_for_combine (XEXP (x, 2), reg);\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1) || op2 != XEXP (x, 2))\n+\treturn simplify_gen_ternary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t     GET_MODE (op0), op0, op1, op2);\n+\n+    case RTX_OBJ:\n+      if (REG_P (x))\n+\t{\n+\t  if (rtx_equal_p (get_last_value (reg), x)\n+\t      || rtx_equal_p (reg, get_last_value (x)))\n+\t    return reg;\n+\t  else\n+\t    break;\n+\t}\n+\n+      /* fall through */\n+\n+    default:\n+      fmt = GET_RTX_FORMAT (code);\n+      copied = false;\n+      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+        if (fmt[i] == 'e')\n+          {\n+            rtx op = canon_reg_for_combine (XEXP (x, i), reg);\n+\t    if (op != XEXP (x, i))\n+\t      {\n+\t\tif (!copied)\n+\t\t  {\n+\t\t    copied = true;\n+\t\t    x = copy_rtx (x);\n+\t\t  }\n+\t\tXEXP (x, i) = op;\n+              }\n+          }\n+        else if (fmt[i] == 'E')\n+          {\n+            int j;\n+            for (j = 0; j < XVECLEN (x, i); j++)\n+\t      {\n+\t        rtx op = canon_reg_for_combine (XVECEXP (x, i, j), reg);\n+\t        if (op != XVECEXP (x, i, j))\n+\t\t  {\n+\t\t    if (!copied)\n+\t\t      {\n+\t\t\tcopied = true;\n+\t\t\tx = copy_rtx (x);\n+\t\t      }\n+\t\t    XVECEXP (x, i, j) = op;\n+\t          }\n+\t      }\n+\t  }\n+\n+      break;\n+    }\n+\n+  return x;\n+}\n+\n /* See if X can be simplified knowing that we will only refer to it in\n    MODE and will only refer to those bits that are nonzero in MASK.\n    If other bits are being computed or if masking operations are done\n@@ -7000,16 +7100,13 @@ get_pos_from_mask (unsigned HOST_WIDE_INT m, unsigned HOST_WIDE_INT *plen)\n    Return a possibly simplified expression, but always convert X to\n    MODE.  If X is a CONST_INT, AND the CONST_INT with MASK.\n \n-   Also, if REG is nonzero and X is a register equal in value to REG,\n-   replace X with REG.\n-\n    If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK\n    are all off in X.  This is used when X will be complemented, by either\n    NOT, NEG, or XOR.  */\n \n static rtx\n force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n-\t       rtx reg, int just_select)\n+\t       int just_select)\n {\n   enum rtx_code code = GET_CODE (x);\n   int next_select = just_select || code == XOR || code == NOT || code == NEG;\n@@ -7091,7 +7188,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t within that boundary, we don't need the USE any more.  */\n       if (! BITS_BIG_ENDIAN\n \t  && (mask & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n       break;\n \n     case SIGN_EXTEND:\n@@ -7100,13 +7197,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n     case SIGN_EXTRACT:\n       x = expand_compound_operation (x);\n       if (GET_CODE (x) != code)\n-\treturn force_to_mode (x, mode, mask, reg, next_select);\n-      break;\n-\n-    case REG:\n-      if (reg != 0 && (rtx_equal_p (get_last_value (reg), x)\n-\t\t       || rtx_equal_p (reg, get_last_value (x))))\n-\tx = reg;\n+\treturn force_to_mode (x, mode, mask, next_select);\n       break;\n \n     case SUBREG:\n@@ -7119,7 +7210,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t      || (0 == (mask\n \t\t\t& GET_MODE_MASK (GET_MODE (x))\n \t\t\t& ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n-\treturn force_to_mode (SUBREG_REG (x), mode, mask, reg, next_select);\n+\treturn force_to_mode (SUBREG_REG (x), mode, mask, next_select);\n       break;\n \n     case AND:\n@@ -7195,7 +7286,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t    && (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n \t  return force_to_mode (plus_constant (XEXP (x, 0),\n \t\t\t\t\t       (INTVAL (XEXP (x, 1)) & smask)),\n-\t\t\t\tmode, smask, reg, next_select);\n+\t\t\t\tmode, smask, next_select);\n       }\n \n       /* ... fall through ...  */\n@@ -7217,7 +7308,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  x = simplify_gen_unary (NEG, GET_MODE (x), XEXP (x, 1),\n \t\t\t\t  GET_MODE (x));\n-\t  return force_to_mode (x, mode, mask, reg, next_select);\n+\t  return force_to_mode (x, mode, mask, next_select);\n \t}\n \n       /* Similarly, if C contains every bit in the fuller_mask, then we may\n@@ -7228,7 +7319,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  x = simplify_gen_unary (NOT, GET_MODE (x),\n \t\t\t\t  XEXP (x, 1), GET_MODE (x));\n-\t  return force_to_mode (x, mode, mask, reg, next_select);\n+\t  return force_to_mode (x, mode, mask, next_select);\n \t}\n \n       mask = fuller_mask;\n@@ -7258,7 +7349,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n \t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x), temp,\n \t\t\t\t   XEXP (XEXP (x, 0), 1));\n-\t  return force_to_mode (x, mode, mask, reg, next_select);\n+\t  return force_to_mode (x, mode, mask, next_select);\n \t}\n \n     binop:\n@@ -7267,10 +7358,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n       op0 = gen_lowpart (op_mode,\n \t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\treg, next_select));\n+\t\t\t\t\tnext_select));\n       op1 = gen_lowpart (op_mode,\n \t\t\t force_to_mode (XEXP (x, 1), mode, mask,\n-\t\t\t\t\treg, next_select));\n+\t\t\t\t\tnext_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n \tx = simplify_gen_binary (code, op_mode, op0, op1);\n@@ -7304,7 +7395,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n       op0 = gen_lowpart (op_mode,\n \t\t\t force_to_mode (XEXP (x, 0), op_mode,\n-\t\t\t\t\tmask, reg, next_select));\n+\t\t\t\t\tmask, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = simplify_gen_binary (code, op_mode, op0, XEXP (x, 1));\n@@ -7331,7 +7422,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  if ((inner_mask & ~GET_MODE_MASK (GET_MODE (x))) != 0)\n \t    op_mode = GET_MODE (x);\n \n-\t  inner = force_to_mode (inner, op_mode, inner_mask, reg, next_select);\n+\t  inner = force_to_mode (inner, op_mode, inner_mask, next_select);\n \n \t  if (GET_MODE (x) != op_mode || inner != XEXP (x, 0))\n \t    x = simplify_gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n@@ -7368,7 +7459,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       if (GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n \t  && (mask == ((unsigned HOST_WIDE_INT) 1\n \t\t       << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n \n       /* If this is a shift by a constant, get a mask that contains those bits\n \t that are not copies of the sign bit.  We then have two cases:  If\n@@ -7416,7 +7507,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t : GET_MODE_BITSIZE (GET_MODE (x)) - 1 - i);\n \n \t      if (GET_CODE (x) != ASHIFTRT)\n-\t\treturn force_to_mode (x, mode, mask, reg, next_select);\n+\t\treturn force_to_mode (x, mode, mask, next_select);\n \t    }\n \t}\n \n@@ -7440,7 +7531,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  && GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && XEXP (XEXP (x, 0), 1) == XEXP (x, 1))\n \treturn force_to_mode (XEXP (XEXP (x, 0), 0), mode, mask,\n-\t\t\t      reg, next_select);\n+\t\t\t      next_select);\n \n       break;\n \n@@ -7459,15 +7550,15 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  if (temp && GET_CODE (temp) == CONST_INT)\n \t    SUBST (XEXP (x, 0),\n \t\t   force_to_mode (XEXP (x, 0), GET_MODE (x),\n-\t\t\t\t  INTVAL (temp), reg, next_select));\n+\t\t\t\t  INTVAL (temp), next_select));\n \t}\n       break;\n \n     case NEG:\n       /* If we just want the low-order bit, the NEG isn't needed since it\n \t won't change the low-order bit.  */\n       if (mask == 1)\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, just_select);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, just_select);\n \n       /* We need any bits less significant than the most significant bit in\n \t MASK since carries from those bits will affect the bits we are\n@@ -7494,7 +7585,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n \t\t\t\t   temp, XEXP (XEXP (x, 0), 1));\n \n-\t  return force_to_mode (x, mode, mask, reg, next_select);\n+\t  return force_to_mode (x, mode, mask, next_select);\n \t}\n \n       /* (and (not FOO) CONST) is (not (or FOO (not CONST))), so we must\n@@ -7504,7 +7595,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n     unop:\n       op0 = gen_lowpart (op_mode,\n \t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\treg, next_select));\n+\t\t\t\t\tnext_select));\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = simplify_gen_unary (code, op_mode, op0, op_mode);\n       break;\n@@ -7518,7 +7609,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  && exact_log2 (nonzero_bits (XEXP (x, 0), mode)) >= 0\n \t  && (nonzero_bits (XEXP (x, 0), mode)\n \t      == (unsigned HOST_WIDE_INT) STORE_FLAG_VALUE))\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n \n       break;\n \n@@ -7527,13 +7618,11 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t written in a narrower mode.  We play it safe and do not do so.  */\n \n       SUBST (XEXP (x, 1),\n-\t     gen_lowpart (GET_MODE (x),\n-\t\t\t\t      force_to_mode (XEXP (x, 1), mode,\n-\t\t\t\t\t\t     mask, reg, next_select)));\n+\t     gen_lowpart (GET_MODE (x), force_to_mode (XEXP (x, 1), mode,\n+\t\t\t\t\t\t       mask, next_select)));\n       SUBST (XEXP (x, 2),\n-\t     gen_lowpart (GET_MODE (x),\n-\t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n-\t\t\t\t\t\t     mask, reg, next_select)));\n+\t     gen_lowpart (GET_MODE (x), force_to_mode (XEXP (x, 2), mode,\n+\t\t\t\t\t\t       mask, next_select)));\n       break;\n \n     default:\n@@ -8085,13 +8174,15 @@ make_field_assignment (rtx x)\n   /* Shift OTHER right POS places and make it the source, restricting it\n      to the proper length and mode.  */\n \n-  src = force_to_mode (simplify_shift_const (NULL_RTX, LSHIFTRT,\n-\t\t\t\t\t     GET_MODE (src), other, pos),\n-\t\t       mode,\n+  src = canon_reg_for_combine (simplify_shift_const (NULL_RTX, LSHIFTRT,\n+\t\t\t\t\t\t     GET_MODE (src),\n+\t\t\t\t\t\t     other, pos),\n+\t\t\t       dest);\n+  src = force_to_mode (src, mode,\n \t\t       GET_MODE_BITSIZE (mode) >= HOST_BITS_PER_WIDE_INT\n \t\t       ? ~(unsigned HOST_WIDE_INT) 0\n \t\t       : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n-\t\t       dest, 0);\n+\t\t       0);\n \n   /* If SRC is masked by an AND that does not make a difference in\n      the value being stored, strip it.  */\n@@ -8320,7 +8411,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n      CONSTOP are not significant and will never be examined.  We must\n      ensure that is the case by explicitly masking out those bits\n      before returning.  */\n-  varop = force_to_mode (varop, mode, constop, NULL_RTX, 0);\n+  varop = force_to_mode (varop, mode, constop, 0);\n \n   /* If VAROP is a CLOBBER, we will fail so return it.  */\n   if (GET_CODE (varop) == CLOBBER)\n@@ -8374,7 +8465,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n \t\t\t\t\t\t       XEXP (varop, 1),\n \t\t\t\t\t\t       constop))));\n \n-  /* If VAROP is PLUS, and the constant is a mask of low bite, distribute\n+  /* If VAROP is PLUS, and the constant is a mask of low bits, distribute\n      the AND and see if one of the operands simplifies to zero.  If so, we\n      may eliminate it.  */\n \n@@ -10095,7 +10186,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \top0 = force_to_mode (op0, mode,\n \t\t\t     ((HOST_WIDE_INT) 1\n \t\t\t      << (GET_MODE_BITSIZE (mode) - 1)),\n-\t\t\t     NULL_RTX, 0);\n+\t\t\t     0);\n \n       /* Now try cases based on the opcode of OP0.  If none of the cases\n \t does a \"continue\", we exit this loop immediately after the"}]}