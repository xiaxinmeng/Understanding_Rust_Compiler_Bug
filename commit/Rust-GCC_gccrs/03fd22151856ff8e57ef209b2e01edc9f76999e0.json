{"sha": "03fd22151856ff8e57ef209b2e01edc9f76999e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmZDIyMTUxODU2ZmY4ZTU3ZWYyMDliMmUwMWVkYzlmNzY5OTllMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-01-20T00:46:37Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-01-20T00:46:37Z"}, "message": "loop-iv.c: Include df.h and hashtab.h.\n\n\t* loop-iv.c: Include df.h and hashtab.h.\n\t(enum iv_grd_result): New enum.\n\t(DF_REF_IV, DF_REF_IV_SET): New macros.\n\t(struct biv_entry): New.\n\t(df, bivs): New global variables.\n\t(struct insn_info, insn_info, last_def, bivs, max_insn_no, max_reg_no,\n\tassign_luids, mark_sets, kill_sets, mark_single_set, simple_set_p):\n\tRemoved.\n\t(clear_iv_info, latch_dominating_def, record_iv, iv_analyze_expr,\n\tiv_analyze_result, iv_analyze_def, biv_hash, biv_eq,\n\tanalyzed_for_bivness_p, record_biv): New functions.\n\t(iv_analysis_loop_init, iv_get_reaching_def, simple_reg_p,\n\tget_biv_step_1, get_biv_step, iv_analyze_biv, iv_analyze_op,\n\tiv_analyze, biv_p, iv_analysis_done): Work with df representation of\n\tUD chains.\n\t(iv_constant, iv_subreg, iv_extend, iv_mult, iv_shift): Do not set\n\tanalysed.\n\t(iv_number_of_iterations): Use new interface to iv analysis.\n\t* loop-unroll.c: Do not include varray.h.\n\t(analyze_iv_to_split_insn): Use new interface to iv\n\tanalysis.\n\t* loop-unswitch.c (may_unswitch_on): Ditto.\n\t* df.c (df_bitmaps_free): Only work for bbs for that structures are\n\tallocated.\n\t(df_bb_modify): Realloc tables to the new index.\n\t(df_find_use): New function.\n\t* df.h (df_find_use): Declare.\n\t* optabs.c (expand_unop): Make the mode of the REG_EQUAL node be\n\toutmode.\n\t* cfgloop.h (struct rtx_iv): Remove analysed field.\n\t(iv_get_reaching_def): Removed.\n\t(iv_analyze_result, iv_analyze_expr, iv_current_loop_df): Declare.\n\t* Makefile.in (loop-unroll.o): Remove VARRAY_H dependency.\n\t(loop-iv.o): Add df.h and hashtab.h dependency.\n\t* df-problems.c (df_ru_alloc, df_rd_alloc): Fix memory reallocation.\n\nFrom-SVN: r110005", "tree": {"sha": "f0310ff5933484ccfcb5cd7fb312fb89350141a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0310ff5933484ccfcb5cd7fb312fb89350141a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03fd22151856ff8e57ef209b2e01edc9f76999e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd22151856ff8e57ef209b2e01edc9f76999e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03fd22151856ff8e57ef209b2e01edc9f76999e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd22151856ff8e57ef209b2e01edc9f76999e0/comments", "author": null, "committer": null, "parents": [{"sha": "b04c90638b1b3042078fda9582f3b3008ce51bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b04c90638b1b3042078fda9582f3b3008ce51bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b04c90638b1b3042078fda9582f3b3008ce51bc1"}], "stats": {"total": 986, "additions": 506, "deletions": 480}, "files": [{"sha": "836da92b968ef6256265776c22ad6e6a759b6daa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -1,3 +1,41 @@\n+2006-01-20  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* loop-iv.c: Include df.h and hashtab.h.\n+\t(enum iv_grd_result): New enum.\n+\t(DF_REF_IV, DF_REF_IV_SET): New macros.\n+\t(struct biv_entry): New.\n+\t(df, bivs): New global variables.\n+\t(struct insn_info, insn_info, last_def, bivs, max_insn_no, max_reg_no,\n+\tassign_luids, mark_sets, kill_sets, mark_single_set, simple_set_p):\n+\tRemoved.\n+\t(clear_iv_info, latch_dominating_def, record_iv, iv_analyze_expr,\n+\tiv_analyze_result, iv_analyze_def, biv_hash, biv_eq,\n+\tanalyzed_for_bivness_p, record_biv): New functions.\n+\t(iv_analysis_loop_init, iv_get_reaching_def, simple_reg_p,\n+\tget_biv_step_1, get_biv_step, iv_analyze_biv, iv_analyze_op,\n+\tiv_analyze, biv_p, iv_analysis_done): Work with df representation of\n+\tUD chains.\n+\t(iv_constant, iv_subreg, iv_extend, iv_mult, iv_shift): Do not set\n+\tanalysed.\n+\t(iv_number_of_iterations): Use new interface to iv analysis.\n+\t* loop-unroll.c: Do not include varray.h.\n+\t(analyze_iv_to_split_insn): Use new interface to iv\n+\tanalysis.\n+\t* loop-unswitch.c (may_unswitch_on): Ditto.\n+\t* df.c (df_bitmaps_free): Only work for bbs for that structures are\n+\tallocated.\n+\t(df_bb_modify): Realloc tables to the new index.\n+\t(df_find_use): New function.\n+\t* df.h (df_find_use): Declare.\n+\t* optabs.c (expand_unop): Make the mode of the REG_EQUAL node be\n+\toutmode.\n+\t* cfgloop.h (struct rtx_iv): Remove analysed field.\n+\t(iv_get_reaching_def): Removed.\n+\t(iv_analyze_result, iv_analyze_expr, iv_current_loop_df): Declare.\n+\t* Makefile.in (loop-unroll.o): Remove VARRAY_H dependency.\n+\t(loop-iv.o): Add df.h and hashtab.h dependency.\n+\t* df-problems.c (df_ru_alloc, df_rd_alloc): Fix memory reallocation.\n+\n 2006-01-20  Alan Modra  <amodra@bigpond.net.au>\n \n \t* libgcc2.c (__floatdisf, __floatdidf): Don't use IBM Extended"}, {"sha": "fe983d49396e807166159c08b4a3a3f5fcbd4285", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -2431,7 +2431,7 @@ struct-equiv.o : struct-equiv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(REGS_H) $(EMIT_RTL_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n-   output.h intl.h\n+   output.h intl.h $(DF_H) $(HASHTAB_H)\n loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h \\\n    $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) $(OBSTACK_H) output.h \\\n@@ -2447,7 +2447,7 @@ loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)\n loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n-   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) $(VARRAY_H) \\\n+   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \\\n    $(OBSTACK_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) toplev.h"}, {"sha": "3139ef7078011c96a5ca0e22e1d46ac89ff98659", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -352,9 +352,6 @@ struct rtx_iv\n   /* The mode the variable iterates in.  */\n   enum machine_mode mode;\n \n-  /* Whether we have already filled the remaining fields.  */\n-  unsigned analysed : 1;\n-\n   /* Whether the first iteration needs to be handled specially.  */\n   unsigned first_special : 1;\n };\n@@ -404,12 +401,14 @@ struct niter_desc\n };\n \n extern void iv_analysis_loop_init (struct loop *);\n-extern rtx iv_get_reaching_def (rtx, rtx);\n extern bool iv_analyze (rtx, rtx, struct rtx_iv *);\n+extern bool iv_analyze_result (rtx, rtx, struct rtx_iv *);\n+extern bool iv_analyze_expr (rtx, rtx, enum machine_mode, struct rtx_iv *);\n extern rtx get_iv_value (struct rtx_iv *, rtx);\n extern bool biv_p (rtx, rtx);\n extern void find_simple_exit (struct loop *, struct niter_desc *);\n extern void iv_analysis_done (void);\n+extern struct df *iv_current_loop_df (void);\n \n extern struct niter_desc *get_simple_loop_desc (struct loop *loop);\n extern void free_simple_loop_desc (struct loop *loop);"}, {"sha": "2a7ec0d0ed9f9fe8909f5716acc9f7a9caab9f1c", "filename": "gcc/df-problems.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -369,12 +369,12 @@ df_ru_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \t    }\n \t}\n       \n-      if (problem_data->use_sites_size > reg_size)\n+      if (problem_data->use_sites_size < reg_size)\n \t{\n \t  problem_data->use_sites \n-\t    = xrealloc (problem_data->use_sites, reg_size *sizeof (bitmap));\n-\t  memset (problem_data->use_sites, 0,\n-\t\t  (reg_size - problem_data->use_sites_size) *sizeof (bitmap));\n+\t    = xrealloc (problem_data->use_sites, reg_size * sizeof (bitmap));\n+\t  memset (problem_data->use_sites + problem_data->use_sites_size, 0,\n+\t\t  (reg_size - problem_data->use_sites_size) * sizeof (bitmap));\n \t  problem_data->use_sites_size = reg_size;\n \t}\n \n@@ -876,11 +876,11 @@ df_rd_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \t    }\n \t}\n       \n-      if (problem_data->def_sites_size > reg_size)\n+      if (problem_data->def_sites_size < reg_size)\n \t{\n \t  problem_data->def_sites \n \t    = xrealloc (problem_data->def_sites, reg_size *sizeof (bitmap));\n-\t  memset (problem_data->def_sites, 0,\n+\t  memset (problem_data->def_sites + problem_data->def_sites_size, 0,\n \t\t  (reg_size - problem_data->def_sites_size) *sizeof (bitmap));\n \t  problem_data->def_sites_size = reg_size;\n \t}"}, {"sha": "e3ec78b7cfcb1412a4676abf500fee176a24bd18", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 453, "deletions": 462, "changes": 915, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -18,34 +18,35 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/* This is just a very simplistic analysis of induction variables of the loop.\n-   The major use is for determining the number of iterations of a loop for\n-   loop unrolling, doloop optimization and branch prediction.  For this we\n-   are only interested in bivs and a fairly limited set of givs that are\n-   needed in the exit condition.  We also only compute the iv information on\n-   demand.\n-\n-   The interesting registers are determined.  A register is interesting if\n-\n-   -- it is set only in the blocks that dominate the latch of the current loop\n-   -- all its sets are simple -- i.e. in the form we understand\n-\n-   We also number the insns sequentially in each basic block.  For a use of the\n-   interesting reg, it is now easy to find a reaching definition (there may be\n-   only one).\n-\n-   Induction variable is then simply analyzed by walking the use-def\n-   chains.\n-   \n-   Usage:\n-\n-   iv_analysis_loop_init (loop);\n-   insn = iv_get_reaching_def (where, reg);\n-   if (iv_analyze (insn, reg, &iv))\n-     {\n-       ...\n-     }\n-   iv_analysis_done (); */\n+/* This is a simple analysis of induction variables of the loop.  The major use\n+   is for determining the number of iterations of a loop for loop unrolling,\n+   doloop optimization and branch prediction.  The iv information is computed\n+   on demand.\n+\n+   Induction variable is analyzed by walking the use-def chains.  When a biv\n+   is found, it is cached in the bivs hash table.  When register is proved\n+   to be a giv, its description is stored to DF_REF_DATA of the def reference.\n+\n+   The analysis works always with one loop -- you must call\n+   iv_analysis_loop_init (loop) for it.  All the other functions then work with\n+   this loop.   When you need to work with another loop, just call\n+   iv_analysis_loop_init for it.  When you no longer need iv analysis, call\n+   iv_analysis_done () to clean up the memory.\n+\n+   The available functions are:\n+ \n+   iv_analyze (insn, reg, iv): Stores the description of the induction variable\n+     corresponding to the use of register REG in INSN to IV.  Returns true if\n+     REG is an induction variable in INSN. false otherwise.\n+     If use of REG is not found in INSN, following insns are scanned (so that\n+     we may call this function on insn returned by get_condition).\n+   iv_analyze_result (insn, def, iv):  Stores to IV the description of the iv\n+     corresponding to DEF, which is a register defined in INSN.\n+   iv_analyze_expr (insn, rhs, mode, iv):  Stores to IV the description of iv\n+     corresponding to expression EXPR evaluated at INSN.  All registers used bu\n+     EXPR must also be used in INSN.\n+   iv_current_loop_df (): Returns the dataflow object for the current loop used\n+     by iv analysis.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -60,40 +61,61 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"intl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"df.h\"\n+#include \"hashtab.h\"\n \n-/* The insn information.  */\n+/* Possible return values of iv_get_reaching_def.  */\n \n-struct insn_info\n+enum iv_grd_result\n {\n-  /* Id of the insn.  */\n-  unsigned luid;\n+  /* More than one reaching def, or reaching def that does not\n+     dominate the use.  */\n+  GRD_INVALID,\n \n-  /* The previous definition of the register defined by the single\n-     set in the insn.  */\n-  rtx prev_def;\n+  /* The use is trivial invariant of the loop, i.e. is not changed\n+     inside the loop.  */\n+  GRD_INVARIANT,\n \n-  /* The description of the iv.  */\n-  struct rtx_iv iv;\n+  /* The use is reached by initial value and a value from the\n+     previous iteration.  */\n+  GRD_MAYBE_BIV,\n+\n+  /* The use has single dominating def.  */\n+  GRD_SINGLE_DOM\n+};\n+\n+/* Information about a biv.  */\n+\n+struct biv_entry\n+{\n+  unsigned regno;\t/* The register of the biv.  */\n+  struct rtx_iv iv;\t/* Value of the biv.  */\n };\n \n-static struct insn_info *insn_info;\n+/* Induction variable stored at the reference.  */\n+#define DF_REF_IV(REF) ((struct rtx_iv *) DF_REF_DATA (REF))\n+#define DF_REF_IV_SET(REF, IV) DF_REF_DATA (REF) = (IV)\n \n-/* The last definition of register.  */\n+/* The current loop.  */\n \n-static rtx *last_def;\n+static struct loop *current_loop;\n \n-/* The bivs.  */\n+/* Dataflow information for the current loop.  */\n \n-static struct rtx_iv *bivs;\n+static struct df *df = NULL;\n \n-/* Maximal insn number for that there is place in insn_info array.  */\n+/* Bivs of the current loop.  */\n \n-static unsigned max_insn_no;\n+static htab_t bivs;\n \n-/* Maximal register number for that there is place in bivs and last_def\n-   arrays.  */\n+/* Return the dataflow object for the current loop.  */\n+struct df *\n+iv_current_loop_df (void)\n+{\n+  return df;\n+}\n \n-static unsigned max_reg_no;\n+static bool iv_analyze_op (rtx, rtx, struct rtx_iv *);\n \n /* Dumps information about IV to FILE.  */\n \n@@ -139,23 +161,6 @@ dump_iv_info (FILE *file, struct rtx_iv *iv)\n     fprintf (file, \" (first special)\");\n }\n \n-/* Assigns luids to insns in basic block BB.  */\n-\n-static void\n-assign_luids (basic_block bb)\n-{\n-  unsigned i = 0, uid;\n-  rtx insn;\n-\n-  FOR_BB_INSNS (bb, insn)\n-    {\n-      uid = INSN_UID (insn);\n-      insn_info[uid].luid = i++;\n-      insn_info[uid].prev_def = NULL_RTX;\n-      insn_info[uid].iv.analysed = false;\n-    }\n-}\n-\n /* Generates a subreg to get the least significant part of EXPR (in mode\n    INNER_MODE) to OUTER_MODE.  */\n \n@@ -191,229 +196,162 @@ simple_reg_p (rtx reg)\n   if (GET_MODE_CLASS (GET_MODE (reg)) != MODE_INT)\n     return false;\n \n-  if (last_def[r] == const0_rtx)\n-    return false;\n-\n   return true;\n }\n \n-/* Checks whether assignment LHS = RHS is simple enough for us to process.  */\n+/* Clears the information about ivs stored in df.  */\n \n-static bool\n-simple_set_p (rtx lhs, rtx rhs)\n+static void\n+clear_iv_info (void)\n {\n-  rtx op0, op1;\n-\n-  if (!REG_P (lhs)\n-      || !simple_reg_p (lhs))\n-    return false;\n-\n-  if (CONSTANT_P (rhs))\n-    return true;\n+  unsigned i, n_defs = DF_DEFS_SIZE (df);\n+  struct rtx_iv *iv;\n+  struct df_ref *def;\n \n-  switch (GET_CODE (rhs))\n+  for (i = 0; i < n_defs; i++)\n     {\n-    case SUBREG:\n-    case REG:\n-      return simple_reg_p (rhs);\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-    case NEG:\n-      return simple_reg_p (XEXP (rhs, 0));\n-\n-    case PLUS:\n-    case MINUS:\n-    case MULT:\n-    case ASHIFT:\n-      op0 = XEXP (rhs, 0);\n-      op1 = XEXP (rhs, 1);\n-\n-      if (!simple_reg_p (op0)\n-\t  && !CONSTANT_P (op0))\n-\treturn false;\n-\n-      if (!simple_reg_p (op1)\n-\t  && !CONSTANT_P (op1))\n-\treturn false;\n-\n-      if (GET_CODE (rhs) == MULT\n-\t  && !CONSTANT_P (op0)\n-\t  && !CONSTANT_P (op1))\n-\treturn false;\n-\n-      if (GET_CODE (rhs) == ASHIFT\n-\t  && CONSTANT_P (op0))\n-\treturn false;\n-\n-      return true;\n-\n-    default:\n-      return false;\n+      def = DF_DEFS_GET (df, i);\n+      iv = DF_REF_IV (def);\n+      if (!iv)\n+\tcontinue;\n+      free (iv);\n+      DF_REF_IV_SET (def, NULL);\n     }\n-}\n-\n-/* Mark single SET in INSN.  */\n \n-static rtx\n-mark_single_set (rtx insn, rtx set)\n-{\n-  rtx def = SET_DEST (set), src;\n-  unsigned regno, uid;\n-\n-  src = find_reg_equal_equiv_note (insn);\n-  if (src)\n-    src = XEXP (src, 0);\n-  else\n-    src = SET_SRC (set);\n-\n-  if (!simple_set_p (SET_DEST (set), src))\n-    return NULL_RTX;\n-\n-  regno = REGNO (def);\n-  uid = INSN_UID (insn);\n-\n-  bivs[regno].analysed = false;\n-  insn_info[uid].prev_def = last_def[regno];\n-  last_def[regno] = insn;\n-\n-  return def;\n+  htab_empty (bivs);\n }\n \n-/* Invalidate register REG unless it is equal to EXCEPT.  */\n+/* Returns hash value for biv B.  */\n \n-static void\n-kill_sets (rtx reg, rtx by ATTRIBUTE_UNUSED, void *except)\n+static hashval_t\n+biv_hash (const void *b)\n {\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-  if (!REG_P (reg))\n-    return;\n-  if (reg == except)\n-    return;\n-\n-  last_def[REGNO (reg)] = const0_rtx;\n+  return ((const struct biv_entry *) b)->regno;\n }\n \n-/* Marks sets in basic block BB.  If DOM is true, BB dominates the loop\n-   latch.  */\n+/* Compares biv B and register R.  */\n \n-static void\n-mark_sets (basic_block bb, bool dom)\n+static int\n+biv_eq (const void *b, const void *r)\n {\n-  rtx insn, set, def;\n-\n-  FOR_BB_INSNS (bb, insn)\n-    {\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      if (dom\n-\t  && (set = single_set (insn)))\n-\tdef = mark_single_set (insn, set);\n-      else\n-\tdef = NULL_RTX;\n-\n-      note_stores (PATTERN (insn), kill_sets, def);\n-    }\n+  return ((const struct biv_entry *) b)->regno == REGNO ((rtx) r);\n }\n \n /* Prepare the data for an induction variable analysis of a LOOP.  */\n \n void\n iv_analysis_loop_init (struct loop *loop)\n {\n-  basic_block *body = get_loop_body_in_dom_order (loop);\n-  unsigned b;\n+  basic_block *body = get_loop_body_in_dom_order (loop), bb;\n+  bitmap blocks = BITMAP_ALLOC (NULL);\n+  unsigned i;\n+  bool first_time = (df == NULL);\n \n-  if ((unsigned) get_max_uid () >= max_insn_no)\n-    {\n-      /* Add some reserve for insns and registers produced in optimizations.  */\n-      max_insn_no = get_max_uid () + 100;\n-      if (insn_info)\n-\tfree (insn_info);\n-      insn_info = xmalloc (max_insn_no * sizeof (struct insn_info));\n-    }\n+  current_loop = loop;\n \n-  if ((unsigned) max_reg_num () >= max_reg_no)\n+  /* Clear the information from the analysis of the previous loop.  */\n+  if (first_time)\n     {\n-      max_reg_no = max_reg_num () + 100;\n-      if (last_def)\n-\tfree (last_def);\n-      last_def = xmalloc (max_reg_no * sizeof (rtx));\n-      if (bivs)\n-\tfree (bivs);\n-      bivs = xmalloc (max_reg_no * sizeof (struct rtx_iv));\n+      df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES);\n+      df_chain_add_problem (df, DF_UD_CHAIN);\n+      bivs = htab_create (10, biv_hash, biv_eq, free);\n     }\n+  else\n+    clear_iv_info ();\n \n-  memset (last_def, 0, max_reg_num () * sizeof (rtx));\n-\n-  for (b = 0; b < loop->num_nodes; b++)\n+  for (i = 0; i < loop->num_nodes; i++)\n     {\n-      assign_luids (body[b]);\n-      mark_sets (body[b], just_once_each_iteration_p (loop, body[b]));\n+      bb = body[i];\n+      bitmap_set_bit (blocks, bb->index);\n     }\n-\n+  df_set_blocks (df, blocks);\n+  df_analyze (df); \n+  BITMAP_FREE (blocks);\n   free (body);\n }\n \n-/* Gets definition of REG reaching the INSN.  If REG is not simple, const0_rtx\n-   is returned.  If INSN is before the first def in the loop, NULL_RTX is\n-   returned.  */\n+/* Finds the definition of REG that dominates loop latch and stores\n+   it to DEF.  Returns false if there is not a single definition\n+   dominating the latch.  If REG has no definition in loop, DEF\n+   is set to NULL and true is returned.  */\n \n-rtx\n-iv_get_reaching_def (rtx insn, rtx reg)\n+static bool\n+latch_dominating_def (rtx reg, struct df_ref **def)\n {\n-  unsigned regno, luid, auid;\n-  rtx ainsn;\n-  basic_block bb, abb;\n+  struct df_ref *single_rd = NULL, *adef;\n+  unsigned regno = REGNO (reg);\n+  struct df_reg_info *reg_info = DF_REG_DEF_GET (df, regno);\n+  struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (df, current_loop->latch);\n \n-  if (GET_CODE (reg) == SUBREG)\n+  for (adef = reg_info->reg_chain; adef; adef = adef->next_reg)\n     {\n-      if (!subreg_lowpart_p (reg))\n-\treturn const0_rtx;\n-      reg = SUBREG_REG (reg);\n+      if (!bitmap_bit_p (bb_info->out, DF_REF_ID (adef)))\n+\tcontinue;\n+\n+      /* More than one reaching definition.  */\n+      if (single_rd)\n+\treturn false;\n+\n+      if (!just_once_each_iteration_p (current_loop, DF_REF_BB (adef)))\n+\treturn false;\n+\n+      single_rd = adef;\n     }\n-  if (!REG_P (reg))\n-    return NULL_RTX;\n \n-  regno = REGNO (reg);\n-  if (!last_def[regno]\n-      || last_def[regno] == const0_rtx)\n-    return last_def[regno];\n+  *def = single_rd;\n+  return true;\n+}\n \n-  bb = BLOCK_FOR_INSN (insn);\n-  luid = insn_info[INSN_UID (insn)].luid;\n+/* Gets definition of REG reaching its use in INSN and stores it to DEF.  */\n \n-  ainsn = last_def[regno];\n-  while (1)\n-    {\n-      abb = BLOCK_FOR_INSN (ainsn);\n+static enum iv_grd_result\n+iv_get_reaching_def (rtx insn, rtx reg, struct df_ref **def)\n+{\n+  struct df_ref *use, *adef;\n+  basic_block def_bb, use_bb;\n+  rtx def_insn;\n+  bool dom_p;\n+  \n+  *def = NULL;\n+  if (!simple_reg_p (reg))\n+    return GRD_INVALID;\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n \n-      if (dominated_by_p (CDI_DOMINATORS, bb, abb))\n-\tbreak;\n+  use = df_find_use (df, insn, reg);\n+  gcc_assert (use != NULL);\n \n-      auid = INSN_UID (ainsn);\n-      ainsn = insn_info[auid].prev_def;\n+  if (!DF_REF_CHAIN (use))\n+    return GRD_INVARIANT;\n \n-      if (!ainsn)\n-\treturn NULL_RTX;\n-    }\n+  /* More than one reaching def.  */\n+  if (DF_REF_CHAIN (use)->next)\n+    return GRD_INVALID;\n \n-  while (1)\n-    {\n-      abb = BLOCK_FOR_INSN (ainsn);\n-      if (abb != bb)\n-\treturn ainsn;\n+  adef = DF_REF_CHAIN (use)->ref;\n+  def_insn = DF_REF_INSN (adef);\n+  def_bb = DF_REF_BB (adef);\n+  use_bb = BLOCK_FOR_INSN (insn);\n \n-      auid = INSN_UID (ainsn);\n-      if (luid > insn_info[auid].luid)\n-\treturn ainsn;\n+  if (use_bb == def_bb)\n+    dom_p = (DF_INSN_LUID (df, def_insn) < DF_INSN_LUID (df, insn));\n+  else\n+    dom_p = dominated_by_p (CDI_DOMINATORS, use_bb, def_bb);\n \n-      ainsn = insn_info[auid].prev_def;\n-      if (!ainsn)\n-\treturn NULL_RTX;\n+  if (dom_p)\n+    {\n+      *def = adef;\n+      return GRD_SINGLE_DOM;\n     }\n+\n+  /* The definition does not dominate the use.  This is still OK if\n+     this may be a use of a biv, i.e. if the def_bb dominates loop\n+     latch.  */\n+  if (just_once_each_iteration_p (current_loop, def_bb))\n+    return GRD_MAYBE_BIV;\n+\n+  return GRD_INVALID;\n }\n \n /* Sets IV to invariant CST in MODE.  Always returns true (just for\n@@ -425,7 +363,6 @@ iv_constant (struct rtx_iv *iv, rtx cst, enum machine_mode mode)\n   if (mode == VOIDmode)\n     mode = GET_MODE (cst);\n \n-  iv->analysed = true;\n   iv->mode = mode;\n   iv->base = cst;\n   iv->step = const0_rtx;\n@@ -653,20 +590,26 @@ iv_shift (struct rtx_iv *iv, rtx mby)\n }\n \n /* The recursive part of get_biv_step.  Gets the value of the single value\n-   defined in INSN wrto initial value of REG inside loop, in shape described\n+   defined by DEF wrto initial value of REG inside loop, in shape described\n    at get_biv_step.  */\n \n static bool\n-get_biv_step_1 (rtx insn, rtx reg,\n+get_biv_step_1 (struct df_ref *def, rtx reg,\n \t\trtx *inner_step, enum machine_mode *inner_mode,\n \t\tenum rtx_code *extend, enum machine_mode outer_mode,\n \t\trtx *outer_step)\n {\n   rtx set, rhs, op0 = NULL_RTX, op1 = NULL_RTX;\n-  rtx next, nextr, def_insn, tmp;\n+  rtx next, nextr, tmp;\n   enum rtx_code code;\n+  rtx insn = DF_REF_INSN (def);\n+  struct df_ref *next_def;\n+  enum iv_grd_result res;\n \n   set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n   rhs = find_reg_equal_equiv_note (insn);\n   if (rhs)\n     rhs = XEXP (rhs, 0);\n@@ -742,11 +685,12 @@ get_biv_step_1 (rtx insn, rtx reg,\n   else\n     nextr = next;\n \n-  def_insn = iv_get_reaching_def (insn, nextr);\n-  if (def_insn == const0_rtx)\n+  res = iv_get_reaching_def (insn, nextr, &next_def);\n+\n+  if (res == GRD_INVALID || res == GRD_INVARIANT)\n     return false;\n \n-  if (!def_insn)\n+  if (res == GRD_MAYBE_BIV)\n     {\n       if (!rtx_equal_p (nextr, reg))\n \treturn false;\n@@ -756,7 +700,7 @@ get_biv_step_1 (rtx insn, rtx reg,\n       *inner_mode = outer_mode;\n       *outer_step = const0_rtx;\n     }\n-  else if (!get_biv_step_1 (def_insn, reg,\n+  else if (!get_biv_step_1 (next_def, reg,\n \t\t\t    inner_step, inner_mode, extend, outer_mode,\n \t\t\t    outer_step))\n     return false;\n@@ -803,7 +747,7 @@ get_biv_step_1 (rtx insn, rtx reg,\n       break;\n \n     default:\n-      gcc_unreachable ();\n+      return false;\n     }\n \n   return true;\n@@ -813,16 +757,17 @@ get_biv_step_1 (rtx insn, rtx reg,\n \n    OUTER_STEP + EXTEND_{OUTER_MODE} (SUBREG_{INNER_MODE} (REG + INNER_STEP))\n \n-   If the operation cannot be described in this shape, return false.  */\n+   If the operation cannot be described in this shape, return false.\n+   LAST_DEF is the definition of REG that dominates loop latch.  */\n \n static bool\n-get_biv_step (rtx reg, rtx *inner_step, enum machine_mode *inner_mode,\n-\t      enum rtx_code *extend, enum machine_mode *outer_mode,\n-\t      rtx *outer_step)\n+get_biv_step (struct df_ref *last_def, rtx reg, rtx *inner_step,\n+\t      enum machine_mode *inner_mode, enum rtx_code *extend,\n+\t      enum machine_mode *outer_mode, rtx *outer_step)\n {\n   *outer_mode = GET_MODE (reg);\n \n-  if (!get_biv_step_1 (last_def[REGNO (reg)], reg,\n+  if (!get_biv_step_1 (last_def, reg,\n \t\t       inner_step, inner_mode, extend, *outer_mode,\n \t\t       outer_step))\n     return false;\n@@ -833,16 +778,54 @@ get_biv_step (rtx reg, rtx *inner_step, enum machine_mode *inner_mode,\n   return true;\n }\n \n+/* Records information that DEF is induction variable IV.  */\n+\n+static void\n+record_iv (struct df_ref *def, struct rtx_iv *iv)\n+{\n+  struct rtx_iv *recorded_iv = xmalloc (sizeof (struct rtx_iv));\n+\n+  *recorded_iv = *iv;\n+  DF_REF_IV_SET (def, recorded_iv);\n+}\n+\n+/* If DEF was already analyzed for bivness, store the description of the biv to\n+   IV and return true.  Otherwise return false.  */\n+\n+static bool\n+analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n+{\n+  struct biv_entry *biv = htab_find_with_hash (bivs, def, REGNO (def));\n+\n+  if (!biv)\n+    return false;\n+\n+  *iv = biv->iv;\n+  return true;\n+}\n+\n+static void\n+record_biv (rtx def, struct rtx_iv *iv)\n+{\n+  struct biv_entry *biv = xmalloc (sizeof (struct biv_entry));\n+  void **slot = htab_find_slot_with_hash (bivs, def, REGNO (def), INSERT);\n+\n+  biv->regno = REGNO (def);\n+  biv->iv = *iv;\n+  gcc_assert (!*slot);\n+  *slot = biv;\n+}\n+\n /* Determines whether DEF is a biv and if so, stores its description\n    to *IV.  */\n \n static bool\n iv_analyze_biv (rtx def, struct rtx_iv *iv)\n {\n-  unsigned regno;\n   rtx inner_step, outer_step;\n   enum machine_mode inner_mode, outer_mode;\n   enum rtx_code extend;\n+  struct df_ref *last_def;\n \n   if (dump_file)\n     {\n@@ -859,31 +842,24 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n       return iv_constant (iv, def, VOIDmode);\n     }\n \n-  regno = REGNO (def);\n-  if (last_def[regno] == const0_rtx)\n+  if (!latch_dominating_def (def, &last_def))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  not simple.\\n\");\n       return false;\n     }\n \n-  if (last_def[regno] && bivs[regno].analysed)\n+  if (!last_def)\n+    return iv_constant (iv, def, VOIDmode);\n+\n+  if (analyzed_for_bivness_p (def, iv))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  already analysed.\\n\");\n-\n-      *iv = bivs[regno];\n       return iv->base != NULL_RTX;\n     }\n \n-  if (!last_def[regno])\n-    {\n-      iv_constant (iv, def, VOIDmode);\n-      goto end;\n-    }\n-\n-  iv->analysed = true;\n-  if (!get_biv_step (def, &inner_step, &inner_mode, &extend,\n+  if (!get_biv_step (last_def, def, &inner_step, &inner_mode, &extend,\n \t\t     &outer_mode, &outer_step))\n     {\n       iv->base = NULL_RTX;\n@@ -913,119 +889,154 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  bivs[regno] = *iv;\n-\n+  record_biv (def, iv);\n   return iv->base != NULL_RTX;\n }\n \n-/* Analyzes operand OP of INSN and stores the result to *IV.  */\n+/* Analyzes expression RHS used at INSN and stores the result to *IV. \n+   The mode of the induction variable is MODE.  */\n \n-static bool\n-iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n+bool\n+iv_analyze_expr (rtx insn, rtx rhs, enum machine_mode mode, struct rtx_iv *iv)\n {\n-  rtx def_insn;\n-  unsigned regno;\n-  bool inv = CONSTANT_P (op);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Analyzing operand \");\n-      print_rtl (dump_file, op);\n-      fprintf (dump_file, \" of insn \");\n-      print_rtl_single (dump_file, insn);\n-    }\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (!subreg_lowpart_p (op))\n-\treturn false;\n+  rtx mby = NULL_RTX, tmp;\n+  rtx op0 = NULL_RTX, op1 = NULL_RTX;\n+  struct rtx_iv iv0, iv1;\n+  enum rtx_code code = GET_CODE (rhs);\n+  enum machine_mode omode = mode;\n \n-      if (!iv_analyze_op (insn, SUBREG_REG (op), iv))\n-\treturn false;\n+  iv->mode = VOIDmode;\n+  iv->base = NULL_RTX;\n+  iv->step = NULL_RTX;\n \n-      return iv_subreg (iv, GET_MODE (op));\n-    }\n+  gcc_assert (GET_MODE (rhs) == mode || GET_MODE (rhs) == VOIDmode);\n \n-  if (!inv)\n+  if (CONSTANT_P (rhs)\n+      || REG_P (rhs)\n+      || code == SUBREG)\n     {\n-      regno = REGNO (op);\n-      if (!last_def[regno])\n-\tinv = true;\n-      else if (last_def[regno] == const0_rtx)\n+      if (!iv_analyze_op (insn, rhs, iv))\n+\treturn false;\n+\t\n+      if (iv->mode == VOIDmode)\n \t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  not simple.\\n\");\n-\t  return false;\n+\t  iv->mode = mode;\n+\t  iv->extend_mode = mode;\n \t}\n+\n+      return true;\n     }\n \n-  if (inv)\n+  switch (code)\n     {\n-      iv_constant (iv, op, VOIDmode);\n+    case REG:\n+      op0 = rhs;\n+      break;\n \n-      if (dump_file)\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+    case NEG:\n+      op0 = XEXP (rhs, 0);\n+      omode = GET_MODE (op0);\n+      break;\n+\n+    case PLUS:\n+    case MINUS:\n+      op0 = XEXP (rhs, 0);\n+      op1 = XEXP (rhs, 1);\n+      break;\n+\n+    case MULT:\n+      op0 = XEXP (rhs, 0);\n+      mby = XEXP (rhs, 1);\n+      if (!CONSTANT_P (mby))\n \t{\n-\t  fprintf (dump_file, \"  \");\n-\t  dump_iv_info (dump_file, iv);\n-\t  fprintf (dump_file, \"\\n\");\n+\t  tmp = op0;\n+\t  op0 = mby;\n+\t  mby = tmp;\n \t}\n-      return true;\n-    }\n+      if (!CONSTANT_P (mby))\n+\treturn false;\n+      break;\n \n-  def_insn = iv_get_reaching_def (insn, op);\n-  if (def_insn == const0_rtx)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"  not simple.\\n\");\n+    case ASHIFT:\n+      op0 = XEXP (rhs, 0);\n+      mby = XEXP (rhs, 1);\n+      if (!CONSTANT_P (mby))\n+\treturn false;\n+      break;\n+\n+    default:\n       return false;\n     }\n \n-  return iv_analyze (def_insn, op, iv);\n-}\n-\n-/* Analyzes iv DEF defined in INSN and stores the result to *IV.  */\n-\n-bool\n-iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n-{\n-  unsigned uid;\n-  rtx set, rhs, mby = NULL_RTX, tmp;\n-  rtx op0 = NULL_RTX, op1 = NULL_RTX;\n-  struct rtx_iv iv0, iv1;\n-  enum machine_mode amode;\n-  enum rtx_code code;\n+  if (op0\n+      && !iv_analyze_expr (insn, op0, omode, &iv0))\n+    return false;\n \n-  if (insn == const0_rtx)\n+  if (op1\n+      && !iv_analyze_expr (insn, op1, omode, &iv1))\n     return false;\n \n-  if (GET_CODE (def) == SUBREG)\n+  switch (code)\n     {\n-      if (!subreg_lowpart_p (def))\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      if (!iv_extend (&iv0, code, mode))\n+\treturn false;\n+      break;\n+\n+    case NEG:\n+      if (!iv_neg (&iv0))\n \treturn false;\n+      break;\n \n-      if (!iv_analyze (insn, SUBREG_REG (def), iv))\n+    case PLUS:\n+    case MINUS:\n+      if (!iv_add (&iv0, &iv1, code))\n \treturn false;\n+      break;\n \n-      return iv_subreg (iv, GET_MODE (def));\n+    case MULT:\n+      if (!iv_mult (&iv0, mby))\n+\treturn false;\n+      break;\n+\n+    case ASHIFT:\n+      if (!iv_shift (&iv0, mby))\n+\treturn false;\n+      break;\n+\n+    default:\n+      break;\n     }\n \n-  if (!insn)\n-    return iv_analyze_biv (def, iv);\n+  *iv = iv0;\n+  return iv->base != NULL_RTX;\n+}\n+\n+/* Analyzes iv DEF and stores the result to *IV.  */\n+\n+static bool\n+iv_analyze_def (struct df_ref *def, struct rtx_iv *iv)\n+{\n+  rtx insn = DF_REF_INSN (def);\n+  rtx reg = DF_REF_REG (def);\n+  rtx set, rhs;\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"Analyzing def of \");\n-      print_rtl (dump_file, def);\n+      fprintf (dump_file, \"Analysing def of \");\n+      print_rtl (dump_file, reg);\n       fprintf (dump_file, \" in insn \");\n       print_rtl_single (dump_file, insn);\n     }\n \n-  uid = INSN_UID (insn);\n-  if (insn_info[uid].iv.analysed)\n+  if (DF_REF_IV (def))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  already analysed.\\n\");\n-      *iv = insn_info[uid].iv;\n+      *iv = *DF_REF_IV (def);\n       return iv->base != NULL_RTX;\n     }\n \n@@ -1034,161 +1045,152 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n   iv->step = NULL_RTX;\n \n   set = single_set (insn);\n+  if (!set || SET_DEST (set) != reg)\n+    return false;\n+\n   rhs = find_reg_equal_equiv_note (insn);\n   if (rhs)\n     rhs = XEXP (rhs, 0);\n   else\n     rhs = SET_SRC (set);\n-  code = GET_CODE (rhs);\n \n-  if (CONSTANT_P (rhs))\n+  iv_analyze_expr (insn, rhs, GET_MODE (reg), iv);\n+  record_iv (def, iv);\n+\n+  if (dump_file)\n     {\n-      op0 = rhs;\n-      amode = GET_MODE (def);\n+      print_rtl (dump_file, reg);\n+      fprintf (dump_file, \" in insn \");\n+      print_rtl_single (dump_file, insn);\n+      fprintf (dump_file, \"  is \");\n+      dump_iv_info (dump_file, iv);\n+      fprintf (dump_file, \"\\n\");\n     }\n-  else\n-    {\n-      switch (code)\n-\t{\n-\tcase SUBREG:\n-\t  if (!subreg_lowpart_p (rhs))\n-\t    goto end;\n-\t  op0 = rhs;\n-\t  break;\n-\t  \n-\tcase REG:\n-\t  op0 = rhs;\n-\t  break;\n \n-\tcase SIGN_EXTEND:\n-\tcase ZERO_EXTEND:\n-\tcase NEG:\n-\t  op0 = XEXP (rhs, 0);\n-\t  break;\n+  return iv->base != NULL_RTX;\n+}\n \n-\tcase PLUS:\n-\tcase MINUS:\n-\t  op0 = XEXP (rhs, 0);\n-\t  op1 = XEXP (rhs, 1);\n-\t  break;\n+/* Analyzes operand OP of INSN and stores the result to *IV.  */\n \n-\tcase MULT:\n-\t  op0 = XEXP (rhs, 0);\n-\t  mby = XEXP (rhs, 1);\n-\t  if (!CONSTANT_P (mby))\n-\t    {\n-\t      gcc_assert (CONSTANT_P (op0));\n-\t      tmp = op0;\n-\t      op0 = mby;\n-\t      mby = tmp;\n-\t    }\n-\t  break;\n+static bool\n+iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n+{\n+  struct df_ref *def = NULL;\n+  enum iv_grd_result res;\n \n-\tcase ASHIFT:\n-\t  gcc_assert (!CONSTANT_P (XEXP (rhs, 0)));\n-\t  op0 = XEXP (rhs, 0);\n-\t  mby = XEXP (rhs, 1);\n-\t  break;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Analysing operand \");\n+      print_rtl (dump_file, op);\n+      fprintf (dump_file, \" of insn \");\n+      print_rtl_single (dump_file, insn);\n+    }\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+  if (CONSTANT_P (op))\n+    res = GRD_INVARIANT;\n+  else if (GET_CODE (op) == SUBREG)\n+    {\n+      if (!subreg_lowpart_p (op))\n+\treturn false;\n \n-      amode = GET_MODE (rhs);\n-    }\n+      if (!iv_analyze_op (insn, SUBREG_REG (op), iv))\n+\treturn false;\n \n-  if (op0)\n+      return iv_subreg (iv, GET_MODE (op));\n+    }\n+  else\n     {\n-      if (!iv_analyze_op (insn, op0, &iv0))\n-\tgoto end;\n-\t\n-      if (iv0.mode == VOIDmode)\n+      res = iv_get_reaching_def (insn, op, &def);\n+      if (res == GRD_INVALID)\n \t{\n-\t  iv0.mode = amode;\n-\t  iv0.extend_mode = amode;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  not simple.\\n\");\n+\t  return false;\n \t}\n     }\n \n-  if (op1)\n+  if (res == GRD_INVARIANT)\n     {\n-      if (!iv_analyze_op (insn, op1, &iv1))\n-\tgoto end;\n+      iv_constant (iv, op, VOIDmode);\n \n-      if (iv1.mode == VOIDmode)\n+      if (dump_file)\n \t{\n-\t  iv1.mode = amode;\n-\t  iv1.extend_mode = amode;\n+\t  fprintf (dump_file, \"  \");\n+\t  dump_iv_info (dump_file, iv);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n+      return true;\n     }\n \n-  switch (code)\n-    {\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      if (!iv_extend (&iv0, code, amode))\n-\tgoto end;\n-      break;\n+  if (res == GRD_MAYBE_BIV)\n+    return iv_analyze_biv (op, iv);\n \n-    case NEG:\n-      if (!iv_neg (&iv0))\n-\tgoto end;\n-      break;\n+  return iv_analyze_def (def, iv);\n+}\n \n-    case PLUS:\n-    case MINUS:\n-      if (!iv_add (&iv0, &iv1, code))\n-\tgoto end;\n-      break;\n+/* Analyzes value VAL at INSN and stores the result to *IV.  */\n \n-    case MULT:\n-      if (!iv_mult (&iv0, mby))\n-\tgoto end;\n-      break;\n+bool\n+iv_analyze (rtx insn, rtx val, struct rtx_iv *iv)\n+{\n+  rtx reg;\n \n-    case ASHIFT:\n-      if (!iv_shift (&iv0, mby))\n-\tgoto end;\n-      break;\n+  /* We must find the insn in that val is used, so that we get to UD chains.\n+     Since the function is sometimes called on result of get_condition,\n+     this does not necessarily have to be directly INSN; scan also the\n+     following insns.  */\n+  if (simple_reg_p (val))\n+    {\n+      if (GET_CODE (val) == SUBREG)\n+\treg = SUBREG_REG (val);\n+      else\n+\treg = val;\n \n-    default:\n-      break;\n+      while (!df_find_use (df, insn, reg))\n+\tinsn = NEXT_INSN (insn);\n     }\n \n-  *iv = iv0;\n+  return iv_analyze_op (insn, val, iv);\n+}\n \n- end:\n-  iv->analysed = true;\n-  insn_info[uid].iv = *iv;\n+/* Analyzes definition of DEF in INSN and stores the result to IV.  */\n \n-  if (dump_file)\n-    {\n-      print_rtl (dump_file, def);\n-      fprintf (dump_file, \" in insn \");\n-      print_rtl_single (dump_file, insn);\n-      fprintf (dump_file, \"  is \");\n-      dump_iv_info (dump_file, iv);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+bool\n+iv_analyze_result (rtx insn, rtx def, struct rtx_iv *iv)\n+{\n+  struct df_ref *adef;\n \n-  return iv->base != NULL_RTX;\n+  adef = df_find_def (df, insn, def);\n+  if (!adef)\n+    return false;\n+\n+  return iv_analyze_def (adef, iv);\n }\n \n-/* Checks whether definition of register REG in INSN a basic induction\n+/* Checks whether definition of register REG in INSN is a basic induction\n    variable.  IV analysis must have been initialized (via a call to\n    iv_analysis_loop_init) for this function to produce a result.  */\n \n bool\n biv_p (rtx insn, rtx reg)\n {\n   struct rtx_iv iv;\n+  struct df_ref *def, *last_def;\n \n-  if (!REG_P (reg))\n+  if (!simple_reg_p (reg))\n     return false;\n \n-  if (last_def[REGNO (reg)] != insn)\n+  def = df_find_def (df, insn, reg);\n+  gcc_assert (def != NULL);\n+  if (!latch_dominating_def (reg, &last_def))\n+    return false;\n+  if (last_def != def)\n     return false;\n \n-  return iv_analyze_biv (reg, &iv);\n+  if (!iv_analyze_biv (reg, &iv))\n+    return false;\n+\n+  return iv.step != const0_rtx;\n }\n \n /* Calculates value of IV at ITERATION-th iteration.  */\n@@ -1230,21 +1232,12 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n void\n iv_analysis_done (void)\n {\n-  max_insn_no = 0;\n-  max_reg_no = 0;\n-  if (insn_info)\n-    {\n-      free (insn_info);\n-      insn_info = NULL;\n-    }\n-  if (last_def)\n-    {\n-      free (last_def);\n-      last_def = NULL;\n-    }\n-  if (bivs)\n+  if (df)\n     {\n-      free (bivs);\n+      clear_iv_info ();\n+      df_finish (df);\n+      df = NULL;\n+      htab_delete (bivs);\n       bivs = NULL;\n     }\n }\n@@ -1996,7 +1989,7 @@ static void\n iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t\t\t struct niter_desc *desc)\n {\n-  rtx op0, op1, delta, step, bound, may_xform, def_insn, tmp, tmp0, tmp1;\n+  rtx op0, op1, delta, step, bound, may_xform, tmp, tmp0, tmp1;\n   struct rtx_iv iv0, iv1, tmp_iv;\n   rtx assumption, may_not_xform;\n   enum rtx_code cond;\n@@ -2038,15 +2031,13 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n     goto fail;\n \n   op0 = XEXP (condition, 0);\n-  def_insn = iv_get_reaching_def (insn, op0);\n-  if (!iv_analyze (def_insn, op0, &iv0))\n+  if (!iv_analyze (insn, op0, &iv0))\n     goto fail;\n   if (iv0.extend_mode == VOIDmode)\n     iv0.mode = iv0.extend_mode = mode;\n   \n   op1 = XEXP (condition, 1);\n-  def_insn = iv_get_reaching_def (insn, op1);\n-  if (!iv_analyze (def_insn, op1, &iv1))\n+  if (!iv_analyze (insn, op1, &iv1))\n     goto fail;\n   if (iv1.extend_mode == VOIDmode)\n     iv1.mode = iv1.extend_mode = mode;"}, {"sha": "3b4c8e5931c62df925120609c0362e96c9058dfd", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -33,7 +33,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"expr.h\"\n #include \"hashtab.h\"\n #include \"recog.h\"    \n-#include \"varray.h\"                        \n \n /* This pass performs loop unrolling and peeling.  We only perform these\n    optimizations on innermost loops (with single exception) because\n@@ -1670,7 +1669,7 @@ analyze_iv_to_split_insn (rtx insn)\n   if (!biv_p (insn, dest))\n     return NULL;\n \n-  ok = iv_analyze (insn, dest, &iv);\n+  ok = iv_analyze_result (insn, dest, &iv);\n   gcc_assert (ok);\n \n   if (iv.step == const0_rtx"}, {"sha": "c76f481e08e424be4c3cfe2644d0e6a315abe81a", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -172,7 +172,7 @@ unswitch_loops (struct loops *loops)\n static rtx\n may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n {\n-  rtx test, at, insn, op[2], stest;\n+  rtx test, at, op[2], stest;\n   struct rtx_iv iv;\n   unsigned i;\n   enum machine_mode mode;\n@@ -205,8 +205,7 @@ may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n       if (CONSTANT_P (op[i]))\n \tcontinue;\n \n-      insn = iv_get_reaching_def (at, op[i]);\n-      if (!iv_analyze (insn, op[i], &iv))\n+      if (!iv_analyze (at, op[i], &iv))\n \treturn NULL_RTX;\n       if (iv.step != const0_rtx\n \t  || iv.first_special)"}, {"sha": "75d6894a9779e1ecc6aef7b42667f845ace7729b", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd22151856ff8e57ef209b2e01edc9f76999e0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=03fd22151856ff8e57ef209b2e01edc9f76999e0", "patch": "@@ -2721,7 +2721,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n       target = gen_reg_rtx (outmode);\n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx_fmt_e (unoptab->code, mode, op0));\n+\t\t\t  gen_rtx_fmt_e (unoptab->code, outmode, op0));\n \n       return target;\n     }"}]}