{"sha": "15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlYmU0N2Q4OWZjMDQyNjdmM2IyMzI1NTZlYmVkZDZlMTlkM2JjYw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-05-06T00:12:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-06T00:12:15Z"}, "message": "haifa-sched.c (find_rgns): In no_loops case, fix test for leaf blocks.\n\n        * haifa-sched.c (find_rgns): In no_loops case, fix test for leaf\n        blocks.  Check for 1 successor which is the EXIT_BLOCK.\n        * haifa-sched.c (find_rgns): Detect unreachable blocks, including\n        unreachable loops with more than one block.\n\nCo-Authored-By: Jim Wilson <wilson@cygnus.com>\n\nFrom-SVN: r19558", "tree": {"sha": "ef772890c516b422d092a5e6a0eccc6e446a8236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef772890c516b422d092a5e6a0eccc6e446a8236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ebe47d89fc04267f3b232556ebedd6e19d3bcc/comments", "author": null, "committer": null, "parents": [{"sha": "0fac6b0b32f12da03f8443883fa6434db14b55a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fac6b0b32f12da03f8443883fa6434db14b55a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fac6b0b32f12da03f8443883fa6434db14b55a6"}], "stats": {"total": 271, "additions": 153, "deletions": 118}, "files": [{"sha": "85016ebef6465b7c2fa25aa640c6d9cf95c01dcb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ebe47d89fc04267f3b232556ebedd6e19d3bcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ebe47d89fc04267f3b232556ebedd6e19d3bcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "patch": "@@ -1,3 +1,12 @@\n+Wed May  6 01:09:01 1998  Jeffrey A Law  (law@cygnus.com)\n+\t\t\t  Jim Wilson (wilson@cygnus.com)\n+\n+\t* haifa-sched.c (find_rgns): In no_loops case, fix test for leaf\n+\tblocks.  Check for 1 successor which is the EXIT_BLOCK.\n+\n+\t* haifa-sched.c (find_rgns): Detect unreachable blocks, including\n+\tunreachable loops with more than one block.\n+\n Wed May  6 08:22:24 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* fix-header.c (write_rbrac): Add \"abort\" to functions which need to"}, {"sha": "87ce450362363bcd8ccc417e9fcbc4a5a2f5da92", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 144, "deletions": 118, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ebe47d89fc04267f3b232556ebedd6e19d3bcc/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ebe47d89fc04267f3b232556ebedd6e19d3bcc/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=15ebe47d89fc04267f3b232556ebedd6e19d3bcc", "patch": "@@ -1162,8 +1162,13 @@ build_control_flow (s_preds, s_succs, num_preds, num_succs)\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       nr_edges += num_succs[i];\n-      /* ??? We must also detect unreachable loops here.  We only handle the\n-\t trivial case of a loop with one basic block for now.  */\n+\n+      /* Unreachable loops with more than one basic block are detected\n+\t during the DFS traversal in find_rgns.\n+\n+\t Unreachable loops with a single block are detected here.  This\n+\t test is redundant with the one in find_rgns, but it's much\n+\t cheaper to go ahead and catch the trivial case here.  */\n       if (num_preds[i] == 0\n \t  || (num_preds[i] == 1 && INT_LIST_VAL (s_preds[i]) == i))\n \tunreachable = 1;\n@@ -1487,7 +1492,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   char no_loops = 1;\n   int node, child, loop_head, i, j, head, tail;\n   int count = 0, sp, idx = 0, current_edge = out_edges[0];\n-  int num_bbs, num_insns;\n+  int num_bbs, num_insns, unreachable;\n   int too_large_failure;\n \n   /* Note if an edge has been passed.  */\n@@ -1598,13 +1603,20 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n       current_edge = OUT_EDGES (child);\n     }\n \n-  /* ?!? This might be a good place to detect unreachable loops and\n-     avoid problems with them by forcing single block scheduling.  */\n-  if (no_loops)\n-    SET_BIT (header, 0);\n+  /* Another check for unreachable blocks.  The earlier test in\n+     is_cfg_nonregular only finds unreachable blocks that do not\n+     form a loop.\n \n-  /* Second travsersal:find reducible inner loops and topologically sort\n-     block of each region.  */\n+     The DFS traversal will mark every block that is reachable from\n+     the entry node by placing a nonzero value in dfs_nr.  Thus if\n+     dfs_nr is zero for any block, then it must be unreachable.  */\n+  unreachable = 0;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (dfs_nr[i] == 0)\n+      {\n+\tunreachable = 1;\n+\tbreak;\n+      }\n \n   /* Gross.  To avoid wasting memory, the second pass uses the dfs_nr array\n      to hold degree counts.  */\n@@ -1614,81 +1626,94 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   for (i = 0; i < n_basic_blocks; i++)\n     degree[i] = num_preds[i];\n \n-  queue = (int *) alloca (n_basic_blocks * sizeof (int));\n-\n-  /* Find blocks which are inner loop headers.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  /* Do not perform region scheduling if there are any unreachable\n+     blocks.  */\n+  if (!unreachable)\n     {\n-      if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n-\t{\n-\t  int_list_ptr ps;\n+      if (no_loops)\n+\tSET_BIT (header, 0);\n \n-\t  /* I is a header of a reducible inner loop, or block 0 in a\n-\t     subroutine with no loops at all.  */\n-\t  head = tail = -1;\n-\t  too_large_failure = 0;\n-\t  loop_head = max_hdr[i];\n+      /* Second travsersal:find reducible inner loops and topologically sort\n+\t block of each region.  */\n \n-\t  /* Decrease degree of all I's successors for topological\n-\t     ordering.  */\n-\t  for (ps = s_succs[i]; ps; ps = ps->next)\n-\t    if (INT_LIST_VAL (ps) != EXIT_BLOCK\n-\t\t&& INT_LIST_VAL (ps) != ENTRY_BLOCK)\n-\t      --degree[INT_LIST_VAL (ps)];\n+      queue = (int *) alloca (n_basic_blocks * sizeof (int));\n \n-\t  /* Estimate # insns, and count # blocks in the region.  */\n-\t  num_bbs = 1;\n-\t  num_insns\n-\t    = INSN_LUID (basic_block_end[i]) - INSN_LUID (basic_block_head[i]);\n+      /* Find blocks which are inner loop headers.  */\n+      for (i = 0; i < n_basic_blocks; i++)\n+\t{\n+\t  if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n+\t    {\n+\t      int_list_ptr ps;\n \n+\t      /* I is a header of a reducible inner loop, or block 0 in a\n+\t\t subroutine with no loops at all.  */\n+\t      head = tail = -1;\n+\t      too_large_failure = 0;\n+\t      loop_head = max_hdr[i];\n \n-\t  /* Find all loop latches (blocks which back edges to the loop\n-\t     header) or all the leaf blocks in the cfg has no loops.\n+\t      /* Decrease degree of all I's successors for topological\n+\t\t ordering.  */\n+\t      for (ps = s_succs[i]; ps; ps = ps->next)\n+\t\tif (INT_LIST_VAL (ps) != EXIT_BLOCK\n+\t\t    && INT_LIST_VAL (ps) != ENTRY_BLOCK)\n+\t\t  --degree[INT_LIST_VAL (ps)];\n \n-\t     Place those blocks into the queue.  */\n-\t  if (no_loops)\n-\t    {\n-\t      for (j = 0; j < n_basic_blocks; j++)\n-\t\tif (num_succs[j] == 0)\n-\t\t  {\n-\t\t    queue[++tail] = j;\n-\t\t    SET_BIT (in_queue, j);\n+\t      /* Estimate # insns, and count # blocks in the region.  */\n+\t      num_bbs = 1;\n+\t      num_insns\t= (INSN_LUID (basic_block_end[i])\n+\t\t\t   - INSN_LUID (basic_block_head[i]));\n+\n+\n+\t      /* Find all loop latches (blocks which back edges to the loop\n+\t\t header) or all the leaf blocks in the cfg has no loops.\n \n-\t\t    if (too_large (j, &num_bbs, &num_insns))\n+\t\t Place those blocks into the queue.  */\n+\t      if (no_loops)\n+\t\t{\n+\t\t  for (j = 0; j < n_basic_blocks; j++)\n+\t\t    /* Leaf nodes have only a single successor which must\n+\t\t       be EXIT_BLOCK.  */\n+\t\t    if (num_succs[j] == 1\n+\t\t\t&& INT_LIST_VAL (s_succs[j]) == EXIT_BLOCK)\n \t\t      {\n-\t\t\ttoo_large_failure = 1;\n-\t\t\tbreak;\n+\t\t\tqueue[++tail] = j;\n+\t\t\tSET_BIT (in_queue, j);\n+\n+\t\t\tif (too_large (j, &num_bbs, &num_insns))\n+\t\t\t  {\n+\t\t\t    too_large_failure = 1;\n+\t\t\t    break;\n+\t\t\t  }\n \t\t      }\n-\t\t  }\n-\t    }\n-\t  else\n-\t    {\n-\t      int_list_ptr ps;\n-\n-\t      for (ps = s_preds[i]; ps; ps = ps->next)\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  node = INT_LIST_VAL (ps);\n+\t\t  int_list_ptr ps;\n \n-\t\t  if (node == ENTRY_BLOCK || node == EXIT_BLOCK)\n-\t\t    continue;\n- \n-\t\t  if (max_hdr[node] == loop_head && node != i)\n+\t\t  for (ps = s_preds[i]; ps; ps = ps->next)\n \t\t    {\n-\t\t      /* This is a loop latch.  */\n-\t\t      queue[++tail] = node;\n-\t\t      SET_BIT (in_queue, node);\n+\t\t      node = INT_LIST_VAL (ps);\n \n-\t\t      if (too_large (node, &num_bbs, &num_insns))\n+\t\t      if (node == ENTRY_BLOCK || node == EXIT_BLOCK)\n+\t\t\tcontinue;\n+ \n+\t\t      if (max_hdr[node] == loop_head && node != i)\n \t\t\t{\n-\t\t\t  too_large_failure = 1;\n-\t\t\t  break;\n+\t\t\t  /* This is a loop latch.  */\n+\t\t\t  queue[++tail] = node;\n+\t\t\t  SET_BIT (in_queue, node);\n+\n+\t\t\t  if (too_large (node, &num_bbs, &num_insns))\n+\t\t\t    {\n+\t\t\t      too_large_failure = 1;\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\t}\n+\t\t      \n \t\t    }\n-\t\t  \n \t\t}\n-\t    }\n \n-\t  /* Now add all the blocks in the loop to the queue.\n+\t      /* Now add all the blocks in the loop to the queue.\n \n \t     We know the loop is a natural loop; however the algorithm\n \t     above will not always mark certain blocks as being in the\n@@ -1719,74 +1744,75 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t     We do not do this because I'm not sure that the actual\n \t     scheduling code will properly handle this case. ?!? */\n \t\n-\t  while (head < tail && !too_large_failure)\n-\t    {\n-\t      int_list_ptr ps;\n-\t      child = queue[++head];\n-\n-\t      for (ps = s_preds[child]; ps; ps = ps->next)\n+\t      while (head < tail && !too_large_failure)\n \t\t{\n-\t\t  node = INT_LIST_VAL (ps);\n+\t\t  int_list_ptr ps;\n+\t\t  child = queue[++head];\n \n-\t\t  /* See discussion above about nodes not marked as in\n-\t\t     this loop during the initial DFS traversal.  */\n-\t\t  if (node == ENTRY_BLOCK || node == EXIT_BLOCK\n-\t\t      || max_hdr[node] != loop_head)\n-\t\t    {\n-\t\t      tail = -1;\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (!TEST_BIT (in_queue, node) && node != i)\n+\t\t  for (ps = s_preds[child]; ps; ps = ps->next)\n \t\t    {\n-\t\t      queue[++tail] = node;\n-\t\t      SET_BIT (in_queue, node);\n+\t\t      node = INT_LIST_VAL (ps);\n \n-\t\t      if (too_large (node, &num_bbs, &num_insns))\n+\t\t      /* See discussion above about nodes not marked as in\n+\t\t\t this loop during the initial DFS traversal.  */\n+\t\t      if (node == ENTRY_BLOCK || node == EXIT_BLOCK\n+\t\t\t  || max_hdr[node] != loop_head)\n \t\t\t{\n-\t\t\t  too_large_failure = 1;\n+\t\t\t  tail = -1;\n \t\t\t  break;\n \t\t\t}\n+\t\t      else if (!TEST_BIT (in_queue, node) && node != i)\n+\t\t\t{\n+\t\t\t  queue[++tail] = node;\n+\t\t\t  SET_BIT (in_queue, node);\n+\n+\t\t\t  if (too_large (node, &num_bbs, &num_insns))\n+\t\t\t    {\n+\t\t\t      too_large_failure = 1;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t    }\n \n-\t  if (tail >= 0 && !too_large_failure)\n-\t    {\n-\t      /* Place the loop header into list of region blocks.  */\n-\t      degree[i] = -1;\n-\t      rgn_bb_table[idx] = i;\n-\t      RGN_NR_BLOCKS (nr_regions) = num_bbs;\n-\t      RGN_BLOCKS (nr_regions) = idx++;\n-\t      CONTAINING_RGN (i) = nr_regions;\n-\t      BLOCK_TO_BB (i) = count = 0;\n-\n-\t      /* Remove blocks from queue[] when their in degree becomes\n+\t      if (tail >= 0 && !too_large_failure)\n+\t\t{\n+\t\t  /* Place the loop header into list of region blocks.  */\n+\t\t  degree[i] = -1;\n+\t\t  rgn_bb_table[idx] = i;\n+\t\t  RGN_NR_BLOCKS (nr_regions) = num_bbs;\n+\t\t  RGN_BLOCKS (nr_regions) = idx++;\n+\t\t  CONTAINING_RGN (i) = nr_regions;\n+\t\t  BLOCK_TO_BB (i) = count = 0;\n+\n+\t\t  /* Remove blocks from queue[] when their in degree becomes\n \t\t zero.  Repeat until no blocks are left on the list.  This\n \t\t produces a topological list of blocks in the region.  */\n-\t      while (tail >= 0)\n-\t\t{\n-\t\t  int_list_ptr ps;\n-\n-\t\t  if (head < 0)\n-\t\t    head = tail;\n-\t\t  child = queue[head];\n-\t\t  if (degree[child] == 0)\n+\t\t  while (tail >= 0)\n \t\t    {\n-\t\t      degree[child] = -1;\n-\t\t      rgn_bb_table[idx++] = child;\n-\t\t      BLOCK_TO_BB (child) = ++count;\n-\t\t      CONTAINING_RGN (child) = nr_regions;\n-\t\t      queue[head] = queue[tail--];\n-\n-\t\t      for (ps = s_succs[child]; ps; ps = ps->next)\n-\t\t\tif (INT_LIST_VAL (ps) != ENTRY_BLOCK\n-\t\t\t    && INT_LIST_VAL (ps) != EXIT_BLOCK)\n-\t\t\t  --degree[INT_LIST_VAL (ps)];\n+\t\t      int_list_ptr ps;\n+\n+\t\t      if (head < 0)\n+\t\t\thead = tail;\n+\t\t      child = queue[head];\n+\t\t      if (degree[child] == 0)\n+\t\t\t{\n+\t\t\t  degree[child] = -1;\n+\t\t\t  rgn_bb_table[idx++] = child;\n+\t\t\t  BLOCK_TO_BB (child) = ++count;\n+\t\t\t  CONTAINING_RGN (child) = nr_regions;\n+\t\t\t  queue[head] = queue[tail--];\n+\n+\t\t\t  for (ps = s_succs[child]; ps; ps = ps->next)\n+\t\t\t    if (INT_LIST_VAL (ps) != ENTRY_BLOCK\n+\t\t\t\t&& INT_LIST_VAL (ps) != EXIT_BLOCK)\n+\t\t\t      --degree[INT_LIST_VAL (ps)];\n+\t\t\t}\n+\t\t      else\n+\t\t\t--head;\n \t\t    }\n-\t\t  else\n-\t\t    --head;\n+\t\t  ++nr_regions;\n \t\t}\n-\t      ++nr_regions;\n \t    }\n \t}\n     }"}]}