{"sha": "f6052f8680a5510f3f29c51fb69dd2ec3765925a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwNTJmODY4MGE1NTEwZjNmMjljNTFmYjY5ZGQyZWMzNzY1OTI1YQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2010-06-26T03:30:19Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2010-06-26T03:30:19Z"}, "message": "m32c-protos.h (m32c_note_pragma_address): Declare.\n\n* config/m32c/m32c-protos.h (m32c_note_pragma_address): Declare.\n(m32c_output_aligned_common): Likewise.\n* config/m32c/m32c.h (ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n(ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n* config/m32c/m32c-pragma.c (m32c_pragma_address): New.\n(m32c_register_pragmas): Register it.\n* config/m32c/m32c.c (m32c_get_pragma_address): New.\n(m32c_insert_attributes): Set #pragma address decls volatile.\n(pragma_entry_eq): New.\n(pragma_entry_hash): New.\n(m32c_note_pragma_address): New.\n(m32c_get_pragma_address): New.\n(m32c_output_aligned_common): New.\n* doc/extend.texi: Document the new pragma.\n\n* config/m32c/m32c.c (m32c_illegal_subreg_p): Reject illegal MEMs\nalso.\n* config/m32c/predicates.md (m32c_any_operand): Check the code\ninstead of memory_operand so as to allow matching volatile MEMs.\n(m32c_nonimmediate_operand): Likewise.\n(mra_operand): Allow volatiles.\n\nFrom-SVN: r161425", "tree": {"sha": "029a9ae4281f830a057e8a006a023187ac8c6199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/029a9ae4281f830a057e8a006a023187ac8c6199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6052f8680a5510f3f29c51fb69dd2ec3765925a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6052f8680a5510f3f29c51fb69dd2ec3765925a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6052f8680a5510f3f29c51fb69dd2ec3765925a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6052f8680a5510f3f29c51fb69dd2ec3765925a/comments", "author": null, "committer": null, "parents": [{"sha": "19bbf2c4b8041b1ecb367187fe2555243a70d341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19bbf2c4b8041b1ecb367187fe2555243a70d341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19bbf2c4b8041b1ecb367187fe2555243a70d341"}], "stats": {"total": 212, "additions": 206, "deletions": 6}, "files": [{"sha": "797f74dd741cc72357fecbca341851265ab943f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -1,3 +1,27 @@\n+2010-06-25  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c-protos.h (m32c_note_pragma_address): Declare.\n+\t(m32c_output_aligned_common): Likewise.\n+\t* config/m32c/m32c.h (ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n+\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): New.\n+\t* config/m32c/m32c-pragma.c (m32c_pragma_address): New.\n+\t(m32c_register_pragmas): Register it.\n+\t* config/m32c/m32c.c (m32c_get_pragma_address): New.\n+\t(m32c_insert_attributes): Set #pragma address decls volatile.\n+\t(pragma_entry_eq): New.\n+\t(pragma_entry_hash): New.\n+\t(m32c_note_pragma_address): New.\n+\t(m32c_get_pragma_address): New.\n+\t(m32c_output_aligned_common): New.\n+\t* doc/extend.texi: Document the new pragma.\n+\n+\t* config/m32c/m32c.c (m32c_illegal_subreg_p): Reject illegal MEMs\n+\talso.\n+\t* config/m32c/predicates.md (m32c_any_operand): Check the code\n+\tinstead of memory_operand so as to allow matching volatile MEMs.\n+\t(m32c_nonimmediate_operand): Likewise.\n+\t(mra_operand): Allow volatiles.\n+\n 2010-06-25  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/44610"}, {"sha": "b57615265a2724c0bb85c5434270d9ef298db6b6", "filename": "gcc/config/m32c/m32c-pragma.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -87,9 +87,47 @@ m32c_pragma_memregs (cpp_reader * reader ATTRIBUTE_UNUSED)\n   error (\"#pragma GCC memregs takes a number [0..16]\");\n }\n \n+/* Implements the \"pragma ADDRESS\" pragma.  This pragma takes a\n+   variable name and an address, and arranges for that variable to be\n+   \"at\" that address.  The variable is also made volatile.  */\n+static void\n+m32c_pragma_address (cpp_reader * reader ATTRIBUTE_UNUSED)\n+{\n+  /* on off */\n+  tree var, addr;\n+  enum cpp_ttype type;\n+  const char *var_str;\n+\n+  type = pragma_lex (&var);\n+  if (type == CPP_NAME)\n+    {\n+      var_str = IDENTIFIER_POINTER (var);\n+\n+      type = pragma_lex (&addr);\n+      if (type == CPP_NUMBER)\n+\t{\n+\t  if (var != error_mark_node)\n+\t    {\n+\t      unsigned uaddr = tree_low_cst (addr, 1);\n+\t      m32c_note_pragma_address (IDENTIFIER_POINTER (var), uaddr);\n+\t    }\n+\n+\t  type = pragma_lex (&var);\n+\t  if (type != CPP_EOF)\n+\t    {\n+\t      error (\"junk at end of #pragma ADDRESS\");\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  error (\"malformed #pragma ADDRESS variable address\");\n+}\n+\n /* Implements REGISTER_TARGET_PRAGMAS.  */\n void\n m32c_register_pragmas (void)\n {\n   c_register_pragma (\"GCC\", \"memregs\", m32c_pragma_memregs);\n+  c_register_pragma (NULL, \"ADDRESS\", m32c_pragma_address);\n+  c_register_pragma (NULL, \"address\", m32c_pragma_address);\n }"}, {"sha": "89231fc2d5d6a254c76531fded8bb4018ce09b2d", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -42,6 +42,7 @@ int  m32c_print_operand_punct_valid_p (int);\n int  m32c_push_rounding (int);\n int  m32c_reg_class_from_constraint (char, const char *);\n void m32c_register_pragmas (void);\n+void m32c_note_pragma_address (const char *, unsigned);\n int  m32c_regno_ok_for_base_p (int);\n int  m32c_trampoline_alignment (void);\n int  m32c_trampoline_size (void);\n@@ -104,6 +105,8 @@ tree m32c_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n void m32c_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n bool m32c_promote_function_return (const_tree);\n int  m32c_special_page_vector_p (tree);\n+void m32c_output_aligned_common (FILE *, tree, const char *,\n+\t\t\t\t int, int, int);\n \n #endif\n "}, {"sha": "443325f8dd99662c5d834dc523ddad2cf9dcd40f", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -83,6 +83,9 @@ static int need_to_save (int);\n static rtx m32c_function_value (const_tree, const_tree, bool);\n static rtx m32c_libcall_value (enum machine_mode, const_rtx);\n \n+/* Returns true if an address is specified, else false.  */\n+static bool m32c_get_pragma_address (const char *varname, unsigned *addr);\n+\n int current_function_special_page_vector (rtx);\n \n #define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)\n@@ -2929,7 +2932,107 @@ static void\n m32c_insert_attributes (tree node ATTRIBUTE_UNUSED,\n \t\t\ttree * attr_ptr ATTRIBUTE_UNUSED)\n {\n-  /* Nothing to do here.  */\n+  unsigned addr;\n+  /* See if we need to make #pragma address variables volatile.  */\n+\n+  if (TREE_CODE (node) == VAR_DECL)\n+    {\n+      char *name = IDENTIFIER_POINTER (DECL_NAME (node));\n+      if (m32c_get_pragma_address  (name, &addr))\n+\t{\n+\t  TREE_THIS_VOLATILE (node) = true;\n+\t}\n+    }\t\n+}\n+\n+\n+struct GTY(()) pragma_entry {\n+  const char *varname;\n+  unsigned address;\n+};\n+typedef struct pragma_entry pragma_entry;\n+\n+/* Hash table of pragma info.  */\n+static GTY((param_is (pragma_entry))) htab_t pragma_htab;\n+\n+static int\n+pragma_entry_eq (const void *p1, const void *p2)\n+{\n+  const pragma_entry *old = (const pragma_entry *) p1;\n+  const char *new_name = (const char *) p2;\n+\n+  return strcmp (old->varname, new_name) == 0;\n+}\n+\n+static hashval_t\n+pragma_entry_hash (const void *p)\n+{\n+  const pragma_entry *old = (const pragma_entry *) p;\n+  return htab_hash_string (old->varname);\n+}\n+\n+void\n+m32c_note_pragma_address (const char *varname, unsigned address)\n+{\n+  pragma_entry **slot;\n+\n+  if (!pragma_htab)\n+    pragma_htab = htab_create_ggc (31, pragma_entry_hash,\n+\t\t\t\t    pragma_entry_eq, NULL);\n+\n+  slot = (pragma_entry **)\n+    htab_find_slot_with_hash (pragma_htab, varname,\n+\t\t\t      htab_hash_string (varname), INSERT);\n+\n+  if (!*slot)\n+    {\n+      *slot = ggc_alloc_pragma_entry ();\n+      (*slot)->varname = ggc_strdup (varname);\n+    }\n+  (*slot)->address = address;\n+}\n+\n+static bool\n+m32c_get_pragma_address (const char *varname, unsigned *address)\n+{\n+  pragma_entry **slot;\n+\n+  if (!pragma_htab)\n+    return false;\n+\n+  slot = (pragma_entry **)\n+    htab_find_slot_with_hash (pragma_htab, varname,\n+\t\t\t      htab_hash_string (varname), NO_INSERT);\n+  if (slot && *slot)\n+    {\n+      *address = (*slot)->address;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+void\n+m32c_output_aligned_common (FILE *stream, tree decl, const char *name,\n+\t\t\t    int size, int align, int global)\n+{\n+  unsigned address;\n+\n+  if (m32c_get_pragma_address (name, &address))\n+    {\n+      /* We never output these as global.  */\n+      assemble_name (stream, name);\n+      fprintf (stream, \" = 0x%04x\\n\", address);\n+      return;\n+    }\n+  if (!global)\n+    {\n+      fprintf (stream, \"\\t.local\\t\");\n+      assemble_name (stream, name);\n+      fprintf (stream, \"\\n\");\n+    }\n+  fprintf (stream, \"\\t.comm\\t\");\n+  assemble_name (stream, name);\n+  fprintf (stream, \",%u,%u\\n\", size, align / BITS_PER_UNIT);\n }\n \n /* Predicates */\n@@ -2960,14 +3063,20 @@ static const struct {\n };\n \n /* Returns TRUE if OP is a subreg of a hard reg which we don't\n-   support.  */\n+   support.  We also bail on MEMs with illegal addresses.  */\n bool\n m32c_illegal_subreg_p (rtx op)\n {\n   int offset;\n   unsigned int i;\n   int src_mode, dest_mode;\n \n+  if (GET_CODE (op) == MEM\n+      && ! m32c_legitimate_address_p (Pmode, XEXP (op, 0), false))\n+    {\n+      return true;\n+    }\n+\n   if (GET_CODE (op) != SUBREG)\n     return false;\n "}, {"sha": "a98005c78c1e9442d30bd4a4bfa6f0ca4e01062c", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -644,6 +644,13 @@ typedef struct m32c_cumulative_args\n #define ASM_OUTPUT_REG_PUSH(S,R) m32c_output_reg_push (S, R)\n #define ASM_OUTPUT_REG_POP(S,R) m32c_output_reg_pop (S, R)\n \n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\tm32c_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 1)\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\tm32c_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 0)\n+\n+\n /* Output of Dispatch Tables */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(S,V) \\"}, {"sha": "98a1c16e7c54852298020d55ca73393db7c5fd25", "filename": "gcc/config/m32c/predicates.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -26,7 +26,7 @@\n \n (define_predicate \"m32c_any_operand\"\n   (ior (match_operand 0 \"general_operand\")\n-       (match_operand 1 \"memory_operand\"))\n+       (match_code \"mem,const_int,const_double\"))\n   {\n     return ! m32c_illegal_subreg_p (op);\n   }\n@@ -36,7 +36,11 @@\n \n (define_predicate \"m32c_nonimmediate_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")\n-       (match_operand 1 \"memory_operand\")))\n+       (match_code \"mem\"))\n+  {\n+    return ! m32c_illegal_subreg_p (op);\n+  }\n+)\n \n ; TRUE if the operand is a pseudo-register.\n (define_predicate \"m32c_pseudo\"\n@@ -135,7 +139,7 @@\n \n ; Likewise, plus TRUE for memory references.\n (define_predicate \"mra_operand\"\n-  (and (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+  (and (and (match_operand 0 \"m32c_nonimmediate_operand\" \"\")\n \t    (not (match_operand 1 \"cr_operand\" \"\")))\n        (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n "}, {"sha": "86de226a8128fd9d54c64229e7bf1d5ea249e1d4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6052f8680a5510f3f29c51fb69dd2ec3765925a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f6052f8680a5510f3f29c51fb69dd2ec3765925a", "patch": "@@ -12266,7 +12266,7 @@ subsequent functions.\n @subsection M32C Pragmas\n \n @table @code\n-@item memregs @var{number}\n+@item GCC memregs @var{number}\n @cindex pragma, memregs\n Overrides the command-line option @code{-memregs=} for the current\n file.  Use with care!  This pragma must be before any function in the\n@@ -12275,6 +12275,21 @@ make them incompatible.  This pragma is useful when a\n performance-critical function uses a memreg for temporary values,\n as it may allow you to reduce the number of memregs used.\n \n+@item ADDRESS @var{name} @var{address}\n+@cindex pragma, address\n+For any declared symbols matching @var{name}, this does three things\n+to that symbol: it forces the symbol to be located at the given\n+address (a number), it forces the symbol to be volatile, and it\n+changes the symbol's scope to be static.  This pragma exists for\n+compatibility with other compilers, but note that the common\n+@code{1234H} numeric syntax is not supported (use @code{0x1234}\n+instead).  Example:\n+\n+@example\n+#pragma ADDRESS port3 0x103\n+char port3;\n+@end example\n+\n @end table\n \n @node MeP Pragmas"}]}