{"sha": "56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZkMGM2ZTNmNTQwNjg2YTlkN2UyNDBjNTM2YjdjMmZlMzYxYmJlMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-09-20T14:13:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-09-20T14:13:00Z"}, "message": "re PR c++/7586 (Incorrect handling of attributes in template codes)\n\n        PR c++/7586\n        * pt.c (tsubst): Handle typedefs by looking for the specialization.\n        (retrieve_specialization): Only tagged types use\n        DECL_TEMPLATE_INSTANTIATIONS.\n        (instantiate_class_template): Push nested classes too.\n        (tsubst_decl) [TYPE_DECL]: Only check for canonical decl for\n        tagged types.\n        * cp-tree.h (MAYBE_TAGGED_TYPE_P): New macro.\n        * init.c (is_aggr_type): Remove redundant tests.\n        * class.c (push_nested_class): Use CLASS_TYPE_P.\n\nFrom-SVN: r128621", "tree": {"sha": "497200eb12dfd940a8293d497ecc5a24595fb6ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497200eb12dfd940a8293d497ecc5a24595fb6ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "152315665ec17e11bad055588958922ae831def8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152315665ec17e11bad055588958922ae831def8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152315665ec17e11bad055588958922ae831def8"}], "stats": {"total": 145, "additions": 95, "deletions": 50}, "files": [{"sha": "efad3f3e59ae9b084e3ced2e43200db565797ec3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -1,3 +1,16 @@\n+2007-09-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/7586\n+\t* pt.c (tsubst): Handle typedefs by looking for the specialization.\n+\t(retrieve_specialization): Only tagged types use \n+\tDECL_TEMPLATE_INSTANTIATIONS.\n+\t(instantiate_class_template): Push nested classes too.\n+\t(tsubst_decl) [TYPE_DECL]: Only check for canonical decl for\n+\ttagged types.\n+\t* cp-tree.h (MAYBE_TAGGED_TYPE_P): New macro.\n+\t* init.c (is_aggr_type): Remove redundant tests.\n+\t* class.c (push_nested_class): Use CLASS_TYPE_P.\n+\n 2007-09-20  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/33459"}, {"sha": "5c3e0548044fd3f863e4a3ab5b3ff68af7aab148", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -5645,21 +5645,13 @@ currently_open_derived_class (tree t)\n void\n push_nested_class (tree type)\n {\n-  tree context;\n-\n   /* A namespace might be passed in error cases, like A::B:C.  */\n   if (type == NULL_TREE\n-      || type == error_mark_node\n-      || TREE_CODE (type) == NAMESPACE_DECL\n-      || ! IS_AGGR_TYPE (type)\n-      || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+      || !CLASS_TYPE_P (type))\n     return;\n \n-  context = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n+  push_nested_class (DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n \n-  if (context && CLASS_TYPE_P (context))\n-    push_nested_class (context);\n   pushclass (type);\n }\n "}, {"sha": "1ddf88492c6495170cb319e14b374482d5170d1f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -988,6 +988,10 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n   ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n #define TAGGED_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n+/* A tagged type or a dependent type that might be a tagged type when\n+   instantiated.  Like IS_AGGR_TYPE, but include enums as well.  */\n+#define MAYBE_TAGGED_TYPE_P(T) \\\n+  (IS_AGGR_TYPE(T) || TREE_CODE (T) == ENUMERAL_TYPE)\n #define IS_OVERLOAD_TYPE(T) TAGGED_TYPE_P (T)\n \n /* True if this a \"Java\" type, defined in 'extern \"Java\"'.  */"}, {"sha": "c5c17b1a9e15a8928a9651b490be19fcb630a2b2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -1281,9 +1281,7 @@ is_aggr_type (tree type, int or_else)\n   if (type == error_mark_node)\n     return 0;\n \n-  if (! IS_AGGR_TYPE (type)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM)\n+  if (! IS_AGGR_TYPE (type))\n     {\n       if (or_else)\n \terror (\"%qT is not an aggregate type\", type);"}, {"sha": "17acbaf220d3e859a26864df53bf15318e840de6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -930,7 +930,8 @@ retrieve_specialization (tree tmpl, tree args,\n \t DECL_TEMPLATE_INSTANTIATIONS list; other templates use the\n \t DECL_TEMPLATE_SPECIALIZATIONS list.  */\n       if (!class_specializations_p\n-\t  && TREE_CODE (DECL_TEMPLATE_RESULT (tmpl)) == TYPE_DECL)\n+\t  && TREE_CODE (DECL_TEMPLATE_RESULT (tmpl)) == TYPE_DECL\n+\t  && TAGGED_TYPE_P (TREE_TYPE (tmpl)))\n \tsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n       else\n \tsp = &DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n@@ -6688,8 +6689,8 @@ instantiate_class_template (tree type)\n      class, so that name lookups into base classes, etc. will work\n      correctly.  This is precisely analogous to what we do in\n      begin_class_definition when defining an ordinary non-template\n-     class.  */\n-  pushclass (type);\n+     class, except we also need to push the enclosing classes.  */\n+  push_nested_class (type);\n \n   /* Now members are processed in the order of declaration.  */\n   for (member = CLASSTYPE_DECL_LIST (pattern);\n@@ -6986,7 +6987,7 @@ instantiate_class_template (tree type)\n \t  && DECL_TEMPLATE_INFO (t))\n \ttsubst_default_arguments (t);\n \n-  popclass ();\n+  pop_nested_class ();\n   pop_from_top_level ();\n   pop_deferring_access_checks ();\n   pop_tinst_level ();\n@@ -8083,7 +8084,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \ttree type = NULL_TREE;\n \tbool local_p;\n \n-\tif (TREE_CODE (t) == TYPE_DECL)\n+\tif (TREE_CODE (t) == TYPE_DECL\n+\t    && MAYBE_TAGGED_TYPE_P (TREE_TYPE (t)))\n \t  {\n \t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    if (TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n@@ -8158,14 +8160,15 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \t/* Create a new node for the specialization we need.  */\n \tr = copy_decl (t);\n+\tif (type == NULL_TREE)\n+\t  type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n \t    /* Even if the original location is out of scope, the\n \t       newly substituted one is not.  */\n \t    DECL_DEAD_FOR_LOCAL (r) = 0;\n \t    DECL_INITIALIZED_P (r) = 0;\n \t    DECL_TEMPLATE_INSTANTIATED (r) = 0;\n-\t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    if (type == error_mark_node)\n \t      return error_mark_node;\n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -8551,41 +8554,36 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n   gcc_assert (type != unknown_type_node);\n \n-  /* Reuse typedefs.  This is a rather complicated way to check whether the\n-     type is a typedef from the same class template as the current scope,\n-     but I can't think of a better one.\n-\n-     We need to do this to handle dependent attributes, specifically\n-     attribute aligned.  */\n+  /* Reuse typedefs.  We need to do this to handle dependent attributes,\n+     specifically attribute aligned.  */\n   if (TYPE_P (t)\n       && TYPE_NAME (t)\n-      && !IS_AGGR_TYPE (t)\n-      && current_class_type\n-      && CLASSTYPE_TEMPLATE_INFO (current_class_type))\n+      && !MAYBE_TAGGED_TYPE_P (t)\n+      && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n+      && TREE_CODE (t) != UNBOUND_CLASS_TEMPLATE)\n     {\n       tree decl = TYPE_NAME (t);\n-      tree context = DECL_CONTEXT (decl);\n-      if (context\n-\t  && CLASS_TYPE_P (context)\n-\t  && CLASSTYPE_TEMPLATE_INFO (context)\n-\t  && (CLASSTYPE_TI_TEMPLATE (context)\n-\t      == CLASSTYPE_TI_TEMPLATE (current_class_type))\n-\t  && (tsubst_aggr_type (context, args, complain, in_decl,\n-\t\t\t\t/*entering_scope=*/0)\n-\t      == current_class_type))\n-\t    {\n-\t      r = lookup_name (DECL_NAME (decl));\n-\t      if (r && TREE_CODE (r) == TYPE_DECL\n-\t\t  && DECL_CONTEXT (r) == current_class_type)\n-\t\t{\n-\t\t  r = TREE_TYPE (r);\n-\t\t  r = cp_build_qualified_type_real\n-\t\t    (r, cp_type_quals (t) | cp_type_quals (r),\n-\t\t     complain | tf_ignore_bad_quals);\n-\t\t  return r;\n-\t\t  /* Else we're instantiating the typedef, so fall through.  */\n-\t\t}\n-\t    }\n+      \n+      if (DECL_CLASS_SCOPE_P (decl))\n+\t{\n+\t  tree tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n+\t  tree gen_args = tsubst (DECL_TI_ARGS (decl), args, complain, in_decl);\n+\t  r = retrieve_specialization (tmpl, gen_args, false);\n+\t}\n+      else if (DECL_FUNCTION_SCOPE_P (decl))\n+\tr = retrieve_local_specialization (decl);\n+      else\n+\tr = NULL_TREE;\n+\t\n+      if (r)\n+\t{\n+\t  r = TREE_TYPE (r);\n+\t  r = cp_build_qualified_type_real\n+\t    (r, cp_type_quals (t) | cp_type_quals (r),\n+\t     complain | tf_ignore_bad_quals);\n+\t  return r;\n+\t}\n+      /* Else we must be instantiating the typedef, so fall through.  */\n     }\n \n   if (type"}, {"sha": "f8d3c162072f238d67bf327969bc977469465354", "filename": "gcc/testsuite/g++.dg/ext/tmplattr3.C", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr3.C?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -14,8 +14,29 @@ struct Y {\n   layout_type data;\n };\n \n+template<typename T>\n+struct Z {\n+  typedef char layout_type[sizeof(T)]\n+  __attribute ((aligned(__alignof(T))));\n+  struct Z2 {\n+    layout_type data;\n+  } in;\n+};\n+\n+template<typename T>\n+struct A;\n+\n+template <typename T>\n+struct A<T*> {\n+  typedef char layout_type[sizeof(T)]\n+  __attribute ((aligned(__alignof(T))));\n+  layout_type data;\n+};\n+\n template<bool> struct StaticAssert;\n template<> struct StaticAssert<true> {};\n \n StaticAssert<__alignof(X<double>) == __alignof(double)> d1;\n StaticAssert<__alignof(Y<double>) == __alignof(double)> d2;\n+StaticAssert<__alignof(Z<double>) == __alignof(double)> d3;\n+StaticAssert<__alignof(A<double*>) == __alignof(double)> d4;"}, {"sha": "3d5c6b7d5fbd718767521669b0320a72c9333519", "filename": "gcc/testsuite/g++.dg/ext/tmplattr4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d0c6e3f540686a9d7e240c536b7c2fe361bbe2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr4.C?ref=56d0c6e3f540686a9d7e240c536b7c2fe361bbe2", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/7586\n+// { dg-do run }\n+\n+template<typename T>\n+int f()\n+{\n+  typedef unsigned char type[sizeof (T)]\n+    __attribute((aligned(__alignof(T))));\n+\n+  return __alignof (type);\n+}\n+\n+int main()\n+{\n+  if (f<int>() == __alignof (int))\n+    return 0;\n+  else\n+    return 1;\n+}"}]}