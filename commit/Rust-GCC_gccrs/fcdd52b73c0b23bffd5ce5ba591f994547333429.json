{"sha": "fcdd52b73c0b23bffd5ce5ba591f994547333429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNkZDUyYjczYzBiMjNiZmZkNWNlNWJhNTkxZjk5NDU0NzMzMzQyOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-11-18T17:33:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-11-18T17:33:38Z"}, "message": "Makefile.in (recog.o): Add insn-codes.h.\n\ngcc/\n\t* Makefile.in (recog.o): Add insn-codes.h.\n\t* expr.h (extraction_pattern): Move to optabs.h.\n\t(mode_for_extraction): Delete.\n\t* optabs.h (extraction_insn): New structure.\n\t(extraction_pattern): Moved from expr.h.\n\t(get_best_reg_extraction_insn, get_best_mem_extraction_insn): Declare.\n\t* optabs.c (HAVE_insv, CODE_FOR_insv, HAVE_extv, CODE_FOR_extv)\n\t(HAVE_extzv, CODE_FOR_extzv): Provide defaults.\n\t(extraction_type): New enum.\n\t(get_traditional_extraction_insn, get_extraction_insn)\n\t(get_best_reg_extraction_insn, get_best_mem_extraction_insn):\n\tNew functions.\n\t* combine.c (make_extraction): Use get_best_reg_extraction_insn\n\tinstead of mode_for_extraction.\n\t* expmed.c (HAVE_insv, CODE_FOR_insv, gen_insv, HAVE_extv)\n\t(CODE_FOR_extv, gen_extv, HAVE_extzv, CODE_FOR_extzv, gen_extzv):\n\tRemove fallback definitions.\n\t(mode_for_extraction): Delete.\n\t(adjust_bit_field_mem_for_reg): New function.\n\t(store_bit_field_using_insv): Replace OP_MODE parameter with\n\tan extraction_insn.  Pass struct_mode to narrow_bit_field_mem.\n\t(extract_bit_field_using_extv): Likewise EXT_MODE.\n\t(store_bit_field_1): Use get_best_reg_extraction_insn and\n\tget_best_mem_extraction_insn instead of mode_for_extraction.\n\tUse adjust_bit_field_mem_for_reg when forcing memory to a\n\tregister and doing a register insertion.  Update calls to\n\tstore_bit_field_using_insv.\n\t(extract_bit_field_1): Likewise extractions and calls to\n\textract_bit_field_using_extv.\n\t(store_Bit_field): When narrowing to a bitregion, don't use the\n\tinsv mode as a limit.\n\t* recog.c: (HAVE_extv, CODE_FOR_extv, HAVE_extzv, CODE_FOR_extzv):\n\tProvide defaults.\n\t(simplify_while_replacing): Use insn_data instead of\n\tmode_for_extraction.\n\nFrom-SVN: r193605", "tree": {"sha": "322c854e5205121b0545f58847a6f3aa5e4c0b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/322c854e5205121b0545f58847a6f3aa5e4c0b36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcdd52b73c0b23bffd5ce5ba591f994547333429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdd52b73c0b23bffd5ce5ba591f994547333429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcdd52b73c0b23bffd5ce5ba591f994547333429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdd52b73c0b23bffd5ce5ba591f994547333429/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b7d5dab44547924887d15e00823fac44df2aa61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7d5dab44547924887d15e00823fac44df2aa61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7d5dab44547924887d15e00823fac44df2aa61"}], "stats": {"total": 626, "additions": 396, "deletions": 230}, "files": [{"sha": "9361e357aea2e98bcc9b099d9e628417d0d07311", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -1,3 +1,41 @@\n+2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (recog.o): Add insn-codes.h.\n+\t* expr.h (extraction_pattern): Move to optabs.h.\n+\t(mode_for_extraction): Delete.\n+\t* optabs.h (extraction_insn): New structure.\n+\t(extraction_pattern): Moved from expr.h.\n+\t(get_best_reg_extraction_insn, get_best_mem_extraction_insn): Declare.\n+\t* optabs.c (HAVE_insv, CODE_FOR_insv, HAVE_extv, CODE_FOR_extv)\n+\t(HAVE_extzv, CODE_FOR_extzv): Provide defaults.\n+\t(extraction_type): New enum.\n+\t(get_traditional_extraction_insn, get_extraction_insn)\n+\t(get_best_reg_extraction_insn, get_best_mem_extraction_insn):\n+\tNew functions.\n+\t* combine.c (make_extraction): Use get_best_reg_extraction_insn\n+\tinstead of mode_for_extraction.\n+\t* expmed.c (HAVE_insv, CODE_FOR_insv, gen_insv, HAVE_extv)\n+\t(CODE_FOR_extv, gen_extv, HAVE_extzv, CODE_FOR_extzv, gen_extzv):\n+\tRemove fallback definitions.\n+\t(mode_for_extraction): Delete.\n+\t(adjust_bit_field_mem_for_reg): New function.\n+\t(store_bit_field_using_insv): Replace OP_MODE parameter with\n+\tan extraction_insn.  Pass struct_mode to narrow_bit_field_mem.\n+\t(extract_bit_field_using_extv): Likewise EXT_MODE.\n+\t(store_bit_field_1): Use get_best_reg_extraction_insn and\n+\tget_best_mem_extraction_insn instead of mode_for_extraction.\n+\tUse adjust_bit_field_mem_for_reg when forcing memory to a\n+\tregister and doing a register insertion.  Update calls to\n+\tstore_bit_field_using_insv.\n+\t(extract_bit_field_1): Likewise extractions and calls to\n+\textract_bit_field_using_extv.\n+\t(store_Bit_field): When narrowing to a bitregion, don't use the\n+\tinsv mode as a limit.\n+\t* recog.c: (HAVE_extv, CODE_FOR_extv, HAVE_extzv, CODE_FOR_extzv):\n+\tProvide defaults.\n+\t(simplify_while_replacing): Use insn_data instead of\n+\tmode_for_extraction.\n+\n 2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator):"}, {"sha": "d74e7b3c0dcd20c89c73fb8e8d48fed6ab145685", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -3355,7 +3355,7 @@ recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) reload.h \\\n    addresses.h $(TM_P_H) $(TREE_PASS_H) hard-reg-set.h \\\n-   $(DF_H) $(DBGCNT_H) $(TARGET_H) $(DIAGNOSTIC_CORE_H)\n+   $(DF_H) $(DBGCNT_H) $(TARGET_H) $(DIAGNOSTIC_CORE_H) insn-codes.h\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h reload.h $(FUNCTION_H) $(TM_P_H) $(GGC_H) \\"}, {"sha": "abd67e8ab9c7868085e3b46613dfc83a6473b690", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -7179,29 +7179,24 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t  || (pos_rtx != 0 && len != 1)))\n     return 0;\n \n-  /* Get the mode to use should INNER not be a MEM, the mode for the position,\n-     and the mode for the result.  */\n-  if (in_dest && mode_for_extraction (EP_insv, -1) != MAX_MACHINE_MODE)\n-    {\n-      wanted_inner_reg_mode = mode_for_extraction (EP_insv, 0);\n-      pos_mode = mode_for_extraction (EP_insv, 2);\n-      extraction_mode = mode_for_extraction (EP_insv, 3);\n-    }\n+  enum extraction_pattern pattern = (in_dest ? EP_insv\n+\t\t\t\t     : unsignedp ? EP_extzv : EP_extv);\n \n-  if (! in_dest && unsignedp\n-      && mode_for_extraction (EP_extzv, -1) != MAX_MACHINE_MODE)\n-    {\n-      wanted_inner_reg_mode = mode_for_extraction (EP_extzv, 1);\n-      pos_mode = mode_for_extraction (EP_extzv, 3);\n-      extraction_mode = mode_for_extraction (EP_extzv, 0);\n-    }\n+  /* If INNER is not from memory, we want it to have the mode of a register\n+     extraction pattern's structure operand, or word_mode if there is no\n+     such pattern.  The same applies to extraction_mode and pos_mode\n+     and their respective operands.\n \n-  if (! in_dest && ! unsignedp\n-      && mode_for_extraction (EP_extv, -1) != MAX_MACHINE_MODE)\n+     For memory, assume that the desired extraction_mode and pos_mode\n+     are the same as for a register operation, since at present we don't\n+     have named patterns for aligned memory structures.  */\n+  struct extraction_insn insn;\n+  if (get_best_reg_extraction_insn (&insn, pattern,\n+\t\t\t\t    GET_MODE_BITSIZE (inner_mode), mode))\n     {\n-      wanted_inner_reg_mode = mode_for_extraction (EP_extv, 1);\n-      pos_mode = mode_for_extraction (EP_extv, 3);\n-      extraction_mode = mode_for_extraction (EP_extv, 0);\n+      wanted_inner_reg_mode = insn.struct_mode;\n+      pos_mode = insn.pos_mode;\n+      extraction_mode = insn.field_mode;\n     }\n \n   /* Never narrow an object, since that might not be safe.  */\n@@ -7210,9 +7205,6 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       && GET_MODE_SIZE (extraction_mode) < GET_MODE_SIZE (mode))\n     extraction_mode = mode;\n \n-  /* If this is not from memory, the desired mode is the preferred mode\n-     for an extraction pattern's first input operand, or word_mode if there\n-     is none.  */\n   if (!MEM_P (inner))\n     wanted_inner_mode = wanted_inner_reg_mode;\n   else"}, {"sha": "752aecdaf17f9cc32cca297edf008001ed2ec089", "filename": "gcc/expmed.c", "status": "modified", "additions": 118, "deletions": 188, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -69,23 +69,6 @@ static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n /* Test whether a value is zero of a power of two.  */\n #define EXACT_POWER_OF_2_OR_ZERO_P(x) (((x) & ((x) - 1)) == 0)\n \n-/* Reduce conditional compilation elsewhere.  */\n-#ifndef HAVE_insv\n-#define HAVE_insv\t0\n-#define CODE_FOR_insv\tCODE_FOR_nothing\n-#define gen_insv(a,b,c,d) NULL_RTX\n-#endif\n-#ifndef HAVE_extv\n-#define HAVE_extv\t0\n-#define CODE_FOR_extv\tCODE_FOR_nothing\n-#define gen_extv(a,b,c,d) NULL_RTX\n-#endif\n-#ifndef HAVE_extzv\n-#define HAVE_extzv\t0\n-#define CODE_FOR_extzv\tCODE_FOR_nothing\n-#define gen_extzv(a,b,c,d) NULL_RTX\n-#endif\n-\n struct init_expmed_rtl\n {\n   struct rtx_def reg;\t\trtunion reg_fld[2];\n@@ -338,55 +321,6 @@ negate_rtx (enum machine_mode mode, rtx x)\n   return result;\n }\n \n-/* Report on the availability of insv/extv/extzv and the desired mode\n-   of each of their operands.  Returns MAX_MACHINE_MODE if HAVE_foo\n-   is false; else the mode of the specified operand.  If OPNO is -1,\n-   all the caller cares about is whether the insn is available.  */\n-enum machine_mode\n-mode_for_extraction (enum extraction_pattern pattern, int opno)\n-{\n-  const struct insn_data_d *data;\n-\n-  switch (pattern)\n-    {\n-    case EP_insv:\n-      if (HAVE_insv)\n-\t{\n-\t  data = &insn_data[CODE_FOR_insv];\n-\t  break;\n-\t}\n-      return MAX_MACHINE_MODE;\n-\n-    case EP_extv:\n-      if (HAVE_extv)\n-\t{\n-\t  data = &insn_data[CODE_FOR_extv];\n-\t  break;\n-\t}\n-      return MAX_MACHINE_MODE;\n-\n-    case EP_extzv:\n-      if (HAVE_extzv)\n-\t{\n-\t  data = &insn_data[CODE_FOR_extzv];\n-\t  break;\n-\t}\n-      return MAX_MACHINE_MODE;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (opno == -1)\n-    return VOIDmode;\n-\n-  /* Everyone who uses this function used to follow it with\n-     if (result == VOIDmode) result = word_mode; */\n-  if (data->operand[opno].mode == VOIDmode)\n-    return word_mode;\n-  return data->operand[opno].mode;\n-}\n-\n /* Adjust bitfield memory MEM so that it points to the first unit of mode\n    MODE that contains a bitfield of size BITSIZE at bit position BITNUM.\n    If MODE is BLKmode, return a reference to every byte in the bitfield.\n@@ -415,6 +349,57 @@ narrow_bit_field_mem (rtx mem, enum machine_mode mode,\n     }\n }\n \n+/* The caller wants to perform insertion or extraction PATTERN on a\n+   bitfield of size BITSIZE at BITNUM bits into memory operand OP0.\n+   BITREGION_START and BITREGION_END are as for store_bit_field\n+   and FIELDMODE is the natural mode of the field.\n+\n+   Search for a mode that is compatible with the memory access\n+   restrictions and (where applicable) with a register insertion or\n+   extraction.  Return the new memory on success, storing the adjusted\n+   bit position in *NEW_BITNUM.  Return null otherwise.  */\n+\n+static rtx\n+adjust_bit_field_mem_for_reg (enum extraction_pattern pattern,\n+\t\t\t      rtx op0, HOST_WIDE_INT bitsize,\n+\t\t\t      HOST_WIDE_INT bitnum,\n+\t\t\t      unsigned HOST_WIDE_INT bitregion_start,\n+\t\t\t      unsigned HOST_WIDE_INT bitregion_end,\n+\t\t\t      enum machine_mode fieldmode,\n+\t\t\t      unsigned HOST_WIDE_INT *new_bitnum)\n+{\n+  bit_field_mode_iterator iter (bitsize, bitnum, bitregion_start,\n+\t\t\t\tbitregion_end, MEM_ALIGN (op0),\n+\t\t\t\tMEM_VOLATILE_P (op0));\n+  enum machine_mode best_mode;\n+  if (iter.next_mode (&best_mode))\n+    {\n+      /* We can use a memory in BEST_MODE.  See whether this is true for\n+\t any wider modes.  All other things being equal, we prefer to\n+\t use the widest mode possible because it tends to expose more\n+\t CSE opportunities.  */\n+      if (!iter.prefer_smaller_modes ())\n+\t{\n+\t  /* Limit the search to the mode required by the corresponding\n+\t     register insertion or extraction instruction, if any.  */\n+\t  enum machine_mode limit_mode = word_mode;\n+\t  extraction_insn insn;\n+\t  if (get_best_reg_extraction_insn (&insn, pattern,\n+\t\t\t\t\t    GET_MODE_BITSIZE (best_mode),\n+\t\t\t\t\t    fieldmode))\n+\t    limit_mode = insn.field_mode;\n+\n+\t  enum machine_mode wider_mode;\n+\t  while (iter.next_mode (&wider_mode)\n+\t\t && GET_MODE_SIZE (wider_mode) <= GET_MODE_SIZE (limit_mode))\n+\t    best_mode = wider_mode;\n+\t}\n+      return narrow_bit_field_mem (op0, best_mode, bitsize, bitnum,\n+\t\t\t\t   new_bitnum);\n+    }\n+  return NULL_RTX;\n+}\n+\n /* Return true if a bitfield of size BITSIZE at bit number BITNUM within\n    a structure of mode STRUCT_MODE represents a lowpart subreg.   The subreg\n    offset is then BITNUM / BITS_PER_UNIT.  */\n@@ -432,28 +417,29 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n     return bitnum % BITS_PER_WORD == 0;\n }\n \f\n-/* Try to use an insv pattern to store VALUE into a field of OP0.\n-   OP_MODE is the mode of the insertion and BITSIZE and BITNUM are\n-   as for store_bit_field.  */\n+/* Try to use instruction INSV to store VALUE into a field of OP0.\n+   BITSIZE and BITNUM are as for store_bit_field.  */\n \n static bool\n-store_bit_field_using_insv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t\t    unsigned HOST_WIDE_INT bitnum, rtx value,\n-\t\t\t    enum machine_mode op_mode)\n+store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n+\t\t\t    unsigned HOST_WIDE_INT bitsize,\n+\t\t\t    unsigned HOST_WIDE_INT bitnum, rtx value)\n {\n   struct expand_operand ops[4];\n   rtx value1;\n   rtx xop0 = op0;\n   rtx last = get_last_insn ();\n   bool copy_back = false;\n \n+  enum machine_mode op_mode = insv->field_mode;\n   unsigned int unit = GET_MODE_BITSIZE (op_mode);\n   if (bitsize == 0 || bitsize > unit)\n     return false;\n \n   if (MEM_P (xop0))\n     /* Get a reference to the first byte of the field.  */\n-    xop0 = narrow_bit_field_mem (xop0, byte_mode, bitsize, bitnum, &bitnum);\n+    xop0 = narrow_bit_field_mem (xop0, insv->struct_mode, bitsize, bitnum,\n+\t\t\t\t &bitnum);\n   else\n     {\n       /* Convert from counting within OP0 to counting in OP_MODE.  */\n@@ -533,7 +519,7 @@ store_bit_field_using_insv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   create_integer_operand (&ops[1], bitsize);\n   create_integer_operand (&ops[2], bitnum);\n   create_input_operand (&ops[3], value1, op_mode);\n-  if (maybe_expand_insn (CODE_FOR_insv, 4, ops))\n+  if (maybe_expand_insn (insv->icode, 4, ops))\n     {\n       if (copy_back)\n \tconvert_move (op0, xop0, true);\n@@ -807,68 +793,38 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      within a word.  If the destination is a register, it too fits\n      in a word.  */\n \n-  enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n-  if (op_mode != MAX_MACHINE_MODE\n-      && !MEM_P (op0)\n-      && store_bit_field_using_insv (op0, bitsize, bitnum, value, op_mode))\n+  extraction_insn insv;\n+  if (!MEM_P (op0)\n+      && get_best_reg_extraction_insn (&insv, EP_insv,\n+\t\t\t\t       GET_MODE_BITSIZE (GET_MODE (op0)),\n+\t\t\t\t       fieldmode)\n+      && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n     return true;\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n      cheap register alternative is available.  */\n-  if (op_mode != MAX_MACHINE_MODE && MEM_P (op0))\n+  if (MEM_P (op0))\n     {\n-      enum machine_mode bestmode;\n-      unsigned HOST_WIDE_INT maxbits = MAX_FIXED_MODE_SIZE;\n-\n-      /* Do not use insv for volatile bitfields when\n-         -fstrict-volatile-bitfields is in effect.  */\n-      if (!(MEM_VOLATILE_P (op0) && flag_strict_volatile_bitfields > 0)\n-\t  /* Do not use insv if the bit region is restricted and\n-\t     an op_mode integer doesn't fit into the restricted region.  */\n-\t  && !(bitregion_end\n-\t       && (bitnum - (bitnum % BITS_PER_UNIT)\n-\t\t   + GET_MODE_BITSIZE (op_mode)\n-\t\t   > bitregion_end + 1))\n-\t  && store_bit_field_using_insv (op0, bitsize, bitnum, value, op_mode))\n+      /* Do not use unaligned memory insvs for volatile bitfields when\n+\t -fstrict-volatile-bitfields is in effect.  */\n+      if (!(MEM_VOLATILE_P (op0)\n+\t    && flag_strict_volatile_bitfields > 0)\n+\t  && get_best_mem_extraction_insn (&insv, EP_insv, bitsize, bitnum,\n+\t\t\t\t\t   fieldmode)\n+\t  && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n \treturn true;\n \n-      if (bitregion_end)\n-\tmaxbits = bitregion_end - bitregion_start + 1;\n-\n-      /* Get the mode to use for inserting into this field.  If OP0 is\n-\t BLKmode, get the smallest mode consistent with the alignment. If\n-\t OP0 is a non-BLKmode object that is no wider than OP_MODE, use its\n-\t mode. Otherwise, use the smallest mode containing the field.  */\n-\n-      if (GET_MODE (op0) == BLKmode\n-\t  || GET_MODE_BITSIZE (GET_MODE (op0)) > maxbits\n-\t  || GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (op_mode))\n-\tbestmode = get_best_mode (bitsize, bitnum,\n-\t\t\t\t  bitregion_start, bitregion_end,\n-\t\t\t\t  MEM_ALIGN (op0), op_mode,\n-\t\t\t\t  MEM_VOLATILE_P (op0));\n-      else\n-\tbestmode = GET_MODE (op0);\n+      rtx last = get_last_insn ();\n \n-      if (bestmode != VOIDmode\n-\t  && GET_MODE_SIZE (bestmode) >= GET_MODE_SIZE (fieldmode)\n-\t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n-\t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n+      /* Try loading part of OP0 into a register, inserting the bitfield\n+\t into that, and then copying the result back to OP0.  */\n+      unsigned HOST_WIDE_INT bitpos;\n+      rtx xop0 = adjust_bit_field_mem_for_reg (EP_insv, op0, bitsize, bitnum,\n+\t\t\t\t\t       bitregion_start, bitregion_end,\n+\t\t\t\t\t       fieldmode, &bitpos);\n+      if (xop0)\n \t{\n-\t  rtx last, tempreg, xop0;\n-\t  unsigned HOST_WIDE_INT bitpos;\n-\n-\t  last = get_last_insn ();\n-\n-\t  /* Adjust address to point to the containing unit of\n-\t     that mode.  Compute the offset as a multiple of this unit,\n-\t     counting in bytes.  */\n-\t  xop0 = narrow_bit_field_mem (op0, bestmode, bitsize, bitnum,\n-\t\t\t\t       &bitpos);\n-\n-\t  /* Fetch that unit, store the bitfield in it, then store\n-\t     the unit.  */\n-\t  tempreg = copy_to_reg (xop0);\n+\t  rtx tempreg = copy_to_reg (xop0);\n \t  if (store_bit_field_1 (tempreg, bitsize, bitpos,\n \t\t\t\t bitregion_start, bitregion_end,\n \t\t\t\t fieldmode, orig_value, false))\n@@ -913,13 +869,8 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (MEM_P (str_rtx) && bitregion_start > 0)\n     {\n       enum machine_mode bestmode;\n-      enum machine_mode op_mode;\n       unsigned HOST_WIDE_INT offset;\n \n-      op_mode = mode_for_extraction (EP_insv, 3);\n-      if (op_mode == MAX_MACHINE_MODE)\n-\top_mode = VOIDmode;\n-\n       gcc_assert ((bitregion_start % BITS_PER_UNIT) == 0);\n \n       offset = bitregion_start / BITS_PER_UNIT;\n@@ -928,8 +879,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       bitregion_start = 0;\n       bestmode = get_best_mode (bitsize, bitnum,\n \t\t\t\tbitregion_start, bitregion_end,\n-\t\t\t\tMEM_ALIGN (str_rtx),\n-\t\t\t\top_mode,\n+\t\t\t\tMEM_ALIGN (str_rtx), VOIDmode,\n \t\t\t\tMEM_VOLATILE_P (str_rtx));\n       str_rtx = adjust_address (str_rtx, bestmode, offset);\n     }\n@@ -1251,23 +1201,25 @@ convert_extracted_bit_field (rtx x, enum machine_mode mode,\n    are as for extract_bit_field.  */\n \n static rtx\n-extract_bit_field_using_extv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n+\t\t\t      unsigned HOST_WIDE_INT bitsize,\n \t\t\t      unsigned HOST_WIDE_INT bitnum,\n \t\t\t      int unsignedp, rtx target,\n-\t\t\t      enum machine_mode mode, enum machine_mode tmode,\n-\t\t\t      enum machine_mode ext_mode)\n+\t\t\t      enum machine_mode mode, enum machine_mode tmode)\n {\n   struct expand_operand ops[4];\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n+  enum machine_mode ext_mode = extv->field_mode;\n   unsigned unit = GET_MODE_BITSIZE (ext_mode);\n \n   if (bitsize == 0 || unit < bitsize)\n     return NULL_RTX;\n \n   if (MEM_P (op0))\n     /* Get a reference to the first byte of the field.  */\n-    op0 = narrow_bit_field_mem (op0, byte_mode, bitsize, bitnum, &bitnum);\n+    op0 = narrow_bit_field_mem (op0, extv->struct_mode, bitsize, bitnum,\n+\t\t\t\t&bitnum);\n   else\n     {\n       /* Convert from counting within OP0 to counting in EXT_MODE.  */\n@@ -1315,7 +1267,7 @@ extract_bit_field_using_extv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   create_fixed_operand (&ops[1], op0);\n   create_integer_operand (&ops[2], bitsize);\n   create_integer_operand (&ops[3], bitnum);\n-  if (maybe_expand_insn (unsignedp ? CODE_FOR_extzv : CODE_FOR_extv, 4, ops))\n+  if (maybe_expand_insn (extv->icode, 4, ops))\n     {\n       target = ops[0].value;\n       if (target == spec_target)\n@@ -1341,7 +1293,6 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n {\n   rtx op0 = str_rtx;\n   enum machine_mode int_mode;\n-  enum machine_mode ext_mode;\n   enum machine_mode mode1;\n \n   if (tmode == VOIDmode)\n@@ -1612,74 +1563,53 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* From here on we know the desired field is smaller than a word.\n      If OP0 is a register, it too fits within a word.  */\n-\n-  ext_mode = mode_for_extraction (unsignedp ? EP_extzv : EP_extv, 0);\n-  if (ext_mode != MAX_MACHINE_MODE && !MEM_P (op0))\n+  enum extraction_pattern pattern = unsignedp ? EP_extzv : EP_extv;\n+  extraction_insn extv;\n+  if (!MEM_P (op0)\n+      && get_best_reg_extraction_insn (&extv, pattern, bitnum + bitsize,\n+\t\t\t\t       tmode))\n     {\n-      rtx result = extract_bit_field_using_extv (op0, bitsize, bitnum,\n+      rtx result = extract_bit_field_using_extv (&extv, op0, bitsize, bitnum,\n \t\t\t\t\t\t unsignedp, target, mode,\n-\t\t\t\t\t\t tmode, ext_mode);\n+\t\t\t\t\t\t tmode);\n       if (result)\n \treturn result;\n     }\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n      cheap register alternative is available.  */\n-  if (ext_mode != MAX_MACHINE_MODE && MEM_P (op0))\n+  if (MEM_P (op0))\n     {\n-      enum machine_mode bestmode;\n-\n       /* Do not use extv/extzv for volatile bitfields when\n          -fstrict-volatile-bitfields is in effect.  */\n-      if (!(MEM_VOLATILE_P (op0) && flag_strict_volatile_bitfields > 0))\n+      if (!(MEM_VOLATILE_P (op0) && flag_strict_volatile_bitfields > 0)\n+\t  && get_best_mem_extraction_insn (&extv, pattern, bitsize, bitnum,\n+\t\t\t\t\t   tmode))\n \t{\n-\t  rtx result = extract_bit_field_using_extv (op0, bitsize, bitnum,\n-\t\t\t\t\t\t     unsignedp, target, mode,\n-\t\t\t\t\t\t     tmode, ext_mode);\n+\t  rtx result = extract_bit_field_using_extv (&extv, op0, bitsize,\n+\t\t\t\t\t\t     bitnum, unsignedp,\n+\t\t\t\t\t\t     target, mode,\n+\t\t\t\t\t\t     tmode);\n \t  if (result)\n \t    return result;\n \t}\n \n-      /* Get the mode to use for inserting into this field.  If\n-\t OP0 is BLKmode, get the smallest mode consistent with the\n-\t alignment. If OP0 is a non-BLKmode object that is no\n-\t wider than EXT_MODE, use its mode. Otherwise, use the\n-\t smallest mode containing the field.  */\n-\n-      if (GET_MODE (op0) == BLKmode\n-\t  || GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (ext_mode))\n-\tbestmode = get_best_mode (bitsize, bitnum, 0, 0, MEM_ALIGN (op0),\n-\t\t\t\t  ext_mode, MEM_VOLATILE_P (op0));\n-      else\n-\tbestmode = GET_MODE (op0);\n+      rtx last = get_last_insn ();\n \n-      if (bestmode != VOIDmode\n-\t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n-\t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n+      /* Try loading part of OP0 into a register and extracting the\n+\t bitfield from that.  */\n+      unsigned HOST_WIDE_INT bitpos;\n+      rtx xop0 = adjust_bit_field_mem_for_reg (pattern, op0, bitsize, bitnum,\n+\t\t\t\t\t       0, 0, tmode, &bitpos);\n+      if (xop0)\n \t{\n-\t  unsigned HOST_WIDE_INT bitpos;\n-\t  rtx xop0 = narrow_bit_field_mem (op0, bestmode, bitsize, bitnum,\n-\t\t\t\t\t   &bitpos);\n-\n-\t  /* Make sure the register is big enough for the whole field.\n-\t     (It might not be if bestmode == GET_MODE (op0) and the input\n-\t     code was invalid.)  */\n-\t  if (bitpos + bitsize <= GET_MODE_BITSIZE (bestmode))\n-\t    {\n-\t      rtx last, result;\n-\n-\t      last = get_last_insn ();\n-\n-\t      /* Fetch it to a register in that size.  */\n-\t      xop0 = force_reg (bestmode, xop0);\n-\t      result = extract_bit_field_1 (xop0, bitsize, bitpos,\n+\t  xop0 = copy_to_reg (xop0);\n+\t  rtx result = extract_bit_field_1 (xop0, bitsize, bitpos,\n \t\t\t\t\t    unsignedp, packedp, target,\n \t\t\t\t\t    mode, tmode, false);\n-\t      if (result)\n-\t\treturn result;\n-\n-\t      delete_insns_since (last);\n-\t    }\n+\t  if (result)\n+\t    return result;\n+\t  delete_insns_since (last);\n \t}\n     }\n "}, {"sha": "c2168287cff080647684b8c77ffbccf9dde50816", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -698,14 +698,6 @@ extern void probe_stack_range (HOST_WIDE_INT, rtx);\n    in its original home.  This becomes invalid if any more code is emitted.  */\n extern rtx hard_libcall_value (enum machine_mode, rtx);\n \n-/* Return the mode desired by operand N of a particular bitfield\n-   insert/extract insn, or MAX_MACHINE_MODE if no such insn is\n-   available.  */\n-\n-enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n-extern enum machine_mode\n-mode_for_extraction (enum extraction_pattern, int);\n-\n extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,"}, {"sha": "66c0337b0fd7f9a9b371f3888b9f161456b75e7f", "filename": "gcc/optabs.c", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -8239,4 +8239,177 @@ expand_jump_insn (enum insn_code icode, unsigned int nops,\n     gcc_unreachable ();\n }\n \n+/* Reduce conditional compilation elsewhere.  */\n+#ifndef HAVE_insv\n+#define HAVE_insv\t0\n+#define CODE_FOR_insv\tCODE_FOR_nothing\n+#endif\n+#ifndef HAVE_extv\n+#define HAVE_extv\t0\n+#define CODE_FOR_extv\tCODE_FOR_nothing\n+#endif\n+#ifndef HAVE_extzv\n+#define HAVE_extzv\t0\n+#define CODE_FOR_extzv\tCODE_FOR_nothing\n+#endif\n+\n+/* Enumerates the possible types of structure operand to an\n+   extraction_insn.  */\n+enum extraction_type { ET_unaligned_mem, ET_reg };\n+\n+/* Check whether insv, extv or extzv pattern ICODE can be used for an\n+   insertion or extraction of type TYPE on a structure of mode MODE.\n+   Return true if so and fill in *INSN accordingly.  STRUCT_OP is the\n+   operand number of the structure (the first sign_extract or zero_extract\n+   operand) and FIELD_OP is the operand number of the field (the other\n+   side of the set from the sign_extract or zero_extract).  */\n+\n+static bool\n+get_traditional_extraction_insn (extraction_insn *insn,\n+\t\t\t\t enum extraction_type type,\n+\t\t\t\t enum machine_mode mode,\n+\t\t\t\t enum insn_code icode,\n+\t\t\t\t int struct_op, int field_op)\n+{\n+  const struct insn_data_d *data = &insn_data[icode];\n+\n+  enum machine_mode struct_mode = data->operand[struct_op].mode;\n+  if (struct_mode == VOIDmode)\n+    struct_mode = word_mode;\n+  if (mode != struct_mode)\n+    return false;\n+\n+  enum machine_mode field_mode = data->operand[field_op].mode;\n+  if (field_mode == VOIDmode)\n+    field_mode = word_mode;\n+\n+  enum machine_mode pos_mode = data->operand[struct_op + 2].mode;\n+  if (pos_mode == VOIDmode)\n+    pos_mode = word_mode;\n+\n+  insn->icode = icode;\n+  insn->field_mode = field_mode;\n+  insn->struct_mode = (type == ET_unaligned_mem ? byte_mode : struct_mode);\n+  insn->pos_mode = pos_mode;\n+  return true;\n+}\n+\n+/* Return true if an instruction exists to perform an insertion or\n+   extraction (PATTERN says which) of type TYPE in mode MODE.\n+   Describe the instruction in *INSN if so.  */\n+\n+static bool\n+get_extraction_insn (extraction_insn *insn,\n+\t\t     enum extraction_pattern pattern,\n+\t\t     enum extraction_type type,\n+\t\t     enum machine_mode mode)\n+{\n+  switch (pattern)\n+    {\n+    case EP_insv:\n+      if (HAVE_insv\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      CODE_FOR_insv, 0, 3))\n+\treturn true;\n+      return false;\n+\n+    case EP_extv:\n+      if (HAVE_extv\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      CODE_FOR_extv, 1, 0))\n+\treturn true;\n+      return false;\n+\n+    case EP_extzv:\n+      if (HAVE_extzv\n+\t  && get_traditional_extraction_insn (insn, type, mode,\n+\t\t\t\t\t      CODE_FOR_extzv, 1, 0))\n+\treturn true;\n+      return false;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return true if an instruction exists to access a field of mode\n+   FIELDMODE in a structure that has STRUCT_BITS significant bits.\n+   Describe the \"best\" such instruction in *INSN if so.  PATTERN and\n+   TYPE describe the type of insertion or extraction we want to perform.\n+\n+   For an insertion, the number of significant structure bits includes\n+   all bits of the target.  For an extraction, it need only include the\n+   most significant bit of the field.  Larger widths are acceptable\n+   in both cases.  */\n+\n+static bool\n+get_best_extraction_insn (extraction_insn *insn,\n+\t\t\t  enum extraction_pattern pattern,\n+\t\t\t  enum extraction_type type,\n+\t\t\t  unsigned HOST_WIDE_INT struct_bits,\n+\t\t\t  enum machine_mode field_mode)\n+{\n+  enum machine_mode mode = smallest_mode_for_size (struct_bits, MODE_INT);\n+  while (mode != VOIDmode)\n+    {\n+      if (get_extraction_insn (insn, pattern, type, mode))\n+\t{\n+\t  while (mode != VOIDmode\n+\t\t && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (field_mode)\n+\t\t && !TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n+\t\t\t\t\t\t    field_mode))\n+\t    {\n+\t      get_extraction_insn (insn, pattern, type, mode);\n+\t      mode = GET_MODE_WIDER_MODE (mode);\n+\t    }\n+\t  return true;\n+\t}\n+      mode = GET_MODE_WIDER_MODE (mode);\n+    }\n+  return false;\n+}\n+\n+/* Return true if an instruction exists to access a field of mode\n+   FIELDMODE in a register structure that has STRUCT_BITS significant bits.\n+   Describe the \"best\" such instruction in *INSN if so.  PATTERN describes\n+   the type of insertion or extraction we want to perform.\n+\n+   For an insertion, the number of significant structure bits includes\n+   all bits of the target.  For an extraction, it need only include the\n+   most significant bit of the field.  Larger widths are acceptable\n+   in both cases.  */\n+\n+bool\n+get_best_reg_extraction_insn (extraction_insn *insn,\n+\t\t\t      enum extraction_pattern pattern,\n+\t\t\t      unsigned HOST_WIDE_INT struct_bits,\n+\t\t\t      enum machine_mode field_mode)\n+{\n+  return get_best_extraction_insn (insn, pattern, ET_reg, struct_bits,\n+\t\t\t\t   field_mode);\n+}\n+\n+/* Return true if an instruction exists to access a field of BITSIZE\n+   bits starting BITNUM bits into a memory structure.  Describe the\n+   \"best\" such instruction in *INSN if so.  PATTERN describes the type\n+   of insertion or extraction we want to perform and FIELDMODE is the\n+   natural mode of the extracted field.\n+\n+   The instructions considered here only access bytes that overlap\n+   the bitfield; they do not touch any surrounding bytes.  */\n+\n+bool\n+get_best_mem_extraction_insn (extraction_insn *insn,\n+\t\t\t      enum extraction_pattern pattern,\n+\t\t\t      HOST_WIDE_INT bitsize, HOST_WIDE_INT bitnum,\n+\t\t\t      enum machine_mode field_mode)\n+{\n+  unsigned HOST_WIDE_INT struct_bits = (bitnum % BITS_PER_UNIT\n+\t\t\t\t\t+ bitsize\n+\t\t\t\t\t+ BITS_PER_UNIT - 1);\n+  struct_bits -= struct_bits % BITS_PER_UNIT;\n+  return get_best_extraction_insn (insn, pattern, ET_unaligned_mem,\n+\t\t\t\t   struct_bits, field_mode);\n+}\n+\n #include \"gt-optabs.h\""}, {"sha": "81aa1d049dca29b1043108c37535c43a88967141", "filename": "gcc/optabs.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -323,6 +323,38 @@ extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \t\t\t          enum machine_mode mode2);\n \n+/* Describes an instruction that inserts or extracts a bitfield.  */\n+struct extraction_insn\n+{\n+  /* The code of the instruction.  */\n+  enum insn_code icode;\n+\n+  /* The mode that the structure operand should have.  This is byte_mode\n+     when using the legacy insv, extv and extzv patterns to access memory.  */\n+  enum machine_mode struct_mode;\n+\n+  /* The mode of the field to be inserted or extracted, and by extension\n+     the mode of the insertion or extraction itself.  */\n+  enum machine_mode field_mode;\n+\n+  /* The mode of the field's bit position.  This is only important\n+     when the position is variable rather than constant.  */\n+  enum machine_mode pos_mode;\n+};\n+\n+/* Enumerates the possible extraction_insn operations.  */\n+enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n+\n+extern bool get_best_reg_extraction_insn (extraction_insn *,\n+\t\t\t\t\t  enum extraction_pattern,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT,\n+\t\t\t\t\t  enum machine_mode);\n+\n+extern bool get_best_mem_extraction_insn (extraction_insn *,\n+\t\t\t\t\t  enum extraction_pattern,\n+\t\t\t\t\t  HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t  enum machine_mode);\n+\n extern bool insn_operand_matches (enum insn_code icode, unsigned int opno,\n \t\t\t\t  rtx operand);\n "}, {"sha": "3c56703b1f534ae1496a3776c2a9c04a9213a502", "filename": "gcc/recog.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdd52b73c0b23bffd5ce5ba591f994547333429/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=fcdd52b73c0b23bffd5ce5ba591f994547333429", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"insn-codes.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -542,6 +543,16 @@ cancel_changes (int num)\n   num_changes = num;\n }\n \n+/* Reduce conditional compilation elsewhere.  */\n+#ifndef HAVE_extv\n+#define HAVE_extv\t0\n+#define CODE_FOR_extv\tCODE_FOR_nothing\n+#endif\n+#ifndef HAVE_extzv\n+#define HAVE_extzv\t0\n+#define CODE_FOR_extzv\tCODE_FOR_nothing\n+#endif\n+\n /* A subroutine of validate_replace_rtx_1 that tries to simplify the resulting\n    rtx.  */\n \n@@ -628,19 +639,17 @@ simplify_while_replacing (rtx *loc, rtx to, rtx object,\n \t  enum machine_mode is_mode = GET_MODE (XEXP (x, 0));\n \t  int pos = INTVAL (XEXP (x, 2));\n \n-\t  if (GET_CODE (x) == ZERO_EXTRACT)\n+\t  if (GET_CODE (x) == ZERO_EXTRACT && HAVE_extzv)\n \t    {\n-\t      enum machine_mode new_mode\n-\t\t= mode_for_extraction (EP_extzv, 1);\n-\t      if (new_mode != MAX_MACHINE_MODE)\n-\t\twanted_mode = new_mode;\n+\t      wanted_mode = insn_data[CODE_FOR_extzv].operand[1].mode;\n+\t      if (wanted_mode == VOIDmode)\n+\t\twanted_mode = word_mode;\n \t    }\n-\t  else if (GET_CODE (x) == SIGN_EXTRACT)\n+\t  else if (GET_CODE (x) == SIGN_EXTRACT && HAVE_extv)\n \t    {\n-\t      enum machine_mode new_mode\n-\t\t= mode_for_extraction (EP_extv, 1);\n-\t      if (new_mode != MAX_MACHINE_MODE)\n-\t\twanted_mode = new_mode;\n+\t      wanted_mode = insn_data[CODE_FOR_extv].operand[1].mode;\n+\t      if (wanted_mode == VOIDmode)\n+\t\twanted_mode = word_mode;\n \t    }\n \n \t  /* If we have a narrower mode, we can do something.  */"}]}