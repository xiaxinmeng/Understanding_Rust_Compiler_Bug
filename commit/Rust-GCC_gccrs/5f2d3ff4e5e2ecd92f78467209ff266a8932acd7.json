{"sha": "5f2d3ff4e5e2ecd92f78467209ff266a8932acd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyZDNmZjRlNWUyZWNkOTJmNzg0NjcyMDlmZjI2NmE4OTMyYWNkNw==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-07-06T03:13:48Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-07-09T07:17:46Z"}, "message": "Improve early simplify and match for phiopt\n\nPreviously the idea was gimple_simplify_phiopt would call\nresimplify with a NULL sequence but that sometimes fails\neven if there was only one statement produced. The cases\nwhere it fails is when there are two simplifications happen.\nIn the case of the min/max production, the first simplifcation\nproduces:\n(convert (min @1 @2))\nAnd then the convert is removed by a second one. The Min statement\nwill be in the sequence while the op will be a SSA name. This was\nrejected before as could not produce something in the sequence.\nSo this patch changes the way resimplify is called to always passing\na pointer to the sequence and then decide based on if op is a\nSSA_NAME or not.\n\nOK? Bootstrapped and tested on x86_64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-phiopt.c (phiopt_early_allow): Change arguments\n\tto take sequence and gimple_match_op.  Accept the case where\n\top is a SSA_NAME and one statement in the sequence.\n\tAlso allow constants.\n\t(gimple_simplify_phiopt): Always pass a sequence to resimplify.\n\tUpdate call to phiopt_early_allow.  Discard the sequence if not\n\tused.", "tree": {"sha": "e7a3d74601eb059592a4790658283542cadfa707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7a3d74601eb059592a4790658283542cadfa707"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b33b1136d5ba1903a56fa601a848accc3db46ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b33b1136d5ba1903a56fa601a848accc3db46ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b33b1136d5ba1903a56fa601a848accc3db46ef"}], "stats": {"total": 62, "additions": 49, "deletions": 13}, "files": [{"sha": "7a98b7afdf16577142c9f777b9815a90176e341d", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d3ff4e5e2ecd92f78467209ff266a8932acd7/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=5f2d3ff4e5e2ecd92f78467209ff266a8932acd7", "patch": "@@ -812,11 +812,33 @@ two_value_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n-/* Return TRUE if CODE should be allowed during early phiopt.\n-   Currently this is to allow MIN/MAX and ABS/NEGATE.  */\n+/* Return TRUE if SEQ/OP pair should be allowed during early phiopt.\n+   Currently this is to allow MIN/MAX and ABS/NEGATE and constants.  */\n static bool\n-phiopt_early_allow (enum tree_code code)\n+phiopt_early_allow (gimple_seq &seq, gimple_match_op &op)\n {\n+  /* Don't allow functions. */\n+  if (!op.code.is_tree_code ())\n+    return false;\n+  tree_code code = (tree_code)op.code;\n+\n+  /* For non-empty sequence, only allow one statement.  */\n+  if (!gimple_seq_empty_p (seq))\n+    {\n+      /* Check to make sure op was already a SSA_NAME.  */\n+      if (code != SSA_NAME)\n+\treturn false;\n+      if (!gimple_seq_singleton_p (seq))\n+\treturn false;\n+      gimple *stmt = gimple_seq_first_stmt (seq);\n+      /* Only allow assignments.  */\n+      if (!is_gimple_assign (stmt))\n+\treturn false;\n+      if (gimple_assign_lhs (stmt) != op.ops[0])\n+\treturn false;\n+      code = gimple_assign_rhs_code (stmt);\n+    }\n+\n   switch (code)\n     {\n       case MIN_EXPR:\n@@ -826,6 +848,11 @@ phiopt_early_allow (enum tree_code code)\n       case NEGATE_EXPR:\n       case SSA_NAME:\n \treturn true;\n+      case INTEGER_CST:\n+      case REAL_CST:\n+      case VECTOR_CST:\n+      case FIXED_CST:\n+\treturn true;\n       default:\n \treturn false;\n     }\n@@ -844,6 +871,7 @@ gimple_simplify_phiopt (bool early_p, tree type, gimple *comp_stmt,\n \t\t\tgimple_seq *seq)\n {\n   tree result;\n+  gimple_seq seq1 = NULL;\n   enum tree_code comp_code = gimple_cond_code (comp_stmt);\n   location_t loc = gimple_location (comp_stmt);\n   tree cmp0 = gimple_cond_lhs (comp_stmt);\n@@ -858,18 +886,23 @@ gimple_simplify_phiopt (bool early_p, tree type, gimple *comp_stmt,\n   gimple_match_op op (gimple_match_cond::UNCOND,\n \t\t      COND_EXPR, type, cond, arg0, arg1);\n \n-  if (op.resimplify (early_p ? NULL : seq, follow_all_ssa_edges))\n+  if (op.resimplify (&seq1, follow_all_ssa_edges))\n     {\n       /* Early we want only to allow some generated tree codes. */\n       if (!early_p\n-\t  || op.code.is_tree_code ()\n-\t  || phiopt_early_allow ((tree_code)op.code))\n+\t  || phiopt_early_allow (seq1, op))\n \t{\n-\t  result = maybe_push_res_to_seq (&op, seq);\n+\t  result = maybe_push_res_to_seq (&op, &seq1);\n \t  if (result)\n-\t    return result;\n+\t    {\n+\t      gimple_seq_add_seq_without_update (seq, seq1);\n+\t      return result;\n+\t    }\n \t}\n     }\n+  gimple_seq_discard (seq1);\n+  seq1 = NULL;\n+\n   /* Try the inverted comparison, that is !COMP ? ARG1 : ARG0. */\n   comp_code = invert_tree_comparison (comp_code, HONOR_NANS (cmp0));\n \n@@ -882,18 +915,21 @@ gimple_simplify_phiopt (bool early_p, tree type, gimple *comp_stmt,\n   gimple_match_op op1 (gimple_match_cond::UNCOND,\n \t\t       COND_EXPR, type, cond, arg1, arg0);\n \n-  if (op1.resimplify (early_p ? NULL : seq, follow_all_ssa_edges))\n+  if (op1.resimplify (&seq1, follow_all_ssa_edges))\n     {\n       /* Early we want only to allow some generated tree codes. */\n       if (!early_p\n-\t  || op1.code.is_tree_code ()\n-\t  || phiopt_early_allow ((tree_code)op1.code))\n+\t  || phiopt_early_allow (seq1, op1))\n \t{\n-\t  result = maybe_push_res_to_seq (&op1, seq);\n+\t  result = maybe_push_res_to_seq (&op1, &seq1);\n \t  if (result)\n-\t    return result;\n+\t    {\n+\t      gimple_seq_add_seq_without_update (seq, seq1);\n+\t      return result;\n+\t    }\n \t}\n     }\n+  gimple_seq_discard (seq1);\n \n   return NULL;\n }"}]}