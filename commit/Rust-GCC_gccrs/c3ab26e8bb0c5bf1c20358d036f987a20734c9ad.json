{"sha": "c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNhYjI2ZThiYjBjNWJmMWMyMDM1OGQwMzZmOTg3YTIwNzM0YzlhZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-16T16:42:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-16T16:42:53Z"}, "message": "runtime: add some more preemption checks\n    \n    In particular this lets BenchmarkPingPongHog in runtime/proc_test.go\n    complete.\n    \n    Reviewed-on: https://go-review.googlesource.com/94735\n\nFrom-SVN: r257743", "tree": {"sha": "d5ba10b1e7a7066a1d806d7a74159a141f9f53b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5ba10b1e7a7066a1d806d7a74159a141f9f53b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/comments", "author": null, "committer": null, "parents": [{"sha": "3943b161342a68ec90a7b977cf6a8e451671e25d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3943b161342a68ec90a7b977cf6a8e451671e25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3943b161342a68ec90a7b977cf6a8e451671e25d"}], "stats": {"total": 50, "additions": 47, "deletions": 3}, "files": [{"sha": "cb7dffd7905c34d604856ace43f1139826536fec", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -1,4 +1,4 @@\n-5d5ea2fd05dbf369ccc53c93d4846623cdea0c47\n+cef3934fbc63f5e121abb8f88d3799961ac95b59\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "87f7879e6f5e368dbc61fce1d0ddd2926c5df74b", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -148,6 +148,11 @@ func chansend1(c *hchan, elem unsafe.Pointer) {\n  * the operation; we'll see that it's now closed.\n  */\n func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif c == nil {\n \t\tif !block {\n \t\t\treturn false\n@@ -430,6 +435,11 @@ func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n \t\tprint(\"chanrecv: chan=\", c, \"\\n\")\n \t}\n \n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif c == nil {\n \t\tif !block {\n \t\t\treturn"}, {"sha": "aba9abd7aab7d1983710ab07e0b44b692f382e2c", "filename": "libgo/go/runtime/hashmap.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fhashmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fhashmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap.go?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -356,6 +356,11 @@ func makemap(t *maptype, hint int, h *hmap) *hmap {\n // NOTE: The returned pointer may keep the whole map live, so don't\n // hold onto it for very long.\n func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif raceenabled && h != nil {\n \t\tcallerpc := getcallerpc()\n \t\tpc := funcPC(mapaccess1)\n@@ -409,6 +414,11 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n }\n \n func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif raceenabled && h != nil {\n \t\tcallerpc := getcallerpc()\n \t\tpc := funcPC(mapaccess2)\n@@ -463,6 +473,11 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \n // returns both key and value. Used by map iterator\n func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif h == nil || h.count == 0 {\n \t\treturn nil, nil\n \t}\n@@ -521,6 +536,11 @@ func mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Point\n \n // Like mapaccess, but allocates a slot for the key if it is not present in the map.\n func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \tif h == nil {\n \t\tpanic(plainError(\"assignment to entry in nil map\"))\n \t}\n@@ -772,6 +792,11 @@ func mapiterinit(t *maptype, h *hmap, it *hiter) {\n }\n \n func mapiternext(it *hiter) {\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\tif getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \th := it.h\n \tif raceenabled {\n \t\tcallerpc := getcallerpc()"}, {"sha": "c27aa487df3f7eca24ae9118eb9075c6c731c803", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -826,6 +826,7 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \t\t}\n \t}\n \n+\t// Check preemption, since unlike gc we don't check on every call.\n \tif getg().preempt {\n \t\tcheckPreempt()\n \t}"}, {"sha": "1d95109d7c0cbc388800e94d820f324510c3c895", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -4084,8 +4084,9 @@ func preemptone(_p_ *p) bool {\n \t// setting a global variable and figuring out a way to efficiently\n \t// check that global variable.\n \t//\n-\t// For now we check gp.preempt in schedule and mallocgc,\n-\t// which is at least better than doing nothing at all.\n+\t// For now we check gp.preempt in schedule, mallocgc, selectgo,\n+\t// and a few other places, which is at least better than doing\n+\t// nothing at all.\n \n \treturn true\n }"}, {"sha": "1c5124b4704b82b7f453651bf1710a1c4784b7c0", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ab26e8bb0c5bf1c20358d036f987a20734c9ad/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=c3ab26e8bb0c5bf1c20358d036f987a20734c9ad", "patch": "@@ -584,6 +584,13 @@ retc:\n \tif cas.releasetime > 0 {\n \t\tblockevent(cas.releasetime-t0, 1)\n \t}\n+\n+\t// Check preemption, since unlike gc we don't check on every call.\n+\t// A test case for this one is BenchmarkPingPongHog in proc_test.go.\n+\tif dfl != nil && getg().preempt {\n+\t\tcheckPreempt()\n+\t}\n+\n \treturn casi\n \n sclose:"}]}