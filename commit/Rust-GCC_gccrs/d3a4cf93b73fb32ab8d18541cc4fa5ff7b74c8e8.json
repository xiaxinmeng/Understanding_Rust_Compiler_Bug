{"sha": "d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "node_id": "C_kwDOANBUbNoAKGQzYTRjZjkzYjczZmIzMmFiOGQxODU0MWNjNGZhNWZmN2I3NGM4ZTg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-25T11:14:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-25T11:14:37Z"}, "message": "Merge #974\n\n974: Add support for  ranges and index lang items  along with the TyTy::SliceType r=philberty a=philberty\n\nThis PR contains more code to begin supporting Slices which requires support\r\nfor more intrinsic, range and index lang items. More work is needed to support\r\nslices such as the const_ptr lang item and the offset intrinsic but this is a big\r\nPR already and adds support for more lang items along the way.\r\n\r\nFixes #975\r\nAddresses #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "188edbabfaa677bf7971b44a2450f83f4ba0cfba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188edbabfaa677bf7971b44a2450f83f4ba0cfba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGLodCRBK7hj4Ov3rIwAAiKcIAKgSXvoXjJDB6cdtXhKxQuXs\niD5cdkl6tQ+KIVScAXpnseLsmuoReoxPRF3oScGDFWtwR/aVClf4SaSKWrAYs+lx\n+Z21R5jUgPn0lyJtLTi9iSD5mrsVzitCUziYj5Ylc9cLArb2QKfm4g8n+NvY/nqN\n7gCgEMysDkw2XBlXV0T6xD8rWt9R6I5A8NxyO7DLgbSIvbOmHlWy4+eYvdkD4bn1\nIZPu8rlu6IDQfGoX6fLOLlo9wfMFykZ0b8sTT1q7cFSqoFLGUfK8Db3tzGXMPXL1\nN3vYn0E9d+6jQSGIj6mdawwYd5A+B4gNjIcjCOfwbndKKQA9tX2ZH7amNsnq1YQ=\n=ejxg\n-----END PGP SIGNATURE-----\n", "payload": "tree 188edbabfaa677bf7971b44a2450f83f4ba0cfba\nparent bf92a1012264f2544e73a7a8dd0ac1e473c7f658\nparent 22c6bca60a9bc80c043e4da9a94cb80023dde04c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645787677 +0000\ncommitter GitHub <noreply@github.com> 1645787677 +0000\n\nMerge #974\n\n974: Add support for  ranges and index lang items  along with the TyTy::SliceType r=philberty a=philberty\n\nThis PR contains more code to begin supporting Slices which requires support\r\nfor more intrinsic, range and index lang items. More work is needed to support\r\nslices such as the const_ptr lang item and the offset intrinsic but this is a big\r\nPR already and adds support for more lang items along the way.\r\n\r\nFixes #975\r\nAddresses #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf92a1012264f2544e73a7a8dd0ac1e473c7f658"}, {"sha": "22c6bca60a9bc80c043e4da9a94cb80023dde04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c6bca60a9bc80c043e4da9a94cb80023dde04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c6bca60a9bc80c043e4da9a94cb80023dde04c"}], "stats": {"total": 1522, "additions": 1252, "deletions": 270}, "files": [{"sha": "69943f9794af8ae781d8913ebbb0409bda42b454", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -95,6 +95,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-type-check-pattern.o \\\n+    rust/rust-hir-type-check-expr.o \\\n     rust/rust-hir-dot-operator.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "bf47661f42752d7448b3df5417422ea30218c3ab", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 168, "deletions": 1, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -790,7 +790,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \n tree\n CompileExpr::resolve_operator_overload (\n-  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n   tree lhs, tree rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n {\n   TyTy::FnType *fntype;\n@@ -1377,5 +1377,172 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n     }\n }\n \n+void\n+CompileExpr::visit (HIR::RangeFromToExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (from == error_mark_node || to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from, to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFromExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  if (from == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeToExpr &expr)\n+{\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFullExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+  translated = ctx->get_backend ()->constructor_expression (adt, false, {}, -1,\n+\t\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFromToInclExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (from == error_mark_node || to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from, to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n+{\n+  tree array_reference = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+  tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+\n+  // this might be an core::ops::index lang item situation\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type = Analysis::RustLangItem::ItemType::INDEX;\n+      tree operator_overload_call\n+\t= resolve_operator_overload (lang_item_type, expr, array_reference,\n+\t\t\t\t     index, expr.get_array_expr (),\n+\t\t\t\t     expr.get_index_expr ());\n+\n+      // lookup the expected type for this expression\n+      TyTy::BaseType *tyty = nullptr;\n+      bool ok\n+\t= ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t  &tyty);\n+      rust_assert (ok);\n+      tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+      // rust deref always returns a reference from this overload then we can\n+      // actually do the indirection\n+      translated\n+\t= ctx->get_backend ()->indirect_expression (expected_type,\n+\t\t\t\t\t\t    operator_overload_call,\n+\t\t\t\t\t\t    true, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lets check if the array is a reference type then we can add an\n+  // indirection if required\n+  TyTy::BaseType *array_expr_ty = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_array_expr ()->get_mappings ().get_hirid (), &array_expr_ty);\n+  rust_assert (ok);\n+\n+  // do we need to add an indirect reference\n+  if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r\n+\t= static_cast<TyTy::ReferenceType *> (array_expr_ty);\n+      TyTy::BaseType *tuple_type = r->get_base ();\n+      tree array_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n+\n+      array_reference\n+\t= ctx->get_backend ()->indirect_expression (array_tyty, array_reference,\n+\t\t\t\t\t\t    true, expr.get_locus ());\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->array_index_expression (array_reference, index,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "f2b4df894ca7aa10fe2608dc0141cf0ecac70107", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -201,36 +201,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::CompoundAssignmentExpr &expr) override;\n \n-  void visit (HIR::ArrayIndexExpr &expr) override\n-  {\n-    tree array_reference = CompileExpr::Compile (expr.get_array_expr (), ctx);\n-    tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n-\n-    // lets check if the array is a reference type then we can add an\n-    // indirection if required\n-    TyTy::BaseType *array_expr_ty = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (\n-      expr.get_array_expr ()->get_mappings ().get_hirid (), &array_expr_ty);\n-    rust_assert (ok);\n-\n-    // do we need to add an indirect reference\n-    if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tTyTy::ReferenceType *r\n-\t  = static_cast<TyTy::ReferenceType *> (array_expr_ty);\n-\tTyTy::BaseType *tuple_type = r->get_base ();\n-\ttree array_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n-\n-\tarray_reference\n-\t  = ctx->get_backend ()->indirect_expression (array_tyty,\n-\t\t\t\t\t\t      array_reference, true,\n-\t\t\t\t\t\t      expr.get_locus ());\n-      }\n-\n-    translated\n-      = ctx->get_backend ()->array_index_expression (array_reference, index,\n-\t\t\t\t\t\t     expr.get_locus ());\n-  }\n+  void visit (HIR::ArrayIndexExpr &expr) override;\n \n   void visit (HIR::ArrayExpr &expr) override;\n \n@@ -803,6 +774,16 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::MatchExpr &expr) override;\n \n+  void visit (HIR::RangeFromToExpr &expr) override;\n+\n+  void visit (HIR::RangeFromExpr &expr) override;\n+\n+  void visit (HIR::RangeToExpr &expr) override;\n+\n+  void visit (HIR::RangeFullExpr &expr) override;\n+\n+  void visit (HIR::RangeFromToInclExpr &expr) override;\n+\n protected:\n   tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t  TyTy::BaseType *receiver,\n@@ -818,7 +799,7 @@ class CompileExpr : public HIRCompileBase\n \n   tree\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n-\t\t\t     HIR::OperatorExpr &expr, tree lhs, tree rhs,\n+\t\t\t     HIR::OperatorExprMeta expr, tree lhs, tree rhs,\n \t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n \n   tree compile_bool_literal (const HIR::LiteralExpr &expr,"}, {"sha": "21da9aff1d11aacf528ab949e62d9368250b53e5", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -344,6 +344,13 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n     = ctx->get_backend ()->array_type (element_type, folded_capacity_expr);\n }\n \n+void\n+TyTyResolveCompile::visit (const TyTy::SliceType &type)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n void\n TyTyResolveCompile::visit (const TyTy::BoolType &type)\n {"}, {"sha": "4f9c40349e407db206c97d3515f39ef5647c4f17", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -43,6 +43,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n   void visit (const TyTy::FnType &) override;\n   void visit (const TyTy::FnPtr &) override;\n   void visit (const TyTy::ArrayType &) override;\n+  void visit (const TyTy::SliceType &) override;\n   void visit (const TyTy::BoolType &) override;\n   void visit (const TyTy::IntType &) override;\n   void visit (const TyTy::UintType &) override;"}, {"sha": "a3720f8c2fa3b2f051288056b4d90e01f12138d2", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -62,6 +62,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n \n   void visit (TyTy::PointerType &) override { gcc_unreachable (); }"}, {"sha": "df836fc5a5745c0e0f09bda893e8849d624695b8", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -728,6 +728,85 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t    expr.get_outer_attrs (), expr.get_locus ());\n   }\n \n+  void visit (AST::RangeFromToExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromToExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\t  expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFromExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromExpr (mapping,\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\texpr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeToExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeToExpr (mapping, std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t      expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFullExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::RangeFullExpr (mapping, expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFromToInclExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromToInclExpr (mapping,\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\t      expr.get_locus ());\n+  }\n+\n private:\n   ASTLoweringExpr ()\n     : ASTLoweringBase (), translated (nullptr),"}, {"sha": "b77545a0678e219b8f8f6575e4d464b9d4fb4c1f", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -2430,6 +2430,9 @@ class RangeFromToExpr : public RangeExpr\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_from_expr () { return from; }\n+  std::unique_ptr<Expr> &get_to_expr () { return to; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2480,6 +2483,8 @@ class RangeFromExpr : public RangeExpr\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_from_expr () { return from; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2531,6 +2536,8 @@ class RangeToExpr : public RangeExpr\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_to_expr () { return to; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2617,6 +2624,9 @@ class RangeFromToInclExpr : public RangeExpr\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_from_expr () { return from; }\n+  std::unique_ptr<Expr> &get_to_expr () { return to; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4019,6 +4029,40 @@ class AsyncBlockExpr : public ExprWithBlock\n     return new AsyncBlockExpr (*this);\n   }\n };\n+\n+// this is a utility helper class for type-checking and code-generation\n+class OperatorExprMeta\n+{\n+public:\n+  OperatorExprMeta (HIR::CompoundAssignmentExpr &expr)\n+    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+  {}\n+\n+  OperatorExprMeta (HIR::ArithmeticOrLogicalExpr &expr)\n+    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+  {}\n+\n+  OperatorExprMeta (HIR::NegationExpr &expr)\n+    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+  {}\n+\n+  OperatorExprMeta (HIR::DereferenceExpr &expr)\n+    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+  {}\n+\n+  OperatorExprMeta (HIR::ArrayIndexExpr &expr)\n+    : node_mappings (expr.get_mappings ()), locus (expr.get_locus ())\n+  {}\n+\n+  const Analysis::NodeMapping &get_mappings () const { return node_mappings; }\n+\n+  Location get_locus () const { return locus; }\n+\n+private:\n+  const Analysis::NodeMapping node_mappings;\n+  Location locus;\n+};\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "539a3fee6f59418a01661cdc3f25f37f61751b04", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -0,0 +1,490 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromToExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n+  TyTy::BaseType *to_ty\n+    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+  TyTy::BaseType *unified = from_ty->unify (to_ty);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_FROM;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeToExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_TO;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFullExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_FULL;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->is_unit ());\n+\n+  infered = item_type;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromToInclExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_INCLUSIVE;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n+  TyTy::BaseType *to_ty\n+    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+  TyTy::BaseType *unified = from_ty->unify (to_ty);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n+{\n+  auto array_expr_ty\n+    = TypeCheckExpr::Resolve (expr.get_array_expr (), inside_loop);\n+  if (array_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto index_expr_ty = TypeCheckExpr::Resolve (expr.get_index_expr (), false);\n+  if (index_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  // is this a case of core::ops::index?\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::INDEX;\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, array_expr_ty,\n+\t\t\t\t index_expr_ty);\n+  if (operator_overloaded)\n+    {\n+      // index and index mut always return a reference to the element\n+      TyTy::BaseType *resolved = infered;\n+      rust_assert (resolved->get_kind () == TyTy::TypeKind::REF);\n+      TyTy::ReferenceType *ref = static_cast<TyTy::ReferenceType *> (resolved);\n+\n+      infered = ref->get_base ()->clone ();\n+      return;\n+    }\n+\n+  if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      // lets try and deref it since rust allows this\n+      auto ref = static_cast<TyTy::ReferenceType *> (array_expr_ty);\n+      auto base = ref->get_base ();\n+      if (base->get_kind () == TyTy::TypeKind::ARRAY)\n+\tarray_expr_ty = base;\n+    }\n+\n+  if (array_expr_ty->get_kind () != TyTy::TypeKind::ARRAY)\n+    {\n+      rust_error_at (expr.get_index_expr ()->get_locus (),\n+\t\t     \"expected an ArrayType got [%s]\",\n+\t\t     array_expr_ty->as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *size_ty;\n+  bool ok = context->lookup_builtin (\"usize\", &size_ty);\n+  rust_assert (ok);\n+\n+  auto resolved_index_expr\n+    = size_ty->unify (TypeCheckExpr::Resolve (expr.get_index_expr (), false));\n+  if (resolved_index_expr->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::ArrayType *array_type = static_cast<TyTy::ArrayType *> (array_expr_ty);\n+  infered = array_type->get_element_type ()->clone ();\n+}\n+\n+bool\n+TypeCheckExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n+  TyTy::BaseType *lhs, TyTy::BaseType *rhs)\n+{\n+  // look up lang item for arithmetic type\n+  std::string associated_item_name\n+    = Analysis::RustLangItem::ToString (lang_item_type);\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // probe for the lang-item\n+  if (!lang_item_defined)\n+    return false;\n+\n+  auto segment = HIR::PathIdentSegment (associated_item_name);\n+  auto candidate\n+    = MethodResolver::Probe (lhs, HIR::PathIdentSegment (associated_item_name));\n+\n+  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  if (!have_implementation_for_lang_item)\n+    return false;\n+\n+  // Get the adjusted self\n+  Adjuster adj (lhs);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // is this the case we are recursive\n+  // handle the case where we are within the impl block for this lang_item\n+  // otherwise we end up with a recursive operator overload such as the i32\n+  // operator overload trait\n+  TypeCheckContextItem &fn_context = context->peek_context ();\n+  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+    {\n+      auto &impl_item = fn_context.get_impl_item ();\n+      HIR::ImplBlock *parent = impl_item.first;\n+      HIR::Function *fn = impl_item.second;\n+\n+      if (parent->has_trait_ref ()\n+\t  && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t{\n+\t  TraitReference *trait_reference\n+\t    = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t  if (!trait_reference->is_error ())\n+\t    {\n+\t      TyTy::BaseType *lookup = nullptr;\n+\t      bool ok = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t      rust_assert (ok);\n+\t      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t      rust_assert (fntype->is_method ());\n+\n+\t      bool is_lang_item_impl\n+\t\t= trait_reference->get_mappings ().get_defid ()\n+\t\t  == respective_lang_item_id;\n+\t      bool self_is_lang_item_self\n+\t\t= fntype->get_self_type ()->is_equal (*adjusted_self);\n+\t      bool recursive_operator_overload\n+\t\t= is_lang_item_impl && self_is_lang_item_self;\n+\n+\t      if (recursive_operator_overload)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  // store the adjustments for code-generation to know what to do\n+  context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  // now its just like a method-call-expr\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  auto root = lhs->get_root ();\n+  bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // handle generics\n+  if (!receiver_is_type_param)\n+    {\n+      if (lookup->needs_generic_substitutions ())\n+\t{\n+\t  lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n+\t}\n+    }\n+\n+  // type check the arguments if required\n+  TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (type->num_params () > 0);\n+  auto fnparam = type->param_at (0);\n+  fnparam.second->unify (adjusted_self); // typecheck the self\n+  if (rhs == nullptr)\n+    {\n+      rust_assert (type->num_params () == 1);\n+    }\n+  else\n+    {\n+      rust_assert (type->num_params () == 2);\n+      auto fnparam = type->param_at (1);\n+      fnparam.second->unify (rhs); // typecheck the rhs\n+    }\n+\n+  // get the return type\n+  TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n+\n+  // store the expected fntype\n+  context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+\n+  return true;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "93aa868505c0ebc3ea582cdc01c842c3d16df5a1", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 11, "deletions": 230, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -879,52 +879,7 @@ class TypeCheckExpr : public TypeCheckBase\n       = TypeCheckExpr::Resolve (expr.get_block_expr ().get (), inside_loop);\n   }\n \n-  void visit (HIR::ArrayIndexExpr &expr) override\n-  {\n-    TyTy::BaseType *size_ty;\n-    if (!context->lookup_builtin (\"usize\", &size_ty))\n-      {\n-\trust_error_at (\n-\t  expr.get_locus (),\n-\t  \"Failure looking up size type for index in ArrayIndexExpr\");\n-\treturn;\n-      }\n-\n-    auto resolved_index_expr\n-      = size_ty->unify (TypeCheckExpr::Resolve (expr.get_index_expr (), false));\n-    if (resolved_index_expr->get_kind () != TyTy::TypeKind::ERROR)\n-      {\n-\t// allow the index expr to fail lets just continue on\n-\tcontext->insert_type (expr.get_index_expr ()->get_mappings (),\n-\t\t\t      resolved_index_expr);\n-      }\n-\n-    auto array_expr_ty\n-      = TypeCheckExpr::Resolve (expr.get_array_expr (), inside_loop);\n-    if (array_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-    else if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\t// lets try and deref it since rust allows this\n-\tauto ref = static_cast<TyTy::ReferenceType *> (array_expr_ty);\n-\tauto base = ref->get_base ();\n-\tif (base->get_kind () == TyTy::TypeKind::ARRAY)\n-\t  array_expr_ty = base;\n-      }\n-\n-    if (array_expr_ty->get_kind () != TyTy::TypeKind::ARRAY)\n-      {\n-\trust_error_at (expr.get_index_expr ()->get_locus (),\n-\t\t       \"expected an ArrayType got [%s]\",\n-\t\t       infered->as_string ().c_str ());\n-\tinfered = nullptr;\n-\treturn;\n-      }\n-\n-    TyTy::ArrayType *array_type\n-      = static_cast<TyTy::ArrayType *> (array_expr_ty);\n-    infered = array_type->get_element_type ()->clone ();\n-  }\n+  void visit (HIR::ArrayIndexExpr &expr) override;\n \n   void visit (HIR::ArrayExpr &expr) override\n   {\n@@ -1271,195 +1226,21 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n   }\n \n-protected:\n-  bool\n-  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n-\t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n-\t\t\t     TyTy::BaseType *rhs)\n-  {\n-    // look up lang item for arithmetic type\n-    std::string associated_item_name\n-      = Analysis::RustLangItem::ToString (lang_item_type);\n-    DefId respective_lang_item_id = UNKNOWN_DEFID;\n-    bool lang_item_defined\n-      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n-\n-    // probe for the lang-item\n-    if (!lang_item_defined)\n-      return false;\n-\n-    auto segment = HIR::PathIdentSegment (associated_item_name);\n-    auto candidate\n-      = MethodResolver::Probe (lhs,\n-\t\t\t       HIR::PathIdentSegment (associated_item_name));\n+  void visit (HIR::RangeFromToExpr &expr) override;\n \n-    bool have_implementation_for_lang_item = !candidate.is_error ();\n-    if (!have_implementation_for_lang_item)\n-      return false;\n+  void visit (HIR::RangeFromExpr &expr) override;\n \n-    // Get the adjusted self\n-    Adjuster adj (lhs);\n-    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+  void visit (HIR::RangeToExpr &expr) override;\n \n-    // is this the case we are recursive\n-    // handle the case where we are within the impl block for this lang_item\n-    // otherwise we end up with a recursive operator overload such as the i32\n-    // operator overload trait\n-    TypeCheckContextItem &fn_context = context->peek_context ();\n-    if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n-      {\n-\tauto &impl_item = fn_context.get_impl_item ();\n-\tHIR::ImplBlock *parent = impl_item.first;\n-\tHIR::Function *fn = impl_item.second;\n+  void visit (HIR::RangeFullExpr &expr) override;\n \n-\tif (parent->has_trait_ref ()\n-\t    && fn->get_function_name ().compare (associated_item_name) == 0)\n-\t  {\n-\t    TraitReference *trait_reference\n-\t      = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n-\t    if (!trait_reference->is_error ())\n-\t      {\n-\t\tTyTy::BaseType *lookup = nullptr;\n-\t\tbool ok\n-\t\t  = context->lookup_type (fn->get_mappings ().get_hirid (),\n-\t\t\t\t\t  &lookup);\n-\t\trust_assert (ok);\n-\t\trust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t\tTyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\t\trust_assert (fntype->is_method ());\n-\n-\t\tbool is_lang_item_impl\n-\t\t  = trait_reference->get_mappings ().get_defid ()\n-\t\t    == respective_lang_item_id;\n-\t\tbool self_is_lang_item_self\n-\t\t  = fntype->get_self_type ()->is_equal (*adjusted_self);\n-\t\tbool recursive_operator_overload\n-\t\t  = is_lang_item_impl && self_is_lang_item_self;\n-\n-\t\tif (recursive_operator_overload)\n-\t\t  return false;\n-\t      }\n-\t  }\n-      }\n+  void visit (HIR::RangeFromToInclExpr &expr) override;\n \n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (candidate.adjustments));\n-\n-    // now its just like a method-call-expr\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n-\n-    PathProbeCandidate &resolved_candidate = candidate.candidate;\n-    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate.is_impl_candidate ()\n-\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (fn->is_method ());\n-\n-    auto root = lhs->get_root ();\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n-\n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n-\n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n-\n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n-\n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n-\n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    // handle generics\n-    if (!receiver_is_type_param)\n-      {\n-\tif (lookup->needs_generic_substitutions ())\n-\t  {\n-\t    lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n-\t  }\n-      }\n-\n-    // type check the arguments if required\n-    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (type->num_params () > 0);\n-    auto fnparam = type->param_at (0);\n-    fnparam.second->unify (adjusted_self); // typecheck the self\n-    if (rhs == nullptr)\n-      {\n-\trust_assert (type->num_params () == 1);\n-      }\n-    else\n-      {\n-\trust_assert (type->num_params () == 2);\n-\tauto fnparam = type->param_at (1);\n-\tfnparam.second->unify (rhs); // typecheck the rhs\n-      }\n-\n-    // get the return type\n-    TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n-\n-    // store the expected fntype\n-    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n-\n-    return true;\n-  }\n+protected:\n+  bool\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExprMeta expr, TyTy::BaseType *lhs,\n+\t\t\t     TyTy::BaseType *rhs);\n \n private:\n   TypeCheckExpr (bool inside_loop)"}, {"sha": "0d48bd2532c352fc4e8ad6bfe39717b30a6e05cd", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -124,6 +124,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n   void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n   void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n   void visit (TyTy::IntType &) override { gcc_unreachable (); }\n   void visit (TyTy::UintType &) override { gcc_unreachable (); }\n@@ -224,6 +225,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n   void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n   void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n   void visit (TyTy::IntType &) override { gcc_unreachable (); }\n   void visit (TyTy::UintType &) override { gcc_unreachable (); }\n@@ -286,6 +288,7 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n   void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n   void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n   void visit (TyTy::IntType &) override { gcc_unreachable (); }\n   void visit (TyTy::UintType &) override { gcc_unreachable (); }\n@@ -343,6 +346,7 @@ class GetUsedSubstArgs : public TyTy::TyConstVisitor\n   void visit (const TyTy::TupleType &) override {}\n   void visit (const TyTy::FnPtr &) override {}\n   void visit (const TyTy::ArrayType &) override {}\n+  void visit (const TyTy::SliceType &) override {}\n   void visit (const TyTy::BoolType &) override {}\n   void visit (const TyTy::IntType &) override {}\n   void visit (const TyTy::UintType &) override {}"}, {"sha": "51817e6446d3eee0cda6e24ead7e85df2a9fd413", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -43,6 +43,7 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (InferType &) override { gcc_unreachable (); }\n   void visit (TupleType &) override { gcc_unreachable (); }\n   void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (SliceType &) override { gcc_unreachable (); }\n   void visit (BoolType &) override { gcc_unreachable (); }\n   void visit (IntType &) override { gcc_unreachable (); }\n   void visit (UintType &) override { gcc_unreachable (); }\n@@ -99,6 +100,7 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (InferType &) override { gcc_unreachable (); }\n   void visit (TupleType &) override { gcc_unreachable (); }\n   void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (SliceType &) override { gcc_unreachable (); }\n   void visit (BoolType &) override { gcc_unreachable (); }\n   void visit (IntType &) override { gcc_unreachable (); }\n   void visit (UintType &) override { gcc_unreachable (); }"}, {"sha": "0e0e7b0a65bf8cfb5ebe58f2f18213f946c7a8e5", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -153,6 +153,17 @@ class BaseCastRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (SliceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n   virtual void visit (BoolType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n@@ -468,6 +479,19 @@ class InferCastRules : public BaseCastRules\n     BaseCastRules::visit (type);\n   }\n \n+  void visit (SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n   void visit (ADTType &type) override\n   {\n     bool is_valid\n@@ -818,6 +842,35 @@ class ArrayCastRules : public BaseCastRules\n   ArrayType *base;\n };\n \n+class SliceCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  SliceCastRules (SliceType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (SliceType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_ident ().locus,\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  SliceType *base;\n+};\n+\n class BoolCastRules : public BaseCastRules\n {\n   using Rust::TyTy::BaseCastRules::visit;"}, {"sha": "436bde9a2954f90810dcab74fe0ef1f0abb7dca0", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -155,6 +155,22 @@ class BaseCmp : public TyConstVisitor\n       }\n   }\n \n+  virtual void visit (const SliceType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n   virtual void visit (const BoolType &type) override\n   {\n     ok = false;\n@@ -544,6 +560,19 @@ class InferCmp : public BaseCmp\n     BaseCmp::visit (type);\n   }\n \n+  void visit (const SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n   void visit (const ADTType &type) override\n   {\n     bool is_valid\n@@ -864,6 +893,36 @@ class ArrayCmp : public BaseCmp\n   const ArrayType *base;\n };\n \n+class SliceCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  SliceCmp (const SliceType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const SliceType &type) override\n+  {\n+    // check base type\n+    const BaseType *base_element = base->get_element_type ();\n+    const BaseType *other_element = type.get_element_type ();\n+    if (!base_element->can_eq (other_element, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const ParamType &type) override { ok = true; }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const SliceType *base;\n+};\n+\n class BoolCmp : public BaseCmp\n {\n   using Rust::TyTy::BaseCmp::visit;\n@@ -1258,6 +1317,8 @@ class ParamCmp : public BaseCmp\n \n   void visit (const ArrayType &) override { ok = true; }\n \n+  void visit (const SliceType &) override { ok = true; }\n+\n   void visit (const BoolType &) override { ok = true; }\n \n   void visit (const IntType &) override { ok = true; }"}, {"sha": "4deed5521a9b773c55595d3b6bc82e7defe4f8d4", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -167,6 +167,17 @@ class BaseCoercionRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (SliceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n   virtual void visit (BoolType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n@@ -483,6 +494,19 @@ class InferCoercionRules : public BaseCoercionRules\n     BaseCoercionRules::visit (type);\n   }\n \n+  void visit (SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n   void visit (ADTType &type) override\n   {\n     bool is_valid\n@@ -836,6 +860,36 @@ class ArrayCoercionRules : public BaseCoercionRules\n   ArrayType *base;\n };\n \n+class SliceCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  SliceCoercionRules (SliceType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (SliceType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_ident ().locus,\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  SliceType *base;\n+};\n+\n class BoolCoercionRules : public BaseCoercionRules\n {\n   using Rust::TyTy::BaseCoercionRules::visit;"}, {"sha": "c1fc2cd96c13666a134463617573b87e918a39ee", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -185,6 +185,17 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (SliceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n   virtual void visit (BoolType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n@@ -500,6 +511,19 @@ class InferRules : public BaseRules\n     BaseRules::visit (type);\n   }\n \n+  void visit (SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n   void visit (ADTType &type) override\n   {\n     bool is_valid\n@@ -850,6 +874,35 @@ class ArrayRules : public BaseRules\n   ArrayType *base;\n };\n \n+class SliceRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  SliceRules (SliceType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (SliceType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_ident ().locus,\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  SliceType *base;\n+};\n+\n class BoolRules : public BaseRules\n {\n   using Rust::TyTy::BaseRules::visit;"}, {"sha": "464e70d39d7781cd517909e6320773b0249c847e", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -33,6 +33,7 @@ class TyVisitor\n   virtual void visit (FnType &type) = 0;\n   virtual void visit (FnPtr &type) = 0;\n   virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n   virtual void visit (BoolType &type) = 0;\n   virtual void visit (IntType &type) = 0;\n   virtual void visit (UintType &type) = 0;\n@@ -61,6 +62,7 @@ class TyConstVisitor\n   virtual void visit (const FnType &type) = 0;\n   virtual void visit (const FnPtr &type) = 0;\n   virtual void visit (const ArrayType &type) = 0;\n+  virtual void visit (const SliceType &type) = 0;\n   virtual void visit (const BoolType &type) = 0;\n   virtual void visit (const IntType &type) = 0;\n   virtual void visit (const UintType &type) = 0;"}, {"sha": "fa5dcfb877ce2af35201142fcc6dddc7aed4e4ce", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 82, "deletions": 8, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -59,6 +59,9 @@ TypeKindFormat::to_string (TypeKind kind)\n     case TypeKind::ARRAY:\n       return \"ARRAY\";\n \n+    case TypeKind::SLICE:\n+      return \"SLICE\";\n+\n     case TypeKind::FNDEF:\n       return \"FnDef\";\n \n@@ -840,16 +843,14 @@ ADTType::is_equal (const BaseType &other) const\n \t    return false;\n \t}\n     }\n-  else\n+\n+  for (size_t i = 0; i < number_of_variants (); i++)\n     {\n-      for (size_t i = 0; i < number_of_variants (); i++)\n-\t{\n-\t  const TyTy::VariantDef *a = get_variants ().at (i);\n-\t  const TyTy::VariantDef *b = other2.get_variants ().at (i);\n+      const TyTy::VariantDef *a = get_variants ().at (i);\n+      const TyTy::VariantDef *b = other2.get_variants ().at (i);\n \n-\t  if (!a->is_equal (*b))\n-\t    return false;\n-\t}\n+      if (!a->is_equal (*b))\n+\treturn false;\n     }\n \n   return true;\n@@ -1504,6 +1505,79 @@ ArrayType::clone () const\n \t\t\telement_type, get_combined_refs ());\n }\n \n+void\n+SliceType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+SliceType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+SliceType::as_string () const\n+{\n+  return \"[\" + get_element_type ()->as_string () + \"]\";\n+}\n+\n+BaseType *\n+SliceType::unify (BaseType *other)\n+{\n+  SliceRules r (this);\n+  return r.unify (other);\n+}\n+\n+BaseType *\n+SliceType::coerce (BaseType *other)\n+{\n+  SliceCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n+BaseType *\n+SliceType::cast (BaseType *other)\n+{\n+  SliceCastRules r (this);\n+  return r.cast (other);\n+}\n+\n+bool\n+SliceType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  SliceCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+SliceType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const SliceType &> (other);\n+\n+  auto this_element_type = get_element_type ();\n+  auto other_element_type = other2.get_element_type ();\n+\n+  return this_element_type->is_equal (*other_element_type);\n+}\n+\n+BaseType *\n+SliceType::get_element_type () const\n+{\n+  return element_type.get_tyty ();\n+}\n+\n+BaseType *\n+SliceType::clone () const\n+{\n+  return new SliceType (get_ref (), get_ty_ref (), ident.locus, element_type,\n+\t\t\tget_combined_refs ());\n+}\n+\n void\n BoolType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "85948b200d384be5f7ffe9a2b2569f524a2cf973", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -47,6 +47,7 @@ enum TypeKind\n   POINTER,\n   PARAM,\n   ARRAY,\n+  SLICE,\n   FNDEF,\n   FNPTR,\n   TUPLE,\n@@ -1666,6 +1667,50 @@ class ArrayType : public BaseType\n   HIR::Expr &capacity_expr;\n };\n \n+class SliceType : public BaseType\n+{\n+public:\n+  SliceType (HirId ref, Location locus, TyVar base,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::SLICE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base)\n+  {}\n+\n+  SliceType (HirId ref, HirId ty_ref, Location locus, TyVar base,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::SLICE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *get_element_type () const;\n+\n+  BaseType *clone () const final override;\n+\n+  bool is_concrete () const final override\n+  {\n+    return get_element_type ()->is_concrete ();\n+  }\n+\n+private:\n+  TyVar element_type;\n+};\n+\n class BoolType : public BaseType\n {\n public:"}, {"sha": "cade09d88541bef762bcdec30ff6985e35eec53e", "filename": "gcc/rust/util/rust-lang-item.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Futil%2Frust-lang-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Frust%2Futil%2Frust-lang-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-lang-item.h?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -56,6 +56,10 @@ class RustLangItem\n     DEREF,\n     DEREF_MUT,\n \n+    // https://github.com/rust-lang/rust/blob/master/library/core/src/ops/index.rs\n+    INDEX,\n+    INDEX_MUT,\n+\n     // https://github.com/rust-lang/rust/blob/master/library/core/src/ops/range.rs\n     RANGE_FULL,\n     RANGE,\n@@ -165,6 +169,18 @@ class RustLangItem\n       {\n \treturn ItemType::DEREF_MUT;\n       }\n+    else if (item.compare (\"index\") == 0)\n+      {\n+\treturn ItemType::INDEX;\n+      }\n+    else if (item.compare (\"index_mut\") == 0)\n+      {\n+\treturn ItemType::INDEX_MUT;\n+      }\n+    else if (item.compare (\"RangeFull\") == 0)\n+      {\n+\treturn ItemType::RANGE_FULL;\n+      }\n     else if (item.compare (\"Range\") == 0)\n       {\n \treturn ItemType::RANGE;\n@@ -241,6 +257,10 @@ class RustLangItem\n \treturn \"deref\";\n       case DEREF_MUT:\n \treturn \"deref_mut\";\n+      case INDEX:\n+\treturn \"index\";\n+      case INDEX_MUT:\n+\treturn \"index_mut\";\n       case RANGE_FULL:\n \treturn \"RangeFull\";\n       case RANGE:"}, {"sha": "869461622765286244b9bf68ba8f6d3783c3229f", "filename": "gcc/testsuite/rust/compile/torture/range-lang-item1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Frange-lang-item1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Frange-lang-item1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Frange-lang-item1.rs?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -0,0 +1,32 @@\n+// { dg-additional-options \"-w\" }\n+#[lang = \"RangeFull\"]\n+pub struct RangeFull;\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"RangeFrom\"]\n+pub struct RangeFrom<Idx> {\n+    pub start: Idx,\n+}\n+\n+#[lang = \"RangeTo\"]\n+pub struct RangeTo<Idx> {\n+    pub end: Idx,\n+}\n+\n+#[lang = \"RangeInclusive\"]\n+pub struct RangeInclusive<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+fn test() {\n+    let a = 1..2; // range\n+    let b = 1..; // range from\n+    let c = ..3; // range to\n+    let d = 0..=2; // range inclusive\n+}"}, {"sha": "c7e746bf4499358aaa7012ff4debae5dcdc9a68f", "filename": "gcc/testsuite/rust/compile/usize1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fusize1.rs?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     let a = [1, 2, 3];\n     let b: u32 = 1;\n     let c = a[b]; // { dg-error \"expected .usize. got .u32.\" }\n+                  // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-1 }\n }"}, {"sha": "4682978bdd0f83702276443eab5ba022e6a06928", "filename": "gcc/testsuite/rust/execute/torture/index1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Findex1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Findex1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Findex1.rs?ref=d3a4cf93b73fb32ab8d18541cc4fa5ff7b74c8e8", "patch": "@@ -0,0 +1,28 @@\n+// { dg-additional-options \"-w\" }\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+struct Foo(i32, i32);\n+impl Index<isize> for Foo {\n+    type Output = i32;\n+\n+    fn index(&self, index: isize) -> &i32 {\n+        if index == 0 {\n+            &self.0\n+        } else {\n+            &self.1\n+        }\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = Foo(1, 2);\n+    let b = a[0];\n+    let c = a[1];\n+\n+    c - b - 1\n+}"}]}