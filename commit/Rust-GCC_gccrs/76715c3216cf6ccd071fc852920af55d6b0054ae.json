{"sha": "76715c3216cf6ccd071fc852920af55d6b0054ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY3MTVjMzIxNmNmNmNjZDA3MWZjODUyOTIwYWY1NWQ2YjAwNTRhZQ==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2019-06-27T14:45:36Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2019-06-27T14:45:36Z"}, "message": "builtins.c (get_memory_rtx): Fix comment.\n\n2019-06-27  Aaron Sawdey <acsawdey@linux.ibm.com>\n\n\t* builtins.c (get_memory_rtx): Fix comment.\n\t* optabs.def (movmem_optab): Change to cpymem_optab.\n\t* expr.c (emit_block_move_via_cpymem): Change movmem to cpymem.\n\t(emit_block_move_hints): Change movmem to cpymem.\n\t* defaults.h: Change movmem to cpymem.\n\t* targhooks.c (get_move_ratio): Change movmem to cpymem.\n\t(default_use_by_pieces_infrastructure_p): Ditto.\n\t* config/aarch64/aarch64-protos.h: Change movmem to cpymem.\n\t* config/aarch64/aarch64.c (aarch64_expand_movmem): Change movmem\n\tto cpymem.\n\t* config/aarch64/aarch64.h: Change movmem to cpymem.\n\t* config/aarch64/aarch64.md (movmemdi): Change name to cpymemdi.\n\t* config/alpha/alpha.h: Change movmem to cpymem in comment.\n\t* config/alpha/alpha.md (movmemqi, movmemdi, *movmemdi_1): Change\n\tmovmem to cpymem.\n\t* config/arc/arc-protos.h: Change movmem to cpymem.\n\t* config/arc/arc.c (arc_expand_movmem): Change movmem to cpymem.\n\t* config/arc/arc.h: Change movmem to cpymem in comment.\n\t* config/arc/arc.md (movmemsi): Change movmem to cpymem.\n\t* config/arm/arm-protos.h: Change movmem to cpymem in names.\n\t* config/arm/arm.c (arm_movmemqi_unaligned, arm_gen_movmemqi, \n\tgen_movmem_ldrd_strd, thumb_expand_movmemqi) Change movmem to cpymem.\n\t* config/arm/arm.md (movmemqi): Change movmem to cpymem.\n\t* config/arm/thumb1.md (movmem12b, movmem8b): Change movmem to cpymem.\n\t* config/avr/avr-protos.h: Change movmem to cpymem.\n\t* config/avr/avr.c (avr_adjust_insn_length, avr_emit_movmemhi,\n\tavr_out_movmem): Change movmem to cpymem.\n\t* config/avr/avr.md (movmemhi, movmem_<mode>, movmemx_<mode>):\n\tChange movmem to cpymem.\n\t* config/bfin/bfin-protos.h: Change movmem to cpymem.\n\t* config/bfin/bfin.c (single_move_for_movmem, bfin_expand_movmem):\n\tChange movmem to cpymem.\n\t* config/bfin/bfin.h: Change movmem to cpymem in comment.\n\t* config/bfin/bfin.md (movmemsi): Change name to cpymemsi.\n\t* config/c6x/c6x-protos.h: Change movmem to cpymem.\n\t* config/c6x/c6x.c (c6x_expand_movmem): Change movmem to cpymem.\n\t* config/c6x/c6x.md (movmemsi): Change name to cpymemsi.\n\t* config/frv/frv.md (movmemsi): Change name to cpymemsi.\n\t* config/ft32/ft32.md (movmemsi): Change name to cpymemsi.\n\t* config/h8300/h8300.md (movmemsi): Change name to cpymemsi.\n\t* config/i386/i386-expand.c (expand_set_or_movmem_via_loop,\n\texpand_set_or_movmem_via_rep, expand_movmem_epilogue,\n\texpand_setmem_epilogue_via_loop, expand_set_or_cpymem_prologue,\n\texpand_small_cpymem_or_setmem,\n\texpand_set_or_cpymem_prologue_epilogue_by_misaligned_moves,\n\texpand_set_or_cpymem_constant_prologue, \n\tix86_expand_set_or_cpymem): Change movmem to cpymem.\n\t* config/i386/i386-protos.h: Change movmem to cpymem.\n\t* config/i386/i386.h: Change movmem to cpymem in comment.\n\t* config/i386/i386.md (movmem<mode>): Change name to cpymem.\n\t(setmem<mode>): Change expansion function name.\n\t* config/lm32/lm32.md (movmemsi): Change name to cpymemsi.\n\t* config/m32c/blkmov.md (movmemhi, movmemhi_bhi_op, movmemhi_bpsi_op,\n\tmovmemhi_whi_op, movmemhi_wpsi_op): Change movmem to cpymem.\n\t* config/m32c/m32c-protos.h: Change movmem to cpymem.\n\t* config/m32c/m32c.c (m32c_expand_movmemhi): Change movmem to cpymem.\n\t* config/m32r/m32r.c (m32r_expand_block_move): Change movmem to cpymem.\n\t* config/m32r/m32r.md (movmemsi, movmemsi_internal): Change movmem\n\tto cpymem.\n\t* config/mcore/mcore.md (movmemsi): Change name to cpymemsi.\n\t* config/microblaze/microblaze.c: Change movmem to cpymem in comment.\n\t* config/microblaze/microblaze.md (movmemsi): Change name to cpymemsi.\n\t* config/mips/mips.c (mips_use_by_pieces_infrastructure_p):\n\tChange movmem to cpymem.\n\t* config/mips/mips.h: Change movmem to cpymem.\n\t* config/mips/mips.md (movmemsi): Change name to cpymemsi.\n\t* config/nds32/nds32-memory-manipulation.c\n\t(nds32_expand_movmemsi_loop_unknown_size,\n\tnds32_expand_movmemsi_loop_known_size, nds32_expand_movmemsi_loop,\n\tnds32_expand_movmemsi_unroll,\n\tnds32_expand_movmemsi): Change movmem to cpymem.\n\t* config/nds32/nds32-multiple.md (movmemsi): Change name to cpymemsi.\n\t* config/nds32/nds32-protos.h: Change movmem to cpymem.\n\t* config/pa/pa.c (compute_movmem_length): Change movmem to cpymem.\n\t(pa_adjust_insn_length): Change call to compute_movmem_length.\n\t* config/pa/pa.md (movmemsi, movmemsi_prereload, movmemsi_postreload,\n\tmovmemdi, movmemdi_prereload, \n\tmovmemdi_postreload): Change movmem to cpymem.\n\t* config/pdp11/pdp11.md (movmemhi, movmemhi1, \n\tmovmemhi_nocc, UNSPEC_MOVMEM): Change movmem to cpymem.\n\t* config/riscv/riscv.c: Change movmem to cpymem in comment.\n\t* config/riscv/riscv.h: Change movmem to cpymem.\n\t* config/riscv/riscv.md: (movmemsi) Change name to cpymemsi.\n\t* config/rs6000/rs6000.md: (movmemsi) Change name to cpymemsi.\n\t* config/rx/rx.md: (UNSPEC_MOVMEM, movmemsi, rx_movmem): Change\n\tmovmem to cpymem.\n\t* config/s390/s390-protos.h: Change movmem to cpymem.\n\t* config/s390/s390.c (s390_expand_movmem, s390_expand_setmem,\n\ts390_expand_insv): Change movmem to cpymem.\n\t* config/s390/s390.md (movmem<mode>, movmem_short, *movmem_short,\n\tmovmem_long, *movmem_long, *movmem_long_31z): Change movmem to cpymem.\n\t* config/sh/sh.md (movmemsi): Change name to cpymemsi.\n\t* config/sparc/sparc.h: Change movmem to cpymem in comment.\n\t* config/vax/vax-protos.h (vax_output_movmemsi): Remove prototype\n\tfor nonexistent function.\n\t* config/vax/vax.h: Change movmem to cpymem in comment.\n\t* config/vax/vax.md (movmemhi, movmemhi1): Change movmem to cpymem.\n\t* config/visium/visium.h: Change movmem to cpymem in comment.\n\t* config/visium/visium.md (movmemsi): Change name to cpymemsi.\n\t* config/xtensa/xtensa.md (movmemsi): Change name to cpymemsi.\n\t* doc/md.texi: Change movmem to cpymem and update description to match.\n\t* doc/rtl.texi: Change movmem to cpymem.\n\t* target.def (use_by_pieces_infrastructure_p): Change movmem to cpymem.\n        * doc/tm.texi: Regenerate.\n\nFrom-SVN: r272755", "tree": {"sha": "07532694ce79b4f7ddbb3471aed38687fdefefb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07532694ce79b4f7ddbb3471aed38687fdefefb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76715c3216cf6ccd071fc852920af55d6b0054ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76715c3216cf6ccd071fc852920af55d6b0054ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76715c3216cf6ccd071fc852920af55d6b0054ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76715c3216cf6ccd071fc852920af55d6b0054ae/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00e72aa4627bc8cbab70ad0a48efa221a7a707c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e72aa4627bc8cbab70ad0a48efa221a7a707c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00e72aa4627bc8cbab70ad0a48efa221a7a707c8"}], "stats": {"total": 596, "additions": 352, "deletions": 244}, "files": [{"sha": "b548ac3d6ca565eac96e2aa10ea1f038cbab4e98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1,3 +1,110 @@\n+2019-06-27  Aaron Sawdey <acsawdey@linux.ibm.com>\n+\n+\t* builtins.c (get_memory_rtx): Fix comment.\n+\t* optabs.def (movmem_optab): Change to cpymem_optab.\n+\t* expr.c (emit_block_move_via_cpymem): Change movmem to cpymem.\n+\t(emit_block_move_hints): Change movmem to cpymem.\n+\t* defaults.h: Change movmem to cpymem.\n+\t* targhooks.c (get_move_ratio): Change movmem to cpymem.\n+\t(default_use_by_pieces_infrastructure_p): Ditto.\n+\t* config/aarch64/aarch64-protos.h: Change movmem to cpymem.\n+\t* config/aarch64/aarch64.c (aarch64_expand_movmem): Change movmem\n+\tto cpymem.\n+\t* config/aarch64/aarch64.h: Change movmem to cpymem.\n+\t* config/aarch64/aarch64.md (movmemdi): Change name to cpymemdi.\n+\t* config/alpha/alpha.h: Change movmem to cpymem in comment.\n+\t* config/alpha/alpha.md (movmemqi, movmemdi, *movmemdi_1): Change\n+\tmovmem to cpymem.\n+\t* config/arc/arc-protos.h: Change movmem to cpymem.\n+\t* config/arc/arc.c (arc_expand_movmem): Change movmem to cpymem.\n+\t* config/arc/arc.h: Change movmem to cpymem in comment.\n+\t* config/arc/arc.md (movmemsi): Change movmem to cpymem.\n+\t* config/arm/arm-protos.h: Change movmem to cpymem in names.\n+\t* config/arm/arm.c (arm_movmemqi_unaligned, arm_gen_movmemqi, \n+\tgen_movmem_ldrd_strd, thumb_expand_movmemqi) Change movmem to cpymem.\n+\t* config/arm/arm.md (movmemqi): Change movmem to cpymem.\n+\t* config/arm/thumb1.md (movmem12b, movmem8b): Change movmem to cpymem.\n+\t* config/avr/avr-protos.h: Change movmem to cpymem.\n+\t* config/avr/avr.c (avr_adjust_insn_length, avr_emit_movmemhi,\n+\tavr_out_movmem): Change movmem to cpymem.\n+\t* config/avr/avr.md (movmemhi, movmem_<mode>, movmemx_<mode>):\n+\tChange movmem to cpymem.\n+\t* config/bfin/bfin-protos.h: Change movmem to cpymem.\n+\t* config/bfin/bfin.c (single_move_for_movmem, bfin_expand_movmem):\n+\tChange movmem to cpymem.\n+\t* config/bfin/bfin.h: Change movmem to cpymem in comment.\n+\t* config/bfin/bfin.md (movmemsi): Change name to cpymemsi.\n+\t* config/c6x/c6x-protos.h: Change movmem to cpymem.\n+\t* config/c6x/c6x.c (c6x_expand_movmem): Change movmem to cpymem.\n+\t* config/c6x/c6x.md (movmemsi): Change name to cpymemsi.\n+\t* config/frv/frv.md (movmemsi): Change name to cpymemsi.\n+\t* config/ft32/ft32.md (movmemsi): Change name to cpymemsi.\n+\t* config/h8300/h8300.md (movmemsi): Change name to cpymemsi.\n+\t* config/i386/i386-expand.c (expand_set_or_movmem_via_loop,\n+\texpand_set_or_movmem_via_rep, expand_movmem_epilogue,\n+\texpand_setmem_epilogue_via_loop, expand_set_or_cpymem_prologue,\n+\texpand_small_cpymem_or_setmem,\n+\texpand_set_or_cpymem_prologue_epilogue_by_misaligned_moves,\n+\texpand_set_or_cpymem_constant_prologue, \n+\tix86_expand_set_or_cpymem): Change movmem to cpymem.\n+\t* config/i386/i386-protos.h: Change movmem to cpymem.\n+\t* config/i386/i386.h: Change movmem to cpymem in comment.\n+\t* config/i386/i386.md (movmem<mode>): Change name to cpymem.\n+\t(setmem<mode>): Change expansion function name.\n+\t* config/lm32/lm32.md (movmemsi): Change name to cpymemsi.\n+\t* config/m32c/blkmov.md (movmemhi, movmemhi_bhi_op, movmemhi_bpsi_op,\n+\tmovmemhi_whi_op, movmemhi_wpsi_op): Change movmem to cpymem.\n+\t* config/m32c/m32c-protos.h: Change movmem to cpymem.\n+\t* config/m32c/m32c.c (m32c_expand_movmemhi): Change movmem to cpymem.\n+\t* config/m32r/m32r.c (m32r_expand_block_move): Change movmem to cpymem.\n+\t* config/m32r/m32r.md (movmemsi, movmemsi_internal): Change movmem\n+\tto cpymem.\n+\t* config/mcore/mcore.md (movmemsi): Change name to cpymemsi.\n+\t* config/microblaze/microblaze.c: Change movmem to cpymem in comment.\n+\t* config/microblaze/microblaze.md (movmemsi): Change name to cpymemsi.\n+\t* config/mips/mips.c (mips_use_by_pieces_infrastructure_p):\n+\tChange movmem to cpymem.\n+\t* config/mips/mips.h: Change movmem to cpymem.\n+\t* config/mips/mips.md (movmemsi): Change name to cpymemsi.\n+\t* config/nds32/nds32-memory-manipulation.c\n+\t(nds32_expand_movmemsi_loop_unknown_size,\n+\tnds32_expand_movmemsi_loop_known_size, nds32_expand_movmemsi_loop,\n+\tnds32_expand_movmemsi_unroll,\n+\tnds32_expand_movmemsi): Change movmem to cpymem.\n+\t* config/nds32/nds32-multiple.md (movmemsi): Change name to cpymemsi.\n+\t* config/nds32/nds32-protos.h: Change movmem to cpymem.\n+\t* config/pa/pa.c (compute_movmem_length): Change movmem to cpymem.\n+\t(pa_adjust_insn_length): Change call to compute_movmem_length.\n+\t* config/pa/pa.md (movmemsi, movmemsi_prereload, movmemsi_postreload,\n+\tmovmemdi, movmemdi_prereload, \n+\tmovmemdi_postreload): Change movmem to cpymem.\n+\t* config/pdp11/pdp11.md (movmemhi, movmemhi1, \n+\tmovmemhi_nocc, UNSPEC_MOVMEM): Change movmem to cpymem.\n+\t* config/riscv/riscv.c: Change movmem to cpymem in comment.\n+\t* config/riscv/riscv.h: Change movmem to cpymem.\n+\t* config/riscv/riscv.md: (movmemsi) Change name to cpymemsi.\n+\t* config/rs6000/rs6000.md: (movmemsi) Change name to cpymemsi.\n+\t* config/rx/rx.md: (UNSPEC_MOVMEM, movmemsi, rx_movmem): Change\n+\tmovmem to cpymem.\n+\t* config/s390/s390-protos.h: Change movmem to cpymem.\n+\t* config/s390/s390.c (s390_expand_movmem, s390_expand_setmem,\n+\ts390_expand_insv): Change movmem to cpymem.\n+\t* config/s390/s390.md (movmem<mode>, movmem_short, *movmem_short,\n+\tmovmem_long, *movmem_long, *movmem_long_31z): Change movmem to cpymem.\n+\t* config/sh/sh.md (movmemsi): Change name to cpymemsi.\n+\t* config/sparc/sparc.h: Change movmem to cpymem in comment.\n+\t* config/vax/vax-protos.h (vax_output_movmemsi): Remove prototype\n+\tfor nonexistent function.\n+\t* config/vax/vax.h: Change movmem to cpymem in comment.\n+\t* config/vax/vax.md (movmemhi, movmemhi1): Change movmem to cpymem.\n+\t* config/visium/visium.h: Change movmem to cpymem in comment.\n+\t* config/visium/visium.md (movmemsi): Change name to cpymemsi.\n+\t* config/xtensa/xtensa.md (movmemsi): Change name to cpymemsi.\n+\t* doc/md.texi: Change movmem to cpymem and update description to match.\n+\t* doc/rtl.texi: Change movmem to cpymem.\n+\t* target.def (use_by_pieces_infrastructure_p): Change movmem to cpymem.\n+        * doc/tm.texi: Regenerate.\n+\n 2019-06-27  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_option_override_internal): Enable"}, {"sha": "2b8914f13ee1ab34828439c0ad23a228ecd19903", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1416,7 +1416,7 @@ expand_builtin_prefetch (tree exp)\n }\n \n /* Get a MEM rtx for expression EXP which is the address of an operand\n-   to be used in a string instruction (cmpstrsi, movmemsi, ..).  LEN is\n+   to be used in a string instruction (cmpstrsi, cpymemsi, ..).  LEN is\n    the maximum length of the block of memory that might be accessed or\n    NULL if unknown.  */\n "}, {"sha": "e2f4cc19e68a79368f939cb8a83cf1f6d0412264", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -424,12 +424,12 @@ bool aarch64_constant_address_p (rtx);\n bool aarch64_emit_approx_div (rtx, rtx, rtx);\n bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n void aarch64_expand_call (rtx, rtx, bool);\n-bool aarch64_expand_movmem (rtx *);\n+bool aarch64_expand_cpymem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_float_const_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n bool aarch64_fusion_enabled_p (enum aarch64_fusion_pairs);\n-bool aarch64_gen_movmemqi (rtx *);\n+bool aarch64_gen_cpymemqi (rtx *);\n bool aarch64_gimple_fold_builtin (gimple_stmt_iterator *);\n bool aarch64_is_extend_from_extract (scalar_int_mode, rtx, rtx);\n bool aarch64_is_long_call_p (rtx);"}, {"sha": "5a923ca006b332bd4278388be9b729f2c9c29dee", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -17386,11 +17386,11 @@ aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,\n   *dst = aarch64_progress_pointer (*dst);\n }\n \n-/* Expand movmem, as if from a __builtin_memcpy.  Return true if\n+/* Expand cpymem, as if from a __builtin_memcpy.  Return true if\n    we succeed, otherwise return false.  */\n \n bool\n-aarch64_expand_movmem (rtx *operands)\n+aarch64_expand_cpymem (rtx *operands)\n {\n   int n, mode_bits;\n   rtx dst = operands[0];"}, {"sha": "92e38a87a768fe54d3f02beecb919d97223474d9", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -855,7 +855,7 @@ typedef struct\n /* MOVE_RATIO dictates when we will use the move_by_pieces infrastructure.\n    move_by_pieces will continually copy the largest safe chunks.  So a\n    7-byte copy is a 4-byte + 2-byte + byte copy.  This proves inefficient\n-   for both size and speed of copy, so we will instead use the \"movmem\"\n+   for both size and speed of copy, so we will instead use the \"cpymem\"\n    standard name to implement the copy.  This logic does not apply when\n    targeting -mstrict-align, so keep a sensible default in that case.  */\n #define MOVE_RATIO(speed) \\"}, {"sha": "7026b3a3b92be94cb916dfcc1d45930dff93177b", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1375,17 +1375,17 @@\n \n ;; 0 is dst\n ;; 1 is src\n-;; 2 is size of move in bytes\n+;; 2 is size of copy in bytes\n ;; 3 is alignment\n \n-(define_expand \"movmemdi\"\n+(define_expand \"cpymemdi\"\n   [(match_operand:BLK 0 \"memory_operand\")\n    (match_operand:BLK 1 \"memory_operand\")\n    (match_operand:DI 2 \"immediate_operand\")\n    (match_operand:DI 3 \"immediate_operand\")]\n    \"!STRICT_ALIGNMENT\"\n {\n-  if (aarch64_expand_movmem (operands))\n+  if (aarch64_expand_cpymem (operands))\n     DONE;\n   FAIL;\n }"}, {"sha": "68eafe194b56e5996e916455d5841914d383283d", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -759,7 +759,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define MOVE_MAX 8\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.\n+   move-instruction pairs, we will do a cpymem or libcall instead.\n \n    Without byte/word accesses, we want no more than four instructions;\n    with, several single byte accesses are better.  */"}, {"sha": "b195eb9c698daa7baef0dc963d7f2d70f8066f2f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -4673,7 +4673,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemqi\"\n+(define_expand \"cpymemqi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\")\n \t\t   (match_operand:BLK 1 \"memory_operand\"))\n \t      (use (match_operand:DI 2 \"immediate_operand\"))\n@@ -4686,7 +4686,7 @@\n     FAIL;\n })\n \n-(define_expand \"movmemdi\"\n+(define_expand \"cpymemdi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\")\n \t\t   (match_operand:BLK 1 \"memory_operand\"))\n \t      (use (match_operand:DI 2 \"immediate_operand\"))\n@@ -4703,7 +4703,7 @@\n   \"TARGET_ABI_OPEN_VMS\"\n   \"operands[4] = gen_rtx_SYMBOL_REF (Pmode, \\\"OTS$MOVE\\\");\")\n \n-(define_insn \"*movmemdi_1\"\n+(define_insn \"*cpymemdi_1\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=m,m\")\n \t(match_operand:BLK 1 \"memory_operand\" \"m,m\"))\n    (use (match_operand:DI 2 \"nonmemory_operand\" \"r,i\"))"}, {"sha": "74e52475066df29b67b3bc5e0a4987e01808008b", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -35,7 +35,7 @@ extern void arc_final_prescan_insn (rtx_insn *, rtx *, int);\n extern const char *arc_output_libcall (const char *);\n extern int arc_output_addsi (rtx *operands, bool, bool);\n extern int arc_output_commutative_cond_exec (rtx *operands, bool);\n-extern bool arc_expand_movmem (rtx *operands);\n+extern bool arc_expand_cpymem (rtx *operands);\n extern bool prepare_move_operands (rtx *operands, machine_mode mode);\n extern void emit_shift (enum rtx_code, rtx, rtx, rtx);\n extern void arc_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);"}, {"sha": "ff82c9f71365b1981c2cf6ada729288b0d9163f5", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -8778,7 +8778,7 @@ arc_output_commutative_cond_exec (rtx *operands, bool output_p)\n   return 8;\n }\n \n-/* Helper function of arc_expand_movmem.  ADDR points to a chunk of memory.\n+/* Helper function of arc_expand_cpymem.  ADDR points to a chunk of memory.\n    Emit code and return an potentially modified address such that offsets\n    up to SIZE are can be added to yield a legitimate address.\n    if REUSE is set, ADDR is a register that may be modified.  */\n@@ -8812,7 +8812,7 @@ force_offsettable (rtx addr, HOST_WIDE_INT size, bool reuse)\n    offset ranges.  Return true on success.  */\n \n bool\n-arc_expand_movmem (rtx *operands)\n+arc_expand_cpymem (rtx *operands)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -10322,7 +10322,7 @@ arc_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n \t\t\t\t    enum by_pieces_operation op,\n \t\t\t\t    bool speed_p)\n {\n-  /* Let the movmem expander handle small block moves.  */\n+  /* Let the cpymem expander handle small block moves.  */\n   if (op == MOVE_BY_PIECES)\n     return false;\n "}, {"sha": "4a9dd07f558fc444372cf217ea4c8620c0acf7b1", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1423,7 +1423,7 @@ do { \\\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n-/* Undo the effects of the movmem pattern presence on STORE_BY_PIECES_P .  */\n+/* Undo the effects of the cpymem pattern presence on STORE_BY_PIECES_P .  */\n #define MOVE_RATIO(SPEED) ((SPEED) ? 15 : 3)\n \n /* Define this to be nonzero if shift instructions ignore all but the"}, {"sha": "b793e5b07a5b7c48c9343d3398ffd7042317831c", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -5126,13 +5126,13 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n    (set_attr \"type\" \"loop_end\")\n    (set_attr \"length\" \"4,20\")])\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(match_operand:BLK 0 \"\" \"\")\n    (match_operand:BLK 1 \"\" \"\")\n    (match_operand:SI 2 \"nonmemory_operand\" \"\")\n    (match_operand 3 \"immediate_operand\" \"\")]\n   \"\"\n-  \"if (arc_expand_movmem (operands)) DONE; else FAIL;\")\n+  \"if (arc_expand_cpymem (operands)) DONE; else FAIL;\")\n \n ;; Close http://gcc.gnu.org/bugzilla/show_bug.cgi?id=35803 if this works\n ;; to the point that we can generate cmove instructions."}, {"sha": "bf2bf1c3b050365449b422976d7c0b39245f1490", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -126,8 +126,8 @@ extern bool offset_ok_for_ldrd_strd (HOST_WIDE_INT);\n extern bool operands_ok_ldrd_strd (rtx, rtx, rtx, HOST_WIDE_INT, bool, bool);\n extern bool gen_operands_ldrd_strd (rtx *, bool, bool, bool);\n extern bool valid_operands_ldrd_strd (rtx *, bool);\n-extern int arm_gen_movmemqi (rtx *);\n-extern bool gen_movmem_ldrd_strd (rtx *);\n+extern int arm_gen_cpymemqi (rtx *);\n+extern bool gen_cpymem_ldrd_strd (rtx *);\n extern machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n extern machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n \t\t\t\t\t\t       HOST_WIDE_INT);\n@@ -203,7 +203,7 @@ extern void thumb2_final_prescan_insn (rtx_insn *);\n extern const char *thumb_load_double_from_address (rtx *);\n extern const char *thumb_output_move_mem_multiple (int, rtx *);\n extern const char *thumb_call_via_reg (rtx);\n-extern void thumb_expand_movmemqi (rtx *);\n+extern void thumb_expand_cpymemqi (rtx *);\n extern rtx arm_return_addr (int, rtx);\n extern void thumb_reload_out_hi (rtx *);\n extern void thumb_set_return_address (rtx, rtx);"}, {"sha": "820502ac8a0a23274d5ea48ab19794959c811d90", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -14385,7 +14385,7 @@ arm_block_move_unaligned_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n    core type, optimize_size setting, etc.  */\n \n static int\n-arm_movmemqi_unaligned (rtx *operands)\n+arm_cpymemqi_unaligned (rtx *operands)\n {\n   HOST_WIDE_INT length = INTVAL (operands[2]);\n   \n@@ -14422,7 +14422,7 @@ arm_movmemqi_unaligned (rtx *operands)\n }\n \n int\n-arm_gen_movmemqi (rtx *operands)\n+arm_gen_cpymemqi (rtx *operands)\n {\n   HOST_WIDE_INT in_words_to_go, out_words_to_go, last_bytes;\n   HOST_WIDE_INT srcoffset, dstoffset;\n@@ -14436,7 +14436,7 @@ arm_gen_movmemqi (rtx *operands)\n     return 0;\n \n   if (unaligned_access && (INTVAL (operands[3]) & 3) != 0)\n-    return arm_movmemqi_unaligned (operands);\n+    return arm_cpymemqi_unaligned (operands);\n \n   if (INTVAL (operands[3]) & 3)\n     return 0;\n@@ -14570,7 +14570,7 @@ arm_gen_movmemqi (rtx *operands)\n   return 1;\n }\n \n-/* Helper for gen_movmem_ldrd_strd. Increase the address of memory rtx\n+/* Helper for gen_cpymem_ldrd_strd. Increase the address of memory rtx\n by mode size.  */\n inline static rtx\n next_consecutive_mem (rtx mem)\n@@ -14585,7 +14585,7 @@ next_consecutive_mem (rtx mem)\n /* Copy using LDRD/STRD instructions whenever possible.\n    Returns true upon success. */\n bool\n-gen_movmem_ldrd_strd (rtx *operands)\n+gen_cpymem_ldrd_strd (rtx *operands)\n {\n   unsigned HOST_WIDE_INT len;\n   HOST_WIDE_INT align;\n@@ -14629,7 +14629,7 @@ gen_movmem_ldrd_strd (rtx *operands)\n \n   /* If we cannot generate any LDRD/STRD, try to generate LDM/STM.  */\n   if (!(dst_aligned || src_aligned))\n-    return arm_gen_movmemqi (operands);\n+    return arm_gen_cpymemqi (operands);\n \n   /* If the either src or dst is unaligned we'll be accessing it as pairs\n      of unaligned SImode accesses.  Otherwise we can generate DImode\n@@ -26395,7 +26395,7 @@ thumb_call_via_reg (rtx reg)\n \n /* Routines for generating rtl.  */\n void\n-thumb_expand_movmemqi (rtx *operands)\n+thumb_expand_cpymemqi (rtx *operands)\n {\n   rtx out = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n   rtx in  = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n@@ -26404,13 +26404,13 @@ thumb_expand_movmemqi (rtx *operands)\n \n   while (len >= 12)\n     {\n-      emit_insn (gen_movmem12b (out, in, out, in));\n+      emit_insn (gen_cpymem12b (out, in, out, in));\n       len -= 12;\n     }\n \n   if (len >= 8)\n     {\n-      emit_insn (gen_movmem8b (out, in, out, in));\n+      emit_insn (gen_cpymem8b (out, in, out, in));\n       len -= 8;\n     }\n "}, {"sha": "a7fa4109df2bcc574f48b82dc96d8b9286415e40", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -7250,7 +7250,7 @@\n ;; We could let this apply for blocks of less than this, but it clobbers so\n ;; many registers that there is then probably a better way.\n \n-(define_expand \"movmemqi\"\n+(define_expand \"cpymemqi\"\n   [(match_operand:BLK 0 \"general_operand\" \"\")\n    (match_operand:BLK 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"const_int_operand\" \"\")\n@@ -7262,12 +7262,12 @@\n       if (TARGET_LDRD && current_tune->prefer_ldrd_strd\n           && !optimize_function_for_size_p (cfun))\n         {\n-          if (gen_movmem_ldrd_strd (operands))\n+          if (gen_cpymem_ldrd_strd (operands))\n             DONE;\n           FAIL;\n         }\n \n-      if (arm_gen_movmemqi (operands))\n+      if (arm_gen_cpymemqi (operands))\n         DONE;\n       FAIL;\n     }\n@@ -7277,7 +7277,7 @@\n           || INTVAL (operands[2]) > 48)\n         FAIL;\n \n-      thumb_expand_movmemqi (operands);\n+      thumb_expand_cpymemqi (operands);\n       DONE;\n     }\n   \""}, {"sha": "b199349b19c4f489654bad99717b224b00b65a06", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -928,7 +928,7 @@\n \n ;; Thumb block-move insns\n \n-(define_insn \"movmem12b\"\n+(define_insn \"cpymem12b\"\n   [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n \t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n    (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n@@ -950,7 +950,7 @@\n    (set_attr \"type\" \"store_12\")]\n )\n \n-(define_insn \"movmem8b\"\n+(define_insn \"cpymem8b\"\n   [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n \t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n    (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))"}, {"sha": "31fe3a66d9e6b688bc2f3cca22da4b7ad5e25f67", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -82,7 +82,7 @@ extern rtx avr_to_int_mode (rtx);\n \n extern void avr_expand_prologue (void);\n extern void avr_expand_epilogue (bool);\n-extern bool avr_emit_movmemhi (rtx*);\n+extern bool avr_emit_cpymemhi (rtx*);\n extern int avr_epilogue_uses (int regno);\n \n extern void avr_output_addr_vec (rtx_insn*, rtx);\n@@ -92,7 +92,7 @@ extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL, bool =true);\n extern const char* avr_out_round (rtx_insn *, rtx*, int* =NULL);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern const char* avr_out_xload (rtx_insn *, rtx*, int*);\n-extern const char* avr_out_movmem (rtx_insn *, rtx*, int*);\n+extern const char* avr_out_cpymem (rtx_insn *, rtx*, int*);\n extern const char* avr_out_insert_bits (rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n extern bool avr_has_nibble_0xf (rtx);"}, {"sha": "b97faafdc3be936bc84f4e8bfe2a36e232f814ad", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -9404,7 +9404,7 @@ avr_adjust_insn_length (rtx_insn *insn, int len)\n     case ADJUST_LEN_MOV16: output_movhi (insn, op, &len); break;\n     case ADJUST_LEN_MOV24: avr_out_movpsi (insn, op, &len); break;\n     case ADJUST_LEN_MOV32: output_movsisf (insn, op, &len); break;\n-    case ADJUST_LEN_MOVMEM: avr_out_movmem (insn, op, &len); break;\n+    case ADJUST_LEN_CPYMEM: avr_out_cpymem (insn, op, &len); break;\n     case ADJUST_LEN_XLOAD: avr_out_xload (insn, op, &len); break;\n     case ADJUST_LEN_SEXT: avr_out_sign_extend (insn, op, &len); break;\n \n@@ -13321,7 +13321,7 @@ avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,\n }\n \n \n-/* Worker function for movmemhi expander.\n+/* Worker function for cpymemhi expander.\n    XOP[0]  Destination as MEM:BLK\n    XOP[1]  Source      \"     \"\n    XOP[2]  # Bytes to copy\n@@ -13330,7 +13330,7 @@ avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,\n    Return FALSE if the operand compination is not supported.  */\n \n bool\n-avr_emit_movmemhi (rtx *xop)\n+avr_emit_cpymemhi (rtx *xop)\n {\n   HOST_WIDE_INT count;\n   machine_mode loop_mode;\n@@ -13407,14 +13407,14 @@ avr_emit_movmemhi (rtx *xop)\n          Do the copy-loop inline.  */\n \n       rtx (*fun) (rtx, rtx, rtx)\n-        = QImode == loop_mode ? gen_movmem_qi : gen_movmem_hi;\n+        = QImode == loop_mode ? gen_cpymem_qi : gen_cpymem_hi;\n \n       insn = fun (xas, loop_reg, loop_reg);\n     }\n   else\n     {\n       rtx (*fun) (rtx, rtx)\n-        = QImode == loop_mode ? gen_movmemx_qi : gen_movmemx_hi;\n+        = QImode == loop_mode ? gen_cpymemx_qi : gen_cpymemx_hi;\n \n       emit_move_insn (gen_rtx_REG (QImode, 23), a_hi8);\n \n@@ -13428,15 +13428,15 @@ avr_emit_movmemhi (rtx *xop)\n }\n \n \n-/* Print assembler for movmem_qi, movmem_hi insns...\n+/* Print assembler for cpymem_qi, cpymem_hi insns...\n        $0     : Address Space\n        $1, $2 : Loop register\n        Z      : Source address\n        X      : Destination address\n */\n \n const char*\n-avr_out_movmem (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n+avr_out_cpymem (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n {\n   addr_space_t as = (addr_space_t) INTVAL (op[0]);\n   machine_mode loop_mode = GET_MODE (op[1]);"}, {"sha": "e85bf49632dfde1c63773e06e3a160b3b1544c6f", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -70,7 +70,7 @@\n \n (define_c_enum \"unspec\"\n   [UNSPEC_STRLEN\n-   UNSPEC_MOVMEM\n+   UNSPEC_CPYMEM\n    UNSPEC_INDEX_JMP\n    UNSPEC_FMUL\n    UNSPEC_FMULS\n@@ -158,7 +158,7 @@\n    tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n    ufract, sfract, round,\n-   xload, movmem,\n+   xload, cpymem,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n@@ -992,44 +992,44 @@\n ;;=========================================================================\n ;; move string (like memcpy)\n \n-(define_expand \"movmemhi\"\n+(define_expand \"cpymemhi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n                    (match_operand:BLK 1 \"memory_operand\" \"\"))\n               (use (match_operand:HI 2 \"const_int_operand\" \"\"))\n               (use (match_operand:HI 3 \"const_int_operand\" \"\"))])]\n   \"\"\n   {\n-    if (avr_emit_movmemhi (operands))\n+    if (avr_emit_cpymemhi (operands))\n       DONE;\n \n     FAIL;\n   })\n \n-(define_mode_attr MOVMEM_r_d [(QI \"r\")\n+(define_mode_attr CPYMEM_r_d [(QI \"r\")\n                               (HI \"wd\")])\n \n ;; $0     : Address Space\n ;; $1, $2 : Loop register\n ;; R30    : source address\n ;; R26    : destination address\n \n-;; \"movmem_qi\"\n-;; \"movmem_hi\"\n-(define_insn \"movmem_<mode>\"\n+;; \"cpymem_qi\"\n+;; \"cpymem_hi\"\n+(define_insn \"cpymem_<mode>\"\n   [(set (mem:BLK (reg:HI REG_X))\n         (mem:BLK (reg:HI REG_Z)))\n    (unspec [(match_operand:QI 0 \"const_int_operand\" \"n\")]\n-           UNSPEC_MOVMEM)\n-   (use (match_operand:QIHI 1 \"register_operand\" \"<MOVMEM_r_d>\"))\n+           UNSPEC_CPYMEM)\n+   (use (match_operand:QIHI 1 \"register_operand\" \"<CPYMEM_r_d>\"))\n    (clobber (reg:HI REG_X))\n    (clobber (reg:HI REG_Z))\n    (clobber (reg:QI LPM_REGNO))\n    (clobber (match_operand:QIHI 2 \"register_operand\" \"=1\"))]\n   \"\"\n   {\n-    return avr_out_movmem (insn, operands, NULL);\n+    return avr_out_cpymem (insn, operands, NULL);\n   }\n-  [(set_attr \"adjust_len\" \"movmem\")\n+  [(set_attr \"adjust_len\" \"cpymem\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -1039,14 +1039,14 @@\n ;; R23:Z : 24-bit source address\n ;; R26   : 16-bit destination address\n \n-;; \"movmemx_qi\"\n-;; \"movmemx_hi\"\n-(define_insn \"movmemx_<mode>\"\n+;; \"cpymemx_qi\"\n+;; \"cpymemx_hi\"\n+(define_insn \"cpymemx_<mode>\"\n   [(set (mem:BLK (reg:HI REG_X))\n         (mem:BLK (lo_sum:PSI (reg:QI 23)\n                              (reg:HI REG_Z))))\n    (unspec [(match_operand:QI 0 \"const_int_operand\" \"n\")]\n-           UNSPEC_MOVMEM)\n+           UNSPEC_CPYMEM)\n    (use (reg:QIHI 24))\n    (clobber (reg:HI REG_X))\n    (clobber (reg:HI REG_Z))"}, {"sha": "7d0f705e0691d55def8aacccab8fc0408d56d8bf", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -81,7 +81,7 @@ extern bool expand_move (rtx *, machine_mode);\n extern void bfin_expand_call (rtx, rtx, rtx, rtx, int);\n extern bool bfin_longcall_p (rtx, int);\n extern bool bfin_dsp_memref_p (rtx);\n-extern bool bfin_expand_movmem (rtx, rtx, rtx, rtx);\n+extern bool bfin_expand_cpymem (rtx, rtx, rtx, rtx);\n \n extern enum reg_class secondary_input_reload_class (enum reg_class,\n \t\t\t\t\t\t    machine_mode,"}, {"sha": "319d7e2a03538a7b07dc2f3a191bcb336c37ef49", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3208,7 +3208,7 @@ output_pop_multiple (rtx insn, rtx *operands)\n /* Adjust DST and SRC by OFFSET bytes, and generate one move in mode MODE.  */\n \n static void\n-single_move_for_movmem (rtx dst, rtx src, machine_mode mode, HOST_WIDE_INT offset)\n+single_move_for_cpymem (rtx dst, rtx src, machine_mode mode, HOST_WIDE_INT offset)\n {\n   rtx scratch = gen_reg_rtx (mode);\n   rtx srcmem, dstmem;\n@@ -3224,7 +3224,7 @@ single_move_for_movmem (rtx dst, rtx src, machine_mode mode, HOST_WIDE_INT offse\n    back on a different method.  */\n \n bool\n-bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n+bfin_expand_cpymem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n {\n   rtx srcreg, destreg, countreg;\n   HOST_WIDE_INT align = 0;\n@@ -3269,7 +3269,7 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t{\n \t  if ((count & ~3) == 4)\n \t    {\n-\t      single_move_for_movmem (dst, src, SImode, offset);\n+\t      single_move_for_cpymem (dst, src, SImode, offset);\n \t      offset = 4;\n \t    }\n \t  else if (count & ~3)\n@@ -3282,15 +3282,15 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t    }\n \t  if (count & 2)\n \t    {\n-\t      single_move_for_movmem (dst, src, HImode, offset);\n+\t      single_move_for_cpymem (dst, src, HImode, offset);\n \t      offset += 2;\n \t    }\n \t}\n       else\n \t{\n \t  if ((count & ~1) == 2)\n \t    {\n-\t      single_move_for_movmem (dst, src, HImode, offset);\n+\t      single_move_for_cpymem (dst, src, HImode, offset);\n \t      offset = 2;\n \t    }\n \t  else if (count & ~1)\n@@ -3304,7 +3304,7 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t}\n       if (count & 1)\n \t{\n-\t  single_move_for_movmem (dst, src, QImode, offset);\n+\t  single_move_for_cpymem (dst, src, QImode, offset);\n \t}\n       return true;\n     }"}, {"sha": "4aba596f68ebe51255d935ef3463e6c343ec9d9b", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -793,7 +793,7 @@ typedef struct {\n #define MOVE_MAX UNITS_PER_WORD\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.  */\n+   move-instruction pairs, we will do a cpymem or libcall instead.  */\n \n #define MOVE_RATIO(speed) 5\n "}, {"sha": "6ac208d04a57cf814feceec8908bc9112a295db1", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -2316,14 +2316,14 @@\n    (set_attr \"length\" \"16\")\n    (set_attr \"seq_insns\" \"multi\")])\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(match_operand:BLK 0 \"general_operand\" \"\")\n    (match_operand:BLK 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"const_int_operand\" \"\")\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n   \"\"\n {\n-  if (bfin_expand_movmem (operands[0], operands[1], operands[2], operands[3]))\n+  if (bfin_expand_cpymem (operands[0], operands[1], operands[2], operands[3]))\n     DONE;\n   FAIL;\n })"}, {"sha": "8c04c315a635d674bb1e89f057146093157f11be", "filename": "gcc/config/c6x/c6x-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -35,7 +35,7 @@ extern bool c6x_long_call_p (rtx);\n extern void c6x_expand_call (rtx, rtx, bool);\n extern rtx c6x_expand_compare (rtx, machine_mode);\n extern bool c6x_force_op_for_comparison_p (enum rtx_code, rtx);\n-extern bool c6x_expand_movmem (rtx, rtx, rtx, rtx, rtx, rtx);\n+extern bool c6x_expand_cpymem (rtx, rtx, rtx, rtx, rtx, rtx);\n \n extern rtx c6x_subword (rtx, bool);\n extern void split_di (rtx *, int, rtx *, rtx *);"}, {"sha": "93841e4abeffe02019f45841f583dea78ad99484", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1686,10 +1686,10 @@ c6x_valid_mask_p (HOST_WIDE_INT val)\n   return true;\n }\n \n-/* Expand a block move for a movmemM pattern.  */\n+/* Expand a block move for a cpymemM pattern.  */\n \n bool\n-c6x_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n+c6x_expand_cpymem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t\t   rtx expected_align_exp ATTRIBUTE_UNUSED,\n \t\t   rtx expected_size_exp ATTRIBUTE_UNUSED)\n {"}, {"sha": "f9bf9ba99abf2dffbe3567120de2adf7e16513fb", "filename": "gcc/config/c6x/c6x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fc6x%2Fc6x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -2844,7 +2844,7 @@\n ;; Block moves\n ;; -------------------------------------------------------------------------\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n    (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n    (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n@@ -2853,7 +2853,7 @@\n    (use (match_operand:SI 5 \"const_int_operand\" \"\"))]\n   \"\"\n {\n- if (c6x_expand_movmem (operands[0], operands[1], operands[2], operands[3],\n+ if (c6x_expand_cpymem (operands[0], operands[1], operands[2], operands[3],\n \t\t\toperands[4], operands[5]))\n    DONE;\n  else"}, {"sha": "6e8db59fdd9ff1214b88768f31f1499a18ba17bd", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1887,7 +1887,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n \t\t   (match_operand:BLK 1 \"\" \"\"))\n \t      (use (match_operand:SI 2 \"\" \"\"))"}, {"sha": "9e31f2ca7cbdbcc2bde9f54216dcd79d9fd54baa", "filename": "gcc/config/ft32/ft32.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fft32%2Fft32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fft32%2Fft32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -851,7 +851,7 @@\n \"stpcpy %b1,%b2 # %0 %b1 %b2\"\n )\n \n-(define_insn \"movmemsi\"\n+(define_insn \"cpymemsi\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=W,BW\")\n         (match_operand:BLK 1 \"memory_operand\" \"W,BW\"))\n         (use (match_operand:SI 2 \"ft32_imm_operand\" \"KA,KA\"))"}, {"sha": "42610fddb0946420bf59f12b8e2918ca11a10076", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -474,11 +474,11 @@\n    (set_attr \"length_table\" \"*,movl\")\n    (set_attr \"cc\" \"set_zn,set_znv\")])\n \n-;; Implement block moves using movmd.  Defining movmemsi allows the full\n+;; Implement block copies using movmd.  Defining cpymemsi allows the full\n ;; range of constant lengths (up to 0x40000 bytes when using movmd.l).\n ;; See h8sx_emit_movmd for details.\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n    (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n    (use (match_operand:SI 2 \"\" \"\"))"}, {"sha": "85d74a28636ebcbeea60e14f82bf6f61399b2409", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -5801,7 +5801,7 @@ counter_mode (rtx count_exp)\n \n \n static void\n-expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n+expand_set_or_cpymem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t       rtx destptr, rtx srcptr, rtx value,\n \t\t\t       rtx count, machine_mode mode, int unroll,\n \t\t\t       int expected_size, bool issetmem)\n@@ -5954,7 +5954,7 @@ scale_counter (rtx countreg, int scale)\n    Other arguments have same meaning as for previous function.  */\n \n static void\n-expand_set_or_movmem_via_rep (rtx destmem, rtx srcmem,\n+expand_set_or_cpymem_via_rep (rtx destmem, rtx srcmem,\n \t\t\t   rtx destptr, rtx srcptr, rtx value, rtx orig_value,\n \t\t\t   rtx count,\n \t\t\t   machine_mode mode, bool issetmem)\n@@ -6121,7 +6121,7 @@ ix86_expand_aligntest (rtx variable, int value, bool epilogue)\n /* Output code to copy at most count & (max_size - 1) bytes from SRC to DEST.  */\n \n static void\n-expand_movmem_epilogue (rtx destmem, rtx srcmem,\n+expand_cpymem_epilogue (rtx destmem, rtx srcmem,\n \t\t\trtx destptr, rtx srcptr, rtx count, int max_size)\n {\n   rtx src, dest;\n@@ -6146,7 +6146,7 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n     {\n       count = expand_simple_binop (GET_MODE (count), AND, count, GEN_INT (max_size - 1),\n \t\t\t\t    count, 1, OPTAB_DIRECT);\n-      expand_set_or_movmem_via_loop (destmem, srcmem, destptr, srcptr, NULL,\n+      expand_set_or_cpymem_via_loop (destmem, srcmem, destptr, srcptr, NULL,\n \t\t\t\t     count, QImode, 1, 4, false);\n       return;\n     }\n@@ -6295,7 +6295,7 @@ expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n {\n   count = expand_simple_binop (counter_mode (count), AND, count,\n \t\t\t       GEN_INT (max_size - 1), count, 1, OPTAB_DIRECT);\n-  expand_set_or_movmem_via_loop (destmem, NULL, destptr, NULL,\n+  expand_set_or_cpymem_via_loop (destmem, NULL, destptr, NULL,\n \t\t\t\t gen_lowpart (QImode, value), count, QImode,\n \t\t\t\t 1, max_size / 2, true);\n }\n@@ -6416,7 +6416,7 @@ ix86_adjust_counter (rtx countreg, HOST_WIDE_INT value)\n    Return value is updated DESTMEM.  */\n \n static rtx\n-expand_set_or_movmem_prologue (rtx destmem, rtx srcmem,\n+expand_set_or_cpymem_prologue (rtx destmem, rtx srcmem,\n \t\t\t\t  rtx destptr, rtx srcptr, rtx value,\n \t\t\t\t  rtx vec_value, rtx count, int align,\n \t\t\t\t  int desired_alignment, bool issetmem)\n@@ -6449,7 +6449,7 @@ expand_set_or_movmem_prologue (rtx destmem, rtx srcmem,\n    or setmem sequence that is valid for SIZE..2*SIZE-1 bytes\n    and jump to DONE_LABEL.  */\n static void\n-expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n+expand_small_cpymem_or_setmem (rtx destmem, rtx srcmem,\n \t\t\t       rtx destptr, rtx srcptr,\n \t\t\t       rtx value, rtx vec_value,\n \t\t\t       rtx count, int size,\n@@ -6575,7 +6575,7 @@ expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n    done_label:\n   */\n static void\n-expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx srcmem,\n+expand_set_or_cpymem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx srcmem,\n \t\t\t\t\t\t\t    rtx *destptr, rtx *srcptr,\n \t\t\t\t\t\t\t    machine_mode mode,\n \t\t\t\t\t\t\t    rtx value, rtx vec_value,\n@@ -6616,7 +6616,7 @@ expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx src\n \n       /* Handle sizes > 3.  */\n       for (;size2 > 2; size2 >>= 1)\n-\texpand_small_movmem_or_setmem (destmem, srcmem,\n+\texpand_small_cpymem_or_setmem (destmem, srcmem,\n \t\t\t\t       *destptr, *srcptr,\n \t\t\t\t       value, vec_value,\n \t\t\t\t       *count,\n@@ -6771,7 +6771,7 @@ expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx src\n    is returned, but also of SRC, which is passed as a pointer for that\n    reason.  */\n static rtx\n-expand_set_or_movmem_constant_prologue (rtx dst, rtx *srcp, rtx destreg,\n+expand_set_or_cpymem_constant_prologue (rtx dst, rtx *srcp, rtx destreg,\n \t\t\t\t\t   rtx srcreg, rtx value, rtx vec_value,\n \t\t\t\t\t   int desired_align, int align_bytes,\n \t\t\t\t\t   bool issetmem)\n@@ -7214,7 +7214,7 @@ ix86_copy_addr_to_reg (rtx addr)\n      3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n \twith specified algorithm.  */\n bool\n-ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n+ix86_expand_set_or_cpymem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t   rtx align_exp, rtx expected_align_exp,\n \t\t\t   rtx expected_size_exp, rtx min_size_exp,\n \t\t\t   rtx max_size_exp, rtx probable_max_size_exp,\n@@ -7436,7 +7436,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   if (misaligned_prologue_used)\n     {\n       /* Misaligned move prologue handled small blocks by itself.  */\n-      expand_set_or_movmem_prologue_epilogue_by_misaligned_moves\n+      expand_set_or_cpymem_prologue_epilogue_by_misaligned_moves\n \t   (dst, src, &destreg, &srcreg,\n \t    move_mode, promoted_val, vec_promoted_val,\n \t    &count_exp,\n@@ -7553,7 +7553,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t  dst = change_address (dst, BLKmode, destreg);\n \t  if (!issetmem)\n \t    src = change_address (src, BLKmode, srcreg);\n-\t  dst = expand_set_or_movmem_prologue (dst, src, destreg, srcreg,\n+\t  dst = expand_set_or_cpymem_prologue (dst, src, destreg, srcreg,\n \t\t\t\t\t    promoted_val, vec_promoted_val,\n \t\t\t\t\t    count_exp, align, desired_align,\n \t\t\t\t\t    issetmem);\n@@ -7567,7 +7567,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t{\n \t  /* If we know how many bytes need to be stored before dst is\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n-\t  dst = expand_set_or_movmem_constant_prologue (dst, &src, destreg,\n+\t  dst = expand_set_or_cpymem_constant_prologue (dst, &src, destreg,\n \t\t\t\t\t\t\t   srcreg,\n \t\t\t\t\t\t\t   promoted_val,\n \t\t\t\t\t\t\t   vec_promoted_val,\n@@ -7626,19 +7626,19 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n     case loop_1_byte:\n     case loop:\n     case unrolled_loop:\n-      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, promoted_val,\n+      expand_set_or_cpymem_via_loop (dst, src, destreg, srcreg, promoted_val,\n \t\t\t\t     count_exp, move_mode, unroll_factor,\n \t\t\t\t     expected_size, issetmem);\n       break;\n     case vector_loop:\n-      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg,\n+      expand_set_or_cpymem_via_loop (dst, src, destreg, srcreg,\n \t\t\t\t     vec_promoted_val, count_exp, move_mode,\n \t\t\t\t     unroll_factor, expected_size, issetmem);\n       break;\n     case rep_prefix_8_byte:\n     case rep_prefix_4_byte:\n     case rep_prefix_1_byte:\n-      expand_set_or_movmem_via_rep (dst, src, destreg, srcreg, promoted_val,\n+      expand_set_or_cpymem_via_rep (dst, src, destreg, srcreg, promoted_val,\n \t\t\t\t       val_exp, count_exp, move_mode, issetmem);\n       break;\n     }\n@@ -7691,7 +7691,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t\t    vec_promoted_val, count_exp,\n \t\t\t\t    epilogue_size_needed);\n \t  else\n-\t    expand_movmem_epilogue (dst, src, destreg, srcreg, count_exp,\n+\t    expand_cpymem_epilogue (dst, src, destreg, srcreg, count_exp,\n \t\t\t\t    epilogue_size_needed);\n \t}\n     }"}, {"sha": "4d6e76d5580005410206d73541e3f16f164924c3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -66,7 +66,7 @@ extern int avx_vpermilp_parallel (rtx par, machine_mode mode);\n extern int avx_vperm2f128_parallel (rtx par, machine_mode mode);\n \n extern bool ix86_expand_strlen (rtx, rtx, rtx, rtx);\n-extern bool ix86_expand_set_or_movmem (rtx, rtx, rtx, rtx, rtx, rtx,\n+extern bool ix86_expand_set_or_cpymem (rtx, rtx, rtx, rtx, rtx, rtx,\n \t\t\t\t       rtx, rtx, rtx, rtx, bool);\n \n extern bool constant_address_p (rtx);"}, {"sha": "1f70844fc45cff8e73f9ac0a65bdc6b9d8df2223", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1901,7 +1901,7 @@ typedef struct ix86_args {\n    ? GET_MODE_SIZE (TImode) : UNITS_PER_WORD)\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.\n+   move-instruction pairs, we will do a cpymem or libcall instead.\n    Increasing the value will always make code faster, but eventually\n    incurs high cost in increased code size.\n "}, {"sha": "19beeb2a59a85a77bca36f2abea4cba004843f84", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -16580,7 +16580,7 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"modrm\" \"0\")])\n \n-(define_expand \"movmem<mode>\"\n+(define_expand \"cpymem<mode>\"\n   [(use (match_operand:BLK 0 \"memory_operand\"))\n    (use (match_operand:BLK 1 \"memory_operand\"))\n    (use (match_operand:SWI48 2 \"nonmemory_operand\"))\n@@ -16592,7 +16592,7 @@\n    (use (match_operand:SI 8 \"\"))]\n   \"\"\n {\n- if (ix86_expand_set_or_movmem (operands[0], operands[1],\n+ if (ix86_expand_set_or_cpymem (operands[0], operands[1],\n \t\t\t        operands[2], NULL, operands[3],\n \t\t\t        operands[4], operands[5],\n \t\t\t\toperands[6], operands[7],\n@@ -16807,7 +16807,7 @@\n     (use (match_operand:SI 8 \"\"))]\n   \"\"\n {\n- if (ix86_expand_set_or_movmem (operands[0], NULL,\n+ if (ix86_expand_set_or_cpymem (operands[0], NULL,\n \t\t\t        operands[1], operands[2],\n \t\t\t\toperands[3], operands[4],\n \t\t\t        operands[5], operands[6],"}, {"sha": "91a5fe1e0044bff54e2fe9440546e14ca91ce999", "filename": "gcc/config/lm32/lm32.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Flm32%2Flm32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Flm32%2Flm32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -216,7 +216,7 @@\n     }    \n }\")\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n \t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n \t      (use (match_operand:SI 2 \"\" \"\"))"}, {"sha": "e5cdc801fd866a5bc9e46e7bca06ddaeaad2b8e4", "filename": "gcc/config/m32c/blkmov.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fblkmov.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -40,14 +40,14 @@\n ;; 1 = source (mem:BLK ...)\n ;; 2 = count\n ;; 3 = alignment\n-(define_expand \"movmemhi\"\n+(define_expand \"cpymemhi\"\n   [(match_operand 0 \"ap_operand\" \"\")\n    (match_operand 1 \"ap_operand\" \"\")\n    (match_operand 2 \"m32c_r3_operand\" \"\")\n    (match_operand 3 \"\" \"\")\n    ]\n   \"\"\n-  \"if (m32c_expand_movmemhi(operands)) DONE; FAIL;\"\n+  \"if (m32c_expand_cpymemhi(operands)) DONE; FAIL;\"\n   )\n \n ;; We can't use mode iterators for these because M16C uses r1h to extend\n@@ -60,7 +60,7 @@\n ;; 3 = dest (in)\n ;; 4 = src (in)\n ;; 5 = count (in)\n-(define_insn \"movmemhi_bhi_op\"\n+(define_insn \"cpymemhi_bhi_op\"\n   [(set (mem:QI (match_operand:HI 3 \"ap_operand\" \"0\"))\n \t(mem:QI (match_operand:HI 4 \"ap_operand\" \"1\")))\n    (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n@@ -75,7 +75,7 @@\n   \"TARGET_A16\"\n   \"mov.b:q\\t#0,r1h\\n\\tsmovf.b\\t; %0[0..%2-1]=r1h%1[]\"\n   )\n-(define_insn \"movmemhi_bpsi_op\"\n+(define_insn \"cpymemhi_bpsi_op\"\n   [(set (mem:QI (match_operand:PSI 3 \"ap_operand\" \"0\"))\n \t(mem:QI (match_operand:PSI 4 \"ap_operand\" \"1\")))\n    (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n@@ -89,7 +89,7 @@\n   \"TARGET_A24\"\n   \"smovf.b\\t; %0[0..%2-1]=%1[]\"\n   )\n-(define_insn \"movmemhi_whi_op\"\n+(define_insn \"cpymemhi_whi_op\"\n   [(set (mem:HI (match_operand:HI 3 \"ap_operand\" \"0\"))\n \t(mem:HI (match_operand:HI 4 \"ap_operand\" \"1\")))\n    (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n@@ -104,7 +104,7 @@\n   \"TARGET_A16\"\n   \"mov.b:q\\t#0,r1h\\n\\tsmovf.w\\t; %0[0..%2-1]=r1h%1[]\"\n   )\n-(define_insn \"movmemhi_wpsi_op\"\n+(define_insn \"cpymemhi_wpsi_op\"\n   [(set (mem:HI (match_operand:PSI 3 \"ap_operand\" \"0\"))\n \t(mem:HI (match_operand:PSI 4 \"ap_operand\" \"1\")))\n    (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")"}, {"sha": "fe926fd507eebf3a0108c4b6ad90cb2353fe059e", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -43,7 +43,7 @@ void m32c_emit_eh_epilogue (rtx);\n int  m32c_expand_cmpstr (rtx *);\n int  m32c_expand_insv (rtx *);\n int  m32c_expand_movcc (rtx *);\n-int  m32c_expand_movmemhi (rtx *);\n+int  m32c_expand_cpymemhi (rtx *);\n int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);"}, {"sha": "d0d24bb5f2b3a7814642c8ca9d7e2a10684273eb", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3592,7 +3592,7 @@ m32c_expand_setmemhi(rtx *operands)\n    addresses, not [mem] syntax.  $0 is the destination (MEM:BLK), $1\n    is the source (MEM:BLK), and $2 the count (HI).  */\n int\n-m32c_expand_movmemhi(rtx *operands)\n+m32c_expand_cpymemhi(rtx *operands)\n {\n   rtx desta, srca, count;\n   rtx desto, srco, counto;\n@@ -3620,9 +3620,9 @@ m32c_expand_movmemhi(rtx *operands)\n     {\n       count = copy_to_mode_reg (HImode, GEN_INT (INTVAL (count) / 2));\n       if (TARGET_A16)\n-\temit_insn (gen_movmemhi_whi_op (desto, srco, counto, desta, srca, count));\n+\temit_insn (gen_cpymemhi_whi_op (desto, srco, counto, desta, srca, count));\n       else\n-\temit_insn (gen_movmemhi_wpsi_op (desto, srco, counto, desta, srca, count));\n+\temit_insn (gen_cpymemhi_wpsi_op (desto, srco, counto, desta, srca, count));\n       return 1;\n     }\n \n@@ -3632,9 +3632,9 @@ m32c_expand_movmemhi(rtx *operands)\n     count = copy_to_mode_reg (HImode, count);\n \n   if (TARGET_A16)\n-    emit_insn (gen_movmemhi_bhi_op (desto, srco, counto, desta, srca, count));\n+    emit_insn (gen_cpymemhi_bhi_op (desto, srco, counto, desta, srca, count));\n   else\n-    emit_insn (gen_movmemhi_bpsi_op (desto, srco, counto, desta, srca, count));\n+    emit_insn (gen_cpymemhi_bpsi_op (desto, srco, counto, desta, srca, count));\n \n   return 1;\n }"}, {"sha": "ac18aa286c8ef96ae0f46c43a380e70d386f40ec", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -2598,7 +2598,7 @@ m32r_expand_block_move (rtx operands[])\n \t to the word after the end of the source block, and dst_reg to point\n \t to the last word of the destination block, provided that the block\n \t is MAX_MOVE_BYTES long.  */\n-      emit_insn (gen_movmemsi_internal (dst_reg, src_reg, at_a_time,\n+      emit_insn (gen_cpymemsi_internal (dst_reg, src_reg, at_a_time,\n \t\t\t\t\tnew_dst_reg, new_src_reg));\n       emit_move_insn (dst_reg, new_dst_reg);\n       emit_move_insn (src_reg, new_src_reg);\n@@ -2612,7 +2612,7 @@ m32r_expand_block_move (rtx operands[])\n     }\n \n   if (leftover)\n-    emit_insn (gen_movmemsi_internal (dst_reg, src_reg, GEN_INT (leftover),\n+    emit_insn (gen_cpymemsi_internal (dst_reg, src_reg, GEN_INT (leftover),\n \t\t\t\t      gen_reg_rtx (SImode),\n \t\t\t\t      gen_reg_rtx (SImode)));\n   return 1;"}, {"sha": "e944363fd9bf037f31c678add61a2125c47963c2", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -2195,7 +2195,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n \t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n \t      (use (match_operand:SI  2 \"immediate_operand\" \"\"))\n@@ -2214,7 +2214,7 @@\n \n ;; Insn generated by block moves\n \n-(define_insn \"movmemsi_internal\"\n+(define_insn \"cpymemsi_internal\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\t;; destination\n \t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\t;; source\n    (use (match_operand:SI 2 \"m32r_block_immediate_operand\" \"J\"));; # bytes to move"}, {"sha": "c6893518dc05cc6b84244a55cedeb78562d81f3f", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -2552,7 +2552,7 @@\n ;; Block move - adapted from m88k.md\n ;; ------------------------------------------------------------------------\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0 \"\" \"\"))\n \t\t   (mem:BLK (match_operand:BLK 1 \"\" \"\")))\n \t      (use (match_operand:SI 2 \"general_operand\" \"\"))"}, {"sha": "c2cbe3b016cc0a5a0ddf51129360f30a543d6f50", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1250,7 +1250,7 @@ microblaze_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n     microblaze_block_move_straight (dest, src, leftover);\n }\n \n-/* Expand a movmemsi instruction.  */\n+/* Expand a cpymemsi instruction.  */\n \n bool\n microblaze_expand_block_move (rtx dest, rtx src, rtx length, rtx align_rtx)"}, {"sha": "1509e4318597755ce03a6d592e7d5277d776020a", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1144,7 +1144,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n  \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n \t\t   (match_operand:BLK 1 \"general_operand\"))\n \t      (use (match_operand:SI 2 \"\"))"}, {"sha": "cbebb455fd5308b36248c01155a0091652ede9d3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -7938,15 +7938,15 @@ mips_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n {\n   if (op == STORE_BY_PIECES)\n     return mips_store_by_pieces_p (size, align);\n-  if (op == MOVE_BY_PIECES && HAVE_movmemsi)\n+  if (op == MOVE_BY_PIECES && HAVE_cpymemsi)\n     {\n-      /* movmemsi is meant to generate code that is at least as good as\n-\t move_by_pieces.  However, movmemsi effectively uses a by-pieces\n+      /* cpymemsi is meant to generate code that is at least as good as\n+\t move_by_pieces.  However, cpymemsi effectively uses a by-pieces\n \t implementation both for moves smaller than a word and for\n \t word-aligned moves of no more than MIPS_MAX_MOVE_BYTES_STRAIGHT\n \t bytes.  We should allow the tree-level optimisers to do such\n \t moves by pieces, as it often exposes other optimization\n-\t opportunities.  We might as well continue to use movmemsi at\n+\t opportunities.  We might as well continue to use cpymemsi at\n \t the rtl level though, as it produces better code when\n \t scheduling is disabled (such as at -O).  */\n       if (currently_expanding_to_rtl)\n@@ -8165,7 +8165,7 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n     emit_insn (gen_nop ());\n }\n \n-/* Expand a movmemsi instruction, which copies LENGTH bytes from\n+/* Expand a cpymemsi instruction, which copies LENGTH bytes from\n    memory reference SRC to memory reference DEST.  */\n \n bool"}, {"sha": "a5be7fa394c3b6b897e394469c92772869fe5938", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3099,12 +3099,12 @@ while (0)\n #define MIPS_MIN_MOVE_MEM_ALIGN 16\n \n /* The maximum number of bytes that can be copied by one iteration of\n-   a movmemsi loop; see mips_block_move_loop.  */\n+   a cpymemsi loop; see mips_block_move_loop.  */\n #define MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER \\\n   (UNITS_PER_WORD * 4)\n \n /* The maximum number of bytes that can be copied by a straight-line\n-   implementation of movmemsi; see mips_block_move_straight.  We want\n+   implementation of cpymemsi; see mips_block_move_straight.  We want\n    to make sure that any loop-based implementation will iterate at\n    least twice.  */\n #define MIPS_MAX_MOVE_BYTES_STRAIGHT \\\n@@ -3119,19 +3119,19 @@ while (0)\n \n #define MIPS_CALL_RATIO 8\n \n-/* Any loop-based implementation of movmemsi will have at least\n+/* Any loop-based implementation of cpymemsi will have at least\n    MIPS_MAX_MOVE_BYTES_STRAIGHT / UNITS_PER_WORD memory-to-memory\n    moves, so allow individual copies of fewer elements.\n \n-   When movmemsi is not available, use a value approximating\n+   When cpymemsi is not available, use a value approximating\n    the length of a memcpy call sequence, so that move_by_pieces\n    will generate inline code if it is shorter than a function call.\n    Since move_by_pieces_ninsns counts memory-to-memory moves, but\n    we'll have to generate a load/store pair for each, halve the\n    value of MIPS_CALL_RATIO to take that into account.  */\n \n #define MOVE_RATIO(speed)\t\t\t\t\\\n-  (HAVE_movmemsi\t\t\t\t\t\\\n+  (HAVE_cpymemsi\t\t\t\t\t\\\n    ? MIPS_MAX_MOVE_BYTES_STRAIGHT / MOVE_MAX\t\t\\\n    : MIPS_CALL_RATIO / 2)\n "}, {"sha": "d260cf9170c63502a76e399b3ca6f5a2916b947a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -5638,7 +5638,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n \t\t   (match_operand:BLK 1 \"general_operand\"))\n \t      (use (match_operand:SI 2 \"\"))"}, {"sha": "b3f2cd69899a310218c6b94d3f17764c3252713a", "filename": "gcc/config/nds32/nds32-memory-manipulation.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1,4 +1,4 @@\n-/* Auxiliary functions for expand movmem, setmem, cmpmem, load_multiple\n+/* Auxiliary functions for expand cpymem, setmem, cmpmem, load_multiple\n    and store_multiple pattern of Andes NDS32 cpu for GNU compiler\n    Copyright (C) 2012-2019 Free Software Foundation, Inc.\n    Contributed by Andes Technology Corporation.\n@@ -120,14 +120,14 @@ nds32_emit_mem_move_block (int base_regno, int count,\n \n /* ------------------------------------------------------------------------ */\n \n-/* Auxiliary function for expand movmem pattern.  */\n+/* Auxiliary function for expand cpymem pattern.  */\n \n static bool\n-nds32_expand_movmemsi_loop_unknown_size (rtx dstmem, rtx srcmem,\n+nds32_expand_cpymemsi_loop_unknown_size (rtx dstmem, rtx srcmem,\n \t\t\t\t\t rtx size,\n \t\t\t\t\t rtx alignment)\n {\n-  /* Emit loop version of movmem.\n+  /* Emit loop version of cpymem.\n \n        andi    $size_least_3_bit, $size, #~7\n        add     $dst_end, $dst, $size\n@@ -254,7 +254,7 @@ nds32_expand_movmemsi_loop_unknown_size (rtx dstmem, rtx srcmem,\n }\n \n static bool\n-nds32_expand_movmemsi_loop_known_size (rtx dstmem, rtx srcmem,\n+nds32_expand_cpymemsi_loop_known_size (rtx dstmem, rtx srcmem,\n \t\t\t\t       rtx size, rtx alignment)\n {\n   rtx dst_base_reg, src_base_reg;\n@@ -288,7 +288,7 @@ nds32_expand_movmemsi_loop_known_size (rtx dstmem, rtx srcmem,\n \n   if (total_bytes < 8)\n     {\n-      /* Emit total_bytes less than 8 loop version of movmem.\n+      /* Emit total_bytes less than 8 loop version of cpymem.\n \tadd     $dst_end, $dst, $size\n \tmove    $dst_itr, $dst\n \t.Lbyte_mode_loop:\n@@ -321,7 +321,7 @@ nds32_expand_movmemsi_loop_known_size (rtx dstmem, rtx srcmem,\n     }\n   else if (total_bytes % 8 == 0)\n     {\n-      /* Emit multiple of 8 loop version of movmem.\n+      /* Emit multiple of 8 loop version of cpymem.\n \n \t add     $dst_end, $dst, $size\n \t move    $dst_itr, $dst\n@@ -370,27 +370,27 @@ nds32_expand_movmemsi_loop_known_size (rtx dstmem, rtx srcmem,\n   else\n     {\n       /* Handle size greater than 8, and not a multiple of 8.  */\n-      return nds32_expand_movmemsi_loop_unknown_size (dstmem, srcmem,\n+      return nds32_expand_cpymemsi_loop_unknown_size (dstmem, srcmem,\n \t\t\t\t\t\t      size, alignment);\n     }\n \n   return true;\n }\n \n static bool\n-nds32_expand_movmemsi_loop (rtx dstmem, rtx srcmem,\n+nds32_expand_cpymemsi_loop (rtx dstmem, rtx srcmem,\n \t\t\t    rtx size, rtx alignment)\n {\n   if (CONST_INT_P (size))\n-    return nds32_expand_movmemsi_loop_known_size (dstmem, srcmem,\n+    return nds32_expand_cpymemsi_loop_known_size (dstmem, srcmem,\n \t\t\t\t\t\t  size, alignment);\n   else\n-    return nds32_expand_movmemsi_loop_unknown_size (dstmem, srcmem,\n+    return nds32_expand_cpymemsi_loop_unknown_size (dstmem, srcmem,\n \t\t\t\t\t\t    size, alignment);\n }\n \n static bool\n-nds32_expand_movmemsi_unroll (rtx dstmem, rtx srcmem,\n+nds32_expand_cpymemsi_unroll (rtx dstmem, rtx srcmem,\n \t\t\t      rtx total_bytes, rtx alignment)\n {\n   rtx dst_base_reg, src_base_reg;\n@@ -533,13 +533,13 @@ nds32_expand_movmemsi_unroll (rtx dstmem, rtx srcmem,\n    This is auxiliary extern function to help create rtx template.\n    Check nds32-multiple.md file for the patterns.  */\n bool\n-nds32_expand_movmemsi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n+nds32_expand_cpymemsi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n {\n-  if (nds32_expand_movmemsi_unroll (dstmem, srcmem, total_bytes, alignment))\n+  if (nds32_expand_cpymemsi_unroll (dstmem, srcmem, total_bytes, alignment))\n     return true;\n \n   if (!optimize_size && optimize > 2)\n-    return nds32_expand_movmemsi_loop (dstmem, srcmem, total_bytes, alignment);\n+    return nds32_expand_cpymemsi_loop (dstmem, srcmem, total_bytes, alignment);\n \n   return false;\n }"}, {"sha": "98d9508c06bb524df5c7676f711b1db0bd9b7d7e", "filename": "gcc/config/nds32/nds32-multiple.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3751,14 +3751,14 @@\n ;; operands[3] is the known shared alignment.\n \n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(match_operand:BLK 0 \"general_operand\" \"\")\n    (match_operand:BLK 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"nds32_reg_constant_operand\" \"\")\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n   \"\"\n {\n-  if (nds32_expand_movmemsi (operands[0],\n+  if (nds32_expand_cpymemsi (operands[0],\n \t\t\t     operands[1],\n \t\t\t     operands[2],\n \t\t\t     operands[3]))"}, {"sha": "7ae1954d01c5ef9282a27b080c38f173f26d277b", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -78,7 +78,7 @@ extern rtx nds32_di_low_part_subreg(rtx);\n \n extern rtx nds32_expand_load_multiple (int, int, rtx, rtx, bool, rtx *);\n extern rtx nds32_expand_store_multiple (int, int, rtx, rtx, bool, rtx *);\n-extern bool nds32_expand_movmemsi (rtx, rtx, rtx, rtx);\n+extern bool nds32_expand_cpymemsi (rtx, rtx, rtx, rtx);\n extern bool nds32_expand_setmem (rtx, rtx, rtx, rtx, rtx, rtx);\n extern bool nds32_expand_strlen (rtx, rtx, rtx, rtx);\n "}, {"sha": "0d00bf6b4f69b8a672d45e0bad9240fa129b44f8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -107,7 +107,7 @@ static int pa_can_combine_p (rtx_insn *, rtx_insn *, rtx_insn *, int, rtx,\n static bool forward_branch_p (rtx_insn *);\n static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static void compute_zdepdi_operands (unsigned HOST_WIDE_INT, unsigned *);\n-static int compute_movmem_length (rtx_insn *);\n+static int compute_cpymem_length (rtx_insn *);\n static int compute_clrmem_length (rtx_insn *);\n static bool pa_assemble_integer (rtx, unsigned int, int);\n static void remove_useless_addtr_insns (int);\n@@ -2985,7 +2985,7 @@ pa_output_block_move (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n    count insns rather than emit them.  */\n \n static int\n-compute_movmem_length (rtx_insn *insn)\n+compute_cpymem_length (rtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n   unsigned int align = INTVAL (XEXP (XVECEXP (pat, 0, 7), 0));\n@@ -5060,7 +5060,7 @@ pa_adjust_insn_length (rtx_insn *insn, int length)\n       && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 1)) == MEM\n       && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 0)) == BLKmode\n       && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 1)) == BLKmode)\n-    length += compute_movmem_length (insn) - 4;\n+    length += compute_cpymem_length (insn) - 4;\n   /* Block clear pattern.  */\n   else if (NONJUMP_INSN_P (insn)\n \t   && GET_CODE (pat) == PARALLEL"}, {"sha": "809a7b7853cf3b27625e2cd917bcb841060e0d57", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3162,9 +3162,9 @@\n \n ;; The definition of this insn does not really explain what it does,\n ;; but it should suffice that anything generated as this insn will be\n-;; recognized as a movmemsi operation, and that it will not successfully\n+;; recognized as a cpymemsi operation, and that it will not successfully\n ;; combine with anything.\n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n \t\t   (match_operand:BLK 1 \"\" \"\"))\n \t      (clobber (match_dup 4))\n@@ -3244,7 +3244,7 @@\n ;; operands 0 and 1 are both equivalent to symbolic MEMs.  Thus, we are\n ;; forced to internally copy operands 0 and 1 to operands 7 and 8,\n ;; respectively.  We then split or peephole optimize after reload.\n-(define_insn \"movmemsi_prereload\"\n+(define_insn \"cpymemsi_prereload\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r,r\"))\n \t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r,r\")))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n@@ -3337,7 +3337,7 @@\n     }\n }\")\n \n-(define_insn \"movmemsi_postreload\"\n+(define_insn \"cpymemsi_postreload\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+r,r\"))\n \t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+r,r\")))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n@@ -3352,7 +3352,7 @@\n   \"* return pa_output_block_move (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n-(define_expand \"movmemdi\"\n+(define_expand \"cpymemdi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n \t\t   (match_operand:BLK 1 \"\" \"\"))\n \t      (clobber (match_dup 4))\n@@ -3432,7 +3432,7 @@\n ;; operands 0 and 1 are both equivalent to symbolic MEMs.  Thus, we are\n ;; forced to internally copy operands 0 and 1 to operands 7 and 8,\n ;; respectively.  We then split or peephole optimize after reload.\n-(define_insn \"movmemdi_prereload\"\n+(define_insn \"cpymemdi_prereload\"\n   [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"r,r\"))\n \t(mem:BLK (match_operand:DI 1 \"register_operand\" \"r,r\")))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp\n@@ -3525,7 +3525,7 @@\n     }\n }\")\n \n-(define_insn \"movmemdi_postreload\"\n+(define_insn \"cpymemdi_postreload\"\n   [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"+r,r\"))\n \t(mem:BLK (match_operand:DI 1 \"register_operand\" \"+r,r\")))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=&r,&r\"))\t;loop cnt/tmp"}, {"sha": "be5ddc4c35953fe407c5b780a969652e127cff97", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -26,7 +26,7 @@\n     UNSPECV_BLOCKAGE\n     UNSPECV_SETD\n     UNSPECV_SETI\n-    UNSPECV_MOVMEM\n+    UNSPECV_CPYMEM\n   ])\n \n (define_constants\n@@ -664,8 +664,8 @@\n   [(set_attr \"length\" \"2,2,4,4,2\")])\n \n ;; Expand a block move.  We turn this into a move loop.\n-(define_expand \"movmemhi\"\n-  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+(define_expand \"cpymemhi\"\n+  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_CPYMEM)\n \t      (match_operand:BLK 0 \"general_operand\" \"=g\")\n \t      (match_operand:BLK 1 \"general_operand\" \"g\")\n \t      (match_operand:HI 2 \"immediate_operand\" \"i\")\n@@ -694,8 +694,8 @@\n }\")\n \n ;; Expand a block move.  We turn this into a move loop.\n-(define_insn_and_split \"movmemhi1\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+(define_insn_and_split \"cpymemhi1\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_CPYMEM)\n    (match_operand:HI 0 \"register_operand\" \"+r\")\n    (match_operand:HI 1 \"register_operand\" \"+r\")\n    (match_operand:HI 2 \"register_operand\" \"+r\")\n@@ -707,7 +707,7 @@\n   \"\"\n   \"#\"\n   \"reload_completed\"\n-  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_CPYMEM)\n \t      (match_dup 0)\n \t      (match_dup 1)\n \t      (match_dup 2)\n@@ -719,8 +719,8 @@\n \t      (clobber (reg:CC CC_REGNUM))])]\n   \"\")\n \n-(define_insn \"movmemhi_nocc\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+(define_insn \"cpymemhi_nocc\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_CPYMEM)\n    (match_operand:HI 0 \"register_operand\" \"+r\")\n    (match_operand:HI 1 \"register_operand\" \"+r\")\n    (match_operand:HI 2 \"register_operand\" \"+r\")"}, {"sha": "8ac09f204d2230588ab1da5976e0a5954287409b", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3050,7 +3050,7 @@ riscv_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n     emit_insn(gen_nop ());\n }\n \n-/* Expand a movmemsi instruction, which copies LENGTH bytes from\n+/* Expand a cpymemsi instruction, which copies LENGTH bytes from\n    memory reference SRC to memory reference DEST.  */\n \n bool"}, {"sha": "4509d7359358e6103419e0852eb2f9d8790d70af", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -840,20 +840,20 @@ while (0)\n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n \n-/* The maximum number of bytes copied by one iteration of a movmemsi loop.  */\n+/* The maximum number of bytes copied by one iteration of a cpymemsi loop.  */\n \n #define RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER (UNITS_PER_WORD * 4)\n \n /* The maximum number of bytes that can be copied by a straight-line\n-   movmemsi implementation.  */\n+   cpymemsi implementation.  */\n \n #define RISCV_MAX_MOVE_BYTES_STRAIGHT (RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER * 3)\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.\n+   move-instruction pairs, we will do a cpymem or libcall instead.\n    Do not use move_by_pieces at all when strict alignment is not\n    in effect but the target has slow unaligned accesses; in this\n-   case, movmem or libcall is more efficient.  */\n+   case, cpymem or libcall is more efficient.  */\n \n #define MOVE_RATIO(speed)\t\t\t\t\t\t\\\n   (!STRICT_ALIGNMENT && riscv_slow_unaligned_access_p ? 1 :\t\t\\"}, {"sha": "309c109db4c61df460a969d3e0bc3ee85eace3f8", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1498,7 +1498,7 @@\n   DONE;\n })\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n \t\t   (match_operand:BLK 1 \"general_operand\"))\n \t      (use (match_operand:SI 2 \"\"))"}, {"sha": "1b4a43e5d5010094e93786522d14f68174cb546c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -9113,7 +9113,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\")\n \t\t   (match_operand:BLK 1 \"\"))\n \t      (use (match_operand:SI 2 \"\"))"}, {"sha": "9df73e6efc6d0f41e954946babf045dbca3a5ebc", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -46,7 +46,7 @@\n    (UNSPEC_CONST           13)\n    \n    (UNSPEC_MOVSTR          20)\n-   (UNSPEC_MOVMEM          21)\n+   (UNSPEC_CPYMEM          21)\n    (UNSPEC_SETMEM          22)\n    (UNSPEC_STRLEN          23)\n    (UNSPEC_CMPSTRN         24)\n@@ -2449,13 +2449,13 @@\n    (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n )\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel\n     [(set (match_operand:BLK 0 \"memory_operand\")    ;; Dest\n \t  (match_operand:BLK 1 \"memory_operand\"))   ;; Source\n      (use (match_operand:SI  2 \"register_operand\")) ;; Length in bytes\n      (match_operand          3 \"immediate_operand\") ;; Align\n-     (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVMEM)]\n+     (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_CPYMEM)]\n     )]\n   \"rx_allow_string_insns\"\n   {\n@@ -2486,16 +2486,16 @@\n     emit_move_insn (len, force_operand (operands[2], NULL_RTX));\n     operands[0] = replace_equiv_address_nv (operands[0], addr1);\n     operands[1] = replace_equiv_address_nv (operands[1], addr2);\n-    emit_insn (gen_rx_movmem ());\n+    emit_insn (gen_rx_cpymem ());\n     DONE;\n   }\n )\n \n-(define_insn \"rx_movmem\"\n+(define_insn \"rx_cpymem\"\n   [(set (mem:BLK (reg:SI 1))\n \t(mem:BLK (reg:SI 2)))\n    (use (reg:SI 3))\n-   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVMEM)\n+   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_CPYMEM)\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (clobber (reg:SI 3))]"}, {"sha": "b162b26b344a68c4514bcc0409005b23d737e3c6", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -104,7 +104,7 @@ extern void s390_reload_symref_address (rtx , rtx , rtx , bool);\n extern void s390_expand_plus_operand (rtx, rtx, rtx);\n extern void emit_symbolic_move (rtx *);\n extern void s390_load_address (rtx, rtx);\n-extern bool s390_expand_movmem (rtx, rtx, rtx);\n+extern bool s390_expand_cpymem (rtx, rtx, rtx);\n extern void s390_expand_setmem (rtx, rtx, rtx);\n extern bool s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern void s390_expand_vec_strlen (rtx, rtx, rtx);"}, {"sha": "5ec26a0592b6788e7a382fc652787ee6bc7d0d26", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -5394,7 +5394,7 @@ legitimize_reload_address (rtx ad, machine_mode mode ATTRIBUTE_UNUSED,\n /* Emit code to move LEN bytes from DST to SRC.  */\n \n bool\n-s390_expand_movmem (rtx dst, rtx src, rtx len)\n+s390_expand_cpymem (rtx dst, rtx src, rtx len)\n {\n   /* When tuning for z10 or higher we rely on the Glibc functions to\n      do the right thing. Only for constant lengths below 64k we will\n@@ -5419,14 +5419,14 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n \t{\n \t  rtx newdst = adjust_address (dst, BLKmode, o);\n \t  rtx newsrc = adjust_address (src, BLKmode, o);\n-\t  emit_insn (gen_movmem_short (newdst, newsrc,\n+\t  emit_insn (gen_cpymem_short (newdst, newsrc,\n \t\t\t\t       GEN_INT (l > 256 ? 255 : l - 1)));\n \t}\n     }\n \n   else if (TARGET_MVCLE)\n     {\n-      emit_insn (gen_movmem_long (dst, src, convert_to_mode (Pmode, len, 1)));\n+      emit_insn (gen_cpymem_long (dst, src, convert_to_mode (Pmode, len, 1)));\n     }\n \n   else\n@@ -5488,7 +5488,7 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n \t  emit_insn (prefetch);\n \t}\n \n-      emit_insn (gen_movmem_short (dst, src, GEN_INT (255)));\n+      emit_insn (gen_cpymem_short (dst, src, GEN_INT (255)));\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n       s390_load_address (src_addr,\n@@ -5505,7 +5505,7 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n       emit_jump (loop_start_label);\n       emit_label (loop_end_label);\n \n-      emit_insn (gen_movmem_short (dst, src,\n+      emit_insn (gen_cpymem_short (dst, src,\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n     }\n@@ -5557,7 +5557,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t    if (l > 1)\n \t      {\n \t\trtx newdstp1 = adjust_address (dst, BLKmode, o + 1);\n-\t\temit_insn (gen_movmem_short (newdstp1, newdst,\n+\t\temit_insn (gen_cpymem_short (newdstp1, newdst,\n \t\t\t\t\t     GEN_INT (l > 257 ? 255 : l - 2)));\n \t      }\n \t  }\n@@ -5664,7 +5664,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t  /* Set the first byte in the block to the value and use an\n \t     overlapping mvc for the block.  */\n \t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n-\t  emit_insn (gen_movmem_short (dstp1, dst, GEN_INT (254)));\n+\t  emit_insn (gen_cpymem_short (dstp1, dst, GEN_INT (254)));\n \t}\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n@@ -5688,7 +5688,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n \t  /* execute only uses the lowest 8 bits of count that's\n \t     exactly what we need here.  */\n-\t  emit_insn (gen_movmem_short (dstp1, dst,\n+\t  emit_insn (gen_cpymem_short (dstp1, dst,\n \t\t\t\t       convert_to_mode (Pmode, count, 1)));\n \t}\n \n@@ -6330,7 +6330,7 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \n \t  dest = adjust_address (dest, BLKmode, 0);\n \t  set_mem_size (dest, size);\n-\t  s390_expand_movmem (dest, src_mem, GEN_INT (size));\n+\t  s390_expand_cpymem (dest, src_mem, GEN_INT (size));\n \t  return true;\n \t}\n "}, {"sha": "d06aea93128795742eaccf6a20ef34f6fc31a133", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3196,17 +3196,17 @@\n \n \n ;\n-; movmemM instruction pattern(s).\n+; cpymemM instruction pattern(s).\n ;\n \n-(define_expand \"movmem<mode>\"\n+(define_expand \"cpymem<mode>\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")   ; destination\n         (match_operand:BLK 1 \"memory_operand\" \"\"))  ; source\n    (use (match_operand:GPR 2 \"general_operand\" \"\")) ; count\n    (match_operand 3 \"\" \"\")]\n   \"\"\n {\n-  if (s390_expand_movmem (operands[0], operands[1], operands[2]))\n+  if (s390_expand_cpymem (operands[0], operands[1], operands[2]))\n     DONE;\n   else\n     FAIL;\n@@ -3215,7 +3215,7 @@\n ; Move a block that is up to 256 bytes in length.\n ; The block length is taken as (operands[2] % 256) + 1.\n \n-(define_expand \"movmem_short\"\n+(define_expand \"cpymem_short\"\n   [(parallel\n     [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n           (match_operand:BLK 1 \"memory_operand\" \"\"))\n@@ -3225,7 +3225,7 @@\n   \"\"\n   \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n-(define_insn \"*movmem_short\"\n+(define_insn \"*cpymem_short\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q,Q\")\n         (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q,Q\"))\n    (use (match_operand 2 \"nonmemory_operand\" \"n,a,a,a\"))\n@@ -3293,7 +3293,7 @@\n \n ; Move a block of arbitrary length.\n \n-(define_expand \"movmem_long\"\n+(define_expand \"cpymem_long\"\n   [(parallel\n     [(clobber (match_dup 2))\n      (clobber (match_dup 3))\n@@ -3327,7 +3327,7 @@\n   operands[3] = reg1;\n })\n \n-(define_insn \"*movmem_long\"\n+(define_insn \"*cpymem_long\"\n   [(clobber (match_operand:<DBL> 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:<DBL> 1 \"register_operand\" \"=d\"))\n    (set (mem:BLK (subreg:P (match_operand:<DBL> 2 \"register_operand\" \"0\") 0))\n@@ -3340,7 +3340,7 @@\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n \n-(define_insn \"*movmem_long_31z\"\n+(define_insn \"*cpymem_long_31z\"\n   [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n    (set (mem:BLK (subreg:SI (match_operand:TI 2 \"register_operand\" \"0\") 4))"}, {"sha": "ed70e344dfa821b1c672d64e048e35bbd878cad4", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -8906,7 +8906,7 @@\n \n ;; String/block move insn.\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0))\n \t\t   (mem:BLK (match_operand:BLK 1)))\n \t      (use (match_operand:SI 2 \"nonmemory_operand\"))"}, {"sha": "2dd765bca18377fa02c62424c051ea4f90ae4c7b", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1412,7 +1412,7 @@ do {\t\t\t\t\t\t\t\t\t   \\\n #define MOVE_MAX 8\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.  */\n+   move-instruction pairs, we will do a cpymem or libcall instead.  */\n \n #define MOVE_RATIO(speed) ((speed) ? 8 : 3)\n "}, {"sha": "a85cf36114c9af099b9059a70a4a484581415814", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -31,7 +31,6 @@ extern void vax_expand_addsub_di_operands (rtx *, enum rtx_code);\n extern const char * vax_output_int_move (rtx, rtx *, machine_mode);\n extern const char * vax_output_int_add (rtx_insn *, rtx *, machine_mode);\n extern const char * vax_output_int_subtract (rtx_insn *, rtx *, machine_mode);\n-extern const char * vax_output_movmemsi (rtx, rtx *);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "e7137dc09e66e8a30529c37bd16188e2823ea8f6", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -430,7 +430,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define MOVE_MAX 8\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movmem or libcall instead.  */\n+   move-instruction pairs, we will do a cpymem or libcall instead.  */\n #define MOVE_RATIO(speed) ((speed) ? 6 : 3)\n #define CLEAR_RATIO(speed) ((speed) ? 6 : 2)\n "}, {"sha": "298f3393d2d741e7b306daa7c726ad498af5c148", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -206,16 +206,16 @@\n }\")\n \n ;; This is here to accept 4 arguments and pass the first 3 along\n-;; to the movmemhi1 pattern that really does the work.\n-(define_expand \"movmemhi\"\n+;; to the cpymemhi1 pattern that really does the work.\n+(define_expand \"cpymemhi\"\n   [(set (match_operand:BLK 0 \"general_operand\" \"=g\")\n \t(match_operand:BLK 1 \"general_operand\" \"g\"))\n    (use (match_operand:HI 2 \"general_operand\" \"g\"))\n    (match_operand 3 \"\" \"\")]\n   \"\"\n   \"\n {\n-  emit_insn (gen_movmemhi1 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_cpymemhi1 (operands[0], operands[1], operands[2]));\n   DONE;\n }\")\n \n@@ -224,7 +224,7 @@\n ;; that anything generated as this insn will be recognized as one\n ;; and that it won't successfully combine with anything.\n \n-(define_insn \"movmemhi1\"\n+(define_insn \"cpymemhi1\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\n \t(match_operand:BLK 1 \"memory_operand\" \"o\"))\n    (use (match_operand:HI 2 \"general_operand\" \"g\"))"}, {"sha": "c9376b28fff1b17b5a42d765379e66394bf49d34", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1138,8 +1138,8 @@ do\t\t\t\t\t\t\t\t\t\\\n    always make code faster, but eventually incurs high cost in\n    increased code size.\n \n-   Since we have a movmemsi pattern, the default MOVE_RATIO is 2, which\n-   is too low given that movmemsi will invoke a libcall.  */\n+   Since we have a cpymemsi pattern, the default MOVE_RATIO is 2, which\n+   is too low given that cpymemsi will invoke a libcall.  */\n #define MOVE_RATIO(speed) ((speed) ? 9 : 3)\n \n /* `CLEAR_RATIO (SPEED)`"}, {"sha": "e146b89d1da82fe883f1573c2fc28ca5d66b5e8e", "filename": "gcc/config/visium/visium.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3006,7 +3006,7 @@\n ;; Argument 2 is the length\n ;; Argument 3 is the alignment\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (use (match_operand:SI  2 \"general_operand\" \"\"))"}, {"sha": "d1448a02f202640619f2ebce6c46db47b1ca28ff", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1026,7 +1026,7 @@\n \n ;; Block moves\n \n-(define_expand \"movmemsi\"\n+(define_expand \"cpymemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n \t\t   (match_operand:BLK 1 \"\" \"\"))\n \t      (use (match_operand:SI 2 \"arith_operand\" \"\"))"}, {"sha": "af7ea185f1ea95f6539f881e51e5594a0a4d6cb8", "filename": "gcc/defaults.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1318,10 +1318,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #endif\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction sequences, we will do a movmem or libcall instead.  */\n+   move-instruction sequences, we will do a cpymem or libcall instead.  */\n \n #ifndef MOVE_RATIO\n-#if defined (HAVE_movmemqi) || defined (HAVE_movmemhi) || defined (HAVE_movmemsi) || defined (HAVE_movmemdi) || defined (HAVE_movmemti)\n+#if defined (HAVE_cpymemqi) || defined (HAVE_cpymemhi) || defined (HAVE_cpymemsi) || defined (HAVE_cpymemdi) || defined (HAVE_cpymemti)\n #define MOVE_RATIO(speed) 2\n #else\n /* If we are optimizing for space (-Os), cut down the default move ratio.  */\n@@ -1342,7 +1342,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #endif\n \n /* If a memory set (to value other than zero) operation would take\n-   SET_RATIO or more simple move-instruction sequences, we will do a movmem\n+   SET_RATIO or more simple move-instruction sequences, we will do a setmem\n    or libcall instead.  */\n #ifndef SET_RATIO\n #define SET_RATIO(speed) MOVE_RATIO (speed)"}, {"sha": "3f9d545a1a5821382e0624bfd2072de01ecb160d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -6200,13 +6200,13 @@ This pattern is not allowed to @code{FAIL}.\n @item @samp{one_cmpl@var{m}2}\n Store the bitwise-complement of operand 1 into operand 0.\n \n-@cindex @code{movmem@var{m}} instruction pattern\n-@item @samp{movmem@var{m}}\n-Block move instruction.  The destination and source blocks of memory\n+@cindex @code{cpymem@var{m}} instruction pattern\n+@item @samp{cpymem@var{m}}\n+Block copy instruction.  The destination and source blocks of memory\n are the first two operands, and both are @code{mem:BLK}s with an\n address in mode @code{Pmode}.\n \n-The number of bytes to move is the third operand, in mode @var{m}.\n+The number of bytes to copy is the third operand, in mode @var{m}.\n Usually, you specify @code{Pmode} for @var{m}.  However, if you can\n generate better code knowing the range of valid lengths is smaller than\n those representable in a full Pmode pointer, you should provide\n@@ -6226,14 +6226,16 @@ in a way that the blocks are not required to be aligned according to it in\n all cases. This expected alignment is also in bytes, just like operand 4.\n Expected size, when unknown, is set to @code{(const_int -1)}.\n \n-Descriptions of multiple @code{movmem@var{m}} patterns can only be\n+Descriptions of multiple @code{cpymem@var{m}} patterns can only be\n beneficial if the patterns for smaller modes have fewer restrictions\n on their first, second and fourth operands.  Note that the mode @var{m}\n-in @code{movmem@var{m}} does not impose any restriction on the mode of\n-individually moved data units in the block.\n+in @code{cpymem@var{m}} does not impose any restriction on the mode of\n+individually copied data units in the block.\n \n-These patterns need not give special consideration to the possibility\n-that the source and destination strings might overlap.\n+The @code{cpymem@var{m}} patterns need not give special consideration\n+to the possibility that the source and destination strings might\n+overlap. These patterns are used to do inline expansion of\n+@code{__builtin_memcpy}.\n \n @cindex @code{movstr} instruction pattern\n @item @samp{movstr}\n@@ -6254,7 +6256,7 @@ given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The\n number of bytes to set is the second operand, in mode @var{m}.  The value to\n initialize the memory with is the third operand. Targets that only support the\n clearing of memory should reject any value that is not the constant 0.  See\n-@samp{movmem@var{m}} for a discussion of the choice of mode.\n+@samp{cpymem@var{m}} for a discussion of the choice of mode.\n \n The fourth operand is the known alignment of the destination, in the form\n of a @code{const_int} rtx.  Thus, if the compiler knows that the\n@@ -6272,13 +6274,13 @@ Operand 9 is the probable maximal size (i.e.@: we cannot rely on it for\n correctness, but it can be used for choosing proper code sequence for a\n given size).\n \n-The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n+The use for multiple @code{setmem@var{m}} is as for @code{cpymem@var{m}}.\n \n @cindex @code{cmpstrn@var{m}} instruction pattern\n @item @samp{cmpstrn@var{m}}\n String compare instruction, with five operands.  Operand 0 is the output;\n it has mode @var{m}.  The remaining four operands are like the operands\n-of @samp{movmem@var{m}}.  The two memory blocks specified are compared\n+of @samp{cpymem@var{m}}.  The two memory blocks specified are compared\n byte by byte in lexicographic order starting at the beginning of each\n string.  The instruction is not allowed to prefetch more than one byte\n at a time since either string may end in the first byte and reading past"}, {"sha": "0814b66a4861d2cc6266d7f1fedbbd2429ac2355", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3341,7 +3341,7 @@ that the register is live.  You should think twice before adding\n instead.  The @code{use} RTX is most commonly useful to describe that\n a fixed register is implicitly used in an insn.  It is also safe to use\n in patterns where the compiler knows for other reasons that the result\n-of the whole pattern is variable, such as @samp{movmem@var{m}} or\n+of the whole pattern is variable, such as @samp{cpymem@var{m}} or\n @samp{call} patterns.\n \n During the reload phase, an insn that has a @code{use} as pattern"}, {"sha": "14c1ea6a3235994ff050958829c94adec6d37098", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -6661,7 +6661,7 @@ two areas of memory, or to set, clear or store to memory, for example\n when copying a @code{struct}. The @code{by_pieces} infrastructure\n implements such memory operations as a sequence of load, store or move\n insns.  Alternate strategies are to expand the\n-@code{movmem} or @code{setmem} optabs, to emit a library call, or to emit\n+@code{cpymem} or @code{setmem} optabs, to emit a library call, or to emit\n unit-by-unit, loop-based operations.\n \n This target hook should return true if, for a memory operation with a\n@@ -6680,7 +6680,7 @@ optimized for speed rather than size.\n \n Returning true for higher values of @var{size} can improve code generation\n for speed if the target does not provide an implementation of the\n-@code{movmem} or @code{setmem} standard names, if the @code{movmem} or\n+@code{cpymem} or @code{setmem} standard names, if the @code{cpymem} or\n @code{setmem} implementation would be more expensive than a sequence of\n insns, or if the overhead of a library call would dominate that of\n the body of the memory operation."}, {"sha": "4d395697645673f8f973eb12b32cbd5a10124c95", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -73,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n int cse_not_expected;\n \n static bool block_move_libcall_safe_for_call_parm (void);\n-static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n+static bool emit_block_move_via_cpymem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n@@ -1624,7 +1624,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \n   if (CONST_INT_P (size) && can_move_by_pieces (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align, RETURN_BEGIN);\n-  else if (emit_block_move_via_movmem (x, y, size, align,\n+  else if (emit_block_move_via_cpymem (x, y, size, align,\n \t\t\t\t       expected_align, expected_size,\n \t\t\t\t       min_size, max_size, probable_max_size))\n     ;\n@@ -1722,11 +1722,11 @@ block_move_libcall_safe_for_call_parm (void)\n   return true;\n }\n \n-/* A subroutine of emit_block_move.  Expand a movmem pattern;\n+/* A subroutine of emit_block_move.  Expand a cpymem pattern;\n    return true if successful.  */\n \n static bool\n-emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n+emit_block_move_via_cpymem (rtx x, rtx y, rtx size, unsigned int align,\n \t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t\t    unsigned HOST_WIDE_INT min_size,\n \t\t\t    unsigned HOST_WIDE_INT max_size,\n@@ -1755,7 +1755,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n   FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n     {\n       scalar_int_mode mode = mode_iter.require ();\n-      enum insn_code code = direct_optab_handler (movmem_optab, mode);\n+      enum insn_code code = direct_optab_handler (cpymem_optab, mode);\n \n       if (code != CODE_FOR_nothing\n \t  /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT"}, {"sha": "03a08da575af9acf75cf92fe714a6810220a0d4d", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -256,7 +256,7 @@ OPTAB_D (umul_highpart_optab, \"umul$a3_highpart\")\n OPTAB_D (cmpmem_optab, \"cmpmem$a\")\n OPTAB_D (cmpstr_optab, \"cmpstr$a\")\n OPTAB_D (cmpstrn_optab, \"cmpstrn$a\")\n-OPTAB_D (movmem_optab, \"movmem$a\")\n+OPTAB_D (cpymem_optab, \"cpymem$a\")\n OPTAB_D (setmem_optab, \"setmem$a\")\n OPTAB_D (strlen_optab, \"strlen$a\")\n "}, {"sha": "41654054ad8d6ca7d6d5c00fb5972ada05ece489", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -3531,7 +3531,7 @@ two areas of memory, or to set, clear or store to memory, for example\\n\\\n when copying a @code{struct}. The @code{by_pieces} infrastructure\\n\\\n implements such memory operations as a sequence of load, store or move\\n\\\n insns.  Alternate strategies are to expand the\\n\\\n-@code{movmem} or @code{setmem} optabs, to emit a library call, or to emit\\n\\\n+@code{cpymem} or @code{setmem} optabs, to emit a library call, or to emit\\n\\\n unit-by-unit, loop-based operations.\\n\\\n \\n\\\n This target hook should return true if, for a memory operation with a\\n\\\n@@ -3550,7 +3550,7 @@ optimized for speed rather than size.\\n\\\n \\n\\\n Returning true for higher values of @var{size} can improve code generation\\n\\\n for speed if the target does not provide an implementation of the\\n\\\n-@code{movmem} or @code{setmem} standard names, if the @code{movmem} or\\n\\\n+@code{cpymem} or @code{setmem} standard names, if the @code{cpymem} or\\n\\\n @code{setmem} implementation would be more expensive than a sequence of\\n\\\n insns, or if the overhead of a library call would dominate that of\\n\\\n the body of the memory operation.\\n\\"}, {"sha": "676885bb32e1f07b63a339d56015d4bb6d975cde", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76715c3216cf6ccd071fc852920af55d6b0054ae/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=76715c3216cf6ccd071fc852920af55d6b0054ae", "patch": "@@ -1746,17 +1746,17 @@ get_move_ratio (bool speed_p ATTRIBUTE_UNUSED)\n #ifdef MOVE_RATIO\n   move_ratio = (unsigned int) MOVE_RATIO (speed_p);\n #else\n-#if defined (HAVE_movmemqi) || defined (HAVE_movmemhi) || defined (HAVE_movmemsi) || defined (HAVE_movmemdi) || defined (HAVE_movmemti)\n+#if defined (HAVE_cpymemqi) || defined (HAVE_cpymemhi) || defined (HAVE_cpymemsi) || defined (HAVE_cpymemdi) || defined (HAVE_cpymemti)\n   move_ratio = 2;\n-#else /* No movmem patterns, pick a default.  */\n+#else /* No cpymem patterns, pick a default.  */\n   move_ratio = ((speed_p) ? 15 : 3);\n #endif\n #endif\n   return move_ratio;\n }\n \n /* Return TRUE if the move_by_pieces/set_by_pieces infrastructure should be\n-   used; return FALSE if the movmem/setmem optab should be expanded, or\n+   used; return FALSE if the cpymem/setmem optab should be expanded, or\n    a call to memcpy emitted.  */\n \n bool"}]}