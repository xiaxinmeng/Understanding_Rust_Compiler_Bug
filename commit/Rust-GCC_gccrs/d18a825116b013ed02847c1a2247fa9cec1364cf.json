{"sha": "d18a825116b013ed02847c1a2247fa9cec1364cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4YTgyNTExNmIwMTNlZDAyODQ3YzFhMjI0N2ZhOWNlYzEzNjRjZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-09-04T07:16:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-09-04T07:16:43Z"}, "message": "Remove cast-as-lvalue extension.\n\n\t* call.c (build_conditional_expr): Correct formatting.\n\t(convert_like_real): Use lvalue_p, not non_cast_lvalue_p.\n\t(initialize_real): Use real_lvalue_p, not real_non_cast_lvalue_p.\n\t* cp-tree.h (non_cast_lvalue_p): Remove.\n\t(real_non_cast_lvalue_p): Remove.\n\t(non_cast_lvalue_or_else): Remove.\n\t* tree.c (lvalue_p_1): Remove allow_cast_as_lvalue parameter.\n\t(real_lvalue_p): Adjust call to lvalue_p_1.\n\t(non_cast_lvalue_p): Remove.\n\t(non_cast_lvalue_or_else): Remove.\n\t(lvalue_p): Adjust call to lvalue_p_1.\n\t(lvalue_or_else): Simplify.\n\t* typeck.c (build_unary_op): Use lvalue_or_else, not\n\tnon_cast_lvalue_or_else.\n\t(build_static_cast): Use real_lvalue_p, not real_non_cast_lvalue_p.\n\n\t* doc/extend.texi: Document removal of cast-as-lvalue extension in\n\tC++.\n\n\t* g++.dg/expr/lval1.C: New test.\n\t* g++.dg/ext/lvcast.C: Remove.\n\nFrom-SVN: r71051", "tree": {"sha": "5bb40582c760ac444032db79c71b9f81c183e39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb40582c760ac444032db79c71b9f81c183e39e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18a825116b013ed02847c1a2247fa9cec1364cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18a825116b013ed02847c1a2247fa9cec1364cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18a825116b013ed02847c1a2247fa9cec1364cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18a825116b013ed02847c1a2247fa9cec1364cf/comments", "author": null, "committer": null, "parents": [{"sha": "c5ef564bebaa4e7abb41636a565e43ddbeb268a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ef564bebaa4e7abb41636a565e43ddbeb268a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ef564bebaa4e7abb41636a565e43ddbeb268a6"}], "stats": {"total": 151, "additions": 65, "deletions": 86}, "files": [{"sha": "f078ad499bdd6de1c3db84f538ed01d9bb150449", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -1,3 +1,8 @@\n+2003-09-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* doc/extend.texi: Document removal of cast-as-lvalue extension in\n+\tC++.\n+\n 2003-09-04  Nicolas Roche  <roche@act-europe.fr>\n \n \t* gcc.c (process_command): Fix typo."}, {"sha": "50fe2658ab722dd5a80d3802b5cbfa8a7386ae22", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -1,3 +1,22 @@\n+2003-09-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove cast-as-lvalue extension.\n+\t* call.c (build_conditional_expr): Correct formatting.\n+\t(convert_like_real): Use lvalue_p, not non_cast_lvalue_p.\n+\t(initialize_real): Use real_lvalue_p, not real_non_cast_lvalue_p.\n+\t* cp-tree.h (non_cast_lvalue_p): Remove.\n+\t(real_non_cast_lvalue_p): Remove.\n+\t(non_cast_lvalue_or_else): Remove.\n+\t* tree.c (lvalue_p_1): Remove allow_cast_as_lvalue parameter.\n+\t(real_lvalue_p): Adjust call to lvalue_p_1.\n+\t(non_cast_lvalue_p): Remove.\n+\t(non_cast_lvalue_or_else): Remove.\n+\t(lvalue_p): Adjust call to lvalue_p_1.\n+\t(lvalue_or_else): Simplify.\n+\t* typeck.c (build_unary_op): Use lvalue_or_else, not\n+\tnon_cast_lvalue_or_else.\n+\t(build_static_cast): Use real_lvalue_p, not real_non_cast_lvalue_p.\n+\n 2003-09-03  DJ Delorie  <dj@redhat.com>\n \n \t* decl.c (finish_function): Pass fndecl to aggregate_value_p."}, {"sha": "35a82268b848ecfe4c426e129873aa14f49e2bd0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -3193,8 +3193,9 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n      If the second and third operands are lvalues and have the same\n      type, the result is of that type and is an lvalue.  */\n-  if (real_lvalue_p (arg2) && real_lvalue_p (arg3) && \n-      same_type_p (arg2_type, arg3_type))\n+  if (real_lvalue_p (arg2) \n+      && real_lvalue_p (arg3) \n+      && same_type_p (arg2_type, arg3_type))\n     {\n       result_type = arg2_type;\n       goto valid_operands;\n@@ -4126,7 +4127,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n \ttree ref_type = totype;\n \n \t/* If necessary, create a temporary.  */\n-\tif (NEED_TEMPORARY_P (convs) || !non_cast_lvalue_p (expr))\n+\tif (NEED_TEMPORARY_P (convs) || !lvalue_p (expr))\n \t  {\n \t    tree type = TREE_TYPE (TREE_OPERAND (convs, 0));\n \n@@ -6089,7 +6090,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \tbase_conv_type = NULL_TREE;\n       /* Perform the remainder of the conversion.  */\n       expr = convert_like (conv, expr);\n-      if (!real_non_cast_lvalue_p (expr))\n+      if (!real_lvalue_p (expr))\n \t{\n \t  tree init;\n \t  tree type;"}, {"sha": "50228e22760843e2358a936afb449e25c0ea0a4f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -4167,10 +4167,7 @@ extern int zero_init_p\t\t\t\t(tree);\n extern tree canonical_type_variant              (tree);\n extern tree copy_base_binfos\t\t\t(tree, tree, tree);\n extern int member_p\t\t\t\t(tree);\n-extern cp_lvalue_kind real_lvalue_p\t\t(tree);\n-extern int non_cast_lvalue_p\t\t\t(tree);\n-extern cp_lvalue_kind real_non_cast_lvalue_p    (tree);\n-extern int non_cast_lvalue_or_else\t\t(tree, const char *);\n+extern cp_lvalue_kind real_lvalue_p             (tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree,\n \t\t\t\t\t\t\t ...);\n extern tree build_min_nt\t\t\t(enum tree_code, ...);"}, {"sha": "71742a7bba7bb949e65598a8abe5405d6a6dd0ba", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -41,7 +41,7 @@ static tree build_cplus_array_type_1 (tree, tree);\n static int list_hash_eq (const void *, const void *);\n static hashval_t list_hash_pieces (tree, tree, tree);\n static hashval_t list_hash (const void *);\n-static cp_lvalue_kind lvalue_p_1 (tree, int, int);\n+static cp_lvalue_kind lvalue_p_1 (tree, int);\n static tree no_linkage_helper (tree *, int *, void *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n static tree cp_unsave_r (tree *, int *, void *);\n@@ -60,8 +60,7 @@ static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n \n static cp_lvalue_kind\n lvalue_p_1 (tree ref, \n-            int treat_class_rvalues_as_lvalues, \n-            int allow_cast_as_lvalue)\n+            int treat_class_rvalues_as_lvalues)\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n   cp_lvalue_kind op2_lvalue_kind = clk_none;\n@@ -85,21 +84,11 @@ lvalue_p_1 (tree ref,\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       return lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t treat_class_rvalues_as_lvalues,\n-\t\t\t allow_cast_as_lvalue);\n-\n-    case NOP_EXPR:\n-      if (allow_cast_as_lvalue)\n-\treturn lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t   treat_class_rvalues_as_lvalues,\n-\t\t\t   allow_cast_as_lvalue);\n-      else\n-\treturn clk_none;\n+\t\t\t treat_class_rvalues_as_lvalues);\n \n     case COMPONENT_REF:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t    treat_class_rvalues_as_lvalues,\n-\t\t\t\t    allow_cast_as_lvalue);\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       if (!op1_lvalue_kind \n \t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\t\n   \t     situations.  */\n@@ -140,29 +129,24 @@ lvalue_p_1 (tree ref,\n     case MAX_EXPR:\n     case MIN_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t    treat_class_rvalues_as_lvalues,\n-\t\t\t\t    allow_cast_as_lvalue);\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t    treat_class_rvalues_as_lvalues,\n-\t\t\t\t    allow_cast_as_lvalue);\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       break;\n \n     case COND_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t    treat_class_rvalues_as_lvalues,\n-\t\t\t\t    allow_cast_as_lvalue);\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 2),\n-\t\t\t\t    treat_class_rvalues_as_lvalues,\n-\t\t\t\t    allow_cast_as_lvalue);\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       break;\n \n     case MODIFY_EXPR:\n       return clk_ordinary;\n \n     case COMPOUND_EXPR:\n       return lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t treat_class_rvalues_as_lvalues,\n-\t\t\t allow_cast_as_lvalue);\n+\t\t\t treat_class_rvalues_as_lvalues);\n \n     case TARGET_EXPR:\n       return treat_class_rvalues_as_lvalues ? clk_class : clk_none;\n@@ -205,27 +189,15 @@ lvalue_p_1 (tree ref,\n   return op1_lvalue_kind;\n }\n \n-/* If REF is an lvalue, returns the kind of lvalue that REF is.\n-   Otherwise, returns clk_none.  Lvalues can be assigned, unless they\n-   have TREE_READONLY, or unless they are FUNCTION_DECLs.  Lvalues can\n-   have their address taken, unless they have DECL_REGISTER.  */\n-\n-cp_lvalue_kind\n-real_lvalue_p (tree ref)\n-{\n-  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/ 0, /*cast*/ 1);\n-}\n-\n /* Returns the kind of lvalue that REF is, in the sense of\n    [basic.lval].  This function should really be named lvalue_p; it\n    computes the C++ definition of lvalue.  */\n \n cp_lvalue_kind\n-real_non_cast_lvalue_p (tree ref)\n+real_lvalue_p (tree ref)\n {\n   return lvalue_p_1 (ref, \n-\t\t     /*treat_class_rvalues_as_lvalues=*/0, \n-\t\t     /*allow_cast_as_lvalue=*/0);\n+\t\t     /*treat_class_rvalues_as_lvalues=*/0);\n }\n \n /* This differs from real_lvalue_p in that class rvalues are\n@@ -235,14 +207,7 @@ int\n lvalue_p (tree ref)\n {\n   return \n-    (lvalue_p_1 (ref, /*class rvalue ok*/ 1, /*cast*/ 1) != clk_none);\n-}\n-\n-int\n-non_cast_lvalue_p (tree ref)\n-{\n-  return \n-    (lvalue_p_1 (ref, /*class rvalue ok*/ 1, /*cast*/ 0) != clk_none);\n+    (lvalue_p_1 (ref, /*class rvalue ok*/ 1) != clk_none);\n }\n \n /* Return nonzero if REF is an lvalue valid for this language;\n@@ -251,21 +216,12 @@ non_cast_lvalue_p (tree ref)\n int\n lvalue_or_else (tree ref, const char* string)\n {\n-  int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 1);\n-  int win = (ret != clk_none);\n-  if (! win)\n-    error (\"non-lvalue in %s\", string);\n-  return win;\n-}\n-\n-int\n-non_cast_lvalue_or_else (tree ref, const char* string)\n-{\n-  int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 0);\n-  int win = (ret != clk_none);\n-  if (! win)\n-    error (\"non-lvalue in %s\", string);\n-  return win;\n+  if (!lvalue_p (ref))\n+    {\n+      error (\"non-lvalue in %s\", string);\n+      return 0;\n+    }\n+  return 1;\n }\n \n /* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */"}, {"sha": "2a21a005c584ba4f1878e97587f5628384d1f985", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -3967,7 +3967,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t is an error.  */\n       else if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t       && TREE_CODE (argtype) != METHOD_TYPE\n-\t       && !non_cast_lvalue_or_else (arg, \"unary `&'\"))\n+\t       && !lvalue_or_else (arg, \"unary `&'\"))\n \treturn error_mark_node;\n \n       if (argtype != error_mark_node)\n@@ -4391,7 +4391,7 @@ build_static_cast (tree type, tree expr)\n   if (TREE_CODE (type) == REFERENCE_TYPE\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (intype)\n-      && real_non_cast_lvalue_p (expr)\n+      && real_lvalue_p (expr)\n       && DERIVED_FROM_P (intype, TREE_TYPE (type))\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT "}, {"sha": "6664e1c5eb7cff4970cd54be44cb0ace77b76d62", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -1071,9 +1071,9 @@ Compound expressions, conditional expressions and casts are allowed as\n lvalues provided their operands are lvalues.  This means that you can take\n their addresses or store values into them.\n \n-Standard C++ allows compound expressions and conditional expressions as\n-lvalues, and permits casts to reference type, so use of this extension\n-is deprecated for C++ code.\n+Standard C++ allows compound expressions and conditional expressions\n+as lvalues, and permits casts to reference type, so use of this\n+extension is not supported for C++ code.\n \n For example, a compound expression can be assigned, provided the last\n expression in the sequence is an lvalue.  These two expressions are"}, {"sha": "562ed09c162bda5110bba3770b6d9ed66ab09be0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -1,3 +1,8 @@\n+2003-09-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/expr/lval1.C: New test.\n+\t* g++.dg/ext/lvcast.C: Remove.\n+\n 2003-09-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/11700."}, {"sha": "bed47d8e4ec6ebaa613bea840e3835e63d06e7bb", "filename": "gcc/testsuite/g++.dg/expr/lval1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Flval1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18a825116b013ed02847c1a2247fa9cec1364cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Flval1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Flval1.C?ref=d18a825116b013ed02847c1a2247fa9cec1364cf", "patch": "@@ -0,0 +1,7 @@\n+// Contributed by Matt Austern <austern@apple.com>\n+\n+void f ()\n+{\n+  int n;\n+  (char) n = 1; // { dg-error \"\" }\n+}"}, {"sha": "efff04ec0896703897678a1a4d9b414d4455ef77", "filename": "gcc/testsuite/g++.dg/ext/lvcast.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ef564bebaa4e7abb41636a565e43ddbeb268a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ef564bebaa4e7abb41636a565e43ddbeb268a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flvcast.C?ref=c5ef564bebaa4e7abb41636a565e43ddbeb268a6", "patch": "@@ -1,11 +0,0 @@\n-// Copyright (C) 2002 Free Software Foundation\n-// Contributed by Matt Austern <austern@apple.com>\n-\n-// { dg-do compile }\n-// { dg-options -fpermissive }\n-\n-void f ()\n-{\n-  int n;\n-  (char) n = 1;\n-}"}]}