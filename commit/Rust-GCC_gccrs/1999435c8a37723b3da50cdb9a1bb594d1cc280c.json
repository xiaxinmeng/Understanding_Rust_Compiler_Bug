{"sha": "1999435c8a37723b3da50cdb9a1bb594d1cc280c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk5OTQzNWM4YTM3NzIzYjNkYTUwY2RiOWExYmI1OTRkMWNjMjgwYw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-05-31T06:59:47Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-05-31T06:59:47Z"}, "message": "revert: combine.c (gen_binary): Remove.\n\n2004-05-31  Paolo Bonzini  <bonzini@gnu.org>\n\n\tRevert this patch:\n\t2004-05-27  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* combine.c (gen_binary): Remove.\n\t(known_cond, simplify_shift_const\n\tfind_split_point, combine_simplify_rtx,\n\tsimplify_if_then_else, simplify_set,\n\tsimplify_logical, expand_field_assignment,\n\textract_left_shift, force_to_mode,\n\tif_then_else_cond, apply_distributive_law,\n\tsimplify_and_const_int, simplify_shift_const,\n\tgen_lowpart_for_combine, simplify_comparison,\n\treversed_comparison): Replace with\n\tsimplify_gen_binary, simplify_gen_relational or\n\tdistribute_and_simplify_rtx.\n\t(distribute_and_simplify_rtx): New function.\n\nFrom-SVN: r82475", "tree": {"sha": "56e34782a8018c0af88b13873d397fb5deacd721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56e34782a8018c0af88b13873d397fb5deacd721"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1999435c8a37723b3da50cdb9a1bb594d1cc280c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1999435c8a37723b3da50cdb9a1bb594d1cc280c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1999435c8a37723b3da50cdb9a1bb594d1cc280c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1999435c8a37723b3da50cdb9a1bb594d1cc280c/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97509a89b1c27446c4ac98d0756f6a587d3ebbf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97509a89b1c27446c4ac98d0756f6a587d3ebbf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97509a89b1c27446c4ac98d0756f6a587d3ebbf5"}], "stats": {"total": 635, "additions": 315, "deletions": 320}, "files": [{"sha": "8ce27ff371bbc7ac02bc1a374b9e63c281c08ebd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1999435c8a37723b3da50cdb9a1bb594d1cc280c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1999435c8a37723b3da50cdb9a1bb594d1cc280c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1999435c8a37723b3da50cdb9a1bb594d1cc280c", "patch": "@@ -1,3 +1,22 @@\n+2004-05-31  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tRevert this patch:\n+\t2004-05-27  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (gen_binary): Remove.\n+\t(known_cond, simplify_shift_const\n+\tfind_split_point, combine_simplify_rtx,\n+\tsimplify_if_then_else, simplify_set,\n+\tsimplify_logical, expand_field_assignment,\n+\textract_left_shift, force_to_mode,\n+\tif_then_else_cond, apply_distributive_law,\n+\tsimplify_and_const_int, simplify_shift_const,\n+\tgen_lowpart_for_combine, simplify_comparison,\n+\treversed_comparison): Replace with\n+\tsimplify_gen_binary, simplify_gen_relational or\n+\tdistribute_and_simplify_rtx.\n+\t(distribute_and_simplify_rtx): New function.\n+\n 2004-05-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (emit_move_sequence): Fix loading of non 14-bit CONST operands\n@@ -269,7 +288,7 @@\n \n \t* cfgbuild.c (control_flow_insn_p):  Notice noreturn call\n \n-2004-05-25  Paolo Bonzini  <bonzini@gnu.org>\n+2004-05-27  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* combine.c (gen_binary): Remove.\n \t(known_cond, simplify_shift_const"}, {"sha": "64af27c779bd3e3ecc84f4e62ad8e0084b08c475", "filename": "gcc/combine.c", "status": "modified", "additions": 295, "deletions": 319, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1999435c8a37723b3da50cdb9a1bb594d1cc280c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1999435c8a37723b3da50cdb9a1bb594d1cc280c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1999435c8a37723b3da50cdb9a1bb594d1cc280c", "patch": "@@ -372,7 +372,6 @@ static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n static int rtx_equal_for_field_assignment_p (rtx, rtx);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n-static rtx distribute_and_simplify_rtx (rtx);\n static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n@@ -381,6 +380,7 @@ static rtx simplify_shift_const\t(rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n+static rtx gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n static void record_value_for_reg (rtx, rtx, rtx);\n@@ -3017,16 +3017,14 @@ find_split_point (rtx *loc, rtx insn)\n \n \t  if (src == mask)\n \t    SUBST (SET_SRC (x),\n-\t\t   simplify_gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n+\t\t   gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n \t  else\n-\t    {\n-\t      rtx negmask = gen_int_mode (~(mask << pos), mode);\n-\t      SUBST (SET_SRC (x),\n-\t\t     simplify_gen_binary (IOR, mode,\n-\t\t\t\t          simplify_gen_binary (AND, mode,\n-\t\t\t\t\t\t\t       dest, negmask),\n-\t\t\t\t\t  GEN_INT (src << pos)));\n-\t    }\n+\t    SUBST (SET_SRC (x),\n+\t\t   gen_binary (IOR, mode,\n+\t\t\t       gen_binary (AND, mode, dest,\n+\t\t\t\t\t   gen_int_mode (~(mask << pos),\n+\t\t\t\t\t\t\t mode)),\n+\t\t\t       GEN_INT (src << pos)));\n \n \t  SUBST (SET_DEST (x), dest);\n \n@@ -3601,7 +3599,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       new = simplify_shift_const (NULL_RTX, ASHIFTRT, mode, new,\n \t\t\t\t  INTVAL (XEXP (XEXP (x, 0), 1)));\n \n-      SUBST (XEXP (x, 0), simplify_gen_binary (PLUS, mode, new, temp));\n+      SUBST (XEXP (x, 0), gen_binary (PLUS, mode, new, temp));\n     }\n \n   /* If this is a simple operation applied to an IF_THEN_ELSE, try\n@@ -3658,24 +3656,21 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      /* If the result values are STORE_FLAG_VALUE and zero, we can\n \t\t just make the comparison operation.  */\n \t      if (true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-\t\tx = simplify_gen_relational (cond_code, mode, VOIDmode,\n-\t\t\t\t\t     cond, cop1);\n+\t\tx = gen_binary (cond_code, mode, cond, cop1);\n \t      else if (true_rtx == const0_rtx && false_rtx == const_true_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n-\t\tx = simplify_gen_relational (reversed, mode, VOIDmode,\n-\t\t\t\t\t     cond, cop1);\n+\t\tx = gen_binary (reversed, mode, cond, cop1);\n \n \t      /* Likewise, we can make the negate of a comparison operation\n \t\t if the result values are - STORE_FLAG_VALUE and zero.  */\n \t      else if (GET_CODE (true_rtx) == CONST_INT\n \t\t       && INTVAL (true_rtx) == - STORE_FLAG_VALUE\n \t\t       && false_rtx == const0_rtx)\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tsimplify_gen_relational (cond_code,\n-\t\t\t\t\t\t\t\t mode, VOIDmode,\n-\t\t\t\t\t\t\t\t cond, cop1),\n+\t\t\t\t\tgen_binary (cond_code, mode, cond,\n+\t\t\t\t\t\t    cop1),\n \t\t\t\t\tmode);\n \t      else if (GET_CODE (false_rtx) == CONST_INT\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n@@ -3684,17 +3679,13 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tsimplify_gen_relational (reversed,\n-\t\t\t\t\t\t\t\t mode, VOIDmode,\n-\t\t\t\t\t\t\t\t cond, cop1),\n+\t\t\t\t\tgen_binary (reversed, mode,\n+\t\t\t\t\t\t    cond, cop1),\n \t\t\t\t\tmode);\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n-\t\t\t\t\t     simplify_gen_relational (cond_code,\n-\t\t\t\t\t\t\t\t      mode,\n-\t\t\t\t\t\t\t\t      VOIDmode,\n-\t\t\t\t\t\t\t\t      cond,\n-\t\t\t\t\t\t\t\t      cop1),\n+\t\t\t\t\t     gen_binary (cond_code, VOIDmode,\n+\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\t     true_rtx, false_rtx);\n \n \t      code = GET_CODE (x);\n@@ -3797,7 +3788,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t    }\n \n \t  if (inner)\n-\t    return simplify_gen_binary (code, mode, other, inner);\n+\t    return gen_binary (code, mode, other, inner);\n \t}\n     }\n \n@@ -3899,8 +3890,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n-\treturn simplify_gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t    constm1_rtx);\n+\treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n \n       temp = expand_compound_operation (XEXP (x, 0));\n \n@@ -4128,9 +4118,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n \t  in2 = XEXP (XEXP (x, 0), 1);\n-\t  return simplify_gen_binary (MINUS, mode, XEXP (x, 1),\n-\t\t\t\t      simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t\t\t   in1, in2));\n+\t  return gen_binary (MINUS, mode, XEXP (x, 1),\n+\t\t\t     gen_binary (MULT, mode, in1, in2));\n \t}\n \n       /* If we have (plus (plus (A const) B)), associate it so that CONST is\n@@ -4139,11 +4128,10 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t they are now checked elsewhere.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))\n-\treturn simplify_gen_binary (PLUS, mode,\n-\t\t\t   \t    simplify_gen_binary (PLUS, mode,\n-\t\t\t\t\t\t\t XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t\t\t XEXP (x, 1)),\n-\t\t\t\t    XEXP (XEXP (x, 0), 1));\n+\treturn gen_binary (PLUS, mode,\n+\t\t\t   gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t       XEXP (x, 1)),\n+\t\t\t   XEXP (XEXP (x, 0), 1));\n \n       /* (plus (xor (and <foo> (const_int pow2 - 1)) <c>) <-c>)\n \t when c is (const_int (pow2 + 1) / 2) is a sign extension of a\n@@ -4209,7 +4197,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      & nonzero_bits (XEXP (x, 1), mode)) == 0)\n \t{\n \t  /* Try to simplify the expression further.  */\n-\t  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n+\t  rtx tor = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n \t  temp = combine_simplify_rtx (tor, mode, in_dest);\n \n \t  /* If we could, great.  If not, do not go ahead with the IOR\n@@ -4249,10 +4237,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 1), 0), 0);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return simplify_gen_binary (PLUS, mode,\n-\t\t\t\t      simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t\t\t   in1, in2),\n-\t\t\t\t      XEXP (x, 0));\n+\t  return gen_binary (PLUS, mode, gen_binary (MULT, mode, in1, in2),\n+\t\t\t     XEXP (x, 0));\n \t}\n \n       /* Canonicalize (minus (neg A) (mult B C)) to\n@@ -4264,20 +4250,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 1), 0), mode);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return simplify_gen_binary (MINUS, mode,\n-\t\t\t\t      simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t\t\t   in1, in2),\n-\t\t\t\t      XEXP (XEXP (x, 0), 0));\n+\t  return gen_binary (MINUS, mode, gen_binary (MULT, mode, in1, in2),\n+\t\t\t     XEXP (XEXP (x, 0), 0));\n \t}\n \n       /* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for\n \t integers.  */\n       if (GET_CODE (XEXP (x, 1)) == PLUS && INTEGRAL_MODE_P (mode))\n-\treturn simplify_gen_binary (MINUS, mode,\n-\t\t\t\t    simplify_gen_binary (MINUS, mode,\n-\t\t\t\t\t\t\t XEXP (x, 0),\n-\t\t\t\t\t\t         XEXP (XEXP (x, 1), 0)),\n-\t\t\t\t    XEXP (XEXP (x, 1), 1));\n+\treturn gen_binary (MINUS, mode,\n+\t\t\t   gen_binary (MINUS, mode, XEXP (x, 0),\n+\t\t\t\t       XEXP (XEXP (x, 1), 0)),\n+\t\t\t   XEXP (XEXP (x, 1), 1));\n       break;\n \n     case MULT:\n@@ -4287,11 +4270,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n       if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t{\n-\t  rtx result = distribute_and_simplify_rtx (x);\n-\t  if (result)\n-\t    return result;\n-\t}\n+\t  x = apply_distributive_law\n+\t    (gen_binary (PLUS, mode,\n+\t\t\t gen_binary (MULT, mode,\n+\t\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (x, 1)),\n+\t\t\t gen_binary (MULT, mode,\n+\t\t\t\t     XEXP (XEXP (x, 0), 1),\n+\t\t\t\t     copy_rtx (XEXP (x, 1)))));\n \n+\t  if (GET_CODE (x) != MULT)\n+\t    return x;\n+\t}\n       /* Try simplify a*(b/c) as (a*b)/c.  */\n       if (FLOAT_MODE_P (mode) && flag_unsafe_math_optimizations\n \t  && GET_CODE (XEXP (x, 0)) == DIV)\n@@ -4300,7 +4289,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t       XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t       XEXP (x, 1));\n \t  if (tem)\n-\t    return simplify_gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n+\t    return gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n \t}\n       break;\n \n@@ -4380,9 +4369,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return simplify_gen_binary (XOR, mode,\n-\t\t\t\t\t  gen_lowpart (mode, op0),\n-\t\t\t\t\t  const1_rtx);\n+\t      return gen_binary (XOR, mode,\n+\t\t\t\t gen_lowpart (mode, op0),\n+\t\t\t\t const1_rtx);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n@@ -4625,8 +4614,7 @@ simplify_if_then_else (rtx x)\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-    return simplify_gen_relational (true_code, mode, VOIDmode,\n-\t\t\t\t    XEXP (cond, 0), XEXP (cond, 1));\n+    return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n \n   /* Also when the truth value has to be reversed.  */\n   if (comparison_p\n@@ -4776,16 +4764,16 @@ simplify_if_then_else (rtx x)\n       {\n       case GE:\n       case GT:\n-\treturn simplify_gen_binary (SMAX, mode, true_rtx, false_rtx);\n+\treturn gen_binary (SMAX, mode, true_rtx, false_rtx);\n       case LE:\n       case LT:\n-\treturn simplify_gen_binary (SMIN, mode, true_rtx, false_rtx);\n+\treturn gen_binary (SMIN, mode, true_rtx, false_rtx);\n       case GEU:\n       case GTU:\n-\treturn simplify_gen_binary (UMAX, mode, true_rtx, false_rtx);\n+\treturn gen_binary (UMAX, mode, true_rtx, false_rtx);\n       case LEU:\n       case LTU:\n-\treturn simplify_gen_binary (UMIN, mode, true_rtx, false_rtx);\n+\treturn gen_binary (UMIN, mode, true_rtx, false_rtx);\n       default:\n \tbreak;\n       }\n@@ -4898,14 +4886,12 @@ simplify_if_then_else (rtx x)\n \n       if (z)\n \t{\n-\t  temp = subst (simplify_gen_relational (true_code, m, VOIDmode,\n-\t\t\t\t\t\t cond_op0, cond_op1),\n+\t  temp = subst (gen_binary (true_code, m, cond_op0, cond_op1),\n \t\t\tpc_rtx, pc_rtx, 0, 0);\n-\t  temp = simplify_gen_binary (MULT, m, temp,\n-\t\t\t\t      simplify_gen_binary (MULT, m, c1,\n-\t\t\t\t\t\t\t   const_true_rtx));\n+\t  temp = gen_binary (MULT, m, temp,\n+\t\t\t     gen_binary (MULT, m, c1, const_true_rtx));\n \t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n-\t  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);\n+\t  temp = gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != NIL)\n \t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n@@ -5090,8 +5076,7 @@ simplify_set (rtx x)\n \t\t  PUT_CODE (*cc_use, old_code);\n \t\t  other_changed = 0;\n \n-\t\t  op0 = simplify_gen_binary (XOR, GET_MODE (op0),\n-\t\t\t\t\t     op0, GEN_INT (mask));\n+\t\t  op0 = gen_binary (XOR, GET_MODE (op0), op0, GEN_INT (mask));\n \t\t}\n \t    }\n \t}\n@@ -5255,19 +5240,18 @@ simplify_set (rtx x)\n \t       && rtx_equal_p (XEXP (false_rtx, 1), true_rtx))\n \tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 0), true_rtx = const0_rtx;\n \n-      term2 = simplify_gen_binary (AND, GET_MODE (src),\n-\t\t\t\t   XEXP (XEXP (src, 0), 0), true_rtx);\n-      term3 = simplify_gen_binary (AND, GET_MODE (src),\n-\t\t\t\t   simplify_gen_unary (NOT, GET_MODE (src),\n-\t\t\t\t\t\t       XEXP (XEXP (src, 0), 0),\n-\t\t\t\t\t\t       GET_MODE (src)),\n-\t\t\t\t   false_rtx);\n+      term2 = gen_binary (AND, GET_MODE (src),\n+\t\t\t  XEXP (XEXP (src, 0), 0), true_rtx);\n+      term3 = gen_binary (AND, GET_MODE (src),\n+\t\t\t  simplify_gen_unary (NOT, GET_MODE (src),\n+\t\t\t\t\t      XEXP (XEXP (src, 0), 0),\n+\t\t\t\t\t      GET_MODE (src)),\n+\t\t\t  false_rtx);\n \n       SUBST (SET_SRC (x),\n-\t     simplify_gen_binary (IOR, GET_MODE (src),\n-\t\t\t\t  simplify_gen_binary (IOR, GET_MODE (src),\n-\t\t\t\t\t\t       term1, term2),\n-\t\t\t\t  term3));\n+\t     gen_binary (IOR, GET_MODE (src),\n+\t\t\t gen_binary (IOR, GET_MODE (src), term1, term2),\n+\t\t\t term3));\n \n       src = SET_SRC (x);\n     }\n@@ -5302,31 +5286,29 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = simplify_gen_binary (AND, mode,\n-\t\t\t\t simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t\t     XEXP (op0, 1), mode),\n-\t\t\t\t op1);\n+\tx = gen_binary (AND, mode,\n+\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n+\t\t\top1);\n \n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = simplify_gen_binary (AND, mode,\n-\t\t\t\t simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t\t     XEXP (op0, 0), mode),\n-\t\t\t\t op1);\n+\tx = gen_binary (AND, mode,\n+\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n+\t\t\top1);\n \n       /* Similarly for (~(A ^ B)) & A.  */\n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n+\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n \n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n+\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n \n       /* We can call simplify_and_const_int only if we don't lose\n \t any (sign) bits when converting INTVAL (op1) to\n@@ -5346,9 +5328,8 @@ simplify_logical (rtx x)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && GET_CODE (op1) == CONST_INT\n \t      && (INTVAL (XEXP (op0, 1)) & INTVAL (op1)) != 0)\n-\t    return simplify_gen_binary (IOR, mode,\n-\t\t\t\t        simplify_gen_binary\n-\t\t\t\t\t  (AND, mode, XEXP (op0, 0),\n+\t    return gen_binary (IOR, mode,\n+\t\t\t       gen_binary (AND, mode, XEXP (op0, 0),\n \t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n \t\t\t\t\t\t    & ~INTVAL (op1))), op1);\n \n@@ -5367,16 +5348,54 @@ simplify_logical (rtx x)\n \t  && ! side_effects_p (XEXP (op0, 1)))\n \treturn op1;\n \n-      /* If we have any of (and (ior A B) C) or (and (xor A B) C),\n-\t apply the distributive law and then the inverse distributive\n-\t law to see if things simplify.  */\n-      if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR\n-          || GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n+      /* In the following group of tests (and those in case IOR below),\n+\t we start with some combination of logical operations and apply\n+\t the distributive law followed by the inverse distributive law.\n+\t Most of the time, this results in no change.  However, if some of\n+\t the operands are the same or inverses of each other, simplifications\n+\t will result.\n+\n+\t For example, (and (ior A B) (not B)) can occur as the result of\n+\t expanding a bit field assignment.  When we apply the distributive\n+\t law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n+\t which then simplifies to (and (A (not B))).\n+\n+\t If we have (and (ior A B) C), apply the distributive law and then\n+\t the inverse distributive law to see if things simplify.  */\n+\n+      if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR)\n \t{\n-\t  rtx result = distribute_and_simplify_rtx (x);\n-\t  if (result)\n-\t    return result;\n+\t  x = apply_distributive_law\n+\t    (gen_binary (GET_CODE (op0), mode,\n+\t\t\t gen_binary (AND, mode, XEXP (op0, 0), op1),\n+\t\t\t gen_binary (AND, mode, XEXP (op0, 1),\n+\t\t\t\t     copy_rtx (op1))));\n+\t  if (GET_CODE (x) != AND)\n+\t    return x;\n \t}\n+\n+      if (GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (GET_CODE (op1), mode,\n+\t\t       gen_binary (AND, mode, XEXP (op1, 0), op0),\n+\t\t       gen_binary (AND, mode, XEXP (op1, 1),\n+\t\t\t\t   copy_rtx (op0))));\n+\n+      /* Similarly, taking advantage of the fact that\n+\t (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n+\n+      if (GET_CODE (op0) == NOT && GET_CODE (op1) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (XOR, mode,\n+\t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 0)),\n+\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op0, 0)),\n+\t\t\t\t   XEXP (op1, 1))));\n+\n+      else if (GET_CODE (op1) == NOT && GET_CODE (op0) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (XOR, mode,\n+\t\t       gen_binary (IOR, mode, XEXP (op1, 0), XEXP (op0, 0)),\n+\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op1, 0)), XEXP (op0, 1))));\n       break;\n \n     case IOR:\n@@ -5397,11 +5416,28 @@ simplify_logical (rtx x)\n       /* If we have (ior (and A B) C), apply the distributive law and then\n \t the inverse distributive law to see if things simplify.  */\n \n-      if (GET_CODE (op0) == AND || GET_CODE (op1) == AND)\n+      if (GET_CODE (op0) == AND)\n \t{\n-\t  rtx result = distribute_and_simplify_rtx (x);\n-\t  if (result)\n-\t    return result;\n+\t  x = apply_distributive_law\n+\t    (gen_binary (AND, mode,\n+\t\t\t gen_binary (IOR, mode, XEXP (op0, 0), op1),\n+\t\t\t gen_binary (IOR, mode, XEXP (op0, 1),\n+\t\t\t\t     copy_rtx (op1))));\n+\n+\t  if (GET_CODE (x) != IOR)\n+\t    return x;\n+\t}\n+\n+      if (GET_CODE (op1) == AND)\n+\t{\n+\t  x = apply_distributive_law\n+\t    (gen_binary (AND, mode,\n+\t\t\t gen_binary (IOR, mode, XEXP (op1, 0), op0),\n+\t\t\t gen_binary (IOR, mode, XEXP (op1, 1),\n+\t\t\t\t     copy_rtx (op0))));\n+\n+\t  if (GET_CODE (x) != IOR)\n+\t    return x;\n \t}\n \n       /* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the\n@@ -5450,7 +5486,7 @@ simplify_logical (rtx x)\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (op0, mode)\n \t      & nonzero_bits (op1, mode)) == 0)\n-\treturn (simplify_gen_binary (IOR, mode, op0, op1));\n+\treturn (gen_binary (IOR, mode, op0, op1));\n \n       /* Convert (XOR (NOT x) (NOT y)) to (XOR x y).\n \t Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for\n@@ -5470,8 +5506,7 @@ simplify_logical (rtx x)\n \t  }\n \telse if (num_negated == 1)\n \t  return\n-\t    simplify_gen_unary (NOT, mode,\n-\t\t\t\tsimplify_gen_binary (XOR, mode, op0, op1),\n+\t    simplify_gen_unary (NOT, mode, gen_binary (XOR, mode, op0, op1),\n \t\t\t\tmode);\n       }\n \n@@ -5482,18 +5517,16 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == AND\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\treturn simplify_gen_binary (AND, mode,\n-\t\t\t\t    simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t\t\tXEXP (op0, 0), mode),\n-\t\t\t\t    op1);\n+\treturn gen_binary (AND, mode,\n+\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n+\t\t\t   op1);\n \n       else if (GET_CODE (op0) == AND\n \t       && rtx_equal_p (XEXP (op0, 0), op1)\n \t       && ! side_effects_p (op1))\n-\treturn simplify_gen_binary (AND, mode,\n-\t\t\t\t    simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t\t\tXEXP (op0, 1), mode),\n-\t\t\t\t    op1);\n+\treturn gen_binary (AND, mode,\n+\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n+\t\t\t   op1);\n \n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n \t comparison if STORE_FLAG_VALUE is 1.  */\n@@ -5762,7 +5795,7 @@ expand_field_assignment (rtx x)\n   rtx inner;\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n   int len;\n-  rtx mask, cleared, masked;\n+  rtx mask;\n   enum machine_mode compute_mode;\n \n   /* Loop until we find something we can't simplify.  */\n@@ -5800,11 +5833,10 @@ expand_field_assignment (rtx x)\n \t\t/* If position is ADJUST - X, new position is X.  */\n \t\tpos = XEXP (pos, 0);\n \t      else\n-\t\tpos = simplify_gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (\n-\t\t\t\t\t\t    GET_MODE (inner))\n-\t\t\t\t\t\t    - len),\n-\t\t\t\t\t   pos);\n+\t\tpos = gen_binary (MINUS, GET_MODE (pos),\n+\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n+\t\t\t\t\t   - len),\n+\t\t\t\t  pos);\n \t    }\n \t}\n \n@@ -5851,30 +5883,30 @@ expand_field_assignment (rtx x)\n \t}\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n-      if (len >= HOST_BITS_PER_WIDE_INT)\n+      if (len < HOST_BITS_PER_WIDE_INT)\n+\tmask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n+      else\n \tbreak;\n \n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      mask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n-      cleared = simplify_gen_binary (AND, compute_mode,\n-\t\t\t\t     simplify_gen_unary (NOT, compute_mode,\n-\t\t\t\t       simplify_gen_binary (ASHIFT,\n-\t\t\t\t\t\t\t    compute_mode,\n-\t\t\t\t\t\t\t    mask, pos),\n-\t\t\t\t       compute_mode),\n-\t\t\t\t     inner);\n-      masked = simplify_gen_binary (ASHIFT, compute_mode,\n-\t\t\t\t    simplify_gen_binary (\n-\t\t\t\t      AND, compute_mode,\n-\t\t\t\t      gen_lowpart (compute_mode, SET_SRC (x)),\n-\t\t\t\t      mask),\n-\t\t\t\t    pos);\n-\n-      x = gen_rtx_SET (VOIDmode, copy_rtx (inner),\n-\t\t       simplify_gen_binary (IOR, compute_mode,\n-\t\t\t\t\t    cleared, masked));\n+      x = gen_rtx_SET\n+\t(VOIDmode, copy_rtx (inner),\n+\t gen_binary (IOR, compute_mode,\n+\t\t     gen_binary (AND, compute_mode,\n+\t\t\t\t simplify_gen_unary (NOT, compute_mode,\n+\t\t\t\t\t\t     gen_binary (ASHIFT,\n+\t\t\t\t\t\t\t\t compute_mode,\n+\t\t\t\t\t\t\t\t mask, pos),\n+\t\t\t\t\t\t     compute_mode),\n+\t\t\t\t inner),\n+\t\t     gen_binary (ASHIFT, compute_mode,\n+\t\t\t\t gen_binary (AND, compute_mode,\n+\t\t\t\t\t     gen_lowpart\n+\t\t\t\t\t     (compute_mode, SET_SRC (x)),\n+\t\t\t\t\t     mask),\n+\t\t\t\t pos)));\n     }\n \n   return x;\n@@ -6330,8 +6362,8 @@ extract_left_shift (rtx x, int count)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n-\treturn simplify_gen_binary (code, mode, tem,\n-\t\t\t\t    GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n+\treturn gen_binary (code, mode, tem,\n+\t\t\t   GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n \n       break;\n \n@@ -6822,8 +6854,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t  && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n \t\tcval |= (HOST_WIDE_INT) -1 << width;\n \n-\t      y = simplify_gen_binary (AND, GET_MODE (x),\n-\t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n+\t      y = gen_binary (AND, GET_MODE (x), XEXP (x, 0), GEN_INT (cval));\n \t      if (rtx_cost (y, SET) < rtx_cost (x, SET))\n \t\tx = y;\n \t    }\n@@ -6915,10 +6946,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = GEN_INT ((INTVAL (XEXP (x, 1)) & mask)\n \t\t\t  << INTVAL (XEXP (XEXP (x, 0), 1)));\n-\t  temp = simplify_gen_binary (GET_CODE (x), GET_MODE (x),\n-\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n-\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x), temp,\n-\t\t\t\t   XEXP (XEXP (x, 0), 1));\n+\t  temp = gen_binary (GET_CODE (x), GET_MODE (x),\n+\t\t\t     XEXP (XEXP (x, 0), 0), temp);\n+\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp,\n+\t\t\t  XEXP (XEXP (x, 0), 1));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n@@ -6934,7 +6965,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\treg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = simplify_gen_binary (code, op_mode, op0, op1);\n+\tx = gen_binary (code, op_mode, op0, op1);\n       break;\n \n     case ASHIFT:\n@@ -6968,7 +6999,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\tmask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n-\tx = simplify_gen_binary (code, op_mode, op0, XEXP (x, 1));\n+\tx = gen_binary (code, op_mode, op0, XEXP (x, 1));\n       break;\n \n     case LSHIFTRT:\n@@ -6996,7 +7027,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  inner = force_to_mode (inner, op_mode, inner_mask, reg, next_select);\n \n \t  if (GET_MODE (x) != op_mode || inner != XEXP (x, 0))\n-\t    x = simplify_gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n+\t    x = gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n \t}\n \n       /* If we have (and (lshiftrt FOO C1) C2) where the combination of the\n@@ -7018,9 +7049,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  /* Must be more sign bit copies than the mask needs.  */\n \t  && ((int) num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t      >= exact_log2 (mask + 1)))\n-\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n-\t\t\t\t GEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n-\t\t\t\t\t  - exact_log2 (mask + 1)));\n+\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n+\t\t\tGEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n+\t\t\t\t - exact_log2 (mask + 1)));\n \n       goto shiftrt;\n \n@@ -7085,8 +7116,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* If MASK is 1, convert this to an LSHIFTRT.  This can be done\n \t even if the shift count isn't a constant.  */\n       if (mask == 1)\n-\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n-\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n+\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0), XEXP (x, 1));\n \n     shiftrt:\n \n@@ -7151,10 +7181,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = gen_int_mode (mask << INTVAL (XEXP (XEXP (x, 0), 1)),\n \t\t\t       GET_MODE (x));\n-\t  temp = simplify_gen_binary (XOR, GET_MODE (x),\n-\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n-\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n-\t\t\t\t   temp, XEXP (XEXP (x, 0), 1));\n+\t  temp = gen_binary (XOR, GET_MODE (x), XEXP (XEXP (x, 0), 0), temp);\n+\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp, XEXP (XEXP (x, 0), 1));\n \n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n@@ -7264,19 +7292,8 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t  else if (cond1 == 0)\n \t    true1 = copy_rtx (true1);\n \n-\t  if (COMPARISON_P (x))\n-\t    {\n-\t      *ptrue = simplify_gen_relational (code, mode, VOIDmode,\n-\t\t\t\t\t\ttrue0, true1);\n-\t      *pfalse = simplify_gen_relational (code, mode, VOIDmode,\n-\t\t\t\t\t         false0, false1);\n-\t     }\n-\t  else\n-\t    {\n-\t      *ptrue = simplify_gen_binary (code, mode, true0, true1);\n-\t      *pfalse = simplify_gen_binary (code, mode, false0, false1);\n-\t    }\n-\n+\t  *ptrue = gen_binary (code, mode, true0, true1);\n+\t  *pfalse = gen_binary (code, mode, false0, false1);\n \t  return cond0 ? cond0 : cond1;\n \t}\n \n@@ -7306,13 +7323,13 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n \t      && ! side_effects_p (x))\n \t    {\n-\t      *ptrue = simplify_gen_binary (MULT, mode, op0, const_true_rtx);\n-\t      *pfalse = simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t     (code == MINUS\n-\t\t\t\t\t      ? simplify_gen_unary (NEG, mode,\n-\t\t\t\t\t\t\t\t    op1, mode)\n-\t\t\t\t\t      : op1),\n-\t\t\t\t\t      const_true_rtx);\n+\t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n+\t      *pfalse = gen_binary (MULT, mode,\n+\t\t\t\t    (code == MINUS\n+\t\t\t\t     ? simplify_gen_unary (NEG, mode, op1,\n+\t\t\t\t\t\t\t   mode)\n+\t\t\t\t     : op1),\n+\t\t\t\t    const_true_rtx);\n \t      return cond0;\n \t    }\n \t}\n@@ -7816,8 +7833,8 @@ apply_distributive_law (rtx x)\n \t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD)\n \treturn x;\n \n-      tem = simplify_gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n-\t\t\t\t SUBREG_REG (lhs), SUBREG_REG (rhs));\n+      tem = gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n+\t\t\tSUBREG_REG (lhs), SUBREG_REG (rhs));\n       return gen_lowpart (GET_MODE (x), tem);\n \n     default:\n@@ -7843,7 +7860,7 @@ apply_distributive_law (rtx x)\n     return x;\n \n   /* Form the new inner operation, seeing if it simplifies first.  */\n-  tem = simplify_gen_binary (code, GET_MODE (x), lhs, rhs);\n+  tem = gen_binary (code, GET_MODE (x), lhs, rhs);\n \n   /* There is one exception to the general way of distributing:\n      (a | c) ^ (b | c) -> (a ^ b) & ~c  */\n@@ -7856,95 +7873,8 @@ apply_distributive_law (rtx x)\n   /* We may be able to continuing distributing the result, so call\n      ourselves recursively on the inner operation before forming the\n      outer operation, which we return.  */\n-  return simplify_gen_binary (inner_code, GET_MODE (x),\n-\t\t\t      apply_distributive_law (tem), other);\n-}\n-\n-/* See if X is of the form (* (+ a b) c), and if so convert to\n-   (+ (* a c) (* b c)) and try to simplify.\n-\n-   Most of the time, this results in no change.  However, if some of\n-   the operands are the same or inverses of each other, simplifications\n-   will result.\n-\n-   For example, (and (ior A B) (not B)) can occur as the result of\n-   expanding a bit field assignment.  When we apply the distributive\n-   law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n-   which then simplifies to (and (A (not B))).\n- \n-   Note that no checks happen on the validity of applying the inverse\n-   distributive law.  This is pointless since we can do it in the\n-   few places where this routine is called.  */\n-static rtx\n-distribute_and_simplify_rtx (rtx x)\n-{\n-  enum machine_mode mode;\n-  enum rtx_code outer, inner;\n-  rtx op0, op1, inner_op0, inner_op1, new_op0, new_op1;\n-\n-  mode = GET_MODE (x);\n-  outer = GET_CODE (x);\n-  op0 = XEXP (x, 0);\n-  op1 = XEXP (x, 1);\n-  if (ARITHMETIC_P (op0))\n-    {\n-      inner = GET_CODE (op0);\n-      inner_op0 = XEXP (op0, 0);\n-      inner_op1 = XEXP (op0, 1);\n-\n-      /* (and (xor B C) (not A)) == (xor (ior A B) (ior A C))  */\n-      if (outer == AND && inner == XOR && GET_CODE (op1) == NOT)\n-        {\n-\t  new_op0 = simplify_gen_binary (IOR, mode, inner_op0, op1);\n-          new_op1 = simplify_gen_binary (IOR, mode, inner_op1, op1);\n-          x = apply_distributive_law (simplify_gen_binary (XOR, mode,\n-\t\t\t\t\t\t\t   new_op0, new_op1));\n-\n-\t  if (GET_CODE (x) != AND)\n-\t    return x;\n-\t}\n-      else\n-\t{\n-          new_op0 = simplify_gen_binary (outer, mode, inner_op0, op1);\n-          new_op1 = simplify_gen_binary (outer, mode, inner_op1, op1);\n-          x = apply_distributive_law (simplify_gen_binary (inner, mode,\n-\t\t\t\t\t\t\t   new_op0, new_op1));\n-\n-\t  if (GET_CODE (x) != outer)\n-\t    return x;\n-\t}\n-    }\n-\n-  if (ARITHMETIC_P (op1))\n-    {\n-      inner = GET_CODE (op1);\n-      inner_op0 = XEXP (op1, 0);\n-      inner_op1 = XEXP (op1, 1);\n-\n-      /* (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n-      if (outer == AND && inner == XOR && GET_CODE (op0) == NOT)\n-        {\n-\t  new_op0 = simplify_gen_binary (IOR, mode, inner_op0, op0);\n-          new_op1 = simplify_gen_binary (IOR, mode, inner_op1, op0);\n-          x = apply_distributive_law (simplify_gen_binary (XOR, mode,\n-\t\t\t\t\t\t\t   new_op0, new_op1));\n-\n-\t  if (GET_CODE (x) != AND)\n-\t    return x;\n-\t}\n-      else\n-\t{\n-          new_op0 = simplify_gen_binary (outer, mode, op0, inner_op0);\n-          new_op1 = simplify_gen_binary (outer, mode, op0, inner_op1);\n-          x = apply_distributive_law (simplify_gen_binary (inner, mode,\n-\t\t\t\t\t\t\t   new_op0, new_op1));\n-\n-\t  if (GET_CODE (x) != outer)\n-\t    return x;\n-\t}\n-    }\n-\n-  return NULL_RTX;\n+  return gen_binary (inner_code, GET_MODE (x),\n+\t\t     apply_distributive_law (tem), other);\n }\n \f\n /* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done\n@@ -8011,15 +7941,11 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       gen_lowpart\n \t(mode,\n \t apply_distributive_law\n-\t (simplify_gen_binary (GET_CODE (varop), GET_MODE (varop),\n-\t\t\t       simplify_and_const_int (NULL_RTX,\n-\t\t\t\t\t\t       GET_MODE (varop),\n-\t\t\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t\t\t       constop),\n-\t\t\t       simplify_and_const_int (NULL_RTX,\n-\t\t\t\t\t\t       GET_MODE (varop),\n-\t\t\t\t\t\t       XEXP (varop, 1),\n-\t\t\t\t\t\t       constop))));\n+\t (gen_binary (GET_CODE (varop), GET_MODE (varop),\n+\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n+\t\t\t\t\t      XEXP (varop, 0), constop),\n+\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n+\t\t\t\t\t      XEXP (varop, 1), constop))));\n \n   /* If VAROP is PLUS, and the constant is a mask of low bite, distribute\n      the AND and see if one of the operands simplifies to zero.  If so, we\n@@ -8060,7 +7986,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       constop = trunc_int_for_mode (constop, mode);\n       /* See how much, if any, of X we can use.  */\n       if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-\tx = simplify_gen_binary (AND, mode, varop, GEN_INT (constop));\n+\tx = gen_binary (AND, mode, varop, GEN_INT (constop));\n \n       else\n \t{\n@@ -8579,10 +8505,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= simplify_gen_binary (ASHIFT, GET_MODE (varop),\n-\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n+\t\t= gen_binary (ASHIFT, GET_MODE (varop), XEXP (varop, 0),\n+\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8593,10 +8517,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n-\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n+\t\t= gen_binary (LSHIFTRT, GET_MODE (varop), XEXP (varop, 0),\n+\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8841,7 +8763,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     logical expression, make a new logical expression, and apply\n \t     the inverse distributive law.  This also can't be done\n \t     for some (ashiftrt (xor)).  */\n-\t  if (code != ASHIFTRT || GET_CODE (varop) != XOR\n+\t  if (code != ASHIFTRT || GET_CODE (varop)!= XOR\n \t      || 0 <= trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t  shift_mode))\n \t    {\n@@ -8850,8 +8772,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      rtx rhs = simplify_shift_const (NULL_RTX, code, shift_mode,\n \t\t\t\t\t      XEXP (varop, 1), count);\n \n-\t      varop = simplify_gen_binary (GET_CODE (varop), shift_mode,\n-\t\t\t\t\t   lhs, rhs);\n+\t      varop = gen_binary (GET_CODE (varop), shift_mode, lhs, rhs);\n \t      varop = apply_distributive_law (varop);\n \n \t      count = 0;\n@@ -9105,8 +9026,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n       else if (GET_RTX_CLASS (outer_op) == RTX_UNARY)\n \tx = simplify_gen_unary (outer_op, result_mode, x, result_mode);\n       else\n-\tx = simplify_gen_binary (outer_op, result_mode, x,\n-\t\t\t\t GEN_INT (outer_const));\n+\tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n     }\n \n   return x;\n@@ -9339,6 +9259,63 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n     }\n }\n \f\n+/* These routines make binary and unary operations by first seeing if they\n+   fold; if not, a new expression is allocated.  */\n+\n+static rtx\n+gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n+{\n+  rtx result;\n+  rtx tem;\n+\n+  if (GET_CODE (op0) == CLOBBER)\n+    return op0;\n+  else if (GET_CODE (op1) == CLOBBER)\n+    return op1;\n+  \n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n+      && swap_commutative_operands_p (op0, op1))\n+    tem = op0, op0 = op1, op1 = tem;\n+\n+  if (GET_RTX_CLASS (code) == RTX_COMPARE\n+      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n+    {\n+      enum machine_mode op_mode = GET_MODE (op0);\n+\n+      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get\n+\t just (REL_OP X Y).  */\n+      if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n+\t{\n+\t  op1 = XEXP (op0, 1);\n+\t  op0 = XEXP (op0, 0);\n+\t  op_mode = GET_MODE (op0);\n+\t}\n+\n+      if (op_mode == VOIDmode)\n+\top_mode = GET_MODE (op1);\n+      result = simplify_relational_operation (code, mode, op_mode, op0, op1);\n+    }\n+  else\n+    result = simplify_binary_operation (code, mode, op0, op1);\n+\n+  if (result)\n+    return result;\n+\n+  /* Put complex operands first and constants second.  */\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n+      && swap_commutative_operands_p (op0, op1))\n+    return gen_rtx_fmt_ee (code, mode, op1, op0);\n+\n+  /* If we are turning off bits already known off in OP0, we need not do\n+     an AND.  */\n+  else if (code == AND && GET_CODE (op1) == CONST_INT\n+\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t   && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n+    return op0;\n+\n+  return gen_rtx_fmt_ee (code, mode, op0, op1);\n+}\n+\f\n /* Simplify a comparison between *POP0 and *POP1 where CODE is the\n    comparison code that will be tested.\n \n@@ -10173,9 +10150,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t  && c1 != mask\n \t\t  && c1 != GET_MODE_MASK (tmode))\n \t\t{\n-\t\t  op0 = simplify_gen_binary (AND, tmode,\n-\t\t\t\t\t     SUBREG_REG (XEXP (op0, 0)),\n-\t\t\t\t\t     gen_int_mode (c1, tmode));\n+\t\t  op0 = gen_binary (AND, tmode,\n+\t\t\t\t    SUBREG_REG (XEXP (op0, 0)),\n+\t\t\t\t    gen_int_mode (c1, tmode));\n \t\t  op0 = gen_lowpart (mode, op0);\n \t\t  continue;\n \t\t}\n@@ -10319,12 +10296,12 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n \t      rtx add_const = XEXP (XEXP (op0, 0), 1);\n-\t      rtx new_const = simplify_gen_binary (ASHIFTRT, GET_MODE (op0),\n-\t\t\t\t\t\t   add_const, XEXP (op0, 1));\n+\t      rtx new_const = gen_binary (ASHIFTRT, GET_MODE (op0), add_const,\n+\t\t\t\t\t  XEXP (op0, 1));\n \n-\t      op0 = simplify_gen_binary (PLUS, tmode,\n-\t\t\t\t\t gen_lowpart (tmode, inner),\n-\t\t\t\t\t new_const);\n+\t      op0 = gen_binary (PLUS, tmode,\n+\t\t\t\tgen_lowpart (tmode, inner),\n+\t\t\t\tnew_const);\n \t      continue;\n \t    }\n \n@@ -10477,11 +10454,11 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t make a new AND in the proper mode.  */\n \t      if (GET_CODE (op0) == AND\n \t\t  && !have_insn_for (AND, mode))\n-\t\top0 = simplify_gen_binary (AND, tmode,\n-\t\t\t\t\t   gen_lowpart (tmode,\n-\t\t\t\t\t\t\tXEXP (op0, 0)),\n-\t\t\t\t\t   gen_lowpart (tmode,\n-\t\t\t\t\t\t\tXEXP (op0, 1)));\n+\t\top0 = gen_binary (AND, tmode,\n+\t\t\t\t  gen_lowpart (tmode,\n+\t\t\t\t\t       XEXP (op0, 0)),\n+\t\t\t\t  gen_lowpart (tmode,\n+\t\t\t\t\t       XEXP (op0, 1)));\n \n \t      op0 = gen_lowpart (tmode, op0);\n \t      if (zero_extended && GET_CODE (op1) == CONST_INT)\n@@ -10496,11 +10473,10 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (op1 == const0_rtx && (code == LT || code == GE)\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = simplify_gen_binary (AND, tmode,\n-\t\t\t\t\t gen_lowpart (tmode, op0),\n-\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t\t  << (GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t\t      - 1)));\n+\t      op0 = gen_binary (AND, tmode,\n+\t\t\t\tgen_lowpart (tmode, op0),\n+\t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n \t      code = (code == LT) ? NE : EQ;\n \t      break;\n \t    }\n@@ -10547,7 +10523,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n   if (reversed_code == UNKNOWN)\n     return NULL_RTX;\n   else\n-    return simplify_gen_relational (reversed_code, mode, VOIDmode, op0, op1);\n+    return gen_binary (reversed_code, mode, op0, op1);\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value"}]}