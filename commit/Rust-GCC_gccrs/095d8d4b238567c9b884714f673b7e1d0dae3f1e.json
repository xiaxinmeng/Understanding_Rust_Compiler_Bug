{"sha": "095d8d4b238567c9b884714f673b7e1d0dae3f1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1ZDhkNGIyMzg1NjdjOWI4ODQ3MTRmNjczYjdlMWQwZGFlM2YxZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-02-28T13:43:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-02-28T13:43:38Z"}, "message": "c-ada-spec.c (dump_ada_import): Use boolean and fix formatting.\n\n\t* c-ada-spec.c (dump_ada_import): Use boolean and fix formatting.\n\t(is_char_array): Fix formatting.\n\t(dump_template_types): Likewise.\n\t(dump_generic_ada_node): Rename into...\n\t(dump_ada_node): ...this.\n\t<POINTER_TYPE>: Remove superfluous space.  Use generic address for\n\tincomplete structures and not for empty structures.  Do not use it\n\twhen forward declarations are needed.\n\t(dump_forward_type): New function.\n\t(dump_nested_types): Remove FORWARD parameter.  Do not consider\n\tTREE_VISITED and do not generate a forward declaration.  Only dump\n\toriginal nested types for nested declaration.\n\t(dump_nested_type) <POINTER_TYPE>: Call dump_forward_type.\n\t<ARRAY_TYPE>: Likewise if the component type is an anonymous pointer.\n\t<RECORD_TYPE>: Do not consider TREE_VISITED.\n\t(dump_ada_declaration): Use booleans and fix formatting throughout.\n\t<TYPE_DECL>: Skip incomplete structures and not empty structures.\n\tCall dump_forward_type instead of dump_nested_types for a typedef.\n\tRemove superfluous check and adjust call to dump_nested_types.\n\t<POINTER_TYPE>: Call dump_forward_type and fall through.\n\t(dump_ada_struct_decl): Rename into...\n\t(dump_ada_structure): ...this.  Do not special-case empty structures.\n\nFrom-SVN: r258062", "tree": {"sha": "c9a1cefda5115aa238e70ce9067ae3c63d6f4706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a1cefda5115aa238e70ce9067ae3c63d6f4706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095d8d4b238567c9b884714f673b7e1d0dae3f1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095d8d4b238567c9b884714f673b7e1d0dae3f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095d8d4b238567c9b884714f673b7e1d0dae3f1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095d8d4b238567c9b884714f673b7e1d0dae3f1e/comments", "author": null, "committer": null, "parents": [{"sha": "9348eb677eb9e113ae7889faa5466723a307941f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9348eb677eb9e113ae7889faa5466723a307941f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9348eb677eb9e113ae7889faa5466723a307941f"}], "stats": {"total": 414, "additions": 234, "deletions": 180}, "files": [{"sha": "796ded2369624ec0eeaad746395cec4a5c793c94", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -1,3 +1,28 @@\n+2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (dump_ada_import): Use boolean and fix formatting.\n+\t(is_char_array): Fix formatting.\n+\t(dump_template_types): Likewise.\n+\t(dump_generic_ada_node): Rename into...\n+\t(dump_ada_node): ...this.\n+\t<POINTER_TYPE>: Remove superfluous space.  Use generic address for\n+\tincomplete structures and not for empty structures.  Do not use it\n+\twhen forward declarations are needed.\n+\t(dump_forward_type): New function.\n+\t(dump_nested_types): Remove FORWARD parameter.  Do not consider\n+\tTREE_VISITED and do not generate a forward declaration.  Only dump\n+\toriginal nested types for nested declaration.\n+\t(dump_nested_type) <POINTER_TYPE>: Call dump_forward_type.\n+\t<ARRAY_TYPE>: Likewise if the component type is an anonymous pointer.\n+\t<RECORD_TYPE>: Do not consider TREE_VISITED.\n+\t(dump_ada_declaration): Use booleans and fix formatting throughout.\n+\t<TYPE_DECL>: Skip incomplete structures and not empty structures.\n+\tCall dump_forward_type instead of dump_nested_types for a typedef.\n+\tRemove superfluous check and adjust call to dump_nested_types.\n+\t<POINTER_TYPE>: Call dump_forward_type and fall through.\n+\t(dump_ada_struct_decl): Rename into...\n+\t(dump_ada_structure): ...this.  Do not special-case empty structures.\n+\n 2018-02-27  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/83871"}, {"sha": "69fd8d50157ad7b636cba1d0a0701b1c81002cf6", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 159, "deletions": 180, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -1590,8 +1590,9 @@ static void\n dump_ada_import (pretty_printer *buffer, tree t)\n {\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n-  int is_stdcall = TREE_CODE (t) == FUNCTION_DECL &&\n-    lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (TREE_TYPE (t)));\n+  const bool is_stdcall\n+    = TREE_CODE (t) == FUNCTION_DECL\n+      && lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (TREE_TYPE (t)));\n \n   if (is_stdcall)\n     pp_string (buffer, \"pragma Import (Stdcall, \");\n@@ -2209,9 +2210,9 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       else if (TREE_CODE (TREE_TYPE (node)) == FUNCTION_TYPE)\n \t{\n \t  if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (node))))\n-\t    pp_string (buffer, \"access procedure \");\n+\t    pp_string (buffer, \"access procedure\");\n \t  else\n-\t    pp_string (buffer, \"access function \");\n+\t    pp_string (buffer, \"access function\");\n \n \t  dump_ada_function_declaration\n \t    (buffer, node, false, false, false, spc + INDENT_INCR);\n@@ -2229,7 +2230,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t}\n       else\n \t{\n-\t  int is_access = false;\n+\t  bool is_access = false;\n \t  unsigned int quals = TYPE_QUALS (TREE_TYPE (node));\n \n \t  if (VOID_TYPE_P (TREE_TYPE (node)))\n@@ -2266,24 +2267,12 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t      else\n \t\t{\n \t\t  tree type_name = TYPE_NAME (TREE_TYPE (node));\n-\t\t  tree decl = get_underlying_decl (TREE_TYPE (node));\n-\t\t  tree enclosing_decl = get_underlying_decl (type);\n \n-\t\t  /* For now, handle access-to-access, access-to-empty-struct\n-\t\t     or access-to-incomplete as opaque system.address.  */\n+\t\t  /* For now, handle access-to-access and access-to-incomplete\n+\t\t     as opaque System.Address.  */\n \t\t  if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE\n \t\t      || (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node))\n-\t\t\t  && !TYPE_FIELDS (TREE_TYPE (node)))\n-\t\t      || !decl\n-\t\t      || (!enclosing_decl\n-\t\t\t  && !TREE_VISITED (decl)\n-\t\t\t  && DECL_SOURCE_FILE (decl) == current_source_file)\n-\t\t      || (enclosing_decl\n-\t\t\t  && !TREE_VISITED (decl)\n-\t\t\t  && DECL_SOURCE_FILE (decl)\n-\t\t\t       == DECL_SOURCE_FILE (enclosing_decl)\n-\t\t\t  && decl_sloc (decl, true)\n-\t\t\t       > decl_sloc (enclosing_decl, true)))\n+\t\t\t  && !COMPLETE_TYPE_P (TREE_TYPE (node))))\n \t\t    {\n \t\t      if (package_prefix)\n \t\t\t{\n@@ -2405,7 +2394,6 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (DECL_IS_BUILTIN (node))\n \t{\n \t  /* Don't print the declaration of built-in types.  */\n-\n \t  if (name_only)\n \t    {\n \t      /* If we're in the middle of a declaration, defaults to\n@@ -2503,12 +2491,56 @@ dump_ada_methods (pretty_printer *buffer, tree node, int spc)\n   return 1;\n }\n \n+/* Dump in BUFFER a forward declaration for TYPE present inside T.\n+   SPC is the indentation level.  */\n+\n+static void\n+dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)\n+{\n+  tree decl = get_underlying_decl (type);\n+\n+  /* Anonymous pointer and function types.  */\n+  if (!decl)\n+    {\n+      if (TREE_CODE (type) == POINTER_TYPE)\n+\tdump_forward_type (buffer, TREE_TYPE (type), t, spc);\n+      else if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t{\n+\t  function_args_iterator args_iter;\n+\t  tree arg;\n+\t  dump_forward_type (buffer, TREE_TYPE (type), t, spc);\n+\t  FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n+\t    dump_forward_type (buffer, arg, t, spc);\n+\t}\n+      return;\n+    }\n+\n+  if (DECL_IS_BUILTIN (decl) || TREE_VISITED (decl))\n+    return;\n+\n+  /* We'll need to generate a completion at some point.  */\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n+      && !COMPLETE_TYPE_P (TREE_TYPE (decl)))\n+    return;\n+\n+  /* Forward declarations are only needed within a given file.  */\n+  if (DECL_SOURCE_FILE (decl) != DECL_SOURCE_FILE (t))\n+    return;\n+\n+  /* Generate an incomplete type declaration.  */\n+  pp_string (buffer, \"type \");\n+  dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n+  pp_semicolon (buffer);\n+  newline_and_indent (buffer, spc);\n+\n+  /* Only one incomplete declaration is legal for a given type.  */\n+  TREE_VISITED (decl) = 1;\n+}\n+\n static void dump_nested_type (pretty_printer *, tree, tree, tree, int);\n \n /* Dump in BUFFER anonymous types nested inside T's definition.\n-   PARENT is the parent node of T.\n-   FORWARD indicates whether a forward declaration of T should be generated.\n-   SPC is the indentation level.\n+   PARENT is the parent node of T.  SPC is the indentation level.\n \n    In C anonymous nested tagged types have no name whereas in C++ they have\n    one.  In C their TYPE_DECL is at top level whereas in C++ it is nested.\n@@ -2520,46 +2552,29 @@ static void dump_nested_type (pretty_printer *, tree, tree, tree, int);\n    pass on the nested TYPE_DECLs and a second pass on the unnamed types.  */\n \n static void\n-dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n-\t\t   int spc)\n+dump_nested_types (pretty_printer *buffer, tree t, tree parent, int spc)\n {\n   tree type, field;\n \n-  /* Avoid recursing over the same tree.  */\n-  if (TREE_VISITED (t))\n-    return;\n-\n   /* Find possible anonymous pointers/arrays/structs/unions recursively.  */\n   type = TREE_TYPE (t);\n   if (type == NULL_TREE)\n     return;\n \n-  if (forward)\n-    {\n-      pp_string (buffer, \"type \");\n-      dump_generic_ada_node (buffer, t, t, spc, false, true);\n-      pp_semicolon (buffer);\n-      newline_and_indent (buffer, spc);\n-      TREE_VISITED (t) = 1;\n-    }\n-\n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == TYPE_DECL\n \t&& DECL_NAME (field) != DECL_NAME (t)\n+\t&& !DECL_ORIGINAL_TYPE (field)\n \t&& TYPE_NAME (TREE_TYPE (field)) != TYPE_NAME (type))\n       dump_nested_type (buffer, field, t, parent, spc);\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL && !TYPE_NAME (TREE_TYPE (field)))\n       dump_nested_type (buffer, field, t, parent, spc);\n-\n-  TREE_VISITED (t) = 1;\n }\n \n /* Dump in BUFFER the anonymous type of FIELD inside T.\n-   PARENT is the parent node of T.\n-   FORWARD indicates whether a forward declaration of T should be generated.\n-   SPC is the indentation level.  */\n+   PARENT is the parent node of T.  SPC is the indentation level.  */\n \n static void\n dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n@@ -2572,29 +2587,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n     {\n     case POINTER_TYPE:\n       tmp = TREE_TYPE (field_type);\n-\n-      if (TREE_CODE (tmp) == FUNCTION_TYPE)\n-\tfor (tmp = TREE_TYPE (tmp);\n-\t     tmp && TREE_CODE (tmp) == POINTER_TYPE;\n-\t     tmp = TREE_TYPE (tmp))\n-\t  ;\n-\n-      decl = get_underlying_decl (tmp);\n-      if (decl\n-\t  && !DECL_IS_BUILTIN (decl)\n-\t  && (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n-\t      || TYPE_FIELDS (TREE_TYPE (decl)))\n-\t  && !TREE_VISITED (decl)\n-\t  && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)\n-\t  && decl_sloc (decl, true) > decl_sloc (t, true))\n-\t{\n-\t  /* Generate forward declaration.  */\n-\t  pp_string (buffer, \"type \");\n-\t  dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n-\t  pp_semicolon (buffer);\n-\t  newline_and_indent (buffer, spc);\n-\t  TREE_VISITED (decl) = 1;\n-\t}\n+      dump_forward_type (buffer, tmp, t, spc);\n       break;\n \n     case ARRAY_TYPE:\n@@ -2608,6 +2601,8 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  dump_nested_type (buffer, decl, t, parent, spc);\n \t  TREE_VISITED (decl) = 1;\n \t}\n+      else if (!decl && TREE_CODE (tmp) == POINTER_TYPE)\n+\tdump_forward_type (buffer, TREE_TYPE (tmp), t, spc);\n \n       /* Special case char arrays.  */\n       if (is_char_array (field))\n@@ -2623,16 +2618,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      if (TYPE_NAME (TREE_TYPE (t)) && !TREE_VISITED (t))\n-\t{\n-\t  pp_string (buffer, \"type \");\n-\t  dump_generic_ada_node (buffer, t, parent, spc, false, true);\n-\t  pp_semicolon (buffer);\n-\t  newline_and_indent (buffer, spc);\n-\t}\n-\n-      TREE_VISITED (t) = 1;\n-      dump_nested_types (buffer, field, t, false, spc);\n+      dump_nested_types (buffer, field, t, spc);\n \n       pp_string (buffer, \"type \");\n \n@@ -2724,17 +2710,18 @@ type_name (tree t)\n static int\n dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n {\n-  int is_var = 0, need_indent = 0;\n-  int is_class = false;\n+  bool is_var = false;\n+  bool need_indent = false;\n+  bool is_class = false;\n   tree name = TYPE_NAME (TREE_TYPE (t));\n   tree decl_name = DECL_NAME (t);\n   tree orig = NULL_TREE;\n \n   if (cpp_check && cpp_check (t, IS_TEMPLATE))\n     return dump_ada_template (buffer, t, spc);\n \n+  /* Skip enumeral values: will be handled as part of the type itself.  */\n   if (TREE_CODE (t) == CONST_DECL && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n-    /* Skip enumeral values: will be handled as part of the type itself.  */\n     return 0;\n \n   if (TREE_CODE (t) == TYPE_DECL)\n@@ -2759,16 +2746,15 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t      INDENT (spc);\n \n-\t      if (RECORD_OR_UNION_TYPE_P (typ) && !TYPE_FIELDS (typ))\n+\t      if (RECORD_OR_UNION_TYPE_P (typ) && !COMPLETE_TYPE_P (typ))\n \t\t{\n-\t\t  pp_string (buffer, \"--  skipped empty struct \");\n+\t\t  pp_string (buffer, \"--  skipped incomplete struct \");\n \t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (RECORD_OR_UNION_TYPE_P (typ)\n-\t\t      && DECL_SOURCE_FILE (stub) == current_source_file)\n-\t\t    dump_nested_types (buffer, stub, stub, true, spc);\n+\t\t  if (RECORD_OR_UNION_TYPE_P (typ))\n+\t\t    dump_forward_type (buffer, stub, t, spc);\n \n \t\t  pp_string (buffer, \"subtype \");\n \t\t  dump_generic_ada_node (buffer, t, type, spc, false, true);\n@@ -2803,11 +2789,9 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t{\n \t  case RECORD_TYPE:\n \t  case UNION_TYPE:\n-\t    /* Skip empty structs (typically forward references to real\n-\t       structs).  */\n-\t    if (!TYPE_FIELDS (TREE_TYPE (t)))\n+\t    if (!COMPLETE_TYPE_P (TREE_TYPE (t)))\n \t      {\n-\t\tpp_string (buffer, \"--  skipped empty struct \");\n+\t\tpp_string (buffer, \"--  skipped incomplete struct \");\n \t\tdump_generic_ada_node (buffer, t, type, spc, false, true);\n \t\treturn 1;\n \t      }\n@@ -2822,11 +2806,11 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\treturn 1;\n \t      }\n \n-\t    if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))\n+\t    if (orig && TYPE_NAME (orig))\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      {\n-\t\tdump_nested_types (buffer, t, t, false, spc);\n+\t\tdump_nested_types (buffer, t, t, spc);\n \n                 if (separate_class_package (t))\n \t\t  {\n@@ -2842,11 +2826,13 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      }\n \t    break;\n \n-\t  case ARRAY_TYPE:\n \t  case POINTER_TYPE:\n \t  case REFERENCE_TYPE:\n-\t    if ((orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))\n-\t\t|| is_char_array (t))\n+\t    dump_forward_type (buffer, TREE_TYPE (TREE_TYPE (t)), t, spc);\n+\t    /* fallthrough */\n+\n+\t  case ARRAY_TYPE:\n+\t    if ((orig && TYPE_NAME (orig)) || is_char_array (t))\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      pp_string (buffer, \"type \");\n@@ -2877,7 +2863,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  && *IDENTIFIER_POINTER (decl_name) == '_')\n \treturn 0;\n \n-      need_indent = 1;\n+      need_indent = true;\n     }\n \n   /* Print the type and name.  */\n@@ -2893,7 +2879,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t{\n \t  pp_string (buffer, \" is \");\n \n-\t  if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))\n+\t  if (orig && TYPE_NAME (orig))\n \t    dump_generic_ada_node\n \t      (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n@@ -2904,7 +2890,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  tree tmp = TYPE_NAME (TREE_TYPE (t));\n \n \t  if (spc == INDENT_INCR || TREE_STATIC (t))\n-\t    is_var = 1;\n+\t    is_var = true;\n \n \t  pp_string (buffer, \" : \");\n \n@@ -3027,21 +3013,19 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n       return 1;\n     }\n-  else if (TREE_CODE (t) == TYPE_DECL && !DECL_ORIGINAL_TYPE (t))\n+  else if (TREE_CODE (t) == TYPE_DECL && !orig)\n     {\n-      int is_interface = 0;\n-      int is_abstract_record = 0;\n+      bool is_interface = false;\n+      bool is_abstract_record = false;\n \n       if (need_indent)\n \tINDENT (spc);\n \n-      /* Anonymous structs/unions */\n+      /* Anonymous structs/unions.  */\n       dump_generic_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \n       if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n-\t{\n-\t  pp_string (buffer, \" (discr : unsigned := 0)\");\n-\t}\n+\tpp_string (buffer, \" (discr : unsigned := 0)\");\n \n       pp_string (buffer, \" is \");\n \n@@ -3061,18 +3045,18 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      if (TREE_CODE (fld) == FIELD_DECL)\n \t\t{\n \t\t  if (!has_fields && DECL_VIRTUAL_P (fld))\n-\t\t    is_interface = 1;\n+\t\t    is_interface = true;\n \t\t  else\n-\t\t    is_interface = 0;\n+\t\t    is_interface = false;\n \t\t  has_fields = true;\n \t\t}\n \t      else if (TREE_CODE (fld) == FUNCTION_DECL\n \t\t       && !DECL_ARTIFICIAL (fld))\n \t\t{\n \t\t  if (cpp_check (fld, IS_ABSTRACT))\n-\t\t    is_abstract_record = 1;\n+\t\t    is_abstract_record = true;\n \t\t  else\n-\t\t    is_interface = 0;\n+\t\t    is_interface = false;\n \t\t}\n \t    }\n \t}\n@@ -3110,8 +3094,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n-\t  tree orig = DECL_ORIGINAL_TYPE (t);\n-\t  int is_subtype = orig && TYPE_NAME (orig) && orig != TREE_TYPE (t);\n+\t  const bool is_subtype = TYPE_NAME (orig);\n \n \t  if (!is_subtype && TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n@@ -3123,7 +3106,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       else\n \t{\n \t  if (spc == INDENT_INCR || TREE_STATIC (t))\n-\t    is_var = 1;\n+\t    is_var = true;\n \n \t  pp_string (buffer, \" : \");\n \n@@ -3202,96 +3185,92 @@ dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \n   bitfield_used = false;\n \n-  if (TYPE_FIELDS (node))\n-    {\n-      /* Print the contents of the structure.  */\n-      pp_string (buffer, \"record\");\n+  /* Print the contents of the structure.  */\n+  pp_string (buffer, \"record\");\n \n-      if (is_union)\n-\t{\n-\t  newline_and_indent (buffer, spc + INDENT_INCR);\n-\t  pp_string (buffer, \"case discr is\");\n-\t  field_spc = spc + INDENT_INCR * 3;\n-\t}\n+  if (is_union)\n+    {\n+      newline_and_indent (buffer, spc + INDENT_INCR);\n+      pp_string (buffer, \"case discr is\");\n+      field_spc = spc + INDENT_INCR * 3;\n+    }\n \n-      pp_newline (buffer);\n+  pp_newline (buffer);\n \n-      /* Print the non-static fields of the structure.  */\n-      for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n+  /* Print the non-static fields of the structure.  */\n+  for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n+    {\n+      /* Add parent field if needed.  */\n+      if (!DECL_NAME (tmp))\n \t{\n-\t  /* Add parent field if needed.  */\n-\t  if (!DECL_NAME (tmp))\n+\t  if (!is_tagged_type (TREE_TYPE (tmp)))\n \t    {\n-\t      if (!is_tagged_type (TREE_TYPE (tmp)))\n+\t      if (!TYPE_NAME (TREE_TYPE (tmp)))\n+\t\tdump_ada_declaration (buffer, tmp, type, field_spc);\n+\t      else\n \t\t{\n-\t\t  if (!TYPE_NAME (TREE_TYPE (tmp)))\n-\t\t    dump_ada_declaration (buffer, tmp, type, field_spc);\n+\t\t  INDENT (field_spc);\n+\n+\t\t  if (field_num == 0)\n+\t\t    pp_string (buffer, \"parent : aliased \");\n \t\t  else\n \t\t    {\n-\t\t      INDENT (field_spc);\n-\n-\t\t      if (field_num == 0)\n-\t\t\tpp_string (buffer, \"parent : aliased \");\n-\t\t      else\n-\t\t\t{\n-\t\t\t  sprintf (buf, \"field_%d : aliased \", field_num + 1);\n-\t\t\t  pp_string (buffer, buf);\n-\t\t\t}\n-\t\t      dump_ada_decl_name\n-\t\t\t(buffer, TYPE_NAME (TREE_TYPE (tmp)), false);\n-\t\t      pp_semicolon (buffer);\n+\t\t      sprintf (buf, \"field_%d : aliased \", field_num + 1);\n+\t\t      pp_string (buffer, buf);\n \t\t    }\n-\t\t  pp_newline (buffer);\n-\t\t  field_num++;\n+\t\t  dump_ada_decl_name\n+\t\t    (buffer, TYPE_NAME (TREE_TYPE (tmp)), false);\n+\t\t  pp_semicolon (buffer);\n \t\t}\n+\n+\t      pp_newline (buffer);\n+\t      field_num++;\n \t    }\n-\t  else if (TREE_CODE (tmp) == FIELD_DECL)\n+\t}\n+      else if (TREE_CODE (tmp) == FIELD_DECL)\n+\t{\n+\t  /* Skip internal virtual table field.  */\n+\t  if (!DECL_VIRTUAL_P (tmp))\n \t    {\n-\t      /* Skip internal virtual table field.  */\n-\t      if (!DECL_VIRTUAL_P (tmp))\n+\t      if (is_union)\n \t\t{\n-\t\t  if (is_union)\n-\t\t    {\n-\t\t      if (TREE_CHAIN (tmp)\n-\t\t\t  && TREE_TYPE (TREE_CHAIN (tmp)) != node\n-\t\t\t  && TREE_CODE (TREE_CHAIN (tmp)) != TYPE_DECL)\n-\t\t\tsprintf (buf, \"when %d =>\", field_num);\n-\t\t      else\n-\t\t\tsprintf (buf, \"when others =>\");\n+\t\t  if (TREE_CHAIN (tmp)\n+\t\t      && TREE_TYPE (TREE_CHAIN (tmp)) != node\n+\t\t      && TREE_CODE (TREE_CHAIN (tmp)) != TYPE_DECL)\n+\t\t    sprintf (buf, \"when %d =>\", field_num);\n+\t\t  else\n+\t\t    sprintf (buf, \"when others =>\");\n \n-\t\t      INDENT (spc + INDENT_INCR * 2);\n-\t\t      pp_string (buffer, buf);\n-\t\t      pp_newline (buffer);\n-\t\t    }\n+\t\t  INDENT (spc + INDENT_INCR * 2);\n+\t\t  pp_string (buffer, buf);\n+\t\t  pp_newline (buffer);\n+\t\t}\n \n-\t\t  if (dump_ada_declaration (buffer, tmp, type, field_spc))\n-\t\t    {\n-\t\t      pp_newline (buffer);\n-\t\t      field_num++;\n-\t\t    }\n+\t      if (dump_ada_declaration (buffer, tmp, type, field_spc))\n+\t\t{\n+\t\t  pp_newline (buffer);\n+\t\t  field_num++;\n \t\t}\n \t    }\n \t}\n+    }\n \n-      if (is_union)\n-\t{\n-\t  INDENT (spc + INDENT_INCR);\n-\t  pp_string (buffer, \"end case;\");\n-\t  pp_newline (buffer);\n-\t}\n-\n-      if (field_num == 0)\n-\t{\n-\t  INDENT (spc + INDENT_INCR);\n-\t  pp_string (buffer, \"null;\");\n-\t  pp_newline (buffer);\n-\t}\n+  if (is_union)\n+    {\n+      INDENT (spc + INDENT_INCR);\n+      pp_string (buffer, \"end case;\");\n+      pp_newline (buffer);\n+    }\n \n-      INDENT (spc);\n-      pp_string (buffer, \"end record;\");\n+  if (field_num == 0)\n+    {\n+      INDENT (spc + INDENT_INCR);\n+      pp_string (buffer, \"null;\");\n+      pp_newline (buffer);\n     }\n-  else\n-    pp_string (buffer, \"null record;\");\n+\n+  INDENT (spc);\n+  pp_string (buffer, \"end record;\");\n \n   newline_and_indent (buffer, spc);\n "}, {"sha": "a464fbd2ed975d1c38e2f5ac7ce575514ec2b682", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -1,3 +1,9 @@\n+2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-c++-common/dump-ada-spec-8.c: New test.\n+\t* c-c++-common/dump-ada-spec-9.c: Likewise.\n+\t* c-c++-common/dump-ada-spec-10.c: Likewise.\n+\n 2018-02-28  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/84607"}, {"sha": "c6615e7d2d077625bf35cbf26c3319871c9f0442", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-10.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-10.c?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+typedef struct T *My_Ptr1;\n+\n+int foo1 (My_Ptr1);\n+\n+typedef struct T *My_Ptr2;\n+\n+int foo2 (My_Ptr2);\n+\n+struct T { int i; };\n+\n+/* { dg-final { scan-ada-spec-not \"System.Address\" } } */\n+/* { dg-final { cleanup-ada-spec } } */"}, {"sha": "9b97f5fe4e14497101061e6c3d7848ad184b62e8", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-8.c?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec -w\" } */\n+\n+typedef struct T {} My_T;\n+\n+int foo (My_T *t);\n+\n+\n+struct S1;\n+\n+struct S2 { struct S1 *s; };\n+\n+struct S1 {};\n+\n+/* { dg-final { scan-ada-spec-not \"System.Address\" } } */\n+/* { dg-final { cleanup-ada-spec } } */"}, {"sha": "e38409357eeacca2ded7833c6f9b0e127dc79567", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-9.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d8d4b238567c9b884714f673b7e1d0dae3f1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-9.c?ref=095d8d4b238567c9b884714f673b7e1d0dae3f1e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+typedef struct T My_T;\n+\n+int foo1 (My_T *);\n+\n+int foo2 (My_T *);\n+\n+struct T { int i; };\n+\n+/* { dg-final { scan-ada-spec-not \"System.Address\" } } */\n+/* { dg-final { cleanup-ada-spec } } */"}]}