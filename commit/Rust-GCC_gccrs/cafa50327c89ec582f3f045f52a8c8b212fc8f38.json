{"sha": "cafa50327c89ec582f3f045f52a8c8b212fc8f38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmYTUwMzI3Yzg5ZWM1ODJmM2YwNDVmNTJhOGM4YjIxMmZjOGYzOA==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-11-07T03:16:49Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-11-07T03:16:49Z"}, "message": "re PR libgcj/12231 ([win32] Console applications spawned via Runtime.exec( ) in a GUI application flash console window)\n\n\tPR libgcj/12231\n\t* java/lang/Win32Process.java (hasExited) Changed from\n\tpublic to private.\n\t(startProcess): Likewise.\n\t(cleanup): Likewise.\n\t* java/lang/natWin32Process.cc (cleanup) Don't close\n\tinput, output and error streams.\n\t(ChildProcessPipe): New helper class.\n\t(startProcess): Refactored to use ChildProcessPipe.\n\tUse CREATE_NO_WINDOW when launching child process.\n\nFrom-SVN: r73326", "tree": {"sha": "a0b583d9b121a54cedc52e2514152a8bf66f5244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0b583d9b121a54cedc52e2514152a8bf66f5244"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cafa50327c89ec582f3f045f52a8c8b212fc8f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafa50327c89ec582f3f045f52a8c8b212fc8f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cafa50327c89ec582f3f045f52a8c8b212fc8f38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafa50327c89ec582f3f045f52a8c8b212fc8f38/comments", "author": null, "committer": null, "parents": [{"sha": "bbf76ec06cbb846464bbb3701280167d0319b47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf76ec06cbb846464bbb3701280167d0319b47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf76ec06cbb846464bbb3701280167d0319b47b"}], "stats": {"total": 204, "additions": 130, "deletions": 74}, "files": [{"sha": "c1842dc275d2aab03649e650227b2d36b1cb5ba1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cafa50327c89ec582f3f045f52a8c8b212fc8f38", "patch": "@@ -1,3 +1,16 @@\n+2003-11-06  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\tPR libgcj/12231\n+\t* java/lang/Win32Process.java (hasExited) Changed from\n+\tpublic to private.\n+\t(startProcess): Likewise.\n+\t(cleanup): Likewise.\n+\t* java/lang/natWin32Process.cc (cleanup) Don't close\n+\tinput, output and error streams.\n+\t(ChildProcessPipe): New helper class.\n+\t(startProcess): Refactored to use ChildProcessPipe.\n+\tUse CREATE_NO_WINDOW when launching child process.\n+\n 2003-11-06  Mohan Embar  <gnustuff@thisiscool.com>\n \n \t* include/win32.h (_Jv_platform_close_on_exec): Changed"}, {"sha": "b0ef487c2048fd8a2bfe849faf05f0e72ce9fce1", "filename": "libjava/java/lang/Win32Process.java", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2Fjava%2Flang%2FWin32Process.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2Fjava%2Flang%2FWin32Process.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FWin32Process.java?ref=cafa50327c89ec582f3f045f52a8c8b212fc8f38", "patch": "@@ -28,8 +28,6 @@ final class ConcreteProcess extends Process\n {\n   public native void destroy ();\n \n-  public native boolean hasExited ();\n-\n   public int exitValue ()\n   {\n     if (! hasExited ())\n@@ -55,13 +53,6 @@ public OutputStream getOutputStream ()\n \n   public native int waitFor () throws InterruptedException;\n \n-  public native void startProcess (String[] progarray,\n-\t\t\t\t   String[] envp,\n-\t\t\t\t   File dir)\n-    throws IOException;\n-\n-  public native void cleanup ();\n-\n   public ConcreteProcess (String[] progarray,\n                           String[] envp,\n                           File dir)\n@@ -89,4 +80,11 @@ public ConcreteProcess (String[] progarray,\n \n   // Exit code of the child if it has exited.\n   private int exitCode;\n+\n+  private native boolean hasExited ();\n+  private native void startProcess (String[] progarray,\n+           String[] envp,\n+           File dir)\n+    throws IOException;\n+  private native void cleanup ();\n }"}, {"sha": "b687a0e0abe73814f0f22390d69c33e9d1970c36", "filename": "libjava/java/lang/natWin32Process.cc", "status": "modified", "additions": 110, "deletions": 65, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafa50327c89ec582f3f045f52a8c8b212fc8f38/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatWin32Process.cc?ref=cafa50327c89ec582f3f045f52a8c8b212fc8f38", "patch": "@@ -29,23 +29,29 @@ details.  */\n void\n java::lang::ConcreteProcess::cleanup (void)\n {\n-  if (inputStream != NULL)\n-    {\n-      inputStream->close ();\n-      inputStream = NULL;\n-    }\n-\n-  if (outputStream != NULL)\n-    {\n-      outputStream->close ();\n-      outputStream = NULL;\n-    }\n-\n-  if (errorStream != NULL)\n-    {\n-      errorStream->close ();\n-      errorStream = NULL;\n-    }\n+  // FIXME:\n+  // We used to close the input, output and\n+  // error streams here, but we can't do that\n+  // because the caller also has the right\n+  // to close these and FileInputStream and FileOutputStream\n+  // scream if you attempt to close() them twice. Presently,\n+  // we use _Jv_platform_close_on_exec, which is similar\n+  // to the POSIX approach.\n+  //\n+  // What I wanted to do is have private nested\n+  // classes in ConcreteProcess which extend FileInputStream\n+  // and FileOutputStream, respectively, but override\n+  // close() to permit multiple calls to close(). This\n+  // led to class header and platform configury issues\n+  // that I didn't feel like dealing with. However,\n+  // this approach could conceivably be a good multiplatform\n+  // one since delaying the pipe close until process\n+  // termination could be wasteful if many child processes\n+  // are spawned within the parent process' lifetime.\n+  inputStream = NULL;\n+  outputStream = NULL;\n+  errorStream = NULL;\n+  \n   if (procHandle)\n     {\n       CloseHandle((HANDLE) procHandle);\n@@ -129,6 +135,76 @@ java::lang::ConcreteProcess::waitFor (void)\n   return exitCode;\n }\n \n+\n+// Helper class for creating and managing the pipes\n+// used for I/O redirection for child processes.\n+class ChildProcessPipe\n+{\n+public:\n+  // Indicates from the child process' point of view\n+  // whether the pipe is for reading or writing.\n+  enum EType {INPUT, OUTPUT};\n+\n+  ChildProcessPipe(EType eType);\n+  ~ChildProcessPipe();\n+  \n+  // Returns a pipe handle suitable for use by the parent process\n+  HANDLE getParentHandle();\n+  \n+  // Returns a pipe handle suitable for use by the child process.\n+  HANDLE getChildHandle();\n+  \n+private:\n+  EType m_eType;\n+  HANDLE m_hRead, m_hWrite;\n+};\n+\n+ChildProcessPipe::ChildProcessPipe(EType eType):\n+  m_eType(eType)\n+{\n+  SECURITY_ATTRIBUTES sAttrs;\n+\n+  // Explicitly allow the handles to the pipes to be inherited.\n+  sAttrs.nLength = sizeof (SECURITY_ATTRIBUTES);\n+  sAttrs.bInheritHandle = 1;\n+  sAttrs.lpSecurityDescriptor = NULL;\n+\n+  if (CreatePipe (&m_hRead, &m_hWrite, &sAttrs, 0) == 0)\n+    {\n+      DWORD dwErrorCode = GetLastError ();\n+      throw new java::io::IOException (\n+        _Jv_WinStrError (\"Error creating pipe\", dwErrorCode));\n+    }\n+\n+  // If this is the read end of the child, we need\n+  // to make the parent write end non-inheritable. Similarly,\n+  // if this is the write end of the child, we need to make\n+  // the parent read end non-inheritable. If we didn't\n+  // do this, the child would inherit these ends and we wouldn't\n+  // be able to close them from our end. For full details,\n+  // do a Google search on \"Q190351\".\n+  HANDLE& rhStd = m_eType==INPUT ? m_hWrite : m_hRead;\n+  _Jv_platform_close_on_exec (rhStd);\n+}\n+\n+ChildProcessPipe::~ChildProcessPipe()\n+{\n+  // Close the parent end of the pipe. This\n+  // destructor is called after the child process\n+  // has been spawned.\n+  CloseHandle(getChildHandle());\n+}\n+\n+HANDLE ChildProcessPipe::getParentHandle()\n+{\n+  return m_eType==INPUT ? m_hWrite : m_hRead;\n+}\n+\n+HANDLE ChildProcessPipe::getChildHandle()\n+{\n+  return m_eType==INPUT ? m_hRead : m_hWrite;\n+}\n+\n void\n java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n                                            jstringArray envp,\n@@ -197,46 +273,16 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n     {\n       // We create anonymous pipes to communicate with the child\n       // on each of standard streams.\n+      ChildProcessPipe aChildStdIn(ChildProcessPipe::INPUT);\n+      ChildProcessPipe aChildStdOut(ChildProcessPipe::OUTPUT);\n+      ChildProcessPipe aChildStdErr(ChildProcessPipe::OUTPUT);\n \n-      HANDLE cldStdInRd, cldStdInWr;\n-      HANDLE cldStdOutRd, cldStdOutWr;\n-      HANDLE cldStdErrRd, cldStdErrWr;\n-\n-      SECURITY_ATTRIBUTES sAttrs;\n-\n-      // Explicitly allow the handles to the pipes to be inherited.\n-      sAttrs.nLength = sizeof (SECURITY_ATTRIBUTES);\n-      sAttrs.bInheritHandle = 1;\n-      sAttrs.lpSecurityDescriptor = NULL;\n-\n-\n-      if (CreatePipe (&cldStdInRd, &cldStdInWr, &sAttrs, 0) == 0)\n-        {\n-          DWORD dwErrorCode = GetLastError ();\n-          throw new IOException (_Jv_WinStrError (\"Error creating stdin pipe\",\n-            dwErrorCode));\n-        }\n-\n-      if (CreatePipe (&cldStdOutRd, &cldStdOutWr, &sAttrs, 0) == 0)\n-        {\n-          DWORD dwErrorCode = GetLastError ();\n-          throw new IOException (_Jv_WinStrError (\"Error creating stdout pipe\",\n-            dwErrorCode));\n-        }\n-\n-      if (CreatePipe (&cldStdErrRd, &cldStdErrWr, &sAttrs, 0) == 0)\n-        {\n-          DWORD dwErrorCode = GetLastError ();\n-          throw new IOException (_Jv_WinStrError (\"Error creating stderr pipe\",\n-            dwErrorCode));\n-        }\n-\n-      outputStream = new FileOutputStream\n-                         (new FileDescriptor ((jint) cldStdInWr));\n-      inputStream = new FileInputStream\n-                        (new FileDescriptor ((jint) cldStdOutRd));\n-      errorStream = new FileInputStream\n-                        (new FileDescriptor ((jint) cldStdErrRd));\n+      outputStream = new FileOutputStream (new FileDescriptor (\n+                           (jint) aChildStdIn.getParentHandle ()));\n+      inputStream = new FileInputStream (new FileDescriptor (\n+                           (jint) aChildStdOut.getParentHandle ()));\n+      errorStream = new FileInputStream (new FileDescriptor (\n+                           (jint) aChildStdErr.getParentHandle ()));\n \n       // Now create the child process.\n       PROCESS_INFORMATION pi;\n@@ -250,16 +296,20 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n       // Explicitly specify the handles to the standard streams.\n       si.dwFlags |= STARTF_USESTDHANDLES;\n \n-      si.hStdInput = cldStdInRd;\n-      si.hStdOutput = cldStdOutWr;\n-      si.hStdError = cldStdErrWr;\n+      si.hStdInput = aChildStdIn.getChildHandle();\n+      si.hStdOutput = aChildStdOut.getChildHandle();\n+      si.hStdError = aChildStdErr.getChildHandle();\n \n+      // Spawn the process. CREATE_NO_WINDOW only applies when\n+      // starting a console application; it suppresses the\n+      // creation of a console window. This flag is ignored on\n+      // Win9X.\n       if (CreateProcess (NULL,\n                          cmdLine,\n                          NULL,\n                          NULL,\n                          1,\n-                         0,\n+                         CREATE_NO_WINDOW,\n                          env,\n                          wdir,\n                          &si,\n@@ -272,11 +322,6 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n \n       procHandle = (jint ) pi.hProcess;\n \n-      // Close the wrong ends (for the parent) of the pipes.\n-      CloseHandle (cldStdInRd);\n-      CloseHandle (cldStdOutWr);\n-      CloseHandle (cldStdErrWr);\n-\n       _Jv_Free (cmdLine);\n       if (env != NULL)\n         _Jv_Free (env);"}]}