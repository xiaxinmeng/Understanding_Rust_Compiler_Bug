{"sha": "cb68ec50055e516ac270a043f772935561b01968", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I2OGVjNTAwNTVlNTE2YWMyNzBhMDQzZjc3MjkzNTU2MWIwMTk2OA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-03-30T19:45:57Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-03-30T19:45:57Z"}, "message": "re PR c++/26099 (support for type traits is not available)\n\ngcc/\n2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR c++/26099\n\t* c-common.h (enum rid): Add RID_HAS_NOTHROW_ASSIGN,\n\tRID_HAS_NOTHROW_CONSTRUCTOR, RID_HAS_NOTHROW_COPY,\n\tRID_HAS_TRIVIAL_ASSIGN, RID_HAS_TRIVIAL_CONSTRUCTOR,\n\tRID_HAS_TRIVIAL_COPY, RID_HAS_TRIVIAL_DESTRUCTOR,\n\tRID_HAS_VIRTUAL_DESTRUCTOR, RID_IS_ABSTRACT, RID_IS_BASE_OF,\n\tRID_IS_CONVERTIBLE_TO, RID_IS_CLASS, RID_IS_EMPTY, RID_IS_ENUM,\n\tRID_IS_POD, RID_IS_POLYMORPHIC, RID_IS_UNION, as\n\tC++ extensions.\n\t* doc/extend.texi (Extensions to the C++ Language): Add Type Traits.\n\ngcc/cp/\n2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR c++/26099\n\t* cp-tree.h (enum cp_trait_kind, struct tree_trait_expr,\n\tTRAIT_EXPR_TYPE1, TRAIT_EXPR_TYPE2, TRAIT_EXPR_KIND): Add.\n\t(enum cp_tree_node_structure_enum, union lang_tree_node): Update.\n\t(CLASS_TYPE_NON_UNION_P): Add.\n\t(struct lang_type_class): Add has_complex_dflt.\n\t(TYPE_HAS_COMPLEX_DFLT, TYPE_HAS_TRIVIAL_DFLT): Add.\n\t(locate_copy, locate_ctor, locate_dtor, finish_trait_expr): Declare.\n\t* cp-tree.def: Add TRAIT_EXPR.\n\t* cp-objcp-common.c (cp_tree_size): Add TRAIT_EXPR case.\n\t* lex.c (struct resword): Add __has_nothrow_assign,\n\t__has_nothrow_constructor, __has_nothrow_copy, __has_trivial_assign,\n\t__has_trivial_constructor, __has_trivial_copy,\n\t__has_trivial_destructor, __has_virtual_destructor, __is_abstract,\n\t__is_base_of, __is_class, __is_convertible_to, __is_empty, __is_enum,\n\t__is_pod, __is_polymorphic, __is_union.\n\t* parser.c (cp_parser_primary_expression): Deal with the new RIDs.\n\t(cp_parser_trait_expr): New.\n\t* semantics.c (finish_trait_expr, trait_expr_value\n\tclasstype_has_nothrow_copy_or_assign_p): New.\n\t* method.c (locate_copy, locate_ctor, locate_dtor): Do not define\n\tas static.\n\t* decl.c (cp_tree_node_structure): Add TRAIT_EXPR.\n\t* class.c (check_bases, check_field_decl, check_bases_and_members):\n\tDeal with TYPE_HAS_COMPLEX_DFLT (t) too.\n\t* pt.c (uses_template_parms, tsubst_copy_and_build,\n\tvalue_dependent_expression_p, type_dependent_expression_p): Deal with\n\tTRAIT_EXPR.\n\t* tree.c (cp_walk_subtrees): Deal with TRAIT_EXPR.\n\ngcc/testsuite/\n2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR c++/26099\n\t* g++.dg/ext/is_base_of.C: New.\n\t* g++.dg/ext/has_virtual_destructor.C: New.\n\t* g++.dg/ext/is_polymorphic.C: New.\n\t* g++.dg/ext/is_base_of_diagnostic.C: New.\n\t* g++.dg/ext/is_enum.C: New.\n\t* g++.dg/ext/has_nothrow_assign.C: New.\n\t* g++.dg/ext/has_nothrow_constructor.C: New.\n\t* g++.dg/ext/is_empty.C: New.\n\t* g++.dg/ext/has_trivial_copy.C: New.\n\t* g++.dg/ext/has_trivial_assign.C: New.\n\t* g++.dg/ext/is_abstract.C: New.\n\t* g++.dg/ext/is_pod.C: New.\n\t* g++.dg/ext/has_nothrow_copy.C: New.\n\t* g++.dg/ext/is_class.C: New.\n\t* g++.dg/ext/has_trivial_constructor.C: New.\n\t* g++.dg/ext/is_union.C: New.\n\t* g++.dg/ext/has_trivial_destructor.C: New.\n\t* g++.dg/tree-ssa/pr22444.C: Adjust, avoid __is_pod.\n\t* g++.dg/template/crash43.C: Likewise.\n\nlibstdc++-v3/\n2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR c++/26099\n\t* include/bits/cpp_type_traits.h (struct __is_pod, struct __is_empty):\n\tRemove.\n\t* include/bits/valarray_array.h: Adjust.\n\t* include/bits/allocator.h: Likewise.\n\t* include/bits/stl_tree.h: Likewise.\n\nFrom-SVN: r123366", "tree": {"sha": "63250c95176e6d94178beae6b2735b398dfbfec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63250c95176e6d94178beae6b2735b398dfbfec1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb68ec50055e516ac270a043f772935561b01968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb68ec50055e516ac270a043f772935561b01968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb68ec50055e516ac270a043f772935561b01968", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb68ec50055e516ac270a043f772935561b01968/comments", "author": null, "committer": null, "parents": [{"sha": "c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55"}], "stats": {"total": 2308, "additions": 2240, "deletions": 68}, "files": [{"sha": "de93d5dd1bec8fdf10b9b4227a383f28da7cf47c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,3 +1,16 @@\n+2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR c++/26099\n+\t* c-common.h (enum rid): Add RID_HAS_NOTHROW_ASSIGN,\n+\tRID_HAS_NOTHROW_CONSTRUCTOR, RID_HAS_NOTHROW_COPY,\n+\tRID_HAS_TRIVIAL_ASSIGN, RID_HAS_TRIVIAL_CONSTRUCTOR,\n+\tRID_HAS_TRIVIAL_COPY, RID_HAS_TRIVIAL_DESTRUCTOR,\n+\tRID_HAS_VIRTUAL_DESTRUCTOR, RID_IS_ABSTRACT, RID_IS_BASE_OF,\n+\tRID_IS_CONVERTIBLE_TO, RID_IS_CLASS, RID_IS_EMPTY, RID_IS_ENUM,\n+\tRID_IS_POD, RID_IS_POLYMORPHIC, RID_IS_UNION, as\n+\tC++ extensions.\n+\t* doc/extend.texi (Extensions to the C++ Language): Add Type Traits.\n+\n 2007-03-30  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* regmove.c: Move all of pass_stack_adjustments from here..."}, {"sha": "b128e31a0085da7d0d57d4c9a43e313bbd58d209", "filename": "gcc/c-common.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -90,6 +90,17 @@ enum rid\n   /* casts */\n   RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n \n+  /* C++ extensions */\n+  RID_HAS_NOTHROW_ASSIGN,      RID_HAS_NOTHROW_CONSTRUCTOR,\n+  RID_HAS_NOTHROW_COPY,        RID_HAS_TRIVIAL_ASSIGN,\n+  RID_HAS_TRIVIAL_CONSTRUCTOR, RID_HAS_TRIVIAL_COPY,\n+  RID_HAS_TRIVIAL_DESTRUCTOR,  RID_HAS_VIRTUAL_DESTRUCTOR,\n+  RID_IS_ABSTRACT,             RID_IS_BASE_OF,\n+  RID_IS_CONVERTIBLE_TO,       RID_IS_CLASS,\n+  RID_IS_EMPTY,                RID_IS_ENUM,\n+  RID_IS_POD,                  RID_IS_POLYMORPHIC,\n+  RID_IS_UNION,\n+\n   /* C++0x */\n   RID_STATIC_ASSERT,\n "}, {"sha": "4374e6b7db0a3818f785da12b2d7b2f11b0ec93e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,3 +1,35 @@\n+2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR c++/26099\n+\t* cp-tree.h (enum cp_trait_kind, struct tree_trait_expr,\n+\tTRAIT_EXPR_TYPE1, TRAIT_EXPR_TYPE2, TRAIT_EXPR_KIND): Add.\n+\t(enum cp_tree_node_structure_enum, union lang_tree_node): Update.\n+\t(CLASS_TYPE_NON_UNION_P): Add.\n+\t(struct lang_type_class): Add has_complex_dflt.\n+\t(TYPE_HAS_COMPLEX_DFLT, TYPE_HAS_TRIVIAL_DFLT): Add.\n+\t(locate_copy, locate_ctor, locate_dtor, finish_trait_expr): Declare.\n+\t* cp-tree.def: Add TRAIT_EXPR.\n+\t* cp-objcp-common.c (cp_tree_size): Add TRAIT_EXPR case.\n+\t* lex.c (struct resword): Add __has_nothrow_assign,\n+\t__has_nothrow_constructor, __has_nothrow_copy, __has_trivial_assign,\n+\t__has_trivial_constructor, __has_trivial_copy,\n+\t__has_trivial_destructor, __has_virtual_destructor, __is_abstract,\n+\t__is_base_of, __is_class, __is_convertible_to, __is_empty, __is_enum,\n+\t__is_pod, __is_polymorphic, __is_union.\n+\t* parser.c (cp_parser_primary_expression): Deal with the new RIDs.\n+\t(cp_parser_trait_expr): New.\n+\t* semantics.c (finish_trait_expr, trait_expr_value\n+\tclasstype_has_nothrow_copy_or_assign_p): New.\n+\t* method.c (locate_copy, locate_ctor, locate_dtor): Do not define\n+\tas static.\n+\t* decl.c (cp_tree_node_structure): Add TRAIT_EXPR.\n+\t* class.c (check_bases, check_field_decl, check_bases_and_members):\n+\tDeal with TYPE_HAS_COMPLEX_DFLT (t) too.\n+\t* pt.c (uses_template_parms, tsubst_copy_and_build,\n+\tvalue_dependent_expression_p, type_dependent_expression_p): Deal with\n+\tTRAIT_EXPR.\n+\t* tree.c (cp_walk_subtrees): Deal with TRAIT_EXPR.\n+\n 2007-03-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (cp_walk_subtrees): Do not set input_location."}, {"sha": "5e5bcbf895c40eb9aaf4215a7f78b13c50a9d2d2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1270,6 +1270,7 @@ check_bases (tree t,\n       TYPE_POLYMORPHIC_P (t) |= TYPE_POLYMORPHIC_P (basetype);\n       CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t)\n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n+      TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (basetype);      \n     }\n }\n \n@@ -2753,6 +2754,7 @@ check_field_decl (tree field,\n \t    |= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type);\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n \t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n+\t  TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (type);\n \t}\n \n       if (!TYPE_HAS_CONST_INIT_REF (type))\n@@ -4113,6 +4115,8 @@ check_bases_and_members (tree t)\n \t|| TYPE_HAS_ASSIGN_REF (t));\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n+  TYPE_HAS_COMPLEX_DFLT (t)\n+    |= (TYPE_HAS_DEFAULT_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n \n   /* Synthesize any needed methods.  */\n   add_implicitly_declared_members (t,"}, {"sha": "af8eb94cf4945e61d90ecbd410cc0c633aea4e22", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -135,6 +135,9 @@ cp_tree_size (enum tree_code code)\n     case ARGUMENT_PACK_SELECT:\n       return sizeof (struct tree_argument_pack_select);\n \n+    case TRAIT_EXPR:\n+      return sizeof (struct tree_trait_expr);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "a0feb30e001cc154ae155396a56eeba5156601f4", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -422,6 +422,11 @@ DEFTREECODE (EXPR_PACK_EXPANSION, \"expr_pack_expansion\", tcc_expression, 1)\n    index is a machine integer.  */\n DEFTREECODE (ARGUMENT_PACK_SELECT, \"argument_pack_select\", tcc_exceptional, 0)\n \n+/** C++ extensions. */\n+\n+/* Represents a trait expression during template expansion.  */\n+DEFTREECODE (TRAIT_EXPR, \"trait_expr\", tcc_exceptional, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "2d20246a24441e5c8e50d5d074f85fd6e88acf24", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -478,6 +478,48 @@ struct tree_argument_pack_select GTY (())\n   int index;\n };\n \n+/* The different kinds of traits that we encounter.  */\n+\n+typedef enum cp_trait_kind\n+{\n+  CPTK_HAS_NOTHROW_ASSIGN,\n+  CPTK_HAS_NOTHROW_CONSTRUCTOR,\n+  CPTK_HAS_NOTHROW_COPY,\n+  CPTK_HAS_TRIVIAL_ASSIGN,\n+  CPTK_HAS_TRIVIAL_CONSTRUCTOR,\n+  CPTK_HAS_TRIVIAL_COPY,\n+  CPTK_HAS_TRIVIAL_DESTRUCTOR,\n+  CPTK_HAS_VIRTUAL_DESTRUCTOR,\n+  CPTK_IS_ABSTRACT,\n+  CPTK_IS_BASE_OF,\n+  CPTK_IS_CLASS,\n+  CPTK_IS_CONVERTIBLE_TO,\n+  CPTK_IS_EMPTY,\n+  CPTK_IS_ENUM,\n+  CPTK_IS_POD,\n+  CPTK_IS_POLYMORPHIC,\n+  CPTK_IS_UNION\n+} cp_trait_kind;\n+\n+/* The types that we are processing.  */\n+#define TRAIT_EXPR_TYPE1(NODE) \\\n+  (((struct tree_trait_expr *)TRAIT_EXPR_CHECK (NODE))->type1)\n+\n+#define TRAIT_EXPR_TYPE2(NODE) \\\n+  (((struct tree_trait_expr *)TRAIT_EXPR_CHECK (NODE))->type2)\n+\n+/* The specific trait that we are processing.  */\n+#define TRAIT_EXPR_KIND(NODE) \\\n+  (((struct tree_trait_expr *)TRAIT_EXPR_CHECK (NODE))->kind)\n+\n+struct tree_trait_expr GTY (())\n+{\n+  struct tree_common common;\n+  tree type1;\n+  tree type2;  \n+  enum cp_trait_kind kind;\n+};\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -491,6 +533,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_DEFAULT_ARG,\n   TS_CP_STATIC_ASSERT,\n   TS_CP_ARGUMENT_PACK_SELECT,\n+  TS_CP_TRAIT_EXPR,\n   LAST_TS_CP_ENUM\n };\n \n@@ -511,6 +554,8 @@ union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     static_assertion;\n   struct tree_argument_pack_select GTY ((tag (\"TS_CP_ARGUMENT_PACK_SELECT\")))\n     argument_pack_select;\n+  struct tree_trait_expr GTY ((tag (\"TS_CP_TRAIT_EXPR\")))\n+    trait_expression;\n };\n \n \f\n@@ -936,6 +981,10 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define CLASS_TYPE_P(T) \\\n   (IS_AGGR_TYPE_CODE (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n \n+/* Nonzero if T is a class type but not an union.  */\n+#define NON_UNION_CLASS_TYPE_P(T) \\\n+  (CLASS_TYPE_P (T) && TREE_CODE (T) != UNION_TYPE)\n+\n /* Keep these checks in ascending code order.  */\n #define IS_AGGR_TYPE_CODE(T)\t\\\n   ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n@@ -1093,6 +1142,7 @@ struct lang_type_class GTY(())\n   unsigned has_complex_init_ref : 1;\n   unsigned has_complex_assign_ref : 1;\n   unsigned non_aggregate : 1;\n+  unsigned has_complex_dflt : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1101,7 +1151,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 12;\n+  unsigned dummy : 11;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -2682,8 +2732,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_assign_ref)\n+\n+/* Nonzero if there is a user-defined X::X(x&) for this class.  */\n #define TYPE_HAS_COMPLEX_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_init_ref)\n \n+/* Nonzero if there is a user-defined default constructor for this class.  */\n+#define TYPE_HAS_COMPLEX_DFLT(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_dflt)\n+\n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n \n      A destructor is trivial if it is an implicitly declared\n@@ -2705,6 +2760,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_HAS_NONTRIVIAL_DESTRUCTOR(NODE) \\\n   (TYPE_LANG_FLAG_4 (NODE))\n \n+/* Nonzero for class type means that the default constructor is trivial.  */\n+#define TYPE_HAS_TRIVIAL_DFLT(NODE) \\\n+  (TYPE_HAS_DEFAULT_CONSTRUCTOR (NODE) && ! TYPE_HAS_COMPLEX_DFLT (NODE))\n+\n /* Nonzero for class type means that copy initialization of this type can use\n    a bitwise copy.  */\n #define TYPE_HAS_TRIVIAL_INIT_REF(NODE) \\\n@@ -4280,6 +4339,9 @@ extern tree lazily_declare_fn\t\t\t(special_function_kind,\n extern tree skip_artificial_parms_for\t\t(tree, tree);\n extern int num_artificial_parms_for\t\t(tree);\n extern tree make_alias_for\t\t\t(tree, tree);\n+extern tree locate_copy\t\t\t\t(tree, void *);\n+extern tree locate_ctor\t\t\t\t(tree, void *);\n+extern tree locate_dtor\t\t\t\t(tree, void *);\n \n /* In optimize.c */\n extern bool maybe_clone_body\t\t\t(tree);\n@@ -4557,6 +4619,7 @@ extern bool cxx_omp_privatize_by_reference\t(tree);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n                                                  bool);\n+extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,"}, {"sha": "833e7b8e43a31304a60240701cc53d9ce6997fb6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -11739,6 +11739,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case BASELINK:\t\treturn TS_CP_BASELINK;\n     case STATIC_ASSERT:\t\treturn TS_CP_STATIC_ASSERT;\n     case ARGUMENT_PACK_SELECT:  return TS_CP_ARGUMENT_PACK_SELECT;\n+    case TRAIT_EXPR:\t\treturn TS_CP_TRAIT_EXPR;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "080a843df413bc8106e2f8f58e8cbd079d3458c4", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -199,6 +199,23 @@ static const struct resword reswords[] =\n   { \"__const__\",\tRID_CONST,\t0 },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n   { \"__func__\",\t\tRID_C99_FUNCTION_NAME,\t0 },\n+  { \"__has_nothrow_assign\", RID_HAS_NOTHROW_ASSIGN, 0 },\n+  { \"__has_nothrow_constructor\", RID_HAS_NOTHROW_CONSTRUCTOR, 0 },\n+  { \"__has_nothrow_copy\", RID_HAS_NOTHROW_COPY, 0 },\n+  { \"__has_trivial_assign\", RID_HAS_TRIVIAL_ASSIGN, 0 },\n+  { \"__has_trivial_constructor\", RID_HAS_TRIVIAL_CONSTRUCTOR, 0 },\n+  { \"__has_trivial_copy\", RID_HAS_TRIVIAL_COPY, 0 },\n+  { \"__has_trivial_destructor\", RID_HAS_TRIVIAL_DESTRUCTOR, 0 },\n+  { \"__has_virtual_destructor\", RID_HAS_VIRTUAL_DESTRUCTOR, 0 },\n+  { \"__is_abstract\",\tRID_IS_ABSTRACT, 0 },\n+  { \"__is_base_of\",\tRID_IS_BASE_OF, 0 },\n+  { \"__is_class\",\tRID_IS_CLASS,\t0 },\n+  { \"__is_convertible_to\", RID_IS_CONVERTIBLE_TO, 0 },\n+  { \"__is_empty\",\tRID_IS_EMPTY,\t0 },\n+  { \"__is_enum\",\tRID_IS_ENUM,\t0 },\n+  { \"__is_pod\",\t\tRID_IS_POD,\t0 },\n+  { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, 0 },\n+  { \"__is_union\",\tRID_IS_UNION,\t0 },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },"}, {"sha": "03078a3f017dfd805d54ebfe4e52c20135ad6ed1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -61,9 +61,6 @@ static tree thunk_adjust (tree, bool, HOST_WIDE_INT, tree);\n static void do_build_assign_ref (tree);\n static void do_build_copy_constructor (tree);\n static tree synthesize_exception_spec (tree, tree (*) (tree, void *), void *);\n-static tree locate_dtor (tree, void *);\n-static tree locate_ctor (tree, void *);\n-static tree locate_copy (tree, void *);\n static tree make_alias_for_thunk (tree);\n \n /* Called once to initialize method.c.  */\n@@ -868,15 +865,15 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n \n /* Locate the dtor of TYPE.  */\n \n-static tree\n+tree\n locate_dtor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n   return CLASSTYPE_DESTRUCTORS (type);\n }\n \n /* Locate the default ctor of TYPE.  */\n \n-static tree\n+tree\n locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n   tree fns;\n@@ -912,7 +909,7 @@ struct copy_data\n    points to a COPY_DATA holding the name (NULL for the ctor)\n    and desired qualifiers of the source operand.  */\n \n-static tree\n+tree\n locate_copy (tree type, void *client_)\n {\n   struct copy_data *client = (struct copy_data *)client_;"}, {"sha": "4fc1a629d5c09d89efb25a27d77d28d8df1e144b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 147, "deletions": 1, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1897,6 +1897,8 @@ static void cp_parser_late_parsing_default_args\n   (cp_parser *, tree);\n static tree cp_parser_sizeof_operand\n   (cp_parser *, enum rid);\n+static tree cp_parser_trait_expr\n+  (cp_parser *, enum rid);\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n static void cp_parser_set_storage_class\n@@ -2959,6 +2961,25 @@ cp_parser_translation_unit (cp_parser* parser)\n      __builtin_va_arg ( assignment-expression , type-id )\n      __builtin_offsetof ( type-id , offsetof-expression )\n \n+   C++ Extensions:\n+     __has_nothrow_assign ( type-id )   \n+     __has_nothrow_constructor ( type-id )\n+     __has_nothrow_copy ( type-id )\n+     __has_trivial_assign ( type-id )   \n+     __has_trivial_constructor ( type-id )\n+     __has_trivial_copy ( type-id )\n+     __has_trivial_destructor ( type-id )\n+     __has_virtual_destructor ( type-id )     \n+     __is_abstract ( type-id )\n+     __is_base_of ( type-id , type-id )\n+     __is_class ( type-id )\n+     __is_convertible_to ( type-id , type-id )     \n+     __is_empty ( type-id )\n+     __is_enum ( type-id )\n+     __is_pod ( type-id )\n+     __is_polymorphic ( type-id )\n+     __is_union ( type-id )\n+\n    Objective-C++ Extension:\n \n    primary-expression:\n@@ -3201,7 +3222,26 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_OFFSETOF:\n \t  return cp_parser_builtin_offsetof (parser);\n \n-\t  /* Objective-C++ expressions.  */\n+\tcase RID_HAS_NOTHROW_ASSIGN:\n+\tcase RID_HAS_NOTHROW_CONSTRUCTOR:\n+\tcase RID_HAS_NOTHROW_COPY:\t  \n+\tcase RID_HAS_TRIVIAL_ASSIGN:\n+\tcase RID_HAS_TRIVIAL_CONSTRUCTOR:\n+\tcase RID_HAS_TRIVIAL_COPY:\t  \n+\tcase RID_HAS_TRIVIAL_DESTRUCTOR:\n+\tcase RID_HAS_VIRTUAL_DESTRUCTOR:\n+\tcase RID_IS_ABSTRACT:\n+\tcase RID_IS_BASE_OF:\n+\tcase RID_IS_CLASS:\n+\tcase RID_IS_CONVERTIBLE_TO:\n+\tcase RID_IS_EMPTY:\n+\tcase RID_IS_ENUM:\n+\tcase RID_IS_POD:\n+\tcase RID_IS_POLYMORPHIC:\n+\tcase RID_IS_UNION:\n+\t  return cp_parser_trait_expr (parser, token->keyword);\n+\n+\t/* Objective-C++ expressions.  */\n \tcase RID_AT_ENCODE:\n \tcase RID_AT_PROTOCOL:\n \tcase RID_AT_SELECTOR:\n@@ -6309,6 +6349,112 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   return expr;\n }\n \n+/* Parse a trait expression.  */\n+\n+static tree\n+cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n+{\n+  cp_trait_kind kind;\n+  tree type1, type2 = NULL_TREE;\n+  bool binary = false;\n+  cp_decl_specifier_seq decl_specs;\n+\n+  switch (keyword)\n+    {\n+    case RID_HAS_NOTHROW_ASSIGN:\n+      kind = CPTK_HAS_NOTHROW_ASSIGN;\n+      break;\n+    case RID_HAS_NOTHROW_CONSTRUCTOR:\n+      kind = CPTK_HAS_NOTHROW_CONSTRUCTOR;\n+      break;\n+    case RID_HAS_NOTHROW_COPY:\n+      kind = CPTK_HAS_NOTHROW_COPY;\n+      break;\n+    case RID_HAS_TRIVIAL_ASSIGN:\n+      kind = CPTK_HAS_TRIVIAL_ASSIGN;\n+      break;\n+    case RID_HAS_TRIVIAL_CONSTRUCTOR:\n+      kind = CPTK_HAS_TRIVIAL_CONSTRUCTOR;\n+      break;\n+    case RID_HAS_TRIVIAL_COPY:\n+      kind = CPTK_HAS_TRIVIAL_COPY;\n+      break;\n+    case RID_HAS_TRIVIAL_DESTRUCTOR:\n+      kind = CPTK_HAS_TRIVIAL_DESTRUCTOR;\n+      break;\n+    case RID_HAS_VIRTUAL_DESTRUCTOR:\n+      kind = CPTK_HAS_VIRTUAL_DESTRUCTOR;\n+      break;\n+    case RID_IS_ABSTRACT:\n+      kind = CPTK_IS_ABSTRACT;\n+      break;\n+    case RID_IS_BASE_OF:\n+      kind = CPTK_IS_BASE_OF;\n+      binary = true;\n+      break;\n+    case RID_IS_CLASS:\n+      kind = CPTK_IS_CLASS;\n+      break;\n+    case RID_IS_CONVERTIBLE_TO:\n+      kind = CPTK_IS_CONVERTIBLE_TO;\n+      binary = true;\n+      break;\n+    case RID_IS_EMPTY:\n+      kind = CPTK_IS_EMPTY;\n+      break;\n+    case RID_IS_ENUM:\n+      kind = CPTK_IS_ENUM;\n+      break;\n+    case RID_IS_POD:\n+      kind = CPTK_IS_POD;\n+      break;\n+    case RID_IS_POLYMORPHIC:\n+      kind = CPTK_IS_POLYMORPHIC;\n+      break;\n+    case RID_IS_UNION:\n+      kind = CPTK_IS_UNION;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Consume the token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\n+  type1 = cp_parser_type_id (parser);\n+\n+  /* Build a trivial decl-specifier-seq.  */\n+  clear_decl_specs (&decl_specs);\n+  decl_specs.type = type1;\n+\n+  /* Call grokdeclarator to figure out what type this is.  */\n+  type1 = grokdeclarator (NULL, &decl_specs, TYPENAME,\n+\t\t\t  /*initialized=*/0, /*attrlist=*/NULL);\n+\n+  if (binary)\n+    {\n+      cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+ \n+      type2 = cp_parser_type_id (parser);\n+\n+      /* Build a trivial decl-specifier-seq.  */\n+      clear_decl_specs (&decl_specs);\n+      decl_specs.type = type2;\n+\n+      /* Call grokdeclarator to figure out what type this is.  */\n+      type2 = grokdeclarator (NULL, &decl_specs, TYPENAME,\n+\t\t\t      /*initialized=*/0, /*attrlist=*/NULL);\n+    }\n+\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  /* Complete the trait expr, which may mean either processing the\n+     static assert now or saving it for template instantiation.  */\n+  return finish_trait_expr (kind, type1, type2);\n+}\n+\n /* Statements [gram.stmt.stmt]  */\n \n /* Parse a statement."}, {"sha": "f1e6b18ca24cb725679f07442f4576e271232889", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -5818,6 +5818,7 @@ uses_template_parms (tree t)\n \t   || TREE_CODE (t) == OVERLOAD\n \t   || TREE_CODE (t) == BASELINK\n \t   || TREE_CODE (t) == IDENTIFIER_NODE\n+\t   || TREE_CODE (t) == TRAIT_EXPR\n \t   || CONSTANT_CLASS_P (t))\n     dependent_p = (type_dependent_expression_p (t)\n \t\t   || value_dependent_expression_p (t));\n@@ -10703,6 +10704,18 @@ tsubst_copy_and_build (tree t,\n     case OFFSETOF_EXPR:\n       return finish_offsetof (RECUR (TREE_OPERAND (t, 0)));\n \n+    case TRAIT_EXPR:\n+      {\n+\ttree type1 = tsubst_copy (TRAIT_EXPR_TYPE1 (t), args,\n+\t\t\t\t  complain, in_decl);\n+\n+\ttree type2 = TRAIT_EXPR_TYPE2 (t);\n+\tif (type2)\n+\t  type2 = tsubst_copy (type2, args, complain, in_decl);\n+\t\n+\treturn finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2);\n+      }\n+\n     case STMT_EXPR:\n       {\n \ttree old_stmt_expr = cur_stmt_expr;\n@@ -14912,6 +14925,13 @@ value_dependent_expression_p (tree expression)\n         return false;\n       }\n \n+    case TRAIT_EXPR:\n+      {\n+\ttree type2 = TRAIT_EXPR_TYPE2 (expression);\n+\treturn (dependent_type_p (TRAIT_EXPR_TYPE1 (expression))\n+\t\t|| (type2 ? dependent_type_p (type2) : false));\n+      }\n+\n     default:\n       /* A constant expression is value-dependent if any subexpression is\n \t value-dependent.  */\n@@ -14975,6 +14995,7 @@ type_dependent_expression_p (tree expression)\n   if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR\n       || TREE_CODE (expression) == SIZEOF_EXPR\n       || TREE_CODE (expression) == ALIGNOF_EXPR\n+      || TREE_CODE (expression) == TRAIT_EXPR\n       || TREE_CODE (expression) == TYPEID_EXPR\n       || TREE_CODE (expression) == DELETE_EXPR\n       || TREE_CODE (expression) == VEC_DELETE_EXPR"}, {"sha": "bfb84ec5d5f83a16c1ef0edeb062b9a805e7b682", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -4007,4 +4007,210 @@ finish_static_assert (tree condition, tree message, location_t location,\n     }\n }\n \n+/* Called from trait_expr_value to evaluate either __has_nothrow_copy or \n+   __has_nothrow_assign, depending on copy_p.  */\n+\n+static bool\n+classtype_has_nothrow_copy_or_assign_p (tree type, bool copy_p)\n+{\n+  if ((copy_p && TYPE_HAS_INIT_REF (type))\n+      || (!copy_p && TYPE_HAS_ASSIGN_REF (type)))\n+    {\n+      bool const_p = false;\n+      tree t;\n+\n+      struct copy_data \n+      {\n+\ttree name;\n+\tint quals;\n+      } data;\n+\n+      data.name = copy_p ? NULL_TREE : ansi_assopname (NOP_EXPR);\n+\n+      data.quals = TYPE_QUAL_CONST;\n+      t = locate_copy (type, &data);\n+      if (t)\n+\t{\n+\t  const_p = true;\n+\t  if (!TREE_NOTHROW (t))\n+\t    return false;\n+\t}\n+\n+      if (copy_p || !CP_TYPE_CONST_P (type))\n+\t{\n+\t  data.quals = TYPE_UNQUALIFIED;\n+\t  t = locate_copy (type, &data);\n+\t  if (t && !TREE_NOTHROW (t))\n+\t    return false;\n+\n+\t  data.quals = TYPE_QUAL_VOLATILE;\n+\t  t = locate_copy (type, &data);\n+\t  if (t && !TREE_NOTHROW (t))\n+\t    return false;\n+\t}\n+\n+      data.quals = (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      t = locate_copy (type, &data);\n+      if (t)\n+\t{\n+\t  const_p = true;\n+\t  if (!TREE_NOTHROW (t))\n+\t    return false;\n+\t}\n+\n+      if (!copy_p && CP_TYPE_CONST_P (type) && !const_p)\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Actually evaluates the trait.  */\n+\n+static bool\n+trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n+{\n+  enum tree_code type_code1;\n+  tree t;\n+\n+  type_code1 = TREE_CODE (type1);\n+\n+  switch (kind)\n+    {\n+    case CPTK_HAS_NOTHROW_ASSIGN:\n+      return (trait_expr_value (CPTK_HAS_TRIVIAL_ASSIGN, type1, type2)\n+\t      || (CLASS_TYPE_P (type1)\n+\t\t  && classtype_has_nothrow_copy_or_assign_p (type1, false)));\n+\n+    case CPTK_HAS_TRIVIAL_ASSIGN:\n+      return (!CP_TYPE_CONST_P (type1) && type_code1 != REFERENCE_TYPE\n+\t      && (pod_type_p (type1)\n+\t\t    || (CLASS_TYPE_P (type1)\n+\t\t\t&& TYPE_HAS_TRIVIAL_ASSIGN_REF (type1))));\n+\n+    case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n+      type1 = strip_array_types (type1);\n+      return (trait_expr_value (CPTK_HAS_TRIVIAL_CONSTRUCTOR, type1, type2) \n+\t      || (CLASS_TYPE_P (type1)\n+\t\t  && (t = locate_ctor (type1, NULL)) && TREE_NOTHROW (t)));\n+\n+    case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n+      type1 = strip_array_types (type1);\n+      return (pod_type_p (type1)\n+\t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_DFLT (type1)));\n+\n+    case CPTK_HAS_NOTHROW_COPY:\n+      return (trait_expr_value (CPTK_HAS_TRIVIAL_COPY, type1, type2)\n+\t      || (CLASS_TYPE_P (type1)\n+\t\t  && classtype_has_nothrow_copy_or_assign_p (type1, true)));\n+\n+    case CPTK_HAS_TRIVIAL_COPY:\n+      return (pod_type_p (type1) || type_code1 == REFERENCE_TYPE\n+\t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_INIT_REF (type1)));\n+\n+    case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n+      type1 = strip_array_types (type1);\n+      return (pod_type_p (type1)\n+\t      || (CLASS_TYPE_P (type1)\n+\t\t  && TYPE_HAS_TRIVIAL_DESTRUCTOR (type1)));\n+\n+    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n+      return (CLASS_TYPE_P (type1)\n+\t      && (t = locate_dtor (type1, NULL)) && DECL_VIRTUAL_P (t));\n+\n+    case CPTK_IS_ABSTRACT:\n+      return (CLASS_TYPE_P (type1) && CLASSTYPE_PURE_VIRTUALS (type1));\n+\n+    case CPTK_IS_BASE_OF:\n+      return (NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n+\t      && DERIVED_FROM_P (type1, type2));\n+\n+    case CPTK_IS_CLASS:\n+      return (NON_UNION_CLASS_TYPE_P (type1));\n+\n+    case CPTK_IS_CONVERTIBLE_TO:\n+      /* TODO  */\n+      return false;\n+\n+    case CPTK_IS_EMPTY:\n+      return (NON_UNION_CLASS_TYPE_P (type1) && CLASSTYPE_EMPTY_P (type1));\n+\n+    case CPTK_IS_ENUM:\n+      return (type_code1 == ENUMERAL_TYPE);\n+\n+    case CPTK_IS_POD:\n+      return (pod_type_p (type1));\n+\n+    case CPTK_IS_POLYMORPHIC:\n+      return (CLASS_TYPE_P (type1) && TYPE_POLYMORPHIC_P (type1));\n+\n+    case CPTK_IS_UNION:\n+      return (type_code1 == UNION_TYPE);\n+\n+    default:\n+      gcc_unreachable ();\n+      return false;\n+    }\n+}\n+\n+/* Process a trait expression.  */\n+\n+tree\n+finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n+{\n+  gcc_assert (kind == CPTK_HAS_NOTHROW_ASSIGN\n+\t      || kind == CPTK_HAS_NOTHROW_CONSTRUCTOR\n+\t      || kind == CPTK_HAS_NOTHROW_COPY\n+\t      || kind == CPTK_HAS_TRIVIAL_ASSIGN\n+\t      || kind == CPTK_HAS_TRIVIAL_CONSTRUCTOR\n+\t      || kind == CPTK_HAS_TRIVIAL_COPY\n+\t      || kind == CPTK_HAS_TRIVIAL_DESTRUCTOR\n+\t      || kind == CPTK_HAS_VIRTUAL_DESTRUCTOR\t      \n+\t      || kind == CPTK_IS_ABSTRACT\n+\t      || kind == CPTK_IS_BASE_OF\n+\t      || kind == CPTK_IS_CLASS\n+\t      || kind == CPTK_IS_CONVERTIBLE_TO\n+\t      || kind == CPTK_IS_EMPTY\n+\t      || kind == CPTK_IS_ENUM\n+\t      || kind == CPTK_IS_POD\n+\t      || kind == CPTK_IS_POLYMORPHIC\n+\t      || kind == CPTK_IS_UNION);\n+\n+  if (kind == CPTK_IS_CONVERTIBLE_TO)\n+    {\n+      sorry (\"__is_convertible_to\");\n+      return error_mark_node;\n+    }\n+\n+  if (type1 == error_mark_node\n+      || ((kind == CPTK_IS_BASE_OF || kind == CPTK_IS_CONVERTIBLE_TO)\n+\t  && type2 == error_mark_node))\n+    return error_mark_node;\n+\n+  if (processing_template_decl)\n+    {\n+      tree trait_expr = make_node (TRAIT_EXPR);\n+      TREE_TYPE (trait_expr) = boolean_type_node;\n+      TRAIT_EXPR_TYPE1 (trait_expr) = type1;\n+      TRAIT_EXPR_TYPE2 (trait_expr) = type2;\n+      TRAIT_EXPR_KIND (trait_expr) = kind;\n+      return trait_expr;\n+    }\n+\n+  /* The only required diagnostic.  */\n+  if (kind == CPTK_IS_BASE_OF\n+      && NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n+      && !same_type_ignoring_top_level_qualifiers_p (type1, type2)\n+      && !COMPLETE_TYPE_P (complete_type (type2)))\n+    {\n+      error (\"incomplete type %qT not allowed\", type2);\n+      return error_mark_node;\n+    }\n+\n+  return (trait_expr_value (kind, type1, type2)\n+\t  ? boolean_true_node : boolean_false_node);\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "78a3520dd98b8c7f1e2ef192db31cdec2c2cf116", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -2293,6 +2293,12 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n       *walk_subtrees_p = 0;\n       break;\n \n+    case TRAIT_EXPR:\n+      WALK_SUBTREE (TRAIT_EXPR_TYPE1 (*tp));\n+      WALK_SUBTREE (TRAIT_EXPR_TYPE2 (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+\n     default:\n       return NULL_TREE;\n     }"}, {"sha": "ccdc99516348f919ce4d07ee446188efcd9c612d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -10675,6 +10675,7 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n                         method denoted by a @samp{->*} or @samp{.*} expression.\n * C++ Attributes::      Variable, function, and type attributes for C++ only.\n * Namespace Association:: Strong using-directives for namespace association.\n+* Type Traits::         Compiler support for type traits\n * Java Exceptions::     Tweaking exception handling to work with Java.\n * Deprecated Features:: Things will disappear from g++.\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n@@ -11232,6 +11233,124 @@ int main()\n @}\n @end smallexample\n \n+@node Type Traits\n+@section Type Traits\n+\n+The C++ front-end implements syntactic extensions that allow to\n+determine at compile time various characteristics of a type (or of a\n+pair of types).\n+\n+@table @code\n+@item __has_nothrow_assign (type)\n+If @code{__has_trivial_assign (type)} is true then the trait is true, else if\n+@code{type} is a cv class or union type with copy assignment operators that\n+are known not to throw an exception then the trait is true, else it is false.\n+If @code{type} is const qualified, any copy assignment operator must\n+be both known not to throw an exception, and const qualified, for the\n+trait to be true.  Requires: @code{type} shall be a complete type, an\n+array type of unknown bound, or is a @code{void} type.\n+\n+@item __has_nothrow_copy (type)\n+If @code{__has_trivial_copy (type)} is true then the trait is true, else if\n+@code{type} is a cv class or union type with copy constructors that\n+are known not to throw an exception then the trait is true, else it is false.\n+Requires: @code{type} shall be a complete type, an array type of\n+unknown bound, or is a @code{void} type.\n+\n+@item __has_nothrow_constructor (type)\n+If @code{__has_trivial_constructor (type)} is true then the trait is\n+true, else if @code{type} is a cv class or union type (or array\n+thereof) with a default constructor that is known not to throw an\n+exception then the trait is true, else it is false.  Requires:\n+@code{type} shall be a complete type, an array type of unknown bound,\n+or is a @code{void} type.\n+\n+@item __has_trivial_assign (type)\n+If @code{type} is const qualified or is a reference type then the trait is\n+false.  Otherwise if @code{__is_pod (type)} is true then the trait is\n+true, else if @code{type} is a cv class or union type with a trivial\n+copy assignment ([class.copy]) then the trait is true, else it is\n+false.  Requires: @code{type} shall be a complete type, an array type\n+of unknown bound, or is a @code{void} type.\n+\n+@item __has_trivial_copy (type)\n+If @code{__is_pod (type)} is true or @code{type} is a reference type \n+then the trait is true, else if @code{type} is a cv class or union type\n+with a trivial copy constructor ([class.copy]) then the trait\n+is true, else it is false.  Requires: @code{type} shall be a complete\n+type, an array type of unknown bound, or is a @code{void} type.\n+\n+@item __has_trivial_constructor (type)\n+If @code{__is_pod (type)} is true then the trait is true, else if\n+@code{type} is a cv class or union type (or array thereof) with a\n+trivial default constructor ([class.ctor]) then the trait is true,\n+else it is false.  Requires: @code{type} shall be a complete type, an\n+array type of unknown bound, or is a @code{void} type.\n+\n+@item __has_trivial_destructor (type)\n+If @code{__is_pod (type)} is true or @code{type} is a reference type then\n+the trait is true, else if @code{type} is a cv class or union type (or\n+array thereof) with a trivial destructor ([class.dtor]) then the trait\n+is true, else it is false.  Requires: @code{type} shall be a complete\n+type, an array type of unknown bound, or is a @code{void} type.\n+\n+@item __has_virtual_destructor (type)\n+If @code{type} is a class type with a virtual destructor\n+([class.dtor]) then the trait is true, else it is false.  Requires:\n+@code{type}  shall be a complete type, an array type of unknown bound,\n+or is a @code{void} type.\n+\n+@item __is_abstract (type)\n+If @code{type} is an abstract class ([class.abstract]) then the trait\n+is true, else it is false.  Requires: @code{type} shall be a complete\n+type, an array type of unknown bound, or is a @code{void} type.\n+\n+@item __is_base_of (base_type, derived_type)\n+If @code{base_type} is a base class of @code{derived_type}\n+([class.derived]) then the trait is true, otherwise it is false.\n+Top-level cv qualifications of @code{base_type} and\n+@code{derived_type} are ignored.  For the purposes of this trait, a\n+class type is considered is own base.  Requires: if @code{__is_class\n+(base_type)} and @code{__is_class (derived_type)} are true and\n+@code{base_type} and @code{derived_type} are not the same type\n+(disregarding cv-qualifiers), @code{derived_type} shall be a complete\n+type.  Diagnostic is produced if this requirement is not met.\n+\n+@item __is_class (type)\n+If @code{type} is a cv class type, and not a union type\n+([basic.compound]) the the trait is true, else it is false.\n+\n+@item __is_empty (type)\n+If @code{__is_class (type)} is false then the trait is false.\n+Otherwise @code{type} is considered empty if and only if: @code{type}\n+has no non-static data members, or all non-static data members, if\n+any, are bit-fields of lenght 0, and @code{type} has no virtual\n+members, and @code{type} has no virtual base classes, and @code{type}\n+has no base classes @code{base_type} for which \n+@code{__is_empty (base_type)} is false.  Requires: @code{type} shall\n+be a complete type, an array type of unknown bound, or is a\n+@code{void} type.\n+\n+@item __is_enum (type)\n+If @code{type} is a cv enumeration type ([basic.compound]) the the trait is \n+true, else it is false.\n+\n+@item __is_pod (type)\n+If @code{type} is a cv POD type ([basic.types]) then the trait is true,\n+else it is false.  Requires: @code{type} shall be a complete type, \n+an array type of unknown bound, or is a @code{void} type.\n+\n+@item __is_polymorphic (type)\n+If @code{type} is a polymorphic class ([class.virtual]) then the trait\n+is true, else it is false.  Requires: @code{type} shall be a complete\n+type, an array type of unknown bound, or is a @code{void} type.\n+\n+@item __is_union (type)\n+If @code{type} is a cv union type ([basic.compound]) the the trait is \n+true, else it is false.\n+\n+@end table\n+\n @node Java Exceptions\n @section Java Exceptions\n "}, {"sha": "a1af0d59ca342188cd48fa194f83149f85ad7551", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,3 +1,26 @@\n+2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR c++/26099\n+\t* g++.dg/ext/is_base_of.C: New.\n+\t* g++.dg/ext/has_virtual_destructor.C: New.\n+\t* g++.dg/ext/is_polymorphic.C: New.\n+\t* g++.dg/ext/is_base_of_diagnostic.C: New.\n+\t* g++.dg/ext/is_enum.C: New.\n+\t* g++.dg/ext/has_nothrow_assign.C: New.\n+\t* g++.dg/ext/has_nothrow_constructor.C: New.\n+\t* g++.dg/ext/is_empty.C: New.\n+\t* g++.dg/ext/has_trivial_copy.C: New.\n+\t* g++.dg/ext/has_trivial_assign.C: New.\n+\t* g++.dg/ext/is_abstract.C: New.\n+\t* g++.dg/ext/is_pod.C: New.\n+\t* g++.dg/ext/has_nothrow_copy.C: New.\n+\t* g++.dg/ext/is_class.C: New.\n+\t* g++.dg/ext/has_trivial_constructor.C: New.\n+\t* g++.dg/ext/is_union.C: New.\n+\t* g++.dg/ext/has_trivial_destructor.C: New.\n+\t* g++.dg/tree-ssa/pr22444.C: Adjust, avoid __is_pod.\n+\t* g++.dg/template/crash43.C: Likewise.\n+\n 2007-03-29  Dirk Mueller  <dmueller@suse.de>\n \n \t* g++.dg/warn/pedantic2.C: New testcase."}, {"sha": "f879082535174b2ad23c79817b7d863d562b5e5a", "filename": "gcc/testsuite/g++.dg/ext/has_nothrow_assign.C", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,152 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+struct C\n+: public A { };\n+\n+struct D\n+{\n+  D& operator=(const D&) throw() { return *this; }\n+};\n+\n+struct E\n+{\n+  E& operator=(const E&) throw(int) { return *this; }\n+};\n+\n+struct E1\n+{\n+  E1& operator=(const E1&) throw(int) { throw int(); return *this; }\n+};\n+\n+struct F\n+{\n+  F() throw(int) { }\n+};\n+\n+struct G\n+{\n+  G() throw(int) { throw int(); }\n+};\n+\n+struct H\n+{\n+  H& operator=(H&) throw(int) { return *this; }\n+};\n+\n+struct H1\n+{\n+  H1& operator=(H1&) throw(int) { throw int(); return *this; }\n+};\n+\n+struct I\n+{\n+  I& operator=(I&) throw(int) { return *this; }\n+  I& operator=(const I&) throw() { return *this; }\n+};\n+\n+struct I1\n+{\n+  I1& operator=(I1&) throw(int) { throw int(); return *this; }\n+  I1& operator=(const I1&) throw() { return *this; }\n+};\n+\n+struct J\n+{\n+  J& operator=(J&) throw() { return *this; }\n+  J& operator=(const J&) throw() { return *this; }\n+  J& operator=(volatile J&) throw() { return *this; }\n+  J& operator=(const volatile J&) throw() { return *this; }\n+};\n+\n+struct K\n+{\n+  K& operator=(K&) throw() { return *this; }\n+};\n+\n+struct L\n+{\n+  L& operator=(const L&) throw() { return *this; }\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_nothrow_assign(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_nothrow_assign(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_nothrow_assign(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_nothrow_assign(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_nothrow_assign(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_nothrow_assign(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (B));\n+  assert (PTEST (C));\n+  assert (NTEST (C[]));\n+  assert (PTEST (D));\n+  assert (PTEST (E));\n+  assert (NTEST (E1));\n+  assert (PTEST (F));\n+  assert (PTEST (G));\n+  assert (PTEST (H));\n+  assert (NTEST (H1));\n+  assert (PTEST (I));\n+  assert (NTEST (I1));\n+  assert (PTEST (J));\n+  assert (NTEST (const K));\n+  assert (PTEST (const L));\n+\n+  return 0;\n+}"}, {"sha": "04c2706dad6d20d5535126a561ca912df55db3ac", "filename": "gcc/testsuite/g++.dg/ext/has_nothrow_constructor.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_constructor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_constructor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_constructor.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,106 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+struct C \n+: public A { };\n+\n+struct D\n+{\n+  D() throw() { }\n+};\n+\n+struct E\n+{\n+  E() throw(int) { }\n+};\n+\n+struct E1\n+{\n+  E1() throw(int) { throw int(); }\n+};\n+\n+struct F\n+{\n+  F(const F&) throw() { }\n+};\n+\n+struct G\n+{\n+  G(const G&) throw(int) { throw int(); }\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_nothrow_constructor(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_nothrow_constructor(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_nothrow_constructor(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+\n+template<typename T, bool b = __has_nothrow_constructor(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_nothrow_constructor(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_nothrow_constructor(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (B));\n+  assert (PTEST (C));\n+  assert (PTEST (C[]));\n+  assert (PTEST (D));\n+  assert (PTEST (E));\n+  assert (NTEST (E1));\n+  assert (NTEST (F));\n+  assert (NTEST (G));\n+\n+  return 0;\n+}"}, {"sha": "5ac727c33538bd694db818346e9d99c0d900bd0e", "filename": "gcc/testsuite/g++.dg/ext/has_nothrow_copy.C", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,140 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+struct C\n+: public A { };\n+\n+struct D\n+{\n+  D(const D&) throw() { }\n+};\n+\n+struct E\n+{\n+  E(const E&) throw(int) { }\n+};\n+\n+struct E1\n+{\n+  E1(const E1&) throw(int) { throw int(); }\n+};\n+\n+struct F\n+{\n+  F() throw() { }\n+};\n+\n+struct G\n+{\n+  G() throw(int) { throw int(); }\n+};\n+\n+struct H\n+{\n+  H(H&) throw(int) { }\n+};\n+\n+struct H1\n+{\n+  H1(H1&) throw(int) { throw int(); }\n+};\n+\n+struct I\n+{\n+  I(I&) throw(int) { }\n+  I(const I&) throw() { }\n+};\n+\n+struct I1\n+{\n+  I1(I1&) throw(int) { throw int(); }\n+  I1(const I1&) throw() { }\n+};\n+\n+struct J\n+{\n+  J(J&) throw() { }\n+  J(const J&) throw() { }\n+  J(volatile J&) throw() { }\n+  J(const volatile J&) throw() { }\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_nothrow_copy(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_nothrow_copy(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_nothrow_copy(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_nothrow_copy(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_nothrow_copy(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_nothrow_copy(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (B));\n+  assert (PTEST (C));\n+  assert (NTEST (C[]));\n+  assert (PTEST (D));\n+  assert (PTEST (E));\n+  assert (NTEST (E1));\n+  assert (PTEST (F));\n+  assert (PTEST (G));\n+  assert (PTEST (H));\n+  assert (NTEST (H1));\n+  assert (PTEST (I));\n+  assert (NTEST (I1));  \n+  assert (PTEST (J));\n+\n+  return 0;\n+}"}, {"sha": "97bcbf239974ac017255e008d2fe2bbceec280cf", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_assign.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,106 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  B& operator=(const B&) { return *this;}\n+};\n+\n+struct C\n+{\n+  virtual int f() { return 1; }\n+};\n+\n+struct D \n+: public B { };\n+\n+struct E\n+: public A { };\n+\n+struct F\n+{\n+  A a;\n+};\n+\n+struct G\n+{\n+  B b;\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_trivial_assign(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_trivial_assign(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_trivial_assign(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_trivial_assign(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_trivial_assign(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_trivial_assign(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (U));\n+  assert (NTEST (B));\n+  assert (NTEST (C));\n+  assert (NTEST (D));\n+  assert (PTEST (E));\n+  assert (NTEST (E[]));\n+  assert (PTEST (F));\n+  assert (NTEST (G));\n+  assert (NTEST (const A));\n+  assert (NTEST (A&));\n+  \n+  return 0;\n+}"}, {"sha": "cc747391b3292bc27b161de0a47e0db24f9f9d84", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_constructor.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_constructor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_constructor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_constructor.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,98 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;  \n+};\n+\n+struct B\n+{\n+  B() { }\n+};\n+\n+struct C \n+: public B { };\n+\n+struct D\n+: public A { };\n+\n+struct E\n+{\n+  A a;\n+};\n+\n+struct F\n+{\n+  B b;\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_trivial_constructor(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_trivial_constructor(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_trivial_constructor(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_trivial_constructor(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_trivial_constructor(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_trivial_constructor(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (U));\n+  assert (NTEST (B));\n+  assert (NTEST (C));\n+  assert (PTEST (D));\n+  assert (PTEST (D[]));\n+  assert (PTEST (E));\n+  assert (NTEST (F));\n+\n+  return 0;\n+}"}, {"sha": "ca2eeec4bdb888e3a106298ebcf5e80d98ac3f70", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_copy.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,105 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  B(const B&) { }\n+};\n+\n+struct C\n+{\n+  virtual int f() { return 1; }\n+};\n+\n+struct D \n+: public B { };\n+\n+struct E\n+: public A { };\n+\n+struct F\n+{\n+  A a;\n+};\n+\n+struct G\n+{\n+  B b;\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_trivial_copy(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_trivial_copy(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_trivial_copy(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_trivial_copy(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_trivial_copy(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_trivial_copy(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (U));\n+  assert (NTEST (B));\n+  assert (NTEST (C));\n+  assert (NTEST (D));\n+  assert (PTEST (E));\n+  assert (NTEST (E[]));\n+  assert (PTEST (F));\n+  assert (NTEST (G));\n+  assert (PTEST (B&));\n+\n+  return 0;\n+}"}, {"sha": "719f05fd7a56ea323627c59a23df97327b9cddc7", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_destructor.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_destructor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_destructor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_destructor.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,86 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  ~B() { }\n+};\n+\n+struct C \n+: public B { };\n+\n+struct D\n+: public A { };\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_trivial_destructor(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_trivial_destructor(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_trivial_destructor(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_trivial_destructor(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_trivial_destructor(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_trivial_destructor(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (int (int)));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (U));\n+  assert (NTEST (B));\n+  assert (NTEST (C));\n+  assert (PTEST (D));\n+  assert (PTEST (D[]));\n+\n+  return 0;\n+}"}, {"sha": "c263a94fd043025eb1fbb17ad84cccb8659aa32b", "filename": "gcc/testsuite/g++.dg/ext/has_virtual_destructor.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_virtual_destructor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_virtual_destructor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_virtual_destructor.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,89 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+#include <exception>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{\n+  virtual ~B() { }\n+};\n+\n+class C\n+: public B { };\n+\n+class D\n+{\n+  ~D() { }\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __has_virtual_destructor(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__has_virtual_destructor(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __has_virtual_destructor(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __has_virtual_destructor(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__has_virtual_destructor(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__has_virtual_destructor(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (PTEST (std::exception));\n+  assert (NTEST (A));\n+  assert (NTEST (U));\n+  assert (PTEST (B));\n+  assert (PTEST (C));\n+  assert (NTEST (C[]));\n+  assert (NTEST (D));\n+\n+  return 0;\n+}"}, {"sha": "919f928fd9a6f82fb6a4b1a89c31add031917411", "filename": "gcc/testsuite/g++.dg/ext/is_abstract.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_abstract.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_abstract.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_abstract.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,89 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{\n+  B();\n+};\n+\n+class C\n+{\n+  virtual void rotate(int) = 0;\n+};\n+\n+class D\n+{\n+  virtual void rotate(int) { }\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_abstract(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_abstract(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_abstract(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_abstract(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_abstract(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_abstract(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (NTEST (A));\n+  assert (NTEST (U));\n+  assert (NTEST (B));\n+  assert (NTEST (B[]));  \n+  assert (PTEST (C));\n+  assert (NTEST (D));\n+\n+  return 0;\n+}"}, {"sha": "52ccff100090d3c428f82721fdc5fab5ed6b720a", "filename": "gcc/testsuite/g++.dg/ext/is_base_of.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+class A1\n+{ \n+  double a;\n+  double b;  \n+};\n+\n+class A2\n+{ \n+  double a;\n+  double b;\n+};\n+\n+class B\n+: private A1 { };\n+\n+class C\n+: private A1, private A2 { };\n+\n+union U\n+{ \n+  double a;\n+  double b;\n+};\n+\n+template<typename T, typename U>\n+  bool\n+  f()\n+  { return __is_base_of(T, U); } \n+\n+template<typename T, typename U>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_base_of(T, U); }\n+  };\n+\n+template<typename T, typename U>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_base_of(T, U);\n+  };\n+\n+template<typename T, typename U>\n+  const bool My2<T, U>::trait;\n+\n+template<typename T, typename U, bool b = __is_base_of(T, U)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, typename U, bool b>\n+  const bool My3_help<T, U, b>::trait;\n+\n+template<typename T, typename U>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T, U>::trait; }\n+  };\n+\n+#define PTEST(T, U) (__is_base_of(T, U) && f<T, U>() \\\n+                  && My<T, U>().f() && My2<T, U>::trait && My3<T, U>().f())\n+\n+#define NTEST(T, U) (!__is_base_of(T, U) && !f<T, U>() \\\n+                  && !My<T, U>().f() && !My2<T, U>::trait && !My3<T, U>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int, A1));\n+  assert (NTEST (A1, void));\n+  assert (PTEST (A1, A1));\n+  assert (NTEST (A1*, A1*));\n+  assert (NTEST (A1&, A1&));\n+  assert (PTEST (A1, B));\n+  assert (NTEST (B, A1));\n+  assert (PTEST (A1, C));\n+  assert (PTEST (A2, C));\n+  assert (NTEST (C, A1));\n+  assert (PTEST (A1, const B));\n+  assert (NTEST (const B, A1));\n+  assert (PTEST (A1, volatile C));\n+  assert (PTEST (volatile A2, const C));\n+  assert (NTEST (const volatile C, A1));\n+  assert (NTEST (U, U));\n+\n+  return 0;\n+}"}, {"sha": "8cb1ce38f635d2f0f16064d607dcc7c6c1e4f81d", "filename": "gcc/testsuite/g++.dg/ext/is_base_of_diagnostic.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of_diagnostic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of_diagnostic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_base_of_diagnostic.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,15 @@\n+class A\n+{ };\n+\n+class B;\n+\n+union C\n+{ };\n+\n+union D;\n+\n+void f()\n+{\n+  __is_base_of(A, B);  // { dg-error \"incomplete type\" }\n+  __is_base_of(C, D);  \n+}"}, {"sha": "6f0c8a5ba5b47e3f1855845b2ae0ed247d911c6e", "filename": "gcc/testsuite/g++.dg/ext/is_class.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_class.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_class.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_class.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,76 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{\n+  B() { }\n+};\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_class(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_class(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_class(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_class(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_class(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_class(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (B));\n+  assert (NTEST (U));\n+\n+  return 0;\n+}"}, {"sha": "86a0312c25805ac53f0a29262baa304c4c2d69f7", "filename": "gcc/testsuite/g++.dg/ext/is_empty.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_empty.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_empty.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_empty.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,78 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  virtual ~B() { }\n+};\n+\n+class C \n+{ };\n+\n+union U\n+{ };\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_empty(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_empty(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_empty(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_empty(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_empty(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_empty(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (NTEST (A));\n+  assert (NTEST (B));\n+  assert (PTEST (C));\n+  assert (NTEST (C[]));\n+  assert (NTEST (U));\n+\n+  return 0;\n+}"}, {"sha": "7dc061cec7668b6e6675d5cefdbe6415c514f6c8", "filename": "gcc/testsuite/g++.dg/ext/is_enum.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_enum.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_enum.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_enum.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{ };\n+\n+enum E\n+{\n+  e0\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_enum(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_enum(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_enum(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_enum(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_enum(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_enum(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (NTEST (A));\n+  assert (NTEST (B));\n+  assert (PTEST (E));\n+\n+  return 0;\n+}"}, {"sha": "5c1f0cd3bcd289ea1050b3eaad4f5c10cae37f5c", "filename": "gcc/testsuite/g++.dg/ext/is_pod.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,75 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+struct B\n+{\n+  B() { }\n+};\n+\n+struct C\n+: public A { };\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_pod(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_pod(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_pod(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_pod(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_pod(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_pod(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (PTEST (int));\n+  assert (NTEST (void));\n+  assert (PTEST (A));\n+  assert (PTEST (A[]));\n+  assert (NTEST (B));\n+  assert (NTEST (C));\n+  assert (NTEST (C[]));\n+\n+  return 0;\n+}"}, {"sha": "ded071b1d02aa851e05751471c72c0e9e8dc73b6", "filename": "gcc/testsuite/g++.dg/ext/is_polymorphic.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_polymorphic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_polymorphic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_polymorphic.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,83 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+#include <exception>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{\n+  virtual void rotate(int) { }\n+};\n+\n+class C\n+: public B { };\n+\n+union U\n+{\n+  double a;\n+  double b;\n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_polymorphic(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_polymorphic(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_polymorphic(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_polymorphic(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_polymorphic(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_polymorphic(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (PTEST (std::exception));\n+  assert (NTEST (A));\n+  assert (PTEST (B));\n+  assert (PTEST (C));\n+  assert (NTEST (C[]));\n+  assert (NTEST (U));\n+\n+  return 0;\n+}"}, {"sha": "acba0bb60f2b5b94139e326450bf91e204e95b84", "filename": "gcc/testsuite/g++.dg/ext/is_union.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_union.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_union.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_union.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -0,0 +1,76 @@\n+// { dg-do \"run\" }\n+#include <cassert>\n+\n+struct A\n+{\n+  double a;\n+  double b;\n+};\n+\n+class B\n+{\n+  B() { }\n+};\n+\n+union U\n+{ \n+  double a;\n+  double b;  \n+};\n+\n+template<typename T>\n+  bool\n+  f()\n+  { return __is_union(T); } \n+\n+template<typename T>\n+  class My\n+  {\n+  public:\n+    bool\n+    f()\n+    { return !!__is_union(T); }\n+  };\n+\n+template<typename T>\n+  class My2\n+  {\n+  public:\n+    static const bool trait = __is_union(T);\n+  };\n+\n+template<typename T>\n+  const bool My2<T>::trait;\n+\n+template<typename T, bool b = __is_union(T)>\n+  struct My3_help\n+  { static const bool trait = b; };\n+\n+template<typename T, bool b>\n+  const bool My3_help<T, b>::trait;\n+\n+template<typename T>\n+  class My3\n+  {\n+  public:\n+    bool\n+    f()\n+    { return My3_help<T>::trait; }\n+  };\n+\n+#define PTEST(T) (__is_union(T) && f<T>() \\\n+                  && My<T>().f() && My2<T>::trait && My3<T>().f())\n+\n+#define NTEST(T) (!__is_union(T) && !f<T>() \\\n+                  && !My<T>().f() && !My2<T>::trait && !My3<T>().f())\n+\n+int main()\n+{\n+  assert (NTEST (int));\n+  assert (NTEST (void));\n+  assert (NTEST (A));\n+  assert (NTEST (B));\n+  assert (PTEST (U));\n+\n+  return 0;\n+}"}, {"sha": "cbb1221b355d0d1bcf5e6d1fd1c3f2d70caf130d", "filename": "gcc/testsuite/g++.dg/template/crash43.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash43.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -2,7 +2,7 @@\n \n extern \"C\" {\n   template<typename _Tp>  // { dg-error \"C\" }   \n-  struct __is_pod {\n+  struct ___is_pod {\n     enum {\n       __value = (sizeof(__gnu_internal::__test_type<_Tp>(0)))}; // { dg-error \"declared|expected\" }\n "}, {"sha": "2cc84bb9d1efa887fbda52f9888897a76e27c80f", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr22444.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22444.C?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -22,7 +22,7 @@ namespace __gnu_internal\n }\n namespace std\n {\n-  template<typename _Tp> struct __is_pod\n+  template<typename _Tp> struct ___is_pod\n   {\n     enum { __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))!= sizeof(__gnu_internal::__one)) };\n   };\n@@ -111,7 +111,7 @@ namespace std\n     typedef _Val value_type;\n     typedef value_type* pointer;\n     typedef _Rb_tree_node* _Link_type;\n-    template<typename _Key_compare, bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value> struct _Rb_tree_impl\n+    template<typename _Key_compare, bool _Is_pod_comparator = std::___is_pod<_Key_compare>::__value> struct _Rb_tree_impl\n       : _Node_allocator\n     {\n       _Rb_tree_node_base _M_header;"}, {"sha": "a6ab09b72fe06602871bdc1e91b953c24e40da9a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,3 +1,12 @@\n+2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR c++/26099\n+\t* include/bits/cpp_type_traits.h (struct __is_pod, struct __is_empty):\n+\tRemove.\n+\t* include/bits/valarray_array.h: Adjust.\n+\t* include/bits/allocator.h: Likewise.\n+\t* include/bits/stl_tree.h: Likewise.\n+\n 2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/31401"}, {"sha": "94f43ce23f32607c629cbdad596a4808f98a3cc0", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,6 +1,6 @@\n // Allocators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -132,7 +132,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n #undef __glibcxx_base_allocator\n \n   // To implement Option 3 of DR 431.\n-  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>\n+  template<typename _Alloc, bool = __is_empty(_Alloc)>\n     struct __alloc_swap\n     { static void _S_do_it(_Alloc&, _Alloc&) { } };\n "}, {"sha": "f3c71ac1be5c66e68e3e3c9dc477519103da2ce7", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,6 +1,6 @@\n // The  -*- C++ -*- type traits classes for internal use in libstdc++\n \n-// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -80,20 +80,6 @@ _GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n-namespace __detail\n-{\n-  // NB: g++ can not compile these if declared within the class\n-  // __is_pod itself.\n-  typedef char __one;\n-  typedef char __two[2];\n-\n-  template<typename _Tp>\n-  __one __test_type(int _Tp::*);\n-  template<typename _Tp>\n-  __two& __test_type(...);\n-} // namespace __detail\n-\n-\n   struct __true_type { };\n   struct __false_type { };\n \n@@ -341,37 +327,6 @@ namespace __detail\n     : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >\n     { };\n \n-  // For the immediate use, the following is a good approximation.\n-  template<typename _Tp>\n-    struct __is_pod\n-    {\n-      enum\n-\t{\n-\t  __value = (sizeof(__detail::__test_type<_Tp>(0))\n-\t\t     != sizeof(__detail::__one))\n-\t};\n-    };\n-\n-  //\n-  // A stripped-down version of std::tr1::is_empty\n-  //\n-  template<typename _Tp>\n-    struct __is_empty\n-    { \n-    private:\n-      template<typename>\n-        struct __first { };\n-      template<typename _Up>\n-        struct __second\n-        : public _Up { };\n-           \n-    public:\n-      enum\n-\t{\n-\t  __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)\n-\t};\n-    };\n-\n   //\n   // For use in std::copy and std::find overloads for streambuf iterators.\n   //"}, {"sha": "e80afc808a3ab6425c439861fc63eba993c1cef4", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -393,7 +393,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     protected:\n       template<typename _Key_compare, \n-\t       bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>\n+\t       bool _Is_pod_comparator = __is_pod(_Key_compare)>\n         struct _Rb_tree_impl : public _Node_allocator\n         {\n \t  _Key_compare\t\t_M_key_compare;"}, {"sha": "12a6b5fd4190757393b19b3a851f5e49dc513113", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb68ec50055e516ac270a043f772935561b01968/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=cb68ec50055e516ac270a043f772935561b01968", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- internal _Array helper class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2003, 2004, 2005, 2006, 2007\n //  Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -98,7 +98,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     inline void\n     __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n     {\n-      _Array_default_ctor<_Tp, __is_pod<_Tp>::__value>::_S_do_it(__b, __e);\n+      _Array_default_ctor<_Tp, __is_pod(_Tp)>::_S_do_it(__b, __e);\n     }\n \n   // Turn a raw-memory into an array of _Tp filled with __t\n@@ -133,7 +133,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n \t\t\t      const _Tp __t)\n     {\n-      _Array_init_ctor<_Tp, __is_pod<_Tp>::__value>::_S_do_it(__b, __e, __t);\n+      _Array_init_ctor<_Tp, __is_pod(_Tp)>::_S_do_it(__b, __e, __t);\n     }\n \n   //\n@@ -169,7 +169,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t      const _Tp* __restrict__ __e,\n \t\t\t      _Tp* __restrict__ __o)\n     {\n-      _Array_copy_ctor<_Tp, __is_pod<_Tp>::__value>::_S_do_it(__b, __e, __o);\n+      _Array_copy_ctor<_Tp, __is_pod(_Tp)>::_S_do_it(__b, __e, __o);\n     }\n \n   // copy-construct raw array [__o, *) from strided array __a[<__n : __s>]\n@@ -178,7 +178,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n \t\t\t       size_t __s, _Tp* __restrict__ __o)\n     {\n-      if (__is_pod<_Tp>::__value)\n+      if (__is_pod(_Tp))\n \twhile (__n--)\n \t  {\n \t    *__o++ = *__a;\n@@ -199,7 +199,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t       const size_t* __restrict__ __i,\n \t\t\t       _Tp* __restrict__ __o, size_t __n)\n     {\n-      if (__is_pod<_Tp>::__value)\n+      if (__is_pod(_Tp))\n \twhile (__n--)\n \t  *__o++ = __a[*__i++];\n       else\n@@ -212,7 +212,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     inline void\n     __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n     {\n-      if (!__is_pod<_Tp>::__value)\n+      if (!__is_pod(_Tp))\n \twhile (__b != __e)\n \t  {\n \t    __b->~_Tp();\n@@ -276,7 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n \t\t    _Tp* __restrict__ __b)\n     {\n-      _Array_copier<_Tp, __is_pod<_Tp>::__value>::_S_do_it(__a, __n, __b);\n+      _Array_copier<_Tp, __is_pod(_Tp)>::_S_do_it(__a, __n, __b);\n     }\n \n   // Copy strided array __a[<__n : __s>] in plain __b[<__n>]"}]}