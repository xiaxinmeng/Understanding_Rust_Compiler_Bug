{"sha": "4fe73cc129e2b244d4ae113844518028ff7df440", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlNzNjYzEyOWUyYjI0NGQ0YWUxMTM4NDQ1MTgwMjhmZjdkZjQ0MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-26T21:35:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-26T21:35:38Z"}, "message": "(rtx_renumbered_equal_p): Fix bug in comparing SUBREGs and REGs.\n\nTwo commutative operations are equal if the operands are in the opposite order.\n\nFrom-SVN: r6633", "tree": {"sha": "225658ecf505f29914870b367d71b974fc07b35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/225658ecf505f29914870b367d71b974fc07b35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe73cc129e2b244d4ae113844518028ff7df440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe73cc129e2b244d4ae113844518028ff7df440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe73cc129e2b244d4ae113844518028ff7df440", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe73cc129e2b244d4ae113844518028ff7df440/comments", "author": null, "committer": null, "parents": [{"sha": "63770d6ae3acabd6aa3542993afefd37c4ccfd8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63770d6ae3acabd6aa3542993afefd37c4ccfd8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63770d6ae3acabd6aa3542993afefd37c4ccfd8f"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "f2d4a44de7a3d67cfca4e3a0b516dab9961676c8", "filename": "gcc/jump.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe73cc129e2b244d4ae113844518028ff7df440/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe73cc129e2b244d4ae113844518028ff7df440/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4fe73cc129e2b244d4ae113844518028ff7df440", "patch": "@@ -3733,7 +3733,9 @@ delete_labelref_insn (insn, label, delete_this)\n }\n \f\n /* Like rtx_equal_p except that it considers two REGs as equal\n-   if they renumber to the same value.  */\n+   if they renumber to the same value and considers two commutative\n+   operations to be the same if the order of the operands has been\n+   reversed.  */\n \n int\n rtx_renumbered_equal_p (x, y)\n@@ -3745,11 +3747,13 @@ rtx_renumbered_equal_p (x, y)\n       \n   if (x == y)\n     return 1;\n+\n   if ((code == REG || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG))\n       && (GET_CODE (y) == REG || (GET_CODE (y) == SUBREG\n \t\t\t\t  && GET_CODE (SUBREG_REG (y)) == REG)))\n     {\n-      register int j;\n+      int reg_x = -1, reg_y = -1;\n+      int word_x = 0, word_y = 0;\n \n       if (GET_MODE (x) != GET_MODE (y))\n \treturn 0;\n@@ -3761,36 +3765,50 @@ rtx_renumbered_equal_p (x, y)\n \n       if (code == SUBREG)\n \t{\n-\t  i = REGNO (SUBREG_REG (x));\n-\t  if (reg_renumber[i] >= 0)\n-\t    i = reg_renumber[i];\n-\t  i += SUBREG_WORD (x);\n+\t  reg_x = REGNO (SUBREG_REG (x));\n+\t  word_x = SUBREG_WORD (x);\n+\n+\t  if (reg_renumber[reg_x] >= 0)\n+\t    {\n+\t      reg_x = reg_renumber[reg_x] + word_x;\n+\t      word_x = 0;\n+\t    }\n \t}\n+\n       else\n \t{\n-\t  i = REGNO (x);\n-\t  if (reg_renumber[i] >= 0)\n-\t    i = reg_renumber[i];\n+\t  reg_x = REGNO (x);\n+\t  if (reg_renumber[reg_x] >= 0)\n+\t    reg_x = reg_renumber[reg_x];\n \t}\n+\n       if (GET_CODE (y) == SUBREG)\n \t{\n-\t  j = REGNO (SUBREG_REG (y));\n-\t  if (reg_renumber[j] >= 0)\n-\t    j = reg_renumber[j];\n-\t  j += SUBREG_WORD (y);\n+\t  reg_y = REGNO (SUBREG_REG (y));\n+\t  word_y = SUBREG_WORD (y);\n+\n+\t  if (reg_renumber[reg_y] >= 0)\n+\t    {\n+\t      reg_y = reg_renumber[reg_y];\n+\t      word_y = 0;\n+\t    }\n \t}\n+\n       else\n \t{\n-\t  j = REGNO (y);\n-\t  if (reg_renumber[j] >= 0)\n-\t    j = reg_renumber[j];\n+\t  reg_y = REGNO (y);\n+\t  if (reg_renumber[reg_y] >= 0)\n+\t    reg_y = reg_renumber[reg_y];\n \t}\n-      return i == j;\n+\n+      return reg_x >= 0 && reg_x == reg_y && word_x == word_y;\n     }\n+\n   /* Now we have disposed of all the cases \n      in which different rtx codes can match.  */\n   if (code != GET_CODE (y))\n     return 0;\n+\n   switch (code)\n     {\n     case PC:\n@@ -3806,6 +3824,7 @@ rtx_renumbered_equal_p (x, y)\n       /* We can't assume nonlocal labels have their following insns yet.  */\n       if (LABEL_REF_NONLOCAL_P (x) || LABEL_REF_NONLOCAL_P (y))\n \treturn XEXP (x, 0) == XEXP (y, 0);\n+\n       /* Two label-refs are equivalent if they point at labels\n \t in the same position in the instruction stream.  */\n       return (next_real_insn (XEXP (x, 0))\n@@ -3820,6 +3839,19 @@ rtx_renumbered_equal_p (x, y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* For commutative operations, the RTX match if the operand match in any\n+     order.  Also handle the simple binary and unary cases without a loop.  */\n+  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n+    return ((rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0))\n+\t     && rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 1)))\n+\t    || (rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 1))\n+\t\t&& rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 0))));\n+  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n+    return (rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0))\n+\t    && rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 1)));\n+  else if (GET_RTX_CLASS (code) == '1')\n+    return rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0));\n+\n   /* Compare the elements.  If any pair of corresponding elements\n      fail to match, return 0 for the whole things.  */\n "}]}