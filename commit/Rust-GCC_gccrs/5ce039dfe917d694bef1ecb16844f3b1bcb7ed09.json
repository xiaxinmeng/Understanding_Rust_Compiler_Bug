{"sha": "5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNlMDM5ZGZlOTE3ZDY5NGJlZjFlY2IxNjg0NGYzYjFiY2I3ZWQwOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-11T22:24:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-11T22:24:33Z"}, "message": "class.c (fixup_type_variants): Do not copy TYPE_METHODS\n\n\n\t* class.c (fixup_type_variants): Do not copy TYPE_METHODS\n\t(one_inheriting_sig): Assert tat we always set TYPE_METHODS of main variant.\n\t* semantics.c (finish_member_declaration): Likewise.\n\t* method.c (lazily_declare_fn): Allways add method to main variant list.\n\n\t* dwarf2out.c (gen_member_die): Sanity check that we access TYPE_MAIN_VARIANT\n\tfor TYPE_METHODS.\n\t* function.c (use_register_for_decl): Look for TYPE_MAIN_VARIANT when checking\n\tTYPE_METHODS.\n\t* tree.c (free_lang_data_in_type): See TYPE_METHODS to error_mark_node\n\tif non-null.\n\t(build_distinct_type_copy): Clear TYPE_METHODS.\n\t(verify_type_variant): Verify that TYPE_METHODS is NULL for variants.\n\t(verify_type): Allow TYPE_METHODS to be error_mark_node.\n\t* tree.def: Update docs of YTPE_STUB_DECL and TYPE_METHODS.\n\nFrom-SVN: r223021", "tree": {"sha": "b27aa77b5c6f68e088a61128b1c06c597c6b36f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b27aa77b5c6f68e088a61128b1c06c597c6b36f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/comments", "author": null, "committer": null, "parents": [{"sha": "20d4397af8a085a17925d3a3a3545748d5ab7fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d4397af8a085a17925d3a3a3545748d5ab7fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20d4397af8a085a17925d3a3a3545748d5ab7fc6"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "d7d5ca01cfec70493f686ae454a0bc0dfb752554", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -1,3 +1,16 @@\n+2015-05-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* dwarf2out.c (gen_member_die): Sanity check that we access\n+\tTYPE_MAIN_VARIANT for TYPE_METHODS.\n+\t* function.c (use_register_for_decl): Look for TYPE_MAIN_VARIANT when\n+\tchecking TYPE_METHODS.\n+\t* tree.c (free_lang_data_in_type): See TYPE_METHODS to error_mark_node\n+\tif non-null.\n+\t(build_distinct_type_copy): Clear TYPE_METHODS.\n+\t(verify_type_variant): Verify that TYPE_METHODS is NULL for variants.\n+\t(verify_type): Allow TYPE_METHODS to be error_mark_node.\n+\t* tree.def: Update docs of TYPE_STUB_DECL and TYPE_METHODS.\n+\n 2015-05-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* emit-rtl.c (emit_pattern_after_setloc): Add missing guard."}, {"sha": "0bdbf3c4c1cedfe25e3f9ceb5d30169466b0775c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -1,3 +1,10 @@\n+2015-05-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* class.c (fixup_type_variants): Do not copy TYPE_METHODS\n+\t(one_inheriting_sig): Assert tat we always set TYPE_METHODS of main variant.\n+\t* semantics.c (finish_member_declaration): Likewise.\n+\t* method.c (lazily_declare_fn): Allways add method to main variant list.\n+\n 2015-05-09  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR bootstrap/66085"}, {"sha": "41607055493bc74fb08dbbb12d9cbe64d54595ab", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -1972,7 +1972,6 @@ fixup_type_variants (tree t)\n \n       /* Copy whatever these are holding today.  */\n       TYPE_VFIELD (variants) = TYPE_VFIELD (t);\n-      TYPE_METHODS (variants) = TYPE_METHODS (t);\n       TYPE_FIELDS (variants) = TYPE_FIELDS (t);\n     }\n }\n@@ -3238,6 +3237,7 @@ one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n     parmlist = tree_cons (NULL_TREE, parms[i], parmlist);\n   tree fn = implicitly_declare_fn (sfk_inheriting_constructor,\n \t\t\t\t   t, false, ctor, parmlist);\n+  gcc_assert (TYPE_MAIN_VARIANT (t) == t);\n   if (add_method (t, fn, NULL_TREE))\n     {\n       DECL_CHAIN (fn) = TYPE_METHODS (t);"}, {"sha": "d41e1125aaa6035b42ce4bb55fe0df313801faf1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -2139,6 +2139,8 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n   /* Whether or not the argument has a const reference type.  */\n   bool const_p = false;\n \n+  type = TYPE_MAIN_VARIANT (type);\n+\n   switch (sfk)\n     {\n     case sfk_constructor:"}, {"sha": "e1d18fb9f3dddfb99168fa76cfe5e12267683aef", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -2913,6 +2913,7 @@ finish_member_declaration (tree decl)\n \t CLASSTYPE_METHOD_VEC.  */\n       if (add_method (current_class_type, decl, NULL_TREE))\n \t{\n+\t  gcc_assert (TYPE_MAIN_VARIANT (current_class_type) == current_class_type);\n \t  DECL_CHAIN (decl) = TYPE_METHODS (current_class_type);\n \t  TYPE_METHODS (current_class_type) = decl;\n "}, {"sha": "3212c2e845d92c36ec42b94ec54e386f521bd003", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -19945,23 +19945,26 @@ gen_member_die (tree type, dw_die_ref context_die)\n \tgen_decl_die (member, NULL, context_die);\n     }\n \n+  /* We do not keep type methods in type variants.  */\n+  gcc_assert (TYPE_MAIN_VARIANT (type) == type);\n   /* Now output info about the function members (if any).  */\n-  for (member = TYPE_METHODS (type); member; member = DECL_CHAIN (member))\n-    {\n-      /* Don't include clones in the member list.  */\n-      if (DECL_ABSTRACT_ORIGIN (member))\n-\tcontinue;\n-      /* Nor constructors for anonymous classes.  */\n-      if (DECL_ARTIFICIAL (member)\n-\t  && dwarf2_name (member, 0) == NULL)\n-\tcontinue;\n+  if (TYPE_METHODS (type) != error_mark_node)\n+    for (member = TYPE_METHODS (type); member; member = DECL_CHAIN (member))\n+      {\n+\t/* Don't include clones in the member list.  */\n+\tif (DECL_ABSTRACT_ORIGIN (member))\n+\t  continue;\n+\t/* Nor constructors for anonymous classes.  */\n+\tif (DECL_ARTIFICIAL (member)\n+\t    && dwarf2_name (member, 0) == NULL)\n+\t  continue;\n \n-      child = lookup_decl_die (member);\n-      if (child)\n-\tsplice_child_die (context_die, child);\n-      else\n-\tgen_decl_die (member, NULL, context_die);\n-    }\n+\tchild = lookup_decl_die (member);\n+\tif (child)\n+\t  splice_child_die (context_die, child);\n+\telse\n+\t  gen_decl_die (member, NULL, context_die);\n+      }\n }\n \n /* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG"}, {"sha": "42d5aebd418f636c5135994be2998ebda090f458", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -2170,7 +2170,7 @@ use_register_for_decl (const_tree decl)\n       /* When not optimizing, disregard register keyword for variables with\n \t types containing methods, otherwise the methods won't be callable\n \t from the debugger.  */\n-      if (TYPE_METHODS (TREE_TYPE (decl)))\n+      if (TYPE_METHODS (TYPE_MAIN_VARIANT (TREE_TYPE (decl))))\n \treturn false;\n       break;\n     default:"}, {"sha": "97e84eb74096f36f0feffe72484da0ce815a1ba1", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -5100,7 +5100,13 @@ free_lang_data_in_type (tree type)\n       if (TYPE_VFIELD (type) && TREE_CODE (TYPE_VFIELD (type)) != FIELD_DECL)\n         TYPE_VFIELD (type) = NULL_TREE;\n \n-      TYPE_METHODS (type) = NULL_TREE;\n+      /* Remove TYPE_METHODS list.  While it would be nice to keep it\n+ \t to enable ODR warnings about different method lists, doing so\n+\t seems to impractically increase size of LTO data streamed.\n+\t Keep the infrmation if TYPE_METHODS was non-NULL. This is used\n+\t by function.c and pretty printers.  */\n+      if (TYPE_METHODS (type))\n+        TYPE_METHODS (type) = error_mark_node;\n       if (TYPE_BINFO (type))\n \t{\n \t  free_lang_data_in_binfo (TYPE_BINFO (type));\n@@ -6574,6 +6580,12 @@ build_distinct_type_copy (tree type)\n   TYPE_MAIN_VARIANT (t) = t;\n   TYPE_NEXT_VARIANT (t) = 0;\n \n+  /* We do not record methods in type copies nor variants\n+     so we do not need to keep them up to date when new method\n+     is inserted.  */\n+  if (RECORD_OR_UNION_TYPE_P (t))\n+    TYPE_METHODS (t) = NULL_TREE;\n+\n   /* Note that it is now possible for TYPE_MIN_VALUE to be a value\n      whose TREE_TYPE is not t.  This can also happen in the Ada\n      frontend when using subtypes.  */\n@@ -12528,13 +12540,9 @@ verify_type_variant (const_tree t, tree tv)\n       debug_tree (tv);\n       return false;\n     }\n-  /* FIXME: this check triggers during libstdc++ build that is a bug.\n-     It affects non-LTO debug output only, because free_lang_data clears\n-     this anyway.  */\n-  if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t) && 0\n-      && TYPE_METHODS (t) != TYPE_METHODS (tv))\n+  if (RECORD_OR_UNION_TYPE_P (t) && TYPE_METHODS (t))\n     {\n-      error (\"type variant has different TYPE_METHODS\");\n+      error (\"type variant has TYPE_METHODS\");\n       debug_tree (tv);\n       return false;\n     }\n@@ -12749,9 +12757,10 @@ verify_type (const_tree t)\n   if (RECORD_OR_UNION_TYPE_P (t))\n     {\n       if (TYPE_METHODS (t) && TREE_CODE (TYPE_METHODS (t)) != FUNCTION_DECL\n-\t  && TREE_CODE (TYPE_METHODS (t)) != TEMPLATE_DECL)\n+\t  && TREE_CODE (TYPE_METHODS (t)) != TEMPLATE_DECL\n+\t  && TYPE_METHODS (t) != error_mark_node)\n \t{\n-\t  error (\"TYPE_METHODS is not FUNCTION_DECL nor TEMPLATE_DECL\");\n+\t  error (\"TYPE_METHODS is not FUNCTION_DECL, TEMPLATE_DECL nor error_mark_node\");\n \t  debug_tree (TYPE_METHODS (t));\n \t  error_found = true;\n \t}"}, {"sha": "56580af664c61a582cd07393f789a779fbad2b46", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce039dfe917d694bef1ecb16844f3b1bcb7ed09/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5ce039dfe917d694bef1ecb16844f3b1bcb7ed09", "patch": "@@ -110,9 +110,12 @@ DEFTREECODE (BLOCK, \"block\", tcc_exceptional, 0)\n     particular, since any type which is of some type category  (e.g.\n     an array type or a function type) which cannot either have a name\n     itself or have named members doesn't really have a \"scope\" per se.\n-  The TREE_CHAIN field is used as a forward-references to names for\n+  The TYPE_STUB_DECL field is used as a forward-references to names for\n     ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n-    see below.  */\n+    see below.\n+  The TYPE_METHODS points to list of all methods associated with the type.\n+    It is non-NULL only at main variant of the type and after free_lang_data\n+    it may be set to error_mark_node instead of actual list to save memory. */\n \n /* The ordering of the following codes is optimized for the checking\n    macros in tree.h.  Changing the order will degrade the speed of the"}]}