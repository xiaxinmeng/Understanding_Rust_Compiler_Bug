{"sha": "e1f9550a643dc51e8058afeba44c818350a9012b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmOTU1MGE2NDNkYzUxZTgwNThhZmViYTQ0YzgxODM1MGE5MDEyYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-05-16T22:42:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-05-16T22:42:36Z"}, "message": "except.c (eh_data_format_name): Move to ...\n\n\t* except.c (eh_data_format_name): Move to ...\n\t* dwarf2asm.c: ... here.  Use designated initializers if available.\n\t(dw2_asm_output_encoded_addr_rtx): Accept varargs commentary.\n\t* dwarf2asm.h: Update declarations.\n\t* dwarf2out.c (output_cfi) [DW_CFA_set_loc]: If for_eh, mind\n\tASM_PREFERRED_EH_DATA_FORMAT.\n\t(output_call_frame_info): Likewise.  Use 'L' augmentation for\n\tthe LSDA encoding.\n\n\t* unwind-dw2-fde.h (struct fde_vector): New.\n\t(struct old_object): Rename from struct object.\n\t(struct object): New.\n\t(__register_frame_info_bases): Declare.\n\t(__register_frame_info_table_bases): Declare.\n\t(struct dwarf_fde): Remove explicit pc_begin/pc_range members.\n\t* unwind-dw2-fde.c (objects): Remove.\n\t(unseen_objects, seen_objects): New.\n\t(__register_frame_info_bases): New.\n\t(__register_frame_info): Use it.\n\t(__register_frame_info_table_bases): New.\n\t(__register_frame_info_table): Use it.\n\t(__deregister_frame_info): Rewrite for changed object struct.\n\t(base_from_object, get_cie_encoding, get_fde_encoding): New.\n\t(fde_unencoded_compare): Rename from fde_compare; uninline.\n\t(fde_single_encoding_compare, fde_mixed_encoding_compare): New.\n\t(start_fde_sort): Adjust for new definition of fde_vector.\n\t(fde_insert): Likewise.\n\t(end_fde_sort): Likewise.  Select comparison function based\n\ton properties of the object.\n\t(fde_split): Take object and fde_compare_t arguments.\n\t(frame_heapsort, fde_merge): Likewise.\n\t(classify_object_over_fdes): Rename from count_fdes.  Handle\n\tencoded pointers.  Collect encoding, mixed_encoding, and pc_begin\n\tfor the object.\n\t(add_fdes): Handle encoded pointers.\n\t(init_object): Rename from frame_init.  Update for new struct object.\n\t(linear_search_fdes): Rename from search_fdes.  Handle encoded\n\tpointers.\n\t(binary_search_unencoded_fdes): Broken out from _Unwind_Find_FDE.\n\t(binary_search_single_encoding_fdes): New.\n\t(binary_search_mixed_encoding_fdes): New.\n\t(search_object): New.\n\t(_Unwind_Find_FDE): Update for new struct object.  Fill in\n\tthe dwarf_eh_bases.\n\t* unwind-dw2.c: Include unwind-pe.h.  Constify all pointers\n\titerating over EH data.\n\t(_Unwind_FrameState): Remove saw_lsda, addr_encoding.  Add\n\tfde_encoding, lsda_encoding.\n\t(read_uleb128, read_sleb128): Remove.\n\t(read_encoded_pointer): Remove.  All callers use read_encoded_value.\n\t(extract_cie_info): Set lsda_encoding from 'L' augmentation.\n\t(uw_frame_state_for): Don't set bases.func.  Handle encoded fde\n\tpointers.\n\t* unwind-pe.h: Add \"struct\" to _Unwind_Context references.\n\nFrom-SVN: r42176", "tree": {"sha": "0115a87b72de59adf0b97d879e1d5d59187631ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0115a87b72de59adf0b97d879e1d5d59187631ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f9550a643dc51e8058afeba44c818350a9012b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f9550a643dc51e8058afeba44c818350a9012b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f9550a643dc51e8058afeba44c818350a9012b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f9550a643dc51e8058afeba44c818350a9012b/comments", "author": null, "committer": null, "parents": [{"sha": "f2cf5c14d84944afe85e2736d5582c5721a99d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cf5c14d84944afe85e2736d5582c5721a99d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2cf5c14d84944afe85e2736d5582c5721a99d9a"}], "stats": {"total": 1687, "additions": 1098, "deletions": 589}, "files": [{"sha": "be345a47f10e35a61c27e2d5a002fc8755515298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -1,3 +1,60 @@\n+2001-05-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (eh_data_format_name): Move to ...\n+\t* dwarf2asm.c: ... here.  Use designated initializers if available.\n+\t(dw2_asm_output_encoded_addr_rtx): Accept varargs commentary.\n+\t* dwarf2asm.h: Update declarations.\n+\t* dwarf2out.c (output_cfi) [DW_CFA_set_loc]: If for_eh, mind\n+\tASM_PREFERRED_EH_DATA_FORMAT.\n+\t(output_call_frame_info): Likewise.  Use 'L' augmentation for\n+\tthe LSDA encoding.\n+\n+\t* unwind-dw2-fde.h (struct fde_vector): New.\n+\t(struct old_object): Rename from struct object.\n+\t(struct object): New.\n+\t(__register_frame_info_bases): Declare.\n+\t(__register_frame_info_table_bases): Declare.\n+\t(struct dwarf_fde): Remove explicit pc_begin/pc_range members.\n+\t* unwind-dw2-fde.c (objects): Remove.\n+\t(unseen_objects, seen_objects): New.\n+\t(__register_frame_info_bases): New.\n+\t(__register_frame_info): Use it.\n+\t(__register_frame_info_table_bases): New.\n+\t(__register_frame_info_table): Use it.\n+\t(__deregister_frame_info): Rewrite for changed object struct.\n+\t(base_from_object, get_cie_encoding, get_fde_encoding): New.\n+\t(fde_unencoded_compare): Rename from fde_compare; uninline.\n+\t(fde_single_encoding_compare, fde_mixed_encoding_compare): New.\n+\t(start_fde_sort): Adjust for new definition of fde_vector.\n+\t(fde_insert): Likewise.\n+\t(end_fde_sort): Likewise.  Select comparison function based\n+\ton properties of the object.\n+\t(fde_split): Take object and fde_compare_t arguments.\n+\t(frame_heapsort, fde_merge): Likewise.\n+\t(classify_object_over_fdes): Rename from count_fdes.  Handle\n+\tencoded pointers.  Collect encoding, mixed_encoding, and pc_begin\n+\tfor the object.\n+\t(add_fdes): Handle encoded pointers.\n+\t(init_object): Rename from frame_init.  Update for new struct object.\n+\t(linear_search_fdes): Rename from search_fdes.  Handle encoded\n+\tpointers.\n+\t(binary_search_unencoded_fdes): Broken out from _Unwind_Find_FDE.\n+\t(binary_search_single_encoding_fdes): New.\n+\t(binary_search_mixed_encoding_fdes): New.\n+\t(search_object): New.\n+\t(_Unwind_Find_FDE): Update for new struct object.  Fill in\n+\tthe dwarf_eh_bases.\n+\t* unwind-dw2.c: Include unwind-pe.h.  Constify all pointers\n+\titerating over EH data.\n+\t(_Unwind_FrameState): Remove saw_lsda, addr_encoding.  Add\n+\tfde_encoding, lsda_encoding.\n+\t(read_uleb128, read_sleb128): Remove.\n+\t(read_encoded_pointer): Remove.  All callers use read_encoded_value.\n+\t(extract_cie_info): Set lsda_encoding from 'L' augmentation.\n+\t(uw_frame_state_for): Don't set bases.func.  Handle encoded fde\n+\tpointers.\n+\t* unwind-pe.h: Add \"struct\" to _Unwind_Context references.\n+\n 2001-05-16  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* cppexp.c (lex): Use NODE_NAME and NODE_LEN."}, {"sha": "eff9a77a509f35ab003991c8af2a41e19d096d7a", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 229, "deletions": 66, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -470,6 +470,152 @@ size_of_encoded_value (encoding)\n   abort ();\n }\n \n+/* Yield a name for a given pointer encoding.  */\n+\n+const char *\n+eh_data_format_name (format)\n+     int format;\n+{\n+#if HAVE_DESIGNATED_INITIALIZERS\n+#define S(p, v)\t\t[p] = v,\n+#else\n+#define S(p, v)\t\tcase p: return v;\n+#endif\n+\n+#if HAVE_DESIGNATED_INITIALIZERS\n+  __extension__ static const char * const format_names[256] = {\n+#else\n+  switch (format) {\n+#endif\n+\n+  S(DW_EH_PE_absptr, \"absolute\")\n+  S(DW_EH_PE_omit, \"omit\")\n+\n+  S(DW_EH_PE_uleb128, \"uleb128\")\n+  S(DW_EH_PE_udata2, \"udata2\")\n+  S(DW_EH_PE_udata4, \"udata4\")\n+  S(DW_EH_PE_udata8, \"udata8\")\n+  S(DW_EH_PE_sleb128, \"sleb128\")\n+  S(DW_EH_PE_sdata2, \"sdata2\")\n+  S(DW_EH_PE_sdata4, \"sdata4\")\n+  S(DW_EH_PE_sdata8, \"sdata8\")\n+\n+  S(DW_EH_PE_uleb128 | DW_EH_PE_pcrel, \"pcrel uleb128\")\n+  S(DW_EH_PE_udata2 | DW_EH_PE_pcrel, \"pcrel udata2\")\n+  S(DW_EH_PE_udata4 | DW_EH_PE_pcrel, \"pcrel udata4\")\n+  S(DW_EH_PE_udata8 | DW_EH_PE_pcrel, \"pcrel udata8\")\n+  S(DW_EH_PE_sleb128 | DW_EH_PE_pcrel, \"pcrel sleb128\")\n+  S(DW_EH_PE_sdata2 | DW_EH_PE_pcrel, \"pcrel sdata2\")\n+  S(DW_EH_PE_sdata4 | DW_EH_PE_pcrel, \"pcrel sdata4\")\n+  S(DW_EH_PE_sdata8 | DW_EH_PE_pcrel, \"pcrel sdata8\")\n+\n+  S(DW_EH_PE_uleb128 | DW_EH_PE_textrel, \"textrel uleb128\")\n+  S(DW_EH_PE_udata2 | DW_EH_PE_textrel, \"textrel udata2\")\n+  S(DW_EH_PE_udata4 | DW_EH_PE_textrel, \"textrel udata4\")\n+  S(DW_EH_PE_udata8 | DW_EH_PE_textrel, \"textrel udata8\")\n+  S(DW_EH_PE_sleb128 | DW_EH_PE_textrel, \"textrel sleb128\")\n+  S(DW_EH_PE_sdata2 | DW_EH_PE_textrel, \"textrel sdata2\")\n+  S(DW_EH_PE_sdata4 | DW_EH_PE_textrel, \"textrel sdata4\")\n+  S(DW_EH_PE_sdata8 | DW_EH_PE_textrel, \"textrel sdata8\")\n+\n+  S(DW_EH_PE_uleb128 | DW_EH_PE_datarel, \"datarel uleb128\")\n+  S(DW_EH_PE_udata2 | DW_EH_PE_datarel, \"datarel udata2\")\n+  S(DW_EH_PE_udata4 | DW_EH_PE_datarel, \"datarel udata4\")\n+  S(DW_EH_PE_udata8 | DW_EH_PE_datarel, \"datarel udata8\")\n+  S(DW_EH_PE_sleb128 | DW_EH_PE_datarel, \"datarel sleb128\")\n+  S(DW_EH_PE_sdata2 | DW_EH_PE_datarel, \"datarel sdata2\")\n+  S(DW_EH_PE_sdata4 | DW_EH_PE_datarel, \"datarel sdata4\")\n+  S(DW_EH_PE_sdata8 | DW_EH_PE_datarel, \"datarel sdata8\")\n+\n+  S(DW_EH_PE_uleb128 | DW_EH_PE_funcrel, \"funcrel uleb128\")\n+  S(DW_EH_PE_udata2 | DW_EH_PE_funcrel, \"funcrel udata2\")\n+  S(DW_EH_PE_udata4 | DW_EH_PE_funcrel, \"funcrel udata4\")\n+  S(DW_EH_PE_udata8 | DW_EH_PE_funcrel, \"funcrel udata8\")\n+  S(DW_EH_PE_sleb128 | DW_EH_PE_funcrel, \"funcrel sleb128\")\n+  S(DW_EH_PE_sdata2 | DW_EH_PE_funcrel, \"funcrel sdata2\")\n+  S(DW_EH_PE_sdata4 | DW_EH_PE_funcrel, \"funcrel sdata4\")\n+  S(DW_EH_PE_sdata8 | DW_EH_PE_funcrel, \"funcrel sdata8\")\n+\n+  S(DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_pcrel,\n+    \"indirect pcrel uleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_pcrel,\n+    \"indirect pcrel udata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_pcrel,\n+    \"indirect pcrel udata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_pcrel,\n+    \"indirect pcrel udata8\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_pcrel,\n+    \"indirect pcrel sleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_pcrel,\n+    \"indirect pcrel sdata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_pcrel,\n+    \"indirect pcrel sdata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_pcrel,\n+    \"indirect pcrel sdata8\")\n+\n+  S(DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_textrel,\n+    \"indirect textrel uleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_textrel,\n+    \"indirect textrel udata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_textrel,\n+    \"indirect textrel udata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_textrel,\n+    \"indirect textrel udata8\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_textrel,\n+    \"indirect textrel sleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_textrel,\n+    \"indirect textrel sdata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_textrel,\n+    \"indirect textrel sdata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_textrel,\n+    \"indirect textrel sdata8\")\n+\n+  S(DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_datarel,\n+    \"indirect datarel uleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_datarel,\n+    \"indirect datarel udata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_datarel,\n+    \"indirect datarel udata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_datarel,\n+    \"indirect datarel udata8\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_datarel,\n+    \"indirect datarel sleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_datarel,\n+    \"indirect datarel sdata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_datarel,\n+    \"indirect datarel sdata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_datarel,\n+    \"indirect datarel sdata8\")\n+\n+  S(DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_funcrel,\n+    \"indirect funcrel uleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_funcrel,\n+    \"indirect funcrel udata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_funcrel,\n+    \"indirect funcrel udata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_funcrel,\n+    \"indirect funcrel udata8\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_funcrel,\n+    \"indirect funcrel sleb128\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_funcrel,\n+    \"indirect funcrel sdata2\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_funcrel,\n+    \"indirect funcrel sdata4\")\n+  S(DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_funcrel,\n+    \"indirect funcrel sdata8\")\n+\n+#if HAVE_DESIGNATED_INITIALIZERS\n+  };\n+\n+  if (format < 0 || format > 0xff || format_names[format] == NULL)\n+    abort ();\n+  return format_names[format];\n+#else\n+  }\n+  abort ();\n+#endif\n+}\n+\n /* Output an unsigned LEB128 quantity.  */\n \n void\n@@ -682,6 +828,11 @@ static int dw2_output_indirect_constant_1 PARAMS ((splay_tree_node, void *));\n \n static splay_tree indirect_pool;\n \n+/* Put X, a SYMBOL_REF, in memory.  Return a SYMBOL_REF to the allocated\n+   memory.  Differs from force_const_mem in that a single pool is used for\n+   the entire unit of translation, and the memory is not guaranteed to be\n+   \"near\" the function in any interesting sense.  */\n+\n static rtx\n dw2_force_const_mem (x)\n      rtx x;\n@@ -718,6 +869,9 @@ dw2_force_const_mem (x)\n   return gen_rtx_SYMBOL_REF (Pmode, const_sym);\n }\n \n+/* A helper function for dw2_output_indirect_constants called through\n+   splay_tree_foreach.  Emit one queued constant to memory.  */\n+\n static int\n dw2_output_indirect_constant_1 (node, data)\n      splay_tree_node node;\n@@ -736,6 +890,8 @@ dw2_output_indirect_constant_1 (node, data)\n   return 0;\n }\n \n+/* Emit the constants queued through dw2_force_const_mem.  */\n+\n void\n dw2_output_indirect_constants ()\n {\n@@ -754,97 +910,104 @@ dw2_output_indirect_constants ()\n   splay_tree_foreach (indirect_pool, dw2_output_indirect_constant_1, NULL);\n }\n \n+/* Like dw2_asm_output_addr_rtx, but encode the pointer as directed.  */\n+\n void\n-dw2_asm_output_encoded_addr_rtx (encoding, addr)\n-     int encoding;\n-     rtx addr;\n+dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n+\t\t\t\t\t  rtx addr,\n+\t\t\t\t\t  const char *comment, ...))\n {\n+#ifndef ANSI_PROTOTYPES\n+  int encoding;\n+  rtx addr;\n+  const char *comment;\n+#endif\n+  va_list ap;\n   int size;\n \n-  switch (encoding & 0x07)\n-    {\n-    case DW_EH_PE_absptr:\n-      size = POINTER_SIZE / BITS_PER_UNIT;\n-      break;\n-    case DW_EH_PE_udata2:\n-      size = 2;\n-      break;\n-    case DW_EH_PE_udata4:\n-      size = 4;\n-      break;\n-    case DW_EH_PE_udata8:\n-      size = 8;\n-      break;\n-    default:\n-      abort ();\n-    }\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  encoding = va_arg (ap, int);\n+  addr = va_arg (ap, rtx);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+  size = size_of_encoded_value (encoding);\n \n   /* NULL is _always_ represented as a plain zero.  */\n   if (addr == const0_rtx)\n+    assemble_integer (addr, size, 1);\n+  else\n     {\n-      assemble_integer (addr, size, 1);\n-      return;\n-    }\n-\n- restart:\n-\n-  /* Allow the target first crack at emitting this.  Some of the\n-     special relocations require special directives instead of \n-     just \".4byte\" or whatever.  */\n+    restart:\n+      /* Allow the target first crack at emitting this.  Some of the\n+\t special relocations require special directives instead of \n+\t just \".4byte\" or whatever.  */\n #ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n-  ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(asm_out_file, encoding, size, addr, done);\n+      ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX (asm_out_file, encoding, size,\n+\t\t\t\t\t addr, done);\n #endif\n \n-  /* Indirection is used to get dynamic relocations out of a read-only\n-     section.  */\n-  if (encoding & DW_EH_PE_indirect)\n-    {\n-      /* It is very tempting to use force_const_mem so that we share data\n-\t with the normal constant pool.  However, we've already emitted\n-\t the constant pool for this function.  Moreover, we'd like to share\n-\t these constants across the entire unit of translation, or better,\n-\t across the entire application (or DSO).  */\n-      addr = dw2_force_const_mem (addr);\n-      encoding &= ~DW_EH_PE_indirect;\n-      goto restart;\n-    }\n+      /* Indirection is used to get dynamic relocations out of a\n+\t read-only section.  */\n+      if (encoding & DW_EH_PE_indirect)\n+\t{\n+\t  /* It is very tempting to use force_const_mem so that we share data\n+\t     with the normal constant pool.  However, we've already emitted\n+\t     the constant pool for this function.  Moreover, we'd like to\n+\t     share these constants across the entire unit of translation,\n+\t     or better, across the entire application (or DSO).  */\n+\t  addr = dw2_force_const_mem (addr);\n+\t  encoding &= ~DW_EH_PE_indirect;\n+\t  goto restart;\n+\t}\n \n-  switch (encoding & 0xF0)\n-    {\n-    case DW_EH_PE_absptr:\n+      switch (encoding & 0xF0)\n+\t{\n+\tcase DW_EH_PE_absptr:\n #ifdef UNALIGNED_INT_ASM_OP\n-      fputs (unaligned_integer_asm_op (size), asm_out_file);\n-      output_addr_const (asm_out_file, addr);\n+\t  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+\t  output_addr_const (asm_out_file, addr);\n #else\n-      assemble_integer (addr, size, 1);\n+\t  assemble_integer (addr, size, 1);\n #endif\n-      break;\n+\t  break;\n \n-    case DW_EH_PE_pcrel:\n-      if (GET_CODE (addr) != SYMBOL_REF)\n-\tabort ();\n+\tcase DW_EH_PE_pcrel:\n+\t  if (GET_CODE (addr) != SYMBOL_REF)\n+\t    abort ();\n #ifdef ASM_OUTPUT_DWARF_PCREL\n-      ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, XSTR (addr, 0));\n+\t  ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, XSTR (addr, 0));\n #else\n #ifdef UNALIGNED_INT_ASM_OP\n-      fputs (unaligned_integer_asm_op (size), asm_out_file);\n-      assemble_name (asm_out_file, XSTR (addr, 0));\n-      fputc ('-', asm_out_file);\n-      fputc ('.', asm_out_file);\n+\t  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+\t  assemble_name (asm_out_file, XSTR (addr, 0));\n+\t  fputc ('-', asm_out_file);\n+\t  fputc ('.', asm_out_file);\n #else\n-      abort ();\n+\t  abort ();\n #endif\n #endif\n-      break;\n+\t  break;\n \n-    default:\n-      /* Other encodings should have been handled by \n-\t ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */\n-      abort ();\n-    }\n+\tdefault:\n+\t  /* Other encodings should have been handled by \n+\t     ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */\n+\t  abort ();\n+\t}\n \n #ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n- done:\n+    done:;\n #endif\n+    }\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n   fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n }"}, {"sha": "fb548b2cb8984f7466dbc45dadd15d346b42e5f3", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -48,7 +48,9 @@ extern void dw2_asm_output_addr_rtx\tPARAMS ((int, rtx,\n \t\t\t\t\t\t const char *, ...))\n      /* ATTRIBUTE_PRINTF_3 */;\n \n-extern void dw2_asm_output_encoded_addr_rtx PARAMS ((int, rtx));\n+extern void dw2_asm_output_encoded_addr_rtx PARAMS ((int, rtx,\n+\t\t\t\t\t\t     const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n \n extern void dw2_asm_output_nstring\tPARAMS ((const char *, size_t,\n \t\t\t\t\t\t const char *, ...))\n@@ -73,5 +75,6 @@ extern void dw2_asm_output_delta_sleb128 PARAMS ((const char *, const char *,\n extern int size_of_uleb128\t\tPARAMS ((unsigned HOST_WIDE_INT));\n extern int size_of_sleb128\t\tPARAMS ((HOST_WIDE_INT));\n extern int size_of_encoded_value\tPARAMS ((int));\n+extern const char *eh_data_format_name\tPARAMS ((int));\n \n extern void dw2_output_indirect_constants PARAMS ((void));"}, {"sha": "570c87a9dd9b21564e3477365ad56422a1cee8c4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -1649,8 +1649,14 @@ output_cfi (cfi, fde, for_eh)\n       switch (cfi->dw_cfi_opc)\n \t{\n \tcase DW_CFA_set_loc:\n-\t  dw2_asm_output_addr ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE), \n-\t\t\t       cfi->dw_cfi_oprnd1.dw_cfi_addr, NULL);\n+\t  if (for_eh)\n+\t    dw2_asm_output_encoded_addr_rtx (\n+\t\tASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0),\n+\t\tgen_rtx_SYMBOL_REF (Pmode, cfi->dw_cfi_oprnd1.dw_cfi_addr),\n+\t\tNULL);\n+\t  else\n+\t    dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_addr, NULL);\n \t  break;\n \tcase DW_CFA_advance_loc1:\n \t  dw2_asm_output_delta (1, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n@@ -1717,6 +1723,10 @@ output_call_frame_info (for_eh)\n   char l1[20], l2[20];\n   int any_lsda_needed = 0;\n   char augmentation[6];\n+  int augmentation_size;\n+  int fde_encoding = DW_EH_PE_absptr;\n+  int per_encoding = DW_EH_PE_absptr;\n+  int lsda_encoding = DW_EH_PE_absptr;\n \n   /* If we don't have any functions we'll want to unwind out of, don't\n      emit any EH unwind information.  */\n@@ -1770,20 +1780,46 @@ output_call_frame_info (for_eh)\n   dw2_asm_output_data (1, DW_CIE_VERSION, \"CIE Version\");\n \n   augmentation[0] = 0;\n+  augmentation_size = 0;\n   if (for_eh)\n     {\n+      char *p;\n+\n       /* Augmentation:\n \t z\tIndicates that a uleb128 is present to size the\n \t \taugmentation section.\n-\t R\tIndicates a pointer encoding for CIE and FDE pointers.\n-\t P\tIndicates the presence of a language personality\n-\t \troutine in the CIE augmentation and an LSDA in the\n-\t\tFDE augmentation.  */\n-\n-      /* ??? Handle pointer encodings.  */\n-\n+\t L\tIndicates the encoding (and thus presence) of\n+\t\tan LSDA pointer in the FDE augmentation.\n+\t R\tIndicates a non-default pointer encoding for\n+\t\tFDE code pointers.\n+\t P\tIndicates the presence of an encoding + language\n+\t\tpersonality routine in the CIE augmentation.  */\n+\n+      fde_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0);\n+      per_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1);\n+      lsda_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n+\n+      p = augmentation + 1;\n+      if (eh_personality_libfunc)\n+\t{\n+\t  *p++ = 'P';\n+\t  augmentation_size += 1 + size_of_encoded_value (per_encoding);\n+\t}\n       if (any_lsda_needed)\n-\tstrcpy (augmentation, \"zP\");\n+\t{\n+\t  *p++ = 'L';\n+\t  augmentation_size += 1;\n+\t}\n+      if (fde_encoding != DW_EH_PE_absptr)\n+\t{\n+\t  *p++ = 'R';\n+\t  augmentation_size += 1;\n+\t}\n+      if (p > augmentation + 1)\n+\t{\n+\t  augmentation[0] = 'z';\n+          *p = '\\0';\n+\t}\n     }\n   dw2_asm_output_nstring (augmentation, -1, \"CIE Augmentation\");\n \n@@ -1796,12 +1832,20 @@ output_call_frame_info (for_eh)\n \n   if (augmentation[0])\n     {\n-      dw2_asm_output_data_uleb128 (PTR_SIZE, \"Augmentation size\");\n+      dw2_asm_output_data_uleb128 (augmentation_size, \"Augmentation size\");\n       if (eh_personality_libfunc)\n-\tdw2_asm_output_addr_rtx (PTR_SIZE, eh_personality_libfunc,\n-\t\t\t\t \"Personality\");\n-      else\n-\tdw2_asm_output_data (PTR_SIZE, 0, \"Personality (none)\");\n+\t{\n+\t  dw2_asm_output_data (1, per_encoding, \"Personality (%s)\",\n+\t\t\t       eh_data_format_name (per_encoding));\n+\t  dw2_asm_output_encoded_addr_rtx (per_encoding,\n+\t\t\t\t\t   eh_personality_libfunc, NULL);\n+\t}\n+      if (any_lsda_needed)\n+\tdw2_asm_output_data (1, lsda_encoding, \"LSDA Encoding (%s)\",\n+\t\t\t     eh_data_format_name (lsda_encoding));\n+      if (fde_encoding != DW_EH_PE_absptr)\n+\tdw2_asm_output_data (1, fde_encoding, \"FDE Encoding (%s)\",\n+\t\t\t     eh_data_format_name (fde_encoding));\n     }\n \n   for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n@@ -1843,29 +1887,45 @@ output_call_frame_info (for_eh)\n \t\t\t       stripattributes (FRAME_SECTION),\n \t\t\t       \"FDE CIE offset\");\n \n-      dw2_asm_output_addr ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE),\n-\t\t\t   fde->dw_fde_begin,\n-\t\t\t   \"FDE initial location\");\n-\n-      dw2_asm_output_delta ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE), \n-\t\t\t    fde->dw_fde_end, \n-\t\t\t    fde->dw_fde_begin, \n-\t\t\t    \"FDE address range\");\n+      if (for_eh)\n+\t{\n+\t  dw2_asm_output_encoded_addr_rtx (fde_encoding,\n+\t\t   gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin),\n+\t\t   \"FDE initial location\");\n+\t  dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n+\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin, \n+\t\t\t\t\"FDE address range\");\n+\t}\n+      else\n+\t{\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n+\t\t\t       \"FDE initial location\");\n+\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, \n+\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin, \n+\t\t\t\t\"FDE address range\");\n+\t}\n \n       if (augmentation[0])\n \t{\n-\t  dw2_asm_output_data_uleb128 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE),\n-\t\t\t\t       \"Augmentation size\");\n-\n-\t  if (fde->uses_eh_lsda)\n+\t  if (any_lsda_needed)\n \t    {\n-\t      ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\", fde->funcdef_number);\n-\t      dw2_asm_output_offset ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE), \n-\t\t\t\t     l1, \"Language Specific Data Area\");\n+\t      dw2_asm_output_data_uleb128 (\n+\t\tsize_of_encoded_value (lsda_encoding), \"Augmentation size\");\n+\n+\t      if (fde->uses_eh_lsda)\n+\t        {\n+\t          ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n+\t\t\t\t\t       fde->funcdef_number);\n+\t          dw2_asm_output_encoded_addr_rtx (\n+\t\t\tlsda_encoding, gen_rtx_SYMBOL_REF (Pmode, l1),\n+\t\t \t\"Language Specific Data Area\");\n+\t        }\n+\t      else\n+\t        dw2_asm_output_data (size_of_encoded_value (lsda_encoding),\n+\t\t\t\t     0, \"Language Specific Data Area (none)\");\n \t    }\n \t  else\n-\t    dw2_asm_output_data ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE), \n-\t\t\t\t 0, \"Language Specific Data Area (none)\");\n+\t    dw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n \t}\n \n       /* Loop through the Call Frame Instructions associated with\n@@ -1876,7 +1936,7 @@ output_call_frame_info (for_eh)\n \n       /* Pad the FDE out to an address sized boundary.  */\n       ASM_OUTPUT_ALIGN (asm_out_file, \n-\t\t      floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n+\t\t        floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n       ASM_OUTPUT_LABEL (asm_out_file, l2);\n     }\n "}, {"sha": "b77713671497abcbd4ccab0e7f46e801dd4ff07b", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 129, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -330,7 +330,6 @@ static int add_call_site\t\t\tPARAMS ((rtx, int));\n static void push_uleb128\t\t\tPARAMS ((varray_type *,\n \t\t\t\t\t\t\t unsigned int));\n static void push_sleb128\t\t\tPARAMS ((varray_type *, int));\n-static const char *eh_data_format_name\t\tPARAMS ((int));\n #ifndef HAVE_AS_LEB128\n static int dw2_size_of_call_site_table\t\tPARAMS ((void));\n static int sjlj_size_of_call_site_table\t\tPARAMS ((void));\n@@ -3367,133 +3366,6 @@ push_sleb128 (data_area, value)\n }\n \n \f\n-static const char *\n-eh_data_format_name (format)\n-     int format;\n-{\n-  switch (format)\n-    {\n-    case DW_EH_PE_absptr:\treturn \"absolute\";\n-    case DW_EH_PE_omit:\t\treturn \"omit\";\n-\n-    case DW_EH_PE_uleb128:\treturn \"uleb128\";\n-    case DW_EH_PE_udata2:\treturn \"udata2\";\n-    case DW_EH_PE_udata4:\treturn \"udata4\";\n-    case DW_EH_PE_udata8:\treturn \"udata8\";\n-    case DW_EH_PE_sleb128:\treturn \"sleb128\";\n-    case DW_EH_PE_sdata2:\treturn \"sdata2\";\n-    case DW_EH_PE_sdata4:\treturn \"sdata4\";\n-    case DW_EH_PE_sdata8:\treturn \"sdata8\";\n-\n-    case DW_EH_PE_uleb128 | DW_EH_PE_pcrel:\treturn \"pcrel uleb128\";\n-    case DW_EH_PE_udata2 | DW_EH_PE_pcrel:\treturn \"pcrel udata2\";\n-    case DW_EH_PE_udata4 | DW_EH_PE_pcrel:\treturn \"pcrel udata4\";\n-    case DW_EH_PE_udata8 | DW_EH_PE_pcrel:\treturn \"pcrel udata8\";\n-    case DW_EH_PE_sleb128 | DW_EH_PE_pcrel:\treturn \"pcrel sleb128\";\n-    case DW_EH_PE_sdata2 | DW_EH_PE_pcrel:\treturn \"pcrel sdata2\";\n-    case DW_EH_PE_sdata4 | DW_EH_PE_pcrel:\treturn \"pcrel sdata4\";\n-    case DW_EH_PE_sdata8 | DW_EH_PE_pcrel:\treturn \"pcrel sdata8\";\n-\n-    case DW_EH_PE_uleb128 | DW_EH_PE_textrel:\treturn \"textrel uleb128\";\n-    case DW_EH_PE_udata2 | DW_EH_PE_textrel:\treturn \"textrel udata2\";\n-    case DW_EH_PE_udata4 | DW_EH_PE_textrel:\treturn \"textrel udata4\";\n-    case DW_EH_PE_udata8 | DW_EH_PE_textrel:\treturn \"textrel udata8\";\n-    case DW_EH_PE_sleb128 | DW_EH_PE_textrel:\treturn \"textrel sleb128\";\n-    case DW_EH_PE_sdata2 | DW_EH_PE_textrel:\treturn \"textrel sdata2\";\n-    case DW_EH_PE_sdata4 | DW_EH_PE_textrel:\treturn \"textrel sdata4\";\n-    case DW_EH_PE_sdata8 | DW_EH_PE_textrel:\treturn \"textrel sdata8\";\n-\n-    case DW_EH_PE_uleb128 | DW_EH_PE_datarel:\treturn \"datarel uleb128\";\n-    case DW_EH_PE_udata2 | DW_EH_PE_datarel:\treturn \"datarel udata2\";\n-    case DW_EH_PE_udata4 | DW_EH_PE_datarel:\treturn \"datarel udata4\";\n-    case DW_EH_PE_udata8 | DW_EH_PE_datarel:\treturn \"datarel udata8\";\n-    case DW_EH_PE_sleb128 | DW_EH_PE_datarel:\treturn \"datarel sleb128\";\n-    case DW_EH_PE_sdata2 | DW_EH_PE_datarel:\treturn \"datarel sdata2\";\n-    case DW_EH_PE_sdata4 | DW_EH_PE_datarel:\treturn \"datarel sdata4\";\n-    case DW_EH_PE_sdata8 | DW_EH_PE_datarel:\treturn \"datarel sdata8\";\n-\n-    case DW_EH_PE_uleb128 | DW_EH_PE_funcrel:\treturn \"funcrel uleb128\";\n-    case DW_EH_PE_udata2 | DW_EH_PE_funcrel:\treturn \"funcrel udata2\";\n-    case DW_EH_PE_udata4 | DW_EH_PE_funcrel:\treturn \"funcrel udata4\";\n-    case DW_EH_PE_udata8 | DW_EH_PE_funcrel:\treturn \"funcrel udata8\";\n-    case DW_EH_PE_sleb128 | DW_EH_PE_funcrel:\treturn \"funcrel sleb128\";\n-    case DW_EH_PE_sdata2 | DW_EH_PE_funcrel:\treturn \"funcrel sdata2\";\n-    case DW_EH_PE_sdata4 | DW_EH_PE_funcrel:\treturn \"funcrel sdata4\";\n-    case DW_EH_PE_sdata8 | DW_EH_PE_funcrel:\treturn \"funcrel sdata8\";\n-\n-    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel uleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel udata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel udata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel udata8\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel sleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel sdata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel sdata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_pcrel:\n-      return \"indirect pcrel sdata8\";\n-\n-    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_textrel:\n-      return \"indirect textrel uleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_textrel:\n-      return \"indirect textrel udata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_textrel:\n-      return \"indirect textrel udata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_textrel:\n-      return \"indirect textrel udata8\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_textrel:\n-      return \"indirect textrel sleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_textrel:\n-      return \"indirect textrel sdata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_textrel:\n-      return \"indirect textrel sdata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_textrel:\n-      return \"indirect textrel sdata8\";\n-\n-    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_datarel:\n-      return \"indirect datarel uleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_datarel:\n-      return \"indirect datarel udata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_datarel:\n-      return \"indirect datarel udata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_datarel:\n-      return \"indirect datarel udata8\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_datarel:\n-      return \"indirect datarel sleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_datarel:\n-      return \"indirect datarel sdata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_datarel:\n-      return \"indirect datarel sdata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_datarel:\n-      return \"indirect datarel sdata8\";\n-\n-    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel uleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel udata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel udata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel udata8\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel sleb128\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel sdata2\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel sdata4\";\n-    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_funcrel:\n-      return \"indirect funcrel sdata8\";\n-\n-    default:\n-      abort ();\n-    }\n-}\n-\n #ifndef HAVE_AS_LEB128\n static int\n dw2_size_of_call_site_table ()\n@@ -3767,7 +3639,8 @@ output_function_exception_table ()\n \n       dw2_asm_output_encoded_addr_rtx (tt_format,\n \t\t\t\t       expand_expr (type, NULL_RTX, VOIDmode,\n-\t\t\t\t\t\t    EXPAND_INITIALIZER));\n+\t\t\t\t\t\t    EXPAND_INITIALIZER),\n+\t\t\t\t       NULL);\n     }\n \n #ifdef HAVE_AS_LEB128"}, {"sha": "3a42f29a6ce56592c665d4e8f86de527b6e805c0", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 621, "deletions": 195, "changes": 816, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -30,10 +30,18 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"tconfig.h\"\n #include \"tsystem.h\"\n+#include \"dwarf2.h\"\n+#include \"unwind.h\"\n+#include \"unwind-pe.h\"\n #include \"unwind-dw2-fde.h\"\n #include \"gthr.h\"\n \n-static struct object *objects;\n+/* The unseen_objects list contains objects that have been registered\n+   but not yet categorized in any way.  The seen_objects list has had\n+   it's pc_begin and count fields initialized at minimum, and is sorted\n+   by decreasing value of pc_begin.  */\n+static struct object *unseen_objects;\n+static struct object *seen_objects;\n \n #ifdef __GTHREAD_MUTEX_INIT\n static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n@@ -61,22 +69,31 @@ init_object_mutex_once (void)\n /* Called from crtbegin.o to register the unwind info for an object.  */\n \n void\n-__register_frame_info (void *begin, struct object *ob)\n+__register_frame_info_bases (void *begin, struct object *ob,\n+\t\t\t     void *tbase, void *dbase)\n {\n-  ob->pc_begin = ob->pc_end = 0;\n-  ob->fde_begin = begin;\n-  ob->fde_array = 0;\n-  ob->count = 0;\n+  ob->pc_begin = (void *)-1;\n+  ob->tbase = tbase;\n+  ob->dbase = dbase;\n+  ob->u.single = begin;\n+  ob->s.i = 0;\n+  ob->s.b.encoding = DW_EH_PE_omit;\n \n   init_object_mutex_once ();\n   __gthread_mutex_lock (&object_mutex);\n \n-  ob->next = objects;\n-  objects = ob;\n+  ob->next = unseen_objects;\n+  unseen_objects = ob;\n \n   __gthread_mutex_unlock (&object_mutex);\n }\n \n+void\n+__register_frame_info (void *begin, struct object *ob)\n+{\n+  __register_frame_info_bases (begin, ob, 0, 0);\n+}\n+\n void\n __register_frame (void *begin)\n {\n@@ -89,22 +106,32 @@ __register_frame (void *begin)\n    collect2.  */\n \n void\n-__register_frame_info_table (void *begin, struct object *ob)\n+__register_frame_info_table_bases (void *begin, struct object *ob,\n+\t\t\t\t   void *tbase, void *dbase)\n {\n-  ob->pc_begin = ob->pc_end = 0;\n-  ob->fde_begin = begin;\n-  ob->fde_array = begin;\n-  ob->count = 0;\n+  ob->pc_begin = (void *)-1;\n+  ob->tbase = tbase;\n+  ob->dbase = dbase;\n+  ob->u.array = begin;\n+  ob->s.i = 0;\n+  ob->s.b.from_array = 1;\n+  ob->s.b.encoding = DW_EH_PE_omit;\n \n   init_object_mutex_once ();\n   __gthread_mutex_lock (&object_mutex);\n \n-  ob->next = objects;\n-  objects = ob;\n+  ob->next = unseen_objects;\n+  unseen_objects = ob;\n \n   __gthread_mutex_unlock (&object_mutex);\n }\n \n+void\n+__register_frame_info_table (void *begin, struct object *ob)\n+{\n+  __register_frame_info_table_bases (begin, ob, 0, 0);\n+}\n+\n void\n __register_frame_table (void *begin)\n {\n@@ -118,30 +145,46 @@ void *\n __deregister_frame_info (void *begin)\n {\n   struct object **p;\n+  struct object *ob = 0;\n \n   init_object_mutex_once ();\n   __gthread_mutex_lock (&object_mutex);\n \n-  p = &objects;\n-  while (*p)\n-    {\n-      if ((*p)->fde_begin == begin)\n-\t{\n-\t  struct object *ob = *p;\n-\t  *p = (*p)->next;\n-\n-\t  /* If we've run init_frame for this object, free the FDE array.  */\n-\t  if (ob->fde_array && ob->fde_array != begin)\n-\t    free (ob->fde_array);\n-\n-\t  __gthread_mutex_unlock (&object_mutex);\n-\t  return (void *) ob;\n-\t}\n-      p = &((*p)->next);\n-    }\n+  for (p = &unseen_objects; *p ; p = &(*p)->next)\n+    if ((*p)->u.single == begin)\n+      {\n+\tob = *p;\n+\t*p = ob->next;\n+\tgoto out;\n+      }\n+\n+  for (p = &seen_objects; *p ; p = &(*p)->next)\n+    if ((*p)->s.b.sorted)\n+      {\n+\tif ((*p)->u.sort->orig_data == begin)\n+\t  {\n+\t    ob = *p;\n+\t    *p = ob->next;\n+\t    free (ob->u.sort);\n+\t    goto out;\n+\t  }\n+      }\n+    else\n+      {\n+\tif ((*p)->u.single == begin)\n+\t  {\n+\t    ob = *p;\n+\t    *p = ob->next;\n+\t    goto out;\n+\t  }\n+      }\n \n   __gthread_mutex_unlock (&object_mutex);\n   abort ();\n+\n+ out:\n+  __gthread_mutex_unlock (&object_mutex);\n+  return (void *) ob;\n }\n \n void\n@@ -150,11 +193,120 @@ __deregister_frame (void *begin)\n   free (__deregister_frame_info (begin));\n }\n \n+\f\n+/* Like base_of_encoded_value, but take the base from a struct object\n+   instead of an _Unwind_Context.  */\n+\n+static _Unwind_Ptr\n+base_from_object (unsigned char encoding, struct object *ob)\n+{\n+  if (encoding == DW_EH_PE_omit)\n+    return 0;\n+\n+  switch (encoding & 0x70)\n+    {\n+    case DW_EH_PE_absptr:\n+    case DW_EH_PE_pcrel:\n+      return 0;\n+\n+    case DW_EH_PE_textrel:\n+      return (_Unwind_Ptr) ob->tbase;\n+    case DW_EH_PE_datarel:\n+      return (_Unwind_Ptr) ob->dbase;\n+    }\n+  abort ();\n+}\n+\n+/* Return the FDE pointer encoding from the CIE.  */\n+/* ??? This is a subset of extract_cie_info from unwind-dw2.c.  */\n+\n+static int\n+get_cie_encoding (struct dwarf_cie *cie)\n+{\n+  const unsigned char *aug, *p;\n+  _Unwind_Ptr dummy;\n+\n+  aug = cie->augmentation;\n+  if (aug[0] != 'z')\n+    return DW_EH_PE_absptr;\n+\n+  p = aug + strlen (aug) + 1;\t\t/* Skip the augmentation string.  */\n+  p = read_uleb128 (p, &dummy);\t\t/* Skip code alignment.  */\n+  p = read_sleb128 (p, &dummy);\t\t/* Skip data alignment.  */\n+  p++;\t\t\t\t\t/* Skip return address column.  */\n+\n+  aug++;\t\t\t\t/* Skip 'z' */\n+  p = read_uleb128 (p, &dummy);\t\t/* Skip augmentation length.  */\n+  while (1)\n+    {\n+      /* This is what we're looking for.  */\n+      if (*aug == 'R')\n+\treturn *p;\n+      /* Personality encoding and pointer.  */\n+      else if (*aug == 'P')\n+\tp = read_encoded_value_with_base (*p & 0xF, 0, p + 1, &dummy);\n+      /* LSDA encoding.  */\n+      else if (*aug == 'L')\n+\tp++;\n+      /* Otherwise end of string, or unknown augmentation.  */\n+      else\n+\treturn DW_EH_PE_absptr;\n+      aug++;\n+    }\n+}\n+\n+static inline int\n+get_fde_encoding (struct dwarf_fde *f)\n+{\n+  return get_cie_encoding (get_cie (f));\n+}\n+\n \f\n /* Sorting an array of FDEs by address.\n    (Ideally we would have the linker sort the FDEs so we don't have to do\n    it at run time. But the linkers are not yet prepared for this.)  */\n \n+/* Comparison routines.  Three variants of increasing complexity.  */\n+\n+static saddr\n+fde_unencoded_compare (struct object *ob __attribute__((unused)),\n+\t\t       fde *x, fde *y)\n+{\n+  return *(saddr *)x->pc_begin - *(saddr *)y->pc_begin;\n+}\n+\n+static saddr\n+fde_single_encoding_compare (struct object *ob, fde *x, fde *y)\n+{\n+  _Unwind_Ptr base, x_ptr, y_ptr;\n+\n+  base = base_from_object (ob->s.b.encoding, ob);\n+  read_encoded_value_with_base (ob->s.b.encoding, base, x->pc_begin, &x_ptr);\n+  read_encoded_value_with_base (ob->s.b.encoding, base, y->pc_begin, &y_ptr);\n+\n+  return x_ptr - y_ptr;\n+}\n+\n+static saddr\n+fde_mixed_encoding_compare (struct object *ob, fde *x, fde *y)\n+{\n+  int x_encoding, y_encoding;\n+  _Unwind_Ptr x_ptr, y_ptr;\n+\n+  x_encoding = get_fde_encoding (x);\n+  read_encoded_value_with_base (x_encoding, base_from_object (x_encoding, ob),\n+\t\t\t\tx->pc_begin, &x_ptr);\n+\n+  y_encoding = get_fde_encoding (y);\n+  read_encoded_value_with_base (y_encoding, base_from_object (y_encoding, ob),\n+\t\t\t\ty->pc_begin, &y_ptr);\n+\n+  return x_ptr - y_ptr;\n+}\n+\n+typedef saddr (*fde_compare_t) (struct object *, fde *, fde *);\n+\n+\n /* This is a special mix of insertion sort and heap sort, optimized for\n    the data sets that actually occur. They look like\n    101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.\n@@ -166,41 +318,36 @@ __deregister_frame (void *begin)\n    The worst-case total run time is O(N) + O(n log (n)), where N is the\n    total number of FDEs and n is the number of erratic ones.  */\n \n-typedef struct fde_vector\n-{\n-  fde **array;\n-  size_t count;\n-} fde_vector;\n-\n-typedef struct fde_accumulator\n+struct fde_accumulator\n {\n-  fde_vector linear;\n-  fde_vector erratic;\n-} fde_accumulator;\n-\n-static inline saddr\n-fde_compare (fde *x, fde *y)\n-{\n-  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n-}\n+  struct fde_vector *linear;\n+  struct fde_vector *erratic;\n+};\n \n static inline int\n-start_fde_sort (fde_accumulator *accu, size_t count)\n+start_fde_sort (struct fde_accumulator *accu, size_t count)\n {\n-  accu->linear.array = count ? (fde **) malloc (sizeof (fde *) * count) : NULL;\n-  accu->erratic.array = accu->linear.array ?\n-      (fde **) malloc (sizeof (fde *) * count) : NULL;\n-  accu->linear.count = 0;\n-  accu->erratic.count = 0;\n-  \n-  return accu->linear.array != NULL;\n+  size_t size;\n+  if (! count)\n+    return 0;\n+\n+  size = sizeof (struct fde_vector) + sizeof (fde *) * count;\n+  if ((accu->linear = (struct fde_vector *) malloc (size)))\n+    {\n+      accu->linear->count = 0;\n+      if ((accu->erratic = (struct fde_vector *) malloc (size)))\n+\taccu->erratic->count = 0;\n+      return 1;\n+    }\n+  else\n+    return 0;  \n }\n \n static inline void\n-fde_insert (fde_accumulator *accu, fde *this_fde)\n+fde_insert (struct fde_accumulator *accu, fde *this_fde)\n {\n-  if (accu->linear.array)\n-    accu->linear.array[accu->linear.count++] = this_fde;\n+  if (accu->linear)\n+    accu->linear->array[accu->linear->count++] = this_fde;\n }\n \n /* Split LINEAR into a linear sequence with low values and an erratic\n@@ -214,8 +361,10 @@ fde_insert (fde_accumulator *accu, fde *this_fde)\n    the ERRATIC array during construction.  A final pass iterates over the\n    chain to determine what should be placed in the ERRATIC array, and\n    what is the linear sequence.  This overlay is safe from aliasing.  */\n+\n static inline void\n-fde_split (fde_vector *linear, fde_vector *erratic)\n+fde_split (struct object *ob, fde_compare_t fde_compare,\n+\t   struct fde_vector *linear, struct fde_vector *erratic)\n {\n   static fde *marker;\n   size_t count = linear->count;\n@@ -233,7 +382,7 @@ fde_split (fde_vector *linear, fde_vector *erratic)\n       fde **probe;\n       \n       for (probe = chain_end;\n-           probe != &marker && fde_compare (linear->array[i], *probe) < 0;\n+           probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n            probe = chain_end)\n         {\n           chain_end = (fde **)erratic->array[probe - linear->array];\n@@ -257,8 +406,10 @@ fde_split (fde_vector *linear, fde_vector *erratic)\n \n /* This is O(n log(n)).  BSD/OS defines heapsort in stdlib.h, so we must\n    use a name that does not conflict.  */\n-static inline void\n-frame_heapsort (fde_vector *erratic)\n+\n+static void\n+frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n+\t\tstruct fde_vector *erratic)\n {\n   /* For a description of this algorithm, see:\n      Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,\n@@ -279,13 +430,13 @@ frame_heapsort (fde_vector *erratic)\n       for (i = m; 2*i+1 < n; )\n         {\n           if (2*i+2 < n\n-              && fde_compare (a[2*i+2], a[2*i+1]) > 0\n-              && fde_compare (a[2*i+2], a[i]) > 0)\n+              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n+              && fde_compare (ob, a[2*i+2], a[i]) > 0)\n             {\n               SWAP (a[i], a[2*i+2]);\n               i = 2*i+2;\n             }\n-          else if (fde_compare (a[2*i+1], a[i]) > 0)\n+          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n             {\n               SWAP (a[i], a[2*i+1]);\n               i = 2*i+1;\n@@ -302,13 +453,13 @@ frame_heapsort (fde_vector *erratic)\n       for (i = 0; 2*i+1 < n; )\n         {\n           if (2*i+2 < n\n-              && fde_compare (a[2*i+2], a[2*i+1]) > 0\n-              && fde_compare (a[2*i+2], a[i]) > 0)\n+              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n+              && fde_compare (ob, a[2*i+2], a[i]) > 0)\n             {\n               SWAP (a[i], a[2*i+2]);\n               i = 2*i+2;\n             }\n-          else if (fde_compare (a[2*i+1], a[i]) > 0)\n+          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n             {\n               SWAP (a[i], a[2*i+1]);\n               i = 2*i+1;\n@@ -321,8 +472,9 @@ frame_heapsort (fde_vector *erratic)\n }\n \n /* Merge V1 and V2, both sorted, and put the result into V1. */\n-static void\n-fde_merge (fde_vector *v1, const fde_vector *v2)\n+static inline void\n+fde_merge (struct object *ob, fde_compare_t fde_compare,\n+\t   struct fde_vector *v1, struct fde_vector *v2)\n {\n   size_t i1, i2;\n   fde * fde2;\n@@ -334,7 +486,7 @@ fde_merge (fde_vector *v1, const fde_vector *v2)\n       do {\n         i2--;\n         fde2 = v2->array[i2];\n-        while (i1 > 0 && fde_compare (v1->array[i1-1], fde2) > 0)\n+        while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)\n           {\n             v1->array[i1+i2] = v1->array[i1-1];\n             i1--;\n@@ -345,198 +497,472 @@ fde_merge (fde_vector *v1, const fde_vector *v2)\n     }\n }\n \n-static fde **\n-end_fde_sort (fde_accumulator *accu, size_t count)\n+static inline void\n+end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n {\n-  if (accu->linear.array && accu->linear.count != count)\n+  fde_compare_t fde_compare;\n+\n+  if (accu->linear && accu->linear->count != count)\n     abort ();\n-  \n-  if (accu->erratic.array)\n+\n+  if (ob->s.b.mixed_encoding)\n+    fde_compare = fde_mixed_encoding_compare;\n+  else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+    fde_compare = fde_unencoded_compare;\n+  else\n+    fde_compare = fde_single_encoding_compare;\n+\n+  if (accu->erratic)\n     {\n-      fde_split (&accu->linear, &accu->erratic);\n-      if (accu->linear.count + accu->erratic.count != count)\n+      fde_split (ob, fde_compare, accu->linear, accu->erratic);\n+      if (accu->linear->count + accu->erratic->count != count)\n \tabort ();\n-      frame_heapsort (&accu->erratic);\n-      fde_merge (&accu->linear, &accu->erratic);\n-      free (accu->erratic.array);\n+      frame_heapsort (ob, fde_compare, accu->erratic);\n+      fde_merge (ob, fde_compare, accu->linear, accu->erratic);\n+      free (accu->erratic);\n     }\n   else\n     {\n-      /* We've not managed to malloc an erratic array, so heap sort in the\n-         linear one.  */\n-      frame_heapsort (&accu->linear);\n+      /* We've not managed to malloc an erratic array,\n+\t so heap sort in the linear one.  */\n+      frame_heapsort (ob, fde_compare, accu->linear);\n     }\n-  return accu->linear.array;\n }\n \n \f\n+/* Update encoding, mixed_encoding, and pc_begin for OB for the \n+   fde array beginning at THIS_FDE.  Return the number of fdes\n+   encountered along the way.  */\n+\n static size_t\n-count_fdes (fde *this_fde)\n+classify_object_over_fdes (struct object *ob, fde *this_fde)\n {\n-  size_t count;\n+  struct dwarf_cie *last_cie = 0;\n+  size_t count = 0;\n+  int encoding = DW_EH_PE_absptr;\n+  _Unwind_Ptr base = 0;\n \n-  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    /* Skip CIEs and omitted link-once FDE entries.  */\n-    if (this_fde->CIE_delta != 0 && this_fde->pc_begin != 0)\n-      ++count;\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      struct dwarf_cie *this_cie;\n+      _Unwind_Ptr mask, pc_begin;\n \n-  return count;\n-}\n+      /* Skip CIEs.  */\n+      if (this_fde->CIE_delta == 0)\n+\tcontinue;\n \n-static void\n-add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n-{\n-  void *pc_begin = *beg_ptr;\n-  void *pc_end = *end_ptr;\n+      /* Determine the encoding for this FDE.  Note mixed encoded\n+\t objects for later.  */\n+      this_cie = get_cie (this_fde);\n+      if (this_cie != last_cie)\n+\t{\n+\t  last_cie = this_cie;\n+\t  encoding = get_cie_encoding (this_cie);\n+\t  base = base_from_object (encoding, ob);\n+\t  if (ob->s.b.encoding == DW_EH_PE_omit)\n+\t    ob->s.b.encoding = encoding;\n+\t  else if (ob->s.b.encoding != encoding)\n+\t    ob->s.b.mixed_encoding = 1;\n+\t}\n \n-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-        continue;\n+      read_encoded_value_with_base (encoding, base, this_fde->pc_begin,\n+\t\t\t\t    &pc_begin);\n \n-      fde_insert (accu, this_fde);\n+      /* Take care to ignore link-once functions that were removed.\n+\t In these cases, the function address will be NULL, but if\n+\t the encoding is smaller than a pointer a true NULL may not\n+\t be representable.  Assume 0 in the representable bits is NULL.  */\n+      mask = size_of_encoded_value (encoding);\n+      if (mask < sizeof (void *))\n+\tmask = (1L << (mask << 3)) - 1;\n+      else\n+\tmask = -1;\n+\n+      if ((pc_begin & mask) == 0)\n+\tcontinue;\n \n-      if (this_fde->pc_begin < pc_begin)\n-        pc_begin = this_fde->pc_begin;\n-      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n-        pc_end = this_fde->pc_begin + this_fde->pc_range;\n+      count += 1;\n+      if ((void *)pc_begin < ob->pc_begin)\n+\tob->pc_begin = (void *)pc_begin;\n     }\n \n-  *beg_ptr = pc_begin;\n-  *end_ptr = pc_end;\n+  return count;\n }\n \n-static fde *\n-search_fdes (fde *this_fde, void *pc)\n+static void\n+add_fdes (struct object *ob, struct fde_accumulator *accu, fde *this_fde)\n {\n+  struct dwarf_cie *last_cie = 0;\n+  int encoding = ob->s.b.encoding;\n+  _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);\n+\n   for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n     {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-        continue;\n+      struct dwarf_cie *this_cie;\n \n-      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n-        return this_fde;\n+      /* Skip CIEs.  */\n+      if (this_fde->CIE_delta == 0)\n+\tcontinue;\n+\n+      if (ob->s.b.mixed_encoding)\n+\t{\n+\t  /* Determine the encoding for this FDE.  Note mixed encoded\n+\t     objects for later.  */\n+\t  this_cie = get_cie (this_fde);\n+\t  if (this_cie != last_cie)\n+\t    {\n+\t      last_cie = this_cie;\n+\t      encoding = get_cie_encoding (this_cie);\n+\t      base = base_from_object (encoding, ob);\n+\t    }\n+\t}\n+\n+      if (encoding == DW_EH_PE_absptr)\n+\t{\n+\t  if (*(_Unwind_Ptr *)this_fde->pc_begin == 0)\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  _Unwind_Ptr pc_begin, mask;\n+\n+\t  read_encoded_value_with_base (encoding, base, this_fde->pc_begin,\n+\t\t\t\t\t&pc_begin);\n+\n+\t  /* Take care to ignore link-once functions that were removed.\n+\t     In these cases, the function address will be NULL, but if\n+\t     the encoding is smaller than a pointer a true NULL may not\n+\t     be representable.  Assume 0 in the representable bits is NULL.  */\n+\t  mask = size_of_encoded_value (encoding);\n+\t  if (mask < sizeof (void *))\n+\t    mask = (1L << (mask << 3)) - 1;\n+\t  else\n+\t    mask = -1;\n+\n+\t  if ((pc_begin & mask) == 0)\n+\t    continue;\n+\t}\n+\n+      fde_insert (accu, this_fde);\n     }\n-  return NULL;\n }\n \n /* Set up a sorted array of pointers to FDEs for a loaded object.  We\n    count up the entries before allocating the array because it's likely to\n    be faster.  We can be called multiple times, should we have failed to\n    allocate a sorted fde array on a previous occasion.  */\n \n-static void\n-frame_init (struct object* ob)\n+static inline void\n+init_object (struct object* ob)\n {\n+  struct fde_accumulator accu;\n   size_t count;\n-  fde_accumulator accu;\n-  void *pc_begin, *pc_end;\n-  fde **array;\n \n-  if (ob->pc_begin)\n-    count = ob->count;\n-  else if (ob->fde_array)\n+  count = ob->s.b.count;\n+  if (count == 0)\n     {\n-      fde **p = ob->fde_array;\n-      for (count = 0; *p; ++p)\n-        count += count_fdes (*p);\n+      if (ob->s.b.from_array)\n+\t{\n+\t  fde **p = ob->u.array;\n+\t  for (count = 0; *p; ++p)\n+\t    count += classify_object_over_fdes (ob, *p);\n+\t}\n+      else\n+\tcount = classify_object_over_fdes (ob, ob->u.single);\n+\n+      /* The count field we have in the main struct object is somewhat\n+\t limited, but should suffice for virtually all cases.  If the\n+\t counted value doesn't fit, re-write a zero.  The worst that\n+\t happens is that we re-count next time -- admittedly non-trivial\n+\t in that this implies some 2M fdes, but at least we function.  */\n+      ob->s.b.count = count;\n+      if (ob->s.b.count != count)\n+\tob->s.b.count = 0;\n     }\n-  else\n-    count = count_fdes (ob->fde_begin);\n-  ob->count = count;\n \n-  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n+  if (!start_fde_sort (&accu, count))\n     return;\n \n-  pc_begin = (void*)(uaddr)-1;\n-  pc_end = 0;\n-\n-  if (ob->fde_array)\n+  if (ob->s.b.from_array)\n     {\n-      fde **p = ob->fde_array;\n-      for (; *p; ++p)\n-        add_fdes (*p, &accu, &pc_begin, &pc_end);\n+      fde **p;\n+      for (p = ob->u.array; *p; ++p)\n+        add_fdes (ob, &accu, *p);\n     }\n   else\n-    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n-  array = end_fde_sort (&accu, count);\n-  if (array)\n-    ob->fde_array = array;\n-  ob->pc_begin = pc_begin;\n-  ob->pc_end = pc_end;\n+    add_fdes (ob, &accu, ob->u.single);\n+\n+  end_fde_sort (ob, &accu, count);\n+\n+  /* Save the original fde pointer, since this is the key by which the\n+     DSO will deregister the object.  */\n+  accu.linear->orig_data = ob->u.single;\n+  ob->u.sort = accu.linear;\n+\n+  ob->s.b.sorted = 1;\n }\n \n-fde *\n-_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases ATTRIBUTE_UNUSED)\n+/* A linear search through a set of FDEs for the given PC.  This is\n+   used when there was insufficient memory to allocate and sort an\n+   array.  */\n+\n+static fde *\n+linear_search_fdes (struct object *ob, fde *this_fde, void *pc)\n {\n-  struct object *ob;\n+  struct dwarf_cie *last_cie = 0;\n+  int encoding = ob->s.b.encoding;\n+  _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);\n+\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      struct dwarf_cie *this_cie;\n+      _Unwind_Ptr pc_begin, pc_range;\n+\n+      /* Skip CIEs.  */\n+      if (this_fde->CIE_delta == 0)\n+\tcontinue;\n+\n+      if (ob->s.b.mixed_encoding)\n+\t{\n+\t  /* Determine the encoding for this FDE.  Note mixed encoded\n+\t     objects for later.  */\n+\t  this_cie = get_cie (this_fde);\n+\t  if (this_cie != last_cie)\n+\t    {\n+\t      last_cie = this_cie;\n+\t      encoding = get_cie_encoding (this_cie);\n+\t      base = base_from_object (encoding, ob);\n+\t    }\n+\t}\n+\n+      if (encoding == DW_EH_PE_absptr)\n+\t{\n+\t  pc_begin = ((_Unwind_Ptr *)this_fde->pc_begin)[0];\n+\t  pc_range = ((_Unwind_Ptr *)this_fde->pc_begin)[1];\n+\t  if (pc_begin == 0)\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  _Unwind_Ptr mask;\n+\t  const char *p;\n+\n+\t  p = read_encoded_value_with_base (encoding, base,\n+\t\t\t\t\t    this_fde->pc_begin, &pc_begin);\n+\t  read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);\n+\n+\t  /* Take care to ignore link-once functions that were removed.\n+\t     In these cases, the function address will be NULL, but if\n+\t     the encoding is smaller than a pointer a true NULL may not\n+\t     be representable.  Assume 0 in the representable bits is NULL.  */\n+\t  mask = size_of_encoded_value (encoding);\n+\t  if (mask < sizeof (void *))\n+\t    mask = (1L << (mask << 3)) - 1;\n+\t  else\n+\t    mask = -1;\n+\n+\t  if ((pc_begin & mask) == 0)\n+\t    continue;\n+\t}\n+\n+      if ((_Unwind_Ptr)pc - pc_begin < pc_range)\n+        return this_fde;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Binary search for an FDE containing the given PC.  Here are three\n+   implementations of increasing complexity.  */\n+\n+static inline fde *\n+binary_search_unencoded_fdes (struct object *ob, void *pc)\n+{\n+  struct fde_vector *vec = ob->u.sort;\n   size_t lo, hi;\n+      \n+  for (lo = 0, hi = vec->count; lo < hi; )\n+    {\n+      size_t i = (lo + hi) / 2;\n+      fde *f = vec->array[i];\n+      void *pc_begin;\n+      uaddr pc_range;\n+\n+      pc_begin = ((void **)f->pc_begin)[0];\n+      pc_range = ((uaddr *)f->pc_begin)[1];\n+\n+      if (pc < pc_begin)\n+\thi = i;\n+      else if (pc >= pc_begin + pc_range)\n+\tlo = i + 1;\n+      else\n+\treturn f;\n+    }\n \n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n+  return NULL;\n+}\n \n-  /* Linear search through the objects, to find the one containing the pc. */\n-  for (ob = objects; ob; ob = ob->next)\n+static inline fde *\n+binary_search_single_encoding_fdes (struct object *ob, void *pc)\n+{\n+  struct fde_vector *vec = ob->u.sort;\n+  int encoding = ob->s.b.encoding;\n+  _Unwind_Ptr base = base_from_object (encoding, ob);\n+  size_t lo, hi;\n+      \n+  for (lo = 0, hi = vec->count; lo < hi; )\n     {\n-      if (ob->pc_begin == 0)\n-        frame_init (ob);\n-      if (pc >= ob->pc_begin && pc < ob->pc_end)\n-        break;\n+      size_t i = (lo + hi) / 2;\n+      fde *f = vec->array[i];\n+      _Unwind_Ptr pc_begin, pc_range;\n+      const char *p;\n+\n+      p = read_encoded_value_with_base (encoding, base, f->pc_begin,\n+\t\t\t\t\t&pc_begin);\n+      read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);\n+\n+      if ((_Unwind_Ptr)pc < pc_begin)\n+\thi = i;\n+      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)\n+\tlo = i + 1;\n+      else\n+\treturn f;\n     }\n \n-  if (ob == 0)\n+  return NULL;\n+}\n+\n+static inline fde *\n+binary_search_mixed_encoding_fdes (struct object *ob, void *pc)\n+{\n+  struct fde_vector *vec = ob->u.sort;\n+  size_t lo, hi;\n+      \n+  for (lo = 0, hi = vec->count; lo < hi; )\n     {\n-      __gthread_mutex_unlock (&object_mutex);\n-      return 0;\n+      size_t i = (lo + hi) / 2;\n+      fde *f = vec->array[i];\n+      _Unwind_Ptr pc_begin, pc_range;\n+      const char *p;\n+      int encoding;\n+\n+      encoding = get_fde_encoding (f);\n+      p = read_encoded_value_with_base (encoding,\n+\t\t\t\t\tbase_from_object (encoding, ob),\n+\t\t\t\t\tf->pc_begin, &pc_begin);\n+      read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);\n+\n+      if ((_Unwind_Ptr)pc < pc_begin)\n+\thi = i;\n+      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)\n+\tlo = i + 1;\n+      else\n+\treturn f;\n     }\n \n-  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n-    frame_init (ob);\n+  return NULL;\n+}\n \n-  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n+static fde *\n+search_object (struct object* ob, void *pc)\n+{\n+  /* If the data hasn't been sorted, try to do this now.  We may have\n+     more memory available than last time we tried.  */\n+  if (! ob->s.b.sorted)\n     {\n-      __gthread_mutex_unlock (&object_mutex);\n-      \n-      /* Standard binary search algorithm.  */\n-      for (lo = 0, hi = ob->count; lo < hi; )\n-        {\n-          size_t i = (lo + hi) / 2;\n-          fde *f = ob->fde_array[i];\n+      init_object (ob);\n \n-          if (pc < f->pc_begin)\n-            hi = i;\n-          else if (pc >= f->pc_begin + f->pc_range)\n-            lo = i + 1;\n-          else\n-            return f;\n-        }\n+      /* Despite the above comment, the normal reason to get here is\n+\t that we've not processed this object before.  A quick range\n+\t check is in order.  */\n+      if (pc < ob->pc_begin)\n+\treturn NULL;\n+    }\n+\n+  if (ob->s.b.sorted)\n+    {\n+      if (ob->s.b.mixed_encoding)\n+\treturn binary_search_mixed_encoding_fdes (ob, pc);\n+      else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+\treturn binary_search_unencoded_fdes (ob, pc);\n+      else\n+\treturn binary_search_single_encoding_fdes (ob, pc);\n     }\n   else\n     {\n-      /* Long slow labourious linear search, cos we've no memory. */\n-      fde *f;\n-      \n-      if (ob->fde_array)\n+      /* Long slow labourious linear search, cos we've no memory.  */\n+      if (ob->s.b.from_array)\n         {\n-          fde **p = ob->fde_array;\n-          \n-          do\n-            {\n-              f = search_fdes (*p, pc);\n+          fde **p;\n+\t  for (p = ob->u.array; *p ; p++)\n+\t    {\n+\t      fde *f = linear_search_fdes (ob, *p, pc);\n               if (f)\n-                break;\n-              p++;\n+\t\treturn f;\n             }\n-          while (*p);\n-        }\n+\t  return NULL;\n+\t}\n       else\n-        f = search_fdes (ob->fde_begin, pc);\n+\treturn linear_search_fdes (ob, ob->u.single, pc);\n+    }\n+}\n+\n+fde *\n+_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n+{\n+  struct object *ob;\n+  fde *f = NULL;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  /* Linear search through the classified objects, to find the one\n+     containing the pc.  Note that pc_begin is sorted decending, and\n+     we expect objects to be non-overlapping.  */\n+  for (ob = seen_objects; ob; ob = ob->next)\n+    if (pc >= ob->pc_begin)\n+      {\n+\tf = search_object (ob, pc);\n+\tif (f)\n+\t  goto fini;\n+\tbreak;\n+      }\n+\n+  /* Classify and search the objects we've not yet processed.  */\n+  while ((ob = unseen_objects))\n+    {\n+      struct object **p;\n+\n+      unseen_objects = ob->next;\n+      f = search_object (ob, pc);\n+\n+      /* Insert the object into the classified list.  */\n+      for (p = &seen_objects; *p ; p = &(*p)->next)\n+\tif ((*p)->pc_begin < ob->pc_begin)\n+\t  break;\n+      ob->next = *p;\n+      *p = ob;\n+\n+      if (f)\n+\tgoto fini;\n+    }\n+\n+ fini:\n+  __gthread_mutex_unlock (&object_mutex);\n+\n+  if (f)\n+    {\n+      int encoding;\n+\n+      bases->tbase = ob->tbase;\n+      bases->dbase = ob->dbase;\n \n-      __gthread_mutex_unlock (&object_mutex);\n-      return f;\n+      encoding = ob->s.b.encoding;\n+      if (ob->s.b.mixed_encoding)\n+\tencoding = get_fde_encoding (f);\n+      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),\n+\t\t\t\t    f->pc_begin, (_Unwind_Ptr *)&bases->func);\n     }\n \n-  return 0;\n+  return f;\n }"}, {"sha": "efbded0fa99fd73426a4310cf5ac687083827f7e", "filename": "gcc/unwind-dw2-fde.h", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2-fde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2-fde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.h?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -29,15 +29,52 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* Describes data used to hold onto one shared object or object file.  */\n+struct fde_vector\n+{\n+  void *orig_data;\n+  size_t count;\n+  struct dwarf_fde *array[];\n+};\n+\n struct object\n+{\n+  void *pc_begin;\n+  void *tbase;\n+  void *dbase;\n+  union {\n+    struct dwarf_fde *single;\n+    struct dwarf_fde **array;\n+    struct fde_vector *sort;\n+  } u;\n+\n+  union {\n+    struct {\n+      unsigned long sorted : 1;\n+      unsigned long from_array : 1;\n+      unsigned long mixed_encoding : 1;\n+      unsigned long encoding : 8;\n+      /* ??? Wish there was an easy way to detect a 64-bit host here;\n+\t we've got 32 bits left to play with... */\n+      unsigned long count : 21;\n+    } b;\n+    size_t i;\n+  } s;\n+\n+  struct object *next;\n+};\n+\n+/* This is the original definition of struct object.  While the struct\n+   itself was opaque to users, they did know how large it was, and\n+   allocate one statically in crtbegin for each DSO.  Keep this around\n+   so that we're aware of the static size limitations for the new struct.  */\n+struct old_object\n {\n   void *pc_begin;\n   void *pc_end;\n   struct dwarf_fde *fde_begin;\n   struct dwarf_fde **fde_array;\n   size_t count;\n-  struct object *next;\n+  struct old_object *next;\n };\n \n struct dwarf_eh_bases\n@@ -48,8 +85,12 @@ struct dwarf_eh_bases\n };\n \n \n+extern void __register_frame_info_bases (void *, struct object *,\n+\t\t\t\t\t void *, void *);\n extern void __register_frame_info (void *, struct object *);\n extern void __register_frame (void *);\n+extern void __register_frame_info_table_bases (void *, struct object *,\n+\t\t\t\t\t       void *, void *);\n extern void __register_frame_info_table (void *, struct object *);\n extern void __register_frame_table (void *);\n extern void *__deregister_frame_info (void *);\n@@ -97,8 +138,7 @@ struct dwarf_fde\n {\n   uword length;\n   sword CIE_delta;\n-  void * pc_begin;\n-  uaddr pc_range;\n+  unsigned char pc_begin[];\n } __attribute__ ((packed, aligned (__alignof__ (void *))));\n \n typedef struct dwarf_fde fde;"}, {"sha": "20deb5721f9a15638f8f3042a9faa324526fcbf7", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 46, "deletions": 159, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -22,6 +22,7 @@\n #include \"tsystem.h\"\n #include \"dwarf2.h\"\n #include \"unwind.h\"\n+#include \"unwind-pe.h\"\n #include \"unwind-dw2-fde.h\"\n #include \"gthr.h\"\n \n@@ -69,7 +70,7 @@ typedef struct\n       union {\n \tunsigned int reg;\n \t_Unwind_Sword offset;\n-\tunsigned char *exp;\n+\tconst unsigned char *exp;\n       } loc;\n       enum {\n \tREG_UNSAVED,\n@@ -87,7 +88,7 @@ typedef struct\n      location expression.  */\n   _Unwind_Sword cfa_offset;\n   _Unwind_Word cfa_reg;\n-  unsigned char *cfa_exp;\n+  const unsigned char *cfa_exp;\n   enum {\n     CFA_UNSET,\n     CFA_REG_OFFSET,\n@@ -102,57 +103,11 @@ typedef struct\n   signed int data_align;\n   unsigned int code_align;\n   unsigned char retaddr_column;\n-  unsigned char addr_encoding;\n+  unsigned char fde_encoding;\n+  unsigned char lsda_encoding;\n   unsigned char saw_z;\n-  unsigned char saw_lsda;\n } _Unwind_FrameState;\n \f\n-/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static unsigned char *\n-read_uleb128 (unsigned char *buf, _Unwind_Word *r)\n-{\n-  unsigned shift = 0;\n-  _Unwind_Word result = 0;\n-\n-  while (1)\n-    {\n-      unsigned char byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-      shift += 7;\n-    }\n-  *r = result;\n-  return buf;\n-}\n-\n-/* Decode the signed LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static unsigned char *\n-read_sleb128 (unsigned char *buf, _Unwind_Sword *r)\n-{\n-  unsigned shift = 0;\n-  _Unwind_Sword result = 0;\n-  unsigned char byte;\n-\n-  while (1)\n-    {\n-      byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-    }\n-  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n-    result |= - (1 << shift);\n-\n-  *r = result;\n-  return buf;\n-}\n-\n /* Read unaligned data from the instruction buffer.  */\n \n union unaligned\n@@ -167,107 +122,31 @@ union unaligned\n } __attribute__ ((packed));\n \n static inline void *\n-read_pointer (void *p) { union unaligned *up = p; return up->p; }\n+read_pointer (const void *p) { const union unaligned *up = p; return up->p; }\n \n static inline int\n-read_1u (void *p) { return *(unsigned char *)p; }\n+read_1u (const void *p) { return *(const unsigned char *)p; }\n \n static inline int\n-read_1s (void *p) { return *(signed char *)p; }\n+read_1s (const void *p) { return *(const signed char *)p; }\n \n static inline int\n-read_2u (void *p) { union unaligned *up = p; return up->u2; }\n+read_2u (const void *p) { const union unaligned *up = p; return up->u2; }\n \n static inline int\n-read_2s (void *p) { union unaligned *up = p; return up->s2; }\n+read_2s (const void *p) { const union unaligned *up = p; return up->s2; }\n \n static inline unsigned int\n-read_4u (void *p) { union unaligned *up = p; return up->u4; }\n+read_4u (const void *p) { const union unaligned *up = p; return up->u4; }\n \n static inline int\n-read_4s (void *p) { union unaligned *up = p; return up->s4; }\n+read_4s (const void *p) { const union unaligned *up = p; return up->s4; }\n \n static inline unsigned long\n-read_8u (void *p) { union unaligned *up = p; return up->u8; }\n+read_8u (const void *p) { const union unaligned *up = p; return up->u8; }\n \n static inline unsigned long\n-read_8s (void *p) { union unaligned *up = p; return up->s8; }\n-\n-static unsigned char *\n-read_encoded_pointer (unsigned char *p, unsigned char encoding,\n-\t\t      struct dwarf_eh_bases *bases, void **pptr)\n-{\n-  signed long val;\n-  unsigned char *ret;\n-  \n-  switch (encoding & 0x0f)\n-    {\n-    case DW_EH_PE_absptr:\n-      val = (_Unwind_Ptr) read_pointer (p);\n-      ret = p + sizeof (void *);\n-      break;\n-\n-    case DW_EH_PE_uleb128:\n-      ret = read_uleb128 (p, &val);\n-      break;\n-    case DW_EH_PE_sleb128:\n-      ret = read_sleb128 (p, &val);\n-      break;\n-\n-    case DW_EH_PE_udata2:\n-      val = read_2u (p);\n-      ret = p + 2;\n-      break;\n-    case DW_EH_PE_udata4:\n-      val = read_4u (p);\n-      ret = p + 4;\n-      break;\n-    case DW_EH_PE_udata8:\n-      val = read_8u (p);\n-      ret = p + 8;\n-      break;\n-\n-    case DW_EH_PE_sdata2:\n-      val = read_2s (p);\n-      ret = p + 2;\n-      break;\n-    case DW_EH_PE_sdata4:\n-      val = read_4s (p);\n-      ret = p + 4;\n-      break;\n-    case DW_EH_PE_sdata8:\n-      val = read_8s (p);\n-      ret = p + 8;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  if (val != 0)\n-    switch (encoding & 0xf0)\n-      {\n-      case DW_EH_PE_absptr:\n-\tbreak;\n-      case DW_EH_PE_pcrel:\n-\tval += (_Unwind_Ptr) p;\n-\tbreak;\n-      case DW_EH_PE_textrel:\n-\tval += (_Unwind_Ptr) bases->tbase;\n-\tbreak;\n-      case DW_EH_PE_datarel:\n-\tval += (_Unwind_Ptr) bases->dbase;\n-\tbreak;\n-      case DW_EH_PE_funcrel:\n-\tval += (_Unwind_Ptr) bases->func;\n-\tbreak;\n-      default:\n-\tabort ();\n-      }\n-\n-  *pptr = (void *) (_Unwind_Ptr) val;\n-  return ret;\n-}\n+read_8s (const void *p) { const union unaligned *up = p; return up->s8; }\n \f\n /* Get the value of register REG as saved in CONTEXT.  */\n \n@@ -332,13 +211,13 @@ _Unwind_GetTextRelBase (struct _Unwind_Context *context)\n    unit F belongs to.  Return a pointer to the byte after the augmentation,\n    or NULL if we encountered an undecipherable augmentation.  */\n \n-static unsigned char *\n+static const unsigned char *\n extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n \t\t  _Unwind_FrameState *fs)\n {\n-  unsigned char *aug = cie->augmentation;\n-  unsigned char *p = aug + strlen (aug) + 1;\n-  unsigned char *ret = NULL;\n+  const unsigned char *aug = cie->augmentation;\n+  const unsigned char *p = aug + strlen (aug) + 1;\n+  const unsigned char *ret = NULL;\n   _Unwind_Word code_align;\n   _Unwind_Sword data_align;\n \n@@ -349,6 +228,7 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n   fs->code_align = code_align;\n   fs->data_align = data_align;\n   fs->retaddr_column = *p++;\n+  fs->lsda_encoding = DW_EH_PE_omit;\n \n   /* If the augmentation starts with 'z', then a uleb128 immediately\n      follows containing the length of the augmentation field following\n@@ -373,20 +253,25 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n \t  aug += 2;\n \t}\n \n-      /* \"R\" indicates a byte indicating how addresses are encoded.  */\n+      /* \"L\" indicates a byte showing how the LSDA pointer is encoded.  */\n+      else if (aug[0] == 'L')\n+\t{\n+\t  fs->lsda_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"R\" indicates a byte indicating how FDE addresses are encoded.  */\n       else if (aug[0] == 'R')\n \t{\n-\t  fs->addr_encoding = *p++;\n+\t  fs->fde_encoding = *p++;\n \t  aug += 1;\n \t}\n \n-      /* \"P\" indicates a personality routine in the CIE augmentation\n-\t and an lsda pointer in the FDE augmentation.  */\n+      /* \"P\" indicates a personality routine in the CIE augmentation.  */\n       else if (aug[0] == 'P')\n \t{\n-\t  p = read_encoded_pointer (p, fs->addr_encoding, &context->bases,\n-\t\t\t\t    (void **) &fs->personality);\n-\t  fs->saw_lsda = 1;\n+\t  p = read_encoded_value (context, *p, p + 1,\n+\t\t\t\t  (_Unwind_Ptr *) &fs->personality);\n \t  aug += 1;\n \t}\n \n@@ -404,7 +289,7 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n    onto the stack to start.  */\n \n static _Unwind_Word\n-execute_stack_op (unsigned char *op_ptr, unsigned char *op_end,\n+execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n {\n   _Unwind_Word stack[64];\t/* ??? Assume this is enough. */\n@@ -800,8 +685,10 @@ execute_stack_op (unsigned char *op_ptr, unsigned char *op_end,\n    CIE info, and the PC range to evaluate.  */\n \n static void\n-execute_cfa_program (unsigned char *insn_ptr, unsigned char *insn_end,\n-\t\t     struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+execute_cfa_program (const unsigned char *insn_ptr,\n+\t\t     const unsigned char *insn_end,\n+\t\t     struct _Unwind_Context *context,\n+\t\t     _Unwind_FrameState *fs)\n {\n   struct frame_state_reg_info *unused_rs = NULL;\n \n@@ -832,8 +719,8 @@ execute_cfa_program (unsigned char *insn_ptr, unsigned char *insn_end,\n       else switch (insn)\n \t{\n \tcase DW_CFA_set_loc:\n-\t  insn_ptr = read_encoded_pointer (insn_ptr, fs->addr_encoding,\n-\t\t\t\t\t   &context->bases, &fs->pc);\n+\t  insn_ptr = read_encoded_value (context, fs->fde_encoding,\n+\t\t\t\t\t insn_ptr, (_Unwind_Ptr *) &fs->pc);\n \t  break;\n \n \tcase DW_CFA_advance_loc1:\n@@ -989,7 +876,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n   struct dwarf_fde *fde;\n   struct dwarf_cie *cie;\n-  unsigned char *aug, *insn, *end;\n+  const unsigned char *aug, *insn, *end;\n \n   memset (fs, 0, sizeof (*fs));\n   context->args_size = 0;\n@@ -1011,8 +898,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n #endif\n     }\n \n-  context->bases.func = fde->pc_begin;\n-  fs->pc = fde->pc_begin;\n+  fs->pc = context->bases.func;\n \n   cie = get_cie (fde);\n   insn = extract_cie_info (cie, context, fs);\n@@ -1026,16 +912,17 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \n   /* Locate augmentation for the fde.  */\n   aug = (unsigned char *)fde + sizeof (*fde);\n+  aug += 2 * size_of_encoded_value (fs->fde_encoding);\n   insn = NULL;\n   if (fs->saw_z)\n     {\n       _Unwind_Word i;\n       aug = read_uleb128 (aug, &i);\n       insn = aug + i;\n     }\n-  if (fs->saw_lsda)\n-    aug = read_encoded_pointer (aug, fs->addr_encoding,\n-\t\t\t\t&context->bases, &context->lsda);\n+  if (fs->lsda_encoding != DW_EH_PE_omit)\n+    aug = read_encoded_value (context, fs->lsda_encoding, aug,\n+\t\t\t      (_Unwind_Ptr *) &context->lsda);\n \n   /* Then the insns in the FDE up to our target PC.  */\n   if (insn == NULL)\n@@ -1076,7 +963,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t CFA calculation is so complicated as to require a stack program\n \t that this will not be a problem.  */\n       {\n-\tunsigned char *exp = fs->cfa_exp;\n+\tconst unsigned char *exp = fs->cfa_exp;\n \t_Unwind_Word len;\n \n \texp = read_uleb128 (exp, &len);\n@@ -1104,7 +991,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \tbreak;\n       case REG_SAVED_EXP:\n \t{\n-\t  unsigned char *exp = fs->regs.reg[i].loc.exp;\n+\t  const unsigned char *exp = fs->regs.reg[i].loc.exp;\n \t  _Unwind_Word len;\n \t  _Unwind_Ptr val;\n "}, {"sha": "264aa1821d84443b44690ab6c4350f0ee7c1c07d", "filename": "gcc/unwind-pe.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9550a643dc51e8058afeba44c818350a9012b/gcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-pe.h?ref=e1f9550a643dc51e8058afeba44c818350a9012b", "patch": "@@ -74,7 +74,7 @@ size_of_encoded_value (unsigned char encoding)\n    not available.  */\n \n static _Unwind_Ptr\n-base_of_encoded_value (unsigned char encoding, _Unwind_Context *context)\n+base_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n {\n   if (encoding == DW_EH_PE_omit)\n     return 0;\n@@ -204,7 +204,7 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n    rather than providing it directly.  */\n \n static inline const unsigned char *\n-read_encoded_value (_Unwind_Context *context, unsigned char encoding,\n+read_encoded_value (struct _Unwind_Context *context, unsigned char encoding,\n \t\t    const unsigned char *p, _Unwind_Ptr *val)\n {\n   return read_encoded_value_with_base (encoding, "}]}