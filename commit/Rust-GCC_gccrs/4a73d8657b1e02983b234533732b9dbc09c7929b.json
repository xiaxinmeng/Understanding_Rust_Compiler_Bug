{"sha": "4a73d8657b1e02983b234533732b9dbc09c7929b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3M2Q4NjU3YjFlMDI5ODNiMjM0NTMzNzMyYjlkYmMwOWM3OTI5Yg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-12-15T21:50:10Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-12-15T21:50:10Z"}, "message": "re PR other/25028 (TImode-to-floating conversions broken)\n\n\tPR other/25028\n\t* libgcc2.h (SF_SIZE, DF_SIZE, XF_SIZE, TF_SIZE): Define.\n\t* libgcc2.c (__floatdixf, __floatundixf, __floatditf,\n\t__floatunditf): Use #error if type sizes don't match requirements\n\tof implementation.\n\t(__floatdisf, __floatdidf): Unify.  Possibly use XFmode or TFmode\n\tas wider floating-point type.  Use #error if type sizes don't\n\tmatch requirements of implementation.  Avoid overflow in computing\n\tWtype_MAXp1_F * Wtype_MAXp1_F.  When special casing conversion,\n\tshift one more bit.  Cast 1 to DWtype or UDWtype for shifting.\n\t(__floatundisf, __floatundidf): Likewise.\n\t* config/ia64/hpux.h (XF_SIZE, TF_SIZE): Define.\n\t* config/ia64/ia64.c (ia64_init_libfuncs): Use\n\t_U_Qfcnvfxt_quad_to_quad and _U_Qfcnvxf_quad_to_quad for\n\tTFmode-TImode conversions.\n\t* doc/tm.texi (SF_SIZE, DF_SIZE, XF_SIZE, TF_SIZE): Document.\n\ntestsuite:\n\t* gcc.dg/torture/fp-int-convert-timode.c: Only XFAIL for LP64 IA64\n\tHP-UX.\n\nFrom-SVN: r108598", "tree": {"sha": "103ac80216ebf4fcc51f100555eacea1fd58a30f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/103ac80216ebf4fcc51f100555eacea1fd58a30f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a73d8657b1e02983b234533732b9dbc09c7929b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a73d8657b1e02983b234533732b9dbc09c7929b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a73d8657b1e02983b234533732b9dbc09c7929b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a73d8657b1e02983b234533732b9dbc09c7929b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4976b95c37dd8245c7565d76cfb729dc1b7f603f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4976b95c37dd8245c7565d76cfb729dc1b7f603f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4976b95c37dd8245c7565d76cfb729dc1b7f603f"}], "stats": {"total": 293, "additions": 199, "deletions": 94}, "files": [{"sha": "4170cbc9dc836548f0a2e11c11d3d9b79532d366", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -1,3 +1,22 @@\n+2005-12-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\tPR other/25028\n+\t* libgcc2.h (SF_SIZE, DF_SIZE, XF_SIZE, TF_SIZE): Define.\n+\t* libgcc2.c (__floatdixf, __floatundixf, __floatditf,\n+\t__floatunditf): Use #error if type sizes don't match requirements\n+\tof implementation.\n+\t(__floatdisf, __floatdidf): Unify.  Possibly use XFmode or TFmode\n+\tas wider floating-point type.  Use #error if type sizes don't\n+\tmatch requirements of implementation.  Avoid overflow in computing\n+\tWtype_MAXp1_F * Wtype_MAXp1_F.  When special casing conversion,\n+\tshift one more bit.  Cast 1 to DWtype or UDWtype for shifting.\n+\t(__floatundisf, __floatundidf): Likewise.\n+\t* config/ia64/hpux.h (XF_SIZE, TF_SIZE): Define.\n+\t* config/ia64/ia64.c (ia64_init_libfuncs): Use\n+\t_U_Qfcnvfxt_quad_to_quad and _U_Qfcnvxf_quad_to_quad for\n+\tTFmode-TImode conversions.\n+\t* doc/tm.texi (SF_SIZE, DF_SIZE, XF_SIZE, TF_SIZE): Document.\n+\n 2005-12-14  Craig Rodrigues  <rodrigc@gcc.gnu.org>\n \n \t* freebsd-spec.h (FBSD_TARGET_OS_CPP_BUILTINS):"}, {"sha": "9ffe1fddf30874c5ff2e5a7a363b925a05f6571f", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -195,10 +195,12 @@ do {\t\t\t\t\t\t\t\t\\\n /* Put all *xf routines in libgcc, regardless of long double size.  */\n #undef LIBGCC2_HAS_XF_MODE\n #define LIBGCC2_HAS_XF_MODE 1\n+#define XF_SIZE 64\n \n /* Put all *tf routines in libgcc, regardless of long double size.  */\n #undef LIBGCC2_HAS_TF_MODE\n #define LIBGCC2_HAS_TF_MODE 1\n+#define TF_SIZE 113\n \n /* HP-UX headers are C++-compatible.  */\n #define NO_IMPLICIT_EXTERN_C"}, {"sha": "e6767538d685df4c98c7e87efbfed172768dfab2", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -8437,11 +8437,13 @@ ia64_init_libfuncs (void)\n \n   set_conv_libfunc (sfix_optab, SImode, TFmode, \"_U_Qfcnvfxt_quad_to_sgl\");\n   set_conv_libfunc (sfix_optab, DImode, TFmode, \"_U_Qfcnvfxt_quad_to_dbl\");\n+  set_conv_libfunc (sfix_optab, TImode, TFmode, \"_U_Qfcnvfxt_quad_to_quad\");\n   set_conv_libfunc (ufix_optab, SImode, TFmode, \"_U_Qfcnvfxut_quad_to_sgl\");\n   set_conv_libfunc (ufix_optab, DImode, TFmode, \"_U_Qfcnvfxut_quad_to_dbl\");\n \n   set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_U_Qfcnvxf_sgl_to_quad\");\n   set_conv_libfunc (sfloat_optab, TFmode, DImode, \"_U_Qfcnvxf_dbl_to_quad\");\n+  set_conv_libfunc (sfloat_optab, TFmode, TImode, \"_U_Qfcnvxf_quad_to_quad\");\n   /* HP-UX 11.23 libc does not have a function for unsigned\n      SImode-to-TFmode conversion.  */\n   set_conv_libfunc (ufloat_optab, TFmode, DImode, \"_U_Qfcnvxuf_dbl_to_quad\");"}, {"sha": "b0dd8e1b10a9ebdd6be76499801055cf3200d5c5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -1548,6 +1548,20 @@ anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}\n is 128 then the default is 1, otherwise it is 0.\n @end defmac\n \n+@defmac SF_SIZE\n+@defmacx DF_SIZE\n+@defmacx XF_SIZE\n+@defmacx TF_SIZE\n+Define these macros to be the size in bits of the mantissa of\n+@code{SFmode}, @code{DFmode}, @code{XFmode} and @code{TFmode} values,\n+if the defaults in @file{libgcc2.h} are inappropriate.  By default,\n+@code{FLT_MANT_DIG} is used for @code{SF_SIZE}, @code{LDBL_MANT_DIG}\n+for @code{XF_SIZE} and @code{TF_SIZE}, and @code{DBL_MANT_DIG} or\n+@code{LDBL_MANT_DIG} for @code{DF_SIZE} according to whether\n+@code{LIBGCC2_DOUBLE_TYPE_SIZE} or\n+@code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is 64.\n+@end defmac\n+\n @defmac TARGET_FLT_EVAL_METHOD\n A C expression for the value for @code{FLT_EVAL_METHOD} in @file{float.h},\n assuming, if applicable, that the floating-point control word is in its"}, {"sha": "03cc448cab3e9e86f35a83bb73ed3c218ce2e6a3", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 117, "deletions": 93, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -1316,6 +1316,9 @@ __fixsfdi (SFtype a)\n XFtype\n __floatdixf (DWtype u)\n {\n+#if W_TYPE_SIZE > XF_SIZE\n+# error\n+#endif\n   XFtype d = (Wtype) (u >> W_TYPE_SIZE);\n   d *= Wtype_MAXp1_F;\n   d += (UWtype)u;\n@@ -1327,6 +1330,9 @@ __floatdixf (DWtype u)\n XFtype\n __floatundixf (UDWtype u)\n {\n+#if W_TYPE_SIZE > XF_SIZE\n+# error\n+#endif\n   XFtype d = (UWtype) (u >> W_TYPE_SIZE);\n   d *= Wtype_MAXp1_F;\n   d += (UWtype)u;\n@@ -1338,6 +1344,9 @@ __floatundixf (UDWtype u)\n TFtype\n __floatditf (DWtype u)\n {\n+#if W_TYPE_SIZE > TF_SIZE\n+# error\n+#endif\n   TFtype d = (Wtype) (u >> W_TYPE_SIZE);\n   d *= Wtype_MAXp1_F;\n   d += (UWtype)u;\n@@ -1349,93 +1358,91 @@ __floatditf (DWtype u)\n TFtype\n __floatunditf (UDWtype u)\n {\n-  TFtype d = (UWtype) (u >> W_TYPE_SIZE);\n-  d *= Wtype_MAXp1_F;\n-  d += (UWtype)u;\n-  return d;\n-}\n-#endif\n-\n-#if defined(L_floatdidf) && LIBGCC2_HAS_DF_MODE\n-DFtype\n-__floatdidf (DWtype u)\n-{\n-  DFtype d = (Wtype) (u >> W_TYPE_SIZE);\n-  d *= Wtype_MAXp1_F;\n-  d += (UWtype)u;\n-  return d;\n-}\n+#if W_TYPE_SIZE > TF_SIZE\n+# error\n #endif\n-\n-#if defined(L_floatundidf) && LIBGCC2_HAS_DF_MODE\n-DFtype\n-__floatundidf (UDWtype u)\n-{\n-  DFtype d = (UWtype) (u >> W_TYPE_SIZE);\n+  TFtype d = (UWtype) (u >> W_TYPE_SIZE);\n   d *= Wtype_MAXp1_F;\n   d += (UWtype)u;\n   return d;\n }\n #endif\n \n-#if defined(L_floatdisf) && LIBGCC2_HAS_SF_MODE\n+#if (defined(L_floatdisf) && LIBGCC2_HAS_SF_MODE)\t\\\n+     || (defined(L_floatdidf) && LIBGCC2_HAS_DF_MODE)\n #define DI_SIZE (W_TYPE_SIZE * 2)\n-#define SF_SIZE FLT_MANT_DIG\n+#define F_MODE_OK(SIZE) (SIZE < DI_SIZE && SIZE > (DI_SIZE - SIZE + FSSIZE))\n+#if defined(L_floatdisf)\n+#define FUNC __floatdisf\n+#define FSTYPE SFtype\n+#define FSSIZE SF_SIZE\n+#else\n+#define FUNC __floatdidf\n+#define FSTYPE DFtype\n+#define FSSIZE DF_SIZE\n+#endif\n \n-SFtype\n-__floatdisf (DWtype u)\n+FSTYPE\n+FUNC (DWtype u)\n {\n-#if SF_SIZE >= W_TYPE_SIZE\n+#if FSSIZE >= W_TYPE_SIZE\n   /* When the word size is small, we never get any rounding error.  */\n-  SFtype f = (Wtype) (u >> W_TYPE_SIZE);\n+  FSTYPE f = (Wtype) (u >> W_TYPE_SIZE);\n   f *= Wtype_MAXp1_F;\n   f += (UWtype)u;\n   return f;\n-#elif LIBGCC2_HAS_DF_MODE\n-\n-#if LIBGCC2_DOUBLE_TYPE_SIZE == 64\n-#define DF_SIZE DBL_MANT_DIG\n-#elif LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n-#define DF_SIZE LDBL_MANT_DIG\n+#elif (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))\t\\\n+     || (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))\t\\\n+     || (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))\n+\n+#if (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))\n+# define FSIZE DF_SIZE\n+# define FTYPE DFtype\n+#elif (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))\n+# define FSIZE XF_SIZE\n+# define FTYPE XFtype\n+#elif (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))\n+# define FSIZE TF_SIZE\n+# define FTYPE TFtype\n #else\n # error\n #endif\n \n-#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))\n+#define REP_BIT ((UDWtype) 1 << (DI_SIZE - FSIZE))\n \n   /* Protect against double-rounding error.\n      Represent any low-order bits, that might be truncated by a bit that\n      won't be lost.  The bit can go in anywhere below the rounding position\n-     of the SFmode.  A fixed mask and bit position handles all usual\n-     configurations.  It doesn't handle the case of 128-bit DImode, however.  */\n-  if (DF_SIZE < DI_SIZE\n-      && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n+     of the FSTYPE.  A fixed mask and bit position handles all usual\n+     configurations.  */\n+  if (! (- ((DWtype) 1 << FSIZE) < u\n+\t && u < ((DWtype) 1 << FSIZE)))\n     {\n-      if (! (- ((DWtype) 1 << DF_SIZE) < u\n-\t     && u < ((DWtype) 1 << DF_SIZE)))\n+      if ((UDWtype) u & (REP_BIT - 1))\n \t{\n-\t  if ((UDWtype) u & (REP_BIT - 1))\n-\t    {\n-\t      u &= ~ (REP_BIT - 1);\n-\t      u |= REP_BIT;\n-\t    }\n+\t  u &= ~ (REP_BIT - 1);\n+\t  u |= REP_BIT;\n \t}\n     }\n \n-  /* Do the calculation in DFmode so that we don't lose any of the\n-     precision of the high word while multiplying it.  */\n-  DFtype f = (Wtype) (u >> W_TYPE_SIZE);\n+  /* Do the calculation in a wider type so that we don't lose any of\n+     the precision of the high word while multiplying it.  */\n+  FTYPE f = (Wtype) (u >> W_TYPE_SIZE);\n   f *= Wtype_MAXp1_F;\n   f += (UWtype)u;\n-  return (SFtype) f;\n+  return (FSTYPE) f;\n #else\n-  /* Finally, the word size is larger than the number of bits in SFmode,\n-     and we've got no DFmode.  The only way to avoid double rounding is\n-     to special case the extraction.  */\n+#if FSSIZE >= W_TYPE_SIZE - 2\n+# error\n+#endif\n+  /* Finally, the word size is larger than the number of bits in the\n+     required FSTYPE, and we've got no suitable wider type.  The only\n+     way to avoid double rounding is to special case the\n+     extraction.  */\n \n   /* If there are no high bits set, fall back to one conversion.  */\n   if ((Wtype)u == u)\n-    return (SFtype)(Wtype)u;\n+    return (FSTYPE)(Wtype)u;\n \n   /* Otherwise, find the power of two.  */\n   Wtype hi = u >> W_TYPE_SIZE;\n@@ -1447,82 +1454,99 @@ __floatdisf (DWtype u)\n \n   /* No leading bits means u == minimum.  */\n   if (count == 0)\n-    return -(Wtype_MAXp1_F * Wtype_MAXp1_F / 2);\n+    return -(Wtype_MAXp1_F * (Wtype_MAXp1_F / 2));\n \n-  shift = W_TYPE_SIZE - count;\n+  shift = 1 + W_TYPE_SIZE - count;\n \n   /* Shift down the most significant bits.  */\n   hi = u >> shift;\n \n   /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n-  if (u & ((1 << shift) - 1))\n+  if (u & (((DWtype)1 << shift) - 1))\n     hi |= 1;\n \n   /* Convert the one word of data, and rescale.  */\n-  SFtype f = hi;\n-  f *= (UWtype)1 << shift;\n+  FSTYPE f = hi;\n+  f *= (UDWtype)1 << shift;\n   return f;\n #endif\n }\n #endif\n \n-#if defined(L_floatundisf) && LIBGCC2_HAS_SF_MODE\n+#if (defined(L_floatundisf) && LIBGCC2_HAS_SF_MODE)\t\\\n+     || (defined(L_floatundidf) && LIBGCC2_HAS_DF_MODE)\n #define DI_SIZE (W_TYPE_SIZE * 2)\n-#define SF_SIZE FLT_MANT_DIG\n+#define F_MODE_OK(SIZE) (SIZE < DI_SIZE && SIZE > (DI_SIZE - SIZE + FSSIZE))\n+#if defined(L_floatundisf)\n+#define FUNC __floatundisf\n+#define FSTYPE SFtype\n+#define FSSIZE SF_SIZE\n+#else\n+#define FUNC __floatundidf\n+#define FSTYPE DFtype\n+#define FSSIZE DF_SIZE\n+#endif\n \n-SFtype\n-__floatundisf (UDWtype u)\n+FSTYPE\n+FUNC (UDWtype u)\n {\n-#if SF_SIZE >= W_TYPE_SIZE\n+#if FSSIZE >= W_TYPE_SIZE\n   /* When the word size is small, we never get any rounding error.  */\n-  SFtype f = (UWtype) (u >> W_TYPE_SIZE);\n+  FSTYPE f = (UWtype) (u >> W_TYPE_SIZE);\n   f *= Wtype_MAXp1_F;\n   f += (UWtype)u;\n   return f;\n-#elif LIBGCC2_HAS_DF_MODE\n-\n-#if LIBGCC2_DOUBLE_TYPE_SIZE == 64\n-#define DF_SIZE DBL_MANT_DIG\n-#elif LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n-#define DF_SIZE LDBL_MANT_DIG\n+#elif (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))\t\\\n+     || (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))\t\\\n+     || (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))\n+\n+#if (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))\n+# define FSIZE DF_SIZE\n+# define FTYPE DFtype\n+#elif (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))\n+# define FSIZE XF_SIZE\n+# define FTYPE XFtype\n+#elif (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))\n+# define FSIZE TF_SIZE\n+# define FTYPE TFtype\n #else\n # error\n #endif\n \n-#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))\n+#define REP_BIT ((UDWtype) 1 << (DI_SIZE - FSIZE))\n \n   /* Protect against double-rounding error.\n      Represent any low-order bits, that might be truncated by a bit that\n      won't be lost.  The bit can go in anywhere below the rounding position\n-     of the SFmode.  A fixed mask and bit position handles all usual\n-     configurations.  It doesn't handle the case of 128-bit DImode, however.  */\n-  if (DF_SIZE < DI_SIZE\n-      && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n+     of the FSTYPE.  A fixed mask and bit position handles all usual\n+     configurations.  */\n+  if (u >= ((UDWtype) 1 << FSIZE))\n     {\n-      if (u >= ((UDWtype) 1 << DF_SIZE))\n+      if ((UDWtype) u & (REP_BIT - 1))\n \t{\n-\t  if ((UDWtype) u & (REP_BIT - 1))\n-\t    {\n-\t      u &= ~ (REP_BIT - 1);\n-\t      u |= REP_BIT;\n-\t    }\n+\t  u &= ~ (REP_BIT - 1);\n+\t  u |= REP_BIT;\n \t}\n     }\n \n-  /* Do the calculation in DFmode so that we don't lose any of the\n-     precision of the high word while multiplying it.  */\n-  DFtype f = (UWtype) (u >> W_TYPE_SIZE);\n+  /* Do the calculation in a wider type so that we don't lose any of\n+     the precision of the high word while multiplying it.  */\n+  FTYPE f = (UWtype) (u >> W_TYPE_SIZE);\n   f *= Wtype_MAXp1_F;\n   f += (UWtype)u;\n-  return (SFtype) f;\n+  return (FSTYPE) f;\n #else\n-  /* Finally, the word size is larger than the number of bits in SFmode,\n-     and we've got no DFmode.  The only way to avoid double rounding is\n-     to special case the extraction.  */\n+#if FSSIZE == W_TYPE_SIZE - 1\n+# error\n+#endif\n+  /* Finally, the word size is larger than the number of bits in the\n+     required FSTYPE, and we've got no suitable wider type.  The only\n+     way to avoid double rounding is to special case the\n+     extraction.  */\n \n   /* If there are no high bits set, fall back to one conversion.  */\n   if ((UWtype)u == u)\n-    return (SFtype)(UWtype)u;\n+    return (FSTYPE)(UWtype)u;\n \n   /* Otherwise, find the power of two.  */\n   UWtype hi = u >> W_TYPE_SIZE;\n@@ -1536,12 +1560,12 @@ __floatundisf (UDWtype u)\n   hi = u >> shift;\n \n   /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n-  if (u & ((1 << shift) - 1))\n+  if (u & (((UDWtype)1 << shift) - 1))\n     hi |= 1;\n \n   /* Convert the one word of data, and rescale.  */\n-  SFtype f = hi;\n-  f *= (UWtype)1 << shift;\n+  FSTYPE f = hi;\n+  f *= (UDWtype)1 << shift;\n   return f;\n #endif\n }"}, {"sha": "f8056d66e141e4e4b8fb3a8a93bc5daad518a678", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -79,6 +79,44 @@ extern short int __get_eh_table_version (struct exception_descriptor *);\n   (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n #endif\n \n+#ifndef SF_SIZE\n+#if LIBGCC2_HAS_SF_MODE\n+#define SF_SIZE FLT_MANT_DIG\n+#else\n+#define SF_SIZE 0\n+#endif\n+#endif\n+\n+#ifndef DF_SIZE\n+#if LIBGCC2_HAS_DF_MODE\n+#if LIBGCC2_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE DBL_MANT_DIG\n+#elif LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE LDBL_MANT_DIG\n+#else\n+#define DF_SIZE 0\n+#endif\n+#else\n+#define DF_SIZE 0\n+#endif\n+#endif\n+\n+#ifndef XF_SIZE\n+#if LIBGCC2_HAS_XF_MODE\n+#define XF_SIZE LDBL_MANT_DIG\n+#else\n+#define XF_SIZE 0\n+#endif\n+#endif\n+\n+#ifndef TF_SIZE\n+#if LIBGCC2_HAS_TF_MODE\n+#define TF_SIZE LDBL_MANT_DIG\n+#else\n+#define TF_SIZE 0\n+#endif\n+#endif\n+\n #ifndef MIN_UNITS_PER_WORD\n #define MIN_UNITS_PER_WORD UNITS_PER_WORD\n #endif"}, {"sha": "39fa89ceb607b931213472e6978b1f8600705a5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -1,3 +1,9 @@\n+2005-12-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\tPR other/25028\n+\t* gcc.dg/torture/fp-int-convert-timode.c: Only XFAIL for LP64 IA64\n+\tHP-UX.\n+\n 2005-12-15  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.dg/20051215-1.c: New file."}, {"sha": "244fc31728a45027b30ba6cdf8901c014a0b89eb", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-timode.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a73d8657b1e02983b234533732b9dbc09c7929b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c?ref=4a73d8657b1e02983b234533732b9dbc09c7929b", "patch": "@@ -1,6 +1,6 @@\n /* Test floating-point conversions.  TImode types.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do run { xfail lp64 } } */\n+/* { dg-do run { xfail { ia64-*-hpux* && lp64 } } } */\n /* { dg-options \"\" } */\n \n #include <float.h>"}]}