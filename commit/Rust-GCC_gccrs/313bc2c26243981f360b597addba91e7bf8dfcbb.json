{"sha": "313bc2c26243981f360b597addba91e7bf8dfcbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEzYmMyYzI2MjQzOTgxZjM2MGI1OTdhZGRiYTkxZTdiZjhkZmNiYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-30T15:48:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-30T15:48:19Z"}, "message": "decl2.c (struct priority_info_s): Remove initialization_sequence and destruction_sequence.\n\n\t* decl2.c (struct priority_info_s): Remove initialization_sequence\n\tand destruction_sequence.\n\t(start_static_storage_duration_function): Return the body of the\n\tfunction.  Convert for function-at-a-time mode.\n\t(generate_inits_for_priority): Remove.\n\t(finish_static_storage_duration_function): Change prototype.\n\tAdjust for function-at-a-time mode.\n\t(do_static_initialization): Likewise.\n\t(do_static_destruction): Likewise.\n\t(do_static_initialization_and_destruction): Remove.\n\t(start_static_initialization_or_destruction): New function.\n\t(finish_static_initialization_or_destruction): Likewise.\n\t(get_priority_info): Don't manipulation initialization_sequence or\n\tdestruction_sequence.\n\t(prune_vars_needing_no_initialization): New function.\n\t(write_out_vars): Likewise.\n\t(finish_file): Use the various new functions instead of the old.\n\nFrom-SVN: r29731", "tree": {"sha": "948177ed00e80522b5d60a0bc5fef4483ca01a68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/948177ed00e80522b5d60a0bc5fef4483ca01a68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/313bc2c26243981f360b597addba91e7bf8dfcbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313bc2c26243981f360b597addba91e7bf8dfcbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313bc2c26243981f360b597addba91e7bf8dfcbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313bc2c26243981f360b597addba91e7bf8dfcbb/comments", "author": null, "committer": null, "parents": [{"sha": "d9d5c9de1c377b1104d371bc935a31e53e83cf8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d5c9de1c377b1104d371bc935a31e53e83cf8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d5c9de1c377b1104d371bc935a31e53e83cf8d"}], "stats": {"total": 567, "additions": 269, "deletions": 298}, "files": [{"sha": "0272a878642c206d13cd42a051df12796e3026d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313bc2c26243981f360b597addba91e7bf8dfcbb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313bc2c26243981f360b597addba91e7bf8dfcbb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=313bc2c26243981f360b597addba91e7bf8dfcbb", "patch": "@@ -1,3 +1,23 @@\n+1999-09-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl2.c (struct priority_info_s): Remove initialization_sequence\n+\tand destruction_sequence.\n+\t(start_static_storage_duration_function): Return the body of the\n+\tfunction.  Convert for function-at-a-time mode.\n+\t(generate_inits_for_priority): Remove.\n+\t(finish_static_storage_duration_function): Change prototype.\n+\tAdjust for function-at-a-time mode.\n+\t(do_static_initialization): Likewise.\n+\t(do_static_destruction): Likewise.\n+\t(do_static_initialization_and_destruction): Remove.\n+\t(start_static_initialization_or_destruction): New function.\n+\t(finish_static_initialization_or_destruction): Likewise.\n+\t(get_priority_info): Don't manipulation initialization_sequence or\n+\tdestruction_sequence.\n+\t(prune_vars_needing_no_initialization): New function.\n+\t(write_out_vars): Likewise.\n+\t(finish_file): Use the various new functions instead of the old.\n+\t\n Thu Sep 30 00:13:27 1999  Dirk Zoller  <duz@rtsffm.com>\n \n \t* cp-tree.h (warn_float_equal): Declare."}, {"sha": "19a9cf1701fa64b0b2d9c463aec1cb3cbb50ba38", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 249, "deletions": 298, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313bc2c26243981f360b597addba91e7bf8dfcbb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313bc2c26243981f360b597addba91e7bf8dfcbb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=313bc2c26243981f360b597addba91e7bf8dfcbb", "patch": "@@ -53,12 +53,6 @@ extern cpp_reader  parse_in;\n /* This structure contains information about the initializations\n    and/or destructions required for a particular priority level.  */\n typedef struct priority_info_s {\n-  /* A label indicating where we should generate the next\n-     initialization with this priority.  */\n-  rtx initialization_sequence;\n-  /* A label indicating where we should generate the next destruction\n-     with this priority.  */\n-  rtx destruction_sequence;\n   /* Non-zero if there have been any initializations at this priority\n      throughout the translation unit.  */\n   int initializations_p;\n@@ -85,16 +79,19 @@ static tree decl_namespace PROTO((tree));\n static tree validate_nonmember_using_decl PROTO((tree, tree *, tree *));\n static void do_nonmember_using_decl PROTO((tree, tree, tree, tree,\n \t\t\t\t\t   tree *, tree *));\n-static void start_static_storage_duration_function PROTO((void));\n-static int generate_inits_for_priority PROTO((splay_tree_node, void *));\n-static void finish_static_storage_duration_function PROTO((void));\n+static tree start_static_storage_duration_function PROTO((void));\n+static void finish_static_storage_duration_function PROTO((tree));\n static priority_info get_priority_info PROTO((int));\n-static void do_static_initialization PROTO((tree, tree, tree, int));\n-static void do_static_destruction PROTO((tree, tree, int));\n-static void do_static_initialization_and_destruction PROTO((tree, tree));\n+static void do_static_initialization PROTO((tree, tree));\n+static void do_static_destruction PROTO((tree));\n+static tree start_static_initialization_or_destruction PROTO((tree, int));\n+static void finish_static_initialization_or_destruction PROTO((tree));\n static void generate_ctor_or_dtor_function PROTO((int, int));\n static int generate_ctor_and_dtor_functions_for_priority\n                                   PROTO((splay_tree_node, void *));\n+static tree prune_vars_needing_no_initialization PROTO((tree));\n+static void write_out_vars PROTO((tree));\n+\n extern int current_class_depth;\n \n /* A list of virtual function tables we must make sure to write out.  */\n@@ -2916,13 +2913,14 @@ static splay_tree priority_info_map;\n    It is assumed that this function will only be called once per\n    translation unit.  */\n \n-static void\n+static tree\n start_static_storage_duration_function ()\n {\n   static unsigned ssdf_number;\n \n   tree parm_types;\n   tree type;\n+  tree body;\n   char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\\0' */ + 32];\n \n   /* Create the identifier for this function.  It will be of the form\n@@ -3000,104 +2998,30 @@ start_static_storage_duration_function ()\n   start_function (/*specs=*/NULL_TREE, \n \t\t  ssdf_decl,\n \t\t  /*attrs=*/NULL_TREE,\n-\t\t  SF_PRE_PARSED | SF_EXPAND);\n+\t\t  SF_PRE_PARSED);\n \n   /* Set up the scope of the outermost block in the function.  */\n-  store_parm_decls ();\n-  pushlevel (0);\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n+  body = begin_compound_stmt (/*has_no_scope=*/0);\n \n   /* This function must not be deferred because we are depending on\n      its compilation to tell us what is TREE_SYMBOL_REFERENCED.  */\n   current_function_cannot_inline \n     = \"static storage duration functions cannot be inlined\";\n-}\n-\n-/* Generate the initialization code for the priority indicated in N.  */\n-\n-static int\n-generate_inits_for_priority (n, data)\n-     splay_tree_node n;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  int priority = (int) n->key;\n-  priority_info pi = (priority_info) n->value;\n-\n-  /* For each priority N which has been used generate code which looks\n-     like:\n-\n-       if (__priority == N) {\n-         if (__initialize_p)\n-\t   ...\n-\t else\n-\t   ...\n-       }\n-\n-     We use the sequences we've accumulated to fill in the `...'s.  */\n-  expand_start_cond (build_binary_op (EQ_EXPR,\n-\t\t\t\t      priority_decl,\n-\t\t\t\t      build_int_2 (priority, 0)),\n-\t\t     /*exit_flag=*/0);\n-\n-  /* Do the initializations.  */\n-  expand_start_cond (build_binary_op (NE_EXPR,\n-\t\t\t\t      initialize_p_decl,\n-\t\t\t\t      integer_zero_node),\n-\t\t     /*exit_flag=*/0);\n-  if (pi->initialization_sequence) \n-    {\n-      rtx insns;\n-\n-      push_to_sequence (pi->initialization_sequence);\n-      insns = gen_sequence ();\n-      end_sequence ();\n-\n-      emit_insn (insns);\n-      pi->initialization_sequence = NULL_RTX;\n-      pi->initializations_p = 1;\n-    }\n-\n-  /* Do the destructions.  */\n-  expand_start_else ();\n-  if (pi->destruction_sequence)\n-    {\n-      rtx insns;\n-\n-      push_to_sequence (pi->destruction_sequence);\n-      insns = gen_sequence ();\n-      end_sequence ();\n \n-      emit_insn (insns);\n-      pi->destruction_sequence = NULL_RTX;\n-      pi->destructions_p = 1;\n-    }\n-  \n-  /* Close out the conditionals.  */\n-  expand_end_cond ();\n-  expand_end_cond ();\n-\n-  /* Don't stop iterating.  */\n-  return 0;\n+  return body;\n }\n \n /* Finish the generation of the function which performs initialization\n    and destruction of objects with static storage duration.  After\n    this point, no more such objects can be created.  */\n \n static void\n-finish_static_storage_duration_function ()\n+finish_static_storage_duration_function (body)\n+     tree body;\n {\n-  splay_tree_foreach (priority_info_map, \n-\t\t      generate_inits_for_priority,\n-\t\t      /*data=*/0);\n-\n   /* Close out the function.  */\n-  expand_end_bindings (getdecls (), 1, 0);\n-  poplevel (1, 0, 0);\n-  pop_momentary ();\n-  finish_function (lineno, 0);\n+  finish_compound_stmt (/*has_no_scope=*/0, body);\n+  expand_body (finish_function (lineno, 0));\n }\n \n /* Return the information about the indicated PRIORITY level.  If no\n@@ -3118,8 +3042,6 @@ get_priority_info (priority)\n       /* Create a new priority information structure, and insert it\n \t into the map.  */\n       pi = (priority_info) xmalloc (sizeof (struct priority_info_s));\n-      pi->initialization_sequence = NULL_RTX;\n-      pi->destruction_sequence = NULL_RTX;\n       pi->initializations_p = 0;\n       pi->destructions_p = 0;\n       splay_tree_insert (priority_info_map,\n@@ -3132,75 +3054,159 @@ get_priority_info (priority)\n   return pi;\n }\n \n+/* Set up to handle the initialization or destruction of DECL.  If\n+   INITP is non-zero, we are initializing the variable.  Otherwise, we\n+   are destroying it.  */\n+\n+static tree\n+start_static_initialization_or_destruction (decl, initp)\n+     tree decl;\n+     int initp;\n+{\n+  tree sentry_if_stmt = NULL_TREE;\n+  int priority;\n+  tree cond;\n+  tree init_cond;\n+  priority_info pi;\n+\n+  /* Figure out the priority for this declaration.  */\n+  priority = DECL_INIT_PRIORITY (decl);\n+  if (!priority)\n+    priority = DEFAULT_INIT_PRIORITY;\n+\n+  /* Remember that we had an initialization or finalization at this\n+     priority.  */\n+  pi = get_priority_info (priority);\n+  if (initp)\n+    pi->initializations_p = 1;\n+  else\n+    pi->destructions_p = 1;\n+\n+  /* Trick the compiler into thinking we are at the file and line\n+     where DECL was declared so that error-messages make sense, and so\n+     that the debugger will show somewhat sensible file and line\n+     information.  */\n+  input_filename = DECL_SOURCE_FILE (decl);\n+  lineno = DECL_SOURCE_LINE (decl);\n+\n+  /* Because of:\n+\n+       [class.access.spec]\n+\n+       Access control for implicit calls to the constructors,\n+       the conversion functions, or the destructor called to\n+       create and destroy a static data member is performed as\n+       if these calls appeared in the scope of the member's\n+       class.  \n+\n+     we pretend we are in a static member function of the class of\n+     which the DECL is a member.  */\n+  if (member_p (decl))\n+    {\n+      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n+      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n+    }\n+  \n+  /* Conditionalize this initialization on being in the right priority\n+     and being initializing/finalizing appropriately.  */\n+  sentry_if_stmt = begin_if_stmt ();\n+  cond = build_binary_op (EQ_EXPR,\n+\t\t\t  priority_decl,\n+\t\t\t  build_int_2 (priority, 0));\n+  init_cond = initp ? integer_one_node : integer_zero_node;\n+  init_cond = build_binary_op (EQ_EXPR,\n+\t\t\t       initialize_p_decl,\n+\t\t\t       init_cond);\n+  cond = build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n+\n+  /* We need a sentry if this is an object with external linkage that\n+     might be initialized in more than one place.  */\n+  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n+\t\t\t     || DECL_ONE_ONLY (decl)\n+\t\t\t     || DECL_WEAK (decl)))\n+    {\n+      tree sentry;\n+      tree sentry_cond;\n+\n+      sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\n+      /* We do initializations only if the SENTRY is zero, i.e., if we\n+\t are the first to initialize the variable.  We do destructions\n+\t only if the SENTRY is one, i.e., if we are the last to\n+\t destroy the variable.  */\n+      if (initp)\n+\tsentry_cond = build_binary_op (EQ_EXPR,\n+\t\t\t\t       build_unary_op (PREINCREMENT_EXPR,\n+\t\t\t\t\t\t       sentry,\n+\t\t\t\t\t\t       /*noconvert=*/1),\n+\t\t\t\t       integer_one_node);\n+      else\n+\tsentry_cond = build_binary_op (EQ_EXPR,\n+\t\t\t\t       build_unary_op (PREDECREMENT_EXPR,\n+\t\t\t\t\t\t       sentry,\n+\t\t\t\t\t\t       /*noconvert=*/1),\n+\t\t\t\t       integer_zero_node);\n+\n+      cond = build_binary_op (TRUTH_ANDIF_EXPR, cond, sentry_cond);\n+    }\n+\n+  finish_if_stmt_cond (cond, sentry_if_stmt);\n+\n+  return sentry_if_stmt;\n+}\n+\n+/* We've just finished generating code to do an initialization or\n+   finalization.  SENTRY_IF_STMT is the if-statement we used to guard\n+   the initialization.  */\n+\n+static void\n+finish_static_initialization_or_destruction (sentry_if_stmt)\n+     tree sentry_if_stmt;\n+{\n+  finish_then_clause (sentry_if_stmt);\n+  finish_if_stmt ();\n+\n+  /* Now that we're done with DECL we don't need to pretend to be a\n+     member of its class any longer.  */\n+  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n+}\n+\n /* Generate code to do the static initialization of DECL.  The\n    initialization is INIT.  If DECL may be initialized more than once\n    in different object files, SENTRY is the guard variable to \n    check.  PRIORITY is the priority for the initialization.  */\n \n static void\n-do_static_initialization (decl, init, sentry, priority)\n+do_static_initialization (decl, init)\n      tree decl;\n      tree init;\n-     tree sentry;\n-     int priority;\n {\n-  priority_info pi;\n+  tree expr;\n+  tree sentry_if_stmt;\n \n-  /* Get the priority information for this PRIORITY,  */\n-  pi = get_priority_info (priority);\n-  if (!pi->initialization_sequence)\n-    start_sequence ();\n-  else\n-    push_to_sequence (pi->initialization_sequence);\n-\n-  /* Tell the debugger that we are at the location of the static\n-     variable in question.  */\n-  emit_note (input_filename, lineno);\n-\n-  /* If there's a SENTRY, we only do the initialization if it is\n-     zero, i.e., if we are the first to initialize it.  */\n-  if (sentry) \n-    expand_start_cond (build_binary_op (EQ_EXPR, \n-\t\t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t\t\t\tsentry,\n-\t\t\t\t\t\t\t/*noconvert=*/0),\n-\t\t\t\t\tinteger_one_node),\n-\t\t       /*exit_flag=*/0);\n+  /* Set up for the initialization.  */\n+  sentry_if_stmt\n+    = start_static_initialization_or_destruction (decl,\n+\t\t\t\t\t\t  /*initp=*/1);\n   \n-  /* Prepare a binding level for temporaries created during the\n-     initialization.  */\n-  expand_start_target_temps ();\n-\n+  /* Do the initialization itself.  */\n   if (IS_AGGR_TYPE (TREE_TYPE (decl))\n       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    expand_expr (build_aggr_init (decl, init, 0),\n-\t\t const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    expr = build_aggr_init (decl, init, 0);\n   else if (TREE_CODE (init) == TREE_VEC)\n-    expand_expr (build_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t\t TREE_VEC_ELT (init, 1),\n-\t\t\t\t TREE_VEC_ELT (init, 2), 0),\n-\t\t const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    expr = build_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t   TREE_VEC_ELT (init, 1),\n+\t\t\t   TREE_VEC_ELT (init, 2), 0);\n   else\n-    expand_assignment (decl, init, 0, 0);\n-  \n-  /* The expression might have involved increments and decrements.  */\n-  emit_queue ();\n-\n-  /* Cleanup any temporaries needed for the initial value.  */\n-  expand_end_target_temps ();\n-\n-  /* Cleanup any deferred pops from function calls.  This would be done\n-     by expand_end_cond, but we also need it when !SENTRY, since we are\n-     constructing these sequences by parts.  */\n-  do_pending_stack_adjust ();\n-\n-  /* Close the conditional opened above.  */\n-  if (sentry)\n-    expand_end_cond ();\n+    {\n+      expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+    }\n+  finish_expr_stmt (expr);\n \n-  /* Save the sequence for later use.  */\n-  pi->initialization_sequence = get_insns ();\n-  end_sequence ();\n+  /* Finsh up.  */\n+  finish_static_initialization_or_destruction (sentry_if_stmt);\n }\n \n /* Generate code to do the static destruction of DECL.  If DECL may be\n@@ -3209,143 +3215,82 @@ do_static_initialization (decl, init, sentry, priority)\n    destruction.  */\n \n static void\n-do_static_destruction (decl, sentry, priority)\n+do_static_destruction (decl)\n      tree decl;\n-     tree sentry;\n-     int priority;\n {\n-  rtx new_insns;\n-  priority_info pi;\n+  tree sentry_if_stmt;\n \n   /* If we don't need a destructor, there's nothing to do.  */\n   if (!TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n     \n-  /* Get the priority information for this PRIORITY,  */\n-  pi = get_priority_info (priority);\n-  if (!pi->destruction_sequence)\n-    start_sequence ();\n-  else\n-    push_to_sequence (pi->destruction_sequence);\n-\n-  /* Start a new sequence to handle just this destruction.  */\n-  start_sequence ();\n-\n-  /* Tell the debugger that we are at the location of the static\n-     variable in question.  */\n-  emit_note (input_filename, lineno);\n-  \n-  /* If there's a SENTRY, we only do the destruction if it is one,\n-     i.e., if we are the last to destroy it.  */\n-  if (sentry)\n-    expand_start_cond (build_binary_op (EQ_EXPR,\n-\t\t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t\t\t\tsentry,\n-\t\t\t\t\t\t\t/*nonconvert=*/1),\n-\t\t\t\t\tinteger_zero_node),\n-\t\t       /*exit_flag=*/0);\n-  \n   /* Actually do the destruction.  */\n-  expand_expr_stmt (build_cleanup (decl));\n-\n-  /* Cleanup any deferred pops from function calls.  This would be done\n-     by expand_end_cond, but we also need it when !SENTRY, since we are\n-     constructing these sequences by parts.  */\n-  do_pending_stack_adjust ();\n-\n-  /* Close the conditional opened above.  */\n-  if (sentry)\n-    expand_end_cond ();\n-\n-  /* Insert the NEW_INSNS before the current insns.  (Destructions are\n-     run in reverse order of initializations.)  */\n-  new_insns = gen_sequence ();\n-  end_sequence ();\n-  if (pi->destruction_sequence)\n-    emit_insn_before (new_insns, pi->destruction_sequence);\n-  else\n-    emit_insn (new_insns);\n-\n-  /* Save the sequence for later use.  */\n-  pi->destruction_sequence = get_insns ();\n-  end_sequence ();\n+  sentry_if_stmt = start_static_initialization_or_destruction (decl,\n+\t\t\t\t\t\t\t       /*initp=*/0);\n+  finish_expr_stmt (build_cleanup (decl));\n+  finish_static_initialization_or_destruction (sentry_if_stmt);\n }\n \n-/* Add code to the static storage duration function that will handle\n-   DECL (a static variable that needs initializing and/or destruction)\n-   with the indicated PRIORITY.  If DECL needs initializing, INIT is\n-   the initializer.  */\n+/* VARS is a list of variables with static storage duration which may\n+   need initialization and/or finalization.  Remove those variables\n+   that don't really need to be initialized or finalized, and return\n+   the resulting list.  The order in which the variables appear in\n+   VARS is in reverse order of the order in which they should actually\n+   be initialized.  The list we return is in the unreversed order;\n+   i.e., the first variable should be initialized first.  */\n \n-static void\n-do_static_initialization_and_destruction (decl, init)\n-     tree decl;\n-     tree init;\n+static tree\n+prune_vars_needing_no_initialization (vars)\n+     tree vars;\n {\n-  tree sentry = NULL_TREE;\n-  int priority;\n-\n-  /* Deal gracefully with error.  */\n-  if (decl == error_mark_node)\n-    return;\n+  tree var;\n+  tree result;\n \n-  /* The only things that can be initialized are variables.  */\n-  my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 19990420);\n+  for (var = vars, result = NULL_TREE;\n+       var;\n+       var = TREE_CHAIN (var))\n+    {\n+      tree decl = TREE_VALUE (var);\n+      tree init = TREE_PURPOSE (var);\n \n-  /* If this object is not defined, we don't need to do anything \n-     here.  */ \n-  if (DECL_EXTERNAL (decl))\n-    return;\n+      /* Deal gracefully with error.  */\n+      if (decl == error_mark_node)\n+\tcontinue;\n \n-  /* Also, if the initializer already contains errors, we can bail out\n-     now.  */\n-  if (init && TREE_CODE (init) == TREE_LIST \n-      && value_member (error_mark_node, init))\n-    return;\n+      /* The only things that can be initialized are variables.  */\n+      my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 19990420);\n \n-  /* Trick the compiler into thinking we are at the file and line\n-     where DECL was declared so that error-messages make sense, and so\n-     that the debugger will show somewhat sensible file and line\n-     information.  */\n-  input_filename = DECL_SOURCE_FILE (decl);\n-  lineno = DECL_SOURCE_LINE (decl);\n+      /* If this object is not defined, we don't need to do anything\n+\t here.  */\n+      if (DECL_EXTERNAL (decl))\n+\tcontinue;\n \n-  /* Because of:\n+      /* Also, if the initializer already contains errors, we can bail\n+\t out now.  */\n+      if (init && TREE_CODE (init) == TREE_LIST \n+\t  && value_member (error_mark_node, init))\n+\tcontinue;\n \n-       [class.access.spec]\n+      /* This variable is going to need initialization and/or\n+\t finalization, so we add it to the list.  */\n+      result = tree_cons (init, decl, result);\n+    }\n \n-       Access control for implicit calls to the constructors,\n-       the conversion functions, or the destructor called to\n-       create and destroy a static data member is performed as\n-       if these calls appeared in the scope of the member's\n-       class.  \n+  return result;\n+}\n \n-     we pretend we are in a static member function of the class of\n-     which the DECL is a member.  */\n-  if (member_p (decl))\n-    {\n-      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n-      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n-    }\n-  \n-  /* We need a sentry if this is an object with external linkage that\n-     might be initialized in more than one place.  */\n-  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n-\t\t\t     || DECL_ONE_ONLY (decl)\n-\t\t\t     || DECL_WEAK (decl)))\n-    sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+/* Make sure we have told the back end about all the variables in\n+   VARS.  */\n \n-  /* Generate the code to actually do the intialization and\n-     destruction.  */\n-  priority = DECL_INIT_PRIORITY (decl);\n-  if (!priority)\n-    priority = DEFAULT_INIT_PRIORITY;\n-  do_static_initialization (decl, init, sentry, priority);\n-  do_static_destruction (decl, sentry, priority);\n+static void\n+write_out_vars (vars)\n+     tree vars;\n+{\n+  tree v;\n \n-  /* Now that we're done with DECL we don't need to pretend to be a\n-     member of its class any longer.  */\n-  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n-  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n+  for (v = vars; v; v = TREE_CHAIN (v))\n+    if (! TREE_ASM_WRITTEN (TREE_VALUE (v)))\n+      rest_of_decl_compilation (TREE_VALUE (v), 0, 1, 1);\n }\n \n /* Generate a static constructor (if CONSTRUCTOR_P) or destructor\n@@ -3480,10 +3425,6 @@ finish_file ()\n \n   do \n     {\n-      /* Non-zero if we need a static storage duration function on\n-\t this iteration through the loop.  */\n-      int need_ssdf_p = 0;\n-\n       reconsider = 0;\n \n       /* If there are templates that we've put off instantiating, do\n@@ -3499,41 +3440,51 @@ finish_file ()\n \treconsider = 1;\n       \n       /* The list of objects with static storage duration is built up\n-\t in reverse order, so we reverse it here.  We also clear\n-\t STATIC_AGGREGATES so that any new aggregates added during the\n-\t initialization of these will be initialized in the correct\n-\t order when we next come around the loop.  */\n-      vars = nreverse (static_aggregates);\n+\t in reverse order.  We clear STATIC_AGGREGATES so that any new\n+\t aggregates added during the initialization of these will be\n+\t initialized in the correct order when we next come around the\n+\t loop.  */\n+      vars = prune_vars_needing_no_initialization (static_aggregates);\n       static_aggregates = NULL_TREE;\n-      while (vars)\n-\t{\n-\t  if (! TREE_ASM_WRITTEN (TREE_VALUE (vars)))\n-\t    rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n-\t  if (!need_ssdf_p)\n-\t    {\n-\t      /* We need to start a new initialization function each\n-\t\t time through the loop.  That's because we need to\n-\t\t know which vtables have been referenced, and\n-\t\t TREE_SYMBOL_REFERENCED isn't computed until a\n-\t\t function is finished, and written out.  That's a\n-\t\t deficiency in the back-end.  When this is fixed,\n-\t\t these initialization functions could all become\n-\t\t inline, with resulting performance improvements.  */\n-\t      start_static_storage_duration_function ();\n-\t      need_ssdf_p = 1;\n-\t    }\n \n-\t  do_static_initialization_and_destruction (TREE_VALUE (vars), \n-\t\t\t\t\t\t    TREE_PURPOSE (vars));\n+      if (vars)\n+\t{\n+\t  tree v;\n+\n+\t  /* We need to start a new initialization function each time\n+\t     through the loop.  That's because we need to know which\n+\t     vtables have been referenced, and TREE_SYMBOL_REFERENCED\n+\t     isn't computed until a function is finished, and written\n+\t     out.  That's a deficiency in the back-end.  When this is\n+\t     fixed, these initialization functions could all become\n+\t     inline, with resulting performance improvements.  */\n+\t  tree ssdf_body = start_static_storage_duration_function ();\n+\n+\t  /* Make sure the back end knows about all the variables.  */\n+\t  write_out_vars (vars);\n+\n+\t  /* First generate code to do all the initializations.  */\n+\t  for (v = vars; v; v = TREE_CHAIN (v))\n+\t    do_static_initialization (TREE_VALUE (v),\n+\t\t\t\t      TREE_PURPOSE (v));\n+\n+\t  /* Then, generate code to do all the destructions.  Do these\n+\t     in reverse order so that the most recently constructed\n+\t     variable is the first destroyed.  */\n+\t  vars = nreverse (vars);\n+\t  for (v = vars; v; v = TREE_CHAIN (v))\n+\t    do_static_destruction (TREE_VALUE (v));\n+\n+\t  /* Finish up the static storage duration function for this\n+\t     round.  */\n+\t  finish_static_storage_duration_function (ssdf_body);\n+\n+\t  /* All those initializations and finalizations might cause\n+\t     us to need more inline functions, more template\n+\t     instantiations, etc.  */\n \t  reconsider = 1;\n-\t  vars = TREE_CHAIN (vars);\n \t}\n       \n-      /* Finish up the static storage duration function for this\n-         round.  */\n-      if (need_ssdf_p)\n-\tfinish_static_storage_duration_function ();\n-\n       /* Go through the various inline functions, and see if any need\n \t synthesizing.  */\n       for (i = 0; i < saved_inlines_used; ++i)"}]}