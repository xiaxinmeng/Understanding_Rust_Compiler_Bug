{"sha": "261efdefd067fbb10979f662f9fe0a3da986d2b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxZWZkZWZkMDY3ZmJiMTA5NzlmNjYyZjlmZTBhM2RhOTg2ZDJiNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-08T15:16:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-08T15:16:40Z"}, "message": "jump.c (jump_optimize_1): Use reversed_comparison_code instead of can_reverse_comparison_p.\n\n\n\t* jump.c (jump_optimize_1): Use reversed_comparison_code\n\tinstead of can_reverse_comparison_p.\n\t(jump_back_p): Likewise.\n\t(invert_exp_1): Likewise.\n\t(thread_jumps): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation): Likewise.\n\t(simplify_ternary_operation): Likewise.\n\t* cse.c (find_comparison_args): Convert to use\n\tcan_reverse_comparison_p.\n\t(record_jump_equiv): Likewise.\n\nFrom-SVN: r38802", "tree": {"sha": "3ffcebd198ac0745cfb083cc4d096b8c14b9273d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ffcebd198ac0745cfb083cc4d096b8c14b9273d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261efdefd067fbb10979f662f9fe0a3da986d2b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261efdefd067fbb10979f662f9fe0a3da986d2b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261efdefd067fbb10979f662f9fe0a3da986d2b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261efdefd067fbb10979f662f9fe0a3da986d2b5/comments", "author": null, "committer": null, "parents": [{"sha": "3febd12318b0cdef645012bbce9cf85e4e4d80ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3febd12318b0cdef645012bbce9cf85e4e4d80ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3febd12318b0cdef645012bbce9cf85e4e4d80ed"}], "stats": {"total": 86, "additions": 58, "deletions": 28}, "files": [{"sha": "721b1c7097f0b3c78950110a8d896af60eec0df8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=261efdefd067fbb10979f662f9fe0a3da986d2b5", "patch": "@@ -1,3 +1,16 @@\n+Mon Jan  8 16:14:56 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* jump.c (jump_optimize_1): Use reversed_comparison_code\n+\tinstead of can_reverse_comparison_p.\n+\t(jump_back_p): Likewise.\n+\t(invert_exp_1): Likewise.\n+\t(thread_jumps): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation): Likewise.\n+\t(simplify_ternary_operation): Likewise.\n+\t* cse.c (find_comparison_args): Convert to use\n+\tcan_reverse_comparison_p.\n+\t(record_jump_equiv): Likewise.\n+\n 2001-01-08  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (HARD_REGNO_RENAME_OK): Delete."}, {"sha": "3d0f1a7658c119d8693c388a3f96734bb2fbde51", "filename": "gcc/cse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=261efdefd067fbb10979f662f9fe0a3da986d2b5", "patch": "@@ -3251,15 +3251,16 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n       /* If we need to reverse the comparison, make sure that that is\n \t possible -- we can't necessarily infer the value of GE from LT\n \t with floating-point operands.  */\n-      if (reverse_code && ! can_reverse_comparison_p (x, NULL_RTX))\n-\tbreak;\n-\n-      arg1 = XEXP (x, 0), arg2 = XEXP (x, 1);\n-      if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n-\tcode = GET_CODE (x);\n-\n       if (reverse_code)\n-\tcode = reverse_condition (code);\n+\t{\n+\t  enum rtx_code reversed = reversed_comparison_code (x, NULL_RTX);\n+\t  if (reversed == UNKNOWN)\n+\t    break;\n+\t  else code = reversed;\n+\t}\n+      else if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n+\tcode = GET_CODE (x);\n+      arg1 = XEXP (x, 0), arg2 = XEXP (x, 1);\n     }\n \n   /* Return our results.  Return the modes from before fold_rtx\n@@ -4446,8 +4447,7 @@ record_jump_equiv (insn, taken)\n   code = find_comparison_args (code, &op0, &op1, &mode0, &mode1);\n   if (! cond_known_true)\n     {\n-      reversed_nonequality = (code != EQ && code != NE);\n-      code = reverse_condition (code);\n+      code = reversed_comparison_code_parts (code, op0, op1, insn);\n \n       /* Don't remember if we can't find the inverse.  */\n       if (code == UNKNOWN)"}, {"sha": "15e41f0266f261ae61ccbbdf1c7f5b847e8f7170", "filename": "gcc/jump.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=261efdefd067fbb10979f662f9fe0a3da986d2b5", "patch": "@@ -207,6 +207,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n   int first = 1;\n   int max_uid = 0;\n   rtx last_insn;\n+  enum rtx_code reversed_code;\n \n   cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n@@ -525,9 +526,10 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t      && prev_active_insn (reallabelprev) == insn\n \t      && no_labels_between_p (insn, reallabelprev)\n \t      && (temp2 = get_condition (insn, &temp4))\n-\t      && can_reverse_comparison_p (temp2, insn))\n+\t      && ((reversed_code = reversed_comparison_code (temp2, insn))\n+\t\t  != UNKNOWN))\n \t    {\n-\t      rtx new = gen_cond_trap (reverse_condition (GET_CODE (temp2)),\n+\t      rtx new = gen_cond_trap (reversed_code,\n \t\t\t\t       XEXP (temp2, 0), XEXP (temp2, 1),\n \t\t\t\t       TRAP_CODE (PATTERN (reallabelprev)));\n \n@@ -1682,16 +1684,16 @@ jump_back_p (insn, target)\n \n   if (XEXP (SET_SRC (set), 1) == pc_rtx)\n     {\n-      if (! can_reverse_comparison_p (cinsn, insn))\n+      codei = reversed_comparison_code (cinsn, insn);\n+      if (codei == UNKNOWN)\n \treturn 0;\n-      codei = reverse_condition (codei);\n     }\n \n   if (XEXP (SET_SRC (tset), 2) == pc_rtx)\n     {\n-      if (! can_reverse_comparison_p (ctarget, target))\n+      codet = reversed_comparison_code (ctarget, target);\n+      if (codei == UNKNOWN)\n \treturn 0;\n-      codet = reverse_condition (codet);\n     }\n \n   return (codei == codet\n@@ -3319,16 +3321,19 @@ invert_exp_1 (insn)\n     {\n       register rtx comp = XEXP (x, 0);\n       register rtx tem;\n+      enum rtx_code reversed_code;\n \n       /* We can do this in two ways:  The preferable way, which can only\n \t be done if this is not an integer comparison, is to reverse\n \t the comparison code.  Otherwise, swap the THEN-part and ELSE-part\n \t of the IF_THEN_ELSE.  If we can't do either, fail.  */\n \n-      if (can_reverse_comparison_p (comp, insn))\n+      reversed_code = reversed_comparison_code (comp, insn);\n+\n+      if (reversed_code != UNKNOWN)\n \t{\n \t  validate_change (insn, &XEXP (x, 0),\n-\t\t\t   gen_rtx_fmt_ee (reverse_condition (GET_CODE (comp)),\n+\t\t\t   gen_rtx_fmt_ee (reversed_code,\n \t\t\t\t\t   GET_MODE (comp), XEXP (comp, 0),\n \t\t\t\t\t   XEXP (comp, 1)),\n \t\t\t   1);\n@@ -3849,6 +3854,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n   int changed = 1;\n   int i;\n   int *all_reset;\n+  enum rtx_code reversed_code1, reversed_code2;\n \n   /* Allocate register tables and quick-reset table.  */\n   modified_regs = (char *) xmalloc (max_reg * sizeof (char));\n@@ -3938,24 +3944,28 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t  b1op0 = XEXP (XEXP (SET_SRC (set), 0), 0);\n \t  b1op1 = XEXP (XEXP (SET_SRC (set), 0), 1);\n \t  code1 = GET_CODE (XEXP (SET_SRC (set), 0));\n+\t  reversed_code1 = code1;\n \t  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n-\t    code1 = reverse_condition (code1);\n+\t    code1 = reversed_comparison_code (XEXP (SET_SRC (set), 0), b1);\n+\t  else\n+\t    reversed_code1 = reversed_comparison_code (XEXP (SET_SRC (set), 0), b1);\n \n \t  b2op0 = XEXP (XEXP (SET_SRC (set2), 0), 0);\n \t  b2op1 = XEXP (XEXP (SET_SRC (set2), 0), 1);\n \t  code2 = GET_CODE (XEXP (SET_SRC (set2), 0));\n+\t  reversed_code2 = code2;\n \t  if (XEXP (SET_SRC (set2), 1) == pc_rtx)\n-\t    code2 = reverse_condition (code2);\n+\t    code2 = reversed_comparison_code (XEXP (SET_SRC (set2), 0), b2);\n+\t  else\n+\t    reversed_code2 = reversed_comparison_code (XEXP (SET_SRC (set2), 0), b2);\n \n \t  /* If they test the same things and knowing that B1 branches\n \t     tells us whether or not B2 branches, check if we\n \t     can thread the branch.  */\n \t  if (rtx_equal_for_thread_p (b1op0, b2op0, b2)\n \t      && rtx_equal_for_thread_p (b1op1, b2op1, b2)\n \t      && (comparison_dominates_p (code1, code2)\n-\t\t  || (can_reverse_comparison_p (XEXP (SET_SRC (set), 0), b1)\n-\t\t      && comparison_dominates_p (code1,\n-\t\t\t\t\t\t reverse_condition (code2)))))\n+\t\t  || comparison_dominates_p (code1, reversed_code2)))\n \n \t    {\n \t      t1 = prev_nonnote_insn (b1);"}, {"sha": "9b0f79876ddee3b6eb621696da044a7a7368e0b6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261efdefd067fbb10979f662f9fe0a3da986d2b5/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=261efdefd067fbb10979f662f9fe0a3da986d2b5", "patch": "@@ -584,6 +584,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n      eggert@twinsun.com says it is safe for IEEE also.  */\n   else\n     {\n+      enum rtx_code reversed;\n       /* There are some simplifications we can do even if the operands\n \t aren't constant.  */\n       switch (code)\n@@ -595,8 +596,9 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n \t  /* (not (eq X Y)) == (ne X Y), etc.  */\n \t  if (mode == BImode && GET_RTX_CLASS (GET_CODE (op)) == '<'\n-\t      && can_reverse_comparison_p (op, NULL_RTX))\n-\t    return gen_rtx_fmt_ee (reverse_condition (GET_CODE (op)),\n+\t      && ((reversed = reversed_comparison_code (op, NULL_RTX))\n+\t\t  != UNKNOWN))\n+\t    return gen_rtx_fmt_ee (reversed,\n \t\t\t\t   op_mode, XEXP (op, 0), XEXP (op, 1));\n \t  break;\n \n@@ -2075,9 +2077,14 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t      \n \t      if (t == STORE_FLAG_VALUE && f == 0)\n \t        code = GET_CODE (op0);\n-\t      else if (t == 0 && f == STORE_FLAG_VALUE\n-\t\t       && can_reverse_comparison_p (op0, NULL_RTX))\n-\t\tcode = reverse_condition (GET_CODE (op0));\n+\t      else if (t == 0 && f == STORE_FLAG_VALUE)\n+\t\t{\n+\t\t  enum rtx_code tmp;\n+\t\t  tmp = reversed_comparison_code (op0, NULL_RTX);\n+\t\t  if (tmp == UNKNOWN)\n+\t\t    break;\n+\t\t  code = tmp;\n+\t\t}\n \t      else\n \t\tbreak;\n "}]}