{"sha": "bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "node_id": "C_kwDOANBUbNoAKGJmYTA0ZDBlYzk1OGViZmYzOGVhOWQyMzQwYTNmNGY4ZTRjMDRhMmQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-11T10:57:26Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-11T14:42:00Z"}, "message": "Move import population from threader to path solver.\n\nImports are our nomenclature for external SSA names to a block that\nare used to calculate the outgoing edges for said block.  For example,\nin the following snippet:\n\n    <bb 2> :\n    _1 = b_10 == block_11;\n    _2 = b_10 != -1;\n    _3 = _1 & _2;\n    if (_3 != 0)\n      goto <bb 3>; [INV]\n    else\n      goto <bb 5>; [INV]\n\n...the imports to the block are b_10 and block_11 since they are both\nneeded to calculate _3.\n\nThe path solver takes a bitmap of imports in addition to the path\nitself.  This sets up the number of SSA names to be on the lookout\nfor, while resolving the final conditional.\n\nCalculating these imports was initially done in the threader, since it\nwas the only user of the path solver.  With new clients, it has become\nobvious that populating the imports should be a task for the path\nsolver, so it can be shared among the clients.\n\nThis patch moves the import code to the solver, making both the solver\nand the threader simpler in the process.  This is because intent is\nclearer and some duplicate code was removed.\n\nThis reshuffling had the net effect of giving us a handful of new\nthreads through my suite of .ii files (125).  This was unexpected, but\nwelcome nevertheless.  There is no performance difference in callgrind\nover the same suite.\n\nRegstrapped on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::add_copies_to_imports):\n\tRename to...\n\t(path_range_query::compute_imports): ...this.  Adapt it so it can\n\tbe passed the imports bitmap instead of working on m_imports.\n\t(path_range_query::compute_ranges): Call compute_imports in all\n\tcases unless an imports bitmap is passed.\n\t* gimple-range-path.h (path_range_query::compute_imports): New.\n\t(path_range_query::add_copies_to_imports): Remove.\n\t* tree-ssa-threadbackward.c (back_threader::resolve_def): Remove.\n\t(back_threader::find_paths_to_names): Inline resolve_def.\n\t(back_threader::find_paths): Call compute_imports.\n\t(back_threader::resolve_phi): Adjust comment.", "tree": {"sha": "39bfee50b549cc94b5df41139295f8ea4a420455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39bfee50b549cc94b5df41139295f8ea4a420455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ea781a8657cdbecffa14b5bce960738087e58f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea781a8657cdbecffa14b5bce960738087e58f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea781a8657cdbecffa14b5bce960738087e58f3"}], "stats": {"total": 94, "additions": 30, "deletions": 64}, "files": [{"sha": "4843c133e62659bcc25ff3c1307d5d9828f3f85d", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "patch": "@@ -439,42 +439,45 @@ path_range_query::add_to_imports (tree name, bitmap imports)\n   return false;\n }\n \n-// Add the copies of any SSA names in IMPORTS to IMPORTS.\n+// Compute the imports to the path ending in EXIT.  These are\n+// essentially the SSA names used to calculate the final conditional\n+// along the path.\n //\n-// These are hints for the solver.  Adding more elements (within\n-// reason) doesn't slow us down, because we don't solve anything that\n-// doesn't appear in the path.  On the other hand, not having enough\n-// imports will limit what we can solve.\n+// They are hints for the solver.  Adding more elements doesn't slow\n+// us down, because we don't solve anything that doesn't appear in the\n+// path.  On the other hand, not having enough imports will limit what\n+// we can solve.\n \n void\n-path_range_query::add_copies_to_imports ()\n+path_range_query::compute_imports (bitmap imports, basic_block exit)\n {\n-  auto_vec<tree> worklist (bitmap_count_bits (m_imports));\n+  // Start with the imports from the exit block...\n+  bitmap r_imports = m_ranger.gori ().imports (exit);\n+  bitmap_copy (imports, r_imports);\n+\n+  auto_vec<tree> worklist (bitmap_count_bits (imports));\n   bitmap_iterator bi;\n   unsigned i;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (imports, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n       worklist.quick_push (name);\n     }\n \n+  // ...and add any operands used to define these imports.\n   while (!worklist.is_empty ())\n     {\n       tree name = worklist.pop ();\n       gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n \n       if (is_gimple_assign (def_stmt))\n \t{\n-\t  // ?? Adding assignment copies doesn't get us much.  At the\n-\t  // time of writing, we got 63 more threaded paths across the\n-\t  // .ii files from a bootstrap.\n-\t  add_to_imports (gimple_assign_rhs1 (def_stmt), m_imports);\n+\t  add_to_imports (gimple_assign_rhs1 (def_stmt), imports);\n \t  tree rhs = gimple_assign_rhs2 (def_stmt);\n-\t  if (rhs && add_to_imports (rhs, m_imports))\n+\t  if (rhs && add_to_imports (rhs, imports))\n \t    worklist.safe_push (rhs);\n \t  rhs = gimple_assign_rhs3 (def_stmt);\n-\t  if (rhs && add_to_imports (rhs, m_imports))\n+\t  if (rhs && add_to_imports (rhs, imports))\n \t    worklist.safe_push (rhs);\n \t}\n       else if (gphi *phi = dyn_cast <gphi *> (def_stmt))\n@@ -486,7 +489,7 @@ path_range_query::add_copies_to_imports ()\n \n \t      if (TREE_CODE (arg) == SSA_NAME\n \t\t  && m_path.contains (e->src)\n-\t\t  && bitmap_set_bit (m_imports, SSA_NAME_VERSION (arg)))\n+\t\t  && bitmap_set_bit (imports, SSA_NAME_VERSION (arg)))\n \t\tworklist.safe_push (arg);\n \t    }\n \t}\n@@ -512,16 +515,10 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n   if (imports)\n     bitmap_copy (m_imports, imports);\n   else\n-    {\n-      bitmap imports = m_ranger.gori ().imports (exit_bb ());\n-      bitmap_copy (m_imports, imports);\n-    }\n+    compute_imports (m_imports, exit_bb ());\n \n   if (m_resolve)\n-    {\n-      add_copies_to_imports ();\n-      get_path_oracle ()->reset_path ();\n-    }\n+    get_path_oracle ()->reset_path ();\n \n   if (DEBUG_SOLVER)\n     {"}, {"sha": "b5a054359adcad1caec0d6a355fd929787628b98", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "patch": "@@ -36,6 +36,7 @@ class path_range_query : public range_query\n   virtual ~path_range_query ();\n   void compute_ranges (const vec<basic_block> &, const bitmap_head *imports = NULL);\n   void compute_ranges (edge e);\n+  void compute_imports (bitmap imports, basic_block exit);\n   bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n   bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n   bool unreachable_path_p ();\n@@ -61,7 +62,6 @@ class path_range_query : public range_query\n   void compute_outgoing_relations (basic_block bb, basic_block next);\n   void compute_phi_relations (basic_block bb, basic_block prev);\n   void maybe_register_phi_relation (gphi *, tree arg);\n-  void add_copies_to_imports ();\n   bool add_to_imports (tree name, bitmap imports);\n   inline bool import_p (tree name);\n "}, {"sha": "d067c470c38fbcfa67c2c738cfc4c3d4b7665520", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=bfa04d0ec958ebff38ea9d2340a3f4f8e4c04a2d", "patch": "@@ -91,7 +91,6 @@ class back_threader\n   edge maybe_register_path ();\n   void maybe_register_path_dump (edge taken_edge);\n   void find_paths_to_names (basic_block bb, bitmap imports);\n-  bool resolve_def (tree name, bitmap interesting, vec<tree> &worklist);\n   void resolve_phi (gphi *phi, bitmap imports);\n   edge find_taken_edge (const vec<basic_block> &path);\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n@@ -363,12 +362,8 @@ back_threader::resolve_phi (gphi *phi, bitmap interesting)\n       edge e = gimple_phi_arg_edge (phi, i);\n \n       // This is like path_crosses_loops in profitable_path_p but more\n-      // restrictive, since profitable_path_p allows threading the\n-      // first block because it would be redirected anyhow.\n-      //\n-      // If we loosened the restriction and used profitable_path_p()\n-      // here instead, we would peel off the first iterations of loops\n-      // in places like tree-ssa/pr14341.c.\n+      // restrictive to avoid peeling off loop iterations (see\n+      // tree-ssa/pr14341.c for an example).\n       bool profitable_p = m_path[0]->loop_father == e->src->loop_father;\n       if (!profitable_p)\n \t{\n@@ -404,33 +399,6 @@ back_threader::resolve_phi (gphi *phi, bitmap interesting)\n     }\n }\n \n-// If the definition of NAME causes the final conditional of the\n-// current path to be constant, register the path, and return TRUE.\n-\n-bool\n-back_threader::resolve_def (tree name, bitmap interesting, vec<tree> &worklist)\n-{\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-\n-  // Handle PHIs.\n-  if (is_a<gphi *> (def_stmt))\n-    {\n-      resolve_phi (as_a<gphi *> (def_stmt), interesting);\n-      return true;\n-    }\n-\n-  // Defer copies of SSAs by adding the source to the worklist.\n-  if (gimple_assign_single_p (def_stmt)\n-      && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n-    {\n-      tree rhs = gimple_assign_rhs1 (def_stmt);\n-      bitmap_set_bit (m_imports, SSA_NAME_VERSION (rhs));\n-      bitmap_set_bit (interesting, SSA_NAME_VERSION (rhs));\n-      worklist.safe_push (rhs);\n-    }\n-  return false;\n-}\n-\n // Find jump threading paths to any of the SSA names in the\n // INTERESTING bitmap, and register any such paths.\n //\n@@ -464,13 +432,15 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting)\n     {\n       tree name = worklist.pop ();\n       unsigned i = SSA_NAME_VERSION (name);\n-      basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+      basic_block def_bb = gimple_bb (def_stmt);\n \n-      // Process any names defined in this block.\n+      // Process any PHIs defined in this block.\n       if (def_bb == bb\n \t  && bitmap_set_bit (processed, i)\n-\t  && resolve_def (name, interesting, worklist))\n+\t  && gimple_code (def_stmt) == GIMPLE_PHI)\n \t{\n+\t  resolve_phi (as_a<gphi *> (def_stmt), interesting);\n \t  done = true;\n \t  break;\n \t}\n@@ -515,10 +485,9 @@ back_threader::find_paths (basic_block bb, tree name)\n       m_visited_bbs.empty ();\n       m_path.truncate (0);\n       m_name = name;\n-      bitmap_clear (m_imports);\n+      m_solver->compute_imports (m_imports, bb);\n \n       auto_bitmap interesting;\n-      bitmap_copy (m_imports, m_ranger->gori ().imports (bb));\n       bitmap_copy (interesting, m_imports);\n       find_paths_to_names (bb, interesting);\n     }"}]}