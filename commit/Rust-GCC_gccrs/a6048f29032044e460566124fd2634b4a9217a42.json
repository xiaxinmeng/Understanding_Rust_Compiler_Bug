{"sha": "a6048f29032044e460566124fd2634b4a9217a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYwNDhmMjkwMzIwNDRlNDYwNTY2MTI0ZmQyNjM0YjRhOTIxN2E0Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-06-27T17:51:08Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-27T17:51:08Z"}, "message": "rope: Trivial formatting fixes.\n\n2004-06-27  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/rope: Trivial formatting fixes.\n\t* include/ext/ropeimpl.h: Likewise.\n\nFrom-SVN: r83737", "tree": {"sha": "75693ee17d2b57451196414072148ebf7d253e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75693ee17d2b57451196414072148ebf7d253e6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6048f29032044e460566124fd2634b4a9217a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6048f29032044e460566124fd2634b4a9217a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6048f29032044e460566124fd2634b4a9217a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6048f29032044e460566124fd2634b4a9217a42/comments", "author": null, "committer": null, "parents": [{"sha": "60cdabab22144d92f227338dea26bcbc81f93dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cdabab22144d92f227338dea26bcbc81f93dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cdabab22144d92f227338dea26bcbc81f93dbc"}], "stats": {"total": 7346, "additions": 3961, "deletions": 3385}, "files": [{"sha": "8343b5eaf5613249835d25b3b141c86d83eac301", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a6048f29032044e460566124fd2634b4a9217a42", "patch": "@@ -1,3 +1,8 @@\n+2004-06-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/rope: Trivial formatting fixes.\n+\t* include/ext/ropeimpl.h: Likewise.\n+\n 2004-06-26  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/16210"}, {"sha": "8cfcde9534ee0eaf295e854f2862e2e157fadb54", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 2540, "deletions": 2132, "changes": 4672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=a6048f29032044e460566124fd2634b4a9217a42"}, {"sha": "e9f927164c6bf52f44bdc8bd16d2aa66b8fa1b0b", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 1416, "deletions": 1253, "changes": 2669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6048f29032044e460566124fd2634b4a9217a42/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=a6048f29032044e460566124fd2634b4a9217a42", "patch": "@@ -62,1474 +62,1637 @@ namespace __gnu_cxx\n   using std::_Destroy;\n   using std::uninitialized_fill_n;\n \n-// Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n-// if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.\n-// Results in a valid buf_ptr if the iterator can be legitimately\n-// dereferenced.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(\n-  _Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];\n-    size_t __leaf_pos = __x._M_leaf_pos;\n-    size_t __pos = __x._M_current_pos;\n+  // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n+  // if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.\n+  // Results in a valid buf_ptr if the iterator can be legitimately\n+  // dereferenced.\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator_base<_CharT, _Alloc>::\n+    _S_setbuf(_Rope_iterator_base<_CharT, _Alloc>& __x)\n+    {\n+      const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];\n+      size_t __leaf_pos = __x._M_leaf_pos;\n+      size_t __pos = __x._M_current_pos;\n \n-    switch(__leaf->_M_tag) {\n+      switch(__leaf->_M_tag)\n+\t{\n \tcase _Rope_constants::_S_leaf:\n-\t    __x._M_buf_start =\n-\t      ((_Rope_RopeLeaf<_CharT,_Alloc>*)__leaf)->_M_data;\n-\t    __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n-\t    __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n-\t    break;\n+\t  __x._M_buf_start = ((_Rope_RopeLeaf<_CharT, _Alloc>*)__leaf)->_M_data;\n+\t  __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n+\t  __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n+\t  break;\n \tcase _Rope_constants::_S_function:\n \tcase _Rope_constants::_S_substringfn:\n-\t    {\n-\t\tsize_t __len = _S_iterator_buf_len;\n-\t\tsize_t __buf_start_pos = __leaf_pos;\n-\t\tsize_t __leaf_end = __leaf_pos + __leaf->_M_size;\n-\t\tchar_producer<_CharT>* __fn =\n-\t\t\t((_Rope_RopeFunction<_CharT,_Alloc>*)__leaf)->_M_fn;\n-\n-\t\tif (__buf_start_pos + __len <= __pos) {\n-\t\t    __buf_start_pos = __pos - __len/4;\n-\t\t    if (__buf_start_pos + __len > __leaf_end) {\n-\t\t\t__buf_start_pos = __leaf_end - __len;\n-\t\t    }\n-\t\t}\n-\t\tif (__buf_start_pos + __len > __leaf_end) {\n-\t\t    __len = __leaf_end - __buf_start_pos;\n-\t\t}\n-\t\t(*__fn)(__buf_start_pos - __leaf_pos, __len, __x._M_tmp_buf);\n-\t\t__x._M_buf_ptr = __x._M_tmp_buf + (__pos - __buf_start_pos);\n-\t\t__x._M_buf_start = __x._M_tmp_buf;\n-\t\t__x._M_buf_end = __x._M_tmp_buf + __len;\n-\t    }\n-\t    break;\n+\t  {\n+\t    size_t __len = _S_iterator_buf_len;\n+\t    size_t __buf_start_pos = __leaf_pos;\n+\t    size_t __leaf_end = __leaf_pos + __leaf->_M_size;\n+\t    char_producer<_CharT>* __fn = ((_Rope_RopeFunction<_CharT,\n+\t\t\t\t\t    _Alloc>*)__leaf)->_M_fn;\n+\t    if (__buf_start_pos + __len <= __pos)\n+\t      {\n+\t\t__buf_start_pos = __pos - __len / 4;\n+\t\tif (__buf_start_pos + __len > __leaf_end)\n+\t\t  __buf_start_pos = __leaf_end - __len;\n+\t      }\n+\t    if (__buf_start_pos + __len > __leaf_end)\n+\t      __len = __leaf_end - __buf_start_pos;\n+\t    (*__fn)(__buf_start_pos - __leaf_pos, __len, __x._M_tmp_buf);\n+\t    __x._M_buf_ptr = __x._M_tmp_buf + (__pos - __buf_start_pos);\n+\t    __x._M_buf_start = __x._M_tmp_buf;\n+\t    __x._M_buf_end = __x._M_tmp_buf + __len;\n+\t  }\n+\t  break;\n \tdefault:\n \t  break;\n+\t}\n     }\n-}\n \n-// Set path and buffer inside a rope iterator.  We assume that\n-// pos and root are already set.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n-(_Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    const _RopeRep* __path[_Rope_constants::_S_max_rope_depth + 1];\n-    const _RopeRep* __curr_rope;\n-    int __curr_depth = -1;  /* index into path    */\n-    size_t __curr_start_pos = 0;\n-    size_t __pos = __x._M_current_pos;\n-    unsigned char __dirns = 0; // Bit vector marking right turns in the path\n-\n-    if (__pos >= __x._M_root->_M_size) {\n-\t__x._M_buf_ptr = 0;\n-\treturn;\n-    }\n-    __curr_rope = __x._M_root;\n-    if (0 != __curr_rope->_M_c_string) {\n-\t/* Treat the root as a leaf. */\n-\t__x._M_buf_start = __curr_rope->_M_c_string;\n-\t__x._M_buf_end = __curr_rope->_M_c_string + __curr_rope->_M_size;\n-\t__x._M_buf_ptr = __curr_rope->_M_c_string + __pos;\n-\t__x._M_path_end[0] = __curr_rope;\n-\t__x._M_leaf_index = 0;\n-\t__x._M_leaf_pos = 0;\n-\treturn;\n-    }\n-    for(;;) {\n-\t++__curr_depth;\n-\t__path[__curr_depth] = __curr_rope;\n-\tswitch(__curr_rope->_M_tag) {\n-\t  case _Rope_constants::_S_leaf:\n-\t  case _Rope_constants::_S_function:\n-\t  case _Rope_constants::_S_substringfn:\n-\t    __x._M_leaf_pos = __curr_start_pos;\n-\t    goto done;\n-\t  case _Rope_constants::_S_concat:\n+  // Set path and buffer inside a rope iterator.  We assume that\n+  // pos and root are already set.\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator_base<_CharT, _Alloc>::\n+    _S_setcache(_Rope_iterator_base<_CharT, _Alloc>& __x)\n+    {\n+      const _RopeRep* __path[_Rope_constants::_S_max_rope_depth + 1];\n+      const _RopeRep* __curr_rope;\n+      int __curr_depth = -1;  /* index into path    */\n+      size_t __curr_start_pos = 0;\n+      size_t __pos = __x._M_current_pos;\n+      unsigned char __dirns = 0; // Bit vector marking right turns in the path\n+\n+      if (__pos >= __x._M_root->_M_size)\n+\t{\n+\t  __x._M_buf_ptr = 0;\n+\t  return;\n+\t}\n+      __curr_rope = __x._M_root;\n+      if (0 != __curr_rope->_M_c_string)\n+\t{\n+\t  /* Treat the root as a leaf. */\n+\t  __x._M_buf_start = __curr_rope->_M_c_string;\n+\t  __x._M_buf_end = __curr_rope->_M_c_string + __curr_rope->_M_size;\n+\t  __x._M_buf_ptr = __curr_rope->_M_c_string + __pos;\n+\t  __x._M_path_end[0] = __curr_rope;\n+\t  __x._M_leaf_index = 0;\n+\t  __x._M_leaf_pos = 0;\n+\t  return;\n+\t}\n+      for(;;)\n+\t{\n+\t  ++__curr_depth;\n+\t  __path[__curr_depth] = __curr_rope;\n+\t  switch(__curr_rope->_M_tag)\n \t    {\n-\t\t_Rope_RopeConcatenation<_CharT,_Alloc>* __c =\n-\t\t\t(_Rope_RopeConcatenation<_CharT,_Alloc>*)__curr_rope;\n+\t    case _Rope_constants::_S_leaf:\n+\t    case _Rope_constants::_S_function:\n+\t    case _Rope_constants::_S_substringfn:\n+\t      __x._M_leaf_pos = __curr_start_pos;\n+\t      goto done;\n+\t    case _Rope_constants::_S_concat:\n+\t      {\n+\t\t_Rope_RopeConcatenation<_CharT, _Alloc>* __c =\n+\t\t  (_Rope_RopeConcatenation<_CharT, _Alloc>*)__curr_rope;\n \t\t_RopeRep* __left = __c->_M_left;\n \t\tsize_t __left_len = __left->_M_size;\n \n \t\t__dirns <<= 1;\n-\t\tif (__pos >= __curr_start_pos + __left_len) {\n+\t\tif (__pos >= __curr_start_pos + __left_len)\n+\t\t  {\n \t\t    __dirns |= 1;\n \t\t    __curr_rope = __c->_M_right;\n \t\t    __curr_start_pos += __left_len;\n-\t\t} else {\n-\t\t    __curr_rope = __left;\n-\t\t}\n+\t\t  }\n+\t\telse\n+\t\t  __curr_rope = __left;\n+\t      }\n+\t      break;\n \t    }\n-\t    break;\n \t}\n-    }\n-  done:\n-    // Copy last section of path into _M_path_end.\n+    done:\n+      // Copy last section of path into _M_path_end.\n       {\n \tint __i = -1;\n \tint __j = __curr_depth + 1 - _S_path_cache_len;\n \n \tif (__j < 0) __j = 0;\n-\twhile (__j <= __curr_depth) {\n-\t    __x._M_path_end[++__i] = __path[__j++];\n-\t}\n+\twhile (__j <= __curr_depth)\n+\t  __x._M_path_end[++__i] = __path[__j++];\n \t__x._M_leaf_index = __i;\n       }\n       __x._M_path_directions = __dirns;\n       _S_setbuf(__x);\n-}\n-\n-// Specialized version of the above.  Assumes that\n-// the path cache is valid for the previous position.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr\n-(_Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    int __current_index = __x._M_leaf_index;\n-    const _RopeRep* __current_node = __x._M_path_end[__current_index];\n-    size_t __len = __current_node->_M_size;\n-    size_t __node_start_pos = __x._M_leaf_pos;\n-    unsigned char __dirns = __x._M_path_directions;\n-    _Rope_RopeConcatenation<_CharT,_Alloc>* __c;\n-\n-    if (__x._M_current_pos - __node_start_pos < __len) {\n-\t/* More stuff in this leaf, we just didn't cache it. */\n-\t_S_setbuf(__x);\n-\treturn;\n-    }\n-    //  node_start_pos is starting position of last_node.\n-    while (--__current_index >= 0) {\n-\tif (!(__dirns & 1) /* Path turned left */)\n-\t  break;\n-\t__current_node = __x._M_path_end[__current_index];\n-\t__c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n-\t// Otherwise we were in the right child.  Thus we should pop\n-\t// the concatenation node.\n-\t__node_start_pos -= __c->_M_left->_M_size;\n-\t__dirns >>= 1;\n-    }\n-    if (__current_index < 0) {\n-\t// We underflowed the cache. Punt.\n-\t_S_setcache(__x);\n-\treturn;\n     }\n-    __current_node = __x._M_path_end[__current_index];\n-    __c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n-    // current_node is a concatenation node.  We are positioned on the first\n-    // character in its right child.\n-    // node_start_pos is starting position of current_node.\n-    __node_start_pos += __c->_M_left->_M_size;\n-    __current_node = __c->_M_right;\n-    __x._M_path_end[++__current_index] = __current_node;\n-    __dirns |= 1;\n-    while (_Rope_constants::_S_concat == __current_node->_M_tag) {\n-\t++__current_index;\n-\tif (_S_path_cache_len == __current_index) {\n-\t    int __i;\n-\t    for (__i = 0; __i < _S_path_cache_len-1; __i++) {\n+\n+  // Specialized version of the above.  Assumes that\n+  // the path cache is valid for the previous position.\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator_base<_CharT, _Alloc>::\n+    _S_setcache_for_incr(_Rope_iterator_base<_CharT, _Alloc>& __x)\n+    {\n+      int __current_index = __x._M_leaf_index;\n+      const _RopeRep* __current_node = __x._M_path_end[__current_index];\n+      size_t __len = __current_node->_M_size;\n+      size_t __node_start_pos = __x._M_leaf_pos;\n+      unsigned char __dirns = __x._M_path_directions;\n+      _Rope_RopeConcatenation<_CharT, _Alloc>* __c;\n+\n+      if (__x._M_current_pos - __node_start_pos < __len)\n+\t{\n+\t  /* More stuff in this leaf, we just didn't cache it. */\n+\t  _S_setbuf(__x);\n+\t  return;\n+\t}\n+      //  node_start_pos is starting position of last_node.\n+      while (--__current_index >= 0)\n+\t{\n+\t  if (!(__dirns & 1) /* Path turned left */)\n+\t    break;\n+\t  __current_node = __x._M_path_end[__current_index];\n+\t  __c = (_Rope_RopeConcatenation<_CharT, _Alloc>*)__current_node;\n+\t  // Otherwise we were in the right child.  Thus we should pop\n+\t  // the concatenation node.\n+\t  __node_start_pos -= __c->_M_left->_M_size;\n+\t  __dirns >>= 1;\n+\t}\n+      if (__current_index < 0)\n+\t{\n+\t  // We underflowed the cache. Punt.\n+\t  _S_setcache(__x);\n+\t  return;\n+\t}\n+      __current_node = __x._M_path_end[__current_index];\n+      __c = (_Rope_RopeConcatenation<_CharT, _Alloc>*)__current_node;\n+      // current_node is a concatenation node.  We are positioned on the first\n+      // character in its right child.\n+      // node_start_pos is starting position of current_node.\n+      __node_start_pos += __c->_M_left->_M_size;\n+      __current_node = __c->_M_right;\n+      __x._M_path_end[++__current_index] = __current_node;\n+      __dirns |= 1;\n+      while (_Rope_constants::_S_concat == __current_node->_M_tag)\n+\t{\n+\t  ++__current_index;\n+\t  if (_S_path_cache_len == __current_index)\n+\t    {\n+\t      int __i;\n+\t      for (__i = 0; __i < _S_path_cache_len-1; __i++)\n \t\t__x._M_path_end[__i] = __x._M_path_end[__i+1];\n+\t      --__current_index;\n \t    }\n-\t    --__current_index;\n+\t  __current_node =\n+\t    ((_Rope_RopeConcatenation<_CharT, _Alloc>*)__current_node)->_M_left;\n+\t  __x._M_path_end[__current_index] = __current_node;\n+\t  __dirns <<= 1;\n+\t  // node_start_pos is unchanged.\n \t}\n-\t__current_node =\n-\t    ((_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node)->_M_left;\n-\t__x._M_path_end[__current_index] = __current_node;\n-\t__dirns <<= 1;\n-\t// node_start_pos is unchanged.\n-    }\n-    __x._M_leaf_index = __current_index;\n-    __x._M_leaf_pos = __node_start_pos;\n-    __x._M_path_directions = __dirns;\n-    _S_setbuf(__x);\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_M_incr(size_t __n) {\n-    _M_current_pos += __n;\n-    if (0 != _M_buf_ptr) {\n-        size_t __chars_left = _M_buf_end - _M_buf_ptr;\n-        if (__chars_left > __n) {\n-            _M_buf_ptr += __n;\n-        } else if (__chars_left == __n) {\n-            _M_buf_ptr += __n;\n-            _S_setcache_for_incr(*this);\n-        } else {\n-            _M_buf_ptr = 0;\n-        }\n+      __x._M_leaf_index = __current_index;\n+      __x._M_leaf_pos = __node_start_pos;\n+      __x._M_path_directions = __dirns;\n+      _S_setbuf(__x);\n     }\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_M_decr(size_t __n) {\n-    if (0 != _M_buf_ptr) {\n-        size_t __chars_left = _M_buf_ptr - _M_buf_start;\n-        if (__chars_left >= __n) {\n-            _M_buf_ptr -= __n;\n-        } else {\n-            _M_buf_ptr = 0;\n-        }\n+\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator_base<_CharT, _Alloc>::\n+    _M_incr(size_t __n)\n+    {\n+      _M_current_pos += __n;\n+      if (0 != _M_buf_ptr)\n+\t{\n+\t  size_t __chars_left = _M_buf_end - _M_buf_ptr;\n+\t  if (__chars_left > __n)\n+\t    _M_buf_ptr += __n;\n+\t  else if (__chars_left == __n)\n+\t    {\n+\t      _M_buf_ptr += __n;\n+\t      _S_setcache_for_incr(*this);\n+\t    }\n+\t  else\n+\t    _M_buf_ptr = 0;\n+\t}\n     }\n-    _M_current_pos -= __n;\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator<_CharT,_Alloc>::_M_check() {\n-    if (_M_root_rope->_M_tree_ptr != this->_M_root) {\n-        // _Rope was modified.  Get things fixed up.\n-        _RopeRep::_S_unref(this->_M_root);\n-        this->_M_root = _M_root_rope->_M_tree_ptr;\n-        _RopeRep::_S_ref(this->_M_root);\n-        this->_M_buf_ptr = 0;\n+\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator_base<_CharT, _Alloc>::\n+    _M_decr(size_t __n)\n+    {\n+      if (0 != _M_buf_ptr)\n+\t{\n+\t  size_t __chars_left = _M_buf_ptr - _M_buf_start;\n+\t  if (__chars_left >= __n)\n+\t    _M_buf_ptr -= __n;\n+\t  else\n+\t    _M_buf_ptr = 0;\n+\t}\n+      _M_current_pos -= __n;\n     }\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline\n-_Rope_const_iterator<_CharT, _Alloc>::_Rope_const_iterator(\n-  const _Rope_iterator<_CharT,_Alloc>& __x)\n-: _Rope_iterator_base<_CharT,_Alloc>(__x)\n-{ }\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_iterator<_CharT,_Alloc>::_Rope_iterator(\n-  rope<_CharT,_Alloc>& __r, size_t __pos)\n-: _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos),\n-  _M_root_rope(&__r)\n-{\n-    _RopeRep::_S_ref(this->_M_root);\n-}\n \n-template <class _CharT, class _Alloc>\n-inline size_t\n-rope<_CharT,_Alloc>::_S_char_ptr_len(const _CharT* __s)\n-{\n-    const _CharT* __p = __s;\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_iterator<_CharT, _Alloc>::\n+    _M_check()\n+    {\n+      if (_M_root_rope->_M_tree_ptr != this->_M_root)\n+\t{\n+\t  // _Rope was modified.  Get things fixed up.\n+\t  _RopeRep::_S_unref(this->_M_root);\n+\t  this->_M_root = _M_root_rope->_M_tree_ptr;\n+\t  _RopeRep::_S_ref(this->_M_root);\n+\t  this->_M_buf_ptr = 0;\n+\t}\n+    }\n \n-    while (!_S_is0(*__p)) { ++__p; }\n-    return (__p - __s);\n-}\n+  template <class _CharT, class _Alloc>\n+    inline\n+    _Rope_const_iterator<_CharT, _Alloc>::\n+    _Rope_const_iterator(const _Rope_iterator<_CharT, _Alloc>& __x)\n+    : _Rope_iterator_base<_CharT, _Alloc>(__x)\n+    { }\n+\n+  template <class _CharT, class _Alloc>\n+    inline\n+    _Rope_iterator<_CharT, _Alloc>::\n+    _Rope_iterator(rope<_CharT, _Alloc>& __r, size_t __pos)\n+    : _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos),\n+      _M_root_rope(&__r)\n+    { _RopeRep::_S_ref(this->_M_root); }\n+\n+  template <class _CharT, class _Alloc>\n+    inline size_t\n+    rope<_CharT, _Alloc>::\n+    _S_char_ptr_len(const _CharT* __s)\n+    {\n+      const _CharT* __p = __s;\n+      \n+      while (!_S_is0(*__p))\n+\t++__p;\n+      return (__p - __s);\n+    }\n \n \n #ifndef __GC\n \n-template <class _CharT, class _Alloc>\n-inline void _Rope_RopeRep<_CharT,_Alloc>::_M_free_c_string()\n-{\n-    _CharT* __cstr = _M_c_string;\n-    if (0 != __cstr) {\n-\tsize_t __size = this->_M_size + 1;\n-\t_Destroy(__cstr, __cstr + __size);\n-\tthis->_Data_deallocate(__cstr, __size);\n+  template <class _CharT, class _Alloc>\n+    inline void\n+    _Rope_RopeRep<_CharT, _Alloc>::\n+    _M_free_c_string()\n+    {\n+      _CharT* __cstr = _M_c_string;\n+      if (0 != __cstr)\n+\t{\n+\t  size_t __size = this->_M_size + 1;\n+\t  _Destroy(__cstr, __cstr + __size);\n+\t  this->_Data_deallocate(__cstr, __size);\n+\t}\n     }\n-}\n-\n \n-template <class _CharT, class _Alloc>\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n-\t\t\t\t\t\t\t   size_t __n,\n-\t\t\t\t\t\t           allocator_type __a)\n-{\n-    if (!_S_is_basic_char_type((_CharT*)0)) {\n+  template <class _CharT, class _Alloc>\n+    inline void\n+    _Rope_RopeRep<_CharT, _Alloc>::\n+    _S_free_string(_CharT* __s, size_t __n, allocator_type __a)\n+    {\n+      if (!_S_is_basic_char_type((_CharT*)0))\n \t_Destroy(__s, __s + __n);\n+      \n+      //  This has to be a static member, so this gets a bit messy\n+      __a.deallocate(__s,\n+\t\t     _Rope_RopeLeaf<_CharT, _Alloc>::_S_rounded_up_size(__n));\n     }\n-//  This has to be a static member, so this gets a bit messy\n-        __a.deallocate(\n-\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n-}\n-\n-\n-//  There are several reasons for not doing this with virtual destructors\n-//  and a class specific delete operator:\n-//  - A class specific delete operator can't easily get access to\n-//    allocator instances if we need them.\n-//  - Any virtual function would need a 4 or byte vtable pointer;\n-//    this only requires a one byte tag per object.\n-template <class _CharT, class _Alloc>\n-void _Rope_RopeRep<_CharT,_Alloc>::_M_free_tree()\n-{\n-    switch(_M_tag) {\n+\n+  //  There are several reasons for not doing this with virtual destructors\n+  //  and a class specific delete operator:\n+  //  - A class specific delete operator can't easily get access to\n+  //    allocator instances if we need them.\n+  //  - Any virtual function would need a 4 or byte vtable pointer;\n+  //    this only requires a one byte tag per object.\n+  template <class _CharT, class _Alloc>\n+    void\n+    _Rope_RopeRep<_CharT, _Alloc>::\n+    _M_free_tree()\n+    {\n+      switch(_M_tag)\n+\t{\n \tcase _Rope_constants::_S_leaf:\n-\t    {\n-\t        _Rope_RopeLeaf<_CharT,_Alloc>* __l\n-\t\t\t= (_Rope_RopeLeaf<_CharT,_Alloc>*)this;\n-\t        __l->_Rope_RopeLeaf<_CharT,_Alloc>::~_Rope_RopeLeaf();\n-\t        _L_deallocate(__l, 1);\n-\t        break;\n-\t    }\n+\t  {\n+\t    _Rope_RopeLeaf<_CharT, _Alloc>* __l\n+\t      = (_Rope_RopeLeaf<_CharT, _Alloc>*)this;\n+\t    __l->_Rope_RopeLeaf<_CharT, _Alloc>::~_Rope_RopeLeaf();\n+\t    _L_deallocate(__l, 1);\n+\t    break;\n+\t  }\n \tcase _Rope_constants::_S_concat:\n-\t    {\n-\t        _Rope_RopeConcatenation<_CharT,_Alloc>* __c\n-\t\t    = (_Rope_RopeConcatenation<_CharT,_Alloc>*)this;\n-\t        __c->_Rope_RopeConcatenation<_CharT,_Alloc>::\n-\t\t       ~_Rope_RopeConcatenation();\n-\t        _C_deallocate(__c, 1);\n-\t        break;\n-\t    }\n+\t  {\n+\t    _Rope_RopeConcatenation<_CharT,_Alloc>* __c\n+\t      = (_Rope_RopeConcatenation<_CharT, _Alloc>*)this;\n+\t    __c->_Rope_RopeConcatenation<_CharT, _Alloc>::\n+\t      ~_Rope_RopeConcatenation();\n+\t    _C_deallocate(__c, 1);\n+\t    break;\n+\t  }\n \tcase _Rope_constants::_S_function:\n-\t    {\n-\t        _Rope_RopeFunction<_CharT,_Alloc>* __f\n-\t\t    = (_Rope_RopeFunction<_CharT,_Alloc>*)this;\n-\t        __f->_Rope_RopeFunction<_CharT,_Alloc>::~_Rope_RopeFunction();\n-\t        _F_deallocate(__f, 1);\n-\t        break;\n-\t    }\n+\t  {\n+\t    _Rope_RopeFunction<_CharT, _Alloc>* __f\n+\t      = (_Rope_RopeFunction<_CharT, _Alloc>*)this;\n+\t    __f->_Rope_RopeFunction<_CharT, _Alloc>::~_Rope_RopeFunction();\n+\t    _F_deallocate(__f, 1);\n+\t    break;\n+\t  }\n \tcase _Rope_constants::_S_substringfn:\n-\t    {\n-\t        _Rope_RopeSubstring<_CharT,_Alloc>* __ss =\n-\t\t\t(_Rope_RopeSubstring<_CharT,_Alloc>*)this;\n-\t\t__ss->_Rope_RopeSubstring<_CharT,_Alloc>::\n-\t\t        ~_Rope_RopeSubstring();\n-\t\t_S_deallocate(__ss, 1);\n-\t\tbreak;\n-\t    }\n+\t  {\n+\t    _Rope_RopeSubstring<_CharT, _Alloc>* __ss =\n+\t      (_Rope_RopeSubstring<_CharT, _Alloc>*)this;\n+\t    __ss->_Rope_RopeSubstring<_CharT, _Alloc>::\n+\t      ~_Rope_RopeSubstring();\n+\t    _S_deallocate(__ss, 1);\n+\t    break;\n+\t  }\n+\t}\n     }\n-}\n #else\n \n-template <class _CharT, class _Alloc>\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n-\t\t(const _CharT*, size_t, allocator_type)\n-{}\n+  template <class _CharT, class _Alloc>\n+    inline void\n+    _Rope_RopeRep<_CharT, _Alloc>::\n+    _S_free_string(const _CharT*, size_t, allocator_type)\n+    { }\n \n #endif\n \n-\n-// Concatenate a C string onto a leaf rope by copying the rope data.\n-// Used for short ropes.\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeLeaf*\n-rope<_CharT,_Alloc>::_S_leaf_concat_char_iter\n-\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n-{\n-    size_t __old_len = __r->_M_size;\n-    _CharT* __new_data = (_CharT*)\n-      _Data_allocate(_S_rounded_up_size(__old_len + __len));\n-    _RopeLeaf* __result;\n-\n-    uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n-    uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n-    _S_cond_store_eos(__new_data[__old_len + __len]);\n-    try {\n-\t__result = _S_new_RopeLeaf(__new_data, __old_len + __len,\n-\t\t\t\t   __r->get_allocator());\n+  // Concatenate a C string onto a leaf rope by copying the rope data.\n+  // Used for short ropes.\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeLeaf*\n+    rope<_CharT, _Alloc>::\n+    _S_leaf_concat_char_iter(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n+    {\n+      size_t __old_len = __r->_M_size;\n+      _CharT* __new_data = (_CharT*)\n+\t_Data_allocate(_S_rounded_up_size(__old_len + __len));\n+      _RopeLeaf* __result;\n+\n+      uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n+      uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n+      _S_cond_store_eos(__new_data[__old_len + __len]);\n+      try\n+\t{\n+\t  __result = _S_new_RopeLeaf(__new_data, __old_len + __len,\n+\t\t\t\t     __r->get_allocator());\n+\t}\n+      catch(...)\n+\t{\n+\t  _RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n+\t\t\t\t      __r->get_allocator());\n+\t  __throw_exception_again;\n+\t}\n+      return __result;\n     }\n-    catch(...)\n-      {\n-\t_RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n-\t\t\t\t    __r->get_allocator());\n-\t__throw_exception_again;\n-      }\n-    return __result;\n-}\n \n #ifndef __GC\n-// As above, but it's OK to clobber original if refcount is 1\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeLeaf*\n-rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter\n-\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n-{\n-    if (__r->_M_ref_count > 1)\n-      return _S_leaf_concat_char_iter(__r, __iter, __len);\n-    size_t __old_len = __r->_M_size;\n-    if (_S_allocated_capacity(__old_len) >= __old_len + __len) {\n-\t// The space has been partially initialized for the standard\n-\t// character types.  But that doesn't matter for those types.\n-\tuninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);\n-\tif (_S_is_basic_char_type((_CharT*)0)) {\n+  // As above, but it's OK to clobber original if refcount is 1\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT,_Alloc>::_RopeLeaf*\n+    rope<_CharT, _Alloc>::\n+    _S_destr_leaf_concat_char_iter(_RopeLeaf* __r, const _CharT* __iter,\n+\t\t\t\t   size_t __len)\n+    {\n+      if (__r->_M_ref_count > 1)\n+\treturn _S_leaf_concat_char_iter(__r, __iter, __len);\n+      size_t __old_len = __r->_M_size;\n+      if (_S_allocated_capacity(__old_len) >= __old_len + __len)\n+\t{\n+\t  // The space has been partially initialized for the standard\n+\t  // character types.  But that doesn't matter for those types.\n+\t  uninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);\n+\t  if (_S_is_basic_char_type((_CharT*)0))\n \t    _S_cond_store_eos(__r->_M_data[__old_len + __len]);\n-\t} else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string) {\n-\t    __r->_M_free_c_string();\n-\t    __r->_M_c_string = 0;\n+\t  else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string)\n+\t    {\n+\t      __r->_M_free_c_string();\n+\t      __r->_M_c_string = 0;\n+\t    }\n+\t  __r->_M_size = __old_len + __len;\n+\t  __r->_M_ref_count = 2;\n+\t  return __r;\n+\t}\n+      else\n+\t{\n+\t  _RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);\n+\t  return __result;\n \t}\n-\t__r->_M_size = __old_len + __len;\n-\t__r->_M_ref_count = 2;\n-\treturn __r;\n-    } else {\n-\t_RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);\n-\treturn __result;\n     }\n-}\n #endif\n \n-// Assumes left and right are not 0.\n-// Does not increment (nor decrement on exception) child reference counts.\n-// Result has ref count 1.\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n-{\n-  _RopeConcatenation* __result = _S_new_RopeConcatenation(__left, __right,\n-\t\t\t\t\t\t      __left->get_allocator());\n-  size_t __depth = __result->_M_depth;\n-\n-  if (__depth > 20 && (__result->_M_size < 1000 ||\n-\t\t       __depth > _Rope_constants::_S_max_rope_depth))\n+  // Assumes left and right are not 0.\n+  // Does not increment (nor decrement on exception) child reference counts.\n+  // Result has ref count 1.\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeRep*\n+    rope<_CharT, _Alloc>::\n+    _S_tree_concat(_RopeRep* __left, _RopeRep* __right)\n     {\n-      _RopeRep* __balanced;\n+      _RopeConcatenation* __result = _S_new_RopeConcatenation(__left, __right,\n+\t\t\t\t\t\t\t      __left->\n+\t\t\t\t\t\t\t      get_allocator());\n+      size_t __depth = __result->_M_depth;\n+      \n+      if (__depth > 20 && (__result->_M_size < 1000\n+\t\t\t   || __depth > _Rope_constants::_S_max_rope_depth))\n+\t{\n+\t  _RopeRep* __balanced;\n+\n+\t  try\n+\t    {\n+\t      __balanced = _S_balance(__result);\n+\t      __result->_M_unref_nonnil();\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      _C_deallocate(__result,1);\n+\t      __throw_exception_again;\n+\t    }\n+\t  // In case of exception, we need to deallocate\n+\t  // otherwise dangling result node.  But caller\n+\t  // still owns its children.  Thus unref is\n+\t  // inappropriate.\n+\t  return __balanced;\n+\t}\n+      else\n+\treturn __result;\n+    }\n \n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeRep*\n+    rope<_CharT, _Alloc>::\n+    _S_concat_char_iter(_RopeRep* __r, const _CharT*__s, size_t __slen)\n+    {\n+      _RopeRep* __result;\n+      if (0 == __slen)\n+\t{\n+\t  _S_ref(__r);\n+\t  return __r;\n+\t}\n+      if (0 == __r)\n+\treturn __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n+\t\t\t\t\t\t__r->get_allocator());\n+      if (_Rope_constants::_S_leaf == __r->_M_tag\n+\t  && __r->_M_size + __slen <= _S_copy_max)\n+\t{\n+\t  __result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n+\t  return __result;\n+\t}\n+      if (_Rope_constants::_S_concat == __r->_M_tag\n+\t  && _Rope_constants::_S_leaf == ((_RopeConcatenation*)\n+\t\t\t\t\t  __r)->_M_right->_M_tag)\n+\t{\n+\t  _RopeLeaf* __right =\n+\t    (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n+\t  if (__right->_M_size + __slen <= _S_copy_max)\n+\t    {\n+\t      _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;\n+\t      _RopeRep* __nright =\n+\t\t_S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n+\t      __left->_M_ref_nonnil();\n+\t      try\n+\t\t{ __result = _S_tree_concat(__left, __nright); }\n+\t      catch(...)\n+\t\t{\n+\t\t  _S_unref(__left);\n+\t\t  _S_unref(__nright);\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t      return __result;\n+\t    }\n+\t}\n+      _RopeRep* __nright =\n+\t__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n       try\n \t{\n-\t  __balanced = _S_balance(__result);\n-\t  __result->_M_unref_nonnil();\n-        }\n+\t  __r->_M_ref_nonnil();\n+\t  __result = _S_tree_concat(__r, __nright);\n+\t}\n       catch(...)\n \t{\n-\t  _C_deallocate(__result,1);\n+\t  _S_unref(__r);\n+\t  _S_unref(__nright);\n \t  __throw_exception_again;\n \t}\n-      // In case of exception, we need to deallocate\n-      // otherwise dangling result node.  But caller\n-      // still owns its children.  Thus unref is\n-      // inappropriate.\n-      return __balanced;\n-    }\n-  else\n-    return __result;\n-}\n-\n-template <class _CharT, class _Alloc>\n-typename\n-rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n-\t\t(_RopeRep* __r, const _CharT*__s, size_t __slen)\n-{\n-    _RopeRep* __result;\n-    if (0 == __slen) {\n-\t_S_ref(__r);\n-\treturn __r;\n-    }\n-    if (0 == __r)\n-      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n-\t\t\t\t\t      __r->get_allocator());\n-    if (_Rope_constants::_S_leaf == __r->_M_tag &&\n-          __r->_M_size + __slen <= _S_copy_max) {\n-\t__result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n-\treturn __result;\n+      return __result;\n     }\n-    if (_Rope_constants::_S_concat == __r->_M_tag\n-\t&& _Rope_constants::_S_leaf == ((_RopeConcatenation*)__r)->_M_right->_M_tag) {\n-\t_RopeLeaf* __right =\n-\t  (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n-\tif (__right->_M_size + __slen <= _S_copy_max) {\n-\t  _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;\n-\t  _RopeRep* __nright =\n-\t    _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n-\t  __left->_M_ref_nonnil();\n-\t  try {\n-\t    __result = _S_tree_concat(__left, __nright);\n-          }\n-\t  catch(...)\n+\n+#ifndef __GC\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT,_Alloc>::_RopeRep*\n+    rope<_CharT,_Alloc>::\n+    _S_destr_concat_char_iter(_RopeRep* __r, const _CharT* __s, size_t __slen)\n+    {\n+      _RopeRep* __result;\n+      if (0 == __r)\n+\treturn __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n+\t\t\t\t\t\t__r->get_allocator());\n+      size_t __count = __r->_M_ref_count;\n+      size_t __orig_size = __r->_M_size;\n+      if (__count > 1)\n+\treturn _S_concat_char_iter(__r, __s, __slen);\n+      if (0 == __slen)\n+\t{\n+\t  __r->_M_ref_count = 2;      // One more than before\n+\t  return __r;\n+\t}\n+      if (__orig_size + __slen <= _S_copy_max\n+\t  && _Rope_constants::_S_leaf == __r->_M_tag)\n+\t{\n+\t  __result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, \n+\t\t\t\t\t\t    __slen);\n+\t  return __result;\n+\t}\n+      if (_Rope_constants::_S_concat == __r->_M_tag)\n+\t{\n+\t  _RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)\n+\t\t\t\t\t     __r)->_M_right);\n+\t  if (_Rope_constants::_S_leaf == __right->_M_tag\n+\t      && __right->_M_size + __slen <= _S_copy_max)\n \t    {\n-\t      _S_unref(__left);\n-\t      _S_unref(__nright);\n-\t      __throw_exception_again;\n+\t      _RopeRep* __new_right =\n+\t\t_S_destr_leaf_concat_char_iter(__right, __s, __slen);\n+\t      if (__right == __new_right)\n+\t\t__new_right->_M_ref_count = 1;\n+\t      else\n+\t\t__right->_M_unref_nonnil();\n+\t      __r->_M_ref_count = 2;    // One more than before.\n+\t      ((_RopeConcatenation*)__r)->_M_right = __new_right;\n+\t      __r->_M_size = __orig_size + __slen;\n+\t      if (0 != __r->_M_c_string)\n+\t\t{\n+\t\t  __r->_M_free_c_string();\n+\t\t  __r->_M_c_string = 0;\n+\t\t}\n+\t      return __r;\n \t    }\n-\t  return __result;\n \t}\n-    }\n-    _RopeRep* __nright =\n-      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n-    try {\n+      _RopeRep* __right =\n+\t__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n       __r->_M_ref_nonnil();\n-      __result = _S_tree_concat(__r, __nright);\n-    }\n-    catch(...)\n-      {\n-\t_S_unref(__r);\n-\t_S_unref(__nright);\n-\t__throw_exception_again;\n-      }\n-    return __result;\n-}\n-\n-#ifndef __GC\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n-  _RopeRep* __r, const _CharT* __s, size_t __slen)\n-{\n-    _RopeRep* __result;\n-    if (0 == __r)\n-      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n-\t\t\t\t\t      __r->get_allocator());\n-    size_t __count = __r->_M_ref_count;\n-    size_t __orig_size = __r->_M_size;\n-    if (__count > 1) return _S_concat_char_iter(__r, __s, __slen);\n-    if (0 == __slen) {\n-\t__r->_M_ref_count = 2;      // One more than before\n-\treturn __r;\n-    }\n-    if (__orig_size + __slen <= _S_copy_max &&\n-          _Rope_constants::_S_leaf == __r->_M_tag) {\n-\t__result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n-\treturn __result;\n-    }\n-    if (_Rope_constants::_S_concat == __r->_M_tag) {\n-\t_RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)__r)->_M_right);\n-\tif (_Rope_constants::_S_leaf == __right->_M_tag\n-\t    && __right->_M_size + __slen <= _S_copy_max) {\n-\t  _RopeRep* __new_right =\n-\t    _S_destr_leaf_concat_char_iter(__right, __s, __slen);\n-\t  if (__right == __new_right)\n-\t    __new_right->_M_ref_count = 1;\n-\t  else\n-\t    __right->_M_unref_nonnil();\n-\t  __r->_M_ref_count = 2;    // One more than before.\n-\t  ((_RopeConcatenation*)__r)->_M_right = __new_right;\n-\t  __r->_M_size = __orig_size + __slen;\n-\t  if (0 != __r->_M_c_string) {\n-\t      __r->_M_free_c_string();\n-\t      __r->_M_c_string = 0;\n-\t  }\n-\t  return __r;\n+      try\n+\t{ __result = _S_tree_concat(__r, __right); }\n+      catch(...)\n+\t{\n+\t  _S_unref(__r);\n+\t  _S_unref(__right);\n+\t  __throw_exception_again;\n \t}\n+      return __result;\n     }\n-    _RopeRep* __right =\n-      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n-    __r->_M_ref_nonnil();\n-    try {\n-      __result = _S_tree_concat(__r, __right);\n-    }\n-    catch(...)\n-      {\n-\t_S_unref(__r);\n-\t_S_unref(__right);\n-\t__throw_exception_again;\n-      }\n-    return __result;\n-}\n #endif /* !__GC */\n-\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n-{\n-    if (0 == __left) {\n-\t_S_ref(__right);\n-\treturn __right;\n-    }\n-    if (0 == __right) {\n-\t__left->_M_ref_nonnil();\n-\treturn __left;\n-    }\n-    if (_Rope_constants::_S_leaf == __right->_M_tag) {\n-\tif (_Rope_constants::_S_leaf == __left->_M_tag) {\n-\t  if (__right->_M_size + __left->_M_size <= _S_copy_max) {\n-\t    return _S_leaf_concat_char_iter((_RopeLeaf*)__left,\n-\t\t\t\t\t ((_RopeLeaf*)__right)->_M_data,\n-\t\t\t\t\t __right->_M_size);\n-\t  }\n-\t} else if (_Rope_constants::_S_concat == __left->_M_tag\n-\t\t   && _Rope_constants::_S_leaf ==\n-\t\t      ((_RopeConcatenation*)__left)->_M_right->_M_tag) {\n-\t  _RopeLeaf* __leftright =\n-\t\t    (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right);\n-\t  if (__leftright->_M_size + __right->_M_size <= _S_copy_max) {\n-\t    _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;\n-\t    _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,\n-\t\t\t\t\t   ((_RopeLeaf*)__right)->_M_data,\n-\t\t\t\t\t   __right->_M_size);\n-\t    __leftleft->_M_ref_nonnil();\n-\t    try {\n-\t      return(_S_tree_concat(__leftleft, __rest));\n-            }\n-\t    catch(...)\n-\t      {\n-\t\t_S_unref(__leftleft);\n-\t\t_S_unref(__rest);\n-\t\t__throw_exception_again;\n-\t      }\n-\t  }\n+  \n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeRep*\n+    rope<_CharT, _Alloc>::\n+    _S_concat(_RopeRep* __left, _RopeRep* __right)\n+    {\n+      if (0 == __left)\n+\t{\n+\t  _S_ref(__right);\n+\t  return __right;\n+\t}\n+      if (0 == __right)\n+\t{\n+\t  __left->_M_ref_nonnil();\n+\t  return __left;\n+\t}\n+      if (_Rope_constants::_S_leaf == __right->_M_tag)\n+\t{\n+\t  if (_Rope_constants::_S_leaf == __left->_M_tag)\n+\t    {\n+\t      if (__right->_M_size + __left->_M_size <= _S_copy_max)\n+\t\treturn _S_leaf_concat_char_iter((_RopeLeaf*)__left,\n+\t\t\t\t\t\t((_RopeLeaf*)__right)->_M_data,\n+\t\t\t\t\t\t__right->_M_size);\n+\t    }\n+\t  else if (_Rope_constants::_S_concat == __left->_M_tag\n+\t\t   && _Rope_constants::_S_leaf == ((_RopeConcatenation*)\n+\t\t\t\t\t\t   __left)->_M_right->_M_tag)\n+\t    {\n+\t      _RopeLeaf* __leftright =\n+\t\t(_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right);\n+\t      if (__leftright->_M_size + __right->_M_size <= _S_copy_max)\n+\t\t{\n+\t\t  _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;\n+\t\t  _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,\n+\t\t\t\t\t\t\t      ((_RopeLeaf*)\n+\t\t\t\t\t\t\t       __right)->\n+\t\t\t\t\t\t\t      _M_data,\n+\t\t\t\t\t\t\t      __right->_M_size);\n+\t\t  __leftleft->_M_ref_nonnil();\n+\t\t  try\n+\t\t    { return(_S_tree_concat(__leftleft, __rest)); }\n+\t\t  catch(...)\n+\t\t    {\n+\t\t      _S_unref(__leftleft);\n+\t\t      _S_unref(__rest);\n+\t\t      __throw_exception_again;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      __left->_M_ref_nonnil();\n+      __right->_M_ref_nonnil();\n+      try\n+\t{ return(_S_tree_concat(__left, __right)); }\n+      catch(...)\n+\t{\n+\t  _S_unref(__left);\n+\t  _S_unref(__right);\n+\t  __throw_exception_again;\n \t}\n     }\n-    __left->_M_ref_nonnil();\n-    __right->_M_ref_nonnil();\n-    try {\n-      return(_S_tree_concat(__left, __right));\n-    }\n-    catch(...)\n-      {\n-\t_S_unref(__left);\n-\t_S_unref(__right);\n-\t__throw_exception_again;\n-      }\t\n-}\n-\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base,\n-                               size_t __start, size_t __endp1)\n-{\n-    if (0 == __base) return 0;\n-    size_t __len = __base->_M_size;\n-    size_t __adj_endp1;\n-    const size_t __lazy_threshold = 128;\n-\n-    if (__endp1 >= __len) {\n-\tif (0 == __start) {\n-\t    __base->_M_ref_nonnil();\n-\t    return __base;\n-\t} else {\n+\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeRep*\n+    rope<_CharT, _Alloc>::\n+    _S_substring(_RopeRep* __base, size_t __start, size_t __endp1)\n+    {\n+      if (0 == __base)\n+\treturn 0;\n+      size_t __len = __base->_M_size;\n+      size_t __adj_endp1;\n+      const size_t __lazy_threshold = 128;\n+      \n+      if (__endp1 >= __len)\n+\t{\n+\t  if (0 == __start)\n+\t    {\n+\t      __base->_M_ref_nonnil();\n+\t      return __base;\n+\t    }\n+\t  else\n \t    __adj_endp1 = __len;\n+\t  \n \t}\n-    } else {\n+      else\n \t__adj_endp1 = __endp1;\n-    }\n-    switch(__base->_M_tag) {\n+\n+      switch(__base->_M_tag)\n+\t{\n \tcase _Rope_constants::_S_concat:\n \t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__base;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\t_RopeRep* __right = __c->_M_right;\n-\t\tsize_t __left_len = __left->_M_size;\n-\t\t_RopeRep* __result;\n-\n-\t\tif (__adj_endp1 <= __left_len) {\n-\t\t    return _S_substring(__left, __start, __endp1);\n-\t\t} else if (__start >= __left_len) {\n-\t\t    return _S_substring(__right, __start - __left_len,\n-\t\t\t\t  __adj_endp1 - __left_len);\n-\t\t}\n-\t\t_Self_destruct_ptr __left_result(\n-\t\t  _S_substring(__left, __start, __left_len));\n-\t\t_Self_destruct_ptr __right_result(\n-\t\t  _S_substring(__right, 0, __endp1 - __left_len));\n-\t\t__result = _S_concat(__left_result, __right_result);\n-\t\treturn __result;\n+\t      _RopeConcatenation* __c = (_RopeConcatenation*)__base;\n+\t      _RopeRep* __left = __c->_M_left;\n+\t      _RopeRep* __right = __c->_M_right;\n+\t      size_t __left_len = __left->_M_size;\n+\t      _RopeRep* __result;\n+\t      \n+\t      if (__adj_endp1 <= __left_len)\n+\t\treturn _S_substring(__left, __start, __endp1);\n+\t      else if (__start >= __left_len)\n+\t\treturn _S_substring(__right, __start - __left_len,\n+\t\t\t\t    __adj_endp1 - __left_len);\n+\t      _Self_destruct_ptr __left_result(_S_substring(__left,\n+\t\t\t\t\t\t\t    __start,\n+\t\t\t\t\t\t\t    __left_len));\n+\t      _Self_destruct_ptr __right_result(_S_substring(__right, 0,\n+\t\t\t\t\t\t\t     __endp1 \n+\t\t\t\t\t\t\t     - __left_len));\n+\t      __result = _S_concat(__left_result, __right_result);\n+\t      return __result;\n \t    }\n \tcase _Rope_constants::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__base;\n-\t\t_RopeLeaf* __result;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\t\tif (__result_len > __lazy_threshold) goto lazy;\n-#               ifdef __GC\n-\t\t    const _CharT* __section = __l->_M_data + __start;\n-\t\t    __result = _S_new_RopeLeaf(__section, __result_len,\n-\t\t\t\t\t  __base->get_allocator());\n-\t\t    __result->_M_c_string = 0;  // Not eos terminated.\n-#               else\n-\t\t    // We should sometimes create substring node instead.\n-\t\t    __result = __STL_ROPE_FROM_UNOWNED_CHAR_PTR(\n-\t\t\t\t\t__l->_M_data + __start, __result_len,\n-\t\t\t\t\t__base->get_allocator());\n-#               endif\n-\t\treturn __result;\n-\t    }\n+\t  {\n+\t    _RopeLeaf* __l = (_RopeLeaf*)__base;\n+\t    _RopeLeaf* __result;\n+\t    size_t __result_len;\n+\t    if (__start >= __adj_endp1)\n+\t      return 0;\n+\t    __result_len = __adj_endp1 - __start;\n+\t    if (__result_len > __lazy_threshold)\n+\t      goto lazy;\n+#ifdef __GC\n+\t    const _CharT* __section = __l->_M_data + __start;\n+\t    __result = _S_new_RopeLeaf(__section, __result_len,\n+\t\t\t\t       __base->get_allocator());\n+\t    __result->_M_c_string = 0;  // Not eos terminated.\n+#else\n+\t    // We should sometimes create substring node instead.\n+\t    __result = __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__l->_M_data + __start,\n+\t\t\t\t\t\t\t__result_len,\n+\t\t\t\t\t\t\t__base->\n+\t\t\t\t\t\t\tget_allocator());\n+#endif\n+\t    return __result;\n+\t  }\n \tcase _Rope_constants::_S_substringfn:\n-\t    // Avoid introducing multiple layers of substring nodes.\n-\t    {\n-\t\t_RopeSubstring* __old = (_RopeSubstring*)__base;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\t\tif (__result_len > __lazy_threshold) {\n-\t\t    _RopeSubstring* __result =\n-\t\t\t_S_new_RopeSubstring(__old->_M_base,\n-\t\t\t\t\t  __start + __old->_M_start,\n-\t\t\t\t\t  __adj_endp1 - __start,\n-\t\t\t\t\t  __base->get_allocator());\n-\t\t    return __result;\n-\n-\t\t} // *** else fall through: ***\n-\t    }\n-\tcase _Rope_constants::_S_function:\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__base;\n-\t\t_CharT* __section;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\n-\t\tif (__result_len > __lazy_threshold) goto lazy;\n-\t\t__section = (_CharT*)\n-\t\t  _Data_allocate(_S_rounded_up_size(__result_len));\n-\t\ttry {\n-\t\t  (*(__f->_M_fn))(__start, __result_len, __section);\n-                }\n-\t\tcatch(...)\n-\t\t  {\n-\t\t    _RopeRep::__STL_FREE_STRING(\n-\t               __section, __result_len, __base->get_allocator());\n-\t\t    __throw_exception_again;\n-\t\t  }\n-\t\t_S_cond_store_eos(__section[__result_len]);\n-\t\treturn _S_new_RopeLeaf(__section, __result_len,\n+\t  // Avoid introducing multiple layers of substring nodes.\n+\t  {\n+\t    _RopeSubstring* __old = (_RopeSubstring*)__base;\n+\t    size_t __result_len;\n+\t    if (__start >= __adj_endp1)\n+\t      return 0;\n+\t    __result_len = __adj_endp1 - __start;\n+\t    if (__result_len > __lazy_threshold)\n+\t      {\n+\t\t_RopeSubstring* __result =\n+\t\t  _S_new_RopeSubstring(__old->_M_base,\n+\t\t\t\t       __start + __old->_M_start,\n+\t\t\t\t       __adj_endp1 - __start,\n \t\t\t\t       __base->get_allocator());\n-\t    }\n-    }\n-  lazy:\n-    {\n+\t\treturn __result;\n+\t\t\n+\t      } // *** else fall through: ***\n+\t  }\n+\tcase _Rope_constants::_S_function:\n+\t  {\n+\t    _RopeFunction* __f = (_RopeFunction*)__base;\n+\t    _CharT* __section;\n+\t    size_t __result_len;\n+\t    if (__start >= __adj_endp1)\n+\t      return 0;\n+\t    __result_len = __adj_endp1 - __start;\n+\t    \n+\t    if (__result_len > __lazy_threshold)\n+\t      goto lazy;\n+\t    __section = (_CharT*)\n+\t      _Data_allocate(_S_rounded_up_size(__result_len));\n+\t    try\n+\t      {\t(*(__f->_M_fn))(__start, __result_len, __section); }\n+\t    catch(...)\n+\t      {\n+\t\t_RopeRep::__STL_FREE_STRING(__section, __result_len,\n+\t\t\t\t\t    __base->get_allocator());\n+\t\t__throw_exception_again;\n+\t      }\n+\t    _S_cond_store_eos(__section[__result_len]);\n+\t    return _S_new_RopeLeaf(__section, __result_len,\n+\t\t\t\t   __base->get_allocator());\n+\t  }\n+\t}\n+    lazy:\n+      {\n \t// Create substring node.\n \treturn _S_new_RopeSubstring(__base, __start, __adj_endp1 - __start,\n-\t\t\t       __base->get_allocator());\n+\t\t\t\t    __base->get_allocator());\n+      }\n     }\n-}\n \n-template<class _CharT>\n-class _Rope_flatten_char_consumer : public _Rope_char_consumer<_CharT> {\n+  template<class _CharT>\n+    class _Rope_flatten_char_consumer\n+    : public _Rope_char_consumer<_CharT>\n+    {\n     private:\n-\t_CharT* _M_buf_ptr;\n+      _CharT* _M_buf_ptr;\n     public:\n+      \n+      _Rope_flatten_char_consumer(_CharT* __buffer)\n+      { _M_buf_ptr = __buffer; };\n+\n+      ~_Rope_flatten_char_consumer() {}\n+      \n+      bool\n+      operator()(const _CharT* __leaf, size_t __n)\n+      {\n+\tuninitialized_copy_n(__leaf, __n, _M_buf_ptr);\n+\t_M_buf_ptr += __n;\n+\treturn true;\n+      }\n+    };\n \n-\t_Rope_flatten_char_consumer(_CharT* __buffer) {\n-\t    _M_buf_ptr = __buffer;\n-\t};\n-\t~_Rope_flatten_char_consumer() {}\n-\tbool operator() (const _CharT* __leaf, size_t __n) {\n-\t    uninitialized_copy_n(__leaf, __n, _M_buf_ptr);\n-\t    _M_buf_ptr += __n;\n-\t    return true;\n-\t}\n-};\n-\n-template<class _CharT>\n-class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n+  template<class _CharT>\n+    class _Rope_find_char_char_consumer\n+    : public _Rope_char_consumer<_CharT>\n+    {\n     private:\n-\t_CharT _M_pattern;\n+      _CharT _M_pattern;\n     public:\n-\tsize_t _M_count;  // Number of nonmatching characters\n-\t_Rope_find_char_char_consumer(_CharT __p)\n-\t  : _M_pattern(__p), _M_count(0) {}\n-\t~_Rope_find_char_char_consumer() {}\n-\tbool operator() (const _CharT* __leaf, size_t __n) {\n-\t    size_t __i;\n-\t    for (__i = 0; __i < __n; __i++) {\n-\t\tif (__leaf[__i] == _M_pattern) {\n-\t\t    _M_count += __i; return false;\n-\t\t}\n-\t    }\n-\t    _M_count += __n; return true;\n-\t}\n-};\n+      size_t _M_count;  // Number of nonmatching characters\n+      \n+      _Rope_find_char_char_consumer(_CharT __p)\n+      : _M_pattern(__p), _M_count(0) {}\n+\t\n+      ~_Rope_find_char_char_consumer() {}\n+      \n+      bool\n+      operator()(const _CharT* __leaf, size_t __n)\n+      {\n+\tsize_t __i;\n+\tfor (__i = 0; __i < __n; __i++)\n+\t  {\n+\t    if (__leaf[__i] == _M_pattern)\n+\t      {\n+\t\t_M_count += __i;\n+\t\treturn false;\n+\t      }\n+\t  }\n+\t_M_count += __n; return true;\n+      }\n+    };\n \n   template<class _CharT, class _Traits>\n   // Here _CharT is both the stream and rope character type.\n-class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n+    class _Rope_insert_char_consumer\n+    : public _Rope_char_consumer<_CharT>\n+    {\n     private:\n-\t  typedef basic_ostream<_CharT,_Traits> _Insert_ostream;\n-\t_Insert_ostream& _M_o;\n+      typedef basic_ostream<_CharT,_Traits> _Insert_ostream;\n+      _Insert_ostream& _M_o;\n     public:\n-\t_Rope_insert_char_consumer(_Insert_ostream& __writer)\n-\t  : _M_o(__writer) {};\n-\t~_Rope_insert_char_consumer() { };\n-\t\t// Caller is presumed to own the ostream\n-\tbool operator() (const _CharT* __leaf, size_t __n);\n-\t\t// Returns true to continue traversal.\n-};\n-\n-template<class _CharT, class _Traits>\n-bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()\n-                                      (const _CharT* __leaf, size_t __n)\n-{\n-  size_t __i;\n-  //  We assume that formatting is set up correctly for each element.\n-  for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n-  return true;\n-}\n-\n-template <class _CharT, class _Alloc>\n-bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n-\t\t\t\t_Rope_char_consumer<_CharT>& __c,\n-\t\t\t\tconst _RopeRep* __r,\n-\t\t\t\tsize_t __begin, size_t __end)\n-{\n-    if (0 == __r) return true;\n-    switch(__r->_M_tag) {\n+      _Rope_insert_char_consumer(_Insert_ostream& __writer)\n+\t: _M_o(__writer) {};\n+      ~_Rope_insert_char_consumer() { };\n+      // Caller is presumed to own the ostream\n+      bool operator() (const _CharT* __leaf, size_t __n);\n+      // Returns true to continue traversal.\n+    };\n+\n+  template<class _CharT, class _Traits>\n+    bool\n+    _Rope_insert_char_consumer<_CharT, _Traits>::\n+    operator()(const _CharT* __leaf, size_t __n)\n+    {\n+      size_t __i;\n+      //  We assume that formatting is set up correctly for each element.\n+      for (__i = 0; __i < __n; __i++)\n+\t_M_o.put(__leaf[__i]);\n+      return true;\n+    }\n+\n+  template <class _CharT, class _Alloc>\n+    bool\n+    rope<_CharT, _Alloc>::\n+    _S_apply_to_pieces(_Rope_char_consumer<_CharT>& __c,\n+\t\t       const _RopeRep* __r, size_t __begin, size_t __end)\n+    {\n+      if (0 == __r)\n+\treturn true;\n+      switch(__r->_M_tag)\n+\t{\n \tcase _Rope_constants::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __conc = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left =  __conc->_M_left;\n-\t\tsize_t __left_len = __left->_M_size;\n-\t\tif (__begin < __left_len) {\n-\t\t    size_t __left_end = std::min(__left_len, __end);\n-\t\t    if (!_S_apply_to_pieces(__c, __left, __begin, __left_end))\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (__end > __left_len) {\n-\t\t    _RopeRep* __right =  __conc->_M_right;\n-\t\t    size_t __right_start = std::max(__left_len, __begin);\n-\t\t    if (!_S_apply_to_pieces(__c, __right,\n-\t\t\t\t\t __right_start - __left_len,\n-\t\t\t\t\t __end - __left_len)) {\n-\t\t\treturn false;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t    return true;\n-\tcase _Rope_constants::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\treturn __c(__l->_M_data + __begin, __end - __begin);\n-\t    }\n+\t  {\n+\t    _RopeConcatenation* __conc = (_RopeConcatenation*)__r;\n+\t    _RopeRep* __left =  __conc->_M_left;\n+\t    size_t __left_len = __left->_M_size;\n+\t    if (__begin < __left_len)\n+\t      {\n+\t\tsize_t __left_end = std::min(__left_len, __end);\n+\t\tif (!_S_apply_to_pieces(__c, __left, __begin, __left_end))\n+\t\t  return false;\n+\t      }\n+\t    if (__end > __left_len)\n+\t      {\n+\t\t_RopeRep* __right =  __conc->_M_right;\n+\t\tsize_t __right_start = std::max(__left_len, __begin);\n+\t\tif (!_S_apply_to_pieces(__c, __right,\n+\t\t\t\t\t__right_start - __left_len,\n+\t\t\t\t\t__end - __left_len))\n+\t\t  return false;\n+\t      }\n+\t  }\n+\t  return true;\n+\tcase _Rope_constants::_S_leaf:\n+\t  {\n+\t    _RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t    return __c(__l->_M_data + __begin, __end - __begin);\n+\t  }\n \tcase _Rope_constants::_S_function:\n \tcase _Rope_constants::_S_substringfn:\n \t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n-\t\tsize_t __len = __end - __begin;\n-\t\tbool __result;\n-\t\t_CharT* __buffer =\n-\t\t  (_CharT*)_Alloc().allocate(__len * sizeof(_CharT));\n-\t\ttry {\n+\t      _RopeFunction* __f = (_RopeFunction*)__r;\n+\t      size_t __len = __end - __begin;\n+\t      bool __result;\n+\t      _CharT* __buffer =\n+\t\t(_CharT*)_Alloc().allocate(__len * sizeof(_CharT));\n+\t      try\n+\t\t{\n \t\t  (*(__f->_M_fn))(__begin, __len, __buffer);\n \t\t  __result = __c(__buffer, __len);\n                   _Alloc().deallocate(__buffer, __len * sizeof(_CharT));\n                 }\n-\t\tcatch(...)\n-\t\t  {\n-\t\t    _Alloc().deallocate(__buffer, __len * sizeof(_CharT));\n-\t\t    __throw_exception_again;\n-\t\t  }\n-\t\treturn __result;\n+\t      catch(...)\n+\t\t{\n+\t\t  _Alloc().deallocate(__buffer, __len * sizeof(_CharT));\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t      return __result;\n \t    }\n \tdefault:\n \t  return false;\n+\t}\n     }\n-}\n \n   template<class _CharT, class _Traits>\n-  inline void _Rope_fill(basic_ostream<_CharT, _Traits>& __o, size_t __n)\n-{\n-    char __f = __o.fill();\n-    size_t __i;\n+    inline void\n+    _Rope_fill(basic_ostream<_CharT, _Traits>& __o, size_t __n)\n+    {\n+      char __f = __o.fill();\n+      size_t __i;\n+      \n+      for (__i = 0; __i < __n; __i++)\n+\t__o.put(__f);\n+    }\n \n-    for (__i = 0; __i < __n; __i++) __o.put(__f);\n-}\n \n+  template <class _CharT>\n+    inline bool\n+    _Rope_is_simple(_CharT*)\n+    { return false; }\n \n-template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }\n-inline bool _Rope_is_simple(char*) { return true; }\n-inline bool _Rope_is_simple(wchar_t*) { return true; }\n+  inline bool\n+  _Rope_is_simple(char*)\n+  { return true; }\n \n-template<class _CharT, class _Traits, class _Alloc>\n-basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n-                                            const rope<_CharT, _Alloc>& __r)\n-{\n-    size_t __w = __o.width();\n-    bool __left = bool(__o.flags() & std::ios::left);\n-    size_t __pad_len;\n-    size_t __rope_len = __r.size();\n-      _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);\n-    bool __is_simple = _Rope_is_simple((_CharT*)0);\n+  inline bool\n+  _Rope_is_simple(wchar_t*)\n+  { return true; }\n \n-    if (__rope_len < __w) {\n+  template<class _CharT, class _Traits, class _Alloc>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __o,\n+\t       const rope<_CharT, _Alloc>& __r)\n+    {\n+      size_t __w = __o.width();\n+      bool __left = bool(__o.flags() & std::ios::left);\n+      size_t __pad_len;\n+      size_t __rope_len = __r.size();\n+      _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);\n+      bool __is_simple = _Rope_is_simple((_CharT*)0);\n+      \n+      if (__rope_len < __w)\n \t__pad_len = __w - __rope_len;\n-    } else {\n+      else\n \t__pad_len = 0;\n-    }\n-    if (!__is_simple) __o.width(__w/__rope_len);\n-    try {\n-      if (__is_simple && !__left && __pad_len > 0) {\n-\t_Rope_fill(__o, __pad_len);\n-      }\n-      __r.apply_to_pieces(0, __r.size(), __c);\n-      if (__is_simple && __left && __pad_len > 0) {\n-\t_Rope_fill(__o, __pad_len);\n-      }\n+\n       if (!__is_simple)\n-        __o.width(__w);\n+\t__o.width(__w / __rope_len);\n+      try\n+\t{\n+\t  if (__is_simple && !__left && __pad_len > 0)\n+\t    _Rope_fill(__o, __pad_len);\n+\t  __r.apply_to_pieces(0, __r.size(), __c);\n+\t  if (__is_simple && __left && __pad_len > 0)\n+\t    _Rope_fill(__o, __pad_len);\n+\t  if (!__is_simple)\n+\t    __o.width(__w);\n+\t}\n+      catch(...)\n+\t{\n+\t  if (!__is_simple)\n+\t    __o.width(__w);\n+\t  __throw_exception_again;\n+\t}\n+      return __o;\n     }\n-    catch(...)\n-      {\n-\tif (!__is_simple)\n-\t  __o.width(__w);\n-\t__throw_exception_again;\n-      }\n-    return __o;\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r,\n-\t\t\t\t size_t __start, size_t __len,\n-\t\t\t\t _CharT* __buffer)\n-{\n-    _Rope_flatten_char_consumer<_CharT> __c(__buffer);\n-    _S_apply_to_pieces(__c, __r, __start, __start + __len);\n-    return(__buffer + __len);\n-}\n-\n-template <class _CharT, class _Alloc>\n-size_t\n-rope<_CharT,_Alloc>::find(_CharT __pattern, size_t __start) const\n-{\n-    _Rope_find_char_char_consumer<_CharT> __c(__pattern);\n-    _S_apply_to_pieces(__c, this->_M_tree_ptr, __start, size());\n-    size_type __result_pos = __start + __c._M_count;\n-#   ifndef __STL_OLD_ROPE_SEMANTICS\n-\tif (__result_pos == size()) __result_pos = npos;\n-#   endif\n-    return __result_pos;\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r, _CharT* __buffer)\n-{\n-    if (0 == __r) return __buffer;\n-    switch(__r->_M_tag) {\n+\n+  template <class _CharT, class _Alloc>\n+    _CharT*\n+    rope<_CharT, _Alloc>::\n+    _S_flatten(_RopeRep* __r, size_t __start, size_t __len,\n+\t       _CharT* __buffer)\n+    {\n+      _Rope_flatten_char_consumer<_CharT> __c(__buffer);\n+      _S_apply_to_pieces(__c, __r, __start, __start + __len);\n+      return(__buffer + __len);\n+    }\n+\n+  template <class _CharT, class _Alloc>\n+    size_t\n+    rope<_CharT, _Alloc>::\n+    find(_CharT __pattern, size_t __start) const\n+    {\n+      _Rope_find_char_char_consumer<_CharT> __c(__pattern);\n+      _S_apply_to_pieces(__c, this->_M_tree_ptr, __start, size());\n+      size_type __result_pos = __start + __c._M_count;\n+#ifndef __STL_OLD_ROPE_SEMANTICS\n+      if (__result_pos == size())\n+\t__result_pos = npos;\n+#endif\n+      return __result_pos;\n+    }\n+\n+  template <class _CharT, class _Alloc>\n+    _CharT*\n+    rope<_CharT, _Alloc>::\n+    _S_flatten(_RopeRep* __r, _CharT* __buffer)\n+    {\n+      if (0 == __r)\n+\treturn __buffer;\n+      switch(__r->_M_tag)\n+\t{\n \tcase _Rope_constants::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\t_RopeRep* __right = __c->_M_right;\n-\t\t_CharT* __rest = _S_flatten(__left, __buffer);\n-\t\treturn _S_flatten(__right, __rest);\n-\t    }\n+\t  {\n+\t    _RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t    _RopeRep* __left = __c->_M_left;\n+\t    _RopeRep* __right = __c->_M_right;\n+\t    _CharT* __rest = _S_flatten(__left, __buffer);\n+\t    return _S_flatten(__right, __rest);\n+\t  }\n \tcase _Rope_constants::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\treturn copy_n(__l->_M_data, __l->_M_size, __buffer).second;\n-\t    }\n+\t  {\n+\t    _RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t    return copy_n(__l->_M_data, __l->_M_size, __buffer).second;\n+\t  }\n \tcase _Rope_constants::_S_function:\n \tcase _Rope_constants::_S_substringfn:\n-\t    // We don't yet do anything with substring nodes.\n-\t    // This needs to be fixed before ropefiles will work well.\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n-\t\t(*(__f->_M_fn))(0, __f->_M_size, __buffer);\n-\t\treturn __buffer + __f->_M_size;\n-\t    }\n+\t  // We don't yet do anything with substring nodes.\n+\t  // This needs to be fixed before ropefiles will work well.\n+\t  {\n+\t    _RopeFunction* __f = (_RopeFunction*)__r;\n+\t    (*(__f->_M_fn))(0, __f->_M_size, __buffer);\n+\t    return __buffer + __f->_M_size;\n+\t  }\n \tdefault:\n-\t    return 0;\n-    }\n-}\n-\n-\n-// This needs work for _CharT != char\n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_dump(_RopeRep* __r, int __indent)\n-{\n-    for (int __i = 0; __i < __indent; __i++) putchar(' ');\n-    if (0 == __r) {\n-\tprintf(\"NULL\\n\"); return;\n+\t  return 0;\n+\t}\n     }\n-    if (_Rope_constants::_S_concat == __r->_M_tag) {\n-\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t_RopeRep* __left = __c->_M_left;\n-\t_RopeRep* __right = __c->_M_right;\n \n-#       ifdef __GC\n+  // This needs work for _CharT != char\n+  template <class _CharT, class _Alloc>\n+    void\n+    rope<_CharT, _Alloc>::\n+    _S_dump(_RopeRep* __r, int __indent)\n+    {\n+      for (int __i = 0; __i < __indent; __i++)\n+\tputchar(' ');\n+      if (0 == __r)\n+\t{\n+\t  printf(\"NULL\\n\");\n+\t  return;\n+\t}\n+      if (_Rope_constants::_S_concat == __r->_M_tag)\n+\t{\n+\t  _RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t  _RopeRep* __left = __c->_M_left;\n+\t  _RopeRep* __right = __c->_M_right;\n+\t  \n+#ifdef __GC\n \t  printf(\"Concatenation %p (depth = %d, len = %ld, %s balanced)\\n\",\n-\t    __r, __r->_M_depth, __r->_M_size, __r->_M_is_balanced? \"\" : \"not\");\n-#       else\n+\t\t __r, __r->_M_depth, __r->_M_size,\n+\t\t __r->_M_is_balanced? \"\" : \"not\");\n+#else\n \t  printf(\"Concatenation %p (rc = %ld, depth = %d, \"\n-\t           \"len = %ld, %s balanced)\\n\",\n+\t\t \"len = %ld, %s balanced)\\n\",\n \t\t __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size,\n \t\t __r->_M_is_balanced? \"\" : \"not\");\n-#       endif\n-\t_S_dump(__left, __indent + 2);\n-\t_S_dump(__right, __indent + 2);\n-\treturn;\n-    } else {\n-\tchar* __kind;\n-\n-\tswitch (__r->_M_tag) {\n+#endif\n+\t  _S_dump(__left, __indent + 2);\n+\t  _S_dump(__right, __indent + 2);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  char* __kind;\n+\t  \n+\t  switch (__r->_M_tag)\n+\t    {\n \t    case _Rope_constants::_S_leaf:\n-\t\t__kind = \"Leaf\";\n-\t\tbreak;\n+\t      __kind = \"Leaf\";\n+\t      break;\n \t    case _Rope_constants::_S_function:\n-\t\t__kind = \"Function\";\n-\t\tbreak;\n+\t      __kind = \"Function\";\n+\t      break;\n \t    case _Rope_constants::_S_substringfn:\n-\t\t__kind = \"Function representing substring\";\n-\t\tbreak;\n+\t      __kind = \"Function representing substring\";\n+\t      break;\n \t    default:\n-\t\t__kind = \"(corrupted kind field!)\";\n-\t}\n-#       ifdef __GC\n+\t      __kind = \"(corrupted kind field!)\";\n+\t    }\n+#ifdef __GC\n \t  printf(\"%s %p (depth = %d, len = %ld) \",\n \t\t __kind, __r, __r->_M_depth, __r->_M_size);\n-#       else\n+#else\n \t  printf(\"%s %p (rc = %ld, depth = %d, len = %ld) \",\n \t\t __kind, __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size);\n-#       endif\n-\tif (_S_is_one_byte_char_type((_CharT*)0)) {\n-\t    const int __max_len = 40;\n-\t    _Self_destruct_ptr __prefix(_S_substring(__r, 0, __max_len));\n-\t    _CharT __buffer[__max_len + 1];\n-\t    bool __too_big = __r->_M_size > __prefix->_M_size;\n-\n-\t    _S_flatten(__prefix, __buffer);\n-\t    __buffer[__prefix->_M_size] = _S_eos((_CharT*)0);\n-\t    printf(\"%s%s\\n\",\n-\t           (char*)__buffer, __too_big? \"...\\n\" : \"\\n\");\n-\t} else {\n+#endif\n+\t  if (_S_is_one_byte_char_type((_CharT*)0))\n+\t    {\n+\t      const int __max_len = 40;\n+\t      _Self_destruct_ptr __prefix(_S_substring(__r, 0, __max_len));\n+\t      _CharT __buffer[__max_len + 1];\n+\t      bool __too_big = __r->_M_size > __prefix->_M_size;\n+\t      \n+\t      _S_flatten(__prefix, __buffer);\n+\t      __buffer[__prefix->_M_size] = _S_eos((_CharT*)0);\n+\t      printf(\"%s%s\\n\", (char*)__buffer,\n+\t\t     __too_big? \"...\\n\" : \"\\n\");\n+\t    }\n+\t  else\n \t    printf(\"\\n\");\n \t}\n     }\n-}\n-\n-template <class _CharT, class _Alloc>\n-const unsigned long\n-rope<_CharT,_Alloc>::_S_min_len[_Rope_constants::_S_max_rope_depth + 1] = {\n-/* 0 */1, /* 1 */2, /* 2 */3, /* 3 */5, /* 4 */8, /* 5 */13, /* 6 */21,\n-/* 7 */34, /* 8 */55, /* 9 */89, /* 10 */144, /* 11 */233, /* 12 */377,\n-/* 13 */610, /* 14 */987, /* 15 */1597, /* 16 */2584, /* 17 */4181,\n-/* 18 */6765, /* 19 */10946, /* 20 */17711, /* 21 */28657, /* 22 */46368,\n-/* 23 */75025, /* 24 */121393, /* 25 */196418, /* 26 */317811,\n-/* 27 */514229, /* 28 */832040, /* 29 */1346269, /* 30 */2178309,\n-/* 31 */3524578, /* 32 */5702887, /* 33 */9227465, /* 34 */14930352,\n-/* 35 */24157817, /* 36 */39088169, /* 37 */63245986, /* 38 */102334155,\n-/* 39 */165580141, /* 40 */267914296, /* 41 */433494437,\n-/* 42 */701408733, /* 43 */1134903170, /* 44 */1836311903,\n-/* 45 */2971215073u };\n-// These are Fibonacci numbers < 2**32.\n-\n-template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n-{\n-    _RopeRep* __forest[_Rope_constants::_S_max_rope_depth + 1];\n-    _RopeRep* __result = 0;\n-    int __i;\n-    // Invariant:\n-    // The concatenation of forest in descending order is equal to __r.\n-    // __forest[__i]._M_size >= _S_min_len[__i]\n-    // __forest[__i]._M_depth = __i\n-    // References from forest are included in refcount.\n-\n-    for (__i = 0; __i <= _Rope_constants::_S_max_rope_depth; ++__i)\n-      __forest[__i] = 0;\n-    try {\n-      _S_add_to_forest(__r, __forest);\n-      for (__i = 0; __i <= _Rope_constants::_S_max_rope_depth; ++__i)\n-        if (0 != __forest[__i]) {\n-#\tifndef __GC\n-\t  _Self_destruct_ptr __old(__result);\n-#\tendif\n-\t  __result = _S_concat(__forest[__i], __result);\n-\t__forest[__i]->_M_unref_nonnil();\n-#\tif !defined(__GC) && defined(__EXCEPTIONS)\n-\t  __forest[__i] = 0;\n-#\tendif\n-      }\n-    }\n-    catch(...)\n-      {\n-\tfor(__i = 0; __i <= _Rope_constants::_S_max_rope_depth; __i++)\n-\t  _S_unref(__forest[__i]);\n-\t__throw_exception_again;\n-      }\n-\n-    if (__result->_M_depth > _Rope_constants::_S_max_rope_depth)\n-      __throw_length_error(__N(\"rope::_S_balance\"));\n-    return(__result);\n-}\n \n-\n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)\n-{\n-    if (__r->_M_is_balanced) {\n-\t_S_add_leaf_to_forest(__r, __forest);\n-\treturn;\n+  template <class _CharT, class _Alloc>\n+    const unsigned long\n+    rope<_CharT, _Alloc>::\n+    _S_min_len[_Rope_constants::_S_max_rope_depth + 1] = {\n+      /* 0 */1, /* 1 */2, /* 2 */3, /* 3 */5, /* 4 */8, /* 5 */13, /* 6 */21,\n+      /* 7 */34, /* 8 */55, /* 9 */89, /* 10 */144, /* 11 */233, /* 12 */377,\n+      /* 13 */610, /* 14 */987, /* 15 */1597, /* 16 */2584, /* 17 */4181,\n+      /* 18 */6765, /* 19 */10946, /* 20 */17711, /* 21 */28657, /* 22 */46368,\n+      /* 23 */75025, /* 24 */121393, /* 25 */196418, /* 26 */317811,\n+      /* 27 */514229, /* 28 */832040, /* 29 */1346269, /* 30 */2178309,\n+      /* 31 */3524578, /* 32 */5702887, /* 33 */9227465, /* 34 */14930352,\n+      /* 35 */24157817, /* 36 */39088169, /* 37 */63245986, /* 38 */102334155,\n+      /* 39 */165580141, /* 40 */267914296, /* 41 */433494437,\n+      /* 42 */701408733, /* 43 */1134903170, /* 44 */1836311903,\n+      /* 45 */2971215073u };\n+  // These are Fibonacci numbers < 2**32.\n+\n+  template <class _CharT, class _Alloc>\n+    typename rope<_CharT, _Alloc>::_RopeRep*\n+    rope<_CharT, _Alloc>::\n+    _S_balance(_RopeRep* __r)\n+    {\n+      _RopeRep* __forest[_Rope_constants::_S_max_rope_depth + 1];\n+      _RopeRep* __result = 0;\n+      int __i;\n+      // Invariant:\n+      // The concatenation of forest in descending order is equal to __r.\n+      // __forest[__i]._M_size >= _S_min_len[__i]\n+      // __forest[__i]._M_depth = __i\n+      // References from forest are included in refcount.\n+      \n+      for (__i = 0; __i <= _Rope_constants::_S_max_rope_depth; ++__i)\n+\t__forest[__i] = 0;\n+      try\n+\t{\n+\t  _S_add_to_forest(__r, __forest);\n+\t  for (__i = 0; __i <= _Rope_constants::_S_max_rope_depth; ++__i)\n+\t    if (0 != __forest[__i])\n+\t      {\n+#ifndef __GC\n+\t\t_Self_destruct_ptr __old(__result);\n+#endif\n+\t\t__result = _S_concat(__forest[__i], __result);\n+\t\t__forest[__i]->_M_unref_nonnil();\n+#if !defined(__GC) && defined(__EXCEPTIONS)\n+\t\t__forest[__i] = 0;\n+#endif\n+\t      }\n+\t}\n+      catch(...)\n+\t{\n+\t  for(__i = 0; __i <= _Rope_constants::_S_max_rope_depth; __i++)\n+\t    _S_unref(__forest[__i]);\n+\t  __throw_exception_again;\n+\t}\n+      \n+      if (__result->_M_depth > _Rope_constants::_S_max_rope_depth)\n+\t__throw_length_error(__N(\"rope::_S_balance\"));\n+      return(__result);\n     }\n \n+  template <class _CharT, class _Alloc>\n+    void\n+    rope<_CharT, _Alloc>::\n+    _S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)\n     {\n-\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+      if (__r->_M_is_balanced)\n+\t{\n+\t  _S_add_leaf_to_forest(__r, __forest);\n+\t  return;\n+\t}\n \n+      {\n+\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t\n \t_S_add_to_forest(__c->_M_left, __forest);\n \t_S_add_to_forest(__c->_M_right, __forest);\n+      }\n     }\n-}\n \n \n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n-{\n-    _RopeRep* __insertee;\t\t// included in refcount\n-    _RopeRep* __too_tiny = 0;\t\t// included in refcount\n-    int __i;\t\t\t\t// forest[0..__i-1] is empty\n-    size_t __s = __r->_M_size;\n-\n-    for (__i = 0; __s >= _S_min_len[__i+1]/* not this bucket */; ++__i) {\n-\tif (0 != __forest[__i]) {\n-#\t    ifndef __GC\n+  template <class _CharT, class _Alloc>\n+    void\n+    rope<_CharT, _Alloc>::\n+    _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n+    {\n+      _RopeRep* __insertee;\t\t// included in refcount\n+      _RopeRep* __too_tiny = 0;\t\t// included in refcount\n+      int __i;\t\t\t\t// forest[0..__i-1] is empty\n+      size_t __s = __r->_M_size;\n+      \n+      for (__i = 0; __s >= _S_min_len[__i+1]/* not this bucket */; ++__i)\n+\t{\n+\t  if (0 != __forest[__i])\n+\t    {\n+#ifndef __GC\n \t      _Self_destruct_ptr __old(__too_tiny);\n-#\t    endif\n-\t    __too_tiny = _S_concat_and_set_balanced(__forest[__i], __too_tiny);\n-\t    __forest[__i]->_M_unref_nonnil();\n-\t    __forest[__i] = 0;\n+#endif\n+\t      __too_tiny = _S_concat_and_set_balanced(__forest[__i],\n+\t\t\t\t\t\t      __too_tiny);\n+\t      __forest[__i]->_M_unref_nonnil();\n+\t      __forest[__i] = 0;\n+\t    }\n \t}\n-    }\n-    {\n-#\tifndef __GC\n-\t  _Self_destruct_ptr __old(__too_tiny);\n-#\tendif\n+      {\n+#ifndef __GC\n+\t_Self_destruct_ptr __old(__too_tiny);\n+#endif\n \t__insertee = _S_concat_and_set_balanced(__too_tiny, __r);\n-    }\n-    // Too_tiny dead, and no longer included in refcount.\n-    // Insertee is live and included.\n-    for (;; ++__i) {\n-\tif (0 != __forest[__i]) {\n-#\t    ifndef __GC\n+      }\n+      // Too_tiny dead, and no longer included in refcount.\n+      // Insertee is live and included.\n+      for (;; ++__i)\n+\t{\n+\t  if (0 != __forest[__i])\n+\t    {\n+#ifndef __GC\n \t      _Self_destruct_ptr __old(__insertee);\n-#\t    endif\n-\t    __insertee = _S_concat_and_set_balanced(__forest[__i], __insertee);\n-\t    __forest[__i]->_M_unref_nonnil();\n-\t    __forest[__i] = 0;\n-\t}\n-\tif (__i == _Rope_constants::_S_max_rope_depth ||\n-\t      __insertee->_M_size < _S_min_len[__i+1]) {\n-\t    __forest[__i] = __insertee;\n-\t    // refcount is OK since __insertee is now dead.\n-\t    return;\n+#endif\n+\t      __insertee = _S_concat_and_set_balanced(__forest[__i],\n+\t\t\t\t\t\t      __insertee);\n+\t      __forest[__i]->_M_unref_nonnil();\n+\t      __forest[__i] = 0;\n+\t    }\n+\t  if (__i == _Rope_constants::_S_max_rope_depth\n+\t      || __insertee->_M_size < _S_min_len[__i+1])\n+\t    {\n+\t      __forest[__i] = __insertee;\n+\t      // refcount is OK since __insertee is now dead.\n+\t      return;\n+\t    }\n \t}\n     }\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT\n-rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)\n-{\n-    __GC_CONST _CharT* __cstr = __r->_M_c_string;\n \n-    if (0 != __cstr) return __cstr[__i];\n-    for(;;) {\n-      switch(__r->_M_tag) {\n-\tcase _Rope_constants::_S_concat:\n+  template <class _CharT, class _Alloc>\n+    _CharT\n+    rope<_CharT, _Alloc>::\n+    _S_fetch(_RopeRep* __r, size_type __i)\n+    {\n+      __GC_CONST _CharT* __cstr = __r->_M_c_string;\n+      \n+      if (0 != __cstr)\n+\treturn __cstr[__i];\n+      for(;;)\n+\t{\n+\t  switch(__r->_M_tag)\n \t    {\n+\t    case _Rope_constants::_S_concat:\n+\t      {\n \t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t\t_RopeRep* __left = __c->_M_left;\n \t\tsize_t __left_len = __left->_M_size;\n-\n-\t\tif (__i >= __left_len) {\n+\t\t\n+\t\tif (__i >= __left_len)\n+\t\t  {\n \t\t    __i -= __left_len;\n \t\t    __r = __c->_M_right;\n-\t\t} else {\n-\t\t    __r = __left;\n-\t\t}\n-\t    }\n-\t    break;\n-\tcase _Rope_constants::_S_leaf:\n-\t    {\n+\t\t  } \n+\t\telse\n+\t\t  __r = __left;\n+\t      }\n+\t      break;\n+\t    case _Rope_constants::_S_leaf:\n+\t      {\n \t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n \t\treturn __l->_M_data[__i];\n-\t    }\n-\tcase _Rope_constants::_S_function:\n-\tcase _Rope_constants::_S_substringfn:\n-\t    {\n+\t      }\n+\t    case _Rope_constants::_S_function:\n+\t    case _Rope_constants::_S_substringfn:\n+\t      {\n \t\t_RopeFunction* __f = (_RopeFunction*)__r;\n \t\t_CharT __result;\n-\n+\t\t\n \t\t(*(__f->_M_fn))(__i, 1, &__result);\n \t\treturn __result;\n+\t      }\n \t    }\n-      }\n+\t}\n     }\n-}\n-\n-# ifndef __GC\n-// Return a uniquely referenced character slot for the given\n-// position, or 0 if that's not possible.\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_fetch_ptr(_RopeRep* __r, size_type __i)\n-{\n-    _RopeRep* __clrstack[_Rope_constants::_S_max_rope_depth];\n-    size_t __csptr = 0;\n-\n-    for(;;) {\n-      if (__r->_M_ref_count > 1) return 0;\n-      switch(__r->_M_tag) {\n-        case _Rope_constants::_S_concat:\n+  \n+#ifndef __GC\n+  // Return a uniquely referenced character slot for the given\n+  // position, or 0 if that's not possible.\n+  template <class _CharT, class _Alloc>\n+    _CharT*\n+    rope<_CharT, _Alloc>::\n+    _S_fetch_ptr(_RopeRep* __r, size_type __i)\n+    {\n+      _RopeRep* __clrstack[_Rope_constants::_S_max_rope_depth];\n+      size_t __csptr = 0;\n+      \n+      for(;;)\n+\t{\n+\t  if (__r->_M_ref_count > 1)\n+\t    return 0;\n+\t  switch(__r->_M_tag)\n \t    {\n+\t    case _Rope_constants::_S_concat:\n+\t      {\n \t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \t\t_RopeRep* __left = __c->_M_left;\n \t\tsize_t __left_len = __left->_M_size;\n-\n-\t\tif (__c->_M_c_string != 0) __clrstack[__csptr++] = __c;\n-\t\tif (__i >= __left_len) {\n+\t\t\n+\t\tif (__c->_M_c_string != 0)\n+\t\t  __clrstack[__csptr++] = __c;\n+\t\tif (__i >= __left_len)\n+\t\t  {\n \t\t    __i -= __left_len;\n \t\t    __r = __c->_M_right;\n-\t\t} else {\n-\t\t    __r = __left;\n-\t\t}\n-\t    }\n-\t    break;\n-\tcase _Rope_constants::_S_leaf:\n-\t    {\n+\t\t  } \n+\t\telse\n+\t\t  __r = __left;\n+\t      }\n+\t      break;\n+\t    case _Rope_constants::_S_leaf:\n+\t      {\n \t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n \t\tif (__l->_M_c_string != __l->_M_data && __l->_M_c_string != 0)\n-\t\t    __clrstack[__csptr++] = __l;\n-\t\twhile (__csptr > 0) {\n+\t\t  __clrstack[__csptr++] = __l;\n+\t\twhile (__csptr > 0)\n+\t\t  {\n \t\t    -- __csptr;\n \t\t    _RopeRep* __d = __clrstack[__csptr];\n \t\t    __d->_M_free_c_string();\n \t\t    __d->_M_c_string = 0;\n-\t\t}\n+\t\t  }\n \t\treturn __l->_M_data + __i;\n+\t      }\n+\t    case _Rope_constants::_S_function:\n+\t    case _Rope_constants::_S_substringfn:\n+\t      return 0;\n \t    }\n-\tcase _Rope_constants::_S_function:\n-\tcase _Rope_constants::_S_substringfn:\n-\t    return 0;\n-      }\n+\t}\n     }\n-}\n-# endif /* __GC */\n-\n-// The following could be implemented trivially using\n-// lexicographical_compare_3way.\n-// We do a little more work to avoid dealing with rope iterators for\n-// flat strings.\n-template <class _CharT, class _Alloc>\n-int\n-rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left,\n-                                 const _RopeRep* __right)\n-{\n-    size_t __left_len;\n-    size_t __right_len;\n-\n-    if (0 == __right) return 0 != __left;\n-    if (0 == __left) return -1;\n-    __left_len = __left->_M_size;\n-    __right_len = __right->_M_size;\n-    if (_Rope_constants::_S_leaf == __left->_M_tag) {\n-\t_RopeLeaf* __l = (_RopeLeaf*) __left;\n-\tif (_RopeRep::_S_leaf == __right->_M_tag) {\n-\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n-\t    return lexicographical_compare_3way(\n-\t\t\t__l->_M_data, __l->_M_data + __left_len,\n-\t\t\t__r->_M_data, __r->_M_data + __right_len);\n-\t} else {\n-\t    const_iterator __rstart(__right, 0);\n-\t    const_iterator __rend(__right, __right_len);\n-\t    return lexicographical_compare_3way(\n-\t\t\t__l->_M_data, __l->_M_data + __left_len,\n-\t\t\t__rstart, __rend);\n+#endif /* __GC */\n+\n+  // The following could be implemented trivially using\n+  // lexicographical_compare_3way.\n+  // We do a little more work to avoid dealing with rope iterators for\n+  // flat strings.\n+  template <class _CharT, class _Alloc>\n+    int\n+    rope<_CharT, _Alloc>::\n+    _S_compare (const _RopeRep* __left, const _RopeRep* __right)\n+    {\n+      size_t __left_len;\n+      size_t __right_len;\n+      \n+      if (0 == __right)\n+\treturn 0 != __left;\n+      if (0 == __left)\n+\treturn -1;\n+      __left_len = __left->_M_size;\n+      __right_len = __right->_M_size;\n+      if (_Rope_constants::_S_leaf == __left->_M_tag)\n+\t{\n+\t  _RopeLeaf* __l = (_RopeLeaf*) __left;\n+\t  if (_RopeRep::_S_leaf == __right->_M_tag)\n+\t    {\n+\t      _RopeLeaf* __r = (_RopeLeaf*) __right;\n+\t      return lexicographical_compare_3way(__l->_M_data,\n+\t\t\t\t\t\t  __l->_M_data + __left_len,\n+\t\t\t\t\t\t  __r->_M_data, __r->_M_data\n+\t\t\t\t\t\t  + __right_len);\n+\t    }\n+\t  else\n+\t    {\n+\t      const_iterator __rstart(__right, 0);\n+\t      const_iterator __rend(__right, __right_len);\n+\t      return lexicographical_compare_3way(__l->_M_data, __l->_M_data\n+\t\t\t\t\t\t  + __left_len,\n+\t\t\t\t\t\t  __rstart, __rend);\n+\t    }\n \t}\n-    } else {\n-\tconst_iterator __lstart(__left, 0);\n-\tconst_iterator __lend(__left, __left_len);\n-\tif (_Rope_constants::_S_leaf == __right->_M_tag) {\n-\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n-\t    return lexicographical_compare_3way(\n-\t\t\t\t   __lstart, __lend,\n-\t\t\t\t   __r->_M_data, __r->_M_data + __right_len);\n-\t} else {\n-\t    const_iterator __rstart(__right, 0);\n-\t    const_iterator __rend(__right, __right_len);\n-\t    return lexicographical_compare_3way(\n-\t\t\t\t   __lstart, __lend,\n-\t\t\t\t   __rstart, __rend);\n+      else\n+\t{\n+\t  const_iterator __lstart(__left, 0);\n+\t  const_iterator __lend(__left, __left_len);\n+\t  if (_Rope_constants::_S_leaf == __right->_M_tag)\n+\t    {\n+\t      _RopeLeaf* __r = (_RopeLeaf*) __right;\n+\t      return lexicographical_compare_3way(__lstart, __lend,\n+\t\t\t\t\t\t  __r->_M_data, __r->_M_data\n+\t\t\t\t\t\t  + __right_len);\n+\t    }\n+\t  else\n+\t    {\n+\t      const_iterator __rstart(__right, 0);\n+\t      const_iterator __rend(__right, __right_len);\n+\t      return lexicographical_compare_3way(__lstart, __lend,\n+\t\t\t\t\t\t  __rstart, __rend);\n+\t    }\n \t}\n     }\n-}\n-\n-// Assignment to reference proxies.\n-template <class _CharT, class _Alloc>\n-_Rope_char_ref_proxy<_CharT, _Alloc>&\n-_Rope_char_ref_proxy<_CharT, _Alloc>::operator= (_CharT __c) {\n-    _RopeRep* __old = _M_root->_M_tree_ptr;\n-#   ifndef __GC\n-\t// First check for the case in which everything is uniquely\n-\t// referenced.  In that case we can do this destructively.\n-\t_CharT* __ptr = _My_rope::_S_fetch_ptr(__old, _M_pos);\n-\tif (0 != __ptr) {\n-\t    *__ptr = __c;\n-\t    return *this;\n+\n+  // Assignment to reference proxies.\n+  template <class _CharT, class _Alloc>\n+    _Rope_char_ref_proxy<_CharT, _Alloc>&\n+    _Rope_char_ref_proxy<_CharT, _Alloc>::\n+    operator=(_CharT __c)\n+    {\n+      _RopeRep* __old = _M_root->_M_tree_ptr;\n+#ifndef __GC\n+      // First check for the case in which everything is uniquely\n+      // referenced.  In that case we can do this destructively.\n+      _CharT* __ptr = _My_rope::_S_fetch_ptr(__old, _M_pos);\n+      if (0 != __ptr)\n+\t{\n+\t  *__ptr = __c;\n+\t  return *this;\n \t}\n-#   endif\n-    _Self_destruct_ptr __left(\n-      _My_rope::_S_substring(__old, 0, _M_pos));\n-    _Self_destruct_ptr __right(\n-      _My_rope::_S_substring(__old, _M_pos+1, __old->_M_size));\n-    _Self_destruct_ptr __result_left(\n-      _My_rope::_S_destr_concat_char_iter(__left, &__c, 1));\n-\n-    _RopeRep* __result =\n-\t\t_My_rope::_S_concat(__result_left, __right);\n-#   ifndef __GC\n+#endif\n+      _Self_destruct_ptr __left(_My_rope::_S_substring(__old, 0, _M_pos));\n+      _Self_destruct_ptr __right(_My_rope::_S_substring(__old, _M_pos + 1,\n+\t\t\t\t\t\t\t__old->_M_size));\n+      _Self_destruct_ptr __result_left(_My_rope::\n+\t\t\t\t       _S_destr_concat_char_iter(__left,\n+\t\t\t\t\t\t\t\t &__c, 1));\n+\n+      _RopeRep* __result = _My_rope::_S_concat(__result_left, __right);\n+#ifndef __GC\n       _RopeRep::_S_unref(__old);\n-#   endif\n-    _M_root->_M_tree_ptr = __result;\n-    return *this;\n-}\n+#endif\n+      _M_root->_M_tree_ptr = __result;\n+      return *this;\n+    }\n \n-template <class _CharT, class _Alloc>\n-inline _Rope_char_ref_proxy<_CharT, _Alloc>::operator _CharT () const\n-{\n-    if (_M_current_valid) {\n+  template <class _CharT, class _Alloc>\n+    inline _Rope_char_ref_proxy<_CharT, _Alloc>::\n+    operator _CharT() const\n+    {\n+      if (_M_current_valid)\n \treturn _M_current;\n-    } else {\n-        return _My_rope::_S_fetch(_M_root->_M_tree_ptr, _M_pos);\n+      else\n+\treturn _My_rope::_S_fetch(_M_root->_M_tree_ptr, _M_pos);\n     }\n-}\n-template <class _CharT, class _Alloc>\n-_Rope_char_ptr_proxy<_CharT, _Alloc>\n-_Rope_char_ref_proxy<_CharT, _Alloc>::operator& () const {\n-    return _Rope_char_ptr_proxy<_CharT, _Alloc>(*this);\n-}\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n-\t\t\t   const allocator_type& __a)\n-: _Base(__a)\n-{\n-    rope<_CharT,_Alloc> __result;\n-    const size_t __exponentiate_threshold = 32;\n-    size_t __exponent;\n-    size_t __rest;\n-    _CharT* __rest_buffer;\n-    _RopeRep* __remainder;\n-    rope<_CharT,_Alloc> __remainder_rope;\n-\n-    if (0 == __n)\n-      return;\n-\n-    __exponent = __n / __exponentiate_threshold;\n-    __rest = __n % __exponentiate_threshold;\n-    if (0 == __rest) {\n+\n+  template <class _CharT, class _Alloc>\n+    _Rope_char_ptr_proxy<_CharT, _Alloc>\n+    _Rope_char_ref_proxy<_CharT, _Alloc>::\n+    operator&() const\n+    { return _Rope_char_ptr_proxy<_CharT, _Alloc>(*this); }\n+\n+  template <class _CharT, class _Alloc>\n+    rope<_CharT, _Alloc>::\n+    rope(size_t __n, _CharT __c, const allocator_type& __a)\n+    : _Base(__a)\n+    {\n+      rope<_CharT,_Alloc> __result;\n+      const size_t __exponentiate_threshold = 32;\n+      size_t __exponent;\n+      size_t __rest;\n+      _CharT* __rest_buffer;\n+      _RopeRep* __remainder;\n+      rope<_CharT, _Alloc> __remainder_rope;\n+\n+      if (0 == __n)\n+\treturn;\n+\n+      __exponent = __n / __exponentiate_threshold;\n+      __rest = __n % __exponentiate_threshold;\n+      if (0 == __rest)\n \t__remainder = 0;\n-    } else {\n-        __rest_buffer = this->_Data_allocate(_S_rounded_up_size(__rest));\n-\tuninitialized_fill_n(__rest_buffer, __rest, __c);\n-\t_S_cond_store_eos(__rest_buffer[__rest]);\n-\ttry {\n-\t    __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a);\n-        }\n-\tcatch(...)\n-\t  {\n-\t    _RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a);\n-\t    __throw_exception_again;\n-\t  }\n-    }\n-    __remainder_rope._M_tree_ptr = __remainder;\n-    if (__exponent != 0) {\n-\t_CharT* __base_buffer =\n-\t  this->_Data_allocate(_S_rounded_up_size(__exponentiate_threshold));\n-\t_RopeLeaf* __base_leaf;\n-\trope __base_rope;\n-\tuninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n-\t_S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n-\ttry {\n-          __base_leaf = _S_new_RopeLeaf(__base_buffer,\n-                                        __exponentiate_threshold, __a);\n-        }\n-\tcatch(...)\n-\t  {\n-\t    _RopeRep::__STL_FREE_STRING(__base_buffer,\n-\t\t\t\t\t__exponentiate_threshold, __a);\n-\t    __throw_exception_again;\n-\t  }\n-\t__base_rope._M_tree_ptr = __base_leaf;\n-\tif (1 == __exponent) {\n-\t  __result = __base_rope;\n-\t} else {\n-\t  __result = power(__base_rope, __exponent,\n-\t\t\t   _Rope_Concat_fn<_CharT,_Alloc>());\n+      else\n+\t{\n+\t  __rest_buffer = this->_Data_allocate(_S_rounded_up_size(__rest));\n+\t  uninitialized_fill_n(__rest_buffer, __rest, __c);\n+\t  _S_cond_store_eos(__rest_buffer[__rest]);\n+\t  try\n+\t    { __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a); }\n+\t  catch(...)\n+\t    {\n+\t      _RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a);\n+\t      __throw_exception_again;\n+\t    }\n \t}\n-\tif (0 != __remainder) {\n-\t  __result += __remainder_rope;\n+      __remainder_rope._M_tree_ptr = __remainder;\n+      if (__exponent != 0)\n+\t{\n+\t  _CharT* __base_buffer =\n+\t    this->_Data_allocate(_S_rounded_up_size(__exponentiate_threshold));\n+\t  _RopeLeaf* __base_leaf;\n+\t  rope __base_rope;\n+\t  uninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n+\t  _S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n+\t  try\n+\t    {\n+\t      __base_leaf = _S_new_RopeLeaf(__base_buffer,\n+\t\t\t\t\t    __exponentiate_threshold, __a);\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      _RopeRep::__STL_FREE_STRING(__base_buffer,\n+\t\t\t\t\t  __exponentiate_threshold, __a);\n+\t      __throw_exception_again;\n+\t    }\n+\t  __base_rope._M_tree_ptr = __base_leaf;\n+\t  if (1 == __exponent)\n+\t    __result = __base_rope;\n+\t  else\n+\t    __result = power(__base_rope, __exponent,\n+\t\t\t     _Rope_Concat_fn<_CharT, _Alloc>());\n+\t    \n+\t  if (0 != __remainder)\n+\t    __result += __remainder_rope;\n \t}\n-    } else {\n+      else\n \t__result = __remainder_rope;\n+\t  \n+      this->_M_tree_ptr = __result._M_tree_ptr;\n+      this->_M_tree_ptr->_M_ref_nonnil();\n     }\n-    this->_M_tree_ptr = __result._M_tree_ptr;\n-    this->_M_tree_ptr->_M_ref_nonnil();\n-}\n-\n-template<class _CharT, class _Alloc>\n-  _CharT rope<_CharT,_Alloc>::_S_empty_c_str[1];\n-\n-template<class _CharT, class _Alloc>\n-const _CharT* rope<_CharT,_Alloc>::c_str() const {\n-    if (0 == this->_M_tree_ptr) {\n-        _S_empty_c_str[0] = _S_eos((_CharT*)0);  // Possibly redundant,\n-\t\t\t\t\t     // but probably fast.\n-        return _S_empty_c_str;\n-    }\n-    __gthread_mutex_lock (&this->_M_tree_ptr->_M_c_string_lock);\n-    __GC_CONST _CharT* __result = this->_M_tree_ptr->_M_c_string;\n-    if (0 == __result)\n-      {\n-\tsize_t __s = size();\n-\t__result = this->_Data_allocate(__s + 1);\n-\t_S_flatten(this->_M_tree_ptr, __result);\n-\t__result[__s] = _S_eos((_CharT*)0);\n-\tthis->_M_tree_ptr->_M_c_string = __result;\n-      }\n-    __gthread_mutex_unlock (&this->_M_tree_ptr->_M_c_string_lock);\n-    return(__result);\n-}\n-\n-template<class _CharT, class _Alloc>\n-const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {\n-    if (0 == this->_M_tree_ptr) {\n-        _S_empty_c_str[0] = _S_eos((_CharT*)0);\n-        return _S_empty_c_str;\n+      \n+  template<class _CharT, class _Alloc>\n+    _CharT\n+    rope<_CharT, _Alloc>::_S_empty_c_str[1];\n+      \n+  template<class _CharT, class _Alloc>\n+    const _CharT*\n+    rope<_CharT, _Alloc>::\n+    c_str() const\n+    {\n+      if (0 == this->_M_tree_ptr)\n+\t{\n+\t  _S_empty_c_str[0] = _S_eos((_CharT*)0);  // Possibly redundant,\n+\t                                           // but probably fast.\n+\t  return _S_empty_c_str;\n+\t}\n+      __gthread_mutex_lock (&this->_M_tree_ptr->_M_c_string_lock);\n+      __GC_CONST _CharT* __result = this->_M_tree_ptr->_M_c_string;\n+      if (0 == __result)\n+\t{\n+\t  size_t __s = size();\n+\t  __result = this->_Data_allocate(__s + 1);\n+\t  _S_flatten(this->_M_tree_ptr, __result);\n+\t  __result[__s] = _S_eos((_CharT*)0);\n+\t  this->_M_tree_ptr->_M_c_string = __result;\n+\t}\n+      __gthread_mutex_unlock (&this->_M_tree_ptr->_M_c_string_lock);\n+      return(__result);\n     }\n-    __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n-    if (_Rope_constants::_S_leaf == this->_M_tree_ptr->_M_tag\n-\t&& 0 != __old_c_string) {\n+  \n+  template<class _CharT, class _Alloc>\n+    const _CharT* rope<_CharT, _Alloc>::\n+    replace_with_c_str()\n+    {\n+      if (0 == this->_M_tree_ptr)\n+\t{\n+\t  _S_empty_c_str[0] = _S_eos((_CharT*)0);\n+\t  return _S_empty_c_str;\n+\t}\n+      __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n+      if (_Rope_constants::_S_leaf == this->_M_tree_ptr->_M_tag\n+\t  && 0 != __old_c_string)\n \treturn(__old_c_string);\n+      size_t __s = size();\n+      _CharT* __result = this->_Data_allocate(_S_rounded_up_size(__s));\n+      _S_flatten(this->_M_tree_ptr, __result);\n+      __result[__s] = _S_eos((_CharT*)0);\n+      this->_M_tree_ptr->_M_unref_nonnil();\n+      this->_M_tree_ptr = _S_new_RopeLeaf(__result, __s,\n+\t\t\t\t\t  this->get_allocator());\n+      return(__result);\n+    }\n+\n+  // Algorithm specializations.  More should be added.\n+  \n+  template<class _Rope_iterator>  // was templated on CharT and Alloc\n+    void\t\t          // VC++ workaround\n+    _Rope_rotate(_Rope_iterator __first,\n+\t\t _Rope_iterator __middle,\n+\t\t _Rope_iterator __last)\n+    {\n+      typedef typename _Rope_iterator::value_type _CharT;\n+      typedef typename _Rope_iterator::_allocator_type _Alloc;\n+      \n+      rope<_CharT, _Alloc>& __r(__first.container());\n+      rope<_CharT, _Alloc> __prefix = __r.substr(0, __first.index());\n+      rope<_CharT, _Alloc> __suffix =\n+\t__r.substr(__last.index(), __r.size() - __last.index());\n+      rope<_CharT, _Alloc> __part1 =\n+\t__r.substr(__middle.index(), __last.index() - __middle.index());\n+      rope<_CharT, _Alloc> __part2 =\n+\t__r.substr(__first.index(), __middle.index() - __first.index());\n+      __r = __prefix;\n+      __r += __part1;\n+      __r += __part2;\n+      __r += __suffix;\n     }\n-    size_t __s = size();\n-    _CharT* __result = this->_Data_allocate(_S_rounded_up_size(__s));\n-    _S_flatten(this->_M_tree_ptr, __result);\n-    __result[__s] = _S_eos((_CharT*)0);\n-    this->_M_tree_ptr->_M_unref_nonnil();\n-    this->_M_tree_ptr = _S_new_RopeLeaf(__result, __s, this->get_allocator());\n-    return(__result);\n-}\n-\n-// Algorithm specializations.  More should be added.\n-\n-template<class _Rope_iterator>  // was templated on CharT and Alloc\n-void\t\t\t\t// VC++ workaround\n-_Rope_rotate(_Rope_iterator __first,\n-             _Rope_iterator __middle,\n-             _Rope_iterator __last)\n-{\n-  typedef typename _Rope_iterator::value_type _CharT;\n-  typedef typename _Rope_iterator::_allocator_type _Alloc;\n-\n-  rope<_CharT,_Alloc>& __r(__first.container());\n-  rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n-  rope<_CharT,_Alloc> __suffix =\n-    __r.substr(__last.index(), __r.size() - __last.index());\n-  rope<_CharT,_Alloc> __part1 =\n-    __r.substr(__middle.index(), __last.index() - __middle.index());\n-  rope<_CharT,_Alloc> __part2 =\n-    __r.substr(__first.index(), __middle.index() - __first.index());\n-  __r = __prefix;\n-  __r += __part1;\n-  __r += __part2;\n-  __r += __suffix;\n-}\n \n #if !defined(__GNUC__)\n-// Appears to confuse g++\n-inline void rotate(_Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __first,\n-                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n-                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n-    _Rope_rotate(__first, __middle, __last);\n-}\n+  // Appears to confuse g++\n+  inline void\n+  rotate(_Rope_iterator<char, __STL_DEFAULT_ALLOCATOR(char)> __first,\n+\t _Rope_iterator<char, __STL_DEFAULT_ALLOCATOR(char)> __middle,\n+\t _Rope_iterator<char, __STL_DEFAULT_ALLOCATOR(char)> __last)\n+  { _Rope_rotate(__first, __middle, __last); }\n #endif\n \n # if 0\n-// Probably not useful for several reasons:\n-// - for SGIs 7.1 compiler and probably some others,\n-//   this forces lots of rope<wchar_t, ...> instantiations, creating a\n-//   code bloat and compile time problem.  (Fixed in 7.2.)\n-// - wchar_t is 4 bytes wide on most UNIX platforms, making it unattractive\n-//   for unicode strings.  Unsigned short may be a better character\n-//   type.\n-inline void rotate(\n-\t\t_Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __first,\n-                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n-                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n-    _Rope_rotate(__first, __middle, __last);\n-}\n+  // Probably not useful for several reasons:\n+  // - for SGIs 7.1 compiler and probably some others,\n+  //   this forces lots of rope<wchar_t, ...> instantiations, creating a\n+  //   code bloat and compile time problem.  (Fixed in 7.2.)\n+  // - wchar_t is 4 bytes wide on most UNIX platforms, making it\n+  //   unattractive for unicode strings.  Unsigned short may be a better\n+  //   character type.\n+  inline void\n+  rotate(_Rope_iterator<wchar_t, __STL_DEFAULT_ALLOCATOR(char)> __first,\n+\t _Rope_iterator<wchar_t, __STL_DEFAULT_ALLOCATOR(char)> __middle,\n+\t _Rope_iterator<wchar_t, __STL_DEFAULT_ALLOCATOR(char)> __last)\n+  { _Rope_rotate(__first, __middle, __last); }\n # endif\n \n } // namespace __gnu_cxx"}]}