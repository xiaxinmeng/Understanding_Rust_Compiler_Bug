{"sha": "6d4d7b0eed1846e13f5dd75765696b2b6854af44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0ZDdiMGVlZDE4NDZlMTNmNWRkNzU3NjU2OTZiMmI2ODU0YWY0NA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-08-17T07:02:55Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-08-17T07:02:55Z"}, "message": "[multiple changes]\n\n2006-08-17  Paolo Bonzini <bonzini@gnu.org>\n\n\tPR c++/28573\n\t* c-common.c (fold_offsetof_1): Add an argument and recurse down to it\n\tor the INTEGER_CST.  Fail on a CALL_EXPR. \n\t(fold_offsetof): Pass new argument to fold_offsetof_1.\n\t* c-parser.c (c_parser_postfix_expression): Don't include a NULL\n\toperand into an INDIRECT_REF. \n\t* c-typeck.c (build_unary_op): Adjust call to fold_offsetof.\n\ncp:\n2006-08-17  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR c++/28573\n\t* semantics.c (finish_offsetof): Add new argument to fold_offsetof.\n\ntestsuite:\n2006-08-17  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR c++/28573\n\t* g++.dg/parse/offsetof6.C: New test.\n\t* g++.dg/parse/offsetof7.C: New test.\n\nFrom-SVN: r116208", "tree": {"sha": "a00c91d8a45badf842fef53d1a9a8662c9f6f24b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a00c91d8a45badf842fef53d1a9a8662c9f6f24b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d4d7b0eed1846e13f5dd75765696b2b6854af44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4d7b0eed1846e13f5dd75765696b2b6854af44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4d7b0eed1846e13f5dd75765696b2b6854af44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4d7b0eed1846e13f5dd75765696b2b6854af44/comments", "author": null, "committer": null, "parents": [{"sha": "e98a430b854487d164b042b9a1ab0cb6dba0ca25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98a430b854487d164b042b9a1ab0cb6dba0ca25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98a430b854487d164b042b9a1ab0cb6dba0ca25"}], "stats": {"total": 105, "additions": 89, "deletions": 16}, "files": [{"sha": "d2bc8c54cd004eccdfa42fb29eb8c5a3c456b5c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -1,3 +1,13 @@\n+2006-08-17  Paolo Bonzini <bonzini@gnu.org>\n+\n+\tPR c++/28573\n+\t* c-common.c (fold_offsetof_1): Add an argument and recurse down to it\n+\tor the INTEGER_CST.  Fail on a CALL_EXPR. \n+\t(fold_offsetof): Pass new argument to fold_offsetof_1.\n+\t* c-parser.c (c_parser_postfix_expression): Don't include a NULL\n+\toperand into an INDIRECT_REF. \n+\t* c-typeck.c (build_unary_op): Adjust call to fold_offsetof.\n+\n 2006-08-16  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR gcov/profile/26570"}, {"sha": "17643f0b5abc5dcd930e0411f174e10613f0da98", "filename": "gcc/c-common.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -5982,16 +5982,19 @@ c_common_to_target_charset (HOST_WIDE_INT c)\n }\n \n /* Build the result of __builtin_offsetof.  EXPR is a nested sequence of\n-   component references, with an INDIRECT_REF at the bottom; much like\n-   the traditional rendering of offsetof as a macro.  Returns the folded\n-   and properly cast result.  */\n+   component references, with STOP_REF, or alternatively an INDIRECT_REF of\n+   NULL, at the bottom; much like the traditional rendering of offsetof as a\n+   macro.  Returns the folded and properly cast result.  */\n \n static tree\n-fold_offsetof_1 (tree expr)\n+fold_offsetof_1 (tree expr, tree stop_ref)\n {\n   enum tree_code code = PLUS_EXPR;\n   tree base, off, t;\n \n+  if (expr == stop_ref && TREE_CODE (expr) != ERROR_MARK)\n+    return size_zero_node;\n+\n   switch (TREE_CODE (expr))\n     {\n     case ERROR_MARK:\n@@ -6001,11 +6004,22 @@ fold_offsetof_1 (tree expr)\n       error (\"cannot apply %<offsetof%> to static data member %qD\", expr);\n       return error_mark_node;\n \n-    case INDIRECT_REF:\n+    case CALL_EXPR:\n+      error (\"cannot apply %<offsetof%> when %<operator[]%> is overloaded\");\n+      return error_mark_node;\n+\n+    case INTEGER_CST:\n+      gcc_assert (integer_zerop (expr));\n       return size_zero_node;\n \n+    case NOP_EXPR:\n+    case INDIRECT_REF:\n+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);\n+      gcc_assert (base == error_mark_node || base == size_zero_node);\n+      return base;\n+\n     case COMPONENT_REF:\n-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));\n+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);\n       if (base == error_mark_node)\n \treturn base;\n \n@@ -6022,7 +6036,7 @@ fold_offsetof_1 (tree expr)\n       break;\n \n     case ARRAY_REF:\n-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));\n+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);\n       if (base == error_mark_node)\n \treturn base;\n \n@@ -6044,10 +6058,10 @@ fold_offsetof_1 (tree expr)\n }\n \n tree\n-fold_offsetof (tree expr)\n+fold_offsetof (tree expr, tree stop_ref)\n {\n   /* Convert back from the internal sizetype to size_t.  */\n-  return convert (size_type_node, fold_offsetof_1 (expr));\n+  return convert (size_type_node, fold_offsetof_1 (expr, stop_ref));\n }\n \n /* Print an error message for an invalid lvalue.  USE says"}, {"sha": "633990a3a35bc47c409db4f81d135413f063bab1", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -830,7 +830,7 @@ extern void c_warn_unused_result (tree *);\n \n extern void verify_sequence_points (tree);\n \n-extern tree fold_offsetof (tree);\n+extern tree fold_offsetof (tree, tree);\n \n /* Places where an lvalue, or modifiable lvalue, may be required.\n    Used to select diagnostic messages in lvalue_error and"}, {"sha": "9031e5b4d2f2aba953f4172f682c4bf4e9100d70", "filename": "gcc/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -5203,7 +5203,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t    if (type == error_mark_node)\n \t      offsetof_ref = error_mark_node;\n \t    else\n-\t      offsetof_ref = build1 (INDIRECT_REF, type, NULL);\n+\t      offsetof_ref = build1 (INDIRECT_REF, type, null_pointer_node);\n \t    /* Parse the second argument to __builtin_offsetof.  We\n \t       must have one identifier, and beyond that we want to\n \t       accept sub structure and sub array references.  */\n@@ -5245,7 +5245,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t      c_parser_error (parser, \"expected identifier\");\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n-\t    expr.value = fold_offsetof (offsetof_ref);\n+\t    expr.value = fold_offsetof (offsetof_ref, NULL_TREE);\n \t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;"}, {"sha": "c55bcad89c98b37b836040f8169411cc62fa4ed9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -3057,7 +3057,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       if (val && TREE_CODE (val) == INDIRECT_REF\n           && TREE_CONSTANT (TREE_OPERAND (val, 0)))\n \t{\n-\t  tree op0 = fold_convert (argtype, fold_offsetof (arg)), op1;\n+\t  tree op0 = fold_convert (argtype, fold_offsetof (arg, val)), op1;\n \n \t  op1 = fold_convert (argtype, TREE_OPERAND (val, 0));\n \t  return fold_build2 (PLUS_EXPR, argtype, op0, op1);"}, {"sha": "7048c5f1411ecdf70bbcb6d613ac23c774abb8ba", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -1,8 +1,13 @@\n+2006-08-17  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c++/28573\n+\t* semantics.c (finish_offsetof): Add new argument to fold_offsetof.\n+\n 2006-08-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/28302\n \t* typeck.c (build_unary_op <case BIT_NOT_EXPR:>): Don't call\n-\tperform_integral_promotions for non integral type\n+\tperform_integral_promotions for non integral type.\n \n 2006-08-16  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "fb4ea0a79dfa5efe928ad41083026c1bfa9d1339", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -2904,7 +2904,7 @@ finish_offsetof (tree expr)\n       error (\"cannot apply %<offsetof%> to member function %qD\", expr);\n       return error_mark_node;\n     }\n-  return fold_offsetof (expr);\n+  return fold_offsetof (expr, NULL_TREE);\n }\n \n /* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs"}, {"sha": "624a2f23d73efa61cd5d4036acb77f3d38344840", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -1,3 +1,10 @@\n+2006-08-17  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* PR c++/28573\n+\t* g++.dg/parse/offsetof6.C: New test.\n+\t* g++.dg/parse/offsetof6.C: New test.\n+\t* g++.dg/parse/offsetof7.C: New test.\n+\n 2006-08-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR testsuite/28602\n@@ -6,7 +13,7 @@\n \n 2006-08-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n-\tPR C++/28302\n+\tPR c++/28302\n \t* g++.dg/ext/vector3.C: New test.\n \n 2006-08-16  Zdenek Dvorak  <dvorakz@suse.cz>"}, {"sha": "0e07a538009c05aa641421f7caade6ef1850304c", "filename": "gcc/testsuite/g++.dg/parse/offsetof6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof6.C?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+// From PR28573\n+\n+struct A\n+{\n+  char d[44];\n+  char &operator [] ( int indx ) { return d[indx]; }\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+int main()\n+{\n+  return __builtin_offsetof(B, a[0]); /* { dg-error \"cannot apply.*offsetof\" } */\n+}"}, {"sha": "113a7954726d74ff534169c34375598d22db25df", "filename": "gcc/testsuite/g++.dg/parse/offsetof7.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4d7b0eed1846e13f5dd75765696b2b6854af44/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foffsetof7.C?ref=6d4d7b0eed1846e13f5dd75765696b2b6854af44", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+// From PR28573\n+\n+struct A\n+{\n+   int operator [] ( int indx ) { return indx; }\n+};\n+\n+struct B\n+{\n+   A a;\n+};\n+\n+int main()\n+{\n+   return __builtin_offsetof(B, a[0]);  /* { dg-error \"cannot apply.*offsetof\" } */\n+}"}]}