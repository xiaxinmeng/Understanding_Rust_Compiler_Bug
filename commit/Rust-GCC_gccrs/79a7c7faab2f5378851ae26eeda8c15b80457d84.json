{"sha": "79a7c7faab2f5378851ae26eeda8c15b80457d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhN2M3ZmFhYjJmNTM3ODg1MWFlMjZlZWRhOGMxNWI4MDQ1N2Q4NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-07T10:01:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-07T10:01:16Z"}, "message": "[multiple changes]\n\nSun Dec  7 01:46:33 1997  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n\n\t* typeck.c (build_binary_op_nodefault, pointer_diff): Symmetric\n\thandling of pointer difference expressions.\n\n\t* typeck.c (comp_target_types): Comparison of function/method types\n\tis independent of nptrs.\n\nSun Dec  7 01:40:27 1997  Mark Mitchell  <mmitchell@usa.net>\n\n\t* pt.c (tsubst): Avoid creating pointer to reference and\n\treference to reference types.\n\nFrom-SVN: r16990", "tree": {"sha": "7952d2f60c05bc3b21240ad15c2ec342694eb12f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7952d2f60c05bc3b21240ad15c2ec342694eb12f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a7c7faab2f5378851ae26eeda8c15b80457d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a7c7faab2f5378851ae26eeda8c15b80457d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a7c7faab2f5378851ae26eeda8c15b80457d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a7c7faab2f5378851ae26eeda8c15b80457d84/comments", "author": null, "committer": null, "parents": [{"sha": "16169366274f7a28a78f0a5f09481b47537ee529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16169366274f7a28a78f0a5f09481b47537ee529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16169366274f7a28a78f0a5f09481b47537ee529"}], "stats": {"total": 66, "additions": 55, "deletions": 11}, "files": [{"sha": "2d01038dfcba2f56ddd57c3fb09edb4187165d81", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79a7c7faab2f5378851ae26eeda8c15b80457d84", "patch": "@@ -1,3 +1,16 @@\n+Sun Dec  7 01:46:33 1997  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n+\n+\t* typeck.c (build_binary_op_nodefault, pointer_diff): Symmetric\n+\thandling of pointer difference expressions.\n+\n+\t* typeck.c (comp_target_types): Comparison of function/method types\n+\tis independent of nptrs.\n+\n+Sun Dec  7 01:40:27 1997  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* pt.c (tsubst): Avoid creating pointer to reference and\n+\treference to reference types.\n+\n Sat Dec  6 01:29:37 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* parse.y (do_id): New nonterminal."}, {"sha": "ec581d5873786c5579b1142f2e77d1b1308965e9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=79a7c7faab2f5378851ae26eeda8c15b80457d84", "patch": "@@ -2675,15 +2675,43 @@ tsubst (t, args, nargs, in_decl)\n       {\n \ttree r;\n \tenum tree_code code;\n+\n \tif (type == TREE_TYPE (t))\n \t  return t;\n \n \tcode = TREE_CODE (t);\n-\tif (code == POINTER_TYPE)\n+\tif (TREE_CODE (type) == REFERENCE_TYPE) \n+\t  {\n+\t    static int   last_line = 0;\n+\t    static char* last_file = 0;\n+\n+\t    /* We keep track of the last time we issued this error\n+\t       message to avoid spewing a ton of messages during a\n+\t       single bad template instantiation.  */\n+\t    if (last_line != lineno ||\n+\t\tlast_file != input_filename)\n+\t      {\n+\t\tcp_error (\"cannot form type %s to reference type %T during template instantiation\",\n+\t\t\t  (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n+\t\t\t  type);\n+\t\tlast_line = lineno;\n+\t\tlast_file = input_filename;\n+\t      }\n+\n+\t    /* Use the underlying type in an attempt at error\n+\t       recovery; maybe the user meant vector<int> and wrote\n+\t       vector<int&>, or some such.  */\n+\t    if (code == REFERENCE_TYPE)\n+\t      r = type;\n+\t    else\n+\t      r = build_pointer_type (TREE_TYPE (type));\n+\t  }\n+\telse if (code == POINTER_TYPE)\n \t  r = build_pointer_type (type);\n \telse\n \t  r = build_reference_type (type);\n \tr = cp_build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+\n \t/* Will this ever be needed for TYPE_..._TO values?  */\n \tlayout_type (r);\n \treturn r;"}, {"sha": "2739333e5338490a21acdfc2bf86f49752f7eade", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a7c7faab2f5378851ae26eeda8c15b80457d84/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=79a7c7faab2f5378851ae26eeda8c15b80457d84", "patch": "@@ -58,7 +58,7 @@ static tree build_ptrmemfunc1 PROTO((tree, tree, tree, tree, tree));\n static tree common_base_type PROTO((tree, tree));\n static tree convert_sequence PROTO((tree, tree));\n static tree lookup_anon_field PROTO((tree, tree));\n-static tree pointer_diff PROTO((tree, tree));\n+static tree pointer_diff PROTO((tree, tree, tree));\n static tree qualify_type PROTO((tree, tree));\n static tree expand_target_expr PROTO((tree));\n static tree get_delta_difference PROTO((tree, tree, int));\n@@ -647,9 +647,9 @@ comp_array_types (cmp, t1, t2, strict)\n \t0 : <= (compared according to C++)\n \t-1: <= or >= (relaxed)\n \n-   Otherwise, pointers involving base classes and derived classes\n-   can be mixed as valid: i.e. a pointer to a base class may be assigned\n-   to a pointer to one of its derived classes, as per C++. A pointer to\n+   Otherwise, pointers involving base classes and derived classes can\n+   be mixed as valid: i.e. a pointer to a derived class may be converted\n+   to a pointer to one of its base classes, as per C++. A pointer to\n    a derived class may be passed as a parameter to a function expecting a\n    pointer to a base classes. These allowances do not commute. In this\n    case, TYPE1 is assumed to be the base class, and TYPE2 is assumed to\n@@ -848,8 +848,10 @@ comptypes (type1, type2, strict)\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n \n-/* Return 1 if TTL and TTR are pointers to types that are equivalent,\n-   ignoring their qualifiers.\n+/* Return 1 or -1 if TTL and TTR are pointers to types that are equivalent,\n+   ignoring their qualifiers, 0 if not. Return 1 means that TTR can be\n+   converted to TTL. Return -1 means that TTL can be converted to TTR but\n+   not vice versa.\n \n    NPTRS is the number of pointers we can strip off and keep cool.\n    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,\n@@ -930,7 +932,7 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n-    if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n+    if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n       switch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 1))\n \t{\n \tcase 0:\n@@ -3196,7 +3198,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n \t  && comp_target_types (type0, type1, 1))\n-\treturn pointer_diff (op0, op1);\n+\treturn pointer_diff (op0, op1, common_type (type0, type1));\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \treturn pointer_int_sum (MINUS_EXPR, op0, op1);\n@@ -3956,12 +3958,13 @@ pointer_int_sum (resultcode, ptrop, intop)\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (op0, op1)\n+pointer_diff (op0, op1, ptrtype)\n      register tree op0, op1;\n+     register tree ptrtype;\n {\n   register tree result, folded;\n   tree restype = ptrdiff_type_node;\n-  tree target_type = TREE_TYPE (TREE_TYPE (op0));\n+  tree target_type = TREE_TYPE (ptrtype);\n \n   if (pedantic || warn_pointer_arith)\n     {"}]}